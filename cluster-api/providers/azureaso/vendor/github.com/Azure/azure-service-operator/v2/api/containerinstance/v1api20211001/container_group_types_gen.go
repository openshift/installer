// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20211001

import (
	"fmt"
	arm "github.com/Azure/azure-service-operator/v2/api/containerinstance/v1api20211001/arm"
	storage "github.com/Azure/azure-service-operator/v2/api/containerinstance/v1api20211001/storage"
	"github.com/Azure/azure-service-operator/v2/internal/reflecthelpers"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/configmaps"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/core"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/secrets"
	"github.com/pkg/errors"
	"k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
	"sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Generator information:
// - Generated from: /containerinstance/resource-manager/Microsoft.ContainerInstance/stable/2021-10-01/containerInstance.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerInstance/containerGroups/{containerGroupName}
type ContainerGroup struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ContainerGroup_Spec   `json:"spec,omitempty"`
	Status            ContainerGroup_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &ContainerGroup{}

// GetConditions returns the conditions of the resource
func (group *ContainerGroup) GetConditions() conditions.Conditions {
	return group.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (group *ContainerGroup) SetConditions(conditions conditions.Conditions) {
	group.Status.Conditions = conditions
}

var _ conversion.Convertible = &ContainerGroup{}

// ConvertFrom populates our ContainerGroup from the provided hub ContainerGroup
func (group *ContainerGroup) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*storage.ContainerGroup)
	if !ok {
		return fmt.Errorf("expected containerinstance/v1api20211001/storage/ContainerGroup but received %T instead", hub)
	}

	return group.AssignProperties_From_ContainerGroup(source)
}

// ConvertTo populates the provided hub ContainerGroup from our ContainerGroup
func (group *ContainerGroup) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*storage.ContainerGroup)
	if !ok {
		return fmt.Errorf("expected containerinstance/v1api20211001/storage/ContainerGroup but received %T instead", hub)
	}

	return group.AssignProperties_To_ContainerGroup(destination)
}

// +kubebuilder:webhook:path=/mutate-containerinstance-azure-com-v1api20211001-containergroup,mutating=true,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=containerinstance.azure.com,resources=containergroups,verbs=create;update,versions=v1api20211001,name=default.v1api20211001.containergroups.containerinstance.azure.com,admissionReviewVersions=v1

var _ admission.Defaulter = &ContainerGroup{}

// Default applies defaults to the ContainerGroup resource
func (group *ContainerGroup) Default() {
	group.defaultImpl()
	var temp any = group
	if runtimeDefaulter, ok := temp.(genruntime.Defaulter); ok {
		runtimeDefaulter.CustomDefault()
	}
}

// defaultAzureName defaults the Azure name of the resource to the Kubernetes name
func (group *ContainerGroup) defaultAzureName() {
	if group.Spec.AzureName == "" {
		group.Spec.AzureName = group.Name
	}
}

// defaultImpl applies the code generated defaults to the ContainerGroup resource
func (group *ContainerGroup) defaultImpl() { group.defaultAzureName() }

var _ configmaps.Exporter = &ContainerGroup{}

// ConfigMapDestinationExpressions returns the Spec.OperatorSpec.ConfigMapExpressions property
func (group *ContainerGroup) ConfigMapDestinationExpressions() []*core.DestinationExpression {
	if group.Spec.OperatorSpec == nil {
		return nil
	}
	return group.Spec.OperatorSpec.ConfigMapExpressions
}

var _ secrets.Exporter = &ContainerGroup{}

// SecretDestinationExpressions returns the Spec.OperatorSpec.SecretExpressions property
func (group *ContainerGroup) SecretDestinationExpressions() []*core.DestinationExpression {
	if group.Spec.OperatorSpec == nil {
		return nil
	}
	return group.Spec.OperatorSpec.SecretExpressions
}

var _ genruntime.ImportableResource = &ContainerGroup{}

// InitializeSpec initializes the spec for this resource from the given status
func (group *ContainerGroup) InitializeSpec(status genruntime.ConvertibleStatus) error {
	if s, ok := status.(*ContainerGroup_STATUS); ok {
		return group.Spec.Initialize_From_ContainerGroup_STATUS(s)
	}

	return fmt.Errorf("expected Status of type ContainerGroup_STATUS but received %T instead", status)
}

var _ genruntime.KubernetesResource = &ContainerGroup{}

// AzureName returns the Azure name of the resource
func (group *ContainerGroup) AzureName() string {
	return group.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2021-10-01"
func (group ContainerGroup) GetAPIVersion() string {
	return "2021-10-01"
}

// GetResourceScope returns the scope of the resource
func (group *ContainerGroup) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (group *ContainerGroup) GetSpec() genruntime.ConvertibleSpec {
	return &group.Spec
}

// GetStatus returns the status of this resource
func (group *ContainerGroup) GetStatus() genruntime.ConvertibleStatus {
	return &group.Status
}

// GetSupportedOperations returns the operations supported by the resource
func (group *ContainerGroup) GetSupportedOperations() []genruntime.ResourceOperation {
	return []genruntime.ResourceOperation{
		genruntime.ResourceOperationDelete,
		genruntime.ResourceOperationGet,
		genruntime.ResourceOperationPut,
	}
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.ContainerInstance/containerGroups"
func (group *ContainerGroup) GetType() string {
	return "Microsoft.ContainerInstance/containerGroups"
}

// NewEmptyStatus returns a new empty (blank) status
func (group *ContainerGroup) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &ContainerGroup_STATUS{}
}

// Owner returns the ResourceReference of the owner
func (group *ContainerGroup) Owner() *genruntime.ResourceReference {
	ownerGroup, ownerKind := genruntime.LookupOwnerGroupKind(group.Spec)
	return group.Spec.Owner.AsResourceReference(ownerGroup, ownerKind)
}

// SetStatus sets the status of this resource
func (group *ContainerGroup) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*ContainerGroup_STATUS); ok {
		group.Status = *st
		return nil
	}

	// Convert status to required version
	var st ContainerGroup_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return errors.Wrap(err, "failed to convert status")
	}

	group.Status = st
	return nil
}

// +kubebuilder:webhook:path=/validate-containerinstance-azure-com-v1api20211001-containergroup,mutating=false,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=containerinstance.azure.com,resources=containergroups,verbs=create;update,versions=v1api20211001,name=validate.v1api20211001.containergroups.containerinstance.azure.com,admissionReviewVersions=v1

var _ admission.Validator = &ContainerGroup{}

// ValidateCreate validates the creation of the resource
func (group *ContainerGroup) ValidateCreate() (admission.Warnings, error) {
	validations := group.createValidations()
	var temp any = group
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.CreateValidations()...)
	}
	return genruntime.ValidateCreate(validations)
}

// ValidateDelete validates the deletion of the resource
func (group *ContainerGroup) ValidateDelete() (admission.Warnings, error) {
	validations := group.deleteValidations()
	var temp any = group
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.DeleteValidations()...)
	}
	return genruntime.ValidateDelete(validations)
}

// ValidateUpdate validates an update of the resource
func (group *ContainerGroup) ValidateUpdate(old runtime.Object) (admission.Warnings, error) {
	validations := group.updateValidations()
	var temp any = group
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.UpdateValidations()...)
	}
	return genruntime.ValidateUpdate(old, validations)
}

// createValidations validates the creation of the resource
func (group *ContainerGroup) createValidations() []func() (admission.Warnings, error) {
	return []func() (admission.Warnings, error){group.validateResourceReferences, group.validateOwnerReference, group.validateSecretDestinations, group.validateConfigMapDestinations}
}

// deleteValidations validates the deletion of the resource
func (group *ContainerGroup) deleteValidations() []func() (admission.Warnings, error) {
	return nil
}

// updateValidations validates the update of the resource
func (group *ContainerGroup) updateValidations() []func(old runtime.Object) (admission.Warnings, error) {
	return []func(old runtime.Object) (admission.Warnings, error){
		func(old runtime.Object) (admission.Warnings, error) {
			return group.validateResourceReferences()
		},
		group.validateWriteOnceProperties,
		func(old runtime.Object) (admission.Warnings, error) {
			return group.validateOwnerReference()
		},
		func(old runtime.Object) (admission.Warnings, error) {
			return group.validateSecretDestinations()
		},
		func(old runtime.Object) (admission.Warnings, error) {
			return group.validateConfigMapDestinations()
		},
	}
}

// validateConfigMapDestinations validates there are no colliding genruntime.ConfigMapDestinations
func (group *ContainerGroup) validateConfigMapDestinations() (admission.Warnings, error) {
	if group.Spec.OperatorSpec == nil {
		return nil, nil
	}
	return configmaps.ValidateDestinations(group, nil, group.Spec.OperatorSpec.ConfigMapExpressions)
}

// validateOwnerReference validates the owner field
func (group *ContainerGroup) validateOwnerReference() (admission.Warnings, error) {
	return genruntime.ValidateOwner(group)
}

// validateResourceReferences validates all resource references
func (group *ContainerGroup) validateResourceReferences() (admission.Warnings, error) {
	refs, err := reflecthelpers.FindResourceReferences(&group.Spec)
	if err != nil {
		return nil, err
	}
	return genruntime.ValidateResourceReferences(refs)
}

// validateSecretDestinations validates there are no colliding genruntime.SecretDestination's
func (group *ContainerGroup) validateSecretDestinations() (admission.Warnings, error) {
	if group.Spec.OperatorSpec == nil {
		return nil, nil
	}
	return secrets.ValidateDestinations(group, nil, group.Spec.OperatorSpec.SecretExpressions)
}

// validateWriteOnceProperties validates all WriteOnce properties
func (group *ContainerGroup) validateWriteOnceProperties(old runtime.Object) (admission.Warnings, error) {
	oldObj, ok := old.(*ContainerGroup)
	if !ok {
		return nil, nil
	}

	return genruntime.ValidateWriteOnceProperties(oldObj, group)
}

// AssignProperties_From_ContainerGroup populates our ContainerGroup from the provided source ContainerGroup
func (group *ContainerGroup) AssignProperties_From_ContainerGroup(source *storage.ContainerGroup) error {

	// ObjectMeta
	group.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec ContainerGroup_Spec
	err := spec.AssignProperties_From_ContainerGroup_Spec(&source.Spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_ContainerGroup_Spec() to populate field Spec")
	}
	group.Spec = spec

	// Status
	var status ContainerGroup_STATUS
	err = status.AssignProperties_From_ContainerGroup_STATUS(&source.Status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_ContainerGroup_STATUS() to populate field Status")
	}
	group.Status = status

	// No error
	return nil
}

// AssignProperties_To_ContainerGroup populates the provided destination ContainerGroup from our ContainerGroup
func (group *ContainerGroup) AssignProperties_To_ContainerGroup(destination *storage.ContainerGroup) error {

	// ObjectMeta
	destination.ObjectMeta = *group.ObjectMeta.DeepCopy()

	// Spec
	var spec storage.ContainerGroup_Spec
	err := group.Spec.AssignProperties_To_ContainerGroup_Spec(&spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_ContainerGroup_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status storage.ContainerGroup_STATUS
	err = group.Status.AssignProperties_To_ContainerGroup_STATUS(&status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_ContainerGroup_STATUS() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (group *ContainerGroup) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: group.Spec.OriginalVersion(),
		Kind:    "ContainerGroup",
	}
}

// +kubebuilder:object:root=true
// Generator information:
// - Generated from: /containerinstance/resource-manager/Microsoft.ContainerInstance/stable/2021-10-01/containerInstance.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerInstance/containerGroups/{containerGroupName}
type ContainerGroupList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ContainerGroup `json:"items"`
}

// +kubebuilder:validation:Enum={"2021-10-01"}
type APIVersion string

const APIVersion_Value = APIVersion("2021-10-01")

type ContainerGroup_Spec struct {
	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName string `json:"azureName,omitempty"`

	// +kubebuilder:validation:Required
	// Containers: The containers within the container group.
	Containers []Container `json:"containers,omitempty"`

	// Diagnostics: The diagnostic information for a container group.
	Diagnostics *ContainerGroupDiagnostics `json:"diagnostics,omitempty"`

	// DnsConfig: The DNS config information for a container group.
	DnsConfig *DnsConfiguration `json:"dnsConfig,omitempty"`

	// EncryptionProperties: The encryption properties for a container group.
	EncryptionProperties *EncryptionProperties `json:"encryptionProperties,omitempty"`

	// Identity: The identity of the container group, if configured.
	Identity *ContainerGroupIdentity `json:"identity,omitempty"`

	// ImageRegistryCredentials: The image registry credentials by which the container group is created from.
	ImageRegistryCredentials []ImageRegistryCredential `json:"imageRegistryCredentials,omitempty"`

	// InitContainers: The init containers for a container group.
	InitContainers []InitContainerDefinition `json:"initContainers,omitempty"`

	// IpAddress: The IP address type of the container group.
	IpAddress *IpAddress `json:"ipAddress,omitempty"`

	// Location: The resource location.
	Location *string `json:"location,omitempty"`

	// OperatorSpec: The specification for configuring operator behavior. This field is interpreted by the operator and not
	// passed directly to Azure
	OperatorSpec *ContainerGroupOperatorSpec `json:"operatorSpec,omitempty"`

	// +kubebuilder:validation:Required
	// OsType: The operating system type required by the containers in the container group.
	OsType *ContainerGroup_Properties_OsType_Spec `json:"osType,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a resources.azure.com/ResourceGroup resource
	Owner *genruntime.KnownResourceReference `group:"resources.azure.com" json:"owner,omitempty" kind:"ResourceGroup"`

	// RestartPolicy: Restart policy for all containers within the container group.
	// - `Always` Always restart
	// - `OnFailure` Restart on failure
	// - `Never` Never restart
	RestartPolicy *ContainerGroup_Properties_RestartPolicy_Spec `json:"restartPolicy,omitempty"`

	// Sku: The SKU for a container group.
	Sku *ContainerGroupSku `json:"sku,omitempty"`

	// SubnetIds: The subnet resource IDs for a container group.
	SubnetIds []ContainerGroupSubnetId `json:"subnetIds,omitempty"`

	// Tags: The resource tags.
	Tags map[string]string `json:"tags,omitempty"`

	// Volumes: The list of volumes that can be mounted by containers in this container group.
	Volumes []Volume `json:"volumes,omitempty"`

	// Zones: The zones for the container group.
	Zones []string `json:"zones,omitempty"`
}

var _ genruntime.ARMTransformer = &ContainerGroup_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (group *ContainerGroup_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if group == nil {
		return nil, nil
	}
	result := &arm.ContainerGroup_Spec{}

	// Set property "Identity":
	if group.Identity != nil {
		identity_ARM, err := (*group.Identity).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		identity := *identity_ARM.(*arm.ContainerGroupIdentity)
		result.Identity = &identity
	}

	// Set property "Location":
	if group.Location != nil {
		location := *group.Location
		result.Location = &location
	}

	// Set property "Name":
	result.Name = resolved.Name

	// Set property "Properties":
	if group.Containers != nil ||
		group.Diagnostics != nil ||
		group.DnsConfig != nil ||
		group.EncryptionProperties != nil ||
		group.ImageRegistryCredentials != nil ||
		group.InitContainers != nil ||
		group.IpAddress != nil ||
		group.OsType != nil ||
		group.RestartPolicy != nil ||
		group.Sku != nil ||
		group.SubnetIds != nil ||
		group.Volumes != nil {
		result.Properties = &arm.ContainerGroup_Properties_Spec{}
	}
	for _, item := range group.Containers {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.Containers = append(result.Properties.Containers, *item_ARM.(*arm.Container))
	}
	if group.Diagnostics != nil {
		diagnostics_ARM, err := (*group.Diagnostics).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		diagnostics := *diagnostics_ARM.(*arm.ContainerGroupDiagnostics)
		result.Properties.Diagnostics = &diagnostics
	}
	if group.DnsConfig != nil {
		dnsConfig_ARM, err := (*group.DnsConfig).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		dnsConfig := *dnsConfig_ARM.(*arm.DnsConfiguration)
		result.Properties.DnsConfig = &dnsConfig
	}
	if group.EncryptionProperties != nil {
		encryptionProperties_ARM, err := (*group.EncryptionProperties).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		encryptionProperties := *encryptionProperties_ARM.(*arm.EncryptionProperties)
		result.Properties.EncryptionProperties = &encryptionProperties
	}
	for _, item := range group.ImageRegistryCredentials {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.ImageRegistryCredentials = append(result.Properties.ImageRegistryCredentials, *item_ARM.(*arm.ImageRegistryCredential))
	}
	for _, item := range group.InitContainers {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.InitContainers = append(result.Properties.InitContainers, *item_ARM.(*arm.InitContainerDefinition))
	}
	if group.IpAddress != nil {
		ipAddress_ARM, err := (*group.IpAddress).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		ipAddress := *ipAddress_ARM.(*arm.IpAddress)
		result.Properties.IpAddress = &ipAddress
	}
	if group.OsType != nil {
		var temp string
		temp = string(*group.OsType)
		osType := arm.ContainerGroup_Properties_OsType_Spec(temp)
		result.Properties.OsType = &osType
	}
	if group.RestartPolicy != nil {
		var temp string
		temp = string(*group.RestartPolicy)
		restartPolicy := arm.ContainerGroup_Properties_RestartPolicy_Spec(temp)
		result.Properties.RestartPolicy = &restartPolicy
	}
	if group.Sku != nil {
		var temp string
		temp = string(*group.Sku)
		sku := arm.ContainerGroupSku(temp)
		result.Properties.Sku = &sku
	}
	for _, item := range group.SubnetIds {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.SubnetIds = append(result.Properties.SubnetIds, *item_ARM.(*arm.ContainerGroupSubnetId))
	}
	for _, item := range group.Volumes {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.Volumes = append(result.Properties.Volumes, *item_ARM.(*arm.Volume))
	}

	// Set property "Tags":
	if group.Tags != nil {
		result.Tags = make(map[string]string, len(group.Tags))
		for key, value := range group.Tags {
			result.Tags[key] = value
		}
	}

	// Set property "Zones":
	for _, item := range group.Zones {
		result.Zones = append(result.Zones, item)
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (group *ContainerGroup_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ContainerGroup_Spec{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (group *ContainerGroup_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ContainerGroup_Spec)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ContainerGroup_Spec, got %T", armInput)
	}

	// Set property "AzureName":
	group.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property "Containers":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Containers {
			var item1 Container
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			group.Containers = append(group.Containers, item1)
		}
	}

	// Set property "Diagnostics":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Diagnostics != nil {
			var diagnostics1 ContainerGroupDiagnostics
			err := diagnostics1.PopulateFromARM(owner, *typedInput.Properties.Diagnostics)
			if err != nil {
				return err
			}
			diagnostics := diagnostics1
			group.Diagnostics = &diagnostics
		}
	}

	// Set property "DnsConfig":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DnsConfig != nil {
			var dnsConfig1 DnsConfiguration
			err := dnsConfig1.PopulateFromARM(owner, *typedInput.Properties.DnsConfig)
			if err != nil {
				return err
			}
			dnsConfig := dnsConfig1
			group.DnsConfig = &dnsConfig
		}
	}

	// Set property "EncryptionProperties":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EncryptionProperties != nil {
			var encryptionProperties1 EncryptionProperties
			err := encryptionProperties1.PopulateFromARM(owner, *typedInput.Properties.EncryptionProperties)
			if err != nil {
				return err
			}
			encryptionProperties := encryptionProperties1
			group.EncryptionProperties = &encryptionProperties
		}
	}

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 ContainerGroupIdentity
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		group.Identity = &identity
	}

	// Set property "ImageRegistryCredentials":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.ImageRegistryCredentials {
			var item1 ImageRegistryCredential
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			group.ImageRegistryCredentials = append(group.ImageRegistryCredentials, item1)
		}
	}

	// Set property "InitContainers":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.InitContainers {
			var item1 InitContainerDefinition
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			group.InitContainers = append(group.InitContainers, item1)
		}
	}

	// Set property "IpAddress":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IpAddress != nil {
			var ipAddress1 IpAddress
			err := ipAddress1.PopulateFromARM(owner, *typedInput.Properties.IpAddress)
			if err != nil {
				return err
			}
			ipAddress := ipAddress1
			group.IpAddress = &ipAddress
		}
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		group.Location = &location
	}

	// no assignment for property "OperatorSpec"

	// Set property "OsType":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.OsType != nil {
			var temp string
			temp = string(*typedInput.Properties.OsType)
			osType := ContainerGroup_Properties_OsType_Spec(temp)
			group.OsType = &osType
		}
	}

	// Set property "Owner":
	group.Owner = &genruntime.KnownResourceReference{
		Name:  owner.Name,
		ARMID: owner.ARMID,
	}

	// Set property "RestartPolicy":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.RestartPolicy != nil {
			var temp string
			temp = string(*typedInput.Properties.RestartPolicy)
			restartPolicy := ContainerGroup_Properties_RestartPolicy_Spec(temp)
			group.RestartPolicy = &restartPolicy
		}
	}

	// Set property "Sku":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Sku != nil {
			var temp string
			temp = string(*typedInput.Properties.Sku)
			sku := ContainerGroupSku(temp)
			group.Sku = &sku
		}
	}

	// Set property "SubnetIds":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.SubnetIds {
			var item1 ContainerGroupSubnetId
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			group.SubnetIds = append(group.SubnetIds, item1)
		}
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		group.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			group.Tags[key] = value
		}
	}

	// Set property "Volumes":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Volumes {
			var item1 Volume
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			group.Volumes = append(group.Volumes, item1)
		}
	}

	// Set property "Zones":
	for _, item := range typedInput.Zones {
		group.Zones = append(group.Zones, item)
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &ContainerGroup_Spec{}

// ConvertSpecFrom populates our ContainerGroup_Spec from the provided source
func (group *ContainerGroup_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*storage.ContainerGroup_Spec)
	if ok {
		// Populate our instance from source
		return group.AssignProperties_From_ContainerGroup_Spec(src)
	}

	// Convert to an intermediate form
	src = &storage.ContainerGroup_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = group.AssignProperties_From_ContainerGroup_Spec(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our ContainerGroup_Spec
func (group *ContainerGroup_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*storage.ContainerGroup_Spec)
	if ok {
		// Populate destination from our instance
		return group.AssignProperties_To_ContainerGroup_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &storage.ContainerGroup_Spec{}
	err := group.AssignProperties_To_ContainerGroup_Spec(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignProperties_From_ContainerGroup_Spec populates our ContainerGroup_Spec from the provided source ContainerGroup_Spec
func (group *ContainerGroup_Spec) AssignProperties_From_ContainerGroup_Spec(source *storage.ContainerGroup_Spec) error {

	// AzureName
	group.AzureName = source.AzureName

	// Containers
	if source.Containers != nil {
		containerList := make([]Container, len(source.Containers))
		for containerIndex, containerItem := range source.Containers {
			// Shadow the loop variable to avoid aliasing
			containerItem := containerItem
			var container Container
			err := container.AssignProperties_From_Container(&containerItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_Container() to populate field Containers")
			}
			containerList[containerIndex] = container
		}
		group.Containers = containerList
	} else {
		group.Containers = nil
	}

	// Diagnostics
	if source.Diagnostics != nil {
		var diagnostic ContainerGroupDiagnostics
		err := diagnostic.AssignProperties_From_ContainerGroupDiagnostics(source.Diagnostics)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ContainerGroupDiagnostics() to populate field Diagnostics")
		}
		group.Diagnostics = &diagnostic
	} else {
		group.Diagnostics = nil
	}

	// DnsConfig
	if source.DnsConfig != nil {
		var dnsConfig DnsConfiguration
		err := dnsConfig.AssignProperties_From_DnsConfiguration(source.DnsConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DnsConfiguration() to populate field DnsConfig")
		}
		group.DnsConfig = &dnsConfig
	} else {
		group.DnsConfig = nil
	}

	// EncryptionProperties
	if source.EncryptionProperties != nil {
		var encryptionProperty EncryptionProperties
		err := encryptionProperty.AssignProperties_From_EncryptionProperties(source.EncryptionProperties)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_EncryptionProperties() to populate field EncryptionProperties")
		}
		group.EncryptionProperties = &encryptionProperty
	} else {
		group.EncryptionProperties = nil
	}

	// Identity
	if source.Identity != nil {
		var identity ContainerGroupIdentity
		err := identity.AssignProperties_From_ContainerGroupIdentity(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ContainerGroupIdentity() to populate field Identity")
		}
		group.Identity = &identity
	} else {
		group.Identity = nil
	}

	// ImageRegistryCredentials
	if source.ImageRegistryCredentials != nil {
		imageRegistryCredentialList := make([]ImageRegistryCredential, len(source.ImageRegistryCredentials))
		for imageRegistryCredentialIndex, imageRegistryCredentialItem := range source.ImageRegistryCredentials {
			// Shadow the loop variable to avoid aliasing
			imageRegistryCredentialItem := imageRegistryCredentialItem
			var imageRegistryCredential ImageRegistryCredential
			err := imageRegistryCredential.AssignProperties_From_ImageRegistryCredential(&imageRegistryCredentialItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ImageRegistryCredential() to populate field ImageRegistryCredentials")
			}
			imageRegistryCredentialList[imageRegistryCredentialIndex] = imageRegistryCredential
		}
		group.ImageRegistryCredentials = imageRegistryCredentialList
	} else {
		group.ImageRegistryCredentials = nil
	}

	// InitContainers
	if source.InitContainers != nil {
		initContainerList := make([]InitContainerDefinition, len(source.InitContainers))
		for initContainerIndex, initContainerItem := range source.InitContainers {
			// Shadow the loop variable to avoid aliasing
			initContainerItem := initContainerItem
			var initContainer InitContainerDefinition
			err := initContainer.AssignProperties_From_InitContainerDefinition(&initContainerItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_InitContainerDefinition() to populate field InitContainers")
			}
			initContainerList[initContainerIndex] = initContainer
		}
		group.InitContainers = initContainerList
	} else {
		group.InitContainers = nil
	}

	// IpAddress
	if source.IpAddress != nil {
		var ipAddress IpAddress
		err := ipAddress.AssignProperties_From_IpAddress(source.IpAddress)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_IpAddress() to populate field IpAddress")
		}
		group.IpAddress = &ipAddress
	} else {
		group.IpAddress = nil
	}

	// Location
	group.Location = genruntime.ClonePointerToString(source.Location)

	// OperatorSpec
	if source.OperatorSpec != nil {
		var operatorSpec ContainerGroupOperatorSpec
		err := operatorSpec.AssignProperties_From_ContainerGroupOperatorSpec(source.OperatorSpec)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ContainerGroupOperatorSpec() to populate field OperatorSpec")
		}
		group.OperatorSpec = &operatorSpec
	} else {
		group.OperatorSpec = nil
	}

	// OsType
	if source.OsType != nil {
		osType := *source.OsType
		osTypeTemp := genruntime.ToEnum(osType, containerGroup_Properties_OsType_Spec_Values)
		group.OsType = &osTypeTemp
	} else {
		group.OsType = nil
	}

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		group.Owner = &owner
	} else {
		group.Owner = nil
	}

	// RestartPolicy
	if source.RestartPolicy != nil {
		restartPolicy := *source.RestartPolicy
		restartPolicyTemp := genruntime.ToEnum(restartPolicy, containerGroup_Properties_RestartPolicy_Spec_Values)
		group.RestartPolicy = &restartPolicyTemp
	} else {
		group.RestartPolicy = nil
	}

	// Sku
	if source.Sku != nil {
		sku := *source.Sku
		skuTemp := genruntime.ToEnum(sku, containerGroupSku_Values)
		group.Sku = &skuTemp
	} else {
		group.Sku = nil
	}

	// SubnetIds
	if source.SubnetIds != nil {
		subnetIdList := make([]ContainerGroupSubnetId, len(source.SubnetIds))
		for subnetIdIndex, subnetIdItem := range source.SubnetIds {
			// Shadow the loop variable to avoid aliasing
			subnetIdItem := subnetIdItem
			var subnetId ContainerGroupSubnetId
			err := subnetId.AssignProperties_From_ContainerGroupSubnetId(&subnetIdItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ContainerGroupSubnetId() to populate field SubnetIds")
			}
			subnetIdList[subnetIdIndex] = subnetId
		}
		group.SubnetIds = subnetIdList
	} else {
		group.SubnetIds = nil
	}

	// Tags
	group.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Volumes
	if source.Volumes != nil {
		volumeList := make([]Volume, len(source.Volumes))
		for volumeIndex, volumeItem := range source.Volumes {
			// Shadow the loop variable to avoid aliasing
			volumeItem := volumeItem
			var volume Volume
			err := volume.AssignProperties_From_Volume(&volumeItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_Volume() to populate field Volumes")
			}
			volumeList[volumeIndex] = volume
		}
		group.Volumes = volumeList
	} else {
		group.Volumes = nil
	}

	// Zones
	group.Zones = genruntime.CloneSliceOfString(source.Zones)

	// No error
	return nil
}

// AssignProperties_To_ContainerGroup_Spec populates the provided destination ContainerGroup_Spec from our ContainerGroup_Spec
func (group *ContainerGroup_Spec) AssignProperties_To_ContainerGroup_Spec(destination *storage.ContainerGroup_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureName
	destination.AzureName = group.AzureName

	// Containers
	if group.Containers != nil {
		containerList := make([]storage.Container, len(group.Containers))
		for containerIndex, containerItem := range group.Containers {
			// Shadow the loop variable to avoid aliasing
			containerItem := containerItem
			var container storage.Container
			err := containerItem.AssignProperties_To_Container(&container)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_Container() to populate field Containers")
			}
			containerList[containerIndex] = container
		}
		destination.Containers = containerList
	} else {
		destination.Containers = nil
	}

	// Diagnostics
	if group.Diagnostics != nil {
		var diagnostic storage.ContainerGroupDiagnostics
		err := group.Diagnostics.AssignProperties_To_ContainerGroupDiagnostics(&diagnostic)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ContainerGroupDiagnostics() to populate field Diagnostics")
		}
		destination.Diagnostics = &diagnostic
	} else {
		destination.Diagnostics = nil
	}

	// DnsConfig
	if group.DnsConfig != nil {
		var dnsConfig storage.DnsConfiguration
		err := group.DnsConfig.AssignProperties_To_DnsConfiguration(&dnsConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DnsConfiguration() to populate field DnsConfig")
		}
		destination.DnsConfig = &dnsConfig
	} else {
		destination.DnsConfig = nil
	}

	// EncryptionProperties
	if group.EncryptionProperties != nil {
		var encryptionProperty storage.EncryptionProperties
		err := group.EncryptionProperties.AssignProperties_To_EncryptionProperties(&encryptionProperty)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_EncryptionProperties() to populate field EncryptionProperties")
		}
		destination.EncryptionProperties = &encryptionProperty
	} else {
		destination.EncryptionProperties = nil
	}

	// Identity
	if group.Identity != nil {
		var identity storage.ContainerGroupIdentity
		err := group.Identity.AssignProperties_To_ContainerGroupIdentity(&identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ContainerGroupIdentity() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// ImageRegistryCredentials
	if group.ImageRegistryCredentials != nil {
		imageRegistryCredentialList := make([]storage.ImageRegistryCredential, len(group.ImageRegistryCredentials))
		for imageRegistryCredentialIndex, imageRegistryCredentialItem := range group.ImageRegistryCredentials {
			// Shadow the loop variable to avoid aliasing
			imageRegistryCredentialItem := imageRegistryCredentialItem
			var imageRegistryCredential storage.ImageRegistryCredential
			err := imageRegistryCredentialItem.AssignProperties_To_ImageRegistryCredential(&imageRegistryCredential)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ImageRegistryCredential() to populate field ImageRegistryCredentials")
			}
			imageRegistryCredentialList[imageRegistryCredentialIndex] = imageRegistryCredential
		}
		destination.ImageRegistryCredentials = imageRegistryCredentialList
	} else {
		destination.ImageRegistryCredentials = nil
	}

	// InitContainers
	if group.InitContainers != nil {
		initContainerList := make([]storage.InitContainerDefinition, len(group.InitContainers))
		for initContainerIndex, initContainerItem := range group.InitContainers {
			// Shadow the loop variable to avoid aliasing
			initContainerItem := initContainerItem
			var initContainer storage.InitContainerDefinition
			err := initContainerItem.AssignProperties_To_InitContainerDefinition(&initContainer)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_InitContainerDefinition() to populate field InitContainers")
			}
			initContainerList[initContainerIndex] = initContainer
		}
		destination.InitContainers = initContainerList
	} else {
		destination.InitContainers = nil
	}

	// IpAddress
	if group.IpAddress != nil {
		var ipAddress storage.IpAddress
		err := group.IpAddress.AssignProperties_To_IpAddress(&ipAddress)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_IpAddress() to populate field IpAddress")
		}
		destination.IpAddress = &ipAddress
	} else {
		destination.IpAddress = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(group.Location)

	// OperatorSpec
	if group.OperatorSpec != nil {
		var operatorSpec storage.ContainerGroupOperatorSpec
		err := group.OperatorSpec.AssignProperties_To_ContainerGroupOperatorSpec(&operatorSpec)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ContainerGroupOperatorSpec() to populate field OperatorSpec")
		}
		destination.OperatorSpec = &operatorSpec
	} else {
		destination.OperatorSpec = nil
	}

	// OriginalVersion
	destination.OriginalVersion = group.OriginalVersion()

	// OsType
	if group.OsType != nil {
		osType := string(*group.OsType)
		destination.OsType = &osType
	} else {
		destination.OsType = nil
	}

	// Owner
	if group.Owner != nil {
		owner := group.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// RestartPolicy
	if group.RestartPolicy != nil {
		restartPolicy := string(*group.RestartPolicy)
		destination.RestartPolicy = &restartPolicy
	} else {
		destination.RestartPolicy = nil
	}

	// Sku
	if group.Sku != nil {
		sku := string(*group.Sku)
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// SubnetIds
	if group.SubnetIds != nil {
		subnetIdList := make([]storage.ContainerGroupSubnetId, len(group.SubnetIds))
		for subnetIdIndex, subnetIdItem := range group.SubnetIds {
			// Shadow the loop variable to avoid aliasing
			subnetIdItem := subnetIdItem
			var subnetId storage.ContainerGroupSubnetId
			err := subnetIdItem.AssignProperties_To_ContainerGroupSubnetId(&subnetId)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ContainerGroupSubnetId() to populate field SubnetIds")
			}
			subnetIdList[subnetIdIndex] = subnetId
		}
		destination.SubnetIds = subnetIdList
	} else {
		destination.SubnetIds = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(group.Tags)

	// Volumes
	if group.Volumes != nil {
		volumeList := make([]storage.Volume, len(group.Volumes))
		for volumeIndex, volumeItem := range group.Volumes {
			// Shadow the loop variable to avoid aliasing
			volumeItem := volumeItem
			var volume storage.Volume
			err := volumeItem.AssignProperties_To_Volume(&volume)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_Volume() to populate field Volumes")
			}
			volumeList[volumeIndex] = volume
		}
		destination.Volumes = volumeList
	} else {
		destination.Volumes = nil
	}

	// Zones
	destination.Zones = genruntime.CloneSliceOfString(group.Zones)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ContainerGroup_STATUS populates our ContainerGroup_Spec from the provided source ContainerGroup_STATUS
func (group *ContainerGroup_Spec) Initialize_From_ContainerGroup_STATUS(source *ContainerGroup_STATUS) error {

	// Containers
	if source.Containers != nil {
		containerList := make([]Container, len(source.Containers))
		for containerIndex, containerItem := range source.Containers {
			// Shadow the loop variable to avoid aliasing
			containerItem := containerItem
			var container Container
			err := container.Initialize_From_Container_STATUS(&containerItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_Container_STATUS() to populate field Containers")
			}
			containerList[containerIndex] = container
		}
		group.Containers = containerList
	} else {
		group.Containers = nil
	}

	// Diagnostics
	if source.Diagnostics != nil {
		var diagnostic ContainerGroupDiagnostics
		err := diagnostic.Initialize_From_ContainerGroupDiagnostics_STATUS(source.Diagnostics)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_ContainerGroupDiagnostics_STATUS() to populate field Diagnostics")
		}
		group.Diagnostics = &diagnostic
	} else {
		group.Diagnostics = nil
	}

	// DnsConfig
	if source.DnsConfig != nil {
		var dnsConfig DnsConfiguration
		err := dnsConfig.Initialize_From_DnsConfiguration_STATUS(source.DnsConfig)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_DnsConfiguration_STATUS() to populate field DnsConfig")
		}
		group.DnsConfig = &dnsConfig
	} else {
		group.DnsConfig = nil
	}

	// EncryptionProperties
	if source.EncryptionProperties != nil {
		var encryptionProperty EncryptionProperties
		err := encryptionProperty.Initialize_From_EncryptionProperties_STATUS(source.EncryptionProperties)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_EncryptionProperties_STATUS() to populate field EncryptionProperties")
		}
		group.EncryptionProperties = &encryptionProperty
	} else {
		group.EncryptionProperties = nil
	}

	// Identity
	if source.Identity != nil {
		var identity ContainerGroupIdentity
		err := identity.Initialize_From_ContainerGroupIdentity_STATUS(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_ContainerGroupIdentity_STATUS() to populate field Identity")
		}
		group.Identity = &identity
	} else {
		group.Identity = nil
	}

	// ImageRegistryCredentials
	if source.ImageRegistryCredentials != nil {
		imageRegistryCredentialList := make([]ImageRegistryCredential, len(source.ImageRegistryCredentials))
		for imageRegistryCredentialIndex, imageRegistryCredentialItem := range source.ImageRegistryCredentials {
			// Shadow the loop variable to avoid aliasing
			imageRegistryCredentialItem := imageRegistryCredentialItem
			var imageRegistryCredential ImageRegistryCredential
			err := imageRegistryCredential.Initialize_From_ImageRegistryCredential_STATUS(&imageRegistryCredentialItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_ImageRegistryCredential_STATUS() to populate field ImageRegistryCredentials")
			}
			imageRegistryCredentialList[imageRegistryCredentialIndex] = imageRegistryCredential
		}
		group.ImageRegistryCredentials = imageRegistryCredentialList
	} else {
		group.ImageRegistryCredentials = nil
	}

	// InitContainers
	if source.InitContainers != nil {
		initContainerList := make([]InitContainerDefinition, len(source.InitContainers))
		for initContainerIndex, initContainerItem := range source.InitContainers {
			// Shadow the loop variable to avoid aliasing
			initContainerItem := initContainerItem
			var initContainer InitContainerDefinition
			err := initContainer.Initialize_From_InitContainerDefinition_STATUS(&initContainerItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_InitContainerDefinition_STATUS() to populate field InitContainers")
			}
			initContainerList[initContainerIndex] = initContainer
		}
		group.InitContainers = initContainerList
	} else {
		group.InitContainers = nil
	}

	// IpAddress
	if source.IpAddress != nil {
		var ipAddress IpAddress
		err := ipAddress.Initialize_From_IpAddress_STATUS(source.IpAddress)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_IpAddress_STATUS() to populate field IpAddress")
		}
		group.IpAddress = &ipAddress
	} else {
		group.IpAddress = nil
	}

	// Location
	group.Location = genruntime.ClonePointerToString(source.Location)

	// OsType
	if source.OsType != nil {
		osType := genruntime.ToEnum(string(*source.OsType), containerGroup_Properties_OsType_Spec_Values)
		group.OsType = &osType
	} else {
		group.OsType = nil
	}

	// RestartPolicy
	if source.RestartPolicy != nil {
		restartPolicy := genruntime.ToEnum(string(*source.RestartPolicy), containerGroup_Properties_RestartPolicy_Spec_Values)
		group.RestartPolicy = &restartPolicy
	} else {
		group.RestartPolicy = nil
	}

	// Sku
	if source.Sku != nil {
		sku := genruntime.ToEnum(string(*source.Sku), containerGroupSku_Values)
		group.Sku = &sku
	} else {
		group.Sku = nil
	}

	// SubnetIds
	if source.SubnetIds != nil {
		subnetIdList := make([]ContainerGroupSubnetId, len(source.SubnetIds))
		for subnetIdIndex, subnetIdItem := range source.SubnetIds {
			// Shadow the loop variable to avoid aliasing
			subnetIdItem := subnetIdItem
			var subnetId ContainerGroupSubnetId
			err := subnetId.Initialize_From_ContainerGroupSubnetId_STATUS(&subnetIdItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_ContainerGroupSubnetId_STATUS() to populate field SubnetIds")
			}
			subnetIdList[subnetIdIndex] = subnetId
		}
		group.SubnetIds = subnetIdList
	} else {
		group.SubnetIds = nil
	}

	// Tags
	group.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Volumes
	if source.Volumes != nil {
		volumeList := make([]Volume, len(source.Volumes))
		for volumeIndex, volumeItem := range source.Volumes {
			// Shadow the loop variable to avoid aliasing
			volumeItem := volumeItem
			var volume Volume
			err := volume.Initialize_From_Volume_STATUS(&volumeItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_Volume_STATUS() to populate field Volumes")
			}
			volumeList[volumeIndex] = volume
		}
		group.Volumes = volumeList
	} else {
		group.Volumes = nil
	}

	// Zones
	group.Zones = genruntime.CloneSliceOfString(source.Zones)

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (group *ContainerGroup_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (group *ContainerGroup_Spec) SetAzureName(azureName string) { group.AzureName = azureName }

// A container group.
type ContainerGroup_STATUS struct {
	// Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	// Containers: The containers within the container group.
	Containers []Container_STATUS `json:"containers,omitempty"`

	// Diagnostics: The diagnostic information for a container group.
	Diagnostics *ContainerGroupDiagnostics_STATUS `json:"diagnostics,omitempty"`

	// DnsConfig: The DNS config information for a container group.
	DnsConfig *DnsConfiguration_STATUS `json:"dnsConfig,omitempty"`

	// EncryptionProperties: The encryption properties for a container group.
	EncryptionProperties *EncryptionProperties_STATUS `json:"encryptionProperties,omitempty"`

	// Id: The resource id.
	Id *string `json:"id,omitempty"`

	// Identity: The identity of the container group, if configured.
	Identity *ContainerGroupIdentity_STATUS `json:"identity,omitempty"`

	// ImageRegistryCredentials: The image registry credentials by which the container group is created from.
	ImageRegistryCredentials []ImageRegistryCredential_STATUS `json:"imageRegistryCredentials,omitempty"`

	// InitContainers: The init containers for a container group.
	InitContainers []InitContainerDefinition_STATUS `json:"initContainers,omitempty"`

	// InstanceView: The instance view of the container group. Only valid in response.
	InstanceView *ContainerGroup_Properties_InstanceView_STATUS `json:"instanceView,omitempty"`

	// IpAddress: The IP address type of the container group.
	IpAddress *IpAddress_STATUS `json:"ipAddress,omitempty"`

	// Location: The resource location.
	Location *string `json:"location,omitempty"`

	// Name: The resource name.
	Name *string `json:"name,omitempty"`

	// OsType: The operating system type required by the containers in the container group.
	OsType *ContainerGroup_Properties_OsType_STATUS `json:"osType,omitempty"`

	// ProvisioningState: The provisioning state of the container group. This only appears in the response.
	ProvisioningState *string `json:"provisioningState,omitempty"`

	// RestartPolicy: Restart policy for all containers within the container group.
	// - `Always` Always restart
	// - `OnFailure` Restart on failure
	// - `Never` Never restart
	RestartPolicy *ContainerGroup_Properties_RestartPolicy_STATUS `json:"restartPolicy,omitempty"`

	// Sku: The SKU for a container group.
	Sku *ContainerGroupSku_STATUS `json:"sku,omitempty"`

	// SubnetIds: The subnet resource IDs for a container group.
	SubnetIds []ContainerGroupSubnetId_STATUS `json:"subnetIds,omitempty"`

	// Tags: The resource tags.
	Tags map[string]string `json:"tags,omitempty"`

	// Type: The resource type.
	Type *string `json:"type,omitempty"`

	// Volumes: The list of volumes that can be mounted by containers in this container group.
	Volumes []Volume_STATUS `json:"volumes,omitempty"`

	// Zones: The zones for the container group.
	Zones []string `json:"zones,omitempty"`
}

var _ genruntime.ConvertibleStatus = &ContainerGroup_STATUS{}

// ConvertStatusFrom populates our ContainerGroup_STATUS from the provided source
func (group *ContainerGroup_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*storage.ContainerGroup_STATUS)
	if ok {
		// Populate our instance from source
		return group.AssignProperties_From_ContainerGroup_STATUS(src)
	}

	// Convert to an intermediate form
	src = &storage.ContainerGroup_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = group.AssignProperties_From_ContainerGroup_STATUS(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our ContainerGroup_STATUS
func (group *ContainerGroup_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*storage.ContainerGroup_STATUS)
	if ok {
		// Populate destination from our instance
		return group.AssignProperties_To_ContainerGroup_STATUS(dst)
	}

	// Convert to an intermediate form
	dst = &storage.ContainerGroup_STATUS{}
	err := group.AssignProperties_To_ContainerGroup_STATUS(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &ContainerGroup_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (group *ContainerGroup_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ContainerGroup_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (group *ContainerGroup_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ContainerGroup_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ContainerGroup_STATUS, got %T", armInput)
	}

	// no assignment for property "Conditions"

	// Set property "Containers":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Containers {
			var item1 Container_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			group.Containers = append(group.Containers, item1)
		}
	}

	// Set property "Diagnostics":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Diagnostics != nil {
			var diagnostics1 ContainerGroupDiagnostics_STATUS
			err := diagnostics1.PopulateFromARM(owner, *typedInput.Properties.Diagnostics)
			if err != nil {
				return err
			}
			diagnostics := diagnostics1
			group.Diagnostics = &diagnostics
		}
	}

	// Set property "DnsConfig":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DnsConfig != nil {
			var dnsConfig1 DnsConfiguration_STATUS
			err := dnsConfig1.PopulateFromARM(owner, *typedInput.Properties.DnsConfig)
			if err != nil {
				return err
			}
			dnsConfig := dnsConfig1
			group.DnsConfig = &dnsConfig
		}
	}

	// Set property "EncryptionProperties":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EncryptionProperties != nil {
			var encryptionProperties1 EncryptionProperties_STATUS
			err := encryptionProperties1.PopulateFromARM(owner, *typedInput.Properties.EncryptionProperties)
			if err != nil {
				return err
			}
			encryptionProperties := encryptionProperties1
			group.EncryptionProperties = &encryptionProperties
		}
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		group.Id = &id
	}

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 ContainerGroupIdentity_STATUS
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		group.Identity = &identity
	}

	// Set property "ImageRegistryCredentials":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.ImageRegistryCredentials {
			var item1 ImageRegistryCredential_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			group.ImageRegistryCredentials = append(group.ImageRegistryCredentials, item1)
		}
	}

	// Set property "InitContainers":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.InitContainers {
			var item1 InitContainerDefinition_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			group.InitContainers = append(group.InitContainers, item1)
		}
	}

	// Set property "InstanceView":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.InstanceView != nil {
			var instanceView1 ContainerGroup_Properties_InstanceView_STATUS
			err := instanceView1.PopulateFromARM(owner, *typedInput.Properties.InstanceView)
			if err != nil {
				return err
			}
			instanceView := instanceView1
			group.InstanceView = &instanceView
		}
	}

	// Set property "IpAddress":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IpAddress != nil {
			var ipAddress1 IpAddress_STATUS
			err := ipAddress1.PopulateFromARM(owner, *typedInput.Properties.IpAddress)
			if err != nil {
				return err
			}
			ipAddress := ipAddress1
			group.IpAddress = &ipAddress
		}
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		group.Location = &location
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		group.Name = &name
	}

	// Set property "OsType":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.OsType != nil {
			var temp string
			temp = string(*typedInput.Properties.OsType)
			osType := ContainerGroup_Properties_OsType_STATUS(temp)
			group.OsType = &osType
		}
	}

	// Set property "ProvisioningState":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			provisioningState := *typedInput.Properties.ProvisioningState
			group.ProvisioningState = &provisioningState
		}
	}

	// Set property "RestartPolicy":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.RestartPolicy != nil {
			var temp string
			temp = string(*typedInput.Properties.RestartPolicy)
			restartPolicy := ContainerGroup_Properties_RestartPolicy_STATUS(temp)
			group.RestartPolicy = &restartPolicy
		}
	}

	// Set property "Sku":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Sku != nil {
			var temp string
			temp = string(*typedInput.Properties.Sku)
			sku := ContainerGroupSku_STATUS(temp)
			group.Sku = &sku
		}
	}

	// Set property "SubnetIds":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.SubnetIds {
			var item1 ContainerGroupSubnetId_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			group.SubnetIds = append(group.SubnetIds, item1)
		}
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		group.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			group.Tags[key] = value
		}
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		group.Type = &typeVar
	}

	// Set property "Volumes":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Volumes {
			var item1 Volume_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			group.Volumes = append(group.Volumes, item1)
		}
	}

	// Set property "Zones":
	for _, item := range typedInput.Zones {
		group.Zones = append(group.Zones, item)
	}

	// No error
	return nil
}

// AssignProperties_From_ContainerGroup_STATUS populates our ContainerGroup_STATUS from the provided source ContainerGroup_STATUS
func (group *ContainerGroup_STATUS) AssignProperties_From_ContainerGroup_STATUS(source *storage.ContainerGroup_STATUS) error {

	// Conditions
	group.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// Containers
	if source.Containers != nil {
		containerList := make([]Container_STATUS, len(source.Containers))
		for containerIndex, containerItem := range source.Containers {
			// Shadow the loop variable to avoid aliasing
			containerItem := containerItem
			var container Container_STATUS
			err := container.AssignProperties_From_Container_STATUS(&containerItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_Container_STATUS() to populate field Containers")
			}
			containerList[containerIndex] = container
		}
		group.Containers = containerList
	} else {
		group.Containers = nil
	}

	// Diagnostics
	if source.Diagnostics != nil {
		var diagnostic ContainerGroupDiagnostics_STATUS
		err := diagnostic.AssignProperties_From_ContainerGroupDiagnostics_STATUS(source.Diagnostics)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ContainerGroupDiagnostics_STATUS() to populate field Diagnostics")
		}
		group.Diagnostics = &diagnostic
	} else {
		group.Diagnostics = nil
	}

	// DnsConfig
	if source.DnsConfig != nil {
		var dnsConfig DnsConfiguration_STATUS
		err := dnsConfig.AssignProperties_From_DnsConfiguration_STATUS(source.DnsConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DnsConfiguration_STATUS() to populate field DnsConfig")
		}
		group.DnsConfig = &dnsConfig
	} else {
		group.DnsConfig = nil
	}

	// EncryptionProperties
	if source.EncryptionProperties != nil {
		var encryptionProperty EncryptionProperties_STATUS
		err := encryptionProperty.AssignProperties_From_EncryptionProperties_STATUS(source.EncryptionProperties)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_EncryptionProperties_STATUS() to populate field EncryptionProperties")
		}
		group.EncryptionProperties = &encryptionProperty
	} else {
		group.EncryptionProperties = nil
	}

	// Id
	group.Id = genruntime.ClonePointerToString(source.Id)

	// Identity
	if source.Identity != nil {
		var identity ContainerGroupIdentity_STATUS
		err := identity.AssignProperties_From_ContainerGroupIdentity_STATUS(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ContainerGroupIdentity_STATUS() to populate field Identity")
		}
		group.Identity = &identity
	} else {
		group.Identity = nil
	}

	// ImageRegistryCredentials
	if source.ImageRegistryCredentials != nil {
		imageRegistryCredentialList := make([]ImageRegistryCredential_STATUS, len(source.ImageRegistryCredentials))
		for imageRegistryCredentialIndex, imageRegistryCredentialItem := range source.ImageRegistryCredentials {
			// Shadow the loop variable to avoid aliasing
			imageRegistryCredentialItem := imageRegistryCredentialItem
			var imageRegistryCredential ImageRegistryCredential_STATUS
			err := imageRegistryCredential.AssignProperties_From_ImageRegistryCredential_STATUS(&imageRegistryCredentialItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ImageRegistryCredential_STATUS() to populate field ImageRegistryCredentials")
			}
			imageRegistryCredentialList[imageRegistryCredentialIndex] = imageRegistryCredential
		}
		group.ImageRegistryCredentials = imageRegistryCredentialList
	} else {
		group.ImageRegistryCredentials = nil
	}

	// InitContainers
	if source.InitContainers != nil {
		initContainerList := make([]InitContainerDefinition_STATUS, len(source.InitContainers))
		for initContainerIndex, initContainerItem := range source.InitContainers {
			// Shadow the loop variable to avoid aliasing
			initContainerItem := initContainerItem
			var initContainer InitContainerDefinition_STATUS
			err := initContainer.AssignProperties_From_InitContainerDefinition_STATUS(&initContainerItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_InitContainerDefinition_STATUS() to populate field InitContainers")
			}
			initContainerList[initContainerIndex] = initContainer
		}
		group.InitContainers = initContainerList
	} else {
		group.InitContainers = nil
	}

	// InstanceView
	if source.InstanceView != nil {
		var instanceView ContainerGroup_Properties_InstanceView_STATUS
		err := instanceView.AssignProperties_From_ContainerGroup_Properties_InstanceView_STATUS(source.InstanceView)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ContainerGroup_Properties_InstanceView_STATUS() to populate field InstanceView")
		}
		group.InstanceView = &instanceView
	} else {
		group.InstanceView = nil
	}

	// IpAddress
	if source.IpAddress != nil {
		var ipAddress IpAddress_STATUS
		err := ipAddress.AssignProperties_From_IpAddress_STATUS(source.IpAddress)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_IpAddress_STATUS() to populate field IpAddress")
		}
		group.IpAddress = &ipAddress
	} else {
		group.IpAddress = nil
	}

	// Location
	group.Location = genruntime.ClonePointerToString(source.Location)

	// Name
	group.Name = genruntime.ClonePointerToString(source.Name)

	// OsType
	if source.OsType != nil {
		osType := *source.OsType
		osTypeTemp := genruntime.ToEnum(osType, containerGroup_Properties_OsType_STATUS_Values)
		group.OsType = &osTypeTemp
	} else {
		group.OsType = nil
	}

	// ProvisioningState
	group.ProvisioningState = genruntime.ClonePointerToString(source.ProvisioningState)

	// RestartPolicy
	if source.RestartPolicy != nil {
		restartPolicy := *source.RestartPolicy
		restartPolicyTemp := genruntime.ToEnum(restartPolicy, containerGroup_Properties_RestartPolicy_STATUS_Values)
		group.RestartPolicy = &restartPolicyTemp
	} else {
		group.RestartPolicy = nil
	}

	// Sku
	if source.Sku != nil {
		sku := *source.Sku
		skuTemp := genruntime.ToEnum(sku, containerGroupSku_STATUS_Values)
		group.Sku = &skuTemp
	} else {
		group.Sku = nil
	}

	// SubnetIds
	if source.SubnetIds != nil {
		subnetIdList := make([]ContainerGroupSubnetId_STATUS, len(source.SubnetIds))
		for subnetIdIndex, subnetIdItem := range source.SubnetIds {
			// Shadow the loop variable to avoid aliasing
			subnetIdItem := subnetIdItem
			var subnetId ContainerGroupSubnetId_STATUS
			err := subnetId.AssignProperties_From_ContainerGroupSubnetId_STATUS(&subnetIdItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ContainerGroupSubnetId_STATUS() to populate field SubnetIds")
			}
			subnetIdList[subnetIdIndex] = subnetId
		}
		group.SubnetIds = subnetIdList
	} else {
		group.SubnetIds = nil
	}

	// Tags
	group.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Type
	group.Type = genruntime.ClonePointerToString(source.Type)

	// Volumes
	if source.Volumes != nil {
		volumeList := make([]Volume_STATUS, len(source.Volumes))
		for volumeIndex, volumeItem := range source.Volumes {
			// Shadow the loop variable to avoid aliasing
			volumeItem := volumeItem
			var volume Volume_STATUS
			err := volume.AssignProperties_From_Volume_STATUS(&volumeItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_Volume_STATUS() to populate field Volumes")
			}
			volumeList[volumeIndex] = volume
		}
		group.Volumes = volumeList
	} else {
		group.Volumes = nil
	}

	// Zones
	group.Zones = genruntime.CloneSliceOfString(source.Zones)

	// No error
	return nil
}

// AssignProperties_To_ContainerGroup_STATUS populates the provided destination ContainerGroup_STATUS from our ContainerGroup_STATUS
func (group *ContainerGroup_STATUS) AssignProperties_To_ContainerGroup_STATUS(destination *storage.ContainerGroup_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(group.Conditions)

	// Containers
	if group.Containers != nil {
		containerList := make([]storage.Container_STATUS, len(group.Containers))
		for containerIndex, containerItem := range group.Containers {
			// Shadow the loop variable to avoid aliasing
			containerItem := containerItem
			var container storage.Container_STATUS
			err := containerItem.AssignProperties_To_Container_STATUS(&container)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_Container_STATUS() to populate field Containers")
			}
			containerList[containerIndex] = container
		}
		destination.Containers = containerList
	} else {
		destination.Containers = nil
	}

	// Diagnostics
	if group.Diagnostics != nil {
		var diagnostic storage.ContainerGroupDiagnostics_STATUS
		err := group.Diagnostics.AssignProperties_To_ContainerGroupDiagnostics_STATUS(&diagnostic)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ContainerGroupDiagnostics_STATUS() to populate field Diagnostics")
		}
		destination.Diagnostics = &diagnostic
	} else {
		destination.Diagnostics = nil
	}

	// DnsConfig
	if group.DnsConfig != nil {
		var dnsConfig storage.DnsConfiguration_STATUS
		err := group.DnsConfig.AssignProperties_To_DnsConfiguration_STATUS(&dnsConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DnsConfiguration_STATUS() to populate field DnsConfig")
		}
		destination.DnsConfig = &dnsConfig
	} else {
		destination.DnsConfig = nil
	}

	// EncryptionProperties
	if group.EncryptionProperties != nil {
		var encryptionProperty storage.EncryptionProperties_STATUS
		err := group.EncryptionProperties.AssignProperties_To_EncryptionProperties_STATUS(&encryptionProperty)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_EncryptionProperties_STATUS() to populate field EncryptionProperties")
		}
		destination.EncryptionProperties = &encryptionProperty
	} else {
		destination.EncryptionProperties = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(group.Id)

	// Identity
	if group.Identity != nil {
		var identity storage.ContainerGroupIdentity_STATUS
		err := group.Identity.AssignProperties_To_ContainerGroupIdentity_STATUS(&identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ContainerGroupIdentity_STATUS() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// ImageRegistryCredentials
	if group.ImageRegistryCredentials != nil {
		imageRegistryCredentialList := make([]storage.ImageRegistryCredential_STATUS, len(group.ImageRegistryCredentials))
		for imageRegistryCredentialIndex, imageRegistryCredentialItem := range group.ImageRegistryCredentials {
			// Shadow the loop variable to avoid aliasing
			imageRegistryCredentialItem := imageRegistryCredentialItem
			var imageRegistryCredential storage.ImageRegistryCredential_STATUS
			err := imageRegistryCredentialItem.AssignProperties_To_ImageRegistryCredential_STATUS(&imageRegistryCredential)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ImageRegistryCredential_STATUS() to populate field ImageRegistryCredentials")
			}
			imageRegistryCredentialList[imageRegistryCredentialIndex] = imageRegistryCredential
		}
		destination.ImageRegistryCredentials = imageRegistryCredentialList
	} else {
		destination.ImageRegistryCredentials = nil
	}

	// InitContainers
	if group.InitContainers != nil {
		initContainerList := make([]storage.InitContainerDefinition_STATUS, len(group.InitContainers))
		for initContainerIndex, initContainerItem := range group.InitContainers {
			// Shadow the loop variable to avoid aliasing
			initContainerItem := initContainerItem
			var initContainer storage.InitContainerDefinition_STATUS
			err := initContainerItem.AssignProperties_To_InitContainerDefinition_STATUS(&initContainer)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_InitContainerDefinition_STATUS() to populate field InitContainers")
			}
			initContainerList[initContainerIndex] = initContainer
		}
		destination.InitContainers = initContainerList
	} else {
		destination.InitContainers = nil
	}

	// InstanceView
	if group.InstanceView != nil {
		var instanceView storage.ContainerGroup_Properties_InstanceView_STATUS
		err := group.InstanceView.AssignProperties_To_ContainerGroup_Properties_InstanceView_STATUS(&instanceView)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ContainerGroup_Properties_InstanceView_STATUS() to populate field InstanceView")
		}
		destination.InstanceView = &instanceView
	} else {
		destination.InstanceView = nil
	}

	// IpAddress
	if group.IpAddress != nil {
		var ipAddress storage.IpAddress_STATUS
		err := group.IpAddress.AssignProperties_To_IpAddress_STATUS(&ipAddress)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_IpAddress_STATUS() to populate field IpAddress")
		}
		destination.IpAddress = &ipAddress
	} else {
		destination.IpAddress = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(group.Location)

	// Name
	destination.Name = genruntime.ClonePointerToString(group.Name)

	// OsType
	if group.OsType != nil {
		osType := string(*group.OsType)
		destination.OsType = &osType
	} else {
		destination.OsType = nil
	}

	// ProvisioningState
	destination.ProvisioningState = genruntime.ClonePointerToString(group.ProvisioningState)

	// RestartPolicy
	if group.RestartPolicy != nil {
		restartPolicy := string(*group.RestartPolicy)
		destination.RestartPolicy = &restartPolicy
	} else {
		destination.RestartPolicy = nil
	}

	// Sku
	if group.Sku != nil {
		sku := string(*group.Sku)
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// SubnetIds
	if group.SubnetIds != nil {
		subnetIdList := make([]storage.ContainerGroupSubnetId_STATUS, len(group.SubnetIds))
		for subnetIdIndex, subnetIdItem := range group.SubnetIds {
			// Shadow the loop variable to avoid aliasing
			subnetIdItem := subnetIdItem
			var subnetId storage.ContainerGroupSubnetId_STATUS
			err := subnetIdItem.AssignProperties_To_ContainerGroupSubnetId_STATUS(&subnetId)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ContainerGroupSubnetId_STATUS() to populate field SubnetIds")
			}
			subnetIdList[subnetIdIndex] = subnetId
		}
		destination.SubnetIds = subnetIdList
	} else {
		destination.SubnetIds = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(group.Tags)

	// Type
	destination.Type = genruntime.ClonePointerToString(group.Type)

	// Volumes
	if group.Volumes != nil {
		volumeList := make([]storage.Volume_STATUS, len(group.Volumes))
		for volumeIndex, volumeItem := range group.Volumes {
			// Shadow the loop variable to avoid aliasing
			volumeItem := volumeItem
			var volume storage.Volume_STATUS
			err := volumeItem.AssignProperties_To_Volume_STATUS(&volume)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_Volume_STATUS() to populate field Volumes")
			}
			volumeList[volumeIndex] = volume
		}
		destination.Volumes = volumeList
	} else {
		destination.Volumes = nil
	}

	// Zones
	destination.Zones = genruntime.CloneSliceOfString(group.Zones)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// A container instance.
type Container struct {
	// Command: The commands to execute within the container instance in exec form.
	Command []string `json:"command,omitempty"`

	// EnvironmentVariables: The environment variables to set in the container instance.
	EnvironmentVariables []EnvironmentVariable `json:"environmentVariables,omitempty"`

	// +kubebuilder:validation:Required
	// Image: The name of the image used to create the container instance.
	Image *string `json:"image,omitempty"`

	// LivenessProbe: The liveness probe.
	LivenessProbe *ContainerProbe `json:"livenessProbe,omitempty"`

	// +kubebuilder:validation:Required
	// Name: The user-provided name of the container instance.
	Name *string `json:"name,omitempty"`

	// Ports: The exposed ports on the container instance.
	Ports []ContainerPort `json:"ports,omitempty"`

	// ReadinessProbe: The readiness probe.
	ReadinessProbe *ContainerProbe `json:"readinessProbe,omitempty"`

	// +kubebuilder:validation:Required
	// Resources: The resource requirements of the container instance.
	Resources *ResourceRequirements `json:"resources,omitempty"`

	// VolumeMounts: The volume mounts available to the container instance.
	VolumeMounts []VolumeMount `json:"volumeMounts,omitempty"`
}

var _ genruntime.ARMTransformer = &Container{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (container *Container) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if container == nil {
		return nil, nil
	}
	result := &arm.Container{}

	// Set property "Name":
	if container.Name != nil {
		name := *container.Name
		result.Name = &name
	}

	// Set property "Properties":
	if container.Command != nil ||
		container.EnvironmentVariables != nil ||
		container.Image != nil ||
		container.LivenessProbe != nil ||
		container.Ports != nil ||
		container.ReadinessProbe != nil ||
		container.Resources != nil ||
		container.VolumeMounts != nil {
		result.Properties = &arm.ContainerProperties{}
	}
	for _, item := range container.Command {
		result.Properties.Command = append(result.Properties.Command, item)
	}
	for _, item := range container.EnvironmentVariables {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.EnvironmentVariables = append(result.Properties.EnvironmentVariables, *item_ARM.(*arm.EnvironmentVariable))
	}
	if container.Image != nil {
		image := *container.Image
		result.Properties.Image = &image
	}
	if container.LivenessProbe != nil {
		livenessProbe_ARM, err := (*container.LivenessProbe).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		livenessProbe := *livenessProbe_ARM.(*arm.ContainerProbe)
		result.Properties.LivenessProbe = &livenessProbe
	}
	for _, item := range container.Ports {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.Ports = append(result.Properties.Ports, *item_ARM.(*arm.ContainerPort))
	}
	if container.ReadinessProbe != nil {
		readinessProbe_ARM, err := (*container.ReadinessProbe).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		readinessProbe := *readinessProbe_ARM.(*arm.ContainerProbe)
		result.Properties.ReadinessProbe = &readinessProbe
	}
	if container.Resources != nil {
		resources_ARM, err := (*container.Resources).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		resources := *resources_ARM.(*arm.ResourceRequirements)
		result.Properties.Resources = &resources
	}
	for _, item := range container.VolumeMounts {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.VolumeMounts = append(result.Properties.VolumeMounts, *item_ARM.(*arm.VolumeMount))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (container *Container) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Container{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (container *Container) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Container)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Container, got %T", armInput)
	}

	// Set property "Command":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Command {
			container.Command = append(container.Command, item)
		}
	}

	// Set property "EnvironmentVariables":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.EnvironmentVariables {
			var item1 EnvironmentVariable
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			container.EnvironmentVariables = append(container.EnvironmentVariables, item1)
		}
	}

	// Set property "Image":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Image != nil {
			image := *typedInput.Properties.Image
			container.Image = &image
		}
	}

	// Set property "LivenessProbe":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.LivenessProbe != nil {
			var livenessProbe1 ContainerProbe
			err := livenessProbe1.PopulateFromARM(owner, *typedInput.Properties.LivenessProbe)
			if err != nil {
				return err
			}
			livenessProbe := livenessProbe1
			container.LivenessProbe = &livenessProbe
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		container.Name = &name
	}

	// Set property "Ports":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Ports {
			var item1 ContainerPort
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			container.Ports = append(container.Ports, item1)
		}
	}

	// Set property "ReadinessProbe":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ReadinessProbe != nil {
			var readinessProbe1 ContainerProbe
			err := readinessProbe1.PopulateFromARM(owner, *typedInput.Properties.ReadinessProbe)
			if err != nil {
				return err
			}
			readinessProbe := readinessProbe1
			container.ReadinessProbe = &readinessProbe
		}
	}

	// Set property "Resources":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Resources != nil {
			var resources1 ResourceRequirements
			err := resources1.PopulateFromARM(owner, *typedInput.Properties.Resources)
			if err != nil {
				return err
			}
			resources := resources1
			container.Resources = &resources
		}
	}

	// Set property "VolumeMounts":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.VolumeMounts {
			var item1 VolumeMount
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			container.VolumeMounts = append(container.VolumeMounts, item1)
		}
	}

	// No error
	return nil
}

// AssignProperties_From_Container populates our Container from the provided source Container
func (container *Container) AssignProperties_From_Container(source *storage.Container) error {

	// Command
	container.Command = genruntime.CloneSliceOfString(source.Command)

	// EnvironmentVariables
	if source.EnvironmentVariables != nil {
		environmentVariableList := make([]EnvironmentVariable, len(source.EnvironmentVariables))
		for environmentVariableIndex, environmentVariableItem := range source.EnvironmentVariables {
			// Shadow the loop variable to avoid aliasing
			environmentVariableItem := environmentVariableItem
			var environmentVariable EnvironmentVariable
			err := environmentVariable.AssignProperties_From_EnvironmentVariable(&environmentVariableItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_EnvironmentVariable() to populate field EnvironmentVariables")
			}
			environmentVariableList[environmentVariableIndex] = environmentVariable
		}
		container.EnvironmentVariables = environmentVariableList
	} else {
		container.EnvironmentVariables = nil
	}

	// Image
	container.Image = genruntime.ClonePointerToString(source.Image)

	// LivenessProbe
	if source.LivenessProbe != nil {
		var livenessProbe ContainerProbe
		err := livenessProbe.AssignProperties_From_ContainerProbe(source.LivenessProbe)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ContainerProbe() to populate field LivenessProbe")
		}
		container.LivenessProbe = &livenessProbe
	} else {
		container.LivenessProbe = nil
	}

	// Name
	container.Name = genruntime.ClonePointerToString(source.Name)

	// Ports
	if source.Ports != nil {
		portList := make([]ContainerPort, len(source.Ports))
		for portIndex, portItem := range source.Ports {
			// Shadow the loop variable to avoid aliasing
			portItem := portItem
			var port ContainerPort
			err := port.AssignProperties_From_ContainerPort(&portItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ContainerPort() to populate field Ports")
			}
			portList[portIndex] = port
		}
		container.Ports = portList
	} else {
		container.Ports = nil
	}

	// ReadinessProbe
	if source.ReadinessProbe != nil {
		var readinessProbe ContainerProbe
		err := readinessProbe.AssignProperties_From_ContainerProbe(source.ReadinessProbe)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ContainerProbe() to populate field ReadinessProbe")
		}
		container.ReadinessProbe = &readinessProbe
	} else {
		container.ReadinessProbe = nil
	}

	// Resources
	if source.Resources != nil {
		var resource ResourceRequirements
		err := resource.AssignProperties_From_ResourceRequirements(source.Resources)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ResourceRequirements() to populate field Resources")
		}
		container.Resources = &resource
	} else {
		container.Resources = nil
	}

	// VolumeMounts
	if source.VolumeMounts != nil {
		volumeMountList := make([]VolumeMount, len(source.VolumeMounts))
		for volumeMountIndex, volumeMountItem := range source.VolumeMounts {
			// Shadow the loop variable to avoid aliasing
			volumeMountItem := volumeMountItem
			var volumeMount VolumeMount
			err := volumeMount.AssignProperties_From_VolumeMount(&volumeMountItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_VolumeMount() to populate field VolumeMounts")
			}
			volumeMountList[volumeMountIndex] = volumeMount
		}
		container.VolumeMounts = volumeMountList
	} else {
		container.VolumeMounts = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Container populates the provided destination Container from our Container
func (container *Container) AssignProperties_To_Container(destination *storage.Container) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Command
	destination.Command = genruntime.CloneSliceOfString(container.Command)

	// EnvironmentVariables
	if container.EnvironmentVariables != nil {
		environmentVariableList := make([]storage.EnvironmentVariable, len(container.EnvironmentVariables))
		for environmentVariableIndex, environmentVariableItem := range container.EnvironmentVariables {
			// Shadow the loop variable to avoid aliasing
			environmentVariableItem := environmentVariableItem
			var environmentVariable storage.EnvironmentVariable
			err := environmentVariableItem.AssignProperties_To_EnvironmentVariable(&environmentVariable)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_EnvironmentVariable() to populate field EnvironmentVariables")
			}
			environmentVariableList[environmentVariableIndex] = environmentVariable
		}
		destination.EnvironmentVariables = environmentVariableList
	} else {
		destination.EnvironmentVariables = nil
	}

	// Image
	destination.Image = genruntime.ClonePointerToString(container.Image)

	// LivenessProbe
	if container.LivenessProbe != nil {
		var livenessProbe storage.ContainerProbe
		err := container.LivenessProbe.AssignProperties_To_ContainerProbe(&livenessProbe)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ContainerProbe() to populate field LivenessProbe")
		}
		destination.LivenessProbe = &livenessProbe
	} else {
		destination.LivenessProbe = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(container.Name)

	// Ports
	if container.Ports != nil {
		portList := make([]storage.ContainerPort, len(container.Ports))
		for portIndex, portItem := range container.Ports {
			// Shadow the loop variable to avoid aliasing
			portItem := portItem
			var port storage.ContainerPort
			err := portItem.AssignProperties_To_ContainerPort(&port)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ContainerPort() to populate field Ports")
			}
			portList[portIndex] = port
		}
		destination.Ports = portList
	} else {
		destination.Ports = nil
	}

	// ReadinessProbe
	if container.ReadinessProbe != nil {
		var readinessProbe storage.ContainerProbe
		err := container.ReadinessProbe.AssignProperties_To_ContainerProbe(&readinessProbe)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ContainerProbe() to populate field ReadinessProbe")
		}
		destination.ReadinessProbe = &readinessProbe
	} else {
		destination.ReadinessProbe = nil
	}

	// Resources
	if container.Resources != nil {
		var resource storage.ResourceRequirements
		err := container.Resources.AssignProperties_To_ResourceRequirements(&resource)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ResourceRequirements() to populate field Resources")
		}
		destination.Resources = &resource
	} else {
		destination.Resources = nil
	}

	// VolumeMounts
	if container.VolumeMounts != nil {
		volumeMountList := make([]storage.VolumeMount, len(container.VolumeMounts))
		for volumeMountIndex, volumeMountItem := range container.VolumeMounts {
			// Shadow the loop variable to avoid aliasing
			volumeMountItem := volumeMountItem
			var volumeMount storage.VolumeMount
			err := volumeMountItem.AssignProperties_To_VolumeMount(&volumeMount)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_VolumeMount() to populate field VolumeMounts")
			}
			volumeMountList[volumeMountIndex] = volumeMount
		}
		destination.VolumeMounts = volumeMountList
	} else {
		destination.VolumeMounts = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_Container_STATUS populates our Container from the provided source Container_STATUS
func (container *Container) Initialize_From_Container_STATUS(source *Container_STATUS) error {

	// Command
	container.Command = genruntime.CloneSliceOfString(source.Command)

	// EnvironmentVariables
	if source.EnvironmentVariables != nil {
		environmentVariableList := make([]EnvironmentVariable, len(source.EnvironmentVariables))
		for environmentVariableIndex, environmentVariableItem := range source.EnvironmentVariables {
			// Shadow the loop variable to avoid aliasing
			environmentVariableItem := environmentVariableItem
			var environmentVariable EnvironmentVariable
			err := environmentVariable.Initialize_From_EnvironmentVariable_STATUS(&environmentVariableItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_EnvironmentVariable_STATUS() to populate field EnvironmentVariables")
			}
			environmentVariableList[environmentVariableIndex] = environmentVariable
		}
		container.EnvironmentVariables = environmentVariableList
	} else {
		container.EnvironmentVariables = nil
	}

	// Image
	container.Image = genruntime.ClonePointerToString(source.Image)

	// LivenessProbe
	if source.LivenessProbe != nil {
		var livenessProbe ContainerProbe
		err := livenessProbe.Initialize_From_ContainerProbe_STATUS(source.LivenessProbe)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_ContainerProbe_STATUS() to populate field LivenessProbe")
		}
		container.LivenessProbe = &livenessProbe
	} else {
		container.LivenessProbe = nil
	}

	// Name
	container.Name = genruntime.ClonePointerToString(source.Name)

	// Ports
	if source.Ports != nil {
		portList := make([]ContainerPort, len(source.Ports))
		for portIndex, portItem := range source.Ports {
			// Shadow the loop variable to avoid aliasing
			portItem := portItem
			var port ContainerPort
			err := port.Initialize_From_ContainerPort_STATUS(&portItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_ContainerPort_STATUS() to populate field Ports")
			}
			portList[portIndex] = port
		}
		container.Ports = portList
	} else {
		container.Ports = nil
	}

	// ReadinessProbe
	if source.ReadinessProbe != nil {
		var readinessProbe ContainerProbe
		err := readinessProbe.Initialize_From_ContainerProbe_STATUS(source.ReadinessProbe)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_ContainerProbe_STATUS() to populate field ReadinessProbe")
		}
		container.ReadinessProbe = &readinessProbe
	} else {
		container.ReadinessProbe = nil
	}

	// Resources
	if source.Resources != nil {
		var resource ResourceRequirements
		err := resource.Initialize_From_ResourceRequirements_STATUS(source.Resources)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_ResourceRequirements_STATUS() to populate field Resources")
		}
		container.Resources = &resource
	} else {
		container.Resources = nil
	}

	// VolumeMounts
	if source.VolumeMounts != nil {
		volumeMountList := make([]VolumeMount, len(source.VolumeMounts))
		for volumeMountIndex, volumeMountItem := range source.VolumeMounts {
			// Shadow the loop variable to avoid aliasing
			volumeMountItem := volumeMountItem
			var volumeMount VolumeMount
			err := volumeMount.Initialize_From_VolumeMount_STATUS(&volumeMountItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_VolumeMount_STATUS() to populate field VolumeMounts")
			}
			volumeMountList[volumeMountIndex] = volumeMount
		}
		container.VolumeMounts = volumeMountList
	} else {
		container.VolumeMounts = nil
	}

	// No error
	return nil
}

// A container instance.
type Container_STATUS struct {
	// Command: The commands to execute within the container instance in exec form.
	Command []string `json:"command,omitempty"`

	// EnvironmentVariables: The environment variables to set in the container instance.
	EnvironmentVariables []EnvironmentVariable_STATUS `json:"environmentVariables,omitempty"`

	// Image: The name of the image used to create the container instance.
	Image *string `json:"image,omitempty"`

	// InstanceView: The instance view of the container instance. Only valid in response.
	InstanceView *ContainerProperties_InstanceView_STATUS `json:"instanceView,omitempty"`

	// LivenessProbe: The liveness probe.
	LivenessProbe *ContainerProbe_STATUS `json:"livenessProbe,omitempty"`

	// Name: The user-provided name of the container instance.
	Name *string `json:"name,omitempty"`

	// Ports: The exposed ports on the container instance.
	Ports []ContainerPort_STATUS `json:"ports,omitempty"`

	// ReadinessProbe: The readiness probe.
	ReadinessProbe *ContainerProbe_STATUS `json:"readinessProbe,omitempty"`

	// Resources: The resource requirements of the container instance.
	Resources *ResourceRequirements_STATUS `json:"resources,omitempty"`

	// VolumeMounts: The volume mounts available to the container instance.
	VolumeMounts []VolumeMount_STATUS `json:"volumeMounts,omitempty"`
}

var _ genruntime.FromARMConverter = &Container_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (container *Container_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Container_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (container *Container_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Container_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Container_STATUS, got %T", armInput)
	}

	// Set property "Command":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Command {
			container.Command = append(container.Command, item)
		}
	}

	// Set property "EnvironmentVariables":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.EnvironmentVariables {
			var item1 EnvironmentVariable_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			container.EnvironmentVariables = append(container.EnvironmentVariables, item1)
		}
	}

	// Set property "Image":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Image != nil {
			image := *typedInput.Properties.Image
			container.Image = &image
		}
	}

	// Set property "InstanceView":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.InstanceView != nil {
			var instanceView1 ContainerProperties_InstanceView_STATUS
			err := instanceView1.PopulateFromARM(owner, *typedInput.Properties.InstanceView)
			if err != nil {
				return err
			}
			instanceView := instanceView1
			container.InstanceView = &instanceView
		}
	}

	// Set property "LivenessProbe":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.LivenessProbe != nil {
			var livenessProbe1 ContainerProbe_STATUS
			err := livenessProbe1.PopulateFromARM(owner, *typedInput.Properties.LivenessProbe)
			if err != nil {
				return err
			}
			livenessProbe := livenessProbe1
			container.LivenessProbe = &livenessProbe
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		container.Name = &name
	}

	// Set property "Ports":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Ports {
			var item1 ContainerPort_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			container.Ports = append(container.Ports, item1)
		}
	}

	// Set property "ReadinessProbe":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ReadinessProbe != nil {
			var readinessProbe1 ContainerProbe_STATUS
			err := readinessProbe1.PopulateFromARM(owner, *typedInput.Properties.ReadinessProbe)
			if err != nil {
				return err
			}
			readinessProbe := readinessProbe1
			container.ReadinessProbe = &readinessProbe
		}
	}

	// Set property "Resources":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Resources != nil {
			var resources1 ResourceRequirements_STATUS
			err := resources1.PopulateFromARM(owner, *typedInput.Properties.Resources)
			if err != nil {
				return err
			}
			resources := resources1
			container.Resources = &resources
		}
	}

	// Set property "VolumeMounts":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.VolumeMounts {
			var item1 VolumeMount_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			container.VolumeMounts = append(container.VolumeMounts, item1)
		}
	}

	// No error
	return nil
}

// AssignProperties_From_Container_STATUS populates our Container_STATUS from the provided source Container_STATUS
func (container *Container_STATUS) AssignProperties_From_Container_STATUS(source *storage.Container_STATUS) error {

	// Command
	container.Command = genruntime.CloneSliceOfString(source.Command)

	// EnvironmentVariables
	if source.EnvironmentVariables != nil {
		environmentVariableList := make([]EnvironmentVariable_STATUS, len(source.EnvironmentVariables))
		for environmentVariableIndex, environmentVariableItem := range source.EnvironmentVariables {
			// Shadow the loop variable to avoid aliasing
			environmentVariableItem := environmentVariableItem
			var environmentVariable EnvironmentVariable_STATUS
			err := environmentVariable.AssignProperties_From_EnvironmentVariable_STATUS(&environmentVariableItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_EnvironmentVariable_STATUS() to populate field EnvironmentVariables")
			}
			environmentVariableList[environmentVariableIndex] = environmentVariable
		}
		container.EnvironmentVariables = environmentVariableList
	} else {
		container.EnvironmentVariables = nil
	}

	// Image
	container.Image = genruntime.ClonePointerToString(source.Image)

	// InstanceView
	if source.InstanceView != nil {
		var instanceView ContainerProperties_InstanceView_STATUS
		err := instanceView.AssignProperties_From_ContainerProperties_InstanceView_STATUS(source.InstanceView)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ContainerProperties_InstanceView_STATUS() to populate field InstanceView")
		}
		container.InstanceView = &instanceView
	} else {
		container.InstanceView = nil
	}

	// LivenessProbe
	if source.LivenessProbe != nil {
		var livenessProbe ContainerProbe_STATUS
		err := livenessProbe.AssignProperties_From_ContainerProbe_STATUS(source.LivenessProbe)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ContainerProbe_STATUS() to populate field LivenessProbe")
		}
		container.LivenessProbe = &livenessProbe
	} else {
		container.LivenessProbe = nil
	}

	// Name
	container.Name = genruntime.ClonePointerToString(source.Name)

	// Ports
	if source.Ports != nil {
		portList := make([]ContainerPort_STATUS, len(source.Ports))
		for portIndex, portItem := range source.Ports {
			// Shadow the loop variable to avoid aliasing
			portItem := portItem
			var port ContainerPort_STATUS
			err := port.AssignProperties_From_ContainerPort_STATUS(&portItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ContainerPort_STATUS() to populate field Ports")
			}
			portList[portIndex] = port
		}
		container.Ports = portList
	} else {
		container.Ports = nil
	}

	// ReadinessProbe
	if source.ReadinessProbe != nil {
		var readinessProbe ContainerProbe_STATUS
		err := readinessProbe.AssignProperties_From_ContainerProbe_STATUS(source.ReadinessProbe)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ContainerProbe_STATUS() to populate field ReadinessProbe")
		}
		container.ReadinessProbe = &readinessProbe
	} else {
		container.ReadinessProbe = nil
	}

	// Resources
	if source.Resources != nil {
		var resource ResourceRequirements_STATUS
		err := resource.AssignProperties_From_ResourceRequirements_STATUS(source.Resources)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ResourceRequirements_STATUS() to populate field Resources")
		}
		container.Resources = &resource
	} else {
		container.Resources = nil
	}

	// VolumeMounts
	if source.VolumeMounts != nil {
		volumeMountList := make([]VolumeMount_STATUS, len(source.VolumeMounts))
		for volumeMountIndex, volumeMountItem := range source.VolumeMounts {
			// Shadow the loop variable to avoid aliasing
			volumeMountItem := volumeMountItem
			var volumeMount VolumeMount_STATUS
			err := volumeMount.AssignProperties_From_VolumeMount_STATUS(&volumeMountItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_VolumeMount_STATUS() to populate field VolumeMounts")
			}
			volumeMountList[volumeMountIndex] = volumeMount
		}
		container.VolumeMounts = volumeMountList
	} else {
		container.VolumeMounts = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Container_STATUS populates the provided destination Container_STATUS from our Container_STATUS
func (container *Container_STATUS) AssignProperties_To_Container_STATUS(destination *storage.Container_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Command
	destination.Command = genruntime.CloneSliceOfString(container.Command)

	// EnvironmentVariables
	if container.EnvironmentVariables != nil {
		environmentVariableList := make([]storage.EnvironmentVariable_STATUS, len(container.EnvironmentVariables))
		for environmentVariableIndex, environmentVariableItem := range container.EnvironmentVariables {
			// Shadow the loop variable to avoid aliasing
			environmentVariableItem := environmentVariableItem
			var environmentVariable storage.EnvironmentVariable_STATUS
			err := environmentVariableItem.AssignProperties_To_EnvironmentVariable_STATUS(&environmentVariable)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_EnvironmentVariable_STATUS() to populate field EnvironmentVariables")
			}
			environmentVariableList[environmentVariableIndex] = environmentVariable
		}
		destination.EnvironmentVariables = environmentVariableList
	} else {
		destination.EnvironmentVariables = nil
	}

	// Image
	destination.Image = genruntime.ClonePointerToString(container.Image)

	// InstanceView
	if container.InstanceView != nil {
		var instanceView storage.ContainerProperties_InstanceView_STATUS
		err := container.InstanceView.AssignProperties_To_ContainerProperties_InstanceView_STATUS(&instanceView)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ContainerProperties_InstanceView_STATUS() to populate field InstanceView")
		}
		destination.InstanceView = &instanceView
	} else {
		destination.InstanceView = nil
	}

	// LivenessProbe
	if container.LivenessProbe != nil {
		var livenessProbe storage.ContainerProbe_STATUS
		err := container.LivenessProbe.AssignProperties_To_ContainerProbe_STATUS(&livenessProbe)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ContainerProbe_STATUS() to populate field LivenessProbe")
		}
		destination.LivenessProbe = &livenessProbe
	} else {
		destination.LivenessProbe = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(container.Name)

	// Ports
	if container.Ports != nil {
		portList := make([]storage.ContainerPort_STATUS, len(container.Ports))
		for portIndex, portItem := range container.Ports {
			// Shadow the loop variable to avoid aliasing
			portItem := portItem
			var port storage.ContainerPort_STATUS
			err := portItem.AssignProperties_To_ContainerPort_STATUS(&port)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ContainerPort_STATUS() to populate field Ports")
			}
			portList[portIndex] = port
		}
		destination.Ports = portList
	} else {
		destination.Ports = nil
	}

	// ReadinessProbe
	if container.ReadinessProbe != nil {
		var readinessProbe storage.ContainerProbe_STATUS
		err := container.ReadinessProbe.AssignProperties_To_ContainerProbe_STATUS(&readinessProbe)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ContainerProbe_STATUS() to populate field ReadinessProbe")
		}
		destination.ReadinessProbe = &readinessProbe
	} else {
		destination.ReadinessProbe = nil
	}

	// Resources
	if container.Resources != nil {
		var resource storage.ResourceRequirements_STATUS
		err := container.Resources.AssignProperties_To_ResourceRequirements_STATUS(&resource)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ResourceRequirements_STATUS() to populate field Resources")
		}
		destination.Resources = &resource
	} else {
		destination.Resources = nil
	}

	// VolumeMounts
	if container.VolumeMounts != nil {
		volumeMountList := make([]storage.VolumeMount_STATUS, len(container.VolumeMounts))
		for volumeMountIndex, volumeMountItem := range container.VolumeMounts {
			// Shadow the loop variable to avoid aliasing
			volumeMountItem := volumeMountItem
			var volumeMount storage.VolumeMount_STATUS
			err := volumeMountItem.AssignProperties_To_VolumeMount_STATUS(&volumeMount)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_VolumeMount_STATUS() to populate field VolumeMounts")
			}
			volumeMountList[volumeMountIndex] = volumeMount
		}
		destination.VolumeMounts = volumeMountList
	} else {
		destination.VolumeMounts = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ContainerGroup_Properties_InstanceView_STATUS struct {
	// Events: The events of this container group.
	Events []Event_STATUS `json:"events,omitempty"`

	// State: The state of the container group. Only valid in response.
	State *string `json:"state,omitempty"`
}

var _ genruntime.FromARMConverter = &ContainerGroup_Properties_InstanceView_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (view *ContainerGroup_Properties_InstanceView_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ContainerGroup_Properties_InstanceView_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (view *ContainerGroup_Properties_InstanceView_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ContainerGroup_Properties_InstanceView_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ContainerGroup_Properties_InstanceView_STATUS, got %T", armInput)
	}

	// Set property "Events":
	for _, item := range typedInput.Events {
		var item1 Event_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		view.Events = append(view.Events, item1)
	}

	// Set property "State":
	if typedInput.State != nil {
		state := *typedInput.State
		view.State = &state
	}

	// No error
	return nil
}

// AssignProperties_From_ContainerGroup_Properties_InstanceView_STATUS populates our ContainerGroup_Properties_InstanceView_STATUS from the provided source ContainerGroup_Properties_InstanceView_STATUS
func (view *ContainerGroup_Properties_InstanceView_STATUS) AssignProperties_From_ContainerGroup_Properties_InstanceView_STATUS(source *storage.ContainerGroup_Properties_InstanceView_STATUS) error {

	// Events
	if source.Events != nil {
		eventList := make([]Event_STATUS, len(source.Events))
		for eventIndex, eventItem := range source.Events {
			// Shadow the loop variable to avoid aliasing
			eventItem := eventItem
			var event Event_STATUS
			err := event.AssignProperties_From_Event_STATUS(&eventItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_Event_STATUS() to populate field Events")
			}
			eventList[eventIndex] = event
		}
		view.Events = eventList
	} else {
		view.Events = nil
	}

	// State
	view.State = genruntime.ClonePointerToString(source.State)

	// No error
	return nil
}

// AssignProperties_To_ContainerGroup_Properties_InstanceView_STATUS populates the provided destination ContainerGroup_Properties_InstanceView_STATUS from our ContainerGroup_Properties_InstanceView_STATUS
func (view *ContainerGroup_Properties_InstanceView_STATUS) AssignProperties_To_ContainerGroup_Properties_InstanceView_STATUS(destination *storage.ContainerGroup_Properties_InstanceView_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Events
	if view.Events != nil {
		eventList := make([]storage.Event_STATUS, len(view.Events))
		for eventIndex, eventItem := range view.Events {
			// Shadow the loop variable to avoid aliasing
			eventItem := eventItem
			var event storage.Event_STATUS
			err := eventItem.AssignProperties_To_Event_STATUS(&event)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_Event_STATUS() to populate field Events")
			}
			eventList[eventIndex] = event
		}
		destination.Events = eventList
	} else {
		destination.Events = nil
	}

	// State
	destination.State = genruntime.ClonePointerToString(view.State)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Linux","Windows"}
type ContainerGroup_Properties_OsType_Spec string

const (
	ContainerGroup_Properties_OsType_Spec_Linux   = ContainerGroup_Properties_OsType_Spec("Linux")
	ContainerGroup_Properties_OsType_Spec_Windows = ContainerGroup_Properties_OsType_Spec("Windows")
)

// Mapping from string to ContainerGroup_Properties_OsType_Spec
var containerGroup_Properties_OsType_Spec_Values = map[string]ContainerGroup_Properties_OsType_Spec{
	"linux":   ContainerGroup_Properties_OsType_Spec_Linux,
	"windows": ContainerGroup_Properties_OsType_Spec_Windows,
}

type ContainerGroup_Properties_OsType_STATUS string

const (
	ContainerGroup_Properties_OsType_STATUS_Linux   = ContainerGroup_Properties_OsType_STATUS("Linux")
	ContainerGroup_Properties_OsType_STATUS_Windows = ContainerGroup_Properties_OsType_STATUS("Windows")
)

// Mapping from string to ContainerGroup_Properties_OsType_STATUS
var containerGroup_Properties_OsType_STATUS_Values = map[string]ContainerGroup_Properties_OsType_STATUS{
	"linux":   ContainerGroup_Properties_OsType_STATUS_Linux,
	"windows": ContainerGroup_Properties_OsType_STATUS_Windows,
}

// +kubebuilder:validation:Enum={"Always","Never","OnFailure"}
type ContainerGroup_Properties_RestartPolicy_Spec string

const (
	ContainerGroup_Properties_RestartPolicy_Spec_Always    = ContainerGroup_Properties_RestartPolicy_Spec("Always")
	ContainerGroup_Properties_RestartPolicy_Spec_Never     = ContainerGroup_Properties_RestartPolicy_Spec("Never")
	ContainerGroup_Properties_RestartPolicy_Spec_OnFailure = ContainerGroup_Properties_RestartPolicy_Spec("OnFailure")
)

// Mapping from string to ContainerGroup_Properties_RestartPolicy_Spec
var containerGroup_Properties_RestartPolicy_Spec_Values = map[string]ContainerGroup_Properties_RestartPolicy_Spec{
	"always":    ContainerGroup_Properties_RestartPolicy_Spec_Always,
	"never":     ContainerGroup_Properties_RestartPolicy_Spec_Never,
	"onfailure": ContainerGroup_Properties_RestartPolicy_Spec_OnFailure,
}

type ContainerGroup_Properties_RestartPolicy_STATUS string

const (
	ContainerGroup_Properties_RestartPolicy_STATUS_Always    = ContainerGroup_Properties_RestartPolicy_STATUS("Always")
	ContainerGroup_Properties_RestartPolicy_STATUS_Never     = ContainerGroup_Properties_RestartPolicy_STATUS("Never")
	ContainerGroup_Properties_RestartPolicy_STATUS_OnFailure = ContainerGroup_Properties_RestartPolicy_STATUS("OnFailure")
)

// Mapping from string to ContainerGroup_Properties_RestartPolicy_STATUS
var containerGroup_Properties_RestartPolicy_STATUS_Values = map[string]ContainerGroup_Properties_RestartPolicy_STATUS{
	"always":    ContainerGroup_Properties_RestartPolicy_STATUS_Always,
	"never":     ContainerGroup_Properties_RestartPolicy_STATUS_Never,
	"onfailure": ContainerGroup_Properties_RestartPolicy_STATUS_OnFailure,
}

// Container group diagnostic information.
type ContainerGroupDiagnostics struct {
	// LogAnalytics: Container group log analytics information.
	LogAnalytics *LogAnalytics `json:"logAnalytics,omitempty"`
}

var _ genruntime.ARMTransformer = &ContainerGroupDiagnostics{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (diagnostics *ContainerGroupDiagnostics) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if diagnostics == nil {
		return nil, nil
	}
	result := &arm.ContainerGroupDiagnostics{}

	// Set property "LogAnalytics":
	if diagnostics.LogAnalytics != nil {
		logAnalytics_ARM, err := (*diagnostics.LogAnalytics).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		logAnalytics := *logAnalytics_ARM.(*arm.LogAnalytics)
		result.LogAnalytics = &logAnalytics
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (diagnostics *ContainerGroupDiagnostics) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ContainerGroupDiagnostics{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (diagnostics *ContainerGroupDiagnostics) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ContainerGroupDiagnostics)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ContainerGroupDiagnostics, got %T", armInput)
	}

	// Set property "LogAnalytics":
	if typedInput.LogAnalytics != nil {
		var logAnalytics1 LogAnalytics
		err := logAnalytics1.PopulateFromARM(owner, *typedInput.LogAnalytics)
		if err != nil {
			return err
		}
		logAnalytics := logAnalytics1
		diagnostics.LogAnalytics = &logAnalytics
	}

	// No error
	return nil
}

// AssignProperties_From_ContainerGroupDiagnostics populates our ContainerGroupDiagnostics from the provided source ContainerGroupDiagnostics
func (diagnostics *ContainerGroupDiagnostics) AssignProperties_From_ContainerGroupDiagnostics(source *storage.ContainerGroupDiagnostics) error {

	// LogAnalytics
	if source.LogAnalytics != nil {
		var logAnalytic LogAnalytics
		err := logAnalytic.AssignProperties_From_LogAnalytics(source.LogAnalytics)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_LogAnalytics() to populate field LogAnalytics")
		}
		diagnostics.LogAnalytics = &logAnalytic
	} else {
		diagnostics.LogAnalytics = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ContainerGroupDiagnostics populates the provided destination ContainerGroupDiagnostics from our ContainerGroupDiagnostics
func (diagnostics *ContainerGroupDiagnostics) AssignProperties_To_ContainerGroupDiagnostics(destination *storage.ContainerGroupDiagnostics) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// LogAnalytics
	if diagnostics.LogAnalytics != nil {
		var logAnalytic storage.LogAnalytics
		err := diagnostics.LogAnalytics.AssignProperties_To_LogAnalytics(&logAnalytic)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_LogAnalytics() to populate field LogAnalytics")
		}
		destination.LogAnalytics = &logAnalytic
	} else {
		destination.LogAnalytics = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ContainerGroupDiagnostics_STATUS populates our ContainerGroupDiagnostics from the provided source ContainerGroupDiagnostics_STATUS
func (diagnostics *ContainerGroupDiagnostics) Initialize_From_ContainerGroupDiagnostics_STATUS(source *ContainerGroupDiagnostics_STATUS) error {

	// LogAnalytics
	if source.LogAnalytics != nil {
		var logAnalytic LogAnalytics
		err := logAnalytic.Initialize_From_LogAnalytics_STATUS(source.LogAnalytics)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_LogAnalytics_STATUS() to populate field LogAnalytics")
		}
		diagnostics.LogAnalytics = &logAnalytic
	} else {
		diagnostics.LogAnalytics = nil
	}

	// No error
	return nil
}

// Container group diagnostic information.
type ContainerGroupDiagnostics_STATUS struct {
	// LogAnalytics: Container group log analytics information.
	LogAnalytics *LogAnalytics_STATUS `json:"logAnalytics,omitempty"`
}

var _ genruntime.FromARMConverter = &ContainerGroupDiagnostics_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (diagnostics *ContainerGroupDiagnostics_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ContainerGroupDiagnostics_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (diagnostics *ContainerGroupDiagnostics_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ContainerGroupDiagnostics_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ContainerGroupDiagnostics_STATUS, got %T", armInput)
	}

	// Set property "LogAnalytics":
	if typedInput.LogAnalytics != nil {
		var logAnalytics1 LogAnalytics_STATUS
		err := logAnalytics1.PopulateFromARM(owner, *typedInput.LogAnalytics)
		if err != nil {
			return err
		}
		logAnalytics := logAnalytics1
		diagnostics.LogAnalytics = &logAnalytics
	}

	// No error
	return nil
}

// AssignProperties_From_ContainerGroupDiagnostics_STATUS populates our ContainerGroupDiagnostics_STATUS from the provided source ContainerGroupDiagnostics_STATUS
func (diagnostics *ContainerGroupDiagnostics_STATUS) AssignProperties_From_ContainerGroupDiagnostics_STATUS(source *storage.ContainerGroupDiagnostics_STATUS) error {

	// LogAnalytics
	if source.LogAnalytics != nil {
		var logAnalytic LogAnalytics_STATUS
		err := logAnalytic.AssignProperties_From_LogAnalytics_STATUS(source.LogAnalytics)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_LogAnalytics_STATUS() to populate field LogAnalytics")
		}
		diagnostics.LogAnalytics = &logAnalytic
	} else {
		diagnostics.LogAnalytics = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ContainerGroupDiagnostics_STATUS populates the provided destination ContainerGroupDiagnostics_STATUS from our ContainerGroupDiagnostics_STATUS
func (diagnostics *ContainerGroupDiagnostics_STATUS) AssignProperties_To_ContainerGroupDiagnostics_STATUS(destination *storage.ContainerGroupDiagnostics_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// LogAnalytics
	if diagnostics.LogAnalytics != nil {
		var logAnalytic storage.LogAnalytics_STATUS
		err := diagnostics.LogAnalytics.AssignProperties_To_LogAnalytics_STATUS(&logAnalytic)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_LogAnalytics_STATUS() to populate field LogAnalytics")
		}
		destination.LogAnalytics = &logAnalytic
	} else {
		destination.LogAnalytics = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Identity for the container group.
type ContainerGroupIdentity struct {
	// Type: The type of identity used for the container group. The type 'SystemAssigned, UserAssigned' includes both an
	// implicitly created identity and a set of user assigned identities. The type 'None' will remove any identities from the
	// container group.
	Type *ContainerGroupIdentity_Type `json:"type,omitempty"`

	// UserAssignedIdentities: The list of user identities associated with the container group.
	UserAssignedIdentities []UserAssignedIdentityDetails `json:"userAssignedIdentities,omitempty"`
}

var _ genruntime.ARMTransformer = &ContainerGroupIdentity{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (identity *ContainerGroupIdentity) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if identity == nil {
		return nil, nil
	}
	result := &arm.ContainerGroupIdentity{}

	// Set property "Type":
	if identity.Type != nil {
		var temp string
		temp = string(*identity.Type)
		typeVar := arm.ContainerGroupIdentity_Type(temp)
		result.Type = &typeVar
	}

	// Set property "UserAssignedIdentities":
	result.UserAssignedIdentities = make(map[string]arm.UserAssignedIdentityDetails, len(identity.UserAssignedIdentities))
	for _, ident := range identity.UserAssignedIdentities {
		identARMID, err := resolved.ResolvedReferences.Lookup(ident.Reference)
		if err != nil {
			return nil, err
		}
		key := identARMID
		result.UserAssignedIdentities[key] = arm.UserAssignedIdentityDetails{}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *ContainerGroupIdentity) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ContainerGroupIdentity{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *ContainerGroupIdentity) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ContainerGroupIdentity)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ContainerGroupIdentity, got %T", armInput)
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := ContainerGroupIdentity_Type(temp)
		identity.Type = &typeVar
	}

	// no assignment for property "UserAssignedIdentities"

	// No error
	return nil
}

// AssignProperties_From_ContainerGroupIdentity populates our ContainerGroupIdentity from the provided source ContainerGroupIdentity
func (identity *ContainerGroupIdentity) AssignProperties_From_ContainerGroupIdentity(source *storage.ContainerGroupIdentity) error {

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, containerGroupIdentity_Type_Values)
		identity.Type = &typeTemp
	} else {
		identity.Type = nil
	}

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]UserAssignedIdentityDetails, len(source.UserAssignedIdentities))
		for userAssignedIdentityIndex, userAssignedIdentityItem := range source.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityItem := userAssignedIdentityItem
			var userAssignedIdentity UserAssignedIdentityDetails
			err := userAssignedIdentity.AssignProperties_From_UserAssignedIdentityDetails(&userAssignedIdentityItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_UserAssignedIdentityDetails() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityList[userAssignedIdentityIndex] = userAssignedIdentity
		}
		identity.UserAssignedIdentities = userAssignedIdentityList
	} else {
		identity.UserAssignedIdentities = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ContainerGroupIdentity populates the provided destination ContainerGroupIdentity from our ContainerGroupIdentity
func (identity *ContainerGroupIdentity) AssignProperties_To_ContainerGroupIdentity(destination *storage.ContainerGroupIdentity) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Type
	if identity.Type != nil {
		typeVar := string(*identity.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// UserAssignedIdentities
	if identity.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]storage.UserAssignedIdentityDetails, len(identity.UserAssignedIdentities))
		for userAssignedIdentityIndex, userAssignedIdentityItem := range identity.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityItem := userAssignedIdentityItem
			var userAssignedIdentity storage.UserAssignedIdentityDetails
			err := userAssignedIdentityItem.AssignProperties_To_UserAssignedIdentityDetails(&userAssignedIdentity)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_UserAssignedIdentityDetails() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityList[userAssignedIdentityIndex] = userAssignedIdentity
		}
		destination.UserAssignedIdentities = userAssignedIdentityList
	} else {
		destination.UserAssignedIdentities = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ContainerGroupIdentity_STATUS populates our ContainerGroupIdentity from the provided source ContainerGroupIdentity_STATUS
func (identity *ContainerGroupIdentity) Initialize_From_ContainerGroupIdentity_STATUS(source *ContainerGroupIdentity_STATUS) error {

	// Type
	if source.Type != nil {
		typeVar := genruntime.ToEnum(string(*source.Type), containerGroupIdentity_Type_Values)
		identity.Type = &typeVar
	} else {
		identity.Type = nil
	}

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]UserAssignedIdentityDetails, 0, len(source.UserAssignedIdentities))
		for userAssignedIdentitiesKey := range source.UserAssignedIdentities {
			userAssignedIdentitiesRef := genruntime.CreateResourceReferenceFromARMID(userAssignedIdentitiesKey)
			userAssignedIdentityList = append(userAssignedIdentityList, UserAssignedIdentityDetails{Reference: userAssignedIdentitiesRef})
		}
		identity.UserAssignedIdentities = userAssignedIdentityList
	} else {
		identity.UserAssignedIdentities = nil
	}

	// No error
	return nil
}

// Identity for the container group.
type ContainerGroupIdentity_STATUS struct {
	// PrincipalId: The principal id of the container group identity. This property will only be provided for a system assigned
	// identity.
	PrincipalId *string `json:"principalId,omitempty"`

	// TenantId: The tenant id associated with the container group. This property will only be provided for a system assigned
	// identity.
	TenantId *string `json:"tenantId,omitempty"`

	// Type: The type of identity used for the container group. The type 'SystemAssigned, UserAssigned' includes both an
	// implicitly created identity and a set of user assigned identities. The type 'None' will remove any identities from the
	// container group.
	Type *ContainerGroupIdentity_Type_STATUS `json:"type,omitempty"`

	// UserAssignedIdentities: The list of user identities associated with the container group.
	UserAssignedIdentities map[string]UserAssignedIdentities_STATUS `json:"userAssignedIdentities,omitempty"`
}

var _ genruntime.FromARMConverter = &ContainerGroupIdentity_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *ContainerGroupIdentity_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ContainerGroupIdentity_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *ContainerGroupIdentity_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ContainerGroupIdentity_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ContainerGroupIdentity_STATUS, got %T", armInput)
	}

	// Set property "PrincipalId":
	if typedInput.PrincipalId != nil {
		principalId := *typedInput.PrincipalId
		identity.PrincipalId = &principalId
	}

	// Set property "TenantId":
	if typedInput.TenantId != nil {
		tenantId := *typedInput.TenantId
		identity.TenantId = &tenantId
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := ContainerGroupIdentity_Type_STATUS(temp)
		identity.Type = &typeVar
	}

	// Set property "UserAssignedIdentities":
	if typedInput.UserAssignedIdentities != nil {
		identity.UserAssignedIdentities = make(map[string]UserAssignedIdentities_STATUS, len(typedInput.UserAssignedIdentities))
		for key, value := range typedInput.UserAssignedIdentities {
			var value1 UserAssignedIdentities_STATUS
			err := value1.PopulateFromARM(owner, value)
			if err != nil {
				return err
			}
			identity.UserAssignedIdentities[key] = value1
		}
	}

	// No error
	return nil
}

// AssignProperties_From_ContainerGroupIdentity_STATUS populates our ContainerGroupIdentity_STATUS from the provided source ContainerGroupIdentity_STATUS
func (identity *ContainerGroupIdentity_STATUS) AssignProperties_From_ContainerGroupIdentity_STATUS(source *storage.ContainerGroupIdentity_STATUS) error {

	// PrincipalId
	identity.PrincipalId = genruntime.ClonePointerToString(source.PrincipalId)

	// TenantId
	identity.TenantId = genruntime.ClonePointerToString(source.TenantId)

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, containerGroupIdentity_Type_STATUS_Values)
		identity.Type = &typeTemp
	} else {
		identity.Type = nil
	}

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityMap := make(map[string]UserAssignedIdentities_STATUS, len(source.UserAssignedIdentities))
		for userAssignedIdentityKey, userAssignedIdentityValue := range source.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityValue := userAssignedIdentityValue
			var userAssignedIdentity UserAssignedIdentities_STATUS
			err := userAssignedIdentity.AssignProperties_From_UserAssignedIdentities_STATUS(&userAssignedIdentityValue)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_UserAssignedIdentities_STATUS() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityMap[userAssignedIdentityKey] = userAssignedIdentity
		}
		identity.UserAssignedIdentities = userAssignedIdentityMap
	} else {
		identity.UserAssignedIdentities = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ContainerGroupIdentity_STATUS populates the provided destination ContainerGroupIdentity_STATUS from our ContainerGroupIdentity_STATUS
func (identity *ContainerGroupIdentity_STATUS) AssignProperties_To_ContainerGroupIdentity_STATUS(destination *storage.ContainerGroupIdentity_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PrincipalId
	destination.PrincipalId = genruntime.ClonePointerToString(identity.PrincipalId)

	// TenantId
	destination.TenantId = genruntime.ClonePointerToString(identity.TenantId)

	// Type
	if identity.Type != nil {
		typeVar := string(*identity.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// UserAssignedIdentities
	if identity.UserAssignedIdentities != nil {
		userAssignedIdentityMap := make(map[string]storage.UserAssignedIdentities_STATUS, len(identity.UserAssignedIdentities))
		for userAssignedIdentityKey, userAssignedIdentityValue := range identity.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityValue := userAssignedIdentityValue
			var userAssignedIdentity storage.UserAssignedIdentities_STATUS
			err := userAssignedIdentityValue.AssignProperties_To_UserAssignedIdentities_STATUS(&userAssignedIdentity)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_UserAssignedIdentities_STATUS() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityMap[userAssignedIdentityKey] = userAssignedIdentity
		}
		destination.UserAssignedIdentities = userAssignedIdentityMap
	} else {
		destination.UserAssignedIdentities = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Details for configuring operator behavior. Fields in this struct are interpreted by the operator directly rather than being passed to Azure
type ContainerGroupOperatorSpec struct {
	// ConfigMapExpressions: configures where to place operator written dynamic ConfigMaps (created with CEL expressions).
	ConfigMapExpressions []*core.DestinationExpression `json:"configMapExpressions,omitempty"`

	// SecretExpressions: configures where to place operator written dynamic secrets (created with CEL expressions).
	SecretExpressions []*core.DestinationExpression `json:"secretExpressions,omitempty"`
}

// AssignProperties_From_ContainerGroupOperatorSpec populates our ContainerGroupOperatorSpec from the provided source ContainerGroupOperatorSpec
func (operator *ContainerGroupOperatorSpec) AssignProperties_From_ContainerGroupOperatorSpec(source *storage.ContainerGroupOperatorSpec) error {

	// ConfigMapExpressions
	if source.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(source.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range source.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		operator.ConfigMapExpressions = configMapExpressionList
	} else {
		operator.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if source.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(source.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range source.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		operator.SecretExpressions = secretExpressionList
	} else {
		operator.SecretExpressions = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ContainerGroupOperatorSpec populates the provided destination ContainerGroupOperatorSpec from our ContainerGroupOperatorSpec
func (operator *ContainerGroupOperatorSpec) AssignProperties_To_ContainerGroupOperatorSpec(destination *storage.ContainerGroupOperatorSpec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ConfigMapExpressions
	if operator.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(operator.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range operator.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		destination.ConfigMapExpressions = configMapExpressionList
	} else {
		destination.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if operator.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(operator.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range operator.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		destination.SecretExpressions = secretExpressionList
	} else {
		destination.SecretExpressions = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The container group SKU.
// +kubebuilder:validation:Enum={"Dedicated","Standard"}
type ContainerGroupSku string

const (
	ContainerGroupSku_Dedicated = ContainerGroupSku("Dedicated")
	ContainerGroupSku_Standard  = ContainerGroupSku("Standard")
)

// Mapping from string to ContainerGroupSku
var containerGroupSku_Values = map[string]ContainerGroupSku{
	"dedicated": ContainerGroupSku_Dedicated,
	"standard":  ContainerGroupSku_Standard,
}

// The container group SKU.
type ContainerGroupSku_STATUS string

const (
	ContainerGroupSku_STATUS_Dedicated = ContainerGroupSku_STATUS("Dedicated")
	ContainerGroupSku_STATUS_Standard  = ContainerGroupSku_STATUS("Standard")
)

// Mapping from string to ContainerGroupSku_STATUS
var containerGroupSku_STATUS_Values = map[string]ContainerGroupSku_STATUS{
	"dedicated": ContainerGroupSku_STATUS_Dedicated,
	"standard":  ContainerGroupSku_STATUS_Standard,
}

// Container group subnet information.
type ContainerGroupSubnetId struct {
	// Name: Friendly name for the subnet.
	Name *string `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// Reference: Resource ID of virtual network and subnet.
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

var _ genruntime.ARMTransformer = &ContainerGroupSubnetId{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (subnetId *ContainerGroupSubnetId) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if subnetId == nil {
		return nil, nil
	}
	result := &arm.ContainerGroupSubnetId{}

	// Set property "Id":
	if subnetId.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.Lookup(*subnetId.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}

	// Set property "Name":
	if subnetId.Name != nil {
		name := *subnetId.Name
		result.Name = &name
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (subnetId *ContainerGroupSubnetId) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ContainerGroupSubnetId{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (subnetId *ContainerGroupSubnetId) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ContainerGroupSubnetId)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ContainerGroupSubnetId, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		subnetId.Name = &name
	}

	// no assignment for property "Reference"

	// No error
	return nil
}

// AssignProperties_From_ContainerGroupSubnetId populates our ContainerGroupSubnetId from the provided source ContainerGroupSubnetId
func (subnetId *ContainerGroupSubnetId) AssignProperties_From_ContainerGroupSubnetId(source *storage.ContainerGroupSubnetId) error {

	// Name
	subnetId.Name = genruntime.ClonePointerToString(source.Name)

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		subnetId.Reference = &reference
	} else {
		subnetId.Reference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ContainerGroupSubnetId populates the provided destination ContainerGroupSubnetId from our ContainerGroupSubnetId
func (subnetId *ContainerGroupSubnetId) AssignProperties_To_ContainerGroupSubnetId(destination *storage.ContainerGroupSubnetId) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(subnetId.Name)

	// Reference
	if subnetId.Reference != nil {
		reference := subnetId.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ContainerGroupSubnetId_STATUS populates our ContainerGroupSubnetId from the provided source ContainerGroupSubnetId_STATUS
func (subnetId *ContainerGroupSubnetId) Initialize_From_ContainerGroupSubnetId_STATUS(source *ContainerGroupSubnetId_STATUS) error {

	// Name
	subnetId.Name = genruntime.ClonePointerToString(source.Name)

	// Reference
	if source.Id != nil {
		reference := genruntime.CreateResourceReferenceFromARMID(*source.Id)
		subnetId.Reference = &reference
	} else {
		subnetId.Reference = nil
	}

	// No error
	return nil
}

// Container group subnet information.
type ContainerGroupSubnetId_STATUS struct {
	// Id: Resource ID of virtual network and subnet.
	Id *string `json:"id,omitempty"`

	// Name: Friendly name for the subnet.
	Name *string `json:"name,omitempty"`
}

var _ genruntime.FromARMConverter = &ContainerGroupSubnetId_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (subnetId *ContainerGroupSubnetId_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ContainerGroupSubnetId_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (subnetId *ContainerGroupSubnetId_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ContainerGroupSubnetId_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ContainerGroupSubnetId_STATUS, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		subnetId.Id = &id
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		subnetId.Name = &name
	}

	// No error
	return nil
}

// AssignProperties_From_ContainerGroupSubnetId_STATUS populates our ContainerGroupSubnetId_STATUS from the provided source ContainerGroupSubnetId_STATUS
func (subnetId *ContainerGroupSubnetId_STATUS) AssignProperties_From_ContainerGroupSubnetId_STATUS(source *storage.ContainerGroupSubnetId_STATUS) error {

	// Id
	subnetId.Id = genruntime.ClonePointerToString(source.Id)

	// Name
	subnetId.Name = genruntime.ClonePointerToString(source.Name)

	// No error
	return nil
}

// AssignProperties_To_ContainerGroupSubnetId_STATUS populates the provided destination ContainerGroupSubnetId_STATUS from our ContainerGroupSubnetId_STATUS
func (subnetId *ContainerGroupSubnetId_STATUS) AssignProperties_To_ContainerGroupSubnetId_STATUS(destination *storage.ContainerGroupSubnetId_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(subnetId.Id)

	// Name
	destination.Name = genruntime.ClonePointerToString(subnetId.Name)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// DNS configuration for the container group.
type DnsConfiguration struct {
	// +kubebuilder:validation:Required
	// NameServers: The DNS servers for the container group.
	NameServers []string `json:"nameServers,omitempty"`

	// Options: The DNS options for the container group.
	Options *string `json:"options,omitempty"`

	// SearchDomains: The DNS search domains for hostname lookup in the container group.
	SearchDomains *string `json:"searchDomains,omitempty"`
}

var _ genruntime.ARMTransformer = &DnsConfiguration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (configuration *DnsConfiguration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if configuration == nil {
		return nil, nil
	}
	result := &arm.DnsConfiguration{}

	// Set property "NameServers":
	for _, item := range configuration.NameServers {
		result.NameServers = append(result.NameServers, item)
	}

	// Set property "Options":
	if configuration.Options != nil {
		options := *configuration.Options
		result.Options = &options
	}

	// Set property "SearchDomains":
	if configuration.SearchDomains != nil {
		searchDomains := *configuration.SearchDomains
		result.SearchDomains = &searchDomains
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *DnsConfiguration) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DnsConfiguration{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *DnsConfiguration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DnsConfiguration)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DnsConfiguration, got %T", armInput)
	}

	// Set property "NameServers":
	for _, item := range typedInput.NameServers {
		configuration.NameServers = append(configuration.NameServers, item)
	}

	// Set property "Options":
	if typedInput.Options != nil {
		options := *typedInput.Options
		configuration.Options = &options
	}

	// Set property "SearchDomains":
	if typedInput.SearchDomains != nil {
		searchDomains := *typedInput.SearchDomains
		configuration.SearchDomains = &searchDomains
	}

	// No error
	return nil
}

// AssignProperties_From_DnsConfiguration populates our DnsConfiguration from the provided source DnsConfiguration
func (configuration *DnsConfiguration) AssignProperties_From_DnsConfiguration(source *storage.DnsConfiguration) error {

	// NameServers
	configuration.NameServers = genruntime.CloneSliceOfString(source.NameServers)

	// Options
	configuration.Options = genruntime.ClonePointerToString(source.Options)

	// SearchDomains
	configuration.SearchDomains = genruntime.ClonePointerToString(source.SearchDomains)

	// No error
	return nil
}

// AssignProperties_To_DnsConfiguration populates the provided destination DnsConfiguration from our DnsConfiguration
func (configuration *DnsConfiguration) AssignProperties_To_DnsConfiguration(destination *storage.DnsConfiguration) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// NameServers
	destination.NameServers = genruntime.CloneSliceOfString(configuration.NameServers)

	// Options
	destination.Options = genruntime.ClonePointerToString(configuration.Options)

	// SearchDomains
	destination.SearchDomains = genruntime.ClonePointerToString(configuration.SearchDomains)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DnsConfiguration_STATUS populates our DnsConfiguration from the provided source DnsConfiguration_STATUS
func (configuration *DnsConfiguration) Initialize_From_DnsConfiguration_STATUS(source *DnsConfiguration_STATUS) error {

	// NameServers
	configuration.NameServers = genruntime.CloneSliceOfString(source.NameServers)

	// Options
	configuration.Options = genruntime.ClonePointerToString(source.Options)

	// SearchDomains
	configuration.SearchDomains = genruntime.ClonePointerToString(source.SearchDomains)

	// No error
	return nil
}

// DNS configuration for the container group.
type DnsConfiguration_STATUS struct {
	// NameServers: The DNS servers for the container group.
	NameServers []string `json:"nameServers,omitempty"`

	// Options: The DNS options for the container group.
	Options *string `json:"options,omitempty"`

	// SearchDomains: The DNS search domains for hostname lookup in the container group.
	SearchDomains *string `json:"searchDomains,omitempty"`
}

var _ genruntime.FromARMConverter = &DnsConfiguration_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *DnsConfiguration_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DnsConfiguration_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *DnsConfiguration_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DnsConfiguration_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DnsConfiguration_STATUS, got %T", armInput)
	}

	// Set property "NameServers":
	for _, item := range typedInput.NameServers {
		configuration.NameServers = append(configuration.NameServers, item)
	}

	// Set property "Options":
	if typedInput.Options != nil {
		options := *typedInput.Options
		configuration.Options = &options
	}

	// Set property "SearchDomains":
	if typedInput.SearchDomains != nil {
		searchDomains := *typedInput.SearchDomains
		configuration.SearchDomains = &searchDomains
	}

	// No error
	return nil
}

// AssignProperties_From_DnsConfiguration_STATUS populates our DnsConfiguration_STATUS from the provided source DnsConfiguration_STATUS
func (configuration *DnsConfiguration_STATUS) AssignProperties_From_DnsConfiguration_STATUS(source *storage.DnsConfiguration_STATUS) error {

	// NameServers
	configuration.NameServers = genruntime.CloneSliceOfString(source.NameServers)

	// Options
	configuration.Options = genruntime.ClonePointerToString(source.Options)

	// SearchDomains
	configuration.SearchDomains = genruntime.ClonePointerToString(source.SearchDomains)

	// No error
	return nil
}

// AssignProperties_To_DnsConfiguration_STATUS populates the provided destination DnsConfiguration_STATUS from our DnsConfiguration_STATUS
func (configuration *DnsConfiguration_STATUS) AssignProperties_To_DnsConfiguration_STATUS(destination *storage.DnsConfiguration_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// NameServers
	destination.NameServers = genruntime.CloneSliceOfString(configuration.NameServers)

	// Options
	destination.Options = genruntime.ClonePointerToString(configuration.Options)

	// SearchDomains
	destination.SearchDomains = genruntime.ClonePointerToString(configuration.SearchDomains)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The container group encryption properties.
type EncryptionProperties struct {
	// +kubebuilder:validation:Required
	// KeyName: The encryption key name.
	KeyName *string `json:"keyName,omitempty"`

	// +kubebuilder:validation:Required
	// KeyVersion: The encryption key version.
	KeyVersion *string `json:"keyVersion,omitempty"`

	// +kubebuilder:validation:Required
	// VaultBaseUrl: The keyvault base url.
	VaultBaseUrl *string `json:"vaultBaseUrl,omitempty"`
}

var _ genruntime.ARMTransformer = &EncryptionProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *EncryptionProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &arm.EncryptionProperties{}

	// Set property "KeyName":
	if properties.KeyName != nil {
		keyName := *properties.KeyName
		result.KeyName = &keyName
	}

	// Set property "KeyVersion":
	if properties.KeyVersion != nil {
		keyVersion := *properties.KeyVersion
		result.KeyVersion = &keyVersion
	}

	// Set property "VaultBaseUrl":
	if properties.VaultBaseUrl != nil {
		vaultBaseUrl := *properties.VaultBaseUrl
		result.VaultBaseUrl = &vaultBaseUrl
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *EncryptionProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.EncryptionProperties{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *EncryptionProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.EncryptionProperties)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.EncryptionProperties, got %T", armInput)
	}

	// Set property "KeyName":
	if typedInput.KeyName != nil {
		keyName := *typedInput.KeyName
		properties.KeyName = &keyName
	}

	// Set property "KeyVersion":
	if typedInput.KeyVersion != nil {
		keyVersion := *typedInput.KeyVersion
		properties.KeyVersion = &keyVersion
	}

	// Set property "VaultBaseUrl":
	if typedInput.VaultBaseUrl != nil {
		vaultBaseUrl := *typedInput.VaultBaseUrl
		properties.VaultBaseUrl = &vaultBaseUrl
	}

	// No error
	return nil
}

// AssignProperties_From_EncryptionProperties populates our EncryptionProperties from the provided source EncryptionProperties
func (properties *EncryptionProperties) AssignProperties_From_EncryptionProperties(source *storage.EncryptionProperties) error {

	// KeyName
	properties.KeyName = genruntime.ClonePointerToString(source.KeyName)

	// KeyVersion
	properties.KeyVersion = genruntime.ClonePointerToString(source.KeyVersion)

	// VaultBaseUrl
	properties.VaultBaseUrl = genruntime.ClonePointerToString(source.VaultBaseUrl)

	// No error
	return nil
}

// AssignProperties_To_EncryptionProperties populates the provided destination EncryptionProperties from our EncryptionProperties
func (properties *EncryptionProperties) AssignProperties_To_EncryptionProperties(destination *storage.EncryptionProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// KeyName
	destination.KeyName = genruntime.ClonePointerToString(properties.KeyName)

	// KeyVersion
	destination.KeyVersion = genruntime.ClonePointerToString(properties.KeyVersion)

	// VaultBaseUrl
	destination.VaultBaseUrl = genruntime.ClonePointerToString(properties.VaultBaseUrl)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_EncryptionProperties_STATUS populates our EncryptionProperties from the provided source EncryptionProperties_STATUS
func (properties *EncryptionProperties) Initialize_From_EncryptionProperties_STATUS(source *EncryptionProperties_STATUS) error {

	// KeyName
	properties.KeyName = genruntime.ClonePointerToString(source.KeyName)

	// KeyVersion
	properties.KeyVersion = genruntime.ClonePointerToString(source.KeyVersion)

	// VaultBaseUrl
	properties.VaultBaseUrl = genruntime.ClonePointerToString(source.VaultBaseUrl)

	// No error
	return nil
}

// The container group encryption properties.
type EncryptionProperties_STATUS struct {
	// KeyName: The encryption key name.
	KeyName *string `json:"keyName,omitempty"`

	// KeyVersion: The encryption key version.
	KeyVersion *string `json:"keyVersion,omitempty"`

	// VaultBaseUrl: The keyvault base url.
	VaultBaseUrl *string `json:"vaultBaseUrl,omitempty"`
}

var _ genruntime.FromARMConverter = &EncryptionProperties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *EncryptionProperties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.EncryptionProperties_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *EncryptionProperties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.EncryptionProperties_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.EncryptionProperties_STATUS, got %T", armInput)
	}

	// Set property "KeyName":
	if typedInput.KeyName != nil {
		keyName := *typedInput.KeyName
		properties.KeyName = &keyName
	}

	// Set property "KeyVersion":
	if typedInput.KeyVersion != nil {
		keyVersion := *typedInput.KeyVersion
		properties.KeyVersion = &keyVersion
	}

	// Set property "VaultBaseUrl":
	if typedInput.VaultBaseUrl != nil {
		vaultBaseUrl := *typedInput.VaultBaseUrl
		properties.VaultBaseUrl = &vaultBaseUrl
	}

	// No error
	return nil
}

// AssignProperties_From_EncryptionProperties_STATUS populates our EncryptionProperties_STATUS from the provided source EncryptionProperties_STATUS
func (properties *EncryptionProperties_STATUS) AssignProperties_From_EncryptionProperties_STATUS(source *storage.EncryptionProperties_STATUS) error {

	// KeyName
	properties.KeyName = genruntime.ClonePointerToString(source.KeyName)

	// KeyVersion
	properties.KeyVersion = genruntime.ClonePointerToString(source.KeyVersion)

	// VaultBaseUrl
	properties.VaultBaseUrl = genruntime.ClonePointerToString(source.VaultBaseUrl)

	// No error
	return nil
}

// AssignProperties_To_EncryptionProperties_STATUS populates the provided destination EncryptionProperties_STATUS from our EncryptionProperties_STATUS
func (properties *EncryptionProperties_STATUS) AssignProperties_To_EncryptionProperties_STATUS(destination *storage.EncryptionProperties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// KeyName
	destination.KeyName = genruntime.ClonePointerToString(properties.KeyName)

	// KeyVersion
	destination.KeyVersion = genruntime.ClonePointerToString(properties.KeyVersion)

	// VaultBaseUrl
	destination.VaultBaseUrl = genruntime.ClonePointerToString(properties.VaultBaseUrl)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Image registry credential.
type ImageRegistryCredential struct {
	// Identity: The identity for the private registry.
	Identity *string `json:"identity,omitempty"`

	// IdentityUrl: The identity URL for the private registry.
	IdentityUrl *string `json:"identityUrl,omitempty"`

	// Password: The password for the private registry.
	Password *genruntime.SecretReference `json:"password,omitempty"`

	// +kubebuilder:validation:Required
	// Server: The Docker image registry server without a protocol such as "http" and "https".
	Server *string `json:"server,omitempty"`

	// Username: The username for the private registry.
	Username *string `json:"username,omitempty"`
}

var _ genruntime.ARMTransformer = &ImageRegistryCredential{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (credential *ImageRegistryCredential) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if credential == nil {
		return nil, nil
	}
	result := &arm.ImageRegistryCredential{}

	// Set property "Identity":
	if credential.Identity != nil {
		identity := *credential.Identity
		result.Identity = &identity
	}

	// Set property "IdentityUrl":
	if credential.IdentityUrl != nil {
		identityUrl := *credential.IdentityUrl
		result.IdentityUrl = &identityUrl
	}

	// Set property "Password":
	if credential.Password != nil {
		passwordSecret, err := resolved.ResolvedSecrets.Lookup(*credential.Password)
		if err != nil {
			return nil, errors.Wrap(err, "looking up secret for property Password")
		}
		password := passwordSecret
		result.Password = &password
	}

	// Set property "Server":
	if credential.Server != nil {
		server := *credential.Server
		result.Server = &server
	}

	// Set property "Username":
	if credential.Username != nil {
		username := *credential.Username
		result.Username = &username
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (credential *ImageRegistryCredential) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ImageRegistryCredential{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (credential *ImageRegistryCredential) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ImageRegistryCredential)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ImageRegistryCredential, got %T", armInput)
	}

	// Set property "Identity":
	if typedInput.Identity != nil {
		identity := *typedInput.Identity
		credential.Identity = &identity
	}

	// Set property "IdentityUrl":
	if typedInput.IdentityUrl != nil {
		identityUrl := *typedInput.IdentityUrl
		credential.IdentityUrl = &identityUrl
	}

	// no assignment for property "Password"

	// Set property "Server":
	if typedInput.Server != nil {
		server := *typedInput.Server
		credential.Server = &server
	}

	// Set property "Username":
	if typedInput.Username != nil {
		username := *typedInput.Username
		credential.Username = &username
	}

	// No error
	return nil
}

// AssignProperties_From_ImageRegistryCredential populates our ImageRegistryCredential from the provided source ImageRegistryCredential
func (credential *ImageRegistryCredential) AssignProperties_From_ImageRegistryCredential(source *storage.ImageRegistryCredential) error {

	// Identity
	credential.Identity = genruntime.ClonePointerToString(source.Identity)

	// IdentityUrl
	credential.IdentityUrl = genruntime.ClonePointerToString(source.IdentityUrl)

	// Password
	if source.Password != nil {
		password := source.Password.Copy()
		credential.Password = &password
	} else {
		credential.Password = nil
	}

	// Server
	credential.Server = genruntime.ClonePointerToString(source.Server)

	// Username
	credential.Username = genruntime.ClonePointerToString(source.Username)

	// No error
	return nil
}

// AssignProperties_To_ImageRegistryCredential populates the provided destination ImageRegistryCredential from our ImageRegistryCredential
func (credential *ImageRegistryCredential) AssignProperties_To_ImageRegistryCredential(destination *storage.ImageRegistryCredential) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Identity
	destination.Identity = genruntime.ClonePointerToString(credential.Identity)

	// IdentityUrl
	destination.IdentityUrl = genruntime.ClonePointerToString(credential.IdentityUrl)

	// Password
	if credential.Password != nil {
		password := credential.Password.Copy()
		destination.Password = &password
	} else {
		destination.Password = nil
	}

	// Server
	destination.Server = genruntime.ClonePointerToString(credential.Server)

	// Username
	destination.Username = genruntime.ClonePointerToString(credential.Username)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ImageRegistryCredential_STATUS populates our ImageRegistryCredential from the provided source ImageRegistryCredential_STATUS
func (credential *ImageRegistryCredential) Initialize_From_ImageRegistryCredential_STATUS(source *ImageRegistryCredential_STATUS) error {

	// Identity
	credential.Identity = genruntime.ClonePointerToString(source.Identity)

	// IdentityUrl
	credential.IdentityUrl = genruntime.ClonePointerToString(source.IdentityUrl)

	// Server
	credential.Server = genruntime.ClonePointerToString(source.Server)

	// Username
	credential.Username = genruntime.ClonePointerToString(source.Username)

	// No error
	return nil
}

// Image registry credential.
type ImageRegistryCredential_STATUS struct {
	// Identity: The identity for the private registry.
	Identity *string `json:"identity,omitempty"`

	// IdentityUrl: The identity URL for the private registry.
	IdentityUrl *string `json:"identityUrl,omitempty"`

	// Server: The Docker image registry server without a protocol such as "http" and "https".
	Server *string `json:"server,omitempty"`

	// Username: The username for the private registry.
	Username *string `json:"username,omitempty"`
}

var _ genruntime.FromARMConverter = &ImageRegistryCredential_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (credential *ImageRegistryCredential_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ImageRegistryCredential_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (credential *ImageRegistryCredential_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ImageRegistryCredential_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ImageRegistryCredential_STATUS, got %T", armInput)
	}

	// Set property "Identity":
	if typedInput.Identity != nil {
		identity := *typedInput.Identity
		credential.Identity = &identity
	}

	// Set property "IdentityUrl":
	if typedInput.IdentityUrl != nil {
		identityUrl := *typedInput.IdentityUrl
		credential.IdentityUrl = &identityUrl
	}

	// Set property "Server":
	if typedInput.Server != nil {
		server := *typedInput.Server
		credential.Server = &server
	}

	// Set property "Username":
	if typedInput.Username != nil {
		username := *typedInput.Username
		credential.Username = &username
	}

	// No error
	return nil
}

// AssignProperties_From_ImageRegistryCredential_STATUS populates our ImageRegistryCredential_STATUS from the provided source ImageRegistryCredential_STATUS
func (credential *ImageRegistryCredential_STATUS) AssignProperties_From_ImageRegistryCredential_STATUS(source *storage.ImageRegistryCredential_STATUS) error {

	// Identity
	credential.Identity = genruntime.ClonePointerToString(source.Identity)

	// IdentityUrl
	credential.IdentityUrl = genruntime.ClonePointerToString(source.IdentityUrl)

	// Server
	credential.Server = genruntime.ClonePointerToString(source.Server)

	// Username
	credential.Username = genruntime.ClonePointerToString(source.Username)

	// No error
	return nil
}

// AssignProperties_To_ImageRegistryCredential_STATUS populates the provided destination ImageRegistryCredential_STATUS from our ImageRegistryCredential_STATUS
func (credential *ImageRegistryCredential_STATUS) AssignProperties_To_ImageRegistryCredential_STATUS(destination *storage.ImageRegistryCredential_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Identity
	destination.Identity = genruntime.ClonePointerToString(credential.Identity)

	// IdentityUrl
	destination.IdentityUrl = genruntime.ClonePointerToString(credential.IdentityUrl)

	// Server
	destination.Server = genruntime.ClonePointerToString(credential.Server)

	// Username
	destination.Username = genruntime.ClonePointerToString(credential.Username)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The init container definition.
type InitContainerDefinition struct {
	// Command: The command to execute within the init container in exec form.
	Command []string `json:"command,omitempty"`

	// EnvironmentVariables: The environment variables to set in the init container.
	EnvironmentVariables []EnvironmentVariable `json:"environmentVariables,omitempty"`

	// Image: The image of the init container.
	Image *string `json:"image,omitempty"`

	// +kubebuilder:validation:Required
	// Name: The name for the init container.
	Name *string `json:"name,omitempty"`

	// VolumeMounts: The volume mounts available to the init container.
	VolumeMounts []VolumeMount `json:"volumeMounts,omitempty"`
}

var _ genruntime.ARMTransformer = &InitContainerDefinition{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (definition *InitContainerDefinition) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if definition == nil {
		return nil, nil
	}
	result := &arm.InitContainerDefinition{}

	// Set property "Name":
	if definition.Name != nil {
		name := *definition.Name
		result.Name = &name
	}

	// Set property "Properties":
	if definition.Command != nil ||
		definition.EnvironmentVariables != nil ||
		definition.Image != nil ||
		definition.VolumeMounts != nil {
		result.Properties = &arm.InitContainerPropertiesDefinition{}
	}
	for _, item := range definition.Command {
		result.Properties.Command = append(result.Properties.Command, item)
	}
	for _, item := range definition.EnvironmentVariables {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.EnvironmentVariables = append(result.Properties.EnvironmentVariables, *item_ARM.(*arm.EnvironmentVariable))
	}
	if definition.Image != nil {
		image := *definition.Image
		result.Properties.Image = &image
	}
	for _, item := range definition.VolumeMounts {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.VolumeMounts = append(result.Properties.VolumeMounts, *item_ARM.(*arm.VolumeMount))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (definition *InitContainerDefinition) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.InitContainerDefinition{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (definition *InitContainerDefinition) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.InitContainerDefinition)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.InitContainerDefinition, got %T", armInput)
	}

	// Set property "Command":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Command {
			definition.Command = append(definition.Command, item)
		}
	}

	// Set property "EnvironmentVariables":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.EnvironmentVariables {
			var item1 EnvironmentVariable
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			definition.EnvironmentVariables = append(definition.EnvironmentVariables, item1)
		}
	}

	// Set property "Image":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Image != nil {
			image := *typedInput.Properties.Image
			definition.Image = &image
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		definition.Name = &name
	}

	// Set property "VolumeMounts":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.VolumeMounts {
			var item1 VolumeMount
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			definition.VolumeMounts = append(definition.VolumeMounts, item1)
		}
	}

	// No error
	return nil
}

// AssignProperties_From_InitContainerDefinition populates our InitContainerDefinition from the provided source InitContainerDefinition
func (definition *InitContainerDefinition) AssignProperties_From_InitContainerDefinition(source *storage.InitContainerDefinition) error {

	// Command
	definition.Command = genruntime.CloneSliceOfString(source.Command)

	// EnvironmentVariables
	if source.EnvironmentVariables != nil {
		environmentVariableList := make([]EnvironmentVariable, len(source.EnvironmentVariables))
		for environmentVariableIndex, environmentVariableItem := range source.EnvironmentVariables {
			// Shadow the loop variable to avoid aliasing
			environmentVariableItem := environmentVariableItem
			var environmentVariable EnvironmentVariable
			err := environmentVariable.AssignProperties_From_EnvironmentVariable(&environmentVariableItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_EnvironmentVariable() to populate field EnvironmentVariables")
			}
			environmentVariableList[environmentVariableIndex] = environmentVariable
		}
		definition.EnvironmentVariables = environmentVariableList
	} else {
		definition.EnvironmentVariables = nil
	}

	// Image
	definition.Image = genruntime.ClonePointerToString(source.Image)

	// Name
	definition.Name = genruntime.ClonePointerToString(source.Name)

	// VolumeMounts
	if source.VolumeMounts != nil {
		volumeMountList := make([]VolumeMount, len(source.VolumeMounts))
		for volumeMountIndex, volumeMountItem := range source.VolumeMounts {
			// Shadow the loop variable to avoid aliasing
			volumeMountItem := volumeMountItem
			var volumeMount VolumeMount
			err := volumeMount.AssignProperties_From_VolumeMount(&volumeMountItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_VolumeMount() to populate field VolumeMounts")
			}
			volumeMountList[volumeMountIndex] = volumeMount
		}
		definition.VolumeMounts = volumeMountList
	} else {
		definition.VolumeMounts = nil
	}

	// No error
	return nil
}

// AssignProperties_To_InitContainerDefinition populates the provided destination InitContainerDefinition from our InitContainerDefinition
func (definition *InitContainerDefinition) AssignProperties_To_InitContainerDefinition(destination *storage.InitContainerDefinition) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Command
	destination.Command = genruntime.CloneSliceOfString(definition.Command)

	// EnvironmentVariables
	if definition.EnvironmentVariables != nil {
		environmentVariableList := make([]storage.EnvironmentVariable, len(definition.EnvironmentVariables))
		for environmentVariableIndex, environmentVariableItem := range definition.EnvironmentVariables {
			// Shadow the loop variable to avoid aliasing
			environmentVariableItem := environmentVariableItem
			var environmentVariable storage.EnvironmentVariable
			err := environmentVariableItem.AssignProperties_To_EnvironmentVariable(&environmentVariable)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_EnvironmentVariable() to populate field EnvironmentVariables")
			}
			environmentVariableList[environmentVariableIndex] = environmentVariable
		}
		destination.EnvironmentVariables = environmentVariableList
	} else {
		destination.EnvironmentVariables = nil
	}

	// Image
	destination.Image = genruntime.ClonePointerToString(definition.Image)

	// Name
	destination.Name = genruntime.ClonePointerToString(definition.Name)

	// VolumeMounts
	if definition.VolumeMounts != nil {
		volumeMountList := make([]storage.VolumeMount, len(definition.VolumeMounts))
		for volumeMountIndex, volumeMountItem := range definition.VolumeMounts {
			// Shadow the loop variable to avoid aliasing
			volumeMountItem := volumeMountItem
			var volumeMount storage.VolumeMount
			err := volumeMountItem.AssignProperties_To_VolumeMount(&volumeMount)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_VolumeMount() to populate field VolumeMounts")
			}
			volumeMountList[volumeMountIndex] = volumeMount
		}
		destination.VolumeMounts = volumeMountList
	} else {
		destination.VolumeMounts = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_InitContainerDefinition_STATUS populates our InitContainerDefinition from the provided source InitContainerDefinition_STATUS
func (definition *InitContainerDefinition) Initialize_From_InitContainerDefinition_STATUS(source *InitContainerDefinition_STATUS) error {

	// Command
	definition.Command = genruntime.CloneSliceOfString(source.Command)

	// EnvironmentVariables
	if source.EnvironmentVariables != nil {
		environmentVariableList := make([]EnvironmentVariable, len(source.EnvironmentVariables))
		for environmentVariableIndex, environmentVariableItem := range source.EnvironmentVariables {
			// Shadow the loop variable to avoid aliasing
			environmentVariableItem := environmentVariableItem
			var environmentVariable EnvironmentVariable
			err := environmentVariable.Initialize_From_EnvironmentVariable_STATUS(&environmentVariableItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_EnvironmentVariable_STATUS() to populate field EnvironmentVariables")
			}
			environmentVariableList[environmentVariableIndex] = environmentVariable
		}
		definition.EnvironmentVariables = environmentVariableList
	} else {
		definition.EnvironmentVariables = nil
	}

	// Image
	definition.Image = genruntime.ClonePointerToString(source.Image)

	// Name
	definition.Name = genruntime.ClonePointerToString(source.Name)

	// VolumeMounts
	if source.VolumeMounts != nil {
		volumeMountList := make([]VolumeMount, len(source.VolumeMounts))
		for volumeMountIndex, volumeMountItem := range source.VolumeMounts {
			// Shadow the loop variable to avoid aliasing
			volumeMountItem := volumeMountItem
			var volumeMount VolumeMount
			err := volumeMount.Initialize_From_VolumeMount_STATUS(&volumeMountItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_VolumeMount_STATUS() to populate field VolumeMounts")
			}
			volumeMountList[volumeMountIndex] = volumeMount
		}
		definition.VolumeMounts = volumeMountList
	} else {
		definition.VolumeMounts = nil
	}

	// No error
	return nil
}

// The init container definition.
type InitContainerDefinition_STATUS struct {
	// Command: The command to execute within the init container in exec form.
	Command []string `json:"command,omitempty"`

	// EnvironmentVariables: The environment variables to set in the init container.
	EnvironmentVariables []EnvironmentVariable_STATUS `json:"environmentVariables,omitempty"`

	// Image: The image of the init container.
	Image *string `json:"image,omitempty"`

	// InstanceView: The instance view of the init container. Only valid in response.
	InstanceView *InitContainerPropertiesDefinition_InstanceView_STATUS `json:"instanceView,omitempty"`

	// Name: The name for the init container.
	Name *string `json:"name,omitempty"`

	// VolumeMounts: The volume mounts available to the init container.
	VolumeMounts []VolumeMount_STATUS `json:"volumeMounts,omitempty"`
}

var _ genruntime.FromARMConverter = &InitContainerDefinition_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (definition *InitContainerDefinition_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.InitContainerDefinition_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (definition *InitContainerDefinition_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.InitContainerDefinition_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.InitContainerDefinition_STATUS, got %T", armInput)
	}

	// Set property "Command":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Command {
			definition.Command = append(definition.Command, item)
		}
	}

	// Set property "EnvironmentVariables":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.EnvironmentVariables {
			var item1 EnvironmentVariable_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			definition.EnvironmentVariables = append(definition.EnvironmentVariables, item1)
		}
	}

	// Set property "Image":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Image != nil {
			image := *typedInput.Properties.Image
			definition.Image = &image
		}
	}

	// Set property "InstanceView":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.InstanceView != nil {
			var instanceView1 InitContainerPropertiesDefinition_InstanceView_STATUS
			err := instanceView1.PopulateFromARM(owner, *typedInput.Properties.InstanceView)
			if err != nil {
				return err
			}
			instanceView := instanceView1
			definition.InstanceView = &instanceView
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		definition.Name = &name
	}

	// Set property "VolumeMounts":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.VolumeMounts {
			var item1 VolumeMount_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			definition.VolumeMounts = append(definition.VolumeMounts, item1)
		}
	}

	// No error
	return nil
}

// AssignProperties_From_InitContainerDefinition_STATUS populates our InitContainerDefinition_STATUS from the provided source InitContainerDefinition_STATUS
func (definition *InitContainerDefinition_STATUS) AssignProperties_From_InitContainerDefinition_STATUS(source *storage.InitContainerDefinition_STATUS) error {

	// Command
	definition.Command = genruntime.CloneSliceOfString(source.Command)

	// EnvironmentVariables
	if source.EnvironmentVariables != nil {
		environmentVariableList := make([]EnvironmentVariable_STATUS, len(source.EnvironmentVariables))
		for environmentVariableIndex, environmentVariableItem := range source.EnvironmentVariables {
			// Shadow the loop variable to avoid aliasing
			environmentVariableItem := environmentVariableItem
			var environmentVariable EnvironmentVariable_STATUS
			err := environmentVariable.AssignProperties_From_EnvironmentVariable_STATUS(&environmentVariableItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_EnvironmentVariable_STATUS() to populate field EnvironmentVariables")
			}
			environmentVariableList[environmentVariableIndex] = environmentVariable
		}
		definition.EnvironmentVariables = environmentVariableList
	} else {
		definition.EnvironmentVariables = nil
	}

	// Image
	definition.Image = genruntime.ClonePointerToString(source.Image)

	// InstanceView
	if source.InstanceView != nil {
		var instanceView InitContainerPropertiesDefinition_InstanceView_STATUS
		err := instanceView.AssignProperties_From_InitContainerPropertiesDefinition_InstanceView_STATUS(source.InstanceView)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_InitContainerPropertiesDefinition_InstanceView_STATUS() to populate field InstanceView")
		}
		definition.InstanceView = &instanceView
	} else {
		definition.InstanceView = nil
	}

	// Name
	definition.Name = genruntime.ClonePointerToString(source.Name)

	// VolumeMounts
	if source.VolumeMounts != nil {
		volumeMountList := make([]VolumeMount_STATUS, len(source.VolumeMounts))
		for volumeMountIndex, volumeMountItem := range source.VolumeMounts {
			// Shadow the loop variable to avoid aliasing
			volumeMountItem := volumeMountItem
			var volumeMount VolumeMount_STATUS
			err := volumeMount.AssignProperties_From_VolumeMount_STATUS(&volumeMountItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_VolumeMount_STATUS() to populate field VolumeMounts")
			}
			volumeMountList[volumeMountIndex] = volumeMount
		}
		definition.VolumeMounts = volumeMountList
	} else {
		definition.VolumeMounts = nil
	}

	// No error
	return nil
}

// AssignProperties_To_InitContainerDefinition_STATUS populates the provided destination InitContainerDefinition_STATUS from our InitContainerDefinition_STATUS
func (definition *InitContainerDefinition_STATUS) AssignProperties_To_InitContainerDefinition_STATUS(destination *storage.InitContainerDefinition_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Command
	destination.Command = genruntime.CloneSliceOfString(definition.Command)

	// EnvironmentVariables
	if definition.EnvironmentVariables != nil {
		environmentVariableList := make([]storage.EnvironmentVariable_STATUS, len(definition.EnvironmentVariables))
		for environmentVariableIndex, environmentVariableItem := range definition.EnvironmentVariables {
			// Shadow the loop variable to avoid aliasing
			environmentVariableItem := environmentVariableItem
			var environmentVariable storage.EnvironmentVariable_STATUS
			err := environmentVariableItem.AssignProperties_To_EnvironmentVariable_STATUS(&environmentVariable)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_EnvironmentVariable_STATUS() to populate field EnvironmentVariables")
			}
			environmentVariableList[environmentVariableIndex] = environmentVariable
		}
		destination.EnvironmentVariables = environmentVariableList
	} else {
		destination.EnvironmentVariables = nil
	}

	// Image
	destination.Image = genruntime.ClonePointerToString(definition.Image)

	// InstanceView
	if definition.InstanceView != nil {
		var instanceView storage.InitContainerPropertiesDefinition_InstanceView_STATUS
		err := definition.InstanceView.AssignProperties_To_InitContainerPropertiesDefinition_InstanceView_STATUS(&instanceView)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_InitContainerPropertiesDefinition_InstanceView_STATUS() to populate field InstanceView")
		}
		destination.InstanceView = &instanceView
	} else {
		destination.InstanceView = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(definition.Name)

	// VolumeMounts
	if definition.VolumeMounts != nil {
		volumeMountList := make([]storage.VolumeMount_STATUS, len(definition.VolumeMounts))
		for volumeMountIndex, volumeMountItem := range definition.VolumeMounts {
			// Shadow the loop variable to avoid aliasing
			volumeMountItem := volumeMountItem
			var volumeMount storage.VolumeMount_STATUS
			err := volumeMountItem.AssignProperties_To_VolumeMount_STATUS(&volumeMount)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_VolumeMount_STATUS() to populate field VolumeMounts")
			}
			volumeMountList[volumeMountIndex] = volumeMount
		}
		destination.VolumeMounts = volumeMountList
	} else {
		destination.VolumeMounts = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// IP address for the container group.
type IpAddress struct {
	// AutoGeneratedDomainNameLabelScope: The value representing the security enum. The 'Unsecure' value is the default value
	// if not selected and means the object's domain name label is not secured against subdomain takeover. The 'TenantReuse'
	// value is the default value if selected and means the object's domain name label can be reused within the same tenant.
	// The 'SubscriptionReuse' value means the object's domain name label can be reused within the same subscription. The
	// 'ResourceGroupReuse' value means the object's domain name label can be reused within the same resource group. The
	// 'NoReuse' value means the object's domain name label cannot be reused within the same resource group, subscription, or
	// tenant.
	AutoGeneratedDomainNameLabelScope *IpAddress_AutoGeneratedDomainNameLabelScope `json:"autoGeneratedDomainNameLabelScope,omitempty"`

	// DnsNameLabel: The Dns name label for the IP.
	DnsNameLabel *string `json:"dnsNameLabel,omitempty"`

	// Ip: The IP exposed to the public internet.
	Ip *string `json:"ip,omitempty"`

	// +kubebuilder:validation:Required
	// Ports: The list of ports exposed on the container group.
	Ports []Port `json:"ports,omitempty"`

	// +kubebuilder:validation:Required
	// Type: Specifies if the IP is exposed to the public internet or private VNET.
	Type *IpAddress_Type `json:"type,omitempty"`
}

var _ genruntime.ARMTransformer = &IpAddress{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (address *IpAddress) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if address == nil {
		return nil, nil
	}
	result := &arm.IpAddress{}

	// Set property "AutoGeneratedDomainNameLabelScope":
	if address.AutoGeneratedDomainNameLabelScope != nil {
		var temp string
		temp = string(*address.AutoGeneratedDomainNameLabelScope)
		autoGeneratedDomainNameLabelScope := arm.IpAddress_AutoGeneratedDomainNameLabelScope(temp)
		result.AutoGeneratedDomainNameLabelScope = &autoGeneratedDomainNameLabelScope
	}

	// Set property "DnsNameLabel":
	if address.DnsNameLabel != nil {
		dnsNameLabel := *address.DnsNameLabel
		result.DnsNameLabel = &dnsNameLabel
	}

	// Set property "Ip":
	if address.Ip != nil {
		ip := *address.Ip
		result.Ip = &ip
	}

	// Set property "Ports":
	for _, item := range address.Ports {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Ports = append(result.Ports, *item_ARM.(*arm.Port))
	}

	// Set property "Type":
	if address.Type != nil {
		var temp string
		temp = string(*address.Type)
		typeVar := arm.IpAddress_Type(temp)
		result.Type = &typeVar
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (address *IpAddress) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.IpAddress{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (address *IpAddress) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.IpAddress)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.IpAddress, got %T", armInput)
	}

	// Set property "AutoGeneratedDomainNameLabelScope":
	if typedInput.AutoGeneratedDomainNameLabelScope != nil {
		var temp string
		temp = string(*typedInput.AutoGeneratedDomainNameLabelScope)
		autoGeneratedDomainNameLabelScope := IpAddress_AutoGeneratedDomainNameLabelScope(temp)
		address.AutoGeneratedDomainNameLabelScope = &autoGeneratedDomainNameLabelScope
	}

	// Set property "DnsNameLabel":
	if typedInput.DnsNameLabel != nil {
		dnsNameLabel := *typedInput.DnsNameLabel
		address.DnsNameLabel = &dnsNameLabel
	}

	// Set property "Ip":
	if typedInput.Ip != nil {
		ip := *typedInput.Ip
		address.Ip = &ip
	}

	// Set property "Ports":
	for _, item := range typedInput.Ports {
		var item1 Port
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		address.Ports = append(address.Ports, item1)
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := IpAddress_Type(temp)
		address.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_IpAddress populates our IpAddress from the provided source IpAddress
func (address *IpAddress) AssignProperties_From_IpAddress(source *storage.IpAddress) error {

	// AutoGeneratedDomainNameLabelScope
	if source.AutoGeneratedDomainNameLabelScope != nil {
		autoGeneratedDomainNameLabelScope := *source.AutoGeneratedDomainNameLabelScope
		autoGeneratedDomainNameLabelScopeTemp := genruntime.ToEnum(autoGeneratedDomainNameLabelScope, ipAddress_AutoGeneratedDomainNameLabelScope_Values)
		address.AutoGeneratedDomainNameLabelScope = &autoGeneratedDomainNameLabelScopeTemp
	} else {
		address.AutoGeneratedDomainNameLabelScope = nil
	}

	// DnsNameLabel
	address.DnsNameLabel = genruntime.ClonePointerToString(source.DnsNameLabel)

	// Ip
	address.Ip = genruntime.ClonePointerToString(source.Ip)

	// Ports
	if source.Ports != nil {
		portList := make([]Port, len(source.Ports))
		for portIndex, portItem := range source.Ports {
			// Shadow the loop variable to avoid aliasing
			portItem := portItem
			var port Port
			err := port.AssignProperties_From_Port(&portItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_Port() to populate field Ports")
			}
			portList[portIndex] = port
		}
		address.Ports = portList
	} else {
		address.Ports = nil
	}

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, ipAddress_Type_Values)
		address.Type = &typeTemp
	} else {
		address.Type = nil
	}

	// No error
	return nil
}

// AssignProperties_To_IpAddress populates the provided destination IpAddress from our IpAddress
func (address *IpAddress) AssignProperties_To_IpAddress(destination *storage.IpAddress) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AutoGeneratedDomainNameLabelScope
	if address.AutoGeneratedDomainNameLabelScope != nil {
		autoGeneratedDomainNameLabelScope := string(*address.AutoGeneratedDomainNameLabelScope)
		destination.AutoGeneratedDomainNameLabelScope = &autoGeneratedDomainNameLabelScope
	} else {
		destination.AutoGeneratedDomainNameLabelScope = nil
	}

	// DnsNameLabel
	destination.DnsNameLabel = genruntime.ClonePointerToString(address.DnsNameLabel)

	// Ip
	destination.Ip = genruntime.ClonePointerToString(address.Ip)

	// Ports
	if address.Ports != nil {
		portList := make([]storage.Port, len(address.Ports))
		for portIndex, portItem := range address.Ports {
			// Shadow the loop variable to avoid aliasing
			portItem := portItem
			var port storage.Port
			err := portItem.AssignProperties_To_Port(&port)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_Port() to populate field Ports")
			}
			portList[portIndex] = port
		}
		destination.Ports = portList
	} else {
		destination.Ports = nil
	}

	// Type
	if address.Type != nil {
		typeVar := string(*address.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_IpAddress_STATUS populates our IpAddress from the provided source IpAddress_STATUS
func (address *IpAddress) Initialize_From_IpAddress_STATUS(source *IpAddress_STATUS) error {

	// AutoGeneratedDomainNameLabelScope
	if source.AutoGeneratedDomainNameLabelScope != nil {
		autoGeneratedDomainNameLabelScope := genruntime.ToEnum(string(*source.AutoGeneratedDomainNameLabelScope), ipAddress_AutoGeneratedDomainNameLabelScope_Values)
		address.AutoGeneratedDomainNameLabelScope = &autoGeneratedDomainNameLabelScope
	} else {
		address.AutoGeneratedDomainNameLabelScope = nil
	}

	// DnsNameLabel
	address.DnsNameLabel = genruntime.ClonePointerToString(source.DnsNameLabel)

	// Ip
	address.Ip = genruntime.ClonePointerToString(source.Ip)

	// Ports
	if source.Ports != nil {
		portList := make([]Port, len(source.Ports))
		for portIndex, portItem := range source.Ports {
			// Shadow the loop variable to avoid aliasing
			portItem := portItem
			var port Port
			err := port.Initialize_From_Port_STATUS(&portItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_Port_STATUS() to populate field Ports")
			}
			portList[portIndex] = port
		}
		address.Ports = portList
	} else {
		address.Ports = nil
	}

	// Type
	if source.Type != nil {
		typeVar := genruntime.ToEnum(string(*source.Type), ipAddress_Type_Values)
		address.Type = &typeVar
	} else {
		address.Type = nil
	}

	// No error
	return nil
}

// IP address for the container group.
type IpAddress_STATUS struct {
	// AutoGeneratedDomainNameLabelScope: The value representing the security enum. The 'Unsecure' value is the default value
	// if not selected and means the object's domain name label is not secured against subdomain takeover. The 'TenantReuse'
	// value is the default value if selected and means the object's domain name label can be reused within the same tenant.
	// The 'SubscriptionReuse' value means the object's domain name label can be reused within the same subscription. The
	// 'ResourceGroupReuse' value means the object's domain name label can be reused within the same resource group. The
	// 'NoReuse' value means the object's domain name label cannot be reused within the same resource group, subscription, or
	// tenant.
	AutoGeneratedDomainNameLabelScope *IpAddress_AutoGeneratedDomainNameLabelScope_STATUS `json:"autoGeneratedDomainNameLabelScope,omitempty"`

	// DnsNameLabel: The Dns name label for the IP.
	DnsNameLabel *string `json:"dnsNameLabel,omitempty"`

	// Fqdn: The FQDN for the IP.
	Fqdn *string `json:"fqdn,omitempty"`

	// Ip: The IP exposed to the public internet.
	Ip *string `json:"ip,omitempty"`

	// Ports: The list of ports exposed on the container group.
	Ports []Port_STATUS `json:"ports,omitempty"`

	// Type: Specifies if the IP is exposed to the public internet or private VNET.
	Type *IpAddress_Type_STATUS `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &IpAddress_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (address *IpAddress_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.IpAddress_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (address *IpAddress_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.IpAddress_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.IpAddress_STATUS, got %T", armInput)
	}

	// Set property "AutoGeneratedDomainNameLabelScope":
	if typedInput.AutoGeneratedDomainNameLabelScope != nil {
		var temp string
		temp = string(*typedInput.AutoGeneratedDomainNameLabelScope)
		autoGeneratedDomainNameLabelScope := IpAddress_AutoGeneratedDomainNameLabelScope_STATUS(temp)
		address.AutoGeneratedDomainNameLabelScope = &autoGeneratedDomainNameLabelScope
	}

	// Set property "DnsNameLabel":
	if typedInput.DnsNameLabel != nil {
		dnsNameLabel := *typedInput.DnsNameLabel
		address.DnsNameLabel = &dnsNameLabel
	}

	// Set property "Fqdn":
	if typedInput.Fqdn != nil {
		fqdn := *typedInput.Fqdn
		address.Fqdn = &fqdn
	}

	// Set property "Ip":
	if typedInput.Ip != nil {
		ip := *typedInput.Ip
		address.Ip = &ip
	}

	// Set property "Ports":
	for _, item := range typedInput.Ports {
		var item1 Port_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		address.Ports = append(address.Ports, item1)
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := IpAddress_Type_STATUS(temp)
		address.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_IpAddress_STATUS populates our IpAddress_STATUS from the provided source IpAddress_STATUS
func (address *IpAddress_STATUS) AssignProperties_From_IpAddress_STATUS(source *storage.IpAddress_STATUS) error {

	// AutoGeneratedDomainNameLabelScope
	if source.AutoGeneratedDomainNameLabelScope != nil {
		autoGeneratedDomainNameLabelScope := *source.AutoGeneratedDomainNameLabelScope
		autoGeneratedDomainNameLabelScopeTemp := genruntime.ToEnum(autoGeneratedDomainNameLabelScope, ipAddress_AutoGeneratedDomainNameLabelScope_STATUS_Values)
		address.AutoGeneratedDomainNameLabelScope = &autoGeneratedDomainNameLabelScopeTemp
	} else {
		address.AutoGeneratedDomainNameLabelScope = nil
	}

	// DnsNameLabel
	address.DnsNameLabel = genruntime.ClonePointerToString(source.DnsNameLabel)

	// Fqdn
	address.Fqdn = genruntime.ClonePointerToString(source.Fqdn)

	// Ip
	address.Ip = genruntime.ClonePointerToString(source.Ip)

	// Ports
	if source.Ports != nil {
		portList := make([]Port_STATUS, len(source.Ports))
		for portIndex, portItem := range source.Ports {
			// Shadow the loop variable to avoid aliasing
			portItem := portItem
			var port Port_STATUS
			err := port.AssignProperties_From_Port_STATUS(&portItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_Port_STATUS() to populate field Ports")
			}
			portList[portIndex] = port
		}
		address.Ports = portList
	} else {
		address.Ports = nil
	}

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, ipAddress_Type_STATUS_Values)
		address.Type = &typeTemp
	} else {
		address.Type = nil
	}

	// No error
	return nil
}

// AssignProperties_To_IpAddress_STATUS populates the provided destination IpAddress_STATUS from our IpAddress_STATUS
func (address *IpAddress_STATUS) AssignProperties_To_IpAddress_STATUS(destination *storage.IpAddress_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AutoGeneratedDomainNameLabelScope
	if address.AutoGeneratedDomainNameLabelScope != nil {
		autoGeneratedDomainNameLabelScope := string(*address.AutoGeneratedDomainNameLabelScope)
		destination.AutoGeneratedDomainNameLabelScope = &autoGeneratedDomainNameLabelScope
	} else {
		destination.AutoGeneratedDomainNameLabelScope = nil
	}

	// DnsNameLabel
	destination.DnsNameLabel = genruntime.ClonePointerToString(address.DnsNameLabel)

	// Fqdn
	destination.Fqdn = genruntime.ClonePointerToString(address.Fqdn)

	// Ip
	destination.Ip = genruntime.ClonePointerToString(address.Ip)

	// Ports
	if address.Ports != nil {
		portList := make([]storage.Port_STATUS, len(address.Ports))
		for portIndex, portItem := range address.Ports {
			// Shadow the loop variable to avoid aliasing
			portItem := portItem
			var port storage.Port_STATUS
			err := portItem.AssignProperties_To_Port_STATUS(&port)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_Port_STATUS() to populate field Ports")
			}
			portList[portIndex] = port
		}
		destination.Ports = portList
	} else {
		destination.Ports = nil
	}

	// Type
	if address.Type != nil {
		typeVar := string(*address.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The properties of the volume.
type Volume struct {
	// AzureFile: The Azure File volume.
	AzureFile *AzureFileVolume `json:"azureFile,omitempty"`

	// EmptyDir: The empty directory volume.
	EmptyDir map[string]v1.JSON `json:"emptyDir,omitempty"`

	// GitRepo: The git repo volume.
	GitRepo *GitRepoVolume `json:"gitRepo,omitempty"`

	// +kubebuilder:validation:Required
	// Name: The name of the volume.
	Name *string `json:"name,omitempty"`

	// Secret: The secret volume.
	Secret map[string]string `json:"secret,omitempty"`
}

var _ genruntime.ARMTransformer = &Volume{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (volume *Volume) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if volume == nil {
		return nil, nil
	}
	result := &arm.Volume{}

	// Set property "AzureFile":
	if volume.AzureFile != nil {
		azureFile_ARM, err := (*volume.AzureFile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		azureFile := *azureFile_ARM.(*arm.AzureFileVolume)
		result.AzureFile = &azureFile
	}

	// Set property "EmptyDir":
	if volume.EmptyDir != nil {
		result.EmptyDir = make(map[string]v1.JSON, len(volume.EmptyDir))
		for key, value := range volume.EmptyDir {
			result.EmptyDir[key] = *value.DeepCopy()
		}
	}

	// Set property "GitRepo":
	if volume.GitRepo != nil {
		gitRepo_ARM, err := (*volume.GitRepo).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		gitRepo := *gitRepo_ARM.(*arm.GitRepoVolume)
		result.GitRepo = &gitRepo
	}

	// Set property "Name":
	if volume.Name != nil {
		name := *volume.Name
		result.Name = &name
	}

	// Set property "Secret":
	if volume.Secret != nil {
		result.Secret = make(map[string]string, len(volume.Secret))
		for key, value := range volume.Secret {
			result.Secret[key] = value
		}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (volume *Volume) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Volume{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (volume *Volume) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Volume)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Volume, got %T", armInput)
	}

	// Set property "AzureFile":
	if typedInput.AzureFile != nil {
		var azureFile1 AzureFileVolume
		err := azureFile1.PopulateFromARM(owner, *typedInput.AzureFile)
		if err != nil {
			return err
		}
		azureFile := azureFile1
		volume.AzureFile = &azureFile
	}

	// Set property "EmptyDir":
	if typedInput.EmptyDir != nil {
		volume.EmptyDir = make(map[string]v1.JSON, len(typedInput.EmptyDir))
		for key, value := range typedInput.EmptyDir {
			volume.EmptyDir[key] = *value.DeepCopy()
		}
	}

	// Set property "GitRepo":
	if typedInput.GitRepo != nil {
		var gitRepo1 GitRepoVolume
		err := gitRepo1.PopulateFromARM(owner, *typedInput.GitRepo)
		if err != nil {
			return err
		}
		gitRepo := gitRepo1
		volume.GitRepo = &gitRepo
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		volume.Name = &name
	}

	// Set property "Secret":
	if typedInput.Secret != nil {
		volume.Secret = make(map[string]string, len(typedInput.Secret))
		for key, value := range typedInput.Secret {
			volume.Secret[key] = value
		}
	}

	// No error
	return nil
}

// AssignProperties_From_Volume populates our Volume from the provided source Volume
func (volume *Volume) AssignProperties_From_Volume(source *storage.Volume) error {

	// AzureFile
	if source.AzureFile != nil {
		var azureFile AzureFileVolume
		err := azureFile.AssignProperties_From_AzureFileVolume(source.AzureFile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AzureFileVolume() to populate field AzureFile")
		}
		volume.AzureFile = &azureFile
	} else {
		volume.AzureFile = nil
	}

	// EmptyDir
	if source.EmptyDir != nil {
		emptyDirMap := make(map[string]v1.JSON, len(source.EmptyDir))
		for emptyDirKey, emptyDirValue := range source.EmptyDir {
			// Shadow the loop variable to avoid aliasing
			emptyDirValue := emptyDirValue
			emptyDirMap[emptyDirKey] = *emptyDirValue.DeepCopy()
		}
		volume.EmptyDir = emptyDirMap
	} else {
		volume.EmptyDir = nil
	}

	// GitRepo
	if source.GitRepo != nil {
		var gitRepo GitRepoVolume
		err := gitRepo.AssignProperties_From_GitRepoVolume(source.GitRepo)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_GitRepoVolume() to populate field GitRepo")
		}
		volume.GitRepo = &gitRepo
	} else {
		volume.GitRepo = nil
	}

	// Name
	volume.Name = genruntime.ClonePointerToString(source.Name)

	// Secret
	volume.Secret = genruntime.CloneMapOfStringToString(source.Secret)

	// No error
	return nil
}

// AssignProperties_To_Volume populates the provided destination Volume from our Volume
func (volume *Volume) AssignProperties_To_Volume(destination *storage.Volume) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureFile
	if volume.AzureFile != nil {
		var azureFile storage.AzureFileVolume
		err := volume.AzureFile.AssignProperties_To_AzureFileVolume(&azureFile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AzureFileVolume() to populate field AzureFile")
		}
		destination.AzureFile = &azureFile
	} else {
		destination.AzureFile = nil
	}

	// EmptyDir
	if volume.EmptyDir != nil {
		emptyDirMap := make(map[string]v1.JSON, len(volume.EmptyDir))
		for emptyDirKey, emptyDirValue := range volume.EmptyDir {
			// Shadow the loop variable to avoid aliasing
			emptyDirValue := emptyDirValue
			emptyDirMap[emptyDirKey] = *emptyDirValue.DeepCopy()
		}
		destination.EmptyDir = emptyDirMap
	} else {
		destination.EmptyDir = nil
	}

	// GitRepo
	if volume.GitRepo != nil {
		var gitRepo storage.GitRepoVolume
		err := volume.GitRepo.AssignProperties_To_GitRepoVolume(&gitRepo)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_GitRepoVolume() to populate field GitRepo")
		}
		destination.GitRepo = &gitRepo
	} else {
		destination.GitRepo = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(volume.Name)

	// Secret
	destination.Secret = genruntime.CloneMapOfStringToString(volume.Secret)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_Volume_STATUS populates our Volume from the provided source Volume_STATUS
func (volume *Volume) Initialize_From_Volume_STATUS(source *Volume_STATUS) error {

	// AzureFile
	if source.AzureFile != nil {
		var azureFile AzureFileVolume
		err := azureFile.Initialize_From_AzureFileVolume_STATUS(source.AzureFile)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_AzureFileVolume_STATUS() to populate field AzureFile")
		}
		volume.AzureFile = &azureFile
	} else {
		volume.AzureFile = nil
	}

	// EmptyDir
	if source.EmptyDir != nil {
		emptyDirMap := make(map[string]v1.JSON, len(source.EmptyDir))
		for emptyDirKey, emptyDirValue := range source.EmptyDir {
			// Shadow the loop variable to avoid aliasing
			emptyDirValue := emptyDirValue
			emptyDirMap[emptyDirKey] = *emptyDirValue.DeepCopy()
		}
		volume.EmptyDir = emptyDirMap
	} else {
		volume.EmptyDir = nil
	}

	// GitRepo
	if source.GitRepo != nil {
		var gitRepo GitRepoVolume
		err := gitRepo.Initialize_From_GitRepoVolume_STATUS(source.GitRepo)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_GitRepoVolume_STATUS() to populate field GitRepo")
		}
		volume.GitRepo = &gitRepo
	} else {
		volume.GitRepo = nil
	}

	// Name
	volume.Name = genruntime.ClonePointerToString(source.Name)

	// Secret
	volume.Secret = genruntime.CloneMapOfStringToString(source.Secret)

	// No error
	return nil
}

// The properties of the volume.
type Volume_STATUS struct {
	// AzureFile: The Azure File volume.
	AzureFile *AzureFileVolume_STATUS `json:"azureFile,omitempty"`

	// EmptyDir: The empty directory volume.
	EmptyDir map[string]v1.JSON `json:"emptyDir,omitempty"`

	// GitRepo: The git repo volume.
	GitRepo *GitRepoVolume_STATUS `json:"gitRepo,omitempty"`

	// Name: The name of the volume.
	Name *string `json:"name,omitempty"`

	// Secret: The secret volume.
	Secret map[string]string `json:"secret,omitempty"`
}

var _ genruntime.FromARMConverter = &Volume_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (volume *Volume_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Volume_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (volume *Volume_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Volume_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Volume_STATUS, got %T", armInput)
	}

	// Set property "AzureFile":
	if typedInput.AzureFile != nil {
		var azureFile1 AzureFileVolume_STATUS
		err := azureFile1.PopulateFromARM(owner, *typedInput.AzureFile)
		if err != nil {
			return err
		}
		azureFile := azureFile1
		volume.AzureFile = &azureFile
	}

	// Set property "EmptyDir":
	if typedInput.EmptyDir != nil {
		volume.EmptyDir = make(map[string]v1.JSON, len(typedInput.EmptyDir))
		for key, value := range typedInput.EmptyDir {
			volume.EmptyDir[key] = *value.DeepCopy()
		}
	}

	// Set property "GitRepo":
	if typedInput.GitRepo != nil {
		var gitRepo1 GitRepoVolume_STATUS
		err := gitRepo1.PopulateFromARM(owner, *typedInput.GitRepo)
		if err != nil {
			return err
		}
		gitRepo := gitRepo1
		volume.GitRepo = &gitRepo
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		volume.Name = &name
	}

	// Set property "Secret":
	if typedInput.Secret != nil {
		volume.Secret = make(map[string]string, len(typedInput.Secret))
		for key, value := range typedInput.Secret {
			volume.Secret[key] = value
		}
	}

	// No error
	return nil
}

// AssignProperties_From_Volume_STATUS populates our Volume_STATUS from the provided source Volume_STATUS
func (volume *Volume_STATUS) AssignProperties_From_Volume_STATUS(source *storage.Volume_STATUS) error {

	// AzureFile
	if source.AzureFile != nil {
		var azureFile AzureFileVolume_STATUS
		err := azureFile.AssignProperties_From_AzureFileVolume_STATUS(source.AzureFile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AzureFileVolume_STATUS() to populate field AzureFile")
		}
		volume.AzureFile = &azureFile
	} else {
		volume.AzureFile = nil
	}

	// EmptyDir
	if source.EmptyDir != nil {
		emptyDirMap := make(map[string]v1.JSON, len(source.EmptyDir))
		for emptyDirKey, emptyDirValue := range source.EmptyDir {
			// Shadow the loop variable to avoid aliasing
			emptyDirValue := emptyDirValue
			emptyDirMap[emptyDirKey] = *emptyDirValue.DeepCopy()
		}
		volume.EmptyDir = emptyDirMap
	} else {
		volume.EmptyDir = nil
	}

	// GitRepo
	if source.GitRepo != nil {
		var gitRepo GitRepoVolume_STATUS
		err := gitRepo.AssignProperties_From_GitRepoVolume_STATUS(source.GitRepo)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_GitRepoVolume_STATUS() to populate field GitRepo")
		}
		volume.GitRepo = &gitRepo
	} else {
		volume.GitRepo = nil
	}

	// Name
	volume.Name = genruntime.ClonePointerToString(source.Name)

	// Secret
	volume.Secret = genruntime.CloneMapOfStringToString(source.Secret)

	// No error
	return nil
}

// AssignProperties_To_Volume_STATUS populates the provided destination Volume_STATUS from our Volume_STATUS
func (volume *Volume_STATUS) AssignProperties_To_Volume_STATUS(destination *storage.Volume_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureFile
	if volume.AzureFile != nil {
		var azureFile storage.AzureFileVolume_STATUS
		err := volume.AzureFile.AssignProperties_To_AzureFileVolume_STATUS(&azureFile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AzureFileVolume_STATUS() to populate field AzureFile")
		}
		destination.AzureFile = &azureFile
	} else {
		destination.AzureFile = nil
	}

	// EmptyDir
	if volume.EmptyDir != nil {
		emptyDirMap := make(map[string]v1.JSON, len(volume.EmptyDir))
		for emptyDirKey, emptyDirValue := range volume.EmptyDir {
			// Shadow the loop variable to avoid aliasing
			emptyDirValue := emptyDirValue
			emptyDirMap[emptyDirKey] = *emptyDirValue.DeepCopy()
		}
		destination.EmptyDir = emptyDirMap
	} else {
		destination.EmptyDir = nil
	}

	// GitRepo
	if volume.GitRepo != nil {
		var gitRepo storage.GitRepoVolume_STATUS
		err := volume.GitRepo.AssignProperties_To_GitRepoVolume_STATUS(&gitRepo)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_GitRepoVolume_STATUS() to populate field GitRepo")
		}
		destination.GitRepo = &gitRepo
	} else {
		destination.GitRepo = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(volume.Name)

	// Secret
	destination.Secret = genruntime.CloneMapOfStringToString(volume.Secret)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The properties of the Azure File volume. Azure File shares are mounted as volumes.
type AzureFileVolume struct {
	// ReadOnly: The flag indicating whether the Azure File shared mounted as a volume is read-only.
	ReadOnly *bool `json:"readOnly,omitempty"`

	// +kubebuilder:validation:Required
	// ShareName: The name of the Azure File share to be mounted as a volume.
	ShareName *string `json:"shareName,omitempty"`

	// StorageAccountKey: The storage account access key used to access the Azure File share.
	StorageAccountKey *string `json:"storageAccountKey,omitempty"`

	// +kubebuilder:validation:Required
	// StorageAccountName: The name of the storage account that contains the Azure File share.
	StorageAccountName *string `json:"storageAccountName,omitempty"`
}

var _ genruntime.ARMTransformer = &AzureFileVolume{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (volume *AzureFileVolume) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if volume == nil {
		return nil, nil
	}
	result := &arm.AzureFileVolume{}

	// Set property "ReadOnly":
	if volume.ReadOnly != nil {
		readOnly := *volume.ReadOnly
		result.ReadOnly = &readOnly
	}

	// Set property "ShareName":
	if volume.ShareName != nil {
		shareName := *volume.ShareName
		result.ShareName = &shareName
	}

	// Set property "StorageAccountKey":
	if volume.StorageAccountKey != nil {
		storageAccountKey := *volume.StorageAccountKey
		result.StorageAccountKey = &storageAccountKey
	}

	// Set property "StorageAccountName":
	if volume.StorageAccountName != nil {
		storageAccountName := *volume.StorageAccountName
		result.StorageAccountName = &storageAccountName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (volume *AzureFileVolume) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AzureFileVolume{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (volume *AzureFileVolume) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AzureFileVolume)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AzureFileVolume, got %T", armInput)
	}

	// Set property "ReadOnly":
	if typedInput.ReadOnly != nil {
		readOnly := *typedInput.ReadOnly
		volume.ReadOnly = &readOnly
	}

	// Set property "ShareName":
	if typedInput.ShareName != nil {
		shareName := *typedInput.ShareName
		volume.ShareName = &shareName
	}

	// Set property "StorageAccountKey":
	if typedInput.StorageAccountKey != nil {
		storageAccountKey := *typedInput.StorageAccountKey
		volume.StorageAccountKey = &storageAccountKey
	}

	// Set property "StorageAccountName":
	if typedInput.StorageAccountName != nil {
		storageAccountName := *typedInput.StorageAccountName
		volume.StorageAccountName = &storageAccountName
	}

	// No error
	return nil
}

// AssignProperties_From_AzureFileVolume populates our AzureFileVolume from the provided source AzureFileVolume
func (volume *AzureFileVolume) AssignProperties_From_AzureFileVolume(source *storage.AzureFileVolume) error {

	// ReadOnly
	if source.ReadOnly != nil {
		readOnly := *source.ReadOnly
		volume.ReadOnly = &readOnly
	} else {
		volume.ReadOnly = nil
	}

	// ShareName
	volume.ShareName = genruntime.ClonePointerToString(source.ShareName)

	// StorageAccountKey
	volume.StorageAccountKey = genruntime.ClonePointerToString(source.StorageAccountKey)

	// StorageAccountName
	volume.StorageAccountName = genruntime.ClonePointerToString(source.StorageAccountName)

	// No error
	return nil
}

// AssignProperties_To_AzureFileVolume populates the provided destination AzureFileVolume from our AzureFileVolume
func (volume *AzureFileVolume) AssignProperties_To_AzureFileVolume(destination *storage.AzureFileVolume) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ReadOnly
	if volume.ReadOnly != nil {
		readOnly := *volume.ReadOnly
		destination.ReadOnly = &readOnly
	} else {
		destination.ReadOnly = nil
	}

	// ShareName
	destination.ShareName = genruntime.ClonePointerToString(volume.ShareName)

	// StorageAccountKey
	destination.StorageAccountKey = genruntime.ClonePointerToString(volume.StorageAccountKey)

	// StorageAccountName
	destination.StorageAccountName = genruntime.ClonePointerToString(volume.StorageAccountName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_AzureFileVolume_STATUS populates our AzureFileVolume from the provided source AzureFileVolume_STATUS
func (volume *AzureFileVolume) Initialize_From_AzureFileVolume_STATUS(source *AzureFileVolume_STATUS) error {

	// ReadOnly
	if source.ReadOnly != nil {
		readOnly := *source.ReadOnly
		volume.ReadOnly = &readOnly
	} else {
		volume.ReadOnly = nil
	}

	// ShareName
	volume.ShareName = genruntime.ClonePointerToString(source.ShareName)

	// StorageAccountKey
	volume.StorageAccountKey = genruntime.ClonePointerToString(source.StorageAccountKey)

	// StorageAccountName
	volume.StorageAccountName = genruntime.ClonePointerToString(source.StorageAccountName)

	// No error
	return nil
}

// The properties of the Azure File volume. Azure File shares are mounted as volumes.
type AzureFileVolume_STATUS struct {
	// ReadOnly: The flag indicating whether the Azure File shared mounted as a volume is read-only.
	ReadOnly *bool `json:"readOnly,omitempty"`

	// ShareName: The name of the Azure File share to be mounted as a volume.
	ShareName *string `json:"shareName,omitempty"`

	// StorageAccountKey: The storage account access key used to access the Azure File share.
	StorageAccountKey *string `json:"storageAccountKey,omitempty"`

	// StorageAccountName: The name of the storage account that contains the Azure File share.
	StorageAccountName *string `json:"storageAccountName,omitempty"`
}

var _ genruntime.FromARMConverter = &AzureFileVolume_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (volume *AzureFileVolume_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AzureFileVolume_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (volume *AzureFileVolume_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AzureFileVolume_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AzureFileVolume_STATUS, got %T", armInput)
	}

	// Set property "ReadOnly":
	if typedInput.ReadOnly != nil {
		readOnly := *typedInput.ReadOnly
		volume.ReadOnly = &readOnly
	}

	// Set property "ShareName":
	if typedInput.ShareName != nil {
		shareName := *typedInput.ShareName
		volume.ShareName = &shareName
	}

	// Set property "StorageAccountKey":
	if typedInput.StorageAccountKey != nil {
		storageAccountKey := *typedInput.StorageAccountKey
		volume.StorageAccountKey = &storageAccountKey
	}

	// Set property "StorageAccountName":
	if typedInput.StorageAccountName != nil {
		storageAccountName := *typedInput.StorageAccountName
		volume.StorageAccountName = &storageAccountName
	}

	// No error
	return nil
}

// AssignProperties_From_AzureFileVolume_STATUS populates our AzureFileVolume_STATUS from the provided source AzureFileVolume_STATUS
func (volume *AzureFileVolume_STATUS) AssignProperties_From_AzureFileVolume_STATUS(source *storage.AzureFileVolume_STATUS) error {

	// ReadOnly
	if source.ReadOnly != nil {
		readOnly := *source.ReadOnly
		volume.ReadOnly = &readOnly
	} else {
		volume.ReadOnly = nil
	}

	// ShareName
	volume.ShareName = genruntime.ClonePointerToString(source.ShareName)

	// StorageAccountKey
	volume.StorageAccountKey = genruntime.ClonePointerToString(source.StorageAccountKey)

	// StorageAccountName
	volume.StorageAccountName = genruntime.ClonePointerToString(source.StorageAccountName)

	// No error
	return nil
}

// AssignProperties_To_AzureFileVolume_STATUS populates the provided destination AzureFileVolume_STATUS from our AzureFileVolume_STATUS
func (volume *AzureFileVolume_STATUS) AssignProperties_To_AzureFileVolume_STATUS(destination *storage.AzureFileVolume_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ReadOnly
	if volume.ReadOnly != nil {
		readOnly := *volume.ReadOnly
		destination.ReadOnly = &readOnly
	} else {
		destination.ReadOnly = nil
	}

	// ShareName
	destination.ShareName = genruntime.ClonePointerToString(volume.ShareName)

	// StorageAccountKey
	destination.StorageAccountKey = genruntime.ClonePointerToString(volume.StorageAccountKey)

	// StorageAccountName
	destination.StorageAccountName = genruntime.ClonePointerToString(volume.StorageAccountName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"None","SystemAssigned","SystemAssigned, UserAssigned","UserAssigned"}
type ContainerGroupIdentity_Type string

const (
	ContainerGroupIdentity_Type_None                       = ContainerGroupIdentity_Type("None")
	ContainerGroupIdentity_Type_SystemAssigned             = ContainerGroupIdentity_Type("SystemAssigned")
	ContainerGroupIdentity_Type_SystemAssignedUserAssigned = ContainerGroupIdentity_Type("SystemAssigned, UserAssigned")
	ContainerGroupIdentity_Type_UserAssigned               = ContainerGroupIdentity_Type("UserAssigned")
)

// Mapping from string to ContainerGroupIdentity_Type
var containerGroupIdentity_Type_Values = map[string]ContainerGroupIdentity_Type{
	"none":                         ContainerGroupIdentity_Type_None,
	"systemassigned":               ContainerGroupIdentity_Type_SystemAssigned,
	"systemassigned, userassigned": ContainerGroupIdentity_Type_SystemAssignedUserAssigned,
	"userassigned":                 ContainerGroupIdentity_Type_UserAssigned,
}

type ContainerGroupIdentity_Type_STATUS string

const (
	ContainerGroupIdentity_Type_STATUS_None                       = ContainerGroupIdentity_Type_STATUS("None")
	ContainerGroupIdentity_Type_STATUS_SystemAssigned             = ContainerGroupIdentity_Type_STATUS("SystemAssigned")
	ContainerGroupIdentity_Type_STATUS_SystemAssignedUserAssigned = ContainerGroupIdentity_Type_STATUS("SystemAssigned, UserAssigned")
	ContainerGroupIdentity_Type_STATUS_UserAssigned               = ContainerGroupIdentity_Type_STATUS("UserAssigned")
)

// Mapping from string to ContainerGroupIdentity_Type_STATUS
var containerGroupIdentity_Type_STATUS_Values = map[string]ContainerGroupIdentity_Type_STATUS{
	"none":                         ContainerGroupIdentity_Type_STATUS_None,
	"systemassigned":               ContainerGroupIdentity_Type_STATUS_SystemAssigned,
	"systemassigned, userassigned": ContainerGroupIdentity_Type_STATUS_SystemAssignedUserAssigned,
	"userassigned":                 ContainerGroupIdentity_Type_STATUS_UserAssigned,
}

// The port exposed on the container instance.
type ContainerPort struct {
	// +kubebuilder:validation:Required
	// Port: The port number exposed within the container group.
	Port *int `json:"port,omitempty"`

	// Protocol: The protocol associated with the port.
	Protocol *ContainerPort_Protocol `json:"protocol,omitempty"`
}

var _ genruntime.ARMTransformer = &ContainerPort{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (port *ContainerPort) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if port == nil {
		return nil, nil
	}
	result := &arm.ContainerPort{}

	// Set property "Port":
	if port.Port != nil {
		port1 := *port.Port
		result.Port = &port1
	}

	// Set property "Protocol":
	if port.Protocol != nil {
		var temp string
		temp = string(*port.Protocol)
		protocol := arm.ContainerPort_Protocol(temp)
		result.Protocol = &protocol
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (port *ContainerPort) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ContainerPort{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (port *ContainerPort) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ContainerPort)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ContainerPort, got %T", armInput)
	}

	// Set property "Port":
	if typedInput.Port != nil {
		port1 := *typedInput.Port
		port.Port = &port1
	}

	// Set property "Protocol":
	if typedInput.Protocol != nil {
		var temp string
		temp = string(*typedInput.Protocol)
		protocol := ContainerPort_Protocol(temp)
		port.Protocol = &protocol
	}

	// No error
	return nil
}

// AssignProperties_From_ContainerPort populates our ContainerPort from the provided source ContainerPort
func (port *ContainerPort) AssignProperties_From_ContainerPort(source *storage.ContainerPort) error {

	// Port
	port.Port = genruntime.ClonePointerToInt(source.Port)

	// Protocol
	if source.Protocol != nil {
		protocol := *source.Protocol
		protocolTemp := genruntime.ToEnum(protocol, containerPort_Protocol_Values)
		port.Protocol = &protocolTemp
	} else {
		port.Protocol = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ContainerPort populates the provided destination ContainerPort from our ContainerPort
func (port *ContainerPort) AssignProperties_To_ContainerPort(destination *storage.ContainerPort) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Port
	destination.Port = genruntime.ClonePointerToInt(port.Port)

	// Protocol
	if port.Protocol != nil {
		protocol := string(*port.Protocol)
		destination.Protocol = &protocol
	} else {
		destination.Protocol = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ContainerPort_STATUS populates our ContainerPort from the provided source ContainerPort_STATUS
func (port *ContainerPort) Initialize_From_ContainerPort_STATUS(source *ContainerPort_STATUS) error {

	// Port
	port.Port = genruntime.ClonePointerToInt(source.Port)

	// Protocol
	if source.Protocol != nil {
		protocol := genruntime.ToEnum(string(*source.Protocol), containerPort_Protocol_Values)
		port.Protocol = &protocol
	} else {
		port.Protocol = nil
	}

	// No error
	return nil
}

// The port exposed on the container instance.
type ContainerPort_STATUS struct {
	// Port: The port number exposed within the container group.
	Port *int `json:"port,omitempty"`

	// Protocol: The protocol associated with the port.
	Protocol *ContainerPort_Protocol_STATUS `json:"protocol,omitempty"`
}

var _ genruntime.FromARMConverter = &ContainerPort_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (port *ContainerPort_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ContainerPort_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (port *ContainerPort_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ContainerPort_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ContainerPort_STATUS, got %T", armInput)
	}

	// Set property "Port":
	if typedInput.Port != nil {
		port1 := *typedInput.Port
		port.Port = &port1
	}

	// Set property "Protocol":
	if typedInput.Protocol != nil {
		var temp string
		temp = string(*typedInput.Protocol)
		protocol := ContainerPort_Protocol_STATUS(temp)
		port.Protocol = &protocol
	}

	// No error
	return nil
}

// AssignProperties_From_ContainerPort_STATUS populates our ContainerPort_STATUS from the provided source ContainerPort_STATUS
func (port *ContainerPort_STATUS) AssignProperties_From_ContainerPort_STATUS(source *storage.ContainerPort_STATUS) error {

	// Port
	port.Port = genruntime.ClonePointerToInt(source.Port)

	// Protocol
	if source.Protocol != nil {
		protocol := *source.Protocol
		protocolTemp := genruntime.ToEnum(protocol, containerPort_Protocol_STATUS_Values)
		port.Protocol = &protocolTemp
	} else {
		port.Protocol = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ContainerPort_STATUS populates the provided destination ContainerPort_STATUS from our ContainerPort_STATUS
func (port *ContainerPort_STATUS) AssignProperties_To_ContainerPort_STATUS(destination *storage.ContainerPort_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Port
	destination.Port = genruntime.ClonePointerToInt(port.Port)

	// Protocol
	if port.Protocol != nil {
		protocol := string(*port.Protocol)
		destination.Protocol = &protocol
	} else {
		destination.Protocol = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The container probe, for liveness or readiness
type ContainerProbe struct {
	// Exec: The execution command to probe
	Exec *ContainerExec `json:"exec,omitempty"`

	// FailureThreshold: The failure threshold.
	FailureThreshold *int `json:"failureThreshold,omitempty"`

	// HttpGet: The Http Get settings to probe
	HttpGet *ContainerHttpGet `json:"httpGet,omitempty"`

	// InitialDelaySeconds: The initial delay seconds.
	InitialDelaySeconds *int `json:"initialDelaySeconds,omitempty"`

	// PeriodSeconds: The period seconds.
	PeriodSeconds *int `json:"periodSeconds,omitempty"`

	// SuccessThreshold: The success threshold.
	SuccessThreshold *int `json:"successThreshold,omitempty"`

	// TimeoutSeconds: The timeout seconds.
	TimeoutSeconds *int `json:"timeoutSeconds,omitempty"`
}

var _ genruntime.ARMTransformer = &ContainerProbe{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (probe *ContainerProbe) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if probe == nil {
		return nil, nil
	}
	result := &arm.ContainerProbe{}

	// Set property "Exec":
	if probe.Exec != nil {
		exec_ARM, err := (*probe.Exec).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		exec := *exec_ARM.(*arm.ContainerExec)
		result.Exec = &exec
	}

	// Set property "FailureThreshold":
	if probe.FailureThreshold != nil {
		failureThreshold := *probe.FailureThreshold
		result.FailureThreshold = &failureThreshold
	}

	// Set property "HttpGet":
	if probe.HttpGet != nil {
		httpGet_ARM, err := (*probe.HttpGet).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		httpGet := *httpGet_ARM.(*arm.ContainerHttpGet)
		result.HttpGet = &httpGet
	}

	// Set property "InitialDelaySeconds":
	if probe.InitialDelaySeconds != nil {
		initialDelaySeconds := *probe.InitialDelaySeconds
		result.InitialDelaySeconds = &initialDelaySeconds
	}

	// Set property "PeriodSeconds":
	if probe.PeriodSeconds != nil {
		periodSeconds := *probe.PeriodSeconds
		result.PeriodSeconds = &periodSeconds
	}

	// Set property "SuccessThreshold":
	if probe.SuccessThreshold != nil {
		successThreshold := *probe.SuccessThreshold
		result.SuccessThreshold = &successThreshold
	}

	// Set property "TimeoutSeconds":
	if probe.TimeoutSeconds != nil {
		timeoutSeconds := *probe.TimeoutSeconds
		result.TimeoutSeconds = &timeoutSeconds
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (probe *ContainerProbe) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ContainerProbe{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (probe *ContainerProbe) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ContainerProbe)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ContainerProbe, got %T", armInput)
	}

	// Set property "Exec":
	if typedInput.Exec != nil {
		var exec1 ContainerExec
		err := exec1.PopulateFromARM(owner, *typedInput.Exec)
		if err != nil {
			return err
		}
		exec := exec1
		probe.Exec = &exec
	}

	// Set property "FailureThreshold":
	if typedInput.FailureThreshold != nil {
		failureThreshold := *typedInput.FailureThreshold
		probe.FailureThreshold = &failureThreshold
	}

	// Set property "HttpGet":
	if typedInput.HttpGet != nil {
		var httpGet1 ContainerHttpGet
		err := httpGet1.PopulateFromARM(owner, *typedInput.HttpGet)
		if err != nil {
			return err
		}
		httpGet := httpGet1
		probe.HttpGet = &httpGet
	}

	// Set property "InitialDelaySeconds":
	if typedInput.InitialDelaySeconds != nil {
		initialDelaySeconds := *typedInput.InitialDelaySeconds
		probe.InitialDelaySeconds = &initialDelaySeconds
	}

	// Set property "PeriodSeconds":
	if typedInput.PeriodSeconds != nil {
		periodSeconds := *typedInput.PeriodSeconds
		probe.PeriodSeconds = &periodSeconds
	}

	// Set property "SuccessThreshold":
	if typedInput.SuccessThreshold != nil {
		successThreshold := *typedInput.SuccessThreshold
		probe.SuccessThreshold = &successThreshold
	}

	// Set property "TimeoutSeconds":
	if typedInput.TimeoutSeconds != nil {
		timeoutSeconds := *typedInput.TimeoutSeconds
		probe.TimeoutSeconds = &timeoutSeconds
	}

	// No error
	return nil
}

// AssignProperties_From_ContainerProbe populates our ContainerProbe from the provided source ContainerProbe
func (probe *ContainerProbe) AssignProperties_From_ContainerProbe(source *storage.ContainerProbe) error {

	// Exec
	if source.Exec != nil {
		var exec ContainerExec
		err := exec.AssignProperties_From_ContainerExec(source.Exec)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ContainerExec() to populate field Exec")
		}
		probe.Exec = &exec
	} else {
		probe.Exec = nil
	}

	// FailureThreshold
	probe.FailureThreshold = genruntime.ClonePointerToInt(source.FailureThreshold)

	// HttpGet
	if source.HttpGet != nil {
		var httpGet ContainerHttpGet
		err := httpGet.AssignProperties_From_ContainerHttpGet(source.HttpGet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ContainerHttpGet() to populate field HttpGet")
		}
		probe.HttpGet = &httpGet
	} else {
		probe.HttpGet = nil
	}

	// InitialDelaySeconds
	probe.InitialDelaySeconds = genruntime.ClonePointerToInt(source.InitialDelaySeconds)

	// PeriodSeconds
	probe.PeriodSeconds = genruntime.ClonePointerToInt(source.PeriodSeconds)

	// SuccessThreshold
	probe.SuccessThreshold = genruntime.ClonePointerToInt(source.SuccessThreshold)

	// TimeoutSeconds
	probe.TimeoutSeconds = genruntime.ClonePointerToInt(source.TimeoutSeconds)

	// No error
	return nil
}

// AssignProperties_To_ContainerProbe populates the provided destination ContainerProbe from our ContainerProbe
func (probe *ContainerProbe) AssignProperties_To_ContainerProbe(destination *storage.ContainerProbe) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Exec
	if probe.Exec != nil {
		var exec storage.ContainerExec
		err := probe.Exec.AssignProperties_To_ContainerExec(&exec)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ContainerExec() to populate field Exec")
		}
		destination.Exec = &exec
	} else {
		destination.Exec = nil
	}

	// FailureThreshold
	destination.FailureThreshold = genruntime.ClonePointerToInt(probe.FailureThreshold)

	// HttpGet
	if probe.HttpGet != nil {
		var httpGet storage.ContainerHttpGet
		err := probe.HttpGet.AssignProperties_To_ContainerHttpGet(&httpGet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ContainerHttpGet() to populate field HttpGet")
		}
		destination.HttpGet = &httpGet
	} else {
		destination.HttpGet = nil
	}

	// InitialDelaySeconds
	destination.InitialDelaySeconds = genruntime.ClonePointerToInt(probe.InitialDelaySeconds)

	// PeriodSeconds
	destination.PeriodSeconds = genruntime.ClonePointerToInt(probe.PeriodSeconds)

	// SuccessThreshold
	destination.SuccessThreshold = genruntime.ClonePointerToInt(probe.SuccessThreshold)

	// TimeoutSeconds
	destination.TimeoutSeconds = genruntime.ClonePointerToInt(probe.TimeoutSeconds)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ContainerProbe_STATUS populates our ContainerProbe from the provided source ContainerProbe_STATUS
func (probe *ContainerProbe) Initialize_From_ContainerProbe_STATUS(source *ContainerProbe_STATUS) error {

	// Exec
	if source.Exec != nil {
		var exec ContainerExec
		err := exec.Initialize_From_ContainerExec_STATUS(source.Exec)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_ContainerExec_STATUS() to populate field Exec")
		}
		probe.Exec = &exec
	} else {
		probe.Exec = nil
	}

	// FailureThreshold
	probe.FailureThreshold = genruntime.ClonePointerToInt(source.FailureThreshold)

	// HttpGet
	if source.HttpGet != nil {
		var httpGet ContainerHttpGet
		err := httpGet.Initialize_From_ContainerHttpGet_STATUS(source.HttpGet)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_ContainerHttpGet_STATUS() to populate field HttpGet")
		}
		probe.HttpGet = &httpGet
	} else {
		probe.HttpGet = nil
	}

	// InitialDelaySeconds
	probe.InitialDelaySeconds = genruntime.ClonePointerToInt(source.InitialDelaySeconds)

	// PeriodSeconds
	probe.PeriodSeconds = genruntime.ClonePointerToInt(source.PeriodSeconds)

	// SuccessThreshold
	probe.SuccessThreshold = genruntime.ClonePointerToInt(source.SuccessThreshold)

	// TimeoutSeconds
	probe.TimeoutSeconds = genruntime.ClonePointerToInt(source.TimeoutSeconds)

	// No error
	return nil
}

// The container probe, for liveness or readiness
type ContainerProbe_STATUS struct {
	// Exec: The execution command to probe
	Exec *ContainerExec_STATUS `json:"exec,omitempty"`

	// FailureThreshold: The failure threshold.
	FailureThreshold *int `json:"failureThreshold,omitempty"`

	// HttpGet: The Http Get settings to probe
	HttpGet *ContainerHttpGet_STATUS `json:"httpGet,omitempty"`

	// InitialDelaySeconds: The initial delay seconds.
	InitialDelaySeconds *int `json:"initialDelaySeconds,omitempty"`

	// PeriodSeconds: The period seconds.
	PeriodSeconds *int `json:"periodSeconds,omitempty"`

	// SuccessThreshold: The success threshold.
	SuccessThreshold *int `json:"successThreshold,omitempty"`

	// TimeoutSeconds: The timeout seconds.
	TimeoutSeconds *int `json:"timeoutSeconds,omitempty"`
}

var _ genruntime.FromARMConverter = &ContainerProbe_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (probe *ContainerProbe_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ContainerProbe_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (probe *ContainerProbe_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ContainerProbe_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ContainerProbe_STATUS, got %T", armInput)
	}

	// Set property "Exec":
	if typedInput.Exec != nil {
		var exec1 ContainerExec_STATUS
		err := exec1.PopulateFromARM(owner, *typedInput.Exec)
		if err != nil {
			return err
		}
		exec := exec1
		probe.Exec = &exec
	}

	// Set property "FailureThreshold":
	if typedInput.FailureThreshold != nil {
		failureThreshold := *typedInput.FailureThreshold
		probe.FailureThreshold = &failureThreshold
	}

	// Set property "HttpGet":
	if typedInput.HttpGet != nil {
		var httpGet1 ContainerHttpGet_STATUS
		err := httpGet1.PopulateFromARM(owner, *typedInput.HttpGet)
		if err != nil {
			return err
		}
		httpGet := httpGet1
		probe.HttpGet = &httpGet
	}

	// Set property "InitialDelaySeconds":
	if typedInput.InitialDelaySeconds != nil {
		initialDelaySeconds := *typedInput.InitialDelaySeconds
		probe.InitialDelaySeconds = &initialDelaySeconds
	}

	// Set property "PeriodSeconds":
	if typedInput.PeriodSeconds != nil {
		periodSeconds := *typedInput.PeriodSeconds
		probe.PeriodSeconds = &periodSeconds
	}

	// Set property "SuccessThreshold":
	if typedInput.SuccessThreshold != nil {
		successThreshold := *typedInput.SuccessThreshold
		probe.SuccessThreshold = &successThreshold
	}

	// Set property "TimeoutSeconds":
	if typedInput.TimeoutSeconds != nil {
		timeoutSeconds := *typedInput.TimeoutSeconds
		probe.TimeoutSeconds = &timeoutSeconds
	}

	// No error
	return nil
}

// AssignProperties_From_ContainerProbe_STATUS populates our ContainerProbe_STATUS from the provided source ContainerProbe_STATUS
func (probe *ContainerProbe_STATUS) AssignProperties_From_ContainerProbe_STATUS(source *storage.ContainerProbe_STATUS) error {

	// Exec
	if source.Exec != nil {
		var exec ContainerExec_STATUS
		err := exec.AssignProperties_From_ContainerExec_STATUS(source.Exec)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ContainerExec_STATUS() to populate field Exec")
		}
		probe.Exec = &exec
	} else {
		probe.Exec = nil
	}

	// FailureThreshold
	probe.FailureThreshold = genruntime.ClonePointerToInt(source.FailureThreshold)

	// HttpGet
	if source.HttpGet != nil {
		var httpGet ContainerHttpGet_STATUS
		err := httpGet.AssignProperties_From_ContainerHttpGet_STATUS(source.HttpGet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ContainerHttpGet_STATUS() to populate field HttpGet")
		}
		probe.HttpGet = &httpGet
	} else {
		probe.HttpGet = nil
	}

	// InitialDelaySeconds
	probe.InitialDelaySeconds = genruntime.ClonePointerToInt(source.InitialDelaySeconds)

	// PeriodSeconds
	probe.PeriodSeconds = genruntime.ClonePointerToInt(source.PeriodSeconds)

	// SuccessThreshold
	probe.SuccessThreshold = genruntime.ClonePointerToInt(source.SuccessThreshold)

	// TimeoutSeconds
	probe.TimeoutSeconds = genruntime.ClonePointerToInt(source.TimeoutSeconds)

	// No error
	return nil
}

// AssignProperties_To_ContainerProbe_STATUS populates the provided destination ContainerProbe_STATUS from our ContainerProbe_STATUS
func (probe *ContainerProbe_STATUS) AssignProperties_To_ContainerProbe_STATUS(destination *storage.ContainerProbe_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Exec
	if probe.Exec != nil {
		var exec storage.ContainerExec_STATUS
		err := probe.Exec.AssignProperties_To_ContainerExec_STATUS(&exec)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ContainerExec_STATUS() to populate field Exec")
		}
		destination.Exec = &exec
	} else {
		destination.Exec = nil
	}

	// FailureThreshold
	destination.FailureThreshold = genruntime.ClonePointerToInt(probe.FailureThreshold)

	// HttpGet
	if probe.HttpGet != nil {
		var httpGet storage.ContainerHttpGet_STATUS
		err := probe.HttpGet.AssignProperties_To_ContainerHttpGet_STATUS(&httpGet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ContainerHttpGet_STATUS() to populate field HttpGet")
		}
		destination.HttpGet = &httpGet
	} else {
		destination.HttpGet = nil
	}

	// InitialDelaySeconds
	destination.InitialDelaySeconds = genruntime.ClonePointerToInt(probe.InitialDelaySeconds)

	// PeriodSeconds
	destination.PeriodSeconds = genruntime.ClonePointerToInt(probe.PeriodSeconds)

	// SuccessThreshold
	destination.SuccessThreshold = genruntime.ClonePointerToInt(probe.SuccessThreshold)

	// TimeoutSeconds
	destination.TimeoutSeconds = genruntime.ClonePointerToInt(probe.TimeoutSeconds)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ContainerProperties_InstanceView_STATUS struct {
	// CurrentState: Current container instance state.
	CurrentState *ContainerState_STATUS `json:"currentState,omitempty"`

	// Events: The events of the container instance.
	Events []Event_STATUS `json:"events,omitempty"`

	// PreviousState: Previous container instance state.
	PreviousState *ContainerState_STATUS `json:"previousState,omitempty"`

	// RestartCount: The number of times that the container instance has been restarted.
	RestartCount *int `json:"restartCount,omitempty"`
}

var _ genruntime.FromARMConverter = &ContainerProperties_InstanceView_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (view *ContainerProperties_InstanceView_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ContainerProperties_InstanceView_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (view *ContainerProperties_InstanceView_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ContainerProperties_InstanceView_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ContainerProperties_InstanceView_STATUS, got %T", armInput)
	}

	// Set property "CurrentState":
	if typedInput.CurrentState != nil {
		var currentState1 ContainerState_STATUS
		err := currentState1.PopulateFromARM(owner, *typedInput.CurrentState)
		if err != nil {
			return err
		}
		currentState := currentState1
		view.CurrentState = &currentState
	}

	// Set property "Events":
	for _, item := range typedInput.Events {
		var item1 Event_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		view.Events = append(view.Events, item1)
	}

	// Set property "PreviousState":
	if typedInput.PreviousState != nil {
		var previousState1 ContainerState_STATUS
		err := previousState1.PopulateFromARM(owner, *typedInput.PreviousState)
		if err != nil {
			return err
		}
		previousState := previousState1
		view.PreviousState = &previousState
	}

	// Set property "RestartCount":
	if typedInput.RestartCount != nil {
		restartCount := *typedInput.RestartCount
		view.RestartCount = &restartCount
	}

	// No error
	return nil
}

// AssignProperties_From_ContainerProperties_InstanceView_STATUS populates our ContainerProperties_InstanceView_STATUS from the provided source ContainerProperties_InstanceView_STATUS
func (view *ContainerProperties_InstanceView_STATUS) AssignProperties_From_ContainerProperties_InstanceView_STATUS(source *storage.ContainerProperties_InstanceView_STATUS) error {

	// CurrentState
	if source.CurrentState != nil {
		var currentState ContainerState_STATUS
		err := currentState.AssignProperties_From_ContainerState_STATUS(source.CurrentState)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ContainerState_STATUS() to populate field CurrentState")
		}
		view.CurrentState = &currentState
	} else {
		view.CurrentState = nil
	}

	// Events
	if source.Events != nil {
		eventList := make([]Event_STATUS, len(source.Events))
		for eventIndex, eventItem := range source.Events {
			// Shadow the loop variable to avoid aliasing
			eventItem := eventItem
			var event Event_STATUS
			err := event.AssignProperties_From_Event_STATUS(&eventItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_Event_STATUS() to populate field Events")
			}
			eventList[eventIndex] = event
		}
		view.Events = eventList
	} else {
		view.Events = nil
	}

	// PreviousState
	if source.PreviousState != nil {
		var previousState ContainerState_STATUS
		err := previousState.AssignProperties_From_ContainerState_STATUS(source.PreviousState)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ContainerState_STATUS() to populate field PreviousState")
		}
		view.PreviousState = &previousState
	} else {
		view.PreviousState = nil
	}

	// RestartCount
	view.RestartCount = genruntime.ClonePointerToInt(source.RestartCount)

	// No error
	return nil
}

// AssignProperties_To_ContainerProperties_InstanceView_STATUS populates the provided destination ContainerProperties_InstanceView_STATUS from our ContainerProperties_InstanceView_STATUS
func (view *ContainerProperties_InstanceView_STATUS) AssignProperties_To_ContainerProperties_InstanceView_STATUS(destination *storage.ContainerProperties_InstanceView_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CurrentState
	if view.CurrentState != nil {
		var currentState storage.ContainerState_STATUS
		err := view.CurrentState.AssignProperties_To_ContainerState_STATUS(&currentState)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ContainerState_STATUS() to populate field CurrentState")
		}
		destination.CurrentState = &currentState
	} else {
		destination.CurrentState = nil
	}

	// Events
	if view.Events != nil {
		eventList := make([]storage.Event_STATUS, len(view.Events))
		for eventIndex, eventItem := range view.Events {
			// Shadow the loop variable to avoid aliasing
			eventItem := eventItem
			var event storage.Event_STATUS
			err := eventItem.AssignProperties_To_Event_STATUS(&event)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_Event_STATUS() to populate field Events")
			}
			eventList[eventIndex] = event
		}
		destination.Events = eventList
	} else {
		destination.Events = nil
	}

	// PreviousState
	if view.PreviousState != nil {
		var previousState storage.ContainerState_STATUS
		err := view.PreviousState.AssignProperties_To_ContainerState_STATUS(&previousState)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ContainerState_STATUS() to populate field PreviousState")
		}
		destination.PreviousState = &previousState
	} else {
		destination.PreviousState = nil
	}

	// RestartCount
	destination.RestartCount = genruntime.ClonePointerToInt(view.RestartCount)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The environment variable to set within the container instance.
type EnvironmentVariable struct {
	// +kubebuilder:validation:Required
	// Name: The name of the environment variable.
	Name *string `json:"name,omitempty"`

	// SecureValue: The value of the secure environment variable.
	SecureValue *genruntime.SecretReference `json:"secureValue,omitempty"`

	// Value: The value of the environment variable.
	Value *string `json:"value,omitempty"`
}

var _ genruntime.ARMTransformer = &EnvironmentVariable{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (variable *EnvironmentVariable) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if variable == nil {
		return nil, nil
	}
	result := &arm.EnvironmentVariable{}

	// Set property "Name":
	if variable.Name != nil {
		name := *variable.Name
		result.Name = &name
	}

	// Set property "SecureValue":
	if variable.SecureValue != nil {
		secureValueSecret, err := resolved.ResolvedSecrets.Lookup(*variable.SecureValue)
		if err != nil {
			return nil, errors.Wrap(err, "looking up secret for property SecureValue")
		}
		secureValue := secureValueSecret
		result.SecureValue = &secureValue
	}

	// Set property "Value":
	if variable.Value != nil {
		value := *variable.Value
		result.Value = &value
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (variable *EnvironmentVariable) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.EnvironmentVariable{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (variable *EnvironmentVariable) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.EnvironmentVariable)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.EnvironmentVariable, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		variable.Name = &name
	}

	// no assignment for property "SecureValue"

	// Set property "Value":
	if typedInput.Value != nil {
		value := *typedInput.Value
		variable.Value = &value
	}

	// No error
	return nil
}

// AssignProperties_From_EnvironmentVariable populates our EnvironmentVariable from the provided source EnvironmentVariable
func (variable *EnvironmentVariable) AssignProperties_From_EnvironmentVariable(source *storage.EnvironmentVariable) error {

	// Name
	variable.Name = genruntime.ClonePointerToString(source.Name)

	// SecureValue
	if source.SecureValue != nil {
		secureValue := source.SecureValue.Copy()
		variable.SecureValue = &secureValue
	} else {
		variable.SecureValue = nil
	}

	// Value
	variable.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// AssignProperties_To_EnvironmentVariable populates the provided destination EnvironmentVariable from our EnvironmentVariable
func (variable *EnvironmentVariable) AssignProperties_To_EnvironmentVariable(destination *storage.EnvironmentVariable) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(variable.Name)

	// SecureValue
	if variable.SecureValue != nil {
		secureValue := variable.SecureValue.Copy()
		destination.SecureValue = &secureValue
	} else {
		destination.SecureValue = nil
	}

	// Value
	destination.Value = genruntime.ClonePointerToString(variable.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_EnvironmentVariable_STATUS populates our EnvironmentVariable from the provided source EnvironmentVariable_STATUS
func (variable *EnvironmentVariable) Initialize_From_EnvironmentVariable_STATUS(source *EnvironmentVariable_STATUS) error {

	// Name
	variable.Name = genruntime.ClonePointerToString(source.Name)

	// Value
	variable.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// The environment variable to set within the container instance.
type EnvironmentVariable_STATUS struct {
	// Name: The name of the environment variable.
	Name *string `json:"name,omitempty"`

	// Value: The value of the environment variable.
	Value *string `json:"value,omitempty"`
}

var _ genruntime.FromARMConverter = &EnvironmentVariable_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (variable *EnvironmentVariable_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.EnvironmentVariable_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (variable *EnvironmentVariable_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.EnvironmentVariable_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.EnvironmentVariable_STATUS, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		variable.Name = &name
	}

	// Set property "Value":
	if typedInput.Value != nil {
		value := *typedInput.Value
		variable.Value = &value
	}

	// No error
	return nil
}

// AssignProperties_From_EnvironmentVariable_STATUS populates our EnvironmentVariable_STATUS from the provided source EnvironmentVariable_STATUS
func (variable *EnvironmentVariable_STATUS) AssignProperties_From_EnvironmentVariable_STATUS(source *storage.EnvironmentVariable_STATUS) error {

	// Name
	variable.Name = genruntime.ClonePointerToString(source.Name)

	// Value
	variable.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// AssignProperties_To_EnvironmentVariable_STATUS populates the provided destination EnvironmentVariable_STATUS from our EnvironmentVariable_STATUS
func (variable *EnvironmentVariable_STATUS) AssignProperties_To_EnvironmentVariable_STATUS(destination *storage.EnvironmentVariable_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(variable.Name)

	// Value
	destination.Value = genruntime.ClonePointerToString(variable.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// A container group or container instance event.
type Event_STATUS struct {
	// Count: The count of the event.
	Count *int `json:"count,omitempty"`

	// FirstTimestamp: The date-time of the earliest logged event.
	FirstTimestamp *string `json:"firstTimestamp,omitempty"`

	// LastTimestamp: The date-time of the latest logged event.
	LastTimestamp *string `json:"lastTimestamp,omitempty"`

	// Message: The event message.
	Message *string `json:"message,omitempty"`

	// Name: The event name.
	Name *string `json:"name,omitempty"`

	// Type: The event type.
	Type *string `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &Event_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (event *Event_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Event_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (event *Event_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Event_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Event_STATUS, got %T", armInput)
	}

	// Set property "Count":
	if typedInput.Count != nil {
		count := *typedInput.Count
		event.Count = &count
	}

	// Set property "FirstTimestamp":
	if typedInput.FirstTimestamp != nil {
		firstTimestamp := *typedInput.FirstTimestamp
		event.FirstTimestamp = &firstTimestamp
	}

	// Set property "LastTimestamp":
	if typedInput.LastTimestamp != nil {
		lastTimestamp := *typedInput.LastTimestamp
		event.LastTimestamp = &lastTimestamp
	}

	// Set property "Message":
	if typedInput.Message != nil {
		message := *typedInput.Message
		event.Message = &message
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		event.Name = &name
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		event.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_Event_STATUS populates our Event_STATUS from the provided source Event_STATUS
func (event *Event_STATUS) AssignProperties_From_Event_STATUS(source *storage.Event_STATUS) error {

	// Count
	event.Count = genruntime.ClonePointerToInt(source.Count)

	// FirstTimestamp
	event.FirstTimestamp = genruntime.ClonePointerToString(source.FirstTimestamp)

	// LastTimestamp
	event.LastTimestamp = genruntime.ClonePointerToString(source.LastTimestamp)

	// Message
	event.Message = genruntime.ClonePointerToString(source.Message)

	// Name
	event.Name = genruntime.ClonePointerToString(source.Name)

	// Type
	event.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignProperties_To_Event_STATUS populates the provided destination Event_STATUS from our Event_STATUS
func (event *Event_STATUS) AssignProperties_To_Event_STATUS(destination *storage.Event_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Count
	destination.Count = genruntime.ClonePointerToInt(event.Count)

	// FirstTimestamp
	destination.FirstTimestamp = genruntime.ClonePointerToString(event.FirstTimestamp)

	// LastTimestamp
	destination.LastTimestamp = genruntime.ClonePointerToString(event.LastTimestamp)

	// Message
	destination.Message = genruntime.ClonePointerToString(event.Message)

	// Name
	destination.Name = genruntime.ClonePointerToString(event.Name)

	// Type
	destination.Type = genruntime.ClonePointerToString(event.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Represents a volume that is populated with the contents of a git repository
type GitRepoVolume struct {
	// Directory: Target directory name. Must not contain or start with '..'.  If '.' is supplied, the volume directory will be
	// the git repository.  Otherwise, if specified, the volume will contain the git repository in the subdirectory with the
	// given name.
	Directory *string `json:"directory,omitempty"`

	// +kubebuilder:validation:Required
	// Repository: Repository URL
	Repository *string `json:"repository,omitempty"`

	// Revision: Commit hash for the specified revision.
	Revision *string `json:"revision,omitempty"`
}

var _ genruntime.ARMTransformer = &GitRepoVolume{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (volume *GitRepoVolume) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if volume == nil {
		return nil, nil
	}
	result := &arm.GitRepoVolume{}

	// Set property "Directory":
	if volume.Directory != nil {
		directory := *volume.Directory
		result.Directory = &directory
	}

	// Set property "Repository":
	if volume.Repository != nil {
		repository := *volume.Repository
		result.Repository = &repository
	}

	// Set property "Revision":
	if volume.Revision != nil {
		revision := *volume.Revision
		result.Revision = &revision
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (volume *GitRepoVolume) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.GitRepoVolume{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (volume *GitRepoVolume) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.GitRepoVolume)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.GitRepoVolume, got %T", armInput)
	}

	// Set property "Directory":
	if typedInput.Directory != nil {
		directory := *typedInput.Directory
		volume.Directory = &directory
	}

	// Set property "Repository":
	if typedInput.Repository != nil {
		repository := *typedInput.Repository
		volume.Repository = &repository
	}

	// Set property "Revision":
	if typedInput.Revision != nil {
		revision := *typedInput.Revision
		volume.Revision = &revision
	}

	// No error
	return nil
}

// AssignProperties_From_GitRepoVolume populates our GitRepoVolume from the provided source GitRepoVolume
func (volume *GitRepoVolume) AssignProperties_From_GitRepoVolume(source *storage.GitRepoVolume) error {

	// Directory
	volume.Directory = genruntime.ClonePointerToString(source.Directory)

	// Repository
	volume.Repository = genruntime.ClonePointerToString(source.Repository)

	// Revision
	volume.Revision = genruntime.ClonePointerToString(source.Revision)

	// No error
	return nil
}

// AssignProperties_To_GitRepoVolume populates the provided destination GitRepoVolume from our GitRepoVolume
func (volume *GitRepoVolume) AssignProperties_To_GitRepoVolume(destination *storage.GitRepoVolume) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Directory
	destination.Directory = genruntime.ClonePointerToString(volume.Directory)

	// Repository
	destination.Repository = genruntime.ClonePointerToString(volume.Repository)

	// Revision
	destination.Revision = genruntime.ClonePointerToString(volume.Revision)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_GitRepoVolume_STATUS populates our GitRepoVolume from the provided source GitRepoVolume_STATUS
func (volume *GitRepoVolume) Initialize_From_GitRepoVolume_STATUS(source *GitRepoVolume_STATUS) error {

	// Directory
	volume.Directory = genruntime.ClonePointerToString(source.Directory)

	// Repository
	volume.Repository = genruntime.ClonePointerToString(source.Repository)

	// Revision
	volume.Revision = genruntime.ClonePointerToString(source.Revision)

	// No error
	return nil
}

// Represents a volume that is populated with the contents of a git repository
type GitRepoVolume_STATUS struct {
	// Directory: Target directory name. Must not contain or start with '..'.  If '.' is supplied, the volume directory will be
	// the git repository.  Otherwise, if specified, the volume will contain the git repository in the subdirectory with the
	// given name.
	Directory *string `json:"directory,omitempty"`

	// Repository: Repository URL
	Repository *string `json:"repository,omitempty"`

	// Revision: Commit hash for the specified revision.
	Revision *string `json:"revision,omitempty"`
}

var _ genruntime.FromARMConverter = &GitRepoVolume_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (volume *GitRepoVolume_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.GitRepoVolume_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (volume *GitRepoVolume_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.GitRepoVolume_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.GitRepoVolume_STATUS, got %T", armInput)
	}

	// Set property "Directory":
	if typedInput.Directory != nil {
		directory := *typedInput.Directory
		volume.Directory = &directory
	}

	// Set property "Repository":
	if typedInput.Repository != nil {
		repository := *typedInput.Repository
		volume.Repository = &repository
	}

	// Set property "Revision":
	if typedInput.Revision != nil {
		revision := *typedInput.Revision
		volume.Revision = &revision
	}

	// No error
	return nil
}

// AssignProperties_From_GitRepoVolume_STATUS populates our GitRepoVolume_STATUS from the provided source GitRepoVolume_STATUS
func (volume *GitRepoVolume_STATUS) AssignProperties_From_GitRepoVolume_STATUS(source *storage.GitRepoVolume_STATUS) error {

	// Directory
	volume.Directory = genruntime.ClonePointerToString(source.Directory)

	// Repository
	volume.Repository = genruntime.ClonePointerToString(source.Repository)

	// Revision
	volume.Revision = genruntime.ClonePointerToString(source.Revision)

	// No error
	return nil
}

// AssignProperties_To_GitRepoVolume_STATUS populates the provided destination GitRepoVolume_STATUS from our GitRepoVolume_STATUS
func (volume *GitRepoVolume_STATUS) AssignProperties_To_GitRepoVolume_STATUS(destination *storage.GitRepoVolume_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Directory
	destination.Directory = genruntime.ClonePointerToString(volume.Directory)

	// Repository
	destination.Repository = genruntime.ClonePointerToString(volume.Repository)

	// Revision
	destination.Revision = genruntime.ClonePointerToString(volume.Revision)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type InitContainerPropertiesDefinition_InstanceView_STATUS struct {
	// CurrentState: The current state of the init container.
	CurrentState *ContainerState_STATUS `json:"currentState,omitempty"`

	// Events: The events of the init container.
	Events []Event_STATUS `json:"events,omitempty"`

	// PreviousState: The previous state of the init container.
	PreviousState *ContainerState_STATUS `json:"previousState,omitempty"`

	// RestartCount: The number of times that the init container has been restarted.
	RestartCount *int `json:"restartCount,omitempty"`
}

var _ genruntime.FromARMConverter = &InitContainerPropertiesDefinition_InstanceView_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (view *InitContainerPropertiesDefinition_InstanceView_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.InitContainerPropertiesDefinition_InstanceView_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (view *InitContainerPropertiesDefinition_InstanceView_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.InitContainerPropertiesDefinition_InstanceView_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.InitContainerPropertiesDefinition_InstanceView_STATUS, got %T", armInput)
	}

	// Set property "CurrentState":
	if typedInput.CurrentState != nil {
		var currentState1 ContainerState_STATUS
		err := currentState1.PopulateFromARM(owner, *typedInput.CurrentState)
		if err != nil {
			return err
		}
		currentState := currentState1
		view.CurrentState = &currentState
	}

	// Set property "Events":
	for _, item := range typedInput.Events {
		var item1 Event_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		view.Events = append(view.Events, item1)
	}

	// Set property "PreviousState":
	if typedInput.PreviousState != nil {
		var previousState1 ContainerState_STATUS
		err := previousState1.PopulateFromARM(owner, *typedInput.PreviousState)
		if err != nil {
			return err
		}
		previousState := previousState1
		view.PreviousState = &previousState
	}

	// Set property "RestartCount":
	if typedInput.RestartCount != nil {
		restartCount := *typedInput.RestartCount
		view.RestartCount = &restartCount
	}

	// No error
	return nil
}

// AssignProperties_From_InitContainerPropertiesDefinition_InstanceView_STATUS populates our InitContainerPropertiesDefinition_InstanceView_STATUS from the provided source InitContainerPropertiesDefinition_InstanceView_STATUS
func (view *InitContainerPropertiesDefinition_InstanceView_STATUS) AssignProperties_From_InitContainerPropertiesDefinition_InstanceView_STATUS(source *storage.InitContainerPropertiesDefinition_InstanceView_STATUS) error {

	// CurrentState
	if source.CurrentState != nil {
		var currentState ContainerState_STATUS
		err := currentState.AssignProperties_From_ContainerState_STATUS(source.CurrentState)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ContainerState_STATUS() to populate field CurrentState")
		}
		view.CurrentState = &currentState
	} else {
		view.CurrentState = nil
	}

	// Events
	if source.Events != nil {
		eventList := make([]Event_STATUS, len(source.Events))
		for eventIndex, eventItem := range source.Events {
			// Shadow the loop variable to avoid aliasing
			eventItem := eventItem
			var event Event_STATUS
			err := event.AssignProperties_From_Event_STATUS(&eventItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_Event_STATUS() to populate field Events")
			}
			eventList[eventIndex] = event
		}
		view.Events = eventList
	} else {
		view.Events = nil
	}

	// PreviousState
	if source.PreviousState != nil {
		var previousState ContainerState_STATUS
		err := previousState.AssignProperties_From_ContainerState_STATUS(source.PreviousState)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ContainerState_STATUS() to populate field PreviousState")
		}
		view.PreviousState = &previousState
	} else {
		view.PreviousState = nil
	}

	// RestartCount
	view.RestartCount = genruntime.ClonePointerToInt(source.RestartCount)

	// No error
	return nil
}

// AssignProperties_To_InitContainerPropertiesDefinition_InstanceView_STATUS populates the provided destination InitContainerPropertiesDefinition_InstanceView_STATUS from our InitContainerPropertiesDefinition_InstanceView_STATUS
func (view *InitContainerPropertiesDefinition_InstanceView_STATUS) AssignProperties_To_InitContainerPropertiesDefinition_InstanceView_STATUS(destination *storage.InitContainerPropertiesDefinition_InstanceView_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CurrentState
	if view.CurrentState != nil {
		var currentState storage.ContainerState_STATUS
		err := view.CurrentState.AssignProperties_To_ContainerState_STATUS(&currentState)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ContainerState_STATUS() to populate field CurrentState")
		}
		destination.CurrentState = &currentState
	} else {
		destination.CurrentState = nil
	}

	// Events
	if view.Events != nil {
		eventList := make([]storage.Event_STATUS, len(view.Events))
		for eventIndex, eventItem := range view.Events {
			// Shadow the loop variable to avoid aliasing
			eventItem := eventItem
			var event storage.Event_STATUS
			err := eventItem.AssignProperties_To_Event_STATUS(&event)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_Event_STATUS() to populate field Events")
			}
			eventList[eventIndex] = event
		}
		destination.Events = eventList
	} else {
		destination.Events = nil
	}

	// PreviousState
	if view.PreviousState != nil {
		var previousState storage.ContainerState_STATUS
		err := view.PreviousState.AssignProperties_To_ContainerState_STATUS(&previousState)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ContainerState_STATUS() to populate field PreviousState")
		}
		destination.PreviousState = &previousState
	} else {
		destination.PreviousState = nil
	}

	// RestartCount
	destination.RestartCount = genruntime.ClonePointerToInt(view.RestartCount)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Noreuse","ResourceGroupReuse","SubscriptionReuse","TenantReuse","Unsecure"}
type IpAddress_AutoGeneratedDomainNameLabelScope string

const (
	IpAddress_AutoGeneratedDomainNameLabelScope_Noreuse            = IpAddress_AutoGeneratedDomainNameLabelScope("Noreuse")
	IpAddress_AutoGeneratedDomainNameLabelScope_ResourceGroupReuse = IpAddress_AutoGeneratedDomainNameLabelScope("ResourceGroupReuse")
	IpAddress_AutoGeneratedDomainNameLabelScope_SubscriptionReuse  = IpAddress_AutoGeneratedDomainNameLabelScope("SubscriptionReuse")
	IpAddress_AutoGeneratedDomainNameLabelScope_TenantReuse        = IpAddress_AutoGeneratedDomainNameLabelScope("TenantReuse")
	IpAddress_AutoGeneratedDomainNameLabelScope_Unsecure           = IpAddress_AutoGeneratedDomainNameLabelScope("Unsecure")
)

// Mapping from string to IpAddress_AutoGeneratedDomainNameLabelScope
var ipAddress_AutoGeneratedDomainNameLabelScope_Values = map[string]IpAddress_AutoGeneratedDomainNameLabelScope{
	"noreuse":            IpAddress_AutoGeneratedDomainNameLabelScope_Noreuse,
	"resourcegroupreuse": IpAddress_AutoGeneratedDomainNameLabelScope_ResourceGroupReuse,
	"subscriptionreuse":  IpAddress_AutoGeneratedDomainNameLabelScope_SubscriptionReuse,
	"tenantreuse":        IpAddress_AutoGeneratedDomainNameLabelScope_TenantReuse,
	"unsecure":           IpAddress_AutoGeneratedDomainNameLabelScope_Unsecure,
}

type IpAddress_AutoGeneratedDomainNameLabelScope_STATUS string

const (
	IpAddress_AutoGeneratedDomainNameLabelScope_STATUS_Noreuse            = IpAddress_AutoGeneratedDomainNameLabelScope_STATUS("Noreuse")
	IpAddress_AutoGeneratedDomainNameLabelScope_STATUS_ResourceGroupReuse = IpAddress_AutoGeneratedDomainNameLabelScope_STATUS("ResourceGroupReuse")
	IpAddress_AutoGeneratedDomainNameLabelScope_STATUS_SubscriptionReuse  = IpAddress_AutoGeneratedDomainNameLabelScope_STATUS("SubscriptionReuse")
	IpAddress_AutoGeneratedDomainNameLabelScope_STATUS_TenantReuse        = IpAddress_AutoGeneratedDomainNameLabelScope_STATUS("TenantReuse")
	IpAddress_AutoGeneratedDomainNameLabelScope_STATUS_Unsecure           = IpAddress_AutoGeneratedDomainNameLabelScope_STATUS("Unsecure")
)

// Mapping from string to IpAddress_AutoGeneratedDomainNameLabelScope_STATUS
var ipAddress_AutoGeneratedDomainNameLabelScope_STATUS_Values = map[string]IpAddress_AutoGeneratedDomainNameLabelScope_STATUS{
	"noreuse":            IpAddress_AutoGeneratedDomainNameLabelScope_STATUS_Noreuse,
	"resourcegroupreuse": IpAddress_AutoGeneratedDomainNameLabelScope_STATUS_ResourceGroupReuse,
	"subscriptionreuse":  IpAddress_AutoGeneratedDomainNameLabelScope_STATUS_SubscriptionReuse,
	"tenantreuse":        IpAddress_AutoGeneratedDomainNameLabelScope_STATUS_TenantReuse,
	"unsecure":           IpAddress_AutoGeneratedDomainNameLabelScope_STATUS_Unsecure,
}

// +kubebuilder:validation:Enum={"Private","Public"}
type IpAddress_Type string

const (
	IpAddress_Type_Private = IpAddress_Type("Private")
	IpAddress_Type_Public  = IpAddress_Type("Public")
)

// Mapping from string to IpAddress_Type
var ipAddress_Type_Values = map[string]IpAddress_Type{
	"private": IpAddress_Type_Private,
	"public":  IpAddress_Type_Public,
}

type IpAddress_Type_STATUS string

const (
	IpAddress_Type_STATUS_Private = IpAddress_Type_STATUS("Private")
	IpAddress_Type_STATUS_Public  = IpAddress_Type_STATUS("Public")
)

// Mapping from string to IpAddress_Type_STATUS
var ipAddress_Type_STATUS_Values = map[string]IpAddress_Type_STATUS{
	"private": IpAddress_Type_STATUS_Private,
	"public":  IpAddress_Type_STATUS_Public,
}

// Container group log analytics information.
type LogAnalytics struct {
	// LogType: The log type to be used.
	LogType *LogAnalytics_LogType `json:"logType,omitempty"`

	// Metadata: Metadata for log analytics.
	Metadata map[string]string `json:"metadata,omitempty"`

	// +kubebuilder:validation:Required
	// WorkspaceId: The workspace id for log analytics
	WorkspaceId *string `json:"workspaceId,omitempty"`

	// +kubebuilder:validation:Required
	// WorkspaceKey: The workspace key for log analytics
	WorkspaceKey *genruntime.SecretReference `json:"workspaceKey,omitempty"`

	// WorkspaceResourceReference: The workspace resource id for log analytics
	WorkspaceResourceReference *genruntime.ResourceReference `armReference:"WorkspaceResourceId" json:"workspaceResourceReference,omitempty"`
}

var _ genruntime.ARMTransformer = &LogAnalytics{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (analytics *LogAnalytics) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if analytics == nil {
		return nil, nil
	}
	result := &arm.LogAnalytics{}

	// Set property "LogType":
	if analytics.LogType != nil {
		var temp string
		temp = string(*analytics.LogType)
		logType := arm.LogAnalytics_LogType(temp)
		result.LogType = &logType
	}

	// Set property "Metadata":
	if analytics.Metadata != nil {
		result.Metadata = make(map[string]string, len(analytics.Metadata))
		for key, value := range analytics.Metadata {
			result.Metadata[key] = value
		}
	}

	// Set property "WorkspaceId":
	if analytics.WorkspaceId != nil {
		workspaceId := *analytics.WorkspaceId
		result.WorkspaceId = &workspaceId
	}

	// Set property "WorkspaceKey":
	if analytics.WorkspaceKey != nil {
		workspaceKeySecret, err := resolved.ResolvedSecrets.Lookup(*analytics.WorkspaceKey)
		if err != nil {
			return nil, errors.Wrap(err, "looking up secret for property WorkspaceKey")
		}
		workspaceKey := workspaceKeySecret
		result.WorkspaceKey = &workspaceKey
	}

	// Set property "WorkspaceResourceId":
	if analytics.WorkspaceResourceReference != nil {
		workspaceResourceReferenceARMID, err := resolved.ResolvedReferences.Lookup(*analytics.WorkspaceResourceReference)
		if err != nil {
			return nil, err
		}
		workspaceResourceReference := workspaceResourceReferenceARMID
		result.WorkspaceResourceId = &workspaceResourceReference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (analytics *LogAnalytics) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.LogAnalytics{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (analytics *LogAnalytics) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.LogAnalytics)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.LogAnalytics, got %T", armInput)
	}

	// Set property "LogType":
	if typedInput.LogType != nil {
		var temp string
		temp = string(*typedInput.LogType)
		logType := LogAnalytics_LogType(temp)
		analytics.LogType = &logType
	}

	// Set property "Metadata":
	if typedInput.Metadata != nil {
		analytics.Metadata = make(map[string]string, len(typedInput.Metadata))
		for key, value := range typedInput.Metadata {
			analytics.Metadata[key] = value
		}
	}

	// Set property "WorkspaceId":
	if typedInput.WorkspaceId != nil {
		workspaceId := *typedInput.WorkspaceId
		analytics.WorkspaceId = &workspaceId
	}

	// no assignment for property "WorkspaceKey"

	// no assignment for property "WorkspaceResourceReference"

	// No error
	return nil
}

// AssignProperties_From_LogAnalytics populates our LogAnalytics from the provided source LogAnalytics
func (analytics *LogAnalytics) AssignProperties_From_LogAnalytics(source *storage.LogAnalytics) error {

	// LogType
	if source.LogType != nil {
		logType := *source.LogType
		logTypeTemp := genruntime.ToEnum(logType, logAnalytics_LogType_Values)
		analytics.LogType = &logTypeTemp
	} else {
		analytics.LogType = nil
	}

	// Metadata
	analytics.Metadata = genruntime.CloneMapOfStringToString(source.Metadata)

	// WorkspaceId
	analytics.WorkspaceId = genruntime.ClonePointerToString(source.WorkspaceId)

	// WorkspaceKey
	if source.WorkspaceKey != nil {
		workspaceKey := source.WorkspaceKey.Copy()
		analytics.WorkspaceKey = &workspaceKey
	} else {
		analytics.WorkspaceKey = nil
	}

	// WorkspaceResourceReference
	if source.WorkspaceResourceReference != nil {
		workspaceResourceReference := source.WorkspaceResourceReference.Copy()
		analytics.WorkspaceResourceReference = &workspaceResourceReference
	} else {
		analytics.WorkspaceResourceReference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_LogAnalytics populates the provided destination LogAnalytics from our LogAnalytics
func (analytics *LogAnalytics) AssignProperties_To_LogAnalytics(destination *storage.LogAnalytics) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// LogType
	if analytics.LogType != nil {
		logType := string(*analytics.LogType)
		destination.LogType = &logType
	} else {
		destination.LogType = nil
	}

	// Metadata
	destination.Metadata = genruntime.CloneMapOfStringToString(analytics.Metadata)

	// WorkspaceId
	destination.WorkspaceId = genruntime.ClonePointerToString(analytics.WorkspaceId)

	// WorkspaceKey
	if analytics.WorkspaceKey != nil {
		workspaceKey := analytics.WorkspaceKey.Copy()
		destination.WorkspaceKey = &workspaceKey
	} else {
		destination.WorkspaceKey = nil
	}

	// WorkspaceResourceReference
	if analytics.WorkspaceResourceReference != nil {
		workspaceResourceReference := analytics.WorkspaceResourceReference.Copy()
		destination.WorkspaceResourceReference = &workspaceResourceReference
	} else {
		destination.WorkspaceResourceReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_LogAnalytics_STATUS populates our LogAnalytics from the provided source LogAnalytics_STATUS
func (analytics *LogAnalytics) Initialize_From_LogAnalytics_STATUS(source *LogAnalytics_STATUS) error {

	// LogType
	if source.LogType != nil {
		logType := genruntime.ToEnum(string(*source.LogType), logAnalytics_LogType_Values)
		analytics.LogType = &logType
	} else {
		analytics.LogType = nil
	}

	// Metadata
	analytics.Metadata = genruntime.CloneMapOfStringToString(source.Metadata)

	// WorkspaceId
	analytics.WorkspaceId = genruntime.ClonePointerToString(source.WorkspaceId)

	// No error
	return nil
}

// Container group log analytics information.
type LogAnalytics_STATUS struct {
	// LogType: The log type to be used.
	LogType *LogAnalytics_LogType_STATUS `json:"logType,omitempty"`

	// Metadata: Metadata for log analytics.
	Metadata map[string]string `json:"metadata,omitempty"`

	// WorkspaceId: The workspace id for log analytics
	WorkspaceId *string `json:"workspaceId,omitempty"`
}

var _ genruntime.FromARMConverter = &LogAnalytics_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (analytics *LogAnalytics_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.LogAnalytics_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (analytics *LogAnalytics_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.LogAnalytics_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.LogAnalytics_STATUS, got %T", armInput)
	}

	// Set property "LogType":
	if typedInput.LogType != nil {
		var temp string
		temp = string(*typedInput.LogType)
		logType := LogAnalytics_LogType_STATUS(temp)
		analytics.LogType = &logType
	}

	// Set property "Metadata":
	if typedInput.Metadata != nil {
		analytics.Metadata = make(map[string]string, len(typedInput.Metadata))
		for key, value := range typedInput.Metadata {
			analytics.Metadata[key] = value
		}
	}

	// Set property "WorkspaceId":
	if typedInput.WorkspaceId != nil {
		workspaceId := *typedInput.WorkspaceId
		analytics.WorkspaceId = &workspaceId
	}

	// No error
	return nil
}

// AssignProperties_From_LogAnalytics_STATUS populates our LogAnalytics_STATUS from the provided source LogAnalytics_STATUS
func (analytics *LogAnalytics_STATUS) AssignProperties_From_LogAnalytics_STATUS(source *storage.LogAnalytics_STATUS) error {

	// LogType
	if source.LogType != nil {
		logType := *source.LogType
		logTypeTemp := genruntime.ToEnum(logType, logAnalytics_LogType_STATUS_Values)
		analytics.LogType = &logTypeTemp
	} else {
		analytics.LogType = nil
	}

	// Metadata
	analytics.Metadata = genruntime.CloneMapOfStringToString(source.Metadata)

	// WorkspaceId
	analytics.WorkspaceId = genruntime.ClonePointerToString(source.WorkspaceId)

	// No error
	return nil
}

// AssignProperties_To_LogAnalytics_STATUS populates the provided destination LogAnalytics_STATUS from our LogAnalytics_STATUS
func (analytics *LogAnalytics_STATUS) AssignProperties_To_LogAnalytics_STATUS(destination *storage.LogAnalytics_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// LogType
	if analytics.LogType != nil {
		logType := string(*analytics.LogType)
		destination.LogType = &logType
	} else {
		destination.LogType = nil
	}

	// Metadata
	destination.Metadata = genruntime.CloneMapOfStringToString(analytics.Metadata)

	// WorkspaceId
	destination.WorkspaceId = genruntime.ClonePointerToString(analytics.WorkspaceId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The port exposed on the container group.
type Port struct {
	// +kubebuilder:validation:Required
	// Port: The port number.
	Port *int `json:"port,omitempty"`

	// Protocol: The protocol associated with the port.
	Protocol *Port_Protocol `json:"protocol,omitempty"`
}

var _ genruntime.ARMTransformer = &Port{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (port *Port) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if port == nil {
		return nil, nil
	}
	result := &arm.Port{}

	// Set property "Port":
	if port.Port != nil {
		port1 := *port.Port
		result.Port = &port1
	}

	// Set property "Protocol":
	if port.Protocol != nil {
		var temp string
		temp = string(*port.Protocol)
		protocol := arm.Port_Protocol(temp)
		result.Protocol = &protocol
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (port *Port) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Port{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (port *Port) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Port)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Port, got %T", armInput)
	}

	// Set property "Port":
	if typedInput.Port != nil {
		port1 := *typedInput.Port
		port.Port = &port1
	}

	// Set property "Protocol":
	if typedInput.Protocol != nil {
		var temp string
		temp = string(*typedInput.Protocol)
		protocol := Port_Protocol(temp)
		port.Protocol = &protocol
	}

	// No error
	return nil
}

// AssignProperties_From_Port populates our Port from the provided source Port
func (port *Port) AssignProperties_From_Port(source *storage.Port) error {

	// Port
	port.Port = genruntime.ClonePointerToInt(source.Port)

	// Protocol
	if source.Protocol != nil {
		protocol := *source.Protocol
		protocolTemp := genruntime.ToEnum(protocol, port_Protocol_Values)
		port.Protocol = &protocolTemp
	} else {
		port.Protocol = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Port populates the provided destination Port from our Port
func (port *Port) AssignProperties_To_Port(destination *storage.Port) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Port
	destination.Port = genruntime.ClonePointerToInt(port.Port)

	// Protocol
	if port.Protocol != nil {
		protocol := string(*port.Protocol)
		destination.Protocol = &protocol
	} else {
		destination.Protocol = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_Port_STATUS populates our Port from the provided source Port_STATUS
func (port *Port) Initialize_From_Port_STATUS(source *Port_STATUS) error {

	// Port
	port.Port = genruntime.ClonePointerToInt(source.Port)

	// Protocol
	if source.Protocol != nil {
		protocol := genruntime.ToEnum(string(*source.Protocol), port_Protocol_Values)
		port.Protocol = &protocol
	} else {
		port.Protocol = nil
	}

	// No error
	return nil
}

// The port exposed on the container group.
type Port_STATUS struct {
	// Port: The port number.
	Port *int `json:"port,omitempty"`

	// Protocol: The protocol associated with the port.
	Protocol *Port_Protocol_STATUS `json:"protocol,omitempty"`
}

var _ genruntime.FromARMConverter = &Port_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (port *Port_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Port_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (port *Port_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Port_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Port_STATUS, got %T", armInput)
	}

	// Set property "Port":
	if typedInput.Port != nil {
		port1 := *typedInput.Port
		port.Port = &port1
	}

	// Set property "Protocol":
	if typedInput.Protocol != nil {
		var temp string
		temp = string(*typedInput.Protocol)
		protocol := Port_Protocol_STATUS(temp)
		port.Protocol = &protocol
	}

	// No error
	return nil
}

// AssignProperties_From_Port_STATUS populates our Port_STATUS from the provided source Port_STATUS
func (port *Port_STATUS) AssignProperties_From_Port_STATUS(source *storage.Port_STATUS) error {

	// Port
	port.Port = genruntime.ClonePointerToInt(source.Port)

	// Protocol
	if source.Protocol != nil {
		protocol := *source.Protocol
		protocolTemp := genruntime.ToEnum(protocol, port_Protocol_STATUS_Values)
		port.Protocol = &protocolTemp
	} else {
		port.Protocol = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Port_STATUS populates the provided destination Port_STATUS from our Port_STATUS
func (port *Port_STATUS) AssignProperties_To_Port_STATUS(destination *storage.Port_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Port
	destination.Port = genruntime.ClonePointerToInt(port.Port)

	// Protocol
	if port.Protocol != nil {
		protocol := string(*port.Protocol)
		destination.Protocol = &protocol
	} else {
		destination.Protocol = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The resource requirements.
type ResourceRequirements struct {
	// Limits: The resource limits of this container instance.
	Limits *ResourceLimits `json:"limits,omitempty"`

	// +kubebuilder:validation:Required
	// Requests: The resource requests of this container instance.
	Requests *ResourceRequests `json:"requests,omitempty"`
}

var _ genruntime.ARMTransformer = &ResourceRequirements{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (requirements *ResourceRequirements) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if requirements == nil {
		return nil, nil
	}
	result := &arm.ResourceRequirements{}

	// Set property "Limits":
	if requirements.Limits != nil {
		limits_ARM, err := (*requirements.Limits).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		limits := *limits_ARM.(*arm.ResourceLimits)
		result.Limits = &limits
	}

	// Set property "Requests":
	if requirements.Requests != nil {
		requests_ARM, err := (*requirements.Requests).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		requests := *requests_ARM.(*arm.ResourceRequests)
		result.Requests = &requests
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (requirements *ResourceRequirements) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ResourceRequirements{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (requirements *ResourceRequirements) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ResourceRequirements)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ResourceRequirements, got %T", armInput)
	}

	// Set property "Limits":
	if typedInput.Limits != nil {
		var limits1 ResourceLimits
		err := limits1.PopulateFromARM(owner, *typedInput.Limits)
		if err != nil {
			return err
		}
		limits := limits1
		requirements.Limits = &limits
	}

	// Set property "Requests":
	if typedInput.Requests != nil {
		var requests1 ResourceRequests
		err := requests1.PopulateFromARM(owner, *typedInput.Requests)
		if err != nil {
			return err
		}
		requests := requests1
		requirements.Requests = &requests
	}

	// No error
	return nil
}

// AssignProperties_From_ResourceRequirements populates our ResourceRequirements from the provided source ResourceRequirements
func (requirements *ResourceRequirements) AssignProperties_From_ResourceRequirements(source *storage.ResourceRequirements) error {

	// Limits
	if source.Limits != nil {
		var limit ResourceLimits
		err := limit.AssignProperties_From_ResourceLimits(source.Limits)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ResourceLimits() to populate field Limits")
		}
		requirements.Limits = &limit
	} else {
		requirements.Limits = nil
	}

	// Requests
	if source.Requests != nil {
		var request ResourceRequests
		err := request.AssignProperties_From_ResourceRequests(source.Requests)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ResourceRequests() to populate field Requests")
		}
		requirements.Requests = &request
	} else {
		requirements.Requests = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ResourceRequirements populates the provided destination ResourceRequirements from our ResourceRequirements
func (requirements *ResourceRequirements) AssignProperties_To_ResourceRequirements(destination *storage.ResourceRequirements) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Limits
	if requirements.Limits != nil {
		var limit storage.ResourceLimits
		err := requirements.Limits.AssignProperties_To_ResourceLimits(&limit)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ResourceLimits() to populate field Limits")
		}
		destination.Limits = &limit
	} else {
		destination.Limits = nil
	}

	// Requests
	if requirements.Requests != nil {
		var request storage.ResourceRequests
		err := requirements.Requests.AssignProperties_To_ResourceRequests(&request)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ResourceRequests() to populate field Requests")
		}
		destination.Requests = &request
	} else {
		destination.Requests = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ResourceRequirements_STATUS populates our ResourceRequirements from the provided source ResourceRequirements_STATUS
func (requirements *ResourceRequirements) Initialize_From_ResourceRequirements_STATUS(source *ResourceRequirements_STATUS) error {

	// Limits
	if source.Limits != nil {
		var limit ResourceLimits
		err := limit.Initialize_From_ResourceLimits_STATUS(source.Limits)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_ResourceLimits_STATUS() to populate field Limits")
		}
		requirements.Limits = &limit
	} else {
		requirements.Limits = nil
	}

	// Requests
	if source.Requests != nil {
		var request ResourceRequests
		err := request.Initialize_From_ResourceRequests_STATUS(source.Requests)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_ResourceRequests_STATUS() to populate field Requests")
		}
		requirements.Requests = &request
	} else {
		requirements.Requests = nil
	}

	// No error
	return nil
}

// The resource requirements.
type ResourceRequirements_STATUS struct {
	// Limits: The resource limits of this container instance.
	Limits *ResourceLimits_STATUS `json:"limits,omitempty"`

	// Requests: The resource requests of this container instance.
	Requests *ResourceRequests_STATUS `json:"requests,omitempty"`
}

var _ genruntime.FromARMConverter = &ResourceRequirements_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (requirements *ResourceRequirements_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ResourceRequirements_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (requirements *ResourceRequirements_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ResourceRequirements_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ResourceRequirements_STATUS, got %T", armInput)
	}

	// Set property "Limits":
	if typedInput.Limits != nil {
		var limits1 ResourceLimits_STATUS
		err := limits1.PopulateFromARM(owner, *typedInput.Limits)
		if err != nil {
			return err
		}
		limits := limits1
		requirements.Limits = &limits
	}

	// Set property "Requests":
	if typedInput.Requests != nil {
		var requests1 ResourceRequests_STATUS
		err := requests1.PopulateFromARM(owner, *typedInput.Requests)
		if err != nil {
			return err
		}
		requests := requests1
		requirements.Requests = &requests
	}

	// No error
	return nil
}

// AssignProperties_From_ResourceRequirements_STATUS populates our ResourceRequirements_STATUS from the provided source ResourceRequirements_STATUS
func (requirements *ResourceRequirements_STATUS) AssignProperties_From_ResourceRequirements_STATUS(source *storage.ResourceRequirements_STATUS) error {

	// Limits
	if source.Limits != nil {
		var limit ResourceLimits_STATUS
		err := limit.AssignProperties_From_ResourceLimits_STATUS(source.Limits)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ResourceLimits_STATUS() to populate field Limits")
		}
		requirements.Limits = &limit
	} else {
		requirements.Limits = nil
	}

	// Requests
	if source.Requests != nil {
		var request ResourceRequests_STATUS
		err := request.AssignProperties_From_ResourceRequests_STATUS(source.Requests)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ResourceRequests_STATUS() to populate field Requests")
		}
		requirements.Requests = &request
	} else {
		requirements.Requests = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ResourceRequirements_STATUS populates the provided destination ResourceRequirements_STATUS from our ResourceRequirements_STATUS
func (requirements *ResourceRequirements_STATUS) AssignProperties_To_ResourceRequirements_STATUS(destination *storage.ResourceRequirements_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Limits
	if requirements.Limits != nil {
		var limit storage.ResourceLimits_STATUS
		err := requirements.Limits.AssignProperties_To_ResourceLimits_STATUS(&limit)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ResourceLimits_STATUS() to populate field Limits")
		}
		destination.Limits = &limit
	} else {
		destination.Limits = nil
	}

	// Requests
	if requirements.Requests != nil {
		var request storage.ResourceRequests_STATUS
		err := requirements.Requests.AssignProperties_To_ResourceRequests_STATUS(&request)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ResourceRequests_STATUS() to populate field Requests")
		}
		destination.Requests = &request
	} else {
		destination.Requests = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The list of user identities associated with the container group. The user identity dictionary key references will be ARM
// resource ids in the form:
// '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
type UserAssignedIdentities_STATUS struct {
	// ClientId: The client id of user assigned identity.
	ClientId *string `json:"clientId,omitempty"`

	// PrincipalId: The principal id of user assigned identity.
	PrincipalId *string `json:"principalId,omitempty"`
}

var _ genruntime.FromARMConverter = &UserAssignedIdentities_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identities *UserAssignedIdentities_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.UserAssignedIdentities_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identities *UserAssignedIdentities_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.UserAssignedIdentities_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.UserAssignedIdentities_STATUS, got %T", armInput)
	}

	// Set property "ClientId":
	if typedInput.ClientId != nil {
		clientId := *typedInput.ClientId
		identities.ClientId = &clientId
	}

	// Set property "PrincipalId":
	if typedInput.PrincipalId != nil {
		principalId := *typedInput.PrincipalId
		identities.PrincipalId = &principalId
	}

	// No error
	return nil
}

// AssignProperties_From_UserAssignedIdentities_STATUS populates our UserAssignedIdentities_STATUS from the provided source UserAssignedIdentities_STATUS
func (identities *UserAssignedIdentities_STATUS) AssignProperties_From_UserAssignedIdentities_STATUS(source *storage.UserAssignedIdentities_STATUS) error {

	// ClientId
	identities.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// PrincipalId
	identities.PrincipalId = genruntime.ClonePointerToString(source.PrincipalId)

	// No error
	return nil
}

// AssignProperties_To_UserAssignedIdentities_STATUS populates the provided destination UserAssignedIdentities_STATUS from our UserAssignedIdentities_STATUS
func (identities *UserAssignedIdentities_STATUS) AssignProperties_To_UserAssignedIdentities_STATUS(destination *storage.UserAssignedIdentities_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(identities.ClientId)

	// PrincipalId
	destination.PrincipalId = genruntime.ClonePointerToString(identities.PrincipalId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Information about the user assigned identity for the resource
type UserAssignedIdentityDetails struct {
	Reference genruntime.ResourceReference `armReference:"Reference" json:"reference,omitempty"`
}

// AssignProperties_From_UserAssignedIdentityDetails populates our UserAssignedIdentityDetails from the provided source UserAssignedIdentityDetails
func (details *UserAssignedIdentityDetails) AssignProperties_From_UserAssignedIdentityDetails(source *storage.UserAssignedIdentityDetails) error {

	// Reference
	details.Reference = source.Reference.Copy()

	// No error
	return nil
}

// AssignProperties_To_UserAssignedIdentityDetails populates the provided destination UserAssignedIdentityDetails from our UserAssignedIdentityDetails
func (details *UserAssignedIdentityDetails) AssignProperties_To_UserAssignedIdentityDetails(destination *storage.UserAssignedIdentityDetails) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Reference
	destination.Reference = details.Reference.Copy()

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The properties of the volume mount.
type VolumeMount struct {
	// +kubebuilder:validation:Required
	// MountPath: The path within the container where the volume should be mounted. Must not contain colon (:).
	MountPath *string `json:"mountPath,omitempty"`

	// +kubebuilder:validation:Required
	// Name: The name of the volume mount.
	Name *string `json:"name,omitempty"`

	// ReadOnly: The flag indicating whether the volume mount is read-only.
	ReadOnly *bool `json:"readOnly,omitempty"`
}

var _ genruntime.ARMTransformer = &VolumeMount{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (mount *VolumeMount) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if mount == nil {
		return nil, nil
	}
	result := &arm.VolumeMount{}

	// Set property "MountPath":
	if mount.MountPath != nil {
		mountPath := *mount.MountPath
		result.MountPath = &mountPath
	}

	// Set property "Name":
	if mount.Name != nil {
		name := *mount.Name
		result.Name = &name
	}

	// Set property "ReadOnly":
	if mount.ReadOnly != nil {
		readOnly := *mount.ReadOnly
		result.ReadOnly = &readOnly
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (mount *VolumeMount) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VolumeMount{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (mount *VolumeMount) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VolumeMount)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VolumeMount, got %T", armInput)
	}

	// Set property "MountPath":
	if typedInput.MountPath != nil {
		mountPath := *typedInput.MountPath
		mount.MountPath = &mountPath
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		mount.Name = &name
	}

	// Set property "ReadOnly":
	if typedInput.ReadOnly != nil {
		readOnly := *typedInput.ReadOnly
		mount.ReadOnly = &readOnly
	}

	// No error
	return nil
}

// AssignProperties_From_VolumeMount populates our VolumeMount from the provided source VolumeMount
func (mount *VolumeMount) AssignProperties_From_VolumeMount(source *storage.VolumeMount) error {

	// MountPath
	mount.MountPath = genruntime.ClonePointerToString(source.MountPath)

	// Name
	mount.Name = genruntime.ClonePointerToString(source.Name)

	// ReadOnly
	if source.ReadOnly != nil {
		readOnly := *source.ReadOnly
		mount.ReadOnly = &readOnly
	} else {
		mount.ReadOnly = nil
	}

	// No error
	return nil
}

// AssignProperties_To_VolumeMount populates the provided destination VolumeMount from our VolumeMount
func (mount *VolumeMount) AssignProperties_To_VolumeMount(destination *storage.VolumeMount) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MountPath
	destination.MountPath = genruntime.ClonePointerToString(mount.MountPath)

	// Name
	destination.Name = genruntime.ClonePointerToString(mount.Name)

	// ReadOnly
	if mount.ReadOnly != nil {
		readOnly := *mount.ReadOnly
		destination.ReadOnly = &readOnly
	} else {
		destination.ReadOnly = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_VolumeMount_STATUS populates our VolumeMount from the provided source VolumeMount_STATUS
func (mount *VolumeMount) Initialize_From_VolumeMount_STATUS(source *VolumeMount_STATUS) error {

	// MountPath
	mount.MountPath = genruntime.ClonePointerToString(source.MountPath)

	// Name
	mount.Name = genruntime.ClonePointerToString(source.Name)

	// ReadOnly
	if source.ReadOnly != nil {
		readOnly := *source.ReadOnly
		mount.ReadOnly = &readOnly
	} else {
		mount.ReadOnly = nil
	}

	// No error
	return nil
}

// The properties of the volume mount.
type VolumeMount_STATUS struct {
	// MountPath: The path within the container where the volume should be mounted. Must not contain colon (:).
	MountPath *string `json:"mountPath,omitempty"`

	// Name: The name of the volume mount.
	Name *string `json:"name,omitempty"`

	// ReadOnly: The flag indicating whether the volume mount is read-only.
	ReadOnly *bool `json:"readOnly,omitempty"`
}

var _ genruntime.FromARMConverter = &VolumeMount_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (mount *VolumeMount_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VolumeMount_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (mount *VolumeMount_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VolumeMount_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VolumeMount_STATUS, got %T", armInput)
	}

	// Set property "MountPath":
	if typedInput.MountPath != nil {
		mountPath := *typedInput.MountPath
		mount.MountPath = &mountPath
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		mount.Name = &name
	}

	// Set property "ReadOnly":
	if typedInput.ReadOnly != nil {
		readOnly := *typedInput.ReadOnly
		mount.ReadOnly = &readOnly
	}

	// No error
	return nil
}

// AssignProperties_From_VolumeMount_STATUS populates our VolumeMount_STATUS from the provided source VolumeMount_STATUS
func (mount *VolumeMount_STATUS) AssignProperties_From_VolumeMount_STATUS(source *storage.VolumeMount_STATUS) error {

	// MountPath
	mount.MountPath = genruntime.ClonePointerToString(source.MountPath)

	// Name
	mount.Name = genruntime.ClonePointerToString(source.Name)

	// ReadOnly
	if source.ReadOnly != nil {
		readOnly := *source.ReadOnly
		mount.ReadOnly = &readOnly
	} else {
		mount.ReadOnly = nil
	}

	// No error
	return nil
}

// AssignProperties_To_VolumeMount_STATUS populates the provided destination VolumeMount_STATUS from our VolumeMount_STATUS
func (mount *VolumeMount_STATUS) AssignProperties_To_VolumeMount_STATUS(destination *storage.VolumeMount_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MountPath
	destination.MountPath = genruntime.ClonePointerToString(mount.MountPath)

	// Name
	destination.Name = genruntime.ClonePointerToString(mount.Name)

	// ReadOnly
	if mount.ReadOnly != nil {
		readOnly := *mount.ReadOnly
		destination.ReadOnly = &readOnly
	} else {
		destination.ReadOnly = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The container execution command, for liveness or readiness probe
type ContainerExec struct {
	// Command: The commands to execute within the container.
	Command []string `json:"command,omitempty"`
}

var _ genruntime.ARMTransformer = &ContainerExec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (exec *ContainerExec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if exec == nil {
		return nil, nil
	}
	result := &arm.ContainerExec{}

	// Set property "Command":
	for _, item := range exec.Command {
		result.Command = append(result.Command, item)
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (exec *ContainerExec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ContainerExec{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (exec *ContainerExec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ContainerExec)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ContainerExec, got %T", armInput)
	}

	// Set property "Command":
	for _, item := range typedInput.Command {
		exec.Command = append(exec.Command, item)
	}

	// No error
	return nil
}

// AssignProperties_From_ContainerExec populates our ContainerExec from the provided source ContainerExec
func (exec *ContainerExec) AssignProperties_From_ContainerExec(source *storage.ContainerExec) error {

	// Command
	exec.Command = genruntime.CloneSliceOfString(source.Command)

	// No error
	return nil
}

// AssignProperties_To_ContainerExec populates the provided destination ContainerExec from our ContainerExec
func (exec *ContainerExec) AssignProperties_To_ContainerExec(destination *storage.ContainerExec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Command
	destination.Command = genruntime.CloneSliceOfString(exec.Command)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ContainerExec_STATUS populates our ContainerExec from the provided source ContainerExec_STATUS
func (exec *ContainerExec) Initialize_From_ContainerExec_STATUS(source *ContainerExec_STATUS) error {

	// Command
	exec.Command = genruntime.CloneSliceOfString(source.Command)

	// No error
	return nil
}

// The container execution command, for liveness or readiness probe
type ContainerExec_STATUS struct {
	// Command: The commands to execute within the container.
	Command []string `json:"command,omitempty"`
}

var _ genruntime.FromARMConverter = &ContainerExec_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (exec *ContainerExec_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ContainerExec_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (exec *ContainerExec_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ContainerExec_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ContainerExec_STATUS, got %T", armInput)
	}

	// Set property "Command":
	for _, item := range typedInput.Command {
		exec.Command = append(exec.Command, item)
	}

	// No error
	return nil
}

// AssignProperties_From_ContainerExec_STATUS populates our ContainerExec_STATUS from the provided source ContainerExec_STATUS
func (exec *ContainerExec_STATUS) AssignProperties_From_ContainerExec_STATUS(source *storage.ContainerExec_STATUS) error {

	// Command
	exec.Command = genruntime.CloneSliceOfString(source.Command)

	// No error
	return nil
}

// AssignProperties_To_ContainerExec_STATUS populates the provided destination ContainerExec_STATUS from our ContainerExec_STATUS
func (exec *ContainerExec_STATUS) AssignProperties_To_ContainerExec_STATUS(destination *storage.ContainerExec_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Command
	destination.Command = genruntime.CloneSliceOfString(exec.Command)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The container Http Get settings, for liveness or readiness probe
type ContainerHttpGet struct {
	// HttpHeaders: The HTTP headers.
	HttpHeaders []HttpHeader `json:"httpHeaders,omitempty"`

	// Path: The path to probe.
	Path *string `json:"path,omitempty"`

	// +kubebuilder:validation:Required
	// Port: The port number to probe.
	Port *int `json:"port,omitempty"`

	// Scheme: The scheme.
	Scheme *ContainerHttpGet_Scheme `json:"scheme,omitempty"`
}

var _ genruntime.ARMTransformer = &ContainerHttpGet{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (httpGet *ContainerHttpGet) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if httpGet == nil {
		return nil, nil
	}
	result := &arm.ContainerHttpGet{}

	// Set property "HttpHeaders":
	for _, item := range httpGet.HttpHeaders {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.HttpHeaders = append(result.HttpHeaders, *item_ARM.(*arm.HttpHeader))
	}

	// Set property "Path":
	if httpGet.Path != nil {
		path := *httpGet.Path
		result.Path = &path
	}

	// Set property "Port":
	if httpGet.Port != nil {
		port := *httpGet.Port
		result.Port = &port
	}

	// Set property "Scheme":
	if httpGet.Scheme != nil {
		var temp string
		temp = string(*httpGet.Scheme)
		scheme := arm.ContainerHttpGet_Scheme(temp)
		result.Scheme = &scheme
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (httpGet *ContainerHttpGet) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ContainerHttpGet{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (httpGet *ContainerHttpGet) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ContainerHttpGet)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ContainerHttpGet, got %T", armInput)
	}

	// Set property "HttpHeaders":
	for _, item := range typedInput.HttpHeaders {
		var item1 HttpHeader
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		httpGet.HttpHeaders = append(httpGet.HttpHeaders, item1)
	}

	// Set property "Path":
	if typedInput.Path != nil {
		path := *typedInput.Path
		httpGet.Path = &path
	}

	// Set property "Port":
	if typedInput.Port != nil {
		port := *typedInput.Port
		httpGet.Port = &port
	}

	// Set property "Scheme":
	if typedInput.Scheme != nil {
		var temp string
		temp = string(*typedInput.Scheme)
		scheme := ContainerHttpGet_Scheme(temp)
		httpGet.Scheme = &scheme
	}

	// No error
	return nil
}

// AssignProperties_From_ContainerHttpGet populates our ContainerHttpGet from the provided source ContainerHttpGet
func (httpGet *ContainerHttpGet) AssignProperties_From_ContainerHttpGet(source *storage.ContainerHttpGet) error {

	// HttpHeaders
	if source.HttpHeaders != nil {
		httpHeaderList := make([]HttpHeader, len(source.HttpHeaders))
		for httpHeaderIndex, httpHeaderItem := range source.HttpHeaders {
			// Shadow the loop variable to avoid aliasing
			httpHeaderItem := httpHeaderItem
			var httpHeader HttpHeader
			err := httpHeader.AssignProperties_From_HttpHeader(&httpHeaderItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_HttpHeader() to populate field HttpHeaders")
			}
			httpHeaderList[httpHeaderIndex] = httpHeader
		}
		httpGet.HttpHeaders = httpHeaderList
	} else {
		httpGet.HttpHeaders = nil
	}

	// Path
	httpGet.Path = genruntime.ClonePointerToString(source.Path)

	// Port
	httpGet.Port = genruntime.ClonePointerToInt(source.Port)

	// Scheme
	if source.Scheme != nil {
		scheme := *source.Scheme
		schemeTemp := genruntime.ToEnum(scheme, containerHttpGet_Scheme_Values)
		httpGet.Scheme = &schemeTemp
	} else {
		httpGet.Scheme = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ContainerHttpGet populates the provided destination ContainerHttpGet from our ContainerHttpGet
func (httpGet *ContainerHttpGet) AssignProperties_To_ContainerHttpGet(destination *storage.ContainerHttpGet) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// HttpHeaders
	if httpGet.HttpHeaders != nil {
		httpHeaderList := make([]storage.HttpHeader, len(httpGet.HttpHeaders))
		for httpHeaderIndex, httpHeaderItem := range httpGet.HttpHeaders {
			// Shadow the loop variable to avoid aliasing
			httpHeaderItem := httpHeaderItem
			var httpHeader storage.HttpHeader
			err := httpHeaderItem.AssignProperties_To_HttpHeader(&httpHeader)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_HttpHeader() to populate field HttpHeaders")
			}
			httpHeaderList[httpHeaderIndex] = httpHeader
		}
		destination.HttpHeaders = httpHeaderList
	} else {
		destination.HttpHeaders = nil
	}

	// Path
	destination.Path = genruntime.ClonePointerToString(httpGet.Path)

	// Port
	destination.Port = genruntime.ClonePointerToInt(httpGet.Port)

	// Scheme
	if httpGet.Scheme != nil {
		scheme := string(*httpGet.Scheme)
		destination.Scheme = &scheme
	} else {
		destination.Scheme = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ContainerHttpGet_STATUS populates our ContainerHttpGet from the provided source ContainerHttpGet_STATUS
func (httpGet *ContainerHttpGet) Initialize_From_ContainerHttpGet_STATUS(source *ContainerHttpGet_STATUS) error {

	// HttpHeaders
	if source.HttpHeaders != nil {
		httpHeaderList := make([]HttpHeader, len(source.HttpHeaders))
		for httpHeaderIndex, httpHeaderItem := range source.HttpHeaders {
			// Shadow the loop variable to avoid aliasing
			httpHeaderItem := httpHeaderItem
			var httpHeader HttpHeader
			err := httpHeader.Initialize_From_HttpHeader_STATUS(&httpHeaderItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_HttpHeader_STATUS() to populate field HttpHeaders")
			}
			httpHeaderList[httpHeaderIndex] = httpHeader
		}
		httpGet.HttpHeaders = httpHeaderList
	} else {
		httpGet.HttpHeaders = nil
	}

	// Path
	httpGet.Path = genruntime.ClonePointerToString(source.Path)

	// Port
	httpGet.Port = genruntime.ClonePointerToInt(source.Port)

	// Scheme
	if source.Scheme != nil {
		scheme := genruntime.ToEnum(string(*source.Scheme), containerHttpGet_Scheme_Values)
		httpGet.Scheme = &scheme
	} else {
		httpGet.Scheme = nil
	}

	// No error
	return nil
}

// The container Http Get settings, for liveness or readiness probe
type ContainerHttpGet_STATUS struct {
	// HttpHeaders: The HTTP headers.
	HttpHeaders []HttpHeader_STATUS `json:"httpHeaders,omitempty"`

	// Path: The path to probe.
	Path *string `json:"path,omitempty"`

	// Port: The port number to probe.
	Port *int `json:"port,omitempty"`

	// Scheme: The scheme.
	Scheme *ContainerHttpGet_Scheme_STATUS `json:"scheme,omitempty"`
}

var _ genruntime.FromARMConverter = &ContainerHttpGet_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (httpGet *ContainerHttpGet_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ContainerHttpGet_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (httpGet *ContainerHttpGet_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ContainerHttpGet_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ContainerHttpGet_STATUS, got %T", armInput)
	}

	// Set property "HttpHeaders":
	for _, item := range typedInput.HttpHeaders {
		var item1 HttpHeader_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		httpGet.HttpHeaders = append(httpGet.HttpHeaders, item1)
	}

	// Set property "Path":
	if typedInput.Path != nil {
		path := *typedInput.Path
		httpGet.Path = &path
	}

	// Set property "Port":
	if typedInput.Port != nil {
		port := *typedInput.Port
		httpGet.Port = &port
	}

	// Set property "Scheme":
	if typedInput.Scheme != nil {
		var temp string
		temp = string(*typedInput.Scheme)
		scheme := ContainerHttpGet_Scheme_STATUS(temp)
		httpGet.Scheme = &scheme
	}

	// No error
	return nil
}

// AssignProperties_From_ContainerHttpGet_STATUS populates our ContainerHttpGet_STATUS from the provided source ContainerHttpGet_STATUS
func (httpGet *ContainerHttpGet_STATUS) AssignProperties_From_ContainerHttpGet_STATUS(source *storage.ContainerHttpGet_STATUS) error {

	// HttpHeaders
	if source.HttpHeaders != nil {
		httpHeaderList := make([]HttpHeader_STATUS, len(source.HttpHeaders))
		for httpHeaderIndex, httpHeaderItem := range source.HttpHeaders {
			// Shadow the loop variable to avoid aliasing
			httpHeaderItem := httpHeaderItem
			var httpHeader HttpHeader_STATUS
			err := httpHeader.AssignProperties_From_HttpHeader_STATUS(&httpHeaderItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_HttpHeader_STATUS() to populate field HttpHeaders")
			}
			httpHeaderList[httpHeaderIndex] = httpHeader
		}
		httpGet.HttpHeaders = httpHeaderList
	} else {
		httpGet.HttpHeaders = nil
	}

	// Path
	httpGet.Path = genruntime.ClonePointerToString(source.Path)

	// Port
	httpGet.Port = genruntime.ClonePointerToInt(source.Port)

	// Scheme
	if source.Scheme != nil {
		scheme := *source.Scheme
		schemeTemp := genruntime.ToEnum(scheme, containerHttpGet_Scheme_STATUS_Values)
		httpGet.Scheme = &schemeTemp
	} else {
		httpGet.Scheme = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ContainerHttpGet_STATUS populates the provided destination ContainerHttpGet_STATUS from our ContainerHttpGet_STATUS
func (httpGet *ContainerHttpGet_STATUS) AssignProperties_To_ContainerHttpGet_STATUS(destination *storage.ContainerHttpGet_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// HttpHeaders
	if httpGet.HttpHeaders != nil {
		httpHeaderList := make([]storage.HttpHeader_STATUS, len(httpGet.HttpHeaders))
		for httpHeaderIndex, httpHeaderItem := range httpGet.HttpHeaders {
			// Shadow the loop variable to avoid aliasing
			httpHeaderItem := httpHeaderItem
			var httpHeader storage.HttpHeader_STATUS
			err := httpHeaderItem.AssignProperties_To_HttpHeader_STATUS(&httpHeader)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_HttpHeader_STATUS() to populate field HttpHeaders")
			}
			httpHeaderList[httpHeaderIndex] = httpHeader
		}
		destination.HttpHeaders = httpHeaderList
	} else {
		destination.HttpHeaders = nil
	}

	// Path
	destination.Path = genruntime.ClonePointerToString(httpGet.Path)

	// Port
	destination.Port = genruntime.ClonePointerToInt(httpGet.Port)

	// Scheme
	if httpGet.Scheme != nil {
		scheme := string(*httpGet.Scheme)
		destination.Scheme = &scheme
	} else {
		destination.Scheme = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"TCP","UDP"}
type ContainerPort_Protocol string

const (
	ContainerPort_Protocol_TCP = ContainerPort_Protocol("TCP")
	ContainerPort_Protocol_UDP = ContainerPort_Protocol("UDP")
)

// Mapping from string to ContainerPort_Protocol
var containerPort_Protocol_Values = map[string]ContainerPort_Protocol{
	"tcp": ContainerPort_Protocol_TCP,
	"udp": ContainerPort_Protocol_UDP,
}

type ContainerPort_Protocol_STATUS string

const (
	ContainerPort_Protocol_STATUS_TCP = ContainerPort_Protocol_STATUS("TCP")
	ContainerPort_Protocol_STATUS_UDP = ContainerPort_Protocol_STATUS("UDP")
)

// Mapping from string to ContainerPort_Protocol_STATUS
var containerPort_Protocol_STATUS_Values = map[string]ContainerPort_Protocol_STATUS{
	"tcp": ContainerPort_Protocol_STATUS_TCP,
	"udp": ContainerPort_Protocol_STATUS_UDP,
}

// The container instance state.
type ContainerState_STATUS struct {
	// DetailStatus: The human-readable status of the container instance state.
	DetailStatus *string `json:"detailStatus,omitempty"`

	// ExitCode: The container instance exit codes correspond to those from the `docker run` command.
	ExitCode *int `json:"exitCode,omitempty"`

	// FinishTime: The date-time when the container instance state finished.
	FinishTime *string `json:"finishTime,omitempty"`

	// StartTime: The date-time when the container instance state started.
	StartTime *string `json:"startTime,omitempty"`

	// State: The state of the container instance.
	State *string `json:"state,omitempty"`
}

var _ genruntime.FromARMConverter = &ContainerState_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (state *ContainerState_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ContainerState_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (state *ContainerState_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ContainerState_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ContainerState_STATUS, got %T", armInput)
	}

	// Set property "DetailStatus":
	if typedInput.DetailStatus != nil {
		detailStatus := *typedInput.DetailStatus
		state.DetailStatus = &detailStatus
	}

	// Set property "ExitCode":
	if typedInput.ExitCode != nil {
		exitCode := *typedInput.ExitCode
		state.ExitCode = &exitCode
	}

	// Set property "FinishTime":
	if typedInput.FinishTime != nil {
		finishTime := *typedInput.FinishTime
		state.FinishTime = &finishTime
	}

	// Set property "StartTime":
	if typedInput.StartTime != nil {
		startTime := *typedInput.StartTime
		state.StartTime = &startTime
	}

	// Set property "State":
	if typedInput.State != nil {
		state1 := *typedInput.State
		state.State = &state1
	}

	// No error
	return nil
}

// AssignProperties_From_ContainerState_STATUS populates our ContainerState_STATUS from the provided source ContainerState_STATUS
func (state *ContainerState_STATUS) AssignProperties_From_ContainerState_STATUS(source *storage.ContainerState_STATUS) error {

	// DetailStatus
	state.DetailStatus = genruntime.ClonePointerToString(source.DetailStatus)

	// ExitCode
	state.ExitCode = genruntime.ClonePointerToInt(source.ExitCode)

	// FinishTime
	state.FinishTime = genruntime.ClonePointerToString(source.FinishTime)

	// StartTime
	state.StartTime = genruntime.ClonePointerToString(source.StartTime)

	// State
	state.State = genruntime.ClonePointerToString(source.State)

	// No error
	return nil
}

// AssignProperties_To_ContainerState_STATUS populates the provided destination ContainerState_STATUS from our ContainerState_STATUS
func (state *ContainerState_STATUS) AssignProperties_To_ContainerState_STATUS(destination *storage.ContainerState_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DetailStatus
	destination.DetailStatus = genruntime.ClonePointerToString(state.DetailStatus)

	// ExitCode
	destination.ExitCode = genruntime.ClonePointerToInt(state.ExitCode)

	// FinishTime
	destination.FinishTime = genruntime.ClonePointerToString(state.FinishTime)

	// StartTime
	destination.StartTime = genruntime.ClonePointerToString(state.StartTime)

	// State
	destination.State = genruntime.ClonePointerToString(state.State)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"ContainerInsights","ContainerInstanceLogs"}
type LogAnalytics_LogType string

const (
	LogAnalytics_LogType_ContainerInsights     = LogAnalytics_LogType("ContainerInsights")
	LogAnalytics_LogType_ContainerInstanceLogs = LogAnalytics_LogType("ContainerInstanceLogs")
)

// Mapping from string to LogAnalytics_LogType
var logAnalytics_LogType_Values = map[string]LogAnalytics_LogType{
	"containerinsights":     LogAnalytics_LogType_ContainerInsights,
	"containerinstancelogs": LogAnalytics_LogType_ContainerInstanceLogs,
}

type LogAnalytics_LogType_STATUS string

const (
	LogAnalytics_LogType_STATUS_ContainerInsights     = LogAnalytics_LogType_STATUS("ContainerInsights")
	LogAnalytics_LogType_STATUS_ContainerInstanceLogs = LogAnalytics_LogType_STATUS("ContainerInstanceLogs")
)

// Mapping from string to LogAnalytics_LogType_STATUS
var logAnalytics_LogType_STATUS_Values = map[string]LogAnalytics_LogType_STATUS{
	"containerinsights":     LogAnalytics_LogType_STATUS_ContainerInsights,
	"containerinstancelogs": LogAnalytics_LogType_STATUS_ContainerInstanceLogs,
}

// +kubebuilder:validation:Enum={"TCP","UDP"}
type Port_Protocol string

const (
	Port_Protocol_TCP = Port_Protocol("TCP")
	Port_Protocol_UDP = Port_Protocol("UDP")
)

// Mapping from string to Port_Protocol
var port_Protocol_Values = map[string]Port_Protocol{
	"tcp": Port_Protocol_TCP,
	"udp": Port_Protocol_UDP,
}

type Port_Protocol_STATUS string

const (
	Port_Protocol_STATUS_TCP = Port_Protocol_STATUS("TCP")
	Port_Protocol_STATUS_UDP = Port_Protocol_STATUS("UDP")
)

// Mapping from string to Port_Protocol_STATUS
var port_Protocol_STATUS_Values = map[string]Port_Protocol_STATUS{
	"tcp": Port_Protocol_STATUS_TCP,
	"udp": Port_Protocol_STATUS_UDP,
}

// The resource limits.
type ResourceLimits struct {
	// Cpu: The CPU limit of this container instance.
	Cpu *float64 `json:"cpu,omitempty"`

	// Gpu: The GPU limit of this container instance.
	Gpu *GpuResource `json:"gpu,omitempty"`

	// MemoryInGB: The memory limit in GB of this container instance.
	MemoryInGB *float64 `json:"memoryInGB,omitempty"`
}

var _ genruntime.ARMTransformer = &ResourceLimits{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (limits *ResourceLimits) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if limits == nil {
		return nil, nil
	}
	result := &arm.ResourceLimits{}

	// Set property "Cpu":
	if limits.Cpu != nil {
		cpu := *limits.Cpu
		result.Cpu = &cpu
	}

	// Set property "Gpu":
	if limits.Gpu != nil {
		gpu_ARM, err := (*limits.Gpu).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		gpu := *gpu_ARM.(*arm.GpuResource)
		result.Gpu = &gpu
	}

	// Set property "MemoryInGB":
	if limits.MemoryInGB != nil {
		memoryInGB := *limits.MemoryInGB
		result.MemoryInGB = &memoryInGB
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (limits *ResourceLimits) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ResourceLimits{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (limits *ResourceLimits) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ResourceLimits)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ResourceLimits, got %T", armInput)
	}

	// Set property "Cpu":
	if typedInput.Cpu != nil {
		cpu := *typedInput.Cpu
		limits.Cpu = &cpu
	}

	// Set property "Gpu":
	if typedInput.Gpu != nil {
		var gpu1 GpuResource
		err := gpu1.PopulateFromARM(owner, *typedInput.Gpu)
		if err != nil {
			return err
		}
		gpu := gpu1
		limits.Gpu = &gpu
	}

	// Set property "MemoryInGB":
	if typedInput.MemoryInGB != nil {
		memoryInGB := *typedInput.MemoryInGB
		limits.MemoryInGB = &memoryInGB
	}

	// No error
	return nil
}

// AssignProperties_From_ResourceLimits populates our ResourceLimits from the provided source ResourceLimits
func (limits *ResourceLimits) AssignProperties_From_ResourceLimits(source *storage.ResourceLimits) error {

	// Cpu
	if source.Cpu != nil {
		cpu := *source.Cpu
		limits.Cpu = &cpu
	} else {
		limits.Cpu = nil
	}

	// Gpu
	if source.Gpu != nil {
		var gpu GpuResource
		err := gpu.AssignProperties_From_GpuResource(source.Gpu)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_GpuResource() to populate field Gpu")
		}
		limits.Gpu = &gpu
	} else {
		limits.Gpu = nil
	}

	// MemoryInGB
	if source.MemoryInGB != nil {
		memoryInGB := *source.MemoryInGB
		limits.MemoryInGB = &memoryInGB
	} else {
		limits.MemoryInGB = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ResourceLimits populates the provided destination ResourceLimits from our ResourceLimits
func (limits *ResourceLimits) AssignProperties_To_ResourceLimits(destination *storage.ResourceLimits) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Cpu
	if limits.Cpu != nil {
		cpu := *limits.Cpu
		destination.Cpu = &cpu
	} else {
		destination.Cpu = nil
	}

	// Gpu
	if limits.Gpu != nil {
		var gpu storage.GpuResource
		err := limits.Gpu.AssignProperties_To_GpuResource(&gpu)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_GpuResource() to populate field Gpu")
		}
		destination.Gpu = &gpu
	} else {
		destination.Gpu = nil
	}

	// MemoryInGB
	if limits.MemoryInGB != nil {
		memoryInGB := *limits.MemoryInGB
		destination.MemoryInGB = &memoryInGB
	} else {
		destination.MemoryInGB = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ResourceLimits_STATUS populates our ResourceLimits from the provided source ResourceLimits_STATUS
func (limits *ResourceLimits) Initialize_From_ResourceLimits_STATUS(source *ResourceLimits_STATUS) error {

	// Cpu
	if source.Cpu != nil {
		cpu := *source.Cpu
		limits.Cpu = &cpu
	} else {
		limits.Cpu = nil
	}

	// Gpu
	if source.Gpu != nil {
		var gpu GpuResource
		err := gpu.Initialize_From_GpuResource_STATUS(source.Gpu)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_GpuResource_STATUS() to populate field Gpu")
		}
		limits.Gpu = &gpu
	} else {
		limits.Gpu = nil
	}

	// MemoryInGB
	if source.MemoryInGB != nil {
		memoryInGB := *source.MemoryInGB
		limits.MemoryInGB = &memoryInGB
	} else {
		limits.MemoryInGB = nil
	}

	// No error
	return nil
}

// The resource limits.
type ResourceLimits_STATUS struct {
	// Cpu: The CPU limit of this container instance.
	Cpu *float64 `json:"cpu,omitempty"`

	// Gpu: The GPU limit of this container instance.
	Gpu *GpuResource_STATUS `json:"gpu,omitempty"`

	// MemoryInGB: The memory limit in GB of this container instance.
	MemoryInGB *float64 `json:"memoryInGB,omitempty"`
}

var _ genruntime.FromARMConverter = &ResourceLimits_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (limits *ResourceLimits_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ResourceLimits_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (limits *ResourceLimits_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ResourceLimits_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ResourceLimits_STATUS, got %T", armInput)
	}

	// Set property "Cpu":
	if typedInput.Cpu != nil {
		cpu := *typedInput.Cpu
		limits.Cpu = &cpu
	}

	// Set property "Gpu":
	if typedInput.Gpu != nil {
		var gpu1 GpuResource_STATUS
		err := gpu1.PopulateFromARM(owner, *typedInput.Gpu)
		if err != nil {
			return err
		}
		gpu := gpu1
		limits.Gpu = &gpu
	}

	// Set property "MemoryInGB":
	if typedInput.MemoryInGB != nil {
		memoryInGB := *typedInput.MemoryInGB
		limits.MemoryInGB = &memoryInGB
	}

	// No error
	return nil
}

// AssignProperties_From_ResourceLimits_STATUS populates our ResourceLimits_STATUS from the provided source ResourceLimits_STATUS
func (limits *ResourceLimits_STATUS) AssignProperties_From_ResourceLimits_STATUS(source *storage.ResourceLimits_STATUS) error {

	// Cpu
	if source.Cpu != nil {
		cpu := *source.Cpu
		limits.Cpu = &cpu
	} else {
		limits.Cpu = nil
	}

	// Gpu
	if source.Gpu != nil {
		var gpu GpuResource_STATUS
		err := gpu.AssignProperties_From_GpuResource_STATUS(source.Gpu)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_GpuResource_STATUS() to populate field Gpu")
		}
		limits.Gpu = &gpu
	} else {
		limits.Gpu = nil
	}

	// MemoryInGB
	if source.MemoryInGB != nil {
		memoryInGB := *source.MemoryInGB
		limits.MemoryInGB = &memoryInGB
	} else {
		limits.MemoryInGB = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ResourceLimits_STATUS populates the provided destination ResourceLimits_STATUS from our ResourceLimits_STATUS
func (limits *ResourceLimits_STATUS) AssignProperties_To_ResourceLimits_STATUS(destination *storage.ResourceLimits_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Cpu
	if limits.Cpu != nil {
		cpu := *limits.Cpu
		destination.Cpu = &cpu
	} else {
		destination.Cpu = nil
	}

	// Gpu
	if limits.Gpu != nil {
		var gpu storage.GpuResource_STATUS
		err := limits.Gpu.AssignProperties_To_GpuResource_STATUS(&gpu)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_GpuResource_STATUS() to populate field Gpu")
		}
		destination.Gpu = &gpu
	} else {
		destination.Gpu = nil
	}

	// MemoryInGB
	if limits.MemoryInGB != nil {
		memoryInGB := *limits.MemoryInGB
		destination.MemoryInGB = &memoryInGB
	} else {
		destination.MemoryInGB = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The resource requests.
type ResourceRequests struct {
	// +kubebuilder:validation:Required
	// Cpu: The CPU request of this container instance.
	Cpu *float64 `json:"cpu,omitempty"`

	// Gpu: The GPU request of this container instance.
	Gpu *GpuResource `json:"gpu,omitempty"`

	// +kubebuilder:validation:Required
	// MemoryInGB: The memory request in GB of this container instance.
	MemoryInGB *float64 `json:"memoryInGB,omitempty"`
}

var _ genruntime.ARMTransformer = &ResourceRequests{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (requests *ResourceRequests) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if requests == nil {
		return nil, nil
	}
	result := &arm.ResourceRequests{}

	// Set property "Cpu":
	if requests.Cpu != nil {
		cpu := *requests.Cpu
		result.Cpu = &cpu
	}

	// Set property "Gpu":
	if requests.Gpu != nil {
		gpu_ARM, err := (*requests.Gpu).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		gpu := *gpu_ARM.(*arm.GpuResource)
		result.Gpu = &gpu
	}

	// Set property "MemoryInGB":
	if requests.MemoryInGB != nil {
		memoryInGB := *requests.MemoryInGB
		result.MemoryInGB = &memoryInGB
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (requests *ResourceRequests) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ResourceRequests{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (requests *ResourceRequests) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ResourceRequests)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ResourceRequests, got %T", armInput)
	}

	// Set property "Cpu":
	if typedInput.Cpu != nil {
		cpu := *typedInput.Cpu
		requests.Cpu = &cpu
	}

	// Set property "Gpu":
	if typedInput.Gpu != nil {
		var gpu1 GpuResource
		err := gpu1.PopulateFromARM(owner, *typedInput.Gpu)
		if err != nil {
			return err
		}
		gpu := gpu1
		requests.Gpu = &gpu
	}

	// Set property "MemoryInGB":
	if typedInput.MemoryInGB != nil {
		memoryInGB := *typedInput.MemoryInGB
		requests.MemoryInGB = &memoryInGB
	}

	// No error
	return nil
}

// AssignProperties_From_ResourceRequests populates our ResourceRequests from the provided source ResourceRequests
func (requests *ResourceRequests) AssignProperties_From_ResourceRequests(source *storage.ResourceRequests) error {

	// Cpu
	if source.Cpu != nil {
		cpu := *source.Cpu
		requests.Cpu = &cpu
	} else {
		requests.Cpu = nil
	}

	// Gpu
	if source.Gpu != nil {
		var gpu GpuResource
		err := gpu.AssignProperties_From_GpuResource(source.Gpu)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_GpuResource() to populate field Gpu")
		}
		requests.Gpu = &gpu
	} else {
		requests.Gpu = nil
	}

	// MemoryInGB
	if source.MemoryInGB != nil {
		memoryInGB := *source.MemoryInGB
		requests.MemoryInGB = &memoryInGB
	} else {
		requests.MemoryInGB = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ResourceRequests populates the provided destination ResourceRequests from our ResourceRequests
func (requests *ResourceRequests) AssignProperties_To_ResourceRequests(destination *storage.ResourceRequests) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Cpu
	if requests.Cpu != nil {
		cpu := *requests.Cpu
		destination.Cpu = &cpu
	} else {
		destination.Cpu = nil
	}

	// Gpu
	if requests.Gpu != nil {
		var gpu storage.GpuResource
		err := requests.Gpu.AssignProperties_To_GpuResource(&gpu)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_GpuResource() to populate field Gpu")
		}
		destination.Gpu = &gpu
	} else {
		destination.Gpu = nil
	}

	// MemoryInGB
	if requests.MemoryInGB != nil {
		memoryInGB := *requests.MemoryInGB
		destination.MemoryInGB = &memoryInGB
	} else {
		destination.MemoryInGB = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ResourceRequests_STATUS populates our ResourceRequests from the provided source ResourceRequests_STATUS
func (requests *ResourceRequests) Initialize_From_ResourceRequests_STATUS(source *ResourceRequests_STATUS) error {

	// Cpu
	if source.Cpu != nil {
		cpu := *source.Cpu
		requests.Cpu = &cpu
	} else {
		requests.Cpu = nil
	}

	// Gpu
	if source.Gpu != nil {
		var gpu GpuResource
		err := gpu.Initialize_From_GpuResource_STATUS(source.Gpu)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_GpuResource_STATUS() to populate field Gpu")
		}
		requests.Gpu = &gpu
	} else {
		requests.Gpu = nil
	}

	// MemoryInGB
	if source.MemoryInGB != nil {
		memoryInGB := *source.MemoryInGB
		requests.MemoryInGB = &memoryInGB
	} else {
		requests.MemoryInGB = nil
	}

	// No error
	return nil
}

// The resource requests.
type ResourceRequests_STATUS struct {
	// Cpu: The CPU request of this container instance.
	Cpu *float64 `json:"cpu,omitempty"`

	// Gpu: The GPU request of this container instance.
	Gpu *GpuResource_STATUS `json:"gpu,omitempty"`

	// MemoryInGB: The memory request in GB of this container instance.
	MemoryInGB *float64 `json:"memoryInGB,omitempty"`
}

var _ genruntime.FromARMConverter = &ResourceRequests_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (requests *ResourceRequests_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ResourceRequests_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (requests *ResourceRequests_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ResourceRequests_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ResourceRequests_STATUS, got %T", armInput)
	}

	// Set property "Cpu":
	if typedInput.Cpu != nil {
		cpu := *typedInput.Cpu
		requests.Cpu = &cpu
	}

	// Set property "Gpu":
	if typedInput.Gpu != nil {
		var gpu1 GpuResource_STATUS
		err := gpu1.PopulateFromARM(owner, *typedInput.Gpu)
		if err != nil {
			return err
		}
		gpu := gpu1
		requests.Gpu = &gpu
	}

	// Set property "MemoryInGB":
	if typedInput.MemoryInGB != nil {
		memoryInGB := *typedInput.MemoryInGB
		requests.MemoryInGB = &memoryInGB
	}

	// No error
	return nil
}

// AssignProperties_From_ResourceRequests_STATUS populates our ResourceRequests_STATUS from the provided source ResourceRequests_STATUS
func (requests *ResourceRequests_STATUS) AssignProperties_From_ResourceRequests_STATUS(source *storage.ResourceRequests_STATUS) error {

	// Cpu
	if source.Cpu != nil {
		cpu := *source.Cpu
		requests.Cpu = &cpu
	} else {
		requests.Cpu = nil
	}

	// Gpu
	if source.Gpu != nil {
		var gpu GpuResource_STATUS
		err := gpu.AssignProperties_From_GpuResource_STATUS(source.Gpu)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_GpuResource_STATUS() to populate field Gpu")
		}
		requests.Gpu = &gpu
	} else {
		requests.Gpu = nil
	}

	// MemoryInGB
	if source.MemoryInGB != nil {
		memoryInGB := *source.MemoryInGB
		requests.MemoryInGB = &memoryInGB
	} else {
		requests.MemoryInGB = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ResourceRequests_STATUS populates the provided destination ResourceRequests_STATUS from our ResourceRequests_STATUS
func (requests *ResourceRequests_STATUS) AssignProperties_To_ResourceRequests_STATUS(destination *storage.ResourceRequests_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Cpu
	if requests.Cpu != nil {
		cpu := *requests.Cpu
		destination.Cpu = &cpu
	} else {
		destination.Cpu = nil
	}

	// Gpu
	if requests.Gpu != nil {
		var gpu storage.GpuResource_STATUS
		err := requests.Gpu.AssignProperties_To_GpuResource_STATUS(&gpu)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_GpuResource_STATUS() to populate field Gpu")
		}
		destination.Gpu = &gpu
	} else {
		destination.Gpu = nil
	}

	// MemoryInGB
	if requests.MemoryInGB != nil {
		memoryInGB := *requests.MemoryInGB
		destination.MemoryInGB = &memoryInGB
	} else {
		destination.MemoryInGB = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"http","https"}
type ContainerHttpGet_Scheme string

const (
	ContainerHttpGet_Scheme_Http  = ContainerHttpGet_Scheme("http")
	ContainerHttpGet_Scheme_Https = ContainerHttpGet_Scheme("https")
)

// Mapping from string to ContainerHttpGet_Scheme
var containerHttpGet_Scheme_Values = map[string]ContainerHttpGet_Scheme{
	"http":  ContainerHttpGet_Scheme_Http,
	"https": ContainerHttpGet_Scheme_Https,
}

type ContainerHttpGet_Scheme_STATUS string

const (
	ContainerHttpGet_Scheme_STATUS_Http  = ContainerHttpGet_Scheme_STATUS("http")
	ContainerHttpGet_Scheme_STATUS_Https = ContainerHttpGet_Scheme_STATUS("https")
)

// Mapping from string to ContainerHttpGet_Scheme_STATUS
var containerHttpGet_Scheme_STATUS_Values = map[string]ContainerHttpGet_Scheme_STATUS{
	"http":  ContainerHttpGet_Scheme_STATUS_Http,
	"https": ContainerHttpGet_Scheme_STATUS_Https,
}

// The GPU resource.
type GpuResource struct {
	// +kubebuilder:validation:Required
	// Count: The count of the GPU resource.
	Count *int `json:"count,omitempty"`

	// +kubebuilder:validation:Required
	// Sku: The SKU of the GPU resource.
	Sku *GpuResource_Sku `json:"sku,omitempty"`
}

var _ genruntime.ARMTransformer = &GpuResource{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (resource *GpuResource) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if resource == nil {
		return nil, nil
	}
	result := &arm.GpuResource{}

	// Set property "Count":
	if resource.Count != nil {
		count := *resource.Count
		result.Count = &count
	}

	// Set property "Sku":
	if resource.Sku != nil {
		var temp string
		temp = string(*resource.Sku)
		sku := arm.GpuResource_Sku(temp)
		result.Sku = &sku
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (resource *GpuResource) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.GpuResource{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (resource *GpuResource) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.GpuResource)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.GpuResource, got %T", armInput)
	}

	// Set property "Count":
	if typedInput.Count != nil {
		count := *typedInput.Count
		resource.Count = &count
	}

	// Set property "Sku":
	if typedInput.Sku != nil {
		var temp string
		temp = string(*typedInput.Sku)
		sku := GpuResource_Sku(temp)
		resource.Sku = &sku
	}

	// No error
	return nil
}

// AssignProperties_From_GpuResource populates our GpuResource from the provided source GpuResource
func (resource *GpuResource) AssignProperties_From_GpuResource(source *storage.GpuResource) error {

	// Count
	resource.Count = genruntime.ClonePointerToInt(source.Count)

	// Sku
	if source.Sku != nil {
		sku := *source.Sku
		skuTemp := genruntime.ToEnum(sku, gpuResource_Sku_Values)
		resource.Sku = &skuTemp
	} else {
		resource.Sku = nil
	}

	// No error
	return nil
}

// AssignProperties_To_GpuResource populates the provided destination GpuResource from our GpuResource
func (resource *GpuResource) AssignProperties_To_GpuResource(destination *storage.GpuResource) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Count
	destination.Count = genruntime.ClonePointerToInt(resource.Count)

	// Sku
	if resource.Sku != nil {
		sku := string(*resource.Sku)
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_GpuResource_STATUS populates our GpuResource from the provided source GpuResource_STATUS
func (resource *GpuResource) Initialize_From_GpuResource_STATUS(source *GpuResource_STATUS) error {

	// Count
	resource.Count = genruntime.ClonePointerToInt(source.Count)

	// Sku
	if source.Sku != nil {
		sku := genruntime.ToEnum(string(*source.Sku), gpuResource_Sku_Values)
		resource.Sku = &sku
	} else {
		resource.Sku = nil
	}

	// No error
	return nil
}

// The GPU resource.
type GpuResource_STATUS struct {
	// Count: The count of the GPU resource.
	Count *int `json:"count,omitempty"`

	// Sku: The SKU of the GPU resource.
	Sku *GpuResource_Sku_STATUS `json:"sku,omitempty"`
}

var _ genruntime.FromARMConverter = &GpuResource_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (resource *GpuResource_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.GpuResource_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (resource *GpuResource_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.GpuResource_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.GpuResource_STATUS, got %T", armInput)
	}

	// Set property "Count":
	if typedInput.Count != nil {
		count := *typedInput.Count
		resource.Count = &count
	}

	// Set property "Sku":
	if typedInput.Sku != nil {
		var temp string
		temp = string(*typedInput.Sku)
		sku := GpuResource_Sku_STATUS(temp)
		resource.Sku = &sku
	}

	// No error
	return nil
}

// AssignProperties_From_GpuResource_STATUS populates our GpuResource_STATUS from the provided source GpuResource_STATUS
func (resource *GpuResource_STATUS) AssignProperties_From_GpuResource_STATUS(source *storage.GpuResource_STATUS) error {

	// Count
	resource.Count = genruntime.ClonePointerToInt(source.Count)

	// Sku
	if source.Sku != nil {
		sku := *source.Sku
		skuTemp := genruntime.ToEnum(sku, gpuResource_Sku_STATUS_Values)
		resource.Sku = &skuTemp
	} else {
		resource.Sku = nil
	}

	// No error
	return nil
}

// AssignProperties_To_GpuResource_STATUS populates the provided destination GpuResource_STATUS from our GpuResource_STATUS
func (resource *GpuResource_STATUS) AssignProperties_To_GpuResource_STATUS(destination *storage.GpuResource_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Count
	destination.Count = genruntime.ClonePointerToInt(resource.Count)

	// Sku
	if resource.Sku != nil {
		sku := string(*resource.Sku)
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The HTTP header.
type HttpHeader struct {
	// Name: The header name.
	Name *string `json:"name,omitempty"`

	// Value: The header value.
	Value *string `json:"value,omitempty"`
}

var _ genruntime.ARMTransformer = &HttpHeader{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (header *HttpHeader) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if header == nil {
		return nil, nil
	}
	result := &arm.HttpHeader{}

	// Set property "Name":
	if header.Name != nil {
		name := *header.Name
		result.Name = &name
	}

	// Set property "Value":
	if header.Value != nil {
		value := *header.Value
		result.Value = &value
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (header *HttpHeader) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.HttpHeader{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (header *HttpHeader) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.HttpHeader)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.HttpHeader, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		header.Name = &name
	}

	// Set property "Value":
	if typedInput.Value != nil {
		value := *typedInput.Value
		header.Value = &value
	}

	// No error
	return nil
}

// AssignProperties_From_HttpHeader populates our HttpHeader from the provided source HttpHeader
func (header *HttpHeader) AssignProperties_From_HttpHeader(source *storage.HttpHeader) error {

	// Name
	header.Name = genruntime.ClonePointerToString(source.Name)

	// Value
	header.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// AssignProperties_To_HttpHeader populates the provided destination HttpHeader from our HttpHeader
func (header *HttpHeader) AssignProperties_To_HttpHeader(destination *storage.HttpHeader) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(header.Name)

	// Value
	destination.Value = genruntime.ClonePointerToString(header.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_HttpHeader_STATUS populates our HttpHeader from the provided source HttpHeader_STATUS
func (header *HttpHeader) Initialize_From_HttpHeader_STATUS(source *HttpHeader_STATUS) error {

	// Name
	header.Name = genruntime.ClonePointerToString(source.Name)

	// Value
	header.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// The HTTP header.
type HttpHeader_STATUS struct {
	// Name: The header name.
	Name *string `json:"name,omitempty"`

	// Value: The header value.
	Value *string `json:"value,omitempty"`
}

var _ genruntime.FromARMConverter = &HttpHeader_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (header *HttpHeader_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.HttpHeader_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (header *HttpHeader_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.HttpHeader_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.HttpHeader_STATUS, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		header.Name = &name
	}

	// Set property "Value":
	if typedInput.Value != nil {
		value := *typedInput.Value
		header.Value = &value
	}

	// No error
	return nil
}

// AssignProperties_From_HttpHeader_STATUS populates our HttpHeader_STATUS from the provided source HttpHeader_STATUS
func (header *HttpHeader_STATUS) AssignProperties_From_HttpHeader_STATUS(source *storage.HttpHeader_STATUS) error {

	// Name
	header.Name = genruntime.ClonePointerToString(source.Name)

	// Value
	header.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// AssignProperties_To_HttpHeader_STATUS populates the provided destination HttpHeader_STATUS from our HttpHeader_STATUS
func (header *HttpHeader_STATUS) AssignProperties_To_HttpHeader_STATUS(destination *storage.HttpHeader_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(header.Name)

	// Value
	destination.Value = genruntime.ClonePointerToString(header.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"K80","P100","V100"}
type GpuResource_Sku string

const (
	GpuResource_Sku_K80  = GpuResource_Sku("K80")
	GpuResource_Sku_P100 = GpuResource_Sku("P100")
	GpuResource_Sku_V100 = GpuResource_Sku("V100")
)

// Mapping from string to GpuResource_Sku
var gpuResource_Sku_Values = map[string]GpuResource_Sku{
	"k80":  GpuResource_Sku_K80,
	"p100": GpuResource_Sku_P100,
	"v100": GpuResource_Sku_V100,
}

type GpuResource_Sku_STATUS string

const (
	GpuResource_Sku_STATUS_K80  = GpuResource_Sku_STATUS("K80")
	GpuResource_Sku_STATUS_P100 = GpuResource_Sku_STATUS("P100")
	GpuResource_Sku_STATUS_V100 = GpuResource_Sku_STATUS("V100")
)

// Mapping from string to GpuResource_Sku_STATUS
var gpuResource_Sku_STATUS_Values = map[string]GpuResource_Sku_STATUS{
	"k80":  GpuResource_Sku_STATUS_K80,
	"p100": GpuResource_Sku_STATUS_P100,
	"v100": GpuResource_Sku_STATUS_V100,
}

func init() {
	SchemeBuilder.Register(&ContainerGroup{}, &ContainerGroupList{})
}
