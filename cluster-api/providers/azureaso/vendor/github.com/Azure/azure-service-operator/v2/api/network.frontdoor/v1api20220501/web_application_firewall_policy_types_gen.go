// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20220501

import (
	"fmt"
	arm "github.com/Azure/azure-service-operator/v2/api/network.frontdoor/v1api20220501/arm"
	storage "github.com/Azure/azure-service-operator/v2/api/network.frontdoor/v1api20220501/storage"
	"github.com/Azure/azure-service-operator/v2/internal/reflecthelpers"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/configmaps"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/core"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/secrets"
	"github.com/pkg/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
	"sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Generator information:
// - Generated from: /frontdoor/resource-manager/Microsoft.Network/stable/2022-05-01/webapplicationfirewall.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/FrontDoorWebApplicationFirewallPolicies/{policyName}
type WebApplicationFirewallPolicy struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              WebApplicationFirewallPolicy_Spec   `json:"spec,omitempty"`
	Status            WebApplicationFirewallPolicy_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &WebApplicationFirewallPolicy{}

// GetConditions returns the conditions of the resource
func (policy *WebApplicationFirewallPolicy) GetConditions() conditions.Conditions {
	return policy.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (policy *WebApplicationFirewallPolicy) SetConditions(conditions conditions.Conditions) {
	policy.Status.Conditions = conditions
}

var _ conversion.Convertible = &WebApplicationFirewallPolicy{}

// ConvertFrom populates our WebApplicationFirewallPolicy from the provided hub WebApplicationFirewallPolicy
func (policy *WebApplicationFirewallPolicy) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*storage.WebApplicationFirewallPolicy)
	if !ok {
		return fmt.Errorf("expected network.frontdoor/v1api20220501/storage/WebApplicationFirewallPolicy but received %T instead", hub)
	}

	return policy.AssignProperties_From_WebApplicationFirewallPolicy(source)
}

// ConvertTo populates the provided hub WebApplicationFirewallPolicy from our WebApplicationFirewallPolicy
func (policy *WebApplicationFirewallPolicy) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*storage.WebApplicationFirewallPolicy)
	if !ok {
		return fmt.Errorf("expected network.frontdoor/v1api20220501/storage/WebApplicationFirewallPolicy but received %T instead", hub)
	}

	return policy.AssignProperties_To_WebApplicationFirewallPolicy(destination)
}

// +kubebuilder:webhook:path=/mutate-network-frontdoor-azure-com-v1api20220501-webapplicationfirewallpolicy,mutating=true,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=network.frontdoor.azure.com,resources=webapplicationfirewallpolicies,verbs=create;update,versions=v1api20220501,name=default.v1api20220501.webapplicationfirewallpolicies.network.frontdoor.azure.com,admissionReviewVersions=v1

var _ admission.Defaulter = &WebApplicationFirewallPolicy{}

// Default applies defaults to the WebApplicationFirewallPolicy resource
func (policy *WebApplicationFirewallPolicy) Default() {
	policy.defaultImpl()
	var temp any = policy
	if runtimeDefaulter, ok := temp.(genruntime.Defaulter); ok {
		runtimeDefaulter.CustomDefault()
	}
}

// defaultAzureName defaults the Azure name of the resource to the Kubernetes name
func (policy *WebApplicationFirewallPolicy) defaultAzureName() {
	if policy.Spec.AzureName == "" {
		policy.Spec.AzureName = policy.Name
	}
}

// defaultImpl applies the code generated defaults to the WebApplicationFirewallPolicy resource
func (policy *WebApplicationFirewallPolicy) defaultImpl() { policy.defaultAzureName() }

var _ configmaps.Exporter = &WebApplicationFirewallPolicy{}

// ConfigMapDestinationExpressions returns the Spec.OperatorSpec.ConfigMapExpressions property
func (policy *WebApplicationFirewallPolicy) ConfigMapDestinationExpressions() []*core.DestinationExpression {
	if policy.Spec.OperatorSpec == nil {
		return nil
	}
	return policy.Spec.OperatorSpec.ConfigMapExpressions
}

var _ secrets.Exporter = &WebApplicationFirewallPolicy{}

// SecretDestinationExpressions returns the Spec.OperatorSpec.SecretExpressions property
func (policy *WebApplicationFirewallPolicy) SecretDestinationExpressions() []*core.DestinationExpression {
	if policy.Spec.OperatorSpec == nil {
		return nil
	}
	return policy.Spec.OperatorSpec.SecretExpressions
}

var _ genruntime.ImportableResource = &WebApplicationFirewallPolicy{}

// InitializeSpec initializes the spec for this resource from the given status
func (policy *WebApplicationFirewallPolicy) InitializeSpec(status genruntime.ConvertibleStatus) error {
	if s, ok := status.(*WebApplicationFirewallPolicy_STATUS); ok {
		return policy.Spec.Initialize_From_WebApplicationFirewallPolicy_STATUS(s)
	}

	return fmt.Errorf("expected Status of type WebApplicationFirewallPolicy_STATUS but received %T instead", status)
}

var _ genruntime.KubernetesResource = &WebApplicationFirewallPolicy{}

// AzureName returns the Azure name of the resource
func (policy *WebApplicationFirewallPolicy) AzureName() string {
	return policy.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2022-05-01"
func (policy WebApplicationFirewallPolicy) GetAPIVersion() string {
	return "2022-05-01"
}

// GetResourceScope returns the scope of the resource
func (policy *WebApplicationFirewallPolicy) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (policy *WebApplicationFirewallPolicy) GetSpec() genruntime.ConvertibleSpec {
	return &policy.Spec
}

// GetStatus returns the status of this resource
func (policy *WebApplicationFirewallPolicy) GetStatus() genruntime.ConvertibleStatus {
	return &policy.Status
}

// GetSupportedOperations returns the operations supported by the resource
func (policy *WebApplicationFirewallPolicy) GetSupportedOperations() []genruntime.ResourceOperation {
	return []genruntime.ResourceOperation{
		genruntime.ResourceOperationDelete,
		genruntime.ResourceOperationGet,
		genruntime.ResourceOperationPut,
	}
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.Network/FrontDoorWebApplicationFirewallPolicies"
func (policy *WebApplicationFirewallPolicy) GetType() string {
	return "Microsoft.Network/FrontDoorWebApplicationFirewallPolicies"
}

// NewEmptyStatus returns a new empty (blank) status
func (policy *WebApplicationFirewallPolicy) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &WebApplicationFirewallPolicy_STATUS{}
}

// Owner returns the ResourceReference of the owner
func (policy *WebApplicationFirewallPolicy) Owner() *genruntime.ResourceReference {
	group, kind := genruntime.LookupOwnerGroupKind(policy.Spec)
	return policy.Spec.Owner.AsResourceReference(group, kind)
}

// SetStatus sets the status of this resource
func (policy *WebApplicationFirewallPolicy) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*WebApplicationFirewallPolicy_STATUS); ok {
		policy.Status = *st
		return nil
	}

	// Convert status to required version
	var st WebApplicationFirewallPolicy_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return errors.Wrap(err, "failed to convert status")
	}

	policy.Status = st
	return nil
}

// +kubebuilder:webhook:path=/validate-network-frontdoor-azure-com-v1api20220501-webapplicationfirewallpolicy,mutating=false,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=network.frontdoor.azure.com,resources=webapplicationfirewallpolicies,verbs=create;update,versions=v1api20220501,name=validate.v1api20220501.webapplicationfirewallpolicies.network.frontdoor.azure.com,admissionReviewVersions=v1

var _ admission.Validator = &WebApplicationFirewallPolicy{}

// ValidateCreate validates the creation of the resource
func (policy *WebApplicationFirewallPolicy) ValidateCreate() (admission.Warnings, error) {
	validations := policy.createValidations()
	var temp any = policy
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.CreateValidations()...)
	}
	return genruntime.ValidateCreate(validations)
}

// ValidateDelete validates the deletion of the resource
func (policy *WebApplicationFirewallPolicy) ValidateDelete() (admission.Warnings, error) {
	validations := policy.deleteValidations()
	var temp any = policy
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.DeleteValidations()...)
	}
	return genruntime.ValidateDelete(validations)
}

// ValidateUpdate validates an update of the resource
func (policy *WebApplicationFirewallPolicy) ValidateUpdate(old runtime.Object) (admission.Warnings, error) {
	validations := policy.updateValidations()
	var temp any = policy
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.UpdateValidations()...)
	}
	return genruntime.ValidateUpdate(old, validations)
}

// createValidations validates the creation of the resource
func (policy *WebApplicationFirewallPolicy) createValidations() []func() (admission.Warnings, error) {
	return []func() (admission.Warnings, error){policy.validateResourceReferences, policy.validateOwnerReference, policy.validateSecretDestinations, policy.validateConfigMapDestinations}
}

// deleteValidations validates the deletion of the resource
func (policy *WebApplicationFirewallPolicy) deleteValidations() []func() (admission.Warnings, error) {
	return nil
}

// updateValidations validates the update of the resource
func (policy *WebApplicationFirewallPolicy) updateValidations() []func(old runtime.Object) (admission.Warnings, error) {
	return []func(old runtime.Object) (admission.Warnings, error){
		func(old runtime.Object) (admission.Warnings, error) {
			return policy.validateResourceReferences()
		},
		policy.validateWriteOnceProperties,
		func(old runtime.Object) (admission.Warnings, error) {
			return policy.validateOwnerReference()
		},
		func(old runtime.Object) (admission.Warnings, error) {
			return policy.validateSecretDestinations()
		},
		func(old runtime.Object) (admission.Warnings, error) {
			return policy.validateConfigMapDestinations()
		},
	}
}

// validateConfigMapDestinations validates there are no colliding genruntime.ConfigMapDestinations
func (policy *WebApplicationFirewallPolicy) validateConfigMapDestinations() (admission.Warnings, error) {
	if policy.Spec.OperatorSpec == nil {
		return nil, nil
	}
	return configmaps.ValidateDestinations(policy, nil, policy.Spec.OperatorSpec.ConfigMapExpressions)
}

// validateOwnerReference validates the owner field
func (policy *WebApplicationFirewallPolicy) validateOwnerReference() (admission.Warnings, error) {
	return genruntime.ValidateOwner(policy)
}

// validateResourceReferences validates all resource references
func (policy *WebApplicationFirewallPolicy) validateResourceReferences() (admission.Warnings, error) {
	refs, err := reflecthelpers.FindResourceReferences(&policy.Spec)
	if err != nil {
		return nil, err
	}
	return genruntime.ValidateResourceReferences(refs)
}

// validateSecretDestinations validates there are no colliding genruntime.SecretDestination's
func (policy *WebApplicationFirewallPolicy) validateSecretDestinations() (admission.Warnings, error) {
	if policy.Spec.OperatorSpec == nil {
		return nil, nil
	}
	return secrets.ValidateDestinations(policy, nil, policy.Spec.OperatorSpec.SecretExpressions)
}

// validateWriteOnceProperties validates all WriteOnce properties
func (policy *WebApplicationFirewallPolicy) validateWriteOnceProperties(old runtime.Object) (admission.Warnings, error) {
	oldObj, ok := old.(*WebApplicationFirewallPolicy)
	if !ok {
		return nil, nil
	}

	return genruntime.ValidateWriteOnceProperties(oldObj, policy)
}

// AssignProperties_From_WebApplicationFirewallPolicy populates our WebApplicationFirewallPolicy from the provided source WebApplicationFirewallPolicy
func (policy *WebApplicationFirewallPolicy) AssignProperties_From_WebApplicationFirewallPolicy(source *storage.WebApplicationFirewallPolicy) error {

	// ObjectMeta
	policy.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec WebApplicationFirewallPolicy_Spec
	err := spec.AssignProperties_From_WebApplicationFirewallPolicy_Spec(&source.Spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_WebApplicationFirewallPolicy_Spec() to populate field Spec")
	}
	policy.Spec = spec

	// Status
	var status WebApplicationFirewallPolicy_STATUS
	err = status.AssignProperties_From_WebApplicationFirewallPolicy_STATUS(&source.Status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_WebApplicationFirewallPolicy_STATUS() to populate field Status")
	}
	policy.Status = status

	// No error
	return nil
}

// AssignProperties_To_WebApplicationFirewallPolicy populates the provided destination WebApplicationFirewallPolicy from our WebApplicationFirewallPolicy
func (policy *WebApplicationFirewallPolicy) AssignProperties_To_WebApplicationFirewallPolicy(destination *storage.WebApplicationFirewallPolicy) error {

	// ObjectMeta
	destination.ObjectMeta = *policy.ObjectMeta.DeepCopy()

	// Spec
	var spec storage.WebApplicationFirewallPolicy_Spec
	err := policy.Spec.AssignProperties_To_WebApplicationFirewallPolicy_Spec(&spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_WebApplicationFirewallPolicy_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status storage.WebApplicationFirewallPolicy_STATUS
	err = policy.Status.AssignProperties_To_WebApplicationFirewallPolicy_STATUS(&status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_WebApplicationFirewallPolicy_STATUS() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (policy *WebApplicationFirewallPolicy) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: policy.Spec.OriginalVersion(),
		Kind:    "WebApplicationFirewallPolicy",
	}
}

// +kubebuilder:object:root=true
// Generator information:
// - Generated from: /frontdoor/resource-manager/Microsoft.Network/stable/2022-05-01/webapplicationfirewall.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/FrontDoorWebApplicationFirewallPolicies/{policyName}
type WebApplicationFirewallPolicyList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []WebApplicationFirewallPolicy `json:"items"`
}

// +kubebuilder:validation:Enum={"2022-05-01"}
type APIVersion string

const APIVersion_Value = APIVersion("2022-05-01")

type WebApplicationFirewallPolicy_Spec struct {
	// +kubebuilder:validation:MaxLength=128
	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName string `json:"azureName,omitempty"`

	// CustomRules: Describes custom rules inside the policy.
	CustomRules *CustomRuleList `json:"customRules,omitempty"`

	// Etag: Gets a unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`

	// Location: Resource location.
	Location *string `json:"location,omitempty"`

	// ManagedRules: Describes managed rules inside the policy.
	ManagedRules *ManagedRuleSetList `json:"managedRules,omitempty"`

	// OperatorSpec: The specification for configuring operator behavior. This field is interpreted by the operator and not
	// passed directly to Azure
	OperatorSpec *WebApplicationFirewallPolicyOperatorSpec `json:"operatorSpec,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a resources.azure.com/ResourceGroup resource
	Owner *genruntime.KnownResourceReference `group:"resources.azure.com" json:"owner,omitempty" kind:"ResourceGroup"`

	// PolicySettings: Describes settings for the policy.
	PolicySettings *PolicySettings `json:"policySettings,omitempty"`

	// Sku: The pricing tier of web application firewall policy. Defaults to Classic_AzureFrontDoor if not specified.
	Sku *Sku `json:"sku,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`
}

var _ genruntime.ARMTransformer = &WebApplicationFirewallPolicy_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (policy *WebApplicationFirewallPolicy_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if policy == nil {
		return nil, nil
	}
	result := &arm.WebApplicationFirewallPolicy_Spec{}

	// Set property "Etag":
	if policy.Etag != nil {
		etag := *policy.Etag
		result.Etag = &etag
	}

	// Set property "Location":
	if policy.Location != nil {
		location := *policy.Location
		result.Location = &location
	}

	// Set property "Name":
	result.Name = resolved.Name

	// Set property "Properties":
	if policy.CustomRules != nil ||
		policy.ManagedRules != nil ||
		policy.PolicySettings != nil {
		result.Properties = &arm.WebApplicationFirewallPolicyProperties{}
	}
	if policy.CustomRules != nil {
		customRules_ARM, err := (*policy.CustomRules).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		customRules := *customRules_ARM.(*arm.CustomRuleList)
		result.Properties.CustomRules = &customRules
	}
	if policy.ManagedRules != nil {
		managedRules_ARM, err := (*policy.ManagedRules).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		managedRules := *managedRules_ARM.(*arm.ManagedRuleSetList)
		result.Properties.ManagedRules = &managedRules
	}
	if policy.PolicySettings != nil {
		policySettings_ARM, err := (*policy.PolicySettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		policySettings := *policySettings_ARM.(*arm.PolicySettings)
		result.Properties.PolicySettings = &policySettings
	}

	// Set property "Sku":
	if policy.Sku != nil {
		sku_ARM, err := (*policy.Sku).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		sku := *sku_ARM.(*arm.Sku)
		result.Sku = &sku
	}

	// Set property "Tags":
	if policy.Tags != nil {
		result.Tags = make(map[string]string, len(policy.Tags))
		for key, value := range policy.Tags {
			result.Tags[key] = value
		}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (policy *WebApplicationFirewallPolicy_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.WebApplicationFirewallPolicy_Spec{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (policy *WebApplicationFirewallPolicy_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.WebApplicationFirewallPolicy_Spec)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.WebApplicationFirewallPolicy_Spec, got %T", armInput)
	}

	// Set property "AzureName":
	policy.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property "CustomRules":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.CustomRules != nil {
			var customRules1 CustomRuleList
			err := customRules1.PopulateFromARM(owner, *typedInput.Properties.CustomRules)
			if err != nil {
				return err
			}
			customRules := customRules1
			policy.CustomRules = &customRules
		}
	}

	// Set property "Etag":
	if typedInput.Etag != nil {
		etag := *typedInput.Etag
		policy.Etag = &etag
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		policy.Location = &location
	}

	// Set property "ManagedRules":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ManagedRules != nil {
			var managedRules1 ManagedRuleSetList
			err := managedRules1.PopulateFromARM(owner, *typedInput.Properties.ManagedRules)
			if err != nil {
				return err
			}
			managedRules := managedRules1
			policy.ManagedRules = &managedRules
		}
	}

	// no assignment for property "OperatorSpec"

	// Set property "Owner":
	policy.Owner = &genruntime.KnownResourceReference{
		Name:  owner.Name,
		ARMID: owner.ARMID,
	}

	// Set property "PolicySettings":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PolicySettings != nil {
			var policySettings1 PolicySettings
			err := policySettings1.PopulateFromARM(owner, *typedInput.Properties.PolicySettings)
			if err != nil {
				return err
			}
			policySettings := policySettings1
			policy.PolicySettings = &policySettings
		}
	}

	// Set property "Sku":
	if typedInput.Sku != nil {
		var sku1 Sku
		err := sku1.PopulateFromARM(owner, *typedInput.Sku)
		if err != nil {
			return err
		}
		sku := sku1
		policy.Sku = &sku
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		policy.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			policy.Tags[key] = value
		}
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &WebApplicationFirewallPolicy_Spec{}

// ConvertSpecFrom populates our WebApplicationFirewallPolicy_Spec from the provided source
func (policy *WebApplicationFirewallPolicy_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*storage.WebApplicationFirewallPolicy_Spec)
	if ok {
		// Populate our instance from source
		return policy.AssignProperties_From_WebApplicationFirewallPolicy_Spec(src)
	}

	// Convert to an intermediate form
	src = &storage.WebApplicationFirewallPolicy_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = policy.AssignProperties_From_WebApplicationFirewallPolicy_Spec(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our WebApplicationFirewallPolicy_Spec
func (policy *WebApplicationFirewallPolicy_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*storage.WebApplicationFirewallPolicy_Spec)
	if ok {
		// Populate destination from our instance
		return policy.AssignProperties_To_WebApplicationFirewallPolicy_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &storage.WebApplicationFirewallPolicy_Spec{}
	err := policy.AssignProperties_To_WebApplicationFirewallPolicy_Spec(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignProperties_From_WebApplicationFirewallPolicy_Spec populates our WebApplicationFirewallPolicy_Spec from the provided source WebApplicationFirewallPolicy_Spec
func (policy *WebApplicationFirewallPolicy_Spec) AssignProperties_From_WebApplicationFirewallPolicy_Spec(source *storage.WebApplicationFirewallPolicy_Spec) error {

	// AzureName
	policy.AzureName = source.AzureName

	// CustomRules
	if source.CustomRules != nil {
		var customRule CustomRuleList
		err := customRule.AssignProperties_From_CustomRuleList(source.CustomRules)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_CustomRuleList() to populate field CustomRules")
		}
		policy.CustomRules = &customRule
	} else {
		policy.CustomRules = nil
	}

	// Etag
	policy.Etag = genruntime.ClonePointerToString(source.Etag)

	// Location
	policy.Location = genruntime.ClonePointerToString(source.Location)

	// ManagedRules
	if source.ManagedRules != nil {
		var managedRule ManagedRuleSetList
		err := managedRule.AssignProperties_From_ManagedRuleSetList(source.ManagedRules)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedRuleSetList() to populate field ManagedRules")
		}
		policy.ManagedRules = &managedRule
	} else {
		policy.ManagedRules = nil
	}

	// OperatorSpec
	if source.OperatorSpec != nil {
		var operatorSpec WebApplicationFirewallPolicyOperatorSpec
		err := operatorSpec.AssignProperties_From_WebApplicationFirewallPolicyOperatorSpec(source.OperatorSpec)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_WebApplicationFirewallPolicyOperatorSpec() to populate field OperatorSpec")
		}
		policy.OperatorSpec = &operatorSpec
	} else {
		policy.OperatorSpec = nil
	}

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		policy.Owner = &owner
	} else {
		policy.Owner = nil
	}

	// PolicySettings
	if source.PolicySettings != nil {
		var policySetting PolicySettings
		err := policySetting.AssignProperties_From_PolicySettings(source.PolicySettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_PolicySettings() to populate field PolicySettings")
		}
		policy.PolicySettings = &policySetting
	} else {
		policy.PolicySettings = nil
	}

	// Sku
	if source.Sku != nil {
		var sku Sku
		err := sku.AssignProperties_From_Sku(source.Sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Sku() to populate field Sku")
		}
		policy.Sku = &sku
	} else {
		policy.Sku = nil
	}

	// Tags
	policy.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// No error
	return nil
}

// AssignProperties_To_WebApplicationFirewallPolicy_Spec populates the provided destination WebApplicationFirewallPolicy_Spec from our WebApplicationFirewallPolicy_Spec
func (policy *WebApplicationFirewallPolicy_Spec) AssignProperties_To_WebApplicationFirewallPolicy_Spec(destination *storage.WebApplicationFirewallPolicy_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureName
	destination.AzureName = policy.AzureName

	// CustomRules
	if policy.CustomRules != nil {
		var customRule storage.CustomRuleList
		err := policy.CustomRules.AssignProperties_To_CustomRuleList(&customRule)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_CustomRuleList() to populate field CustomRules")
		}
		destination.CustomRules = &customRule
	} else {
		destination.CustomRules = nil
	}

	// Etag
	destination.Etag = genruntime.ClonePointerToString(policy.Etag)

	// Location
	destination.Location = genruntime.ClonePointerToString(policy.Location)

	// ManagedRules
	if policy.ManagedRules != nil {
		var managedRule storage.ManagedRuleSetList
		err := policy.ManagedRules.AssignProperties_To_ManagedRuleSetList(&managedRule)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedRuleSetList() to populate field ManagedRules")
		}
		destination.ManagedRules = &managedRule
	} else {
		destination.ManagedRules = nil
	}

	// OperatorSpec
	if policy.OperatorSpec != nil {
		var operatorSpec storage.WebApplicationFirewallPolicyOperatorSpec
		err := policy.OperatorSpec.AssignProperties_To_WebApplicationFirewallPolicyOperatorSpec(&operatorSpec)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_WebApplicationFirewallPolicyOperatorSpec() to populate field OperatorSpec")
		}
		destination.OperatorSpec = &operatorSpec
	} else {
		destination.OperatorSpec = nil
	}

	// OriginalVersion
	destination.OriginalVersion = policy.OriginalVersion()

	// Owner
	if policy.Owner != nil {
		owner := policy.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// PolicySettings
	if policy.PolicySettings != nil {
		var policySetting storage.PolicySettings
		err := policy.PolicySettings.AssignProperties_To_PolicySettings(&policySetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_PolicySettings() to populate field PolicySettings")
		}
		destination.PolicySettings = &policySetting
	} else {
		destination.PolicySettings = nil
	}

	// Sku
	if policy.Sku != nil {
		var sku storage.Sku
		err := policy.Sku.AssignProperties_To_Sku(&sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Sku() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(policy.Tags)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_WebApplicationFirewallPolicy_STATUS populates our WebApplicationFirewallPolicy_Spec from the provided source WebApplicationFirewallPolicy_STATUS
func (policy *WebApplicationFirewallPolicy_Spec) Initialize_From_WebApplicationFirewallPolicy_STATUS(source *WebApplicationFirewallPolicy_STATUS) error {

	// CustomRules
	if source.CustomRules != nil {
		var customRule CustomRuleList
		err := customRule.Initialize_From_CustomRuleList_STATUS(source.CustomRules)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_CustomRuleList_STATUS() to populate field CustomRules")
		}
		policy.CustomRules = &customRule
	} else {
		policy.CustomRules = nil
	}

	// Etag
	policy.Etag = genruntime.ClonePointerToString(source.Etag)

	// Location
	policy.Location = genruntime.ClonePointerToString(source.Location)

	// ManagedRules
	if source.ManagedRules != nil {
		var managedRule ManagedRuleSetList
		err := managedRule.Initialize_From_ManagedRuleSetList_STATUS(source.ManagedRules)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_ManagedRuleSetList_STATUS() to populate field ManagedRules")
		}
		policy.ManagedRules = &managedRule
	} else {
		policy.ManagedRules = nil
	}

	// PolicySettings
	if source.PolicySettings != nil {
		var policySetting PolicySettings
		err := policySetting.Initialize_From_PolicySettings_STATUS(source.PolicySettings)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_PolicySettings_STATUS() to populate field PolicySettings")
		}
		policy.PolicySettings = &policySetting
	} else {
		policy.PolicySettings = nil
	}

	// Sku
	if source.Sku != nil {
		var sku Sku
		err := sku.Initialize_From_Sku_STATUS(source.Sku)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_Sku_STATUS() to populate field Sku")
		}
		policy.Sku = &sku
	} else {
		policy.Sku = nil
	}

	// Tags
	policy.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (policy *WebApplicationFirewallPolicy_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (policy *WebApplicationFirewallPolicy_Spec) SetAzureName(azureName string) {
	policy.AzureName = azureName
}

type WebApplicationFirewallPolicy_STATUS struct {
	// Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	// CustomRules: Describes custom rules inside the policy.
	CustomRules *CustomRuleList_STATUS `json:"customRules,omitempty"`

	// Etag: Gets a unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`

	// FrontendEndpointLinks: Describes Frontend Endpoints associated with this Web Application Firewall policy.
	FrontendEndpointLinks []FrontendEndpointLink_STATUS `json:"frontendEndpointLinks,omitempty"`

	// Id: Resource ID.
	Id *string `json:"id,omitempty"`

	// Location: Resource location.
	Location *string `json:"location,omitempty"`

	// ManagedRules: Describes managed rules inside the policy.
	ManagedRules *ManagedRuleSetList_STATUS `json:"managedRules,omitempty"`

	// Name: Resource name.
	Name *string `json:"name,omitempty"`

	// PolicySettings: Describes settings for the policy.
	PolicySettings *PolicySettings_STATUS `json:"policySettings,omitempty"`

	// ProvisioningState: Provisioning state of the policy.
	ProvisioningState *string                                                      `json:"provisioningState,omitempty"`
	ResourceState     *WebApplicationFirewallPolicyProperties_ResourceState_STATUS `json:"resourceState,omitempty"`

	// RoutingRuleLinks: Describes Routing Rules associated with this Web Application Firewall policy.
	RoutingRuleLinks []RoutingRuleLink_STATUS `json:"routingRuleLinks,omitempty"`

	// SecurityPolicyLinks: Describes Security Policy associated with this Web Application Firewall policy.
	SecurityPolicyLinks []SecurityPolicyLink_STATUS `json:"securityPolicyLinks,omitempty"`

	// Sku: The pricing tier of web application firewall policy. Defaults to Classic_AzureFrontDoor if not specified.
	Sku *Sku_STATUS `json:"sku,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`

	// Type: Resource type.
	Type *string `json:"type,omitempty"`
}

var _ genruntime.ConvertibleStatus = &WebApplicationFirewallPolicy_STATUS{}

// ConvertStatusFrom populates our WebApplicationFirewallPolicy_STATUS from the provided source
func (policy *WebApplicationFirewallPolicy_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*storage.WebApplicationFirewallPolicy_STATUS)
	if ok {
		// Populate our instance from source
		return policy.AssignProperties_From_WebApplicationFirewallPolicy_STATUS(src)
	}

	// Convert to an intermediate form
	src = &storage.WebApplicationFirewallPolicy_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = policy.AssignProperties_From_WebApplicationFirewallPolicy_STATUS(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our WebApplicationFirewallPolicy_STATUS
func (policy *WebApplicationFirewallPolicy_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*storage.WebApplicationFirewallPolicy_STATUS)
	if ok {
		// Populate destination from our instance
		return policy.AssignProperties_To_WebApplicationFirewallPolicy_STATUS(dst)
	}

	// Convert to an intermediate form
	dst = &storage.WebApplicationFirewallPolicy_STATUS{}
	err := policy.AssignProperties_To_WebApplicationFirewallPolicy_STATUS(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &WebApplicationFirewallPolicy_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (policy *WebApplicationFirewallPolicy_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.WebApplicationFirewallPolicy_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (policy *WebApplicationFirewallPolicy_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.WebApplicationFirewallPolicy_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.WebApplicationFirewallPolicy_STATUS, got %T", armInput)
	}

	// no assignment for property "Conditions"

	// Set property "CustomRules":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.CustomRules != nil {
			var customRules1 CustomRuleList_STATUS
			err := customRules1.PopulateFromARM(owner, *typedInput.Properties.CustomRules)
			if err != nil {
				return err
			}
			customRules := customRules1
			policy.CustomRules = &customRules
		}
	}

	// Set property "Etag":
	if typedInput.Etag != nil {
		etag := *typedInput.Etag
		policy.Etag = &etag
	}

	// Set property "FrontendEndpointLinks":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.FrontendEndpointLinks {
			var item1 FrontendEndpointLink_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			policy.FrontendEndpointLinks = append(policy.FrontendEndpointLinks, item1)
		}
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		policy.Id = &id
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		policy.Location = &location
	}

	// Set property "ManagedRules":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ManagedRules != nil {
			var managedRules1 ManagedRuleSetList_STATUS
			err := managedRules1.PopulateFromARM(owner, *typedInput.Properties.ManagedRules)
			if err != nil {
				return err
			}
			managedRules := managedRules1
			policy.ManagedRules = &managedRules
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		policy.Name = &name
	}

	// Set property "PolicySettings":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PolicySettings != nil {
			var policySettings1 PolicySettings_STATUS
			err := policySettings1.PopulateFromARM(owner, *typedInput.Properties.PolicySettings)
			if err != nil {
				return err
			}
			policySettings := policySettings1
			policy.PolicySettings = &policySettings
		}
	}

	// Set property "ProvisioningState":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			provisioningState := *typedInput.Properties.ProvisioningState
			policy.ProvisioningState = &provisioningState
		}
	}

	// Set property "ResourceState":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ResourceState != nil {
			var temp string
			temp = string(*typedInput.Properties.ResourceState)
			resourceState := WebApplicationFirewallPolicyProperties_ResourceState_STATUS(temp)
			policy.ResourceState = &resourceState
		}
	}

	// Set property "RoutingRuleLinks":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.RoutingRuleLinks {
			var item1 RoutingRuleLink_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			policy.RoutingRuleLinks = append(policy.RoutingRuleLinks, item1)
		}
	}

	// Set property "SecurityPolicyLinks":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.SecurityPolicyLinks {
			var item1 SecurityPolicyLink_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			policy.SecurityPolicyLinks = append(policy.SecurityPolicyLinks, item1)
		}
	}

	// Set property "Sku":
	if typedInput.Sku != nil {
		var sku1 Sku_STATUS
		err := sku1.PopulateFromARM(owner, *typedInput.Sku)
		if err != nil {
			return err
		}
		sku := sku1
		policy.Sku = &sku
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		policy.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			policy.Tags[key] = value
		}
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		policy.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_WebApplicationFirewallPolicy_STATUS populates our WebApplicationFirewallPolicy_STATUS from the provided source WebApplicationFirewallPolicy_STATUS
func (policy *WebApplicationFirewallPolicy_STATUS) AssignProperties_From_WebApplicationFirewallPolicy_STATUS(source *storage.WebApplicationFirewallPolicy_STATUS) error {

	// Conditions
	policy.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// CustomRules
	if source.CustomRules != nil {
		var customRule CustomRuleList_STATUS
		err := customRule.AssignProperties_From_CustomRuleList_STATUS(source.CustomRules)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_CustomRuleList_STATUS() to populate field CustomRules")
		}
		policy.CustomRules = &customRule
	} else {
		policy.CustomRules = nil
	}

	// Etag
	policy.Etag = genruntime.ClonePointerToString(source.Etag)

	// FrontendEndpointLinks
	if source.FrontendEndpointLinks != nil {
		frontendEndpointLinkList := make([]FrontendEndpointLink_STATUS, len(source.FrontendEndpointLinks))
		for frontendEndpointLinkIndex, frontendEndpointLinkItem := range source.FrontendEndpointLinks {
			// Shadow the loop variable to avoid aliasing
			frontendEndpointLinkItem := frontendEndpointLinkItem
			var frontendEndpointLink FrontendEndpointLink_STATUS
			err := frontendEndpointLink.AssignProperties_From_FrontendEndpointLink_STATUS(&frontendEndpointLinkItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_FrontendEndpointLink_STATUS() to populate field FrontendEndpointLinks")
			}
			frontendEndpointLinkList[frontendEndpointLinkIndex] = frontendEndpointLink
		}
		policy.FrontendEndpointLinks = frontendEndpointLinkList
	} else {
		policy.FrontendEndpointLinks = nil
	}

	// Id
	policy.Id = genruntime.ClonePointerToString(source.Id)

	// Location
	policy.Location = genruntime.ClonePointerToString(source.Location)

	// ManagedRules
	if source.ManagedRules != nil {
		var managedRule ManagedRuleSetList_STATUS
		err := managedRule.AssignProperties_From_ManagedRuleSetList_STATUS(source.ManagedRules)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedRuleSetList_STATUS() to populate field ManagedRules")
		}
		policy.ManagedRules = &managedRule
	} else {
		policy.ManagedRules = nil
	}

	// Name
	policy.Name = genruntime.ClonePointerToString(source.Name)

	// PolicySettings
	if source.PolicySettings != nil {
		var policySetting PolicySettings_STATUS
		err := policySetting.AssignProperties_From_PolicySettings_STATUS(source.PolicySettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_PolicySettings_STATUS() to populate field PolicySettings")
		}
		policy.PolicySettings = &policySetting
	} else {
		policy.PolicySettings = nil
	}

	// ProvisioningState
	policy.ProvisioningState = genruntime.ClonePointerToString(source.ProvisioningState)

	// ResourceState
	if source.ResourceState != nil {
		resourceState := *source.ResourceState
		resourceStateTemp := genruntime.ToEnum(resourceState, webApplicationFirewallPolicyProperties_ResourceState_STATUS_Values)
		policy.ResourceState = &resourceStateTemp
	} else {
		policy.ResourceState = nil
	}

	// RoutingRuleLinks
	if source.RoutingRuleLinks != nil {
		routingRuleLinkList := make([]RoutingRuleLink_STATUS, len(source.RoutingRuleLinks))
		for routingRuleLinkIndex, routingRuleLinkItem := range source.RoutingRuleLinks {
			// Shadow the loop variable to avoid aliasing
			routingRuleLinkItem := routingRuleLinkItem
			var routingRuleLink RoutingRuleLink_STATUS
			err := routingRuleLink.AssignProperties_From_RoutingRuleLink_STATUS(&routingRuleLinkItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_RoutingRuleLink_STATUS() to populate field RoutingRuleLinks")
			}
			routingRuleLinkList[routingRuleLinkIndex] = routingRuleLink
		}
		policy.RoutingRuleLinks = routingRuleLinkList
	} else {
		policy.RoutingRuleLinks = nil
	}

	// SecurityPolicyLinks
	if source.SecurityPolicyLinks != nil {
		securityPolicyLinkList := make([]SecurityPolicyLink_STATUS, len(source.SecurityPolicyLinks))
		for securityPolicyLinkIndex, securityPolicyLinkItem := range source.SecurityPolicyLinks {
			// Shadow the loop variable to avoid aliasing
			securityPolicyLinkItem := securityPolicyLinkItem
			var securityPolicyLink SecurityPolicyLink_STATUS
			err := securityPolicyLink.AssignProperties_From_SecurityPolicyLink_STATUS(&securityPolicyLinkItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SecurityPolicyLink_STATUS() to populate field SecurityPolicyLinks")
			}
			securityPolicyLinkList[securityPolicyLinkIndex] = securityPolicyLink
		}
		policy.SecurityPolicyLinks = securityPolicyLinkList
	} else {
		policy.SecurityPolicyLinks = nil
	}

	// Sku
	if source.Sku != nil {
		var sku Sku_STATUS
		err := sku.AssignProperties_From_Sku_STATUS(source.Sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Sku_STATUS() to populate field Sku")
		}
		policy.Sku = &sku
	} else {
		policy.Sku = nil
	}

	// Tags
	policy.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Type
	policy.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignProperties_To_WebApplicationFirewallPolicy_STATUS populates the provided destination WebApplicationFirewallPolicy_STATUS from our WebApplicationFirewallPolicy_STATUS
func (policy *WebApplicationFirewallPolicy_STATUS) AssignProperties_To_WebApplicationFirewallPolicy_STATUS(destination *storage.WebApplicationFirewallPolicy_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(policy.Conditions)

	// CustomRules
	if policy.CustomRules != nil {
		var customRule storage.CustomRuleList_STATUS
		err := policy.CustomRules.AssignProperties_To_CustomRuleList_STATUS(&customRule)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_CustomRuleList_STATUS() to populate field CustomRules")
		}
		destination.CustomRules = &customRule
	} else {
		destination.CustomRules = nil
	}

	// Etag
	destination.Etag = genruntime.ClonePointerToString(policy.Etag)

	// FrontendEndpointLinks
	if policy.FrontendEndpointLinks != nil {
		frontendEndpointLinkList := make([]storage.FrontendEndpointLink_STATUS, len(policy.FrontendEndpointLinks))
		for frontendEndpointLinkIndex, frontendEndpointLinkItem := range policy.FrontendEndpointLinks {
			// Shadow the loop variable to avoid aliasing
			frontendEndpointLinkItem := frontendEndpointLinkItem
			var frontendEndpointLink storage.FrontendEndpointLink_STATUS
			err := frontendEndpointLinkItem.AssignProperties_To_FrontendEndpointLink_STATUS(&frontendEndpointLink)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_FrontendEndpointLink_STATUS() to populate field FrontendEndpointLinks")
			}
			frontendEndpointLinkList[frontendEndpointLinkIndex] = frontendEndpointLink
		}
		destination.FrontendEndpointLinks = frontendEndpointLinkList
	} else {
		destination.FrontendEndpointLinks = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(policy.Id)

	// Location
	destination.Location = genruntime.ClonePointerToString(policy.Location)

	// ManagedRules
	if policy.ManagedRules != nil {
		var managedRule storage.ManagedRuleSetList_STATUS
		err := policy.ManagedRules.AssignProperties_To_ManagedRuleSetList_STATUS(&managedRule)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedRuleSetList_STATUS() to populate field ManagedRules")
		}
		destination.ManagedRules = &managedRule
	} else {
		destination.ManagedRules = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(policy.Name)

	// PolicySettings
	if policy.PolicySettings != nil {
		var policySetting storage.PolicySettings_STATUS
		err := policy.PolicySettings.AssignProperties_To_PolicySettings_STATUS(&policySetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_PolicySettings_STATUS() to populate field PolicySettings")
		}
		destination.PolicySettings = &policySetting
	} else {
		destination.PolicySettings = nil
	}

	// ProvisioningState
	destination.ProvisioningState = genruntime.ClonePointerToString(policy.ProvisioningState)

	// ResourceState
	if policy.ResourceState != nil {
		resourceState := string(*policy.ResourceState)
		destination.ResourceState = &resourceState
	} else {
		destination.ResourceState = nil
	}

	// RoutingRuleLinks
	if policy.RoutingRuleLinks != nil {
		routingRuleLinkList := make([]storage.RoutingRuleLink_STATUS, len(policy.RoutingRuleLinks))
		for routingRuleLinkIndex, routingRuleLinkItem := range policy.RoutingRuleLinks {
			// Shadow the loop variable to avoid aliasing
			routingRuleLinkItem := routingRuleLinkItem
			var routingRuleLink storage.RoutingRuleLink_STATUS
			err := routingRuleLinkItem.AssignProperties_To_RoutingRuleLink_STATUS(&routingRuleLink)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_RoutingRuleLink_STATUS() to populate field RoutingRuleLinks")
			}
			routingRuleLinkList[routingRuleLinkIndex] = routingRuleLink
		}
		destination.RoutingRuleLinks = routingRuleLinkList
	} else {
		destination.RoutingRuleLinks = nil
	}

	// SecurityPolicyLinks
	if policy.SecurityPolicyLinks != nil {
		securityPolicyLinkList := make([]storage.SecurityPolicyLink_STATUS, len(policy.SecurityPolicyLinks))
		for securityPolicyLinkIndex, securityPolicyLinkItem := range policy.SecurityPolicyLinks {
			// Shadow the loop variable to avoid aliasing
			securityPolicyLinkItem := securityPolicyLinkItem
			var securityPolicyLink storage.SecurityPolicyLink_STATUS
			err := securityPolicyLinkItem.AssignProperties_To_SecurityPolicyLink_STATUS(&securityPolicyLink)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SecurityPolicyLink_STATUS() to populate field SecurityPolicyLinks")
			}
			securityPolicyLinkList[securityPolicyLinkIndex] = securityPolicyLink
		}
		destination.SecurityPolicyLinks = securityPolicyLinkList
	} else {
		destination.SecurityPolicyLinks = nil
	}

	// Sku
	if policy.Sku != nil {
		var sku storage.Sku_STATUS
		err := policy.Sku.AssignProperties_To_Sku_STATUS(&sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Sku_STATUS() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(policy.Tags)

	// Type
	destination.Type = genruntime.ClonePointerToString(policy.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines contents of custom rules
type CustomRuleList struct {
	// Rules: List of rules
	Rules []CustomRule `json:"rules,omitempty"`
}

var _ genruntime.ARMTransformer = &CustomRuleList{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (list *CustomRuleList) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if list == nil {
		return nil, nil
	}
	result := &arm.CustomRuleList{}

	// Set property "Rules":
	for _, item := range list.Rules {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Rules = append(result.Rules, *item_ARM.(*arm.CustomRule))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (list *CustomRuleList) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.CustomRuleList{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (list *CustomRuleList) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.CustomRuleList)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.CustomRuleList, got %T", armInput)
	}

	// Set property "Rules":
	for _, item := range typedInput.Rules {
		var item1 CustomRule
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		list.Rules = append(list.Rules, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_CustomRuleList populates our CustomRuleList from the provided source CustomRuleList
func (list *CustomRuleList) AssignProperties_From_CustomRuleList(source *storage.CustomRuleList) error {

	// Rules
	if source.Rules != nil {
		ruleList := make([]CustomRule, len(source.Rules))
		for ruleIndex, ruleItem := range source.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule CustomRule
			err := rule.AssignProperties_From_CustomRule(&ruleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_CustomRule() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		list.Rules = ruleList
	} else {
		list.Rules = nil
	}

	// No error
	return nil
}

// AssignProperties_To_CustomRuleList populates the provided destination CustomRuleList from our CustomRuleList
func (list *CustomRuleList) AssignProperties_To_CustomRuleList(destination *storage.CustomRuleList) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Rules
	if list.Rules != nil {
		ruleList := make([]storage.CustomRule, len(list.Rules))
		for ruleIndex, ruleItem := range list.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule storage.CustomRule
			err := ruleItem.AssignProperties_To_CustomRule(&rule)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_CustomRule() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		destination.Rules = ruleList
	} else {
		destination.Rules = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_CustomRuleList_STATUS populates our CustomRuleList from the provided source CustomRuleList_STATUS
func (list *CustomRuleList) Initialize_From_CustomRuleList_STATUS(source *CustomRuleList_STATUS) error {

	// Rules
	if source.Rules != nil {
		ruleList := make([]CustomRule, len(source.Rules))
		for ruleIndex, ruleItem := range source.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule CustomRule
			err := rule.Initialize_From_CustomRule_STATUS(&ruleItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_CustomRule_STATUS() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		list.Rules = ruleList
	} else {
		list.Rules = nil
	}

	// No error
	return nil
}

// Defines contents of custom rules
type CustomRuleList_STATUS struct {
	// Rules: List of rules
	Rules []CustomRule_STATUS `json:"rules,omitempty"`
}

var _ genruntime.FromARMConverter = &CustomRuleList_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (list *CustomRuleList_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.CustomRuleList_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (list *CustomRuleList_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.CustomRuleList_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.CustomRuleList_STATUS, got %T", armInput)
	}

	// Set property "Rules":
	for _, item := range typedInput.Rules {
		var item1 CustomRule_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		list.Rules = append(list.Rules, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_CustomRuleList_STATUS populates our CustomRuleList_STATUS from the provided source CustomRuleList_STATUS
func (list *CustomRuleList_STATUS) AssignProperties_From_CustomRuleList_STATUS(source *storage.CustomRuleList_STATUS) error {

	// Rules
	if source.Rules != nil {
		ruleList := make([]CustomRule_STATUS, len(source.Rules))
		for ruleIndex, ruleItem := range source.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule CustomRule_STATUS
			err := rule.AssignProperties_From_CustomRule_STATUS(&ruleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_CustomRule_STATUS() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		list.Rules = ruleList
	} else {
		list.Rules = nil
	}

	// No error
	return nil
}

// AssignProperties_To_CustomRuleList_STATUS populates the provided destination CustomRuleList_STATUS from our CustomRuleList_STATUS
func (list *CustomRuleList_STATUS) AssignProperties_To_CustomRuleList_STATUS(destination *storage.CustomRuleList_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Rules
	if list.Rules != nil {
		ruleList := make([]storage.CustomRule_STATUS, len(list.Rules))
		for ruleIndex, ruleItem := range list.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule storage.CustomRule_STATUS
			err := ruleItem.AssignProperties_To_CustomRule_STATUS(&rule)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_CustomRule_STATUS() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		destination.Rules = ruleList
	} else {
		destination.Rules = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines the Resource ID for a Frontend Endpoint.
type FrontendEndpointLink_STATUS struct {
	// Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &FrontendEndpointLink_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (link *FrontendEndpointLink_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.FrontendEndpointLink_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (link *FrontendEndpointLink_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.FrontendEndpointLink_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.FrontendEndpointLink_STATUS, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		link.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_FrontendEndpointLink_STATUS populates our FrontendEndpointLink_STATUS from the provided source FrontendEndpointLink_STATUS
func (link *FrontendEndpointLink_STATUS) AssignProperties_From_FrontendEndpointLink_STATUS(source *storage.FrontendEndpointLink_STATUS) error {

	// Id
	link.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_FrontendEndpointLink_STATUS populates the provided destination FrontendEndpointLink_STATUS from our FrontendEndpointLink_STATUS
func (link *FrontendEndpointLink_STATUS) AssignProperties_To_FrontendEndpointLink_STATUS(destination *storage.FrontendEndpointLink_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(link.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines the list of managed rule sets for the policy.
type ManagedRuleSetList struct {
	// ManagedRuleSets: List of rule sets.
	ManagedRuleSets []ManagedRuleSet `json:"managedRuleSets,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedRuleSetList{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (list *ManagedRuleSetList) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if list == nil {
		return nil, nil
	}
	result := &arm.ManagedRuleSetList{}

	// Set property "ManagedRuleSets":
	for _, item := range list.ManagedRuleSets {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.ManagedRuleSets = append(result.ManagedRuleSets, *item_ARM.(*arm.ManagedRuleSet))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (list *ManagedRuleSetList) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedRuleSetList{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (list *ManagedRuleSetList) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedRuleSetList)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedRuleSetList, got %T", armInput)
	}

	// Set property "ManagedRuleSets":
	for _, item := range typedInput.ManagedRuleSets {
		var item1 ManagedRuleSet
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		list.ManagedRuleSets = append(list.ManagedRuleSets, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedRuleSetList populates our ManagedRuleSetList from the provided source ManagedRuleSetList
func (list *ManagedRuleSetList) AssignProperties_From_ManagedRuleSetList(source *storage.ManagedRuleSetList) error {

	// ManagedRuleSets
	if source.ManagedRuleSets != nil {
		managedRuleSetList := make([]ManagedRuleSet, len(source.ManagedRuleSets))
		for managedRuleSetIndex, managedRuleSetItem := range source.ManagedRuleSets {
			// Shadow the loop variable to avoid aliasing
			managedRuleSetItem := managedRuleSetItem
			var managedRuleSet ManagedRuleSet
			err := managedRuleSet.AssignProperties_From_ManagedRuleSet(&managedRuleSetItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ManagedRuleSet() to populate field ManagedRuleSets")
			}
			managedRuleSetList[managedRuleSetIndex] = managedRuleSet
		}
		list.ManagedRuleSets = managedRuleSetList
	} else {
		list.ManagedRuleSets = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedRuleSetList populates the provided destination ManagedRuleSetList from our ManagedRuleSetList
func (list *ManagedRuleSetList) AssignProperties_To_ManagedRuleSetList(destination *storage.ManagedRuleSetList) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ManagedRuleSets
	if list.ManagedRuleSets != nil {
		managedRuleSetList := make([]storage.ManagedRuleSet, len(list.ManagedRuleSets))
		for managedRuleSetIndex, managedRuleSetItem := range list.ManagedRuleSets {
			// Shadow the loop variable to avoid aliasing
			managedRuleSetItem := managedRuleSetItem
			var managedRuleSet storage.ManagedRuleSet
			err := managedRuleSetItem.AssignProperties_To_ManagedRuleSet(&managedRuleSet)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ManagedRuleSet() to populate field ManagedRuleSets")
			}
			managedRuleSetList[managedRuleSetIndex] = managedRuleSet
		}
		destination.ManagedRuleSets = managedRuleSetList
	} else {
		destination.ManagedRuleSets = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ManagedRuleSetList_STATUS populates our ManagedRuleSetList from the provided source ManagedRuleSetList_STATUS
func (list *ManagedRuleSetList) Initialize_From_ManagedRuleSetList_STATUS(source *ManagedRuleSetList_STATUS) error {

	// ManagedRuleSets
	if source.ManagedRuleSets != nil {
		managedRuleSetList := make([]ManagedRuleSet, len(source.ManagedRuleSets))
		for managedRuleSetIndex, managedRuleSetItem := range source.ManagedRuleSets {
			// Shadow the loop variable to avoid aliasing
			managedRuleSetItem := managedRuleSetItem
			var managedRuleSet ManagedRuleSet
			err := managedRuleSet.Initialize_From_ManagedRuleSet_STATUS(&managedRuleSetItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_ManagedRuleSet_STATUS() to populate field ManagedRuleSets")
			}
			managedRuleSetList[managedRuleSetIndex] = managedRuleSet
		}
		list.ManagedRuleSets = managedRuleSetList
	} else {
		list.ManagedRuleSets = nil
	}

	// No error
	return nil
}

// Defines the list of managed rule sets for the policy.
type ManagedRuleSetList_STATUS struct {
	// ManagedRuleSets: List of rule sets.
	ManagedRuleSets []ManagedRuleSet_STATUS `json:"managedRuleSets,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedRuleSetList_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (list *ManagedRuleSetList_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedRuleSetList_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (list *ManagedRuleSetList_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedRuleSetList_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedRuleSetList_STATUS, got %T", armInput)
	}

	// Set property "ManagedRuleSets":
	for _, item := range typedInput.ManagedRuleSets {
		var item1 ManagedRuleSet_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		list.ManagedRuleSets = append(list.ManagedRuleSets, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedRuleSetList_STATUS populates our ManagedRuleSetList_STATUS from the provided source ManagedRuleSetList_STATUS
func (list *ManagedRuleSetList_STATUS) AssignProperties_From_ManagedRuleSetList_STATUS(source *storage.ManagedRuleSetList_STATUS) error {

	// ManagedRuleSets
	if source.ManagedRuleSets != nil {
		managedRuleSetList := make([]ManagedRuleSet_STATUS, len(source.ManagedRuleSets))
		for managedRuleSetIndex, managedRuleSetItem := range source.ManagedRuleSets {
			// Shadow the loop variable to avoid aliasing
			managedRuleSetItem := managedRuleSetItem
			var managedRuleSet ManagedRuleSet_STATUS
			err := managedRuleSet.AssignProperties_From_ManagedRuleSet_STATUS(&managedRuleSetItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ManagedRuleSet_STATUS() to populate field ManagedRuleSets")
			}
			managedRuleSetList[managedRuleSetIndex] = managedRuleSet
		}
		list.ManagedRuleSets = managedRuleSetList
	} else {
		list.ManagedRuleSets = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedRuleSetList_STATUS populates the provided destination ManagedRuleSetList_STATUS from our ManagedRuleSetList_STATUS
func (list *ManagedRuleSetList_STATUS) AssignProperties_To_ManagedRuleSetList_STATUS(destination *storage.ManagedRuleSetList_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ManagedRuleSets
	if list.ManagedRuleSets != nil {
		managedRuleSetList := make([]storage.ManagedRuleSet_STATUS, len(list.ManagedRuleSets))
		for managedRuleSetIndex, managedRuleSetItem := range list.ManagedRuleSets {
			// Shadow the loop variable to avoid aliasing
			managedRuleSetItem := managedRuleSetItem
			var managedRuleSet storage.ManagedRuleSet_STATUS
			err := managedRuleSetItem.AssignProperties_To_ManagedRuleSet_STATUS(&managedRuleSet)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ManagedRuleSet_STATUS() to populate field ManagedRuleSets")
			}
			managedRuleSetList[managedRuleSetIndex] = managedRuleSet
		}
		destination.ManagedRuleSets = managedRuleSetList
	} else {
		destination.ManagedRuleSets = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines top-level WebApplicationFirewallPolicy configuration settings.
type PolicySettings struct {
	// +kubebuilder:validation:Pattern="^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$"
	// CustomBlockResponseBody: If the action type is block, customer can override the response body. The body must be
	// specified in base64 encoding.
	CustomBlockResponseBody *string `json:"customBlockResponseBody,omitempty"`

	// CustomBlockResponseStatusCode: If the action type is block, customer can override the response status code.
	CustomBlockResponseStatusCode *int `json:"customBlockResponseStatusCode,omitempty"`

	// EnabledState: Describes if the policy is in enabled or disabled state. Defaults to Enabled if not specified.
	EnabledState *PolicySettings_EnabledState `json:"enabledState,omitempty"`

	// Mode: Describes if it is in detection mode or prevention mode at policy level.
	Mode *PolicySettings_Mode `json:"mode,omitempty"`

	// RedirectUrl: If action type is redirect, this field represents redirect URL for the client.
	RedirectUrl *string `json:"redirectUrl,omitempty"`

	// RequestBodyCheck: Describes if policy managed rules will inspect the request body content.
	RequestBodyCheck *PolicySettings_RequestBodyCheck `json:"requestBodyCheck,omitempty"`
}

var _ genruntime.ARMTransformer = &PolicySettings{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (settings *PolicySettings) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if settings == nil {
		return nil, nil
	}
	result := &arm.PolicySettings{}

	// Set property "CustomBlockResponseBody":
	if settings.CustomBlockResponseBody != nil {
		customBlockResponseBody := *settings.CustomBlockResponseBody
		result.CustomBlockResponseBody = &customBlockResponseBody
	}

	// Set property "CustomBlockResponseStatusCode":
	if settings.CustomBlockResponseStatusCode != nil {
		customBlockResponseStatusCode := *settings.CustomBlockResponseStatusCode
		result.CustomBlockResponseStatusCode = &customBlockResponseStatusCode
	}

	// Set property "EnabledState":
	if settings.EnabledState != nil {
		var temp string
		temp = string(*settings.EnabledState)
		enabledState := arm.PolicySettings_EnabledState(temp)
		result.EnabledState = &enabledState
	}

	// Set property "Mode":
	if settings.Mode != nil {
		var temp string
		temp = string(*settings.Mode)
		mode := arm.PolicySettings_Mode(temp)
		result.Mode = &mode
	}

	// Set property "RedirectUrl":
	if settings.RedirectUrl != nil {
		redirectUrl := *settings.RedirectUrl
		result.RedirectUrl = &redirectUrl
	}

	// Set property "RequestBodyCheck":
	if settings.RequestBodyCheck != nil {
		var temp string
		temp = string(*settings.RequestBodyCheck)
		requestBodyCheck := arm.PolicySettings_RequestBodyCheck(temp)
		result.RequestBodyCheck = &requestBodyCheck
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *PolicySettings) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.PolicySettings{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *PolicySettings) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.PolicySettings)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.PolicySettings, got %T", armInput)
	}

	// Set property "CustomBlockResponseBody":
	if typedInput.CustomBlockResponseBody != nil {
		customBlockResponseBody := *typedInput.CustomBlockResponseBody
		settings.CustomBlockResponseBody = &customBlockResponseBody
	}

	// Set property "CustomBlockResponseStatusCode":
	if typedInput.CustomBlockResponseStatusCode != nil {
		customBlockResponseStatusCode := *typedInput.CustomBlockResponseStatusCode
		settings.CustomBlockResponseStatusCode = &customBlockResponseStatusCode
	}

	// Set property "EnabledState":
	if typedInput.EnabledState != nil {
		var temp string
		temp = string(*typedInput.EnabledState)
		enabledState := PolicySettings_EnabledState(temp)
		settings.EnabledState = &enabledState
	}

	// Set property "Mode":
	if typedInput.Mode != nil {
		var temp string
		temp = string(*typedInput.Mode)
		mode := PolicySettings_Mode(temp)
		settings.Mode = &mode
	}

	// Set property "RedirectUrl":
	if typedInput.RedirectUrl != nil {
		redirectUrl := *typedInput.RedirectUrl
		settings.RedirectUrl = &redirectUrl
	}

	// Set property "RequestBodyCheck":
	if typedInput.RequestBodyCheck != nil {
		var temp string
		temp = string(*typedInput.RequestBodyCheck)
		requestBodyCheck := PolicySettings_RequestBodyCheck(temp)
		settings.RequestBodyCheck = &requestBodyCheck
	}

	// No error
	return nil
}

// AssignProperties_From_PolicySettings populates our PolicySettings from the provided source PolicySettings
func (settings *PolicySettings) AssignProperties_From_PolicySettings(source *storage.PolicySettings) error {

	// CustomBlockResponseBody
	if source.CustomBlockResponseBody != nil {
		customBlockResponseBody := *source.CustomBlockResponseBody
		settings.CustomBlockResponseBody = &customBlockResponseBody
	} else {
		settings.CustomBlockResponseBody = nil
	}

	// CustomBlockResponseStatusCode
	settings.CustomBlockResponseStatusCode = genruntime.ClonePointerToInt(source.CustomBlockResponseStatusCode)

	// EnabledState
	if source.EnabledState != nil {
		enabledState := *source.EnabledState
		enabledStateTemp := genruntime.ToEnum(enabledState, policySettings_EnabledState_Values)
		settings.EnabledState = &enabledStateTemp
	} else {
		settings.EnabledState = nil
	}

	// Mode
	if source.Mode != nil {
		mode := *source.Mode
		modeTemp := genruntime.ToEnum(mode, policySettings_Mode_Values)
		settings.Mode = &modeTemp
	} else {
		settings.Mode = nil
	}

	// RedirectUrl
	settings.RedirectUrl = genruntime.ClonePointerToString(source.RedirectUrl)

	// RequestBodyCheck
	if source.RequestBodyCheck != nil {
		requestBodyCheck := *source.RequestBodyCheck
		requestBodyCheckTemp := genruntime.ToEnum(requestBodyCheck, policySettings_RequestBodyCheck_Values)
		settings.RequestBodyCheck = &requestBodyCheckTemp
	} else {
		settings.RequestBodyCheck = nil
	}

	// No error
	return nil
}

// AssignProperties_To_PolicySettings populates the provided destination PolicySettings from our PolicySettings
func (settings *PolicySettings) AssignProperties_To_PolicySettings(destination *storage.PolicySettings) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CustomBlockResponseBody
	if settings.CustomBlockResponseBody != nil {
		customBlockResponseBody := *settings.CustomBlockResponseBody
		destination.CustomBlockResponseBody = &customBlockResponseBody
	} else {
		destination.CustomBlockResponseBody = nil
	}

	// CustomBlockResponseStatusCode
	destination.CustomBlockResponseStatusCode = genruntime.ClonePointerToInt(settings.CustomBlockResponseStatusCode)

	// EnabledState
	if settings.EnabledState != nil {
		enabledState := string(*settings.EnabledState)
		destination.EnabledState = &enabledState
	} else {
		destination.EnabledState = nil
	}

	// Mode
	if settings.Mode != nil {
		mode := string(*settings.Mode)
		destination.Mode = &mode
	} else {
		destination.Mode = nil
	}

	// RedirectUrl
	destination.RedirectUrl = genruntime.ClonePointerToString(settings.RedirectUrl)

	// RequestBodyCheck
	if settings.RequestBodyCheck != nil {
		requestBodyCheck := string(*settings.RequestBodyCheck)
		destination.RequestBodyCheck = &requestBodyCheck
	} else {
		destination.RequestBodyCheck = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_PolicySettings_STATUS populates our PolicySettings from the provided source PolicySettings_STATUS
func (settings *PolicySettings) Initialize_From_PolicySettings_STATUS(source *PolicySettings_STATUS) error {

	// CustomBlockResponseBody
	if source.CustomBlockResponseBody != nil {
		customBlockResponseBody := *source.CustomBlockResponseBody
		settings.CustomBlockResponseBody = &customBlockResponseBody
	} else {
		settings.CustomBlockResponseBody = nil
	}

	// CustomBlockResponseStatusCode
	settings.CustomBlockResponseStatusCode = genruntime.ClonePointerToInt(source.CustomBlockResponseStatusCode)

	// EnabledState
	if source.EnabledState != nil {
		enabledState := genruntime.ToEnum(string(*source.EnabledState), policySettings_EnabledState_Values)
		settings.EnabledState = &enabledState
	} else {
		settings.EnabledState = nil
	}

	// Mode
	if source.Mode != nil {
		mode := genruntime.ToEnum(string(*source.Mode), policySettings_Mode_Values)
		settings.Mode = &mode
	} else {
		settings.Mode = nil
	}

	// RedirectUrl
	settings.RedirectUrl = genruntime.ClonePointerToString(source.RedirectUrl)

	// RequestBodyCheck
	if source.RequestBodyCheck != nil {
		requestBodyCheck := genruntime.ToEnum(string(*source.RequestBodyCheck), policySettings_RequestBodyCheck_Values)
		settings.RequestBodyCheck = &requestBodyCheck
	} else {
		settings.RequestBodyCheck = nil
	}

	// No error
	return nil
}

// Defines top-level WebApplicationFirewallPolicy configuration settings.
type PolicySettings_STATUS struct {
	// CustomBlockResponseBody: If the action type is block, customer can override the response body. The body must be
	// specified in base64 encoding.
	CustomBlockResponseBody *string `json:"customBlockResponseBody,omitempty"`

	// CustomBlockResponseStatusCode: If the action type is block, customer can override the response status code.
	CustomBlockResponseStatusCode *int `json:"customBlockResponseStatusCode,omitempty"`

	// EnabledState: Describes if the policy is in enabled or disabled state. Defaults to Enabled if not specified.
	EnabledState *PolicySettings_EnabledState_STATUS `json:"enabledState,omitempty"`

	// Mode: Describes if it is in detection mode or prevention mode at policy level.
	Mode *PolicySettings_Mode_STATUS `json:"mode,omitempty"`

	// RedirectUrl: If action type is redirect, this field represents redirect URL for the client.
	RedirectUrl *string `json:"redirectUrl,omitempty"`

	// RequestBodyCheck: Describes if policy managed rules will inspect the request body content.
	RequestBodyCheck *PolicySettings_RequestBodyCheck_STATUS `json:"requestBodyCheck,omitempty"`
}

var _ genruntime.FromARMConverter = &PolicySettings_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *PolicySettings_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.PolicySettings_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *PolicySettings_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.PolicySettings_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.PolicySettings_STATUS, got %T", armInput)
	}

	// Set property "CustomBlockResponseBody":
	if typedInput.CustomBlockResponseBody != nil {
		customBlockResponseBody := *typedInput.CustomBlockResponseBody
		settings.CustomBlockResponseBody = &customBlockResponseBody
	}

	// Set property "CustomBlockResponseStatusCode":
	if typedInput.CustomBlockResponseStatusCode != nil {
		customBlockResponseStatusCode := *typedInput.CustomBlockResponseStatusCode
		settings.CustomBlockResponseStatusCode = &customBlockResponseStatusCode
	}

	// Set property "EnabledState":
	if typedInput.EnabledState != nil {
		var temp string
		temp = string(*typedInput.EnabledState)
		enabledState := PolicySettings_EnabledState_STATUS(temp)
		settings.EnabledState = &enabledState
	}

	// Set property "Mode":
	if typedInput.Mode != nil {
		var temp string
		temp = string(*typedInput.Mode)
		mode := PolicySettings_Mode_STATUS(temp)
		settings.Mode = &mode
	}

	// Set property "RedirectUrl":
	if typedInput.RedirectUrl != nil {
		redirectUrl := *typedInput.RedirectUrl
		settings.RedirectUrl = &redirectUrl
	}

	// Set property "RequestBodyCheck":
	if typedInput.RequestBodyCheck != nil {
		var temp string
		temp = string(*typedInput.RequestBodyCheck)
		requestBodyCheck := PolicySettings_RequestBodyCheck_STATUS(temp)
		settings.RequestBodyCheck = &requestBodyCheck
	}

	// No error
	return nil
}

// AssignProperties_From_PolicySettings_STATUS populates our PolicySettings_STATUS from the provided source PolicySettings_STATUS
func (settings *PolicySettings_STATUS) AssignProperties_From_PolicySettings_STATUS(source *storage.PolicySettings_STATUS) error {

	// CustomBlockResponseBody
	settings.CustomBlockResponseBody = genruntime.ClonePointerToString(source.CustomBlockResponseBody)

	// CustomBlockResponseStatusCode
	settings.CustomBlockResponseStatusCode = genruntime.ClonePointerToInt(source.CustomBlockResponseStatusCode)

	// EnabledState
	if source.EnabledState != nil {
		enabledState := *source.EnabledState
		enabledStateTemp := genruntime.ToEnum(enabledState, policySettings_EnabledState_STATUS_Values)
		settings.EnabledState = &enabledStateTemp
	} else {
		settings.EnabledState = nil
	}

	// Mode
	if source.Mode != nil {
		mode := *source.Mode
		modeTemp := genruntime.ToEnum(mode, policySettings_Mode_STATUS_Values)
		settings.Mode = &modeTemp
	} else {
		settings.Mode = nil
	}

	// RedirectUrl
	settings.RedirectUrl = genruntime.ClonePointerToString(source.RedirectUrl)

	// RequestBodyCheck
	if source.RequestBodyCheck != nil {
		requestBodyCheck := *source.RequestBodyCheck
		requestBodyCheckTemp := genruntime.ToEnum(requestBodyCheck, policySettings_RequestBodyCheck_STATUS_Values)
		settings.RequestBodyCheck = &requestBodyCheckTemp
	} else {
		settings.RequestBodyCheck = nil
	}

	// No error
	return nil
}

// AssignProperties_To_PolicySettings_STATUS populates the provided destination PolicySettings_STATUS from our PolicySettings_STATUS
func (settings *PolicySettings_STATUS) AssignProperties_To_PolicySettings_STATUS(destination *storage.PolicySettings_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CustomBlockResponseBody
	destination.CustomBlockResponseBody = genruntime.ClonePointerToString(settings.CustomBlockResponseBody)

	// CustomBlockResponseStatusCode
	destination.CustomBlockResponseStatusCode = genruntime.ClonePointerToInt(settings.CustomBlockResponseStatusCode)

	// EnabledState
	if settings.EnabledState != nil {
		enabledState := string(*settings.EnabledState)
		destination.EnabledState = &enabledState
	} else {
		destination.EnabledState = nil
	}

	// Mode
	if settings.Mode != nil {
		mode := string(*settings.Mode)
		destination.Mode = &mode
	} else {
		destination.Mode = nil
	}

	// RedirectUrl
	destination.RedirectUrl = genruntime.ClonePointerToString(settings.RedirectUrl)

	// RequestBodyCheck
	if settings.RequestBodyCheck != nil {
		requestBodyCheck := string(*settings.RequestBodyCheck)
		destination.RequestBodyCheck = &requestBodyCheck
	} else {
		destination.RequestBodyCheck = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines the Resource ID for a Routing Rule.
type RoutingRuleLink_STATUS struct {
	// Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &RoutingRuleLink_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (link *RoutingRuleLink_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.RoutingRuleLink_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (link *RoutingRuleLink_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.RoutingRuleLink_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.RoutingRuleLink_STATUS, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		link.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_RoutingRuleLink_STATUS populates our RoutingRuleLink_STATUS from the provided source RoutingRuleLink_STATUS
func (link *RoutingRuleLink_STATUS) AssignProperties_From_RoutingRuleLink_STATUS(source *storage.RoutingRuleLink_STATUS) error {

	// Id
	link.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_RoutingRuleLink_STATUS populates the provided destination RoutingRuleLink_STATUS from our RoutingRuleLink_STATUS
func (link *RoutingRuleLink_STATUS) AssignProperties_To_RoutingRuleLink_STATUS(destination *storage.RoutingRuleLink_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(link.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines the Resource ID for a Security Policy.
type SecurityPolicyLink_STATUS struct {
	// Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &SecurityPolicyLink_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (link *SecurityPolicyLink_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SecurityPolicyLink_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (link *SecurityPolicyLink_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SecurityPolicyLink_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SecurityPolicyLink_STATUS, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		link.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_SecurityPolicyLink_STATUS populates our SecurityPolicyLink_STATUS from the provided source SecurityPolicyLink_STATUS
func (link *SecurityPolicyLink_STATUS) AssignProperties_From_SecurityPolicyLink_STATUS(source *storage.SecurityPolicyLink_STATUS) error {

	// Id
	link.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_SecurityPolicyLink_STATUS populates the provided destination SecurityPolicyLink_STATUS from our SecurityPolicyLink_STATUS
func (link *SecurityPolicyLink_STATUS) AssignProperties_To_SecurityPolicyLink_STATUS(destination *storage.SecurityPolicyLink_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(link.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The pricing tier of the web application firewall policy.
type Sku struct {
	// Name: Name of the pricing tier.
	Name *Sku_Name `json:"name,omitempty"`
}

var _ genruntime.ARMTransformer = &Sku{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (sku *Sku) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if sku == nil {
		return nil, nil
	}
	result := &arm.Sku{}

	// Set property "Name":
	if sku.Name != nil {
		var temp string
		temp = string(*sku.Name)
		name := arm.Sku_Name(temp)
		result.Name = &name
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (sku *Sku) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Sku{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (sku *Sku) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Sku)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Sku, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		var temp string
		temp = string(*typedInput.Name)
		name := Sku_Name(temp)
		sku.Name = &name
	}

	// No error
	return nil
}

// AssignProperties_From_Sku populates our Sku from the provided source Sku
func (sku *Sku) AssignProperties_From_Sku(source *storage.Sku) error {

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, sku_Name_Values)
		sku.Name = &nameTemp
	} else {
		sku.Name = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Sku populates the provided destination Sku from our Sku
func (sku *Sku) AssignProperties_To_Sku(destination *storage.Sku) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if sku.Name != nil {
		name := string(*sku.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_Sku_STATUS populates our Sku from the provided source Sku_STATUS
func (sku *Sku) Initialize_From_Sku_STATUS(source *Sku_STATUS) error {

	// Name
	if source.Name != nil {
		name := genruntime.ToEnum(string(*source.Name), sku_Name_Values)
		sku.Name = &name
	} else {
		sku.Name = nil
	}

	// No error
	return nil
}

// The pricing tier of the web application firewall policy.
type Sku_STATUS struct {
	// Name: Name of the pricing tier.
	Name *Sku_Name_STATUS `json:"name,omitempty"`
}

var _ genruntime.FromARMConverter = &Sku_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (sku *Sku_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Sku_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (sku *Sku_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Sku_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Sku_STATUS, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		var temp string
		temp = string(*typedInput.Name)
		name := Sku_Name_STATUS(temp)
		sku.Name = &name
	}

	// No error
	return nil
}

// AssignProperties_From_Sku_STATUS populates our Sku_STATUS from the provided source Sku_STATUS
func (sku *Sku_STATUS) AssignProperties_From_Sku_STATUS(source *storage.Sku_STATUS) error {

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, sku_Name_STATUS_Values)
		sku.Name = &nameTemp
	} else {
		sku.Name = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Sku_STATUS populates the provided destination Sku_STATUS from our Sku_STATUS
func (sku *Sku_STATUS) AssignProperties_To_Sku_STATUS(destination *storage.Sku_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if sku.Name != nil {
		name := string(*sku.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Details for configuring operator behavior. Fields in this struct are interpreted by the operator directly rather than being passed to Azure
type WebApplicationFirewallPolicyOperatorSpec struct {
	// ConfigMapExpressions: configures where to place operator written dynamic ConfigMaps (created with CEL expressions).
	ConfigMapExpressions []*core.DestinationExpression `json:"configMapExpressions,omitempty"`

	// SecretExpressions: configures where to place operator written dynamic secrets (created with CEL expressions).
	SecretExpressions []*core.DestinationExpression `json:"secretExpressions,omitempty"`
}

// AssignProperties_From_WebApplicationFirewallPolicyOperatorSpec populates our WebApplicationFirewallPolicyOperatorSpec from the provided source WebApplicationFirewallPolicyOperatorSpec
func (operator *WebApplicationFirewallPolicyOperatorSpec) AssignProperties_From_WebApplicationFirewallPolicyOperatorSpec(source *storage.WebApplicationFirewallPolicyOperatorSpec) error {

	// ConfigMapExpressions
	if source.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(source.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range source.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		operator.ConfigMapExpressions = configMapExpressionList
	} else {
		operator.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if source.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(source.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range source.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		operator.SecretExpressions = secretExpressionList
	} else {
		operator.SecretExpressions = nil
	}

	// No error
	return nil
}

// AssignProperties_To_WebApplicationFirewallPolicyOperatorSpec populates the provided destination WebApplicationFirewallPolicyOperatorSpec from our WebApplicationFirewallPolicyOperatorSpec
func (operator *WebApplicationFirewallPolicyOperatorSpec) AssignProperties_To_WebApplicationFirewallPolicyOperatorSpec(destination *storage.WebApplicationFirewallPolicyOperatorSpec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ConfigMapExpressions
	if operator.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(operator.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range operator.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		destination.ConfigMapExpressions = configMapExpressionList
	} else {
		destination.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if operator.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(operator.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range operator.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		destination.SecretExpressions = secretExpressionList
	} else {
		destination.SecretExpressions = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type WebApplicationFirewallPolicyProperties_ResourceState_STATUS string

const (
	WebApplicationFirewallPolicyProperties_ResourceState_STATUS_Creating  = WebApplicationFirewallPolicyProperties_ResourceState_STATUS("Creating")
	WebApplicationFirewallPolicyProperties_ResourceState_STATUS_Deleting  = WebApplicationFirewallPolicyProperties_ResourceState_STATUS("Deleting")
	WebApplicationFirewallPolicyProperties_ResourceState_STATUS_Disabled  = WebApplicationFirewallPolicyProperties_ResourceState_STATUS("Disabled")
	WebApplicationFirewallPolicyProperties_ResourceState_STATUS_Disabling = WebApplicationFirewallPolicyProperties_ResourceState_STATUS("Disabling")
	WebApplicationFirewallPolicyProperties_ResourceState_STATUS_Enabled   = WebApplicationFirewallPolicyProperties_ResourceState_STATUS("Enabled")
	WebApplicationFirewallPolicyProperties_ResourceState_STATUS_Enabling  = WebApplicationFirewallPolicyProperties_ResourceState_STATUS("Enabling")
)

// Mapping from string to WebApplicationFirewallPolicyProperties_ResourceState_STATUS
var webApplicationFirewallPolicyProperties_ResourceState_STATUS_Values = map[string]WebApplicationFirewallPolicyProperties_ResourceState_STATUS{
	"creating":  WebApplicationFirewallPolicyProperties_ResourceState_STATUS_Creating,
	"deleting":  WebApplicationFirewallPolicyProperties_ResourceState_STATUS_Deleting,
	"disabled":  WebApplicationFirewallPolicyProperties_ResourceState_STATUS_Disabled,
	"disabling": WebApplicationFirewallPolicyProperties_ResourceState_STATUS_Disabling,
	"enabled":   WebApplicationFirewallPolicyProperties_ResourceState_STATUS_Enabled,
	"enabling":  WebApplicationFirewallPolicyProperties_ResourceState_STATUS_Enabling,
}

// Defines contents of a web application rule
type CustomRule struct {
	// +kubebuilder:validation:Required
	// Action: Describes what action to be applied when rule matches.
	Action *ActionType `json:"action,omitempty"`

	// EnabledState: Describes if the custom rule is in enabled or disabled state. Defaults to Enabled if not specified.
	EnabledState *CustomRule_EnabledState `json:"enabledState,omitempty"`

	// +kubebuilder:validation:Required
	// MatchConditions: List of match conditions.
	MatchConditions []MatchCondition `json:"matchConditions,omitempty"`

	// +kubebuilder:validation:MaxLength=128
	// Name: Describes the name of the rule.
	Name *string `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// Priority: Describes priority of the rule. Rules with a lower value will be evaluated before rules with a higher value.
	Priority *int `json:"priority,omitempty"`

	// +kubebuilder:validation:Maximum=5
	// +kubebuilder:validation:Minimum=0
	// RateLimitDurationInMinutes: Time window for resetting the rate limit count. Default is 1 minute.
	RateLimitDurationInMinutes *int `json:"rateLimitDurationInMinutes,omitempty"`

	// +kubebuilder:validation:Minimum=0
	// RateLimitThreshold: Number of allowed requests per client within the time window.
	RateLimitThreshold *int `json:"rateLimitThreshold,omitempty"`

	// +kubebuilder:validation:Required
	// RuleType: Describes type of rule.
	RuleType *CustomRule_RuleType `json:"ruleType,omitempty"`
}

var _ genruntime.ARMTransformer = &CustomRule{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (rule *CustomRule) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if rule == nil {
		return nil, nil
	}
	result := &arm.CustomRule{}

	// Set property "Action":
	if rule.Action != nil {
		var temp string
		temp = string(*rule.Action)
		action := arm.ActionType(temp)
		result.Action = &action
	}

	// Set property "EnabledState":
	if rule.EnabledState != nil {
		var temp string
		temp = string(*rule.EnabledState)
		enabledState := arm.CustomRule_EnabledState(temp)
		result.EnabledState = &enabledState
	}

	// Set property "MatchConditions":
	for _, item := range rule.MatchConditions {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.MatchConditions = append(result.MatchConditions, *item_ARM.(*arm.MatchCondition))
	}

	// Set property "Name":
	if rule.Name != nil {
		name := *rule.Name
		result.Name = &name
	}

	// Set property "Priority":
	if rule.Priority != nil {
		priority := *rule.Priority
		result.Priority = &priority
	}

	// Set property "RateLimitDurationInMinutes":
	if rule.RateLimitDurationInMinutes != nil {
		rateLimitDurationInMinutes := *rule.RateLimitDurationInMinutes
		result.RateLimitDurationInMinutes = &rateLimitDurationInMinutes
	}

	// Set property "RateLimitThreshold":
	if rule.RateLimitThreshold != nil {
		rateLimitThreshold := *rule.RateLimitThreshold
		result.RateLimitThreshold = &rateLimitThreshold
	}

	// Set property "RuleType":
	if rule.RuleType != nil {
		var temp string
		temp = string(*rule.RuleType)
		ruleType := arm.CustomRule_RuleType(temp)
		result.RuleType = &ruleType
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *CustomRule) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.CustomRule{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *CustomRule) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.CustomRule)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.CustomRule, got %T", armInput)
	}

	// Set property "Action":
	if typedInput.Action != nil {
		var temp string
		temp = string(*typedInput.Action)
		action := ActionType(temp)
		rule.Action = &action
	}

	// Set property "EnabledState":
	if typedInput.EnabledState != nil {
		var temp string
		temp = string(*typedInput.EnabledState)
		enabledState := CustomRule_EnabledState(temp)
		rule.EnabledState = &enabledState
	}

	// Set property "MatchConditions":
	for _, item := range typedInput.MatchConditions {
		var item1 MatchCondition
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		rule.MatchConditions = append(rule.MatchConditions, item1)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		rule.Name = &name
	}

	// Set property "Priority":
	if typedInput.Priority != nil {
		priority := *typedInput.Priority
		rule.Priority = &priority
	}

	// Set property "RateLimitDurationInMinutes":
	if typedInput.RateLimitDurationInMinutes != nil {
		rateLimitDurationInMinutes := *typedInput.RateLimitDurationInMinutes
		rule.RateLimitDurationInMinutes = &rateLimitDurationInMinutes
	}

	// Set property "RateLimitThreshold":
	if typedInput.RateLimitThreshold != nil {
		rateLimitThreshold := *typedInput.RateLimitThreshold
		rule.RateLimitThreshold = &rateLimitThreshold
	}

	// Set property "RuleType":
	if typedInput.RuleType != nil {
		var temp string
		temp = string(*typedInput.RuleType)
		ruleType := CustomRule_RuleType(temp)
		rule.RuleType = &ruleType
	}

	// No error
	return nil
}

// AssignProperties_From_CustomRule populates our CustomRule from the provided source CustomRule
func (rule *CustomRule) AssignProperties_From_CustomRule(source *storage.CustomRule) error {

	// Action
	if source.Action != nil {
		action := *source.Action
		actionTemp := genruntime.ToEnum(action, actionType_Values)
		rule.Action = &actionTemp
	} else {
		rule.Action = nil
	}

	// EnabledState
	if source.EnabledState != nil {
		enabledState := *source.EnabledState
		enabledStateTemp := genruntime.ToEnum(enabledState, customRule_EnabledState_Values)
		rule.EnabledState = &enabledStateTemp
	} else {
		rule.EnabledState = nil
	}

	// MatchConditions
	if source.MatchConditions != nil {
		matchConditionList := make([]MatchCondition, len(source.MatchConditions))
		for matchConditionIndex, matchConditionItem := range source.MatchConditions {
			// Shadow the loop variable to avoid aliasing
			matchConditionItem := matchConditionItem
			var matchCondition MatchCondition
			err := matchCondition.AssignProperties_From_MatchCondition(&matchConditionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_MatchCondition() to populate field MatchConditions")
			}
			matchConditionList[matchConditionIndex] = matchCondition
		}
		rule.MatchConditions = matchConditionList
	} else {
		rule.MatchConditions = nil
	}

	// Name
	if source.Name != nil {
		name := *source.Name
		rule.Name = &name
	} else {
		rule.Name = nil
	}

	// Priority
	rule.Priority = genruntime.ClonePointerToInt(source.Priority)

	// RateLimitDurationInMinutes
	if source.RateLimitDurationInMinutes != nil {
		rateLimitDurationInMinute := *source.RateLimitDurationInMinutes
		rule.RateLimitDurationInMinutes = &rateLimitDurationInMinute
	} else {
		rule.RateLimitDurationInMinutes = nil
	}

	// RateLimitThreshold
	if source.RateLimitThreshold != nil {
		rateLimitThreshold := *source.RateLimitThreshold
		rule.RateLimitThreshold = &rateLimitThreshold
	} else {
		rule.RateLimitThreshold = nil
	}

	// RuleType
	if source.RuleType != nil {
		ruleType := *source.RuleType
		ruleTypeTemp := genruntime.ToEnum(ruleType, customRule_RuleType_Values)
		rule.RuleType = &ruleTypeTemp
	} else {
		rule.RuleType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_CustomRule populates the provided destination CustomRule from our CustomRule
func (rule *CustomRule) AssignProperties_To_CustomRule(destination *storage.CustomRule) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Action
	if rule.Action != nil {
		action := string(*rule.Action)
		destination.Action = &action
	} else {
		destination.Action = nil
	}

	// EnabledState
	if rule.EnabledState != nil {
		enabledState := string(*rule.EnabledState)
		destination.EnabledState = &enabledState
	} else {
		destination.EnabledState = nil
	}

	// MatchConditions
	if rule.MatchConditions != nil {
		matchConditionList := make([]storage.MatchCondition, len(rule.MatchConditions))
		for matchConditionIndex, matchConditionItem := range rule.MatchConditions {
			// Shadow the loop variable to avoid aliasing
			matchConditionItem := matchConditionItem
			var matchCondition storage.MatchCondition
			err := matchConditionItem.AssignProperties_To_MatchCondition(&matchCondition)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_MatchCondition() to populate field MatchConditions")
			}
			matchConditionList[matchConditionIndex] = matchCondition
		}
		destination.MatchConditions = matchConditionList
	} else {
		destination.MatchConditions = nil
	}

	// Name
	if rule.Name != nil {
		name := *rule.Name
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Priority
	destination.Priority = genruntime.ClonePointerToInt(rule.Priority)

	// RateLimitDurationInMinutes
	if rule.RateLimitDurationInMinutes != nil {
		rateLimitDurationInMinute := *rule.RateLimitDurationInMinutes
		destination.RateLimitDurationInMinutes = &rateLimitDurationInMinute
	} else {
		destination.RateLimitDurationInMinutes = nil
	}

	// RateLimitThreshold
	if rule.RateLimitThreshold != nil {
		rateLimitThreshold := *rule.RateLimitThreshold
		destination.RateLimitThreshold = &rateLimitThreshold
	} else {
		destination.RateLimitThreshold = nil
	}

	// RuleType
	if rule.RuleType != nil {
		ruleType := string(*rule.RuleType)
		destination.RuleType = &ruleType
	} else {
		destination.RuleType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_CustomRule_STATUS populates our CustomRule from the provided source CustomRule_STATUS
func (rule *CustomRule) Initialize_From_CustomRule_STATUS(source *CustomRule_STATUS) error {

	// Action
	if source.Action != nil {
		action := genruntime.ToEnum(string(*source.Action), actionType_Values)
		rule.Action = &action
	} else {
		rule.Action = nil
	}

	// EnabledState
	if source.EnabledState != nil {
		enabledState := genruntime.ToEnum(string(*source.EnabledState), customRule_EnabledState_Values)
		rule.EnabledState = &enabledState
	} else {
		rule.EnabledState = nil
	}

	// MatchConditions
	if source.MatchConditions != nil {
		matchConditionList := make([]MatchCondition, len(source.MatchConditions))
		for matchConditionIndex, matchConditionItem := range source.MatchConditions {
			// Shadow the loop variable to avoid aliasing
			matchConditionItem := matchConditionItem
			var matchCondition MatchCondition
			err := matchCondition.Initialize_From_MatchCondition_STATUS(&matchConditionItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_MatchCondition_STATUS() to populate field MatchConditions")
			}
			matchConditionList[matchConditionIndex] = matchCondition
		}
		rule.MatchConditions = matchConditionList
	} else {
		rule.MatchConditions = nil
	}

	// Name
	if source.Name != nil {
		name := *source.Name
		rule.Name = &name
	} else {
		rule.Name = nil
	}

	// Priority
	rule.Priority = genruntime.ClonePointerToInt(source.Priority)

	// RateLimitDurationInMinutes
	if source.RateLimitDurationInMinutes != nil {
		rateLimitDurationInMinute := *source.RateLimitDurationInMinutes
		rule.RateLimitDurationInMinutes = &rateLimitDurationInMinute
	} else {
		rule.RateLimitDurationInMinutes = nil
	}

	// RateLimitThreshold
	if source.RateLimitThreshold != nil {
		rateLimitThreshold := *source.RateLimitThreshold
		rule.RateLimitThreshold = &rateLimitThreshold
	} else {
		rule.RateLimitThreshold = nil
	}

	// RuleType
	if source.RuleType != nil {
		ruleType := genruntime.ToEnum(string(*source.RuleType), customRule_RuleType_Values)
		rule.RuleType = &ruleType
	} else {
		rule.RuleType = nil
	}

	// No error
	return nil
}

// Defines contents of a web application rule
type CustomRule_STATUS struct {
	// Action: Describes what action to be applied when rule matches.
	Action *ActionType_STATUS `json:"action,omitempty"`

	// EnabledState: Describes if the custom rule is in enabled or disabled state. Defaults to Enabled if not specified.
	EnabledState *CustomRule_EnabledState_STATUS `json:"enabledState,omitempty"`

	// MatchConditions: List of match conditions.
	MatchConditions []MatchCondition_STATUS `json:"matchConditions,omitempty"`

	// Name: Describes the name of the rule.
	Name *string `json:"name,omitempty"`

	// Priority: Describes priority of the rule. Rules with a lower value will be evaluated before rules with a higher value.
	Priority *int `json:"priority,omitempty"`

	// RateLimitDurationInMinutes: Time window for resetting the rate limit count. Default is 1 minute.
	RateLimitDurationInMinutes *int `json:"rateLimitDurationInMinutes,omitempty"`

	// RateLimitThreshold: Number of allowed requests per client within the time window.
	RateLimitThreshold *int `json:"rateLimitThreshold,omitempty"`

	// RuleType: Describes type of rule.
	RuleType *CustomRule_RuleType_STATUS `json:"ruleType,omitempty"`
}

var _ genruntime.FromARMConverter = &CustomRule_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *CustomRule_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.CustomRule_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *CustomRule_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.CustomRule_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.CustomRule_STATUS, got %T", armInput)
	}

	// Set property "Action":
	if typedInput.Action != nil {
		var temp string
		temp = string(*typedInput.Action)
		action := ActionType_STATUS(temp)
		rule.Action = &action
	}

	// Set property "EnabledState":
	if typedInput.EnabledState != nil {
		var temp string
		temp = string(*typedInput.EnabledState)
		enabledState := CustomRule_EnabledState_STATUS(temp)
		rule.EnabledState = &enabledState
	}

	// Set property "MatchConditions":
	for _, item := range typedInput.MatchConditions {
		var item1 MatchCondition_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		rule.MatchConditions = append(rule.MatchConditions, item1)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		rule.Name = &name
	}

	// Set property "Priority":
	if typedInput.Priority != nil {
		priority := *typedInput.Priority
		rule.Priority = &priority
	}

	// Set property "RateLimitDurationInMinutes":
	if typedInput.RateLimitDurationInMinutes != nil {
		rateLimitDurationInMinutes := *typedInput.RateLimitDurationInMinutes
		rule.RateLimitDurationInMinutes = &rateLimitDurationInMinutes
	}

	// Set property "RateLimitThreshold":
	if typedInput.RateLimitThreshold != nil {
		rateLimitThreshold := *typedInput.RateLimitThreshold
		rule.RateLimitThreshold = &rateLimitThreshold
	}

	// Set property "RuleType":
	if typedInput.RuleType != nil {
		var temp string
		temp = string(*typedInput.RuleType)
		ruleType := CustomRule_RuleType_STATUS(temp)
		rule.RuleType = &ruleType
	}

	// No error
	return nil
}

// AssignProperties_From_CustomRule_STATUS populates our CustomRule_STATUS from the provided source CustomRule_STATUS
func (rule *CustomRule_STATUS) AssignProperties_From_CustomRule_STATUS(source *storage.CustomRule_STATUS) error {

	// Action
	if source.Action != nil {
		action := *source.Action
		actionTemp := genruntime.ToEnum(action, actionType_STATUS_Values)
		rule.Action = &actionTemp
	} else {
		rule.Action = nil
	}

	// EnabledState
	if source.EnabledState != nil {
		enabledState := *source.EnabledState
		enabledStateTemp := genruntime.ToEnum(enabledState, customRule_EnabledState_STATUS_Values)
		rule.EnabledState = &enabledStateTemp
	} else {
		rule.EnabledState = nil
	}

	// MatchConditions
	if source.MatchConditions != nil {
		matchConditionList := make([]MatchCondition_STATUS, len(source.MatchConditions))
		for matchConditionIndex, matchConditionItem := range source.MatchConditions {
			// Shadow the loop variable to avoid aliasing
			matchConditionItem := matchConditionItem
			var matchCondition MatchCondition_STATUS
			err := matchCondition.AssignProperties_From_MatchCondition_STATUS(&matchConditionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_MatchCondition_STATUS() to populate field MatchConditions")
			}
			matchConditionList[matchConditionIndex] = matchCondition
		}
		rule.MatchConditions = matchConditionList
	} else {
		rule.MatchConditions = nil
	}

	// Name
	rule.Name = genruntime.ClonePointerToString(source.Name)

	// Priority
	rule.Priority = genruntime.ClonePointerToInt(source.Priority)

	// RateLimitDurationInMinutes
	rule.RateLimitDurationInMinutes = genruntime.ClonePointerToInt(source.RateLimitDurationInMinutes)

	// RateLimitThreshold
	rule.RateLimitThreshold = genruntime.ClonePointerToInt(source.RateLimitThreshold)

	// RuleType
	if source.RuleType != nil {
		ruleType := *source.RuleType
		ruleTypeTemp := genruntime.ToEnum(ruleType, customRule_RuleType_STATUS_Values)
		rule.RuleType = &ruleTypeTemp
	} else {
		rule.RuleType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_CustomRule_STATUS populates the provided destination CustomRule_STATUS from our CustomRule_STATUS
func (rule *CustomRule_STATUS) AssignProperties_To_CustomRule_STATUS(destination *storage.CustomRule_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Action
	if rule.Action != nil {
		action := string(*rule.Action)
		destination.Action = &action
	} else {
		destination.Action = nil
	}

	// EnabledState
	if rule.EnabledState != nil {
		enabledState := string(*rule.EnabledState)
		destination.EnabledState = &enabledState
	} else {
		destination.EnabledState = nil
	}

	// MatchConditions
	if rule.MatchConditions != nil {
		matchConditionList := make([]storage.MatchCondition_STATUS, len(rule.MatchConditions))
		for matchConditionIndex, matchConditionItem := range rule.MatchConditions {
			// Shadow the loop variable to avoid aliasing
			matchConditionItem := matchConditionItem
			var matchCondition storage.MatchCondition_STATUS
			err := matchConditionItem.AssignProperties_To_MatchCondition_STATUS(&matchCondition)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_MatchCondition_STATUS() to populate field MatchConditions")
			}
			matchConditionList[matchConditionIndex] = matchCondition
		}
		destination.MatchConditions = matchConditionList
	} else {
		destination.MatchConditions = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(rule.Name)

	// Priority
	destination.Priority = genruntime.ClonePointerToInt(rule.Priority)

	// RateLimitDurationInMinutes
	destination.RateLimitDurationInMinutes = genruntime.ClonePointerToInt(rule.RateLimitDurationInMinutes)

	// RateLimitThreshold
	destination.RateLimitThreshold = genruntime.ClonePointerToInt(rule.RateLimitThreshold)

	// RuleType
	if rule.RuleType != nil {
		ruleType := string(*rule.RuleType)
		destination.RuleType = &ruleType
	} else {
		destination.RuleType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines a managed rule set.
type ManagedRuleSet struct {
	// Exclusions: Describes the exclusions that are applied to all rules in the set.
	Exclusions []ManagedRuleExclusion `json:"exclusions,omitempty"`

	// RuleGroupOverrides: Defines the rule group overrides to apply to the rule set.
	RuleGroupOverrides []ManagedRuleGroupOverride `json:"ruleGroupOverrides,omitempty"`

	// RuleSetAction: Defines the rule set action.
	RuleSetAction *ManagedRuleSetActionType `json:"ruleSetAction,omitempty"`

	// +kubebuilder:validation:Required
	// RuleSetType: Defines the rule set type to use.
	RuleSetType *string `json:"ruleSetType,omitempty"`

	// +kubebuilder:validation:Required
	// RuleSetVersion: Defines the version of the rule set to use.
	RuleSetVersion *string `json:"ruleSetVersion,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedRuleSet{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (ruleSet *ManagedRuleSet) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if ruleSet == nil {
		return nil, nil
	}
	result := &arm.ManagedRuleSet{}

	// Set property "Exclusions":
	for _, item := range ruleSet.Exclusions {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Exclusions = append(result.Exclusions, *item_ARM.(*arm.ManagedRuleExclusion))
	}

	// Set property "RuleGroupOverrides":
	for _, item := range ruleSet.RuleGroupOverrides {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.RuleGroupOverrides = append(result.RuleGroupOverrides, *item_ARM.(*arm.ManagedRuleGroupOverride))
	}

	// Set property "RuleSetAction":
	if ruleSet.RuleSetAction != nil {
		var temp string
		temp = string(*ruleSet.RuleSetAction)
		ruleSetAction := arm.ManagedRuleSetActionType(temp)
		result.RuleSetAction = &ruleSetAction
	}

	// Set property "RuleSetType":
	if ruleSet.RuleSetType != nil {
		ruleSetType := *ruleSet.RuleSetType
		result.RuleSetType = &ruleSetType
	}

	// Set property "RuleSetVersion":
	if ruleSet.RuleSetVersion != nil {
		ruleSetVersion := *ruleSet.RuleSetVersion
		result.RuleSetVersion = &ruleSetVersion
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (ruleSet *ManagedRuleSet) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedRuleSet{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (ruleSet *ManagedRuleSet) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedRuleSet)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedRuleSet, got %T", armInput)
	}

	// Set property "Exclusions":
	for _, item := range typedInput.Exclusions {
		var item1 ManagedRuleExclusion
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		ruleSet.Exclusions = append(ruleSet.Exclusions, item1)
	}

	// Set property "RuleGroupOverrides":
	for _, item := range typedInput.RuleGroupOverrides {
		var item1 ManagedRuleGroupOverride
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		ruleSet.RuleGroupOverrides = append(ruleSet.RuleGroupOverrides, item1)
	}

	// Set property "RuleSetAction":
	if typedInput.RuleSetAction != nil {
		var temp string
		temp = string(*typedInput.RuleSetAction)
		ruleSetAction := ManagedRuleSetActionType(temp)
		ruleSet.RuleSetAction = &ruleSetAction
	}

	// Set property "RuleSetType":
	if typedInput.RuleSetType != nil {
		ruleSetType := *typedInput.RuleSetType
		ruleSet.RuleSetType = &ruleSetType
	}

	// Set property "RuleSetVersion":
	if typedInput.RuleSetVersion != nil {
		ruleSetVersion := *typedInput.RuleSetVersion
		ruleSet.RuleSetVersion = &ruleSetVersion
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedRuleSet populates our ManagedRuleSet from the provided source ManagedRuleSet
func (ruleSet *ManagedRuleSet) AssignProperties_From_ManagedRuleSet(source *storage.ManagedRuleSet) error {

	// Exclusions
	if source.Exclusions != nil {
		exclusionList := make([]ManagedRuleExclusion, len(source.Exclusions))
		for exclusionIndex, exclusionItem := range source.Exclusions {
			// Shadow the loop variable to avoid aliasing
			exclusionItem := exclusionItem
			var exclusion ManagedRuleExclusion
			err := exclusion.AssignProperties_From_ManagedRuleExclusion(&exclusionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ManagedRuleExclusion() to populate field Exclusions")
			}
			exclusionList[exclusionIndex] = exclusion
		}
		ruleSet.Exclusions = exclusionList
	} else {
		ruleSet.Exclusions = nil
	}

	// RuleGroupOverrides
	if source.RuleGroupOverrides != nil {
		ruleGroupOverrideList := make([]ManagedRuleGroupOverride, len(source.RuleGroupOverrides))
		for ruleGroupOverrideIndex, ruleGroupOverrideItem := range source.RuleGroupOverrides {
			// Shadow the loop variable to avoid aliasing
			ruleGroupOverrideItem := ruleGroupOverrideItem
			var ruleGroupOverride ManagedRuleGroupOverride
			err := ruleGroupOverride.AssignProperties_From_ManagedRuleGroupOverride(&ruleGroupOverrideItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ManagedRuleGroupOverride() to populate field RuleGroupOverrides")
			}
			ruleGroupOverrideList[ruleGroupOverrideIndex] = ruleGroupOverride
		}
		ruleSet.RuleGroupOverrides = ruleGroupOverrideList
	} else {
		ruleSet.RuleGroupOverrides = nil
	}

	// RuleSetAction
	if source.RuleSetAction != nil {
		ruleSetAction := *source.RuleSetAction
		ruleSetActionTemp := genruntime.ToEnum(ruleSetAction, managedRuleSetActionType_Values)
		ruleSet.RuleSetAction = &ruleSetActionTemp
	} else {
		ruleSet.RuleSetAction = nil
	}

	// RuleSetType
	ruleSet.RuleSetType = genruntime.ClonePointerToString(source.RuleSetType)

	// RuleSetVersion
	ruleSet.RuleSetVersion = genruntime.ClonePointerToString(source.RuleSetVersion)

	// No error
	return nil
}

// AssignProperties_To_ManagedRuleSet populates the provided destination ManagedRuleSet from our ManagedRuleSet
func (ruleSet *ManagedRuleSet) AssignProperties_To_ManagedRuleSet(destination *storage.ManagedRuleSet) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Exclusions
	if ruleSet.Exclusions != nil {
		exclusionList := make([]storage.ManagedRuleExclusion, len(ruleSet.Exclusions))
		for exclusionIndex, exclusionItem := range ruleSet.Exclusions {
			// Shadow the loop variable to avoid aliasing
			exclusionItem := exclusionItem
			var exclusion storage.ManagedRuleExclusion
			err := exclusionItem.AssignProperties_To_ManagedRuleExclusion(&exclusion)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ManagedRuleExclusion() to populate field Exclusions")
			}
			exclusionList[exclusionIndex] = exclusion
		}
		destination.Exclusions = exclusionList
	} else {
		destination.Exclusions = nil
	}

	// RuleGroupOverrides
	if ruleSet.RuleGroupOverrides != nil {
		ruleGroupOverrideList := make([]storage.ManagedRuleGroupOverride, len(ruleSet.RuleGroupOverrides))
		for ruleGroupOverrideIndex, ruleGroupOverrideItem := range ruleSet.RuleGroupOverrides {
			// Shadow the loop variable to avoid aliasing
			ruleGroupOverrideItem := ruleGroupOverrideItem
			var ruleGroupOverride storage.ManagedRuleGroupOverride
			err := ruleGroupOverrideItem.AssignProperties_To_ManagedRuleGroupOverride(&ruleGroupOverride)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ManagedRuleGroupOverride() to populate field RuleGroupOverrides")
			}
			ruleGroupOverrideList[ruleGroupOverrideIndex] = ruleGroupOverride
		}
		destination.RuleGroupOverrides = ruleGroupOverrideList
	} else {
		destination.RuleGroupOverrides = nil
	}

	// RuleSetAction
	if ruleSet.RuleSetAction != nil {
		ruleSetAction := string(*ruleSet.RuleSetAction)
		destination.RuleSetAction = &ruleSetAction
	} else {
		destination.RuleSetAction = nil
	}

	// RuleSetType
	destination.RuleSetType = genruntime.ClonePointerToString(ruleSet.RuleSetType)

	// RuleSetVersion
	destination.RuleSetVersion = genruntime.ClonePointerToString(ruleSet.RuleSetVersion)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ManagedRuleSet_STATUS populates our ManagedRuleSet from the provided source ManagedRuleSet_STATUS
func (ruleSet *ManagedRuleSet) Initialize_From_ManagedRuleSet_STATUS(source *ManagedRuleSet_STATUS) error {

	// Exclusions
	if source.Exclusions != nil {
		exclusionList := make([]ManagedRuleExclusion, len(source.Exclusions))
		for exclusionIndex, exclusionItem := range source.Exclusions {
			// Shadow the loop variable to avoid aliasing
			exclusionItem := exclusionItem
			var exclusion ManagedRuleExclusion
			err := exclusion.Initialize_From_ManagedRuleExclusion_STATUS(&exclusionItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_ManagedRuleExclusion_STATUS() to populate field Exclusions")
			}
			exclusionList[exclusionIndex] = exclusion
		}
		ruleSet.Exclusions = exclusionList
	} else {
		ruleSet.Exclusions = nil
	}

	// RuleGroupOverrides
	if source.RuleGroupOverrides != nil {
		ruleGroupOverrideList := make([]ManagedRuleGroupOverride, len(source.RuleGroupOverrides))
		for ruleGroupOverrideIndex, ruleGroupOverrideItem := range source.RuleGroupOverrides {
			// Shadow the loop variable to avoid aliasing
			ruleGroupOverrideItem := ruleGroupOverrideItem
			var ruleGroupOverride ManagedRuleGroupOverride
			err := ruleGroupOverride.Initialize_From_ManagedRuleGroupOverride_STATUS(&ruleGroupOverrideItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_ManagedRuleGroupOverride_STATUS() to populate field RuleGroupOverrides")
			}
			ruleGroupOverrideList[ruleGroupOverrideIndex] = ruleGroupOverride
		}
		ruleSet.RuleGroupOverrides = ruleGroupOverrideList
	} else {
		ruleSet.RuleGroupOverrides = nil
	}

	// RuleSetAction
	if source.RuleSetAction != nil {
		ruleSetAction := genruntime.ToEnum(string(*source.RuleSetAction), managedRuleSetActionType_Values)
		ruleSet.RuleSetAction = &ruleSetAction
	} else {
		ruleSet.RuleSetAction = nil
	}

	// RuleSetType
	ruleSet.RuleSetType = genruntime.ClonePointerToString(source.RuleSetType)

	// RuleSetVersion
	ruleSet.RuleSetVersion = genruntime.ClonePointerToString(source.RuleSetVersion)

	// No error
	return nil
}

// Defines a managed rule set.
type ManagedRuleSet_STATUS struct {
	// Exclusions: Describes the exclusions that are applied to all rules in the set.
	Exclusions []ManagedRuleExclusion_STATUS `json:"exclusions,omitempty"`

	// RuleGroupOverrides: Defines the rule group overrides to apply to the rule set.
	RuleGroupOverrides []ManagedRuleGroupOverride_STATUS `json:"ruleGroupOverrides,omitempty"`

	// RuleSetAction: Defines the rule set action.
	RuleSetAction *ManagedRuleSetActionType_STATUS `json:"ruleSetAction,omitempty"`

	// RuleSetType: Defines the rule set type to use.
	RuleSetType *string `json:"ruleSetType,omitempty"`

	// RuleSetVersion: Defines the version of the rule set to use.
	RuleSetVersion *string `json:"ruleSetVersion,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedRuleSet_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (ruleSet *ManagedRuleSet_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedRuleSet_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (ruleSet *ManagedRuleSet_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedRuleSet_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedRuleSet_STATUS, got %T", armInput)
	}

	// Set property "Exclusions":
	for _, item := range typedInput.Exclusions {
		var item1 ManagedRuleExclusion_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		ruleSet.Exclusions = append(ruleSet.Exclusions, item1)
	}

	// Set property "RuleGroupOverrides":
	for _, item := range typedInput.RuleGroupOverrides {
		var item1 ManagedRuleGroupOverride_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		ruleSet.RuleGroupOverrides = append(ruleSet.RuleGroupOverrides, item1)
	}

	// Set property "RuleSetAction":
	if typedInput.RuleSetAction != nil {
		var temp string
		temp = string(*typedInput.RuleSetAction)
		ruleSetAction := ManagedRuleSetActionType_STATUS(temp)
		ruleSet.RuleSetAction = &ruleSetAction
	}

	// Set property "RuleSetType":
	if typedInput.RuleSetType != nil {
		ruleSetType := *typedInput.RuleSetType
		ruleSet.RuleSetType = &ruleSetType
	}

	// Set property "RuleSetVersion":
	if typedInput.RuleSetVersion != nil {
		ruleSetVersion := *typedInput.RuleSetVersion
		ruleSet.RuleSetVersion = &ruleSetVersion
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedRuleSet_STATUS populates our ManagedRuleSet_STATUS from the provided source ManagedRuleSet_STATUS
func (ruleSet *ManagedRuleSet_STATUS) AssignProperties_From_ManagedRuleSet_STATUS(source *storage.ManagedRuleSet_STATUS) error {

	// Exclusions
	if source.Exclusions != nil {
		exclusionList := make([]ManagedRuleExclusion_STATUS, len(source.Exclusions))
		for exclusionIndex, exclusionItem := range source.Exclusions {
			// Shadow the loop variable to avoid aliasing
			exclusionItem := exclusionItem
			var exclusion ManagedRuleExclusion_STATUS
			err := exclusion.AssignProperties_From_ManagedRuleExclusion_STATUS(&exclusionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ManagedRuleExclusion_STATUS() to populate field Exclusions")
			}
			exclusionList[exclusionIndex] = exclusion
		}
		ruleSet.Exclusions = exclusionList
	} else {
		ruleSet.Exclusions = nil
	}

	// RuleGroupOverrides
	if source.RuleGroupOverrides != nil {
		ruleGroupOverrideList := make([]ManagedRuleGroupOverride_STATUS, len(source.RuleGroupOverrides))
		for ruleGroupOverrideIndex, ruleGroupOverrideItem := range source.RuleGroupOverrides {
			// Shadow the loop variable to avoid aliasing
			ruleGroupOverrideItem := ruleGroupOverrideItem
			var ruleGroupOverride ManagedRuleGroupOverride_STATUS
			err := ruleGroupOverride.AssignProperties_From_ManagedRuleGroupOverride_STATUS(&ruleGroupOverrideItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ManagedRuleGroupOverride_STATUS() to populate field RuleGroupOverrides")
			}
			ruleGroupOverrideList[ruleGroupOverrideIndex] = ruleGroupOverride
		}
		ruleSet.RuleGroupOverrides = ruleGroupOverrideList
	} else {
		ruleSet.RuleGroupOverrides = nil
	}

	// RuleSetAction
	if source.RuleSetAction != nil {
		ruleSetAction := *source.RuleSetAction
		ruleSetActionTemp := genruntime.ToEnum(ruleSetAction, managedRuleSetActionType_STATUS_Values)
		ruleSet.RuleSetAction = &ruleSetActionTemp
	} else {
		ruleSet.RuleSetAction = nil
	}

	// RuleSetType
	ruleSet.RuleSetType = genruntime.ClonePointerToString(source.RuleSetType)

	// RuleSetVersion
	ruleSet.RuleSetVersion = genruntime.ClonePointerToString(source.RuleSetVersion)

	// No error
	return nil
}

// AssignProperties_To_ManagedRuleSet_STATUS populates the provided destination ManagedRuleSet_STATUS from our ManagedRuleSet_STATUS
func (ruleSet *ManagedRuleSet_STATUS) AssignProperties_To_ManagedRuleSet_STATUS(destination *storage.ManagedRuleSet_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Exclusions
	if ruleSet.Exclusions != nil {
		exclusionList := make([]storage.ManagedRuleExclusion_STATUS, len(ruleSet.Exclusions))
		for exclusionIndex, exclusionItem := range ruleSet.Exclusions {
			// Shadow the loop variable to avoid aliasing
			exclusionItem := exclusionItem
			var exclusion storage.ManagedRuleExclusion_STATUS
			err := exclusionItem.AssignProperties_To_ManagedRuleExclusion_STATUS(&exclusion)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ManagedRuleExclusion_STATUS() to populate field Exclusions")
			}
			exclusionList[exclusionIndex] = exclusion
		}
		destination.Exclusions = exclusionList
	} else {
		destination.Exclusions = nil
	}

	// RuleGroupOverrides
	if ruleSet.RuleGroupOverrides != nil {
		ruleGroupOverrideList := make([]storage.ManagedRuleGroupOverride_STATUS, len(ruleSet.RuleGroupOverrides))
		for ruleGroupOverrideIndex, ruleGroupOverrideItem := range ruleSet.RuleGroupOverrides {
			// Shadow the loop variable to avoid aliasing
			ruleGroupOverrideItem := ruleGroupOverrideItem
			var ruleGroupOverride storage.ManagedRuleGroupOverride_STATUS
			err := ruleGroupOverrideItem.AssignProperties_To_ManagedRuleGroupOverride_STATUS(&ruleGroupOverride)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ManagedRuleGroupOverride_STATUS() to populate field RuleGroupOverrides")
			}
			ruleGroupOverrideList[ruleGroupOverrideIndex] = ruleGroupOverride
		}
		destination.RuleGroupOverrides = ruleGroupOverrideList
	} else {
		destination.RuleGroupOverrides = nil
	}

	// RuleSetAction
	if ruleSet.RuleSetAction != nil {
		ruleSetAction := string(*ruleSet.RuleSetAction)
		destination.RuleSetAction = &ruleSetAction
	} else {
		destination.RuleSetAction = nil
	}

	// RuleSetType
	destination.RuleSetType = genruntime.ClonePointerToString(ruleSet.RuleSetType)

	// RuleSetVersion
	destination.RuleSetVersion = genruntime.ClonePointerToString(ruleSet.RuleSetVersion)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Disabled","Enabled"}
type PolicySettings_EnabledState string

const (
	PolicySettings_EnabledState_Disabled = PolicySettings_EnabledState("Disabled")
	PolicySettings_EnabledState_Enabled  = PolicySettings_EnabledState("Enabled")
)

// Mapping from string to PolicySettings_EnabledState
var policySettings_EnabledState_Values = map[string]PolicySettings_EnabledState{
	"disabled": PolicySettings_EnabledState_Disabled,
	"enabled":  PolicySettings_EnabledState_Enabled,
}

type PolicySettings_EnabledState_STATUS string

const (
	PolicySettings_EnabledState_STATUS_Disabled = PolicySettings_EnabledState_STATUS("Disabled")
	PolicySettings_EnabledState_STATUS_Enabled  = PolicySettings_EnabledState_STATUS("Enabled")
)

// Mapping from string to PolicySettings_EnabledState_STATUS
var policySettings_EnabledState_STATUS_Values = map[string]PolicySettings_EnabledState_STATUS{
	"disabled": PolicySettings_EnabledState_STATUS_Disabled,
	"enabled":  PolicySettings_EnabledState_STATUS_Enabled,
}

// +kubebuilder:validation:Enum={"Detection","Prevention"}
type PolicySettings_Mode string

const (
	PolicySettings_Mode_Detection  = PolicySettings_Mode("Detection")
	PolicySettings_Mode_Prevention = PolicySettings_Mode("Prevention")
)

// Mapping from string to PolicySettings_Mode
var policySettings_Mode_Values = map[string]PolicySettings_Mode{
	"detection":  PolicySettings_Mode_Detection,
	"prevention": PolicySettings_Mode_Prevention,
}

type PolicySettings_Mode_STATUS string

const (
	PolicySettings_Mode_STATUS_Detection  = PolicySettings_Mode_STATUS("Detection")
	PolicySettings_Mode_STATUS_Prevention = PolicySettings_Mode_STATUS("Prevention")
)

// Mapping from string to PolicySettings_Mode_STATUS
var policySettings_Mode_STATUS_Values = map[string]PolicySettings_Mode_STATUS{
	"detection":  PolicySettings_Mode_STATUS_Detection,
	"prevention": PolicySettings_Mode_STATUS_Prevention,
}

// +kubebuilder:validation:Enum={"Disabled","Enabled"}
type PolicySettings_RequestBodyCheck string

const (
	PolicySettings_RequestBodyCheck_Disabled = PolicySettings_RequestBodyCheck("Disabled")
	PolicySettings_RequestBodyCheck_Enabled  = PolicySettings_RequestBodyCheck("Enabled")
)

// Mapping from string to PolicySettings_RequestBodyCheck
var policySettings_RequestBodyCheck_Values = map[string]PolicySettings_RequestBodyCheck{
	"disabled": PolicySettings_RequestBodyCheck_Disabled,
	"enabled":  PolicySettings_RequestBodyCheck_Enabled,
}

type PolicySettings_RequestBodyCheck_STATUS string

const (
	PolicySettings_RequestBodyCheck_STATUS_Disabled = PolicySettings_RequestBodyCheck_STATUS("Disabled")
	PolicySettings_RequestBodyCheck_STATUS_Enabled  = PolicySettings_RequestBodyCheck_STATUS("Enabled")
)

// Mapping from string to PolicySettings_RequestBodyCheck_STATUS
var policySettings_RequestBodyCheck_STATUS_Values = map[string]PolicySettings_RequestBodyCheck_STATUS{
	"disabled": PolicySettings_RequestBodyCheck_STATUS_Disabled,
	"enabled":  PolicySettings_RequestBodyCheck_STATUS_Enabled,
}

// +kubebuilder:validation:Enum={"Classic_AzureFrontDoor","Premium_AzureFrontDoor","Standard_AzureFrontDoor"}
type Sku_Name string

const (
	Sku_Name_Classic_AzureFrontDoor  = Sku_Name("Classic_AzureFrontDoor")
	Sku_Name_Premium_AzureFrontDoor  = Sku_Name("Premium_AzureFrontDoor")
	Sku_Name_Standard_AzureFrontDoor = Sku_Name("Standard_AzureFrontDoor")
)

// Mapping from string to Sku_Name
var sku_Name_Values = map[string]Sku_Name{
	"classic_azurefrontdoor":  Sku_Name_Classic_AzureFrontDoor,
	"premium_azurefrontdoor":  Sku_Name_Premium_AzureFrontDoor,
	"standard_azurefrontdoor": Sku_Name_Standard_AzureFrontDoor,
}

type Sku_Name_STATUS string

const (
	Sku_Name_STATUS_Classic_AzureFrontDoor  = Sku_Name_STATUS("Classic_AzureFrontDoor")
	Sku_Name_STATUS_Premium_AzureFrontDoor  = Sku_Name_STATUS("Premium_AzureFrontDoor")
	Sku_Name_STATUS_Standard_AzureFrontDoor = Sku_Name_STATUS("Standard_AzureFrontDoor")
)

// Mapping from string to Sku_Name_STATUS
var sku_Name_STATUS_Values = map[string]Sku_Name_STATUS{
	"classic_azurefrontdoor":  Sku_Name_STATUS_Classic_AzureFrontDoor,
	"premium_azurefrontdoor":  Sku_Name_STATUS_Premium_AzureFrontDoor,
	"standard_azurefrontdoor": Sku_Name_STATUS_Standard_AzureFrontDoor,
}

// Defines the action to take on rule match.
// +kubebuilder:validation:Enum={"Allow","AnomalyScoring","Block","Log","Redirect"}
type ActionType string

const (
	ActionType_Allow          = ActionType("Allow")
	ActionType_AnomalyScoring = ActionType("AnomalyScoring")
	ActionType_Block          = ActionType("Block")
	ActionType_Log            = ActionType("Log")
	ActionType_Redirect       = ActionType("Redirect")
)

// Mapping from string to ActionType
var actionType_Values = map[string]ActionType{
	"allow":          ActionType_Allow,
	"anomalyscoring": ActionType_AnomalyScoring,
	"block":          ActionType_Block,
	"log":            ActionType_Log,
	"redirect":       ActionType_Redirect,
}

// Defines the action to take on rule match.
type ActionType_STATUS string

const (
	ActionType_STATUS_Allow          = ActionType_STATUS("Allow")
	ActionType_STATUS_AnomalyScoring = ActionType_STATUS("AnomalyScoring")
	ActionType_STATUS_Block          = ActionType_STATUS("Block")
	ActionType_STATUS_Log            = ActionType_STATUS("Log")
	ActionType_STATUS_Redirect       = ActionType_STATUS("Redirect")
)

// Mapping from string to ActionType_STATUS
var actionType_STATUS_Values = map[string]ActionType_STATUS{
	"allow":          ActionType_STATUS_Allow,
	"anomalyscoring": ActionType_STATUS_AnomalyScoring,
	"block":          ActionType_STATUS_Block,
	"log":            ActionType_STATUS_Log,
	"redirect":       ActionType_STATUS_Redirect,
}

// +kubebuilder:validation:Enum={"Disabled","Enabled"}
type CustomRule_EnabledState string

const (
	CustomRule_EnabledState_Disabled = CustomRule_EnabledState("Disabled")
	CustomRule_EnabledState_Enabled  = CustomRule_EnabledState("Enabled")
)

// Mapping from string to CustomRule_EnabledState
var customRule_EnabledState_Values = map[string]CustomRule_EnabledState{
	"disabled": CustomRule_EnabledState_Disabled,
	"enabled":  CustomRule_EnabledState_Enabled,
}

type CustomRule_EnabledState_STATUS string

const (
	CustomRule_EnabledState_STATUS_Disabled = CustomRule_EnabledState_STATUS("Disabled")
	CustomRule_EnabledState_STATUS_Enabled  = CustomRule_EnabledState_STATUS("Enabled")
)

// Mapping from string to CustomRule_EnabledState_STATUS
var customRule_EnabledState_STATUS_Values = map[string]CustomRule_EnabledState_STATUS{
	"disabled": CustomRule_EnabledState_STATUS_Disabled,
	"enabled":  CustomRule_EnabledState_STATUS_Enabled,
}

// +kubebuilder:validation:Enum={"MatchRule","RateLimitRule"}
type CustomRule_RuleType string

const (
	CustomRule_RuleType_MatchRule     = CustomRule_RuleType("MatchRule")
	CustomRule_RuleType_RateLimitRule = CustomRule_RuleType("RateLimitRule")
)

// Mapping from string to CustomRule_RuleType
var customRule_RuleType_Values = map[string]CustomRule_RuleType{
	"matchrule":     CustomRule_RuleType_MatchRule,
	"ratelimitrule": CustomRule_RuleType_RateLimitRule,
}

type CustomRule_RuleType_STATUS string

const (
	CustomRule_RuleType_STATUS_MatchRule     = CustomRule_RuleType_STATUS("MatchRule")
	CustomRule_RuleType_STATUS_RateLimitRule = CustomRule_RuleType_STATUS("RateLimitRule")
)

// Mapping from string to CustomRule_RuleType_STATUS
var customRule_RuleType_STATUS_Values = map[string]CustomRule_RuleType_STATUS{
	"matchrule":     CustomRule_RuleType_STATUS_MatchRule,
	"ratelimitrule": CustomRule_RuleType_STATUS_RateLimitRule,
}

// Exclude variables from managed rule evaluation.
type ManagedRuleExclusion struct {
	// +kubebuilder:validation:Required
	// MatchVariable: The variable type to be excluded.
	MatchVariable *ManagedRuleExclusion_MatchVariable `json:"matchVariable,omitempty"`

	// +kubebuilder:validation:Required
	// Selector: Selector value for which elements in the collection this exclusion applies to.
	Selector *string `json:"selector,omitempty"`

	// +kubebuilder:validation:Required
	// SelectorMatchOperator: Comparison operator to apply to the selector when specifying which elements in the collection
	// this exclusion applies to.
	SelectorMatchOperator *ManagedRuleExclusion_SelectorMatchOperator `json:"selectorMatchOperator,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedRuleExclusion{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (exclusion *ManagedRuleExclusion) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if exclusion == nil {
		return nil, nil
	}
	result := &arm.ManagedRuleExclusion{}

	// Set property "MatchVariable":
	if exclusion.MatchVariable != nil {
		var temp string
		temp = string(*exclusion.MatchVariable)
		matchVariable := arm.ManagedRuleExclusion_MatchVariable(temp)
		result.MatchVariable = &matchVariable
	}

	// Set property "Selector":
	if exclusion.Selector != nil {
		selector := *exclusion.Selector
		result.Selector = &selector
	}

	// Set property "SelectorMatchOperator":
	if exclusion.SelectorMatchOperator != nil {
		var temp string
		temp = string(*exclusion.SelectorMatchOperator)
		selectorMatchOperator := arm.ManagedRuleExclusion_SelectorMatchOperator(temp)
		result.SelectorMatchOperator = &selectorMatchOperator
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (exclusion *ManagedRuleExclusion) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedRuleExclusion{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (exclusion *ManagedRuleExclusion) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedRuleExclusion)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedRuleExclusion, got %T", armInput)
	}

	// Set property "MatchVariable":
	if typedInput.MatchVariable != nil {
		var temp string
		temp = string(*typedInput.MatchVariable)
		matchVariable := ManagedRuleExclusion_MatchVariable(temp)
		exclusion.MatchVariable = &matchVariable
	}

	// Set property "Selector":
	if typedInput.Selector != nil {
		selector := *typedInput.Selector
		exclusion.Selector = &selector
	}

	// Set property "SelectorMatchOperator":
	if typedInput.SelectorMatchOperator != nil {
		var temp string
		temp = string(*typedInput.SelectorMatchOperator)
		selectorMatchOperator := ManagedRuleExclusion_SelectorMatchOperator(temp)
		exclusion.SelectorMatchOperator = &selectorMatchOperator
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedRuleExclusion populates our ManagedRuleExclusion from the provided source ManagedRuleExclusion
func (exclusion *ManagedRuleExclusion) AssignProperties_From_ManagedRuleExclusion(source *storage.ManagedRuleExclusion) error {

	// MatchVariable
	if source.MatchVariable != nil {
		matchVariable := *source.MatchVariable
		matchVariableTemp := genruntime.ToEnum(matchVariable, managedRuleExclusion_MatchVariable_Values)
		exclusion.MatchVariable = &matchVariableTemp
	} else {
		exclusion.MatchVariable = nil
	}

	// Selector
	exclusion.Selector = genruntime.ClonePointerToString(source.Selector)

	// SelectorMatchOperator
	if source.SelectorMatchOperator != nil {
		selectorMatchOperator := *source.SelectorMatchOperator
		selectorMatchOperatorTemp := genruntime.ToEnum(selectorMatchOperator, managedRuleExclusion_SelectorMatchOperator_Values)
		exclusion.SelectorMatchOperator = &selectorMatchOperatorTemp
	} else {
		exclusion.SelectorMatchOperator = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedRuleExclusion populates the provided destination ManagedRuleExclusion from our ManagedRuleExclusion
func (exclusion *ManagedRuleExclusion) AssignProperties_To_ManagedRuleExclusion(destination *storage.ManagedRuleExclusion) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchVariable
	if exclusion.MatchVariable != nil {
		matchVariable := string(*exclusion.MatchVariable)
		destination.MatchVariable = &matchVariable
	} else {
		destination.MatchVariable = nil
	}

	// Selector
	destination.Selector = genruntime.ClonePointerToString(exclusion.Selector)

	// SelectorMatchOperator
	if exclusion.SelectorMatchOperator != nil {
		selectorMatchOperator := string(*exclusion.SelectorMatchOperator)
		destination.SelectorMatchOperator = &selectorMatchOperator
	} else {
		destination.SelectorMatchOperator = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ManagedRuleExclusion_STATUS populates our ManagedRuleExclusion from the provided source ManagedRuleExclusion_STATUS
func (exclusion *ManagedRuleExclusion) Initialize_From_ManagedRuleExclusion_STATUS(source *ManagedRuleExclusion_STATUS) error {

	// MatchVariable
	if source.MatchVariable != nil {
		matchVariable := genruntime.ToEnum(string(*source.MatchVariable), managedRuleExclusion_MatchVariable_Values)
		exclusion.MatchVariable = &matchVariable
	} else {
		exclusion.MatchVariable = nil
	}

	// Selector
	exclusion.Selector = genruntime.ClonePointerToString(source.Selector)

	// SelectorMatchOperator
	if source.SelectorMatchOperator != nil {
		selectorMatchOperator := genruntime.ToEnum(string(*source.SelectorMatchOperator), managedRuleExclusion_SelectorMatchOperator_Values)
		exclusion.SelectorMatchOperator = &selectorMatchOperator
	} else {
		exclusion.SelectorMatchOperator = nil
	}

	// No error
	return nil
}

// Exclude variables from managed rule evaluation.
type ManagedRuleExclusion_STATUS struct {
	// MatchVariable: The variable type to be excluded.
	MatchVariable *ManagedRuleExclusion_MatchVariable_STATUS `json:"matchVariable,omitempty"`

	// Selector: Selector value for which elements in the collection this exclusion applies to.
	Selector *string `json:"selector,omitempty"`

	// SelectorMatchOperator: Comparison operator to apply to the selector when specifying which elements in the collection
	// this exclusion applies to.
	SelectorMatchOperator *ManagedRuleExclusion_SelectorMatchOperator_STATUS `json:"selectorMatchOperator,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedRuleExclusion_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (exclusion *ManagedRuleExclusion_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedRuleExclusion_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (exclusion *ManagedRuleExclusion_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedRuleExclusion_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedRuleExclusion_STATUS, got %T", armInput)
	}

	// Set property "MatchVariable":
	if typedInput.MatchVariable != nil {
		var temp string
		temp = string(*typedInput.MatchVariable)
		matchVariable := ManagedRuleExclusion_MatchVariable_STATUS(temp)
		exclusion.MatchVariable = &matchVariable
	}

	// Set property "Selector":
	if typedInput.Selector != nil {
		selector := *typedInput.Selector
		exclusion.Selector = &selector
	}

	// Set property "SelectorMatchOperator":
	if typedInput.SelectorMatchOperator != nil {
		var temp string
		temp = string(*typedInput.SelectorMatchOperator)
		selectorMatchOperator := ManagedRuleExclusion_SelectorMatchOperator_STATUS(temp)
		exclusion.SelectorMatchOperator = &selectorMatchOperator
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedRuleExclusion_STATUS populates our ManagedRuleExclusion_STATUS from the provided source ManagedRuleExclusion_STATUS
func (exclusion *ManagedRuleExclusion_STATUS) AssignProperties_From_ManagedRuleExclusion_STATUS(source *storage.ManagedRuleExclusion_STATUS) error {

	// MatchVariable
	if source.MatchVariable != nil {
		matchVariable := *source.MatchVariable
		matchVariableTemp := genruntime.ToEnum(matchVariable, managedRuleExclusion_MatchVariable_STATUS_Values)
		exclusion.MatchVariable = &matchVariableTemp
	} else {
		exclusion.MatchVariable = nil
	}

	// Selector
	exclusion.Selector = genruntime.ClonePointerToString(source.Selector)

	// SelectorMatchOperator
	if source.SelectorMatchOperator != nil {
		selectorMatchOperator := *source.SelectorMatchOperator
		selectorMatchOperatorTemp := genruntime.ToEnum(selectorMatchOperator, managedRuleExclusion_SelectorMatchOperator_STATUS_Values)
		exclusion.SelectorMatchOperator = &selectorMatchOperatorTemp
	} else {
		exclusion.SelectorMatchOperator = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedRuleExclusion_STATUS populates the provided destination ManagedRuleExclusion_STATUS from our ManagedRuleExclusion_STATUS
func (exclusion *ManagedRuleExclusion_STATUS) AssignProperties_To_ManagedRuleExclusion_STATUS(destination *storage.ManagedRuleExclusion_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchVariable
	if exclusion.MatchVariable != nil {
		matchVariable := string(*exclusion.MatchVariable)
		destination.MatchVariable = &matchVariable
	} else {
		destination.MatchVariable = nil
	}

	// Selector
	destination.Selector = genruntime.ClonePointerToString(exclusion.Selector)

	// SelectorMatchOperator
	if exclusion.SelectorMatchOperator != nil {
		selectorMatchOperator := string(*exclusion.SelectorMatchOperator)
		destination.SelectorMatchOperator = &selectorMatchOperator
	} else {
		destination.SelectorMatchOperator = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines a managed rule group override setting.
type ManagedRuleGroupOverride struct {
	// Exclusions: Describes the exclusions that are applied to all rules in the group.
	Exclusions []ManagedRuleExclusion `json:"exclusions,omitempty"`

	// +kubebuilder:validation:Required
	// RuleGroupName: Describes the managed rule group to override.
	RuleGroupName *string `json:"ruleGroupName,omitempty"`

	// Rules: List of rules that will be disabled. If none specified, all rules in the group will be disabled.
	Rules []ManagedRuleOverride `json:"rules,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedRuleGroupOverride{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (override *ManagedRuleGroupOverride) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if override == nil {
		return nil, nil
	}
	result := &arm.ManagedRuleGroupOverride{}

	// Set property "Exclusions":
	for _, item := range override.Exclusions {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Exclusions = append(result.Exclusions, *item_ARM.(*arm.ManagedRuleExclusion))
	}

	// Set property "RuleGroupName":
	if override.RuleGroupName != nil {
		ruleGroupName := *override.RuleGroupName
		result.RuleGroupName = &ruleGroupName
	}

	// Set property "Rules":
	for _, item := range override.Rules {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Rules = append(result.Rules, *item_ARM.(*arm.ManagedRuleOverride))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (override *ManagedRuleGroupOverride) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedRuleGroupOverride{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (override *ManagedRuleGroupOverride) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedRuleGroupOverride)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedRuleGroupOverride, got %T", armInput)
	}

	// Set property "Exclusions":
	for _, item := range typedInput.Exclusions {
		var item1 ManagedRuleExclusion
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		override.Exclusions = append(override.Exclusions, item1)
	}

	// Set property "RuleGroupName":
	if typedInput.RuleGroupName != nil {
		ruleGroupName := *typedInput.RuleGroupName
		override.RuleGroupName = &ruleGroupName
	}

	// Set property "Rules":
	for _, item := range typedInput.Rules {
		var item1 ManagedRuleOverride
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		override.Rules = append(override.Rules, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedRuleGroupOverride populates our ManagedRuleGroupOverride from the provided source ManagedRuleGroupOverride
func (override *ManagedRuleGroupOverride) AssignProperties_From_ManagedRuleGroupOverride(source *storage.ManagedRuleGroupOverride) error {

	// Exclusions
	if source.Exclusions != nil {
		exclusionList := make([]ManagedRuleExclusion, len(source.Exclusions))
		for exclusionIndex, exclusionItem := range source.Exclusions {
			// Shadow the loop variable to avoid aliasing
			exclusionItem := exclusionItem
			var exclusion ManagedRuleExclusion
			err := exclusion.AssignProperties_From_ManagedRuleExclusion(&exclusionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ManagedRuleExclusion() to populate field Exclusions")
			}
			exclusionList[exclusionIndex] = exclusion
		}
		override.Exclusions = exclusionList
	} else {
		override.Exclusions = nil
	}

	// RuleGroupName
	override.RuleGroupName = genruntime.ClonePointerToString(source.RuleGroupName)

	// Rules
	if source.Rules != nil {
		ruleList := make([]ManagedRuleOverride, len(source.Rules))
		for ruleIndex, ruleItem := range source.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule ManagedRuleOverride
			err := rule.AssignProperties_From_ManagedRuleOverride(&ruleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ManagedRuleOverride() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		override.Rules = ruleList
	} else {
		override.Rules = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedRuleGroupOverride populates the provided destination ManagedRuleGroupOverride from our ManagedRuleGroupOverride
func (override *ManagedRuleGroupOverride) AssignProperties_To_ManagedRuleGroupOverride(destination *storage.ManagedRuleGroupOverride) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Exclusions
	if override.Exclusions != nil {
		exclusionList := make([]storage.ManagedRuleExclusion, len(override.Exclusions))
		for exclusionIndex, exclusionItem := range override.Exclusions {
			// Shadow the loop variable to avoid aliasing
			exclusionItem := exclusionItem
			var exclusion storage.ManagedRuleExclusion
			err := exclusionItem.AssignProperties_To_ManagedRuleExclusion(&exclusion)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ManagedRuleExclusion() to populate field Exclusions")
			}
			exclusionList[exclusionIndex] = exclusion
		}
		destination.Exclusions = exclusionList
	} else {
		destination.Exclusions = nil
	}

	// RuleGroupName
	destination.RuleGroupName = genruntime.ClonePointerToString(override.RuleGroupName)

	// Rules
	if override.Rules != nil {
		ruleList := make([]storage.ManagedRuleOverride, len(override.Rules))
		for ruleIndex, ruleItem := range override.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule storage.ManagedRuleOverride
			err := ruleItem.AssignProperties_To_ManagedRuleOverride(&rule)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ManagedRuleOverride() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		destination.Rules = ruleList
	} else {
		destination.Rules = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ManagedRuleGroupOverride_STATUS populates our ManagedRuleGroupOverride from the provided source ManagedRuleGroupOverride_STATUS
func (override *ManagedRuleGroupOverride) Initialize_From_ManagedRuleGroupOverride_STATUS(source *ManagedRuleGroupOverride_STATUS) error {

	// Exclusions
	if source.Exclusions != nil {
		exclusionList := make([]ManagedRuleExclusion, len(source.Exclusions))
		for exclusionIndex, exclusionItem := range source.Exclusions {
			// Shadow the loop variable to avoid aliasing
			exclusionItem := exclusionItem
			var exclusion ManagedRuleExclusion
			err := exclusion.Initialize_From_ManagedRuleExclusion_STATUS(&exclusionItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_ManagedRuleExclusion_STATUS() to populate field Exclusions")
			}
			exclusionList[exclusionIndex] = exclusion
		}
		override.Exclusions = exclusionList
	} else {
		override.Exclusions = nil
	}

	// RuleGroupName
	override.RuleGroupName = genruntime.ClonePointerToString(source.RuleGroupName)

	// Rules
	if source.Rules != nil {
		ruleList := make([]ManagedRuleOverride, len(source.Rules))
		for ruleIndex, ruleItem := range source.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule ManagedRuleOverride
			err := rule.Initialize_From_ManagedRuleOverride_STATUS(&ruleItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_ManagedRuleOverride_STATUS() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		override.Rules = ruleList
	} else {
		override.Rules = nil
	}

	// No error
	return nil
}

// Defines a managed rule group override setting.
type ManagedRuleGroupOverride_STATUS struct {
	// Exclusions: Describes the exclusions that are applied to all rules in the group.
	Exclusions []ManagedRuleExclusion_STATUS `json:"exclusions,omitempty"`

	// RuleGroupName: Describes the managed rule group to override.
	RuleGroupName *string `json:"ruleGroupName,omitempty"`

	// Rules: List of rules that will be disabled. If none specified, all rules in the group will be disabled.
	Rules []ManagedRuleOverride_STATUS `json:"rules,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedRuleGroupOverride_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (override *ManagedRuleGroupOverride_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedRuleGroupOverride_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (override *ManagedRuleGroupOverride_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedRuleGroupOverride_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedRuleGroupOverride_STATUS, got %T", armInput)
	}

	// Set property "Exclusions":
	for _, item := range typedInput.Exclusions {
		var item1 ManagedRuleExclusion_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		override.Exclusions = append(override.Exclusions, item1)
	}

	// Set property "RuleGroupName":
	if typedInput.RuleGroupName != nil {
		ruleGroupName := *typedInput.RuleGroupName
		override.RuleGroupName = &ruleGroupName
	}

	// Set property "Rules":
	for _, item := range typedInput.Rules {
		var item1 ManagedRuleOverride_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		override.Rules = append(override.Rules, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedRuleGroupOverride_STATUS populates our ManagedRuleGroupOverride_STATUS from the provided source ManagedRuleGroupOverride_STATUS
func (override *ManagedRuleGroupOverride_STATUS) AssignProperties_From_ManagedRuleGroupOverride_STATUS(source *storage.ManagedRuleGroupOverride_STATUS) error {

	// Exclusions
	if source.Exclusions != nil {
		exclusionList := make([]ManagedRuleExclusion_STATUS, len(source.Exclusions))
		for exclusionIndex, exclusionItem := range source.Exclusions {
			// Shadow the loop variable to avoid aliasing
			exclusionItem := exclusionItem
			var exclusion ManagedRuleExclusion_STATUS
			err := exclusion.AssignProperties_From_ManagedRuleExclusion_STATUS(&exclusionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ManagedRuleExclusion_STATUS() to populate field Exclusions")
			}
			exclusionList[exclusionIndex] = exclusion
		}
		override.Exclusions = exclusionList
	} else {
		override.Exclusions = nil
	}

	// RuleGroupName
	override.RuleGroupName = genruntime.ClonePointerToString(source.RuleGroupName)

	// Rules
	if source.Rules != nil {
		ruleList := make([]ManagedRuleOverride_STATUS, len(source.Rules))
		for ruleIndex, ruleItem := range source.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule ManagedRuleOverride_STATUS
			err := rule.AssignProperties_From_ManagedRuleOverride_STATUS(&ruleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ManagedRuleOverride_STATUS() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		override.Rules = ruleList
	} else {
		override.Rules = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedRuleGroupOverride_STATUS populates the provided destination ManagedRuleGroupOverride_STATUS from our ManagedRuleGroupOverride_STATUS
func (override *ManagedRuleGroupOverride_STATUS) AssignProperties_To_ManagedRuleGroupOverride_STATUS(destination *storage.ManagedRuleGroupOverride_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Exclusions
	if override.Exclusions != nil {
		exclusionList := make([]storage.ManagedRuleExclusion_STATUS, len(override.Exclusions))
		for exclusionIndex, exclusionItem := range override.Exclusions {
			// Shadow the loop variable to avoid aliasing
			exclusionItem := exclusionItem
			var exclusion storage.ManagedRuleExclusion_STATUS
			err := exclusionItem.AssignProperties_To_ManagedRuleExclusion_STATUS(&exclusion)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ManagedRuleExclusion_STATUS() to populate field Exclusions")
			}
			exclusionList[exclusionIndex] = exclusion
		}
		destination.Exclusions = exclusionList
	} else {
		destination.Exclusions = nil
	}

	// RuleGroupName
	destination.RuleGroupName = genruntime.ClonePointerToString(override.RuleGroupName)

	// Rules
	if override.Rules != nil {
		ruleList := make([]storage.ManagedRuleOverride_STATUS, len(override.Rules))
		for ruleIndex, ruleItem := range override.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule storage.ManagedRuleOverride_STATUS
			err := ruleItem.AssignProperties_To_ManagedRuleOverride_STATUS(&rule)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ManagedRuleOverride_STATUS() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		destination.Rules = ruleList
	} else {
		destination.Rules = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines the action to take when a managed rule set score threshold is met.
// +kubebuilder:validation:Enum={"Block","Log","Redirect"}
type ManagedRuleSetActionType string

const (
	ManagedRuleSetActionType_Block    = ManagedRuleSetActionType("Block")
	ManagedRuleSetActionType_Log      = ManagedRuleSetActionType("Log")
	ManagedRuleSetActionType_Redirect = ManagedRuleSetActionType("Redirect")
)

// Mapping from string to ManagedRuleSetActionType
var managedRuleSetActionType_Values = map[string]ManagedRuleSetActionType{
	"block":    ManagedRuleSetActionType_Block,
	"log":      ManagedRuleSetActionType_Log,
	"redirect": ManagedRuleSetActionType_Redirect,
}

// Defines the action to take when a managed rule set score threshold is met.
type ManagedRuleSetActionType_STATUS string

const (
	ManagedRuleSetActionType_STATUS_Block    = ManagedRuleSetActionType_STATUS("Block")
	ManagedRuleSetActionType_STATUS_Log      = ManagedRuleSetActionType_STATUS("Log")
	ManagedRuleSetActionType_STATUS_Redirect = ManagedRuleSetActionType_STATUS("Redirect")
)

// Mapping from string to ManagedRuleSetActionType_STATUS
var managedRuleSetActionType_STATUS_Values = map[string]ManagedRuleSetActionType_STATUS{
	"block":    ManagedRuleSetActionType_STATUS_Block,
	"log":      ManagedRuleSetActionType_STATUS_Log,
	"redirect": ManagedRuleSetActionType_STATUS_Redirect,
}

// Define a match condition.
type MatchCondition struct {
	// +kubebuilder:validation:Required
	// MatchValue: List of possible match values.
	MatchValue []string `json:"matchValue,omitempty"`

	// +kubebuilder:validation:Required
	// MatchVariable: Request variable to compare with.
	MatchVariable *MatchCondition_MatchVariable `json:"matchVariable,omitempty"`

	// NegateCondition: Describes if the result of this condition should be negated.
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// +kubebuilder:validation:Required
	// Operator: Comparison type to use for matching with the variable value.
	Operator *MatchCondition_Operator `json:"operator,omitempty"`

	// Selector: Match against a specific key from the QueryString, PostArgs, RequestHeader or Cookies variables. Default is
	// null.
	Selector *string `json:"selector,omitempty"`

	// Transforms: List of transforms.
	Transforms []TransformType `json:"transforms,omitempty"`
}

var _ genruntime.ARMTransformer = &MatchCondition{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (condition *MatchCondition) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if condition == nil {
		return nil, nil
	}
	result := &arm.MatchCondition{}

	// Set property "MatchValue":
	for _, item := range condition.MatchValue {
		result.MatchValue = append(result.MatchValue, item)
	}

	// Set property "MatchVariable":
	if condition.MatchVariable != nil {
		var temp string
		temp = string(*condition.MatchVariable)
		matchVariable := arm.MatchCondition_MatchVariable(temp)
		result.MatchVariable = &matchVariable
	}

	// Set property "NegateCondition":
	if condition.NegateCondition != nil {
		negateCondition := *condition.NegateCondition
		result.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if condition.Operator != nil {
		var temp string
		temp = string(*condition.Operator)
		operator := arm.MatchCondition_Operator(temp)
		result.Operator = &operator
	}

	// Set property "Selector":
	if condition.Selector != nil {
		selector := *condition.Selector
		result.Selector = &selector
	}

	// Set property "Transforms":
	for _, item := range condition.Transforms {
		var temp string
		temp = string(item)
		result.Transforms = append(result.Transforms, arm.TransformType(temp))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *MatchCondition) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.MatchCondition{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *MatchCondition) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.MatchCondition)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.MatchCondition, got %T", armInput)
	}

	// Set property "MatchValue":
	for _, item := range typedInput.MatchValue {
		condition.MatchValue = append(condition.MatchValue, item)
	}

	// Set property "MatchVariable":
	if typedInput.MatchVariable != nil {
		var temp string
		temp = string(*typedInput.MatchVariable)
		matchVariable := MatchCondition_MatchVariable(temp)
		condition.MatchVariable = &matchVariable
	}

	// Set property "NegateCondition":
	if typedInput.NegateCondition != nil {
		negateCondition := *typedInput.NegateCondition
		condition.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		var temp string
		temp = string(*typedInput.Operator)
		operator := MatchCondition_Operator(temp)
		condition.Operator = &operator
	}

	// Set property "Selector":
	if typedInput.Selector != nil {
		selector := *typedInput.Selector
		condition.Selector = &selector
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		var temp string
		temp = string(item)
		condition.Transforms = append(condition.Transforms, TransformType(temp))
	}

	// No error
	return nil
}

// AssignProperties_From_MatchCondition populates our MatchCondition from the provided source MatchCondition
func (condition *MatchCondition) AssignProperties_From_MatchCondition(source *storage.MatchCondition) error {

	// MatchValue
	condition.MatchValue = genruntime.CloneSliceOfString(source.MatchValue)

	// MatchVariable
	if source.MatchVariable != nil {
		matchVariable := *source.MatchVariable
		matchVariableTemp := genruntime.ToEnum(matchVariable, matchCondition_MatchVariable_Values)
		condition.MatchVariable = &matchVariableTemp
	} else {
		condition.MatchVariable = nil
	}

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		condition.NegateCondition = &negateCondition
	} else {
		condition.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := *source.Operator
		operatorTemp := genruntime.ToEnum(operator, matchCondition_Operator_Values)
		condition.Operator = &operatorTemp
	} else {
		condition.Operator = nil
	}

	// Selector
	condition.Selector = genruntime.ClonePointerToString(source.Selector)

	// Transforms
	if source.Transforms != nil {
		transformList := make([]TransformType, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = genruntime.ToEnum(transformItem, transformType_Values)
		}
		condition.Transforms = transformList
	} else {
		condition.Transforms = nil
	}

	// No error
	return nil
}

// AssignProperties_To_MatchCondition populates the provided destination MatchCondition from our MatchCondition
func (condition *MatchCondition) AssignProperties_To_MatchCondition(destination *storage.MatchCondition) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValue
	destination.MatchValue = genruntime.CloneSliceOfString(condition.MatchValue)

	// MatchVariable
	if condition.MatchVariable != nil {
		matchVariable := string(*condition.MatchVariable)
		destination.MatchVariable = &matchVariable
	} else {
		destination.MatchVariable = nil
	}

	// NegateCondition
	if condition.NegateCondition != nil {
		negateCondition := *condition.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	if condition.Operator != nil {
		operator := string(*condition.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Selector
	destination.Selector = genruntime.ClonePointerToString(condition.Selector)

	// Transforms
	if condition.Transforms != nil {
		transformList := make([]string, len(condition.Transforms))
		for transformIndex, transformItem := range condition.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_MatchCondition_STATUS populates our MatchCondition from the provided source MatchCondition_STATUS
func (condition *MatchCondition) Initialize_From_MatchCondition_STATUS(source *MatchCondition_STATUS) error {

	// MatchValue
	condition.MatchValue = genruntime.CloneSliceOfString(source.MatchValue)

	// MatchVariable
	if source.MatchVariable != nil {
		matchVariable := genruntime.ToEnum(string(*source.MatchVariable), matchCondition_MatchVariable_Values)
		condition.MatchVariable = &matchVariable
	} else {
		condition.MatchVariable = nil
	}

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		condition.NegateCondition = &negateCondition
	} else {
		condition.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := genruntime.ToEnum(string(*source.Operator), matchCondition_Operator_Values)
		condition.Operator = &operator
	} else {
		condition.Operator = nil
	}

	// Selector
	condition.Selector = genruntime.ClonePointerToString(source.Selector)

	// Transforms
	if source.Transforms != nil {
		transformList := make([]TransformType, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transform := genruntime.ToEnum(string(transformItem), transformType_Values)
			transformList[transformIndex] = transform
		}
		condition.Transforms = transformList
	} else {
		condition.Transforms = nil
	}

	// No error
	return nil
}

// Define a match condition.
type MatchCondition_STATUS struct {
	// MatchValue: List of possible match values.
	MatchValue []string `json:"matchValue,omitempty"`

	// MatchVariable: Request variable to compare with.
	MatchVariable *MatchCondition_MatchVariable_STATUS `json:"matchVariable,omitempty"`

	// NegateCondition: Describes if the result of this condition should be negated.
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// Operator: Comparison type to use for matching with the variable value.
	Operator *MatchCondition_Operator_STATUS `json:"operator,omitempty"`

	// Selector: Match against a specific key from the QueryString, PostArgs, RequestHeader or Cookies variables. Default is
	// null.
	Selector *string `json:"selector,omitempty"`

	// Transforms: List of transforms.
	Transforms []TransformType_STATUS `json:"transforms,omitempty"`
}

var _ genruntime.FromARMConverter = &MatchCondition_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *MatchCondition_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.MatchCondition_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *MatchCondition_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.MatchCondition_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.MatchCondition_STATUS, got %T", armInput)
	}

	// Set property "MatchValue":
	for _, item := range typedInput.MatchValue {
		condition.MatchValue = append(condition.MatchValue, item)
	}

	// Set property "MatchVariable":
	if typedInput.MatchVariable != nil {
		var temp string
		temp = string(*typedInput.MatchVariable)
		matchVariable := MatchCondition_MatchVariable_STATUS(temp)
		condition.MatchVariable = &matchVariable
	}

	// Set property "NegateCondition":
	if typedInput.NegateCondition != nil {
		negateCondition := *typedInput.NegateCondition
		condition.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		var temp string
		temp = string(*typedInput.Operator)
		operator := MatchCondition_Operator_STATUS(temp)
		condition.Operator = &operator
	}

	// Set property "Selector":
	if typedInput.Selector != nil {
		selector := *typedInput.Selector
		condition.Selector = &selector
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		var temp string
		temp = string(item)
		condition.Transforms = append(condition.Transforms, TransformType_STATUS(temp))
	}

	// No error
	return nil
}

// AssignProperties_From_MatchCondition_STATUS populates our MatchCondition_STATUS from the provided source MatchCondition_STATUS
func (condition *MatchCondition_STATUS) AssignProperties_From_MatchCondition_STATUS(source *storage.MatchCondition_STATUS) error {

	// MatchValue
	condition.MatchValue = genruntime.CloneSliceOfString(source.MatchValue)

	// MatchVariable
	if source.MatchVariable != nil {
		matchVariable := *source.MatchVariable
		matchVariableTemp := genruntime.ToEnum(matchVariable, matchCondition_MatchVariable_STATUS_Values)
		condition.MatchVariable = &matchVariableTemp
	} else {
		condition.MatchVariable = nil
	}

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		condition.NegateCondition = &negateCondition
	} else {
		condition.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := *source.Operator
		operatorTemp := genruntime.ToEnum(operator, matchCondition_Operator_STATUS_Values)
		condition.Operator = &operatorTemp
	} else {
		condition.Operator = nil
	}

	// Selector
	condition.Selector = genruntime.ClonePointerToString(source.Selector)

	// Transforms
	if source.Transforms != nil {
		transformList := make([]TransformType_STATUS, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = genruntime.ToEnum(transformItem, transformType_STATUS_Values)
		}
		condition.Transforms = transformList
	} else {
		condition.Transforms = nil
	}

	// No error
	return nil
}

// AssignProperties_To_MatchCondition_STATUS populates the provided destination MatchCondition_STATUS from our MatchCondition_STATUS
func (condition *MatchCondition_STATUS) AssignProperties_To_MatchCondition_STATUS(destination *storage.MatchCondition_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValue
	destination.MatchValue = genruntime.CloneSliceOfString(condition.MatchValue)

	// MatchVariable
	if condition.MatchVariable != nil {
		matchVariable := string(*condition.MatchVariable)
		destination.MatchVariable = &matchVariable
	} else {
		destination.MatchVariable = nil
	}

	// NegateCondition
	if condition.NegateCondition != nil {
		negateCondition := *condition.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	if condition.Operator != nil {
		operator := string(*condition.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Selector
	destination.Selector = genruntime.ClonePointerToString(condition.Selector)

	// Transforms
	if condition.Transforms != nil {
		transformList := make([]string, len(condition.Transforms))
		for transformIndex, transformItem := range condition.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"QueryStringArgNames","RequestBodyJsonArgNames","RequestBodyPostArgNames","RequestCookieNames","RequestHeaderNames"}
type ManagedRuleExclusion_MatchVariable string

const (
	ManagedRuleExclusion_MatchVariable_QueryStringArgNames     = ManagedRuleExclusion_MatchVariable("QueryStringArgNames")
	ManagedRuleExclusion_MatchVariable_RequestBodyJsonArgNames = ManagedRuleExclusion_MatchVariable("RequestBodyJsonArgNames")
	ManagedRuleExclusion_MatchVariable_RequestBodyPostArgNames = ManagedRuleExclusion_MatchVariable("RequestBodyPostArgNames")
	ManagedRuleExclusion_MatchVariable_RequestCookieNames      = ManagedRuleExclusion_MatchVariable("RequestCookieNames")
	ManagedRuleExclusion_MatchVariable_RequestHeaderNames      = ManagedRuleExclusion_MatchVariable("RequestHeaderNames")
)

// Mapping from string to ManagedRuleExclusion_MatchVariable
var managedRuleExclusion_MatchVariable_Values = map[string]ManagedRuleExclusion_MatchVariable{
	"querystringargnames":     ManagedRuleExclusion_MatchVariable_QueryStringArgNames,
	"requestbodyjsonargnames": ManagedRuleExclusion_MatchVariable_RequestBodyJsonArgNames,
	"requestbodypostargnames": ManagedRuleExclusion_MatchVariable_RequestBodyPostArgNames,
	"requestcookienames":      ManagedRuleExclusion_MatchVariable_RequestCookieNames,
	"requestheadernames":      ManagedRuleExclusion_MatchVariable_RequestHeaderNames,
}

type ManagedRuleExclusion_MatchVariable_STATUS string

const (
	ManagedRuleExclusion_MatchVariable_STATUS_QueryStringArgNames     = ManagedRuleExclusion_MatchVariable_STATUS("QueryStringArgNames")
	ManagedRuleExclusion_MatchVariable_STATUS_RequestBodyJsonArgNames = ManagedRuleExclusion_MatchVariable_STATUS("RequestBodyJsonArgNames")
	ManagedRuleExclusion_MatchVariable_STATUS_RequestBodyPostArgNames = ManagedRuleExclusion_MatchVariable_STATUS("RequestBodyPostArgNames")
	ManagedRuleExclusion_MatchVariable_STATUS_RequestCookieNames      = ManagedRuleExclusion_MatchVariable_STATUS("RequestCookieNames")
	ManagedRuleExclusion_MatchVariable_STATUS_RequestHeaderNames      = ManagedRuleExclusion_MatchVariable_STATUS("RequestHeaderNames")
)

// Mapping from string to ManagedRuleExclusion_MatchVariable_STATUS
var managedRuleExclusion_MatchVariable_STATUS_Values = map[string]ManagedRuleExclusion_MatchVariable_STATUS{
	"querystringargnames":     ManagedRuleExclusion_MatchVariable_STATUS_QueryStringArgNames,
	"requestbodyjsonargnames": ManagedRuleExclusion_MatchVariable_STATUS_RequestBodyJsonArgNames,
	"requestbodypostargnames": ManagedRuleExclusion_MatchVariable_STATUS_RequestBodyPostArgNames,
	"requestcookienames":      ManagedRuleExclusion_MatchVariable_STATUS_RequestCookieNames,
	"requestheadernames":      ManagedRuleExclusion_MatchVariable_STATUS_RequestHeaderNames,
}

// +kubebuilder:validation:Enum={"Contains","EndsWith","Equals","EqualsAny","StartsWith"}
type ManagedRuleExclusion_SelectorMatchOperator string

const (
	ManagedRuleExclusion_SelectorMatchOperator_Contains   = ManagedRuleExclusion_SelectorMatchOperator("Contains")
	ManagedRuleExclusion_SelectorMatchOperator_EndsWith   = ManagedRuleExclusion_SelectorMatchOperator("EndsWith")
	ManagedRuleExclusion_SelectorMatchOperator_Equals     = ManagedRuleExclusion_SelectorMatchOperator("Equals")
	ManagedRuleExclusion_SelectorMatchOperator_EqualsAny  = ManagedRuleExclusion_SelectorMatchOperator("EqualsAny")
	ManagedRuleExclusion_SelectorMatchOperator_StartsWith = ManagedRuleExclusion_SelectorMatchOperator("StartsWith")
)

// Mapping from string to ManagedRuleExclusion_SelectorMatchOperator
var managedRuleExclusion_SelectorMatchOperator_Values = map[string]ManagedRuleExclusion_SelectorMatchOperator{
	"contains":   ManagedRuleExclusion_SelectorMatchOperator_Contains,
	"endswith":   ManagedRuleExclusion_SelectorMatchOperator_EndsWith,
	"equals":     ManagedRuleExclusion_SelectorMatchOperator_Equals,
	"equalsany":  ManagedRuleExclusion_SelectorMatchOperator_EqualsAny,
	"startswith": ManagedRuleExclusion_SelectorMatchOperator_StartsWith,
}

type ManagedRuleExclusion_SelectorMatchOperator_STATUS string

const (
	ManagedRuleExclusion_SelectorMatchOperator_STATUS_Contains   = ManagedRuleExclusion_SelectorMatchOperator_STATUS("Contains")
	ManagedRuleExclusion_SelectorMatchOperator_STATUS_EndsWith   = ManagedRuleExclusion_SelectorMatchOperator_STATUS("EndsWith")
	ManagedRuleExclusion_SelectorMatchOperator_STATUS_Equals     = ManagedRuleExclusion_SelectorMatchOperator_STATUS("Equals")
	ManagedRuleExclusion_SelectorMatchOperator_STATUS_EqualsAny  = ManagedRuleExclusion_SelectorMatchOperator_STATUS("EqualsAny")
	ManagedRuleExclusion_SelectorMatchOperator_STATUS_StartsWith = ManagedRuleExclusion_SelectorMatchOperator_STATUS("StartsWith")
)

// Mapping from string to ManagedRuleExclusion_SelectorMatchOperator_STATUS
var managedRuleExclusion_SelectorMatchOperator_STATUS_Values = map[string]ManagedRuleExclusion_SelectorMatchOperator_STATUS{
	"contains":   ManagedRuleExclusion_SelectorMatchOperator_STATUS_Contains,
	"endswith":   ManagedRuleExclusion_SelectorMatchOperator_STATUS_EndsWith,
	"equals":     ManagedRuleExclusion_SelectorMatchOperator_STATUS_Equals,
	"equalsany":  ManagedRuleExclusion_SelectorMatchOperator_STATUS_EqualsAny,
	"startswith": ManagedRuleExclusion_SelectorMatchOperator_STATUS_StartsWith,
}

// Defines a managed rule group override setting.
type ManagedRuleOverride struct {
	// Action: Describes the override action to be applied when rule matches.
	Action *ActionType `json:"action,omitempty"`

	// EnabledState: Describes if the managed rule is in enabled or disabled state. Defaults to Disabled if not specified.
	EnabledState *ManagedRuleEnabledState `json:"enabledState,omitempty"`

	// Exclusions: Describes the exclusions that are applied to this specific rule.
	Exclusions []ManagedRuleExclusion `json:"exclusions,omitempty"`

	// +kubebuilder:validation:Required
	// RuleId: Identifier for the managed rule.
	RuleId *string `json:"ruleId,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedRuleOverride{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (override *ManagedRuleOverride) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if override == nil {
		return nil, nil
	}
	result := &arm.ManagedRuleOverride{}

	// Set property "Action":
	if override.Action != nil {
		var temp string
		temp = string(*override.Action)
		action := arm.ActionType(temp)
		result.Action = &action
	}

	// Set property "EnabledState":
	if override.EnabledState != nil {
		var temp string
		temp = string(*override.EnabledState)
		enabledState := arm.ManagedRuleEnabledState(temp)
		result.EnabledState = &enabledState
	}

	// Set property "Exclusions":
	for _, item := range override.Exclusions {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Exclusions = append(result.Exclusions, *item_ARM.(*arm.ManagedRuleExclusion))
	}

	// Set property "RuleId":
	if override.RuleId != nil {
		ruleId := *override.RuleId
		result.RuleId = &ruleId
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (override *ManagedRuleOverride) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedRuleOverride{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (override *ManagedRuleOverride) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedRuleOverride)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedRuleOverride, got %T", armInput)
	}

	// Set property "Action":
	if typedInput.Action != nil {
		var temp string
		temp = string(*typedInput.Action)
		action := ActionType(temp)
		override.Action = &action
	}

	// Set property "EnabledState":
	if typedInput.EnabledState != nil {
		var temp string
		temp = string(*typedInput.EnabledState)
		enabledState := ManagedRuleEnabledState(temp)
		override.EnabledState = &enabledState
	}

	// Set property "Exclusions":
	for _, item := range typedInput.Exclusions {
		var item1 ManagedRuleExclusion
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		override.Exclusions = append(override.Exclusions, item1)
	}

	// Set property "RuleId":
	if typedInput.RuleId != nil {
		ruleId := *typedInput.RuleId
		override.RuleId = &ruleId
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedRuleOverride populates our ManagedRuleOverride from the provided source ManagedRuleOverride
func (override *ManagedRuleOverride) AssignProperties_From_ManagedRuleOverride(source *storage.ManagedRuleOverride) error {

	// Action
	if source.Action != nil {
		action := *source.Action
		actionTemp := genruntime.ToEnum(action, actionType_Values)
		override.Action = &actionTemp
	} else {
		override.Action = nil
	}

	// EnabledState
	if source.EnabledState != nil {
		enabledState := *source.EnabledState
		enabledStateTemp := genruntime.ToEnum(enabledState, managedRuleEnabledState_Values)
		override.EnabledState = &enabledStateTemp
	} else {
		override.EnabledState = nil
	}

	// Exclusions
	if source.Exclusions != nil {
		exclusionList := make([]ManagedRuleExclusion, len(source.Exclusions))
		for exclusionIndex, exclusionItem := range source.Exclusions {
			// Shadow the loop variable to avoid aliasing
			exclusionItem := exclusionItem
			var exclusion ManagedRuleExclusion
			err := exclusion.AssignProperties_From_ManagedRuleExclusion(&exclusionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ManagedRuleExclusion() to populate field Exclusions")
			}
			exclusionList[exclusionIndex] = exclusion
		}
		override.Exclusions = exclusionList
	} else {
		override.Exclusions = nil
	}

	// RuleId
	override.RuleId = genruntime.ClonePointerToString(source.RuleId)

	// No error
	return nil
}

// AssignProperties_To_ManagedRuleOverride populates the provided destination ManagedRuleOverride from our ManagedRuleOverride
func (override *ManagedRuleOverride) AssignProperties_To_ManagedRuleOverride(destination *storage.ManagedRuleOverride) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Action
	if override.Action != nil {
		action := string(*override.Action)
		destination.Action = &action
	} else {
		destination.Action = nil
	}

	// EnabledState
	if override.EnabledState != nil {
		enabledState := string(*override.EnabledState)
		destination.EnabledState = &enabledState
	} else {
		destination.EnabledState = nil
	}

	// Exclusions
	if override.Exclusions != nil {
		exclusionList := make([]storage.ManagedRuleExclusion, len(override.Exclusions))
		for exclusionIndex, exclusionItem := range override.Exclusions {
			// Shadow the loop variable to avoid aliasing
			exclusionItem := exclusionItem
			var exclusion storage.ManagedRuleExclusion
			err := exclusionItem.AssignProperties_To_ManagedRuleExclusion(&exclusion)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ManagedRuleExclusion() to populate field Exclusions")
			}
			exclusionList[exclusionIndex] = exclusion
		}
		destination.Exclusions = exclusionList
	} else {
		destination.Exclusions = nil
	}

	// RuleId
	destination.RuleId = genruntime.ClonePointerToString(override.RuleId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ManagedRuleOverride_STATUS populates our ManagedRuleOverride from the provided source ManagedRuleOverride_STATUS
func (override *ManagedRuleOverride) Initialize_From_ManagedRuleOverride_STATUS(source *ManagedRuleOverride_STATUS) error {

	// Action
	if source.Action != nil {
		action := genruntime.ToEnum(string(*source.Action), actionType_Values)
		override.Action = &action
	} else {
		override.Action = nil
	}

	// EnabledState
	if source.EnabledState != nil {
		enabledState := genruntime.ToEnum(string(*source.EnabledState), managedRuleEnabledState_Values)
		override.EnabledState = &enabledState
	} else {
		override.EnabledState = nil
	}

	// Exclusions
	if source.Exclusions != nil {
		exclusionList := make([]ManagedRuleExclusion, len(source.Exclusions))
		for exclusionIndex, exclusionItem := range source.Exclusions {
			// Shadow the loop variable to avoid aliasing
			exclusionItem := exclusionItem
			var exclusion ManagedRuleExclusion
			err := exclusion.Initialize_From_ManagedRuleExclusion_STATUS(&exclusionItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_ManagedRuleExclusion_STATUS() to populate field Exclusions")
			}
			exclusionList[exclusionIndex] = exclusion
		}
		override.Exclusions = exclusionList
	} else {
		override.Exclusions = nil
	}

	// RuleId
	override.RuleId = genruntime.ClonePointerToString(source.RuleId)

	// No error
	return nil
}

// Defines a managed rule group override setting.
type ManagedRuleOverride_STATUS struct {
	// Action: Describes the override action to be applied when rule matches.
	Action *ActionType_STATUS `json:"action,omitempty"`

	// EnabledState: Describes if the managed rule is in enabled or disabled state. Defaults to Disabled if not specified.
	EnabledState *ManagedRuleEnabledState_STATUS `json:"enabledState,omitempty"`

	// Exclusions: Describes the exclusions that are applied to this specific rule.
	Exclusions []ManagedRuleExclusion_STATUS `json:"exclusions,omitempty"`

	// RuleId: Identifier for the managed rule.
	RuleId *string `json:"ruleId,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedRuleOverride_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (override *ManagedRuleOverride_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedRuleOverride_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (override *ManagedRuleOverride_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedRuleOverride_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedRuleOverride_STATUS, got %T", armInput)
	}

	// Set property "Action":
	if typedInput.Action != nil {
		var temp string
		temp = string(*typedInput.Action)
		action := ActionType_STATUS(temp)
		override.Action = &action
	}

	// Set property "EnabledState":
	if typedInput.EnabledState != nil {
		var temp string
		temp = string(*typedInput.EnabledState)
		enabledState := ManagedRuleEnabledState_STATUS(temp)
		override.EnabledState = &enabledState
	}

	// Set property "Exclusions":
	for _, item := range typedInput.Exclusions {
		var item1 ManagedRuleExclusion_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		override.Exclusions = append(override.Exclusions, item1)
	}

	// Set property "RuleId":
	if typedInput.RuleId != nil {
		ruleId := *typedInput.RuleId
		override.RuleId = &ruleId
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedRuleOverride_STATUS populates our ManagedRuleOverride_STATUS from the provided source ManagedRuleOverride_STATUS
func (override *ManagedRuleOverride_STATUS) AssignProperties_From_ManagedRuleOverride_STATUS(source *storage.ManagedRuleOverride_STATUS) error {

	// Action
	if source.Action != nil {
		action := *source.Action
		actionTemp := genruntime.ToEnum(action, actionType_STATUS_Values)
		override.Action = &actionTemp
	} else {
		override.Action = nil
	}

	// EnabledState
	if source.EnabledState != nil {
		enabledState := *source.EnabledState
		enabledStateTemp := genruntime.ToEnum(enabledState, managedRuleEnabledState_STATUS_Values)
		override.EnabledState = &enabledStateTemp
	} else {
		override.EnabledState = nil
	}

	// Exclusions
	if source.Exclusions != nil {
		exclusionList := make([]ManagedRuleExclusion_STATUS, len(source.Exclusions))
		for exclusionIndex, exclusionItem := range source.Exclusions {
			// Shadow the loop variable to avoid aliasing
			exclusionItem := exclusionItem
			var exclusion ManagedRuleExclusion_STATUS
			err := exclusion.AssignProperties_From_ManagedRuleExclusion_STATUS(&exclusionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ManagedRuleExclusion_STATUS() to populate field Exclusions")
			}
			exclusionList[exclusionIndex] = exclusion
		}
		override.Exclusions = exclusionList
	} else {
		override.Exclusions = nil
	}

	// RuleId
	override.RuleId = genruntime.ClonePointerToString(source.RuleId)

	// No error
	return nil
}

// AssignProperties_To_ManagedRuleOverride_STATUS populates the provided destination ManagedRuleOverride_STATUS from our ManagedRuleOverride_STATUS
func (override *ManagedRuleOverride_STATUS) AssignProperties_To_ManagedRuleOverride_STATUS(destination *storage.ManagedRuleOverride_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Action
	if override.Action != nil {
		action := string(*override.Action)
		destination.Action = &action
	} else {
		destination.Action = nil
	}

	// EnabledState
	if override.EnabledState != nil {
		enabledState := string(*override.EnabledState)
		destination.EnabledState = &enabledState
	} else {
		destination.EnabledState = nil
	}

	// Exclusions
	if override.Exclusions != nil {
		exclusionList := make([]storage.ManagedRuleExclusion_STATUS, len(override.Exclusions))
		for exclusionIndex, exclusionItem := range override.Exclusions {
			// Shadow the loop variable to avoid aliasing
			exclusionItem := exclusionItem
			var exclusion storage.ManagedRuleExclusion_STATUS
			err := exclusionItem.AssignProperties_To_ManagedRuleExclusion_STATUS(&exclusion)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ManagedRuleExclusion_STATUS() to populate field Exclusions")
			}
			exclusionList[exclusionIndex] = exclusion
		}
		destination.Exclusions = exclusionList
	} else {
		destination.Exclusions = nil
	}

	// RuleId
	destination.RuleId = genruntime.ClonePointerToString(override.RuleId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Cookies","PostArgs","QueryString","RemoteAddr","RequestBody","RequestHeader","RequestMethod","RequestUri","SocketAddr"}
type MatchCondition_MatchVariable string

const (
	MatchCondition_MatchVariable_Cookies       = MatchCondition_MatchVariable("Cookies")
	MatchCondition_MatchVariable_PostArgs      = MatchCondition_MatchVariable("PostArgs")
	MatchCondition_MatchVariable_QueryString   = MatchCondition_MatchVariable("QueryString")
	MatchCondition_MatchVariable_RemoteAddr    = MatchCondition_MatchVariable("RemoteAddr")
	MatchCondition_MatchVariable_RequestBody   = MatchCondition_MatchVariable("RequestBody")
	MatchCondition_MatchVariable_RequestHeader = MatchCondition_MatchVariable("RequestHeader")
	MatchCondition_MatchVariable_RequestMethod = MatchCondition_MatchVariable("RequestMethod")
	MatchCondition_MatchVariable_RequestUri    = MatchCondition_MatchVariable("RequestUri")
	MatchCondition_MatchVariable_SocketAddr    = MatchCondition_MatchVariable("SocketAddr")
)

// Mapping from string to MatchCondition_MatchVariable
var matchCondition_MatchVariable_Values = map[string]MatchCondition_MatchVariable{
	"cookies":       MatchCondition_MatchVariable_Cookies,
	"postargs":      MatchCondition_MatchVariable_PostArgs,
	"querystring":   MatchCondition_MatchVariable_QueryString,
	"remoteaddr":    MatchCondition_MatchVariable_RemoteAddr,
	"requestbody":   MatchCondition_MatchVariable_RequestBody,
	"requestheader": MatchCondition_MatchVariable_RequestHeader,
	"requestmethod": MatchCondition_MatchVariable_RequestMethod,
	"requesturi":    MatchCondition_MatchVariable_RequestUri,
	"socketaddr":    MatchCondition_MatchVariable_SocketAddr,
}

type MatchCondition_MatchVariable_STATUS string

const (
	MatchCondition_MatchVariable_STATUS_Cookies       = MatchCondition_MatchVariable_STATUS("Cookies")
	MatchCondition_MatchVariable_STATUS_PostArgs      = MatchCondition_MatchVariable_STATUS("PostArgs")
	MatchCondition_MatchVariable_STATUS_QueryString   = MatchCondition_MatchVariable_STATUS("QueryString")
	MatchCondition_MatchVariable_STATUS_RemoteAddr    = MatchCondition_MatchVariable_STATUS("RemoteAddr")
	MatchCondition_MatchVariable_STATUS_RequestBody   = MatchCondition_MatchVariable_STATUS("RequestBody")
	MatchCondition_MatchVariable_STATUS_RequestHeader = MatchCondition_MatchVariable_STATUS("RequestHeader")
	MatchCondition_MatchVariable_STATUS_RequestMethod = MatchCondition_MatchVariable_STATUS("RequestMethod")
	MatchCondition_MatchVariable_STATUS_RequestUri    = MatchCondition_MatchVariable_STATUS("RequestUri")
	MatchCondition_MatchVariable_STATUS_SocketAddr    = MatchCondition_MatchVariable_STATUS("SocketAddr")
)

// Mapping from string to MatchCondition_MatchVariable_STATUS
var matchCondition_MatchVariable_STATUS_Values = map[string]MatchCondition_MatchVariable_STATUS{
	"cookies":       MatchCondition_MatchVariable_STATUS_Cookies,
	"postargs":      MatchCondition_MatchVariable_STATUS_PostArgs,
	"querystring":   MatchCondition_MatchVariable_STATUS_QueryString,
	"remoteaddr":    MatchCondition_MatchVariable_STATUS_RemoteAddr,
	"requestbody":   MatchCondition_MatchVariable_STATUS_RequestBody,
	"requestheader": MatchCondition_MatchVariable_STATUS_RequestHeader,
	"requestmethod": MatchCondition_MatchVariable_STATUS_RequestMethod,
	"requesturi":    MatchCondition_MatchVariable_STATUS_RequestUri,
	"socketaddr":    MatchCondition_MatchVariable_STATUS_SocketAddr,
}

// +kubebuilder:validation:Enum={"Any","BeginsWith","Contains","EndsWith","Equal","GeoMatch","GreaterThan","GreaterThanOrEqual","IPMatch","LessThan","LessThanOrEqual","RegEx"}
type MatchCondition_Operator string

const (
	MatchCondition_Operator_Any                = MatchCondition_Operator("Any")
	MatchCondition_Operator_BeginsWith         = MatchCondition_Operator("BeginsWith")
	MatchCondition_Operator_Contains           = MatchCondition_Operator("Contains")
	MatchCondition_Operator_EndsWith           = MatchCondition_Operator("EndsWith")
	MatchCondition_Operator_Equal              = MatchCondition_Operator("Equal")
	MatchCondition_Operator_GeoMatch           = MatchCondition_Operator("GeoMatch")
	MatchCondition_Operator_GreaterThan        = MatchCondition_Operator("GreaterThan")
	MatchCondition_Operator_GreaterThanOrEqual = MatchCondition_Operator("GreaterThanOrEqual")
	MatchCondition_Operator_IPMatch            = MatchCondition_Operator("IPMatch")
	MatchCondition_Operator_LessThan           = MatchCondition_Operator("LessThan")
	MatchCondition_Operator_LessThanOrEqual    = MatchCondition_Operator("LessThanOrEqual")
	MatchCondition_Operator_RegEx              = MatchCondition_Operator("RegEx")
)

// Mapping from string to MatchCondition_Operator
var matchCondition_Operator_Values = map[string]MatchCondition_Operator{
	"any":                MatchCondition_Operator_Any,
	"beginswith":         MatchCondition_Operator_BeginsWith,
	"contains":           MatchCondition_Operator_Contains,
	"endswith":           MatchCondition_Operator_EndsWith,
	"equal":              MatchCondition_Operator_Equal,
	"geomatch":           MatchCondition_Operator_GeoMatch,
	"greaterthan":        MatchCondition_Operator_GreaterThan,
	"greaterthanorequal": MatchCondition_Operator_GreaterThanOrEqual,
	"ipmatch":            MatchCondition_Operator_IPMatch,
	"lessthan":           MatchCondition_Operator_LessThan,
	"lessthanorequal":    MatchCondition_Operator_LessThanOrEqual,
	"regex":              MatchCondition_Operator_RegEx,
}

type MatchCondition_Operator_STATUS string

const (
	MatchCondition_Operator_STATUS_Any                = MatchCondition_Operator_STATUS("Any")
	MatchCondition_Operator_STATUS_BeginsWith         = MatchCondition_Operator_STATUS("BeginsWith")
	MatchCondition_Operator_STATUS_Contains           = MatchCondition_Operator_STATUS("Contains")
	MatchCondition_Operator_STATUS_EndsWith           = MatchCondition_Operator_STATUS("EndsWith")
	MatchCondition_Operator_STATUS_Equal              = MatchCondition_Operator_STATUS("Equal")
	MatchCondition_Operator_STATUS_GeoMatch           = MatchCondition_Operator_STATUS("GeoMatch")
	MatchCondition_Operator_STATUS_GreaterThan        = MatchCondition_Operator_STATUS("GreaterThan")
	MatchCondition_Operator_STATUS_GreaterThanOrEqual = MatchCondition_Operator_STATUS("GreaterThanOrEqual")
	MatchCondition_Operator_STATUS_IPMatch            = MatchCondition_Operator_STATUS("IPMatch")
	MatchCondition_Operator_STATUS_LessThan           = MatchCondition_Operator_STATUS("LessThan")
	MatchCondition_Operator_STATUS_LessThanOrEqual    = MatchCondition_Operator_STATUS("LessThanOrEqual")
	MatchCondition_Operator_STATUS_RegEx              = MatchCondition_Operator_STATUS("RegEx")
)

// Mapping from string to MatchCondition_Operator_STATUS
var matchCondition_Operator_STATUS_Values = map[string]MatchCondition_Operator_STATUS{
	"any":                MatchCondition_Operator_STATUS_Any,
	"beginswith":         MatchCondition_Operator_STATUS_BeginsWith,
	"contains":           MatchCondition_Operator_STATUS_Contains,
	"endswith":           MatchCondition_Operator_STATUS_EndsWith,
	"equal":              MatchCondition_Operator_STATUS_Equal,
	"geomatch":           MatchCondition_Operator_STATUS_GeoMatch,
	"greaterthan":        MatchCondition_Operator_STATUS_GreaterThan,
	"greaterthanorequal": MatchCondition_Operator_STATUS_GreaterThanOrEqual,
	"ipmatch":            MatchCondition_Operator_STATUS_IPMatch,
	"lessthan":           MatchCondition_Operator_STATUS_LessThan,
	"lessthanorequal":    MatchCondition_Operator_STATUS_LessThanOrEqual,
	"regex":              MatchCondition_Operator_STATUS_RegEx,
}

// Describes what transforms applied before matching.
// +kubebuilder:validation:Enum={"Lowercase","RemoveNulls","Trim","Uppercase","UrlDecode","UrlEncode"}
type TransformType string

const (
	TransformType_Lowercase   = TransformType("Lowercase")
	TransformType_RemoveNulls = TransformType("RemoveNulls")
	TransformType_Trim        = TransformType("Trim")
	TransformType_Uppercase   = TransformType("Uppercase")
	TransformType_UrlDecode   = TransformType("UrlDecode")
	TransformType_UrlEncode   = TransformType("UrlEncode")
)

// Mapping from string to TransformType
var transformType_Values = map[string]TransformType{
	"lowercase":   TransformType_Lowercase,
	"removenulls": TransformType_RemoveNulls,
	"trim":        TransformType_Trim,
	"uppercase":   TransformType_Uppercase,
	"urldecode":   TransformType_UrlDecode,
	"urlencode":   TransformType_UrlEncode,
}

// Describes what transforms applied before matching.
type TransformType_STATUS string

const (
	TransformType_STATUS_Lowercase   = TransformType_STATUS("Lowercase")
	TransformType_STATUS_RemoveNulls = TransformType_STATUS("RemoveNulls")
	TransformType_STATUS_Trim        = TransformType_STATUS("Trim")
	TransformType_STATUS_Uppercase   = TransformType_STATUS("Uppercase")
	TransformType_STATUS_UrlDecode   = TransformType_STATUS("UrlDecode")
	TransformType_STATUS_UrlEncode   = TransformType_STATUS("UrlEncode")
)

// Mapping from string to TransformType_STATUS
var transformType_STATUS_Values = map[string]TransformType_STATUS{
	"lowercase":   TransformType_STATUS_Lowercase,
	"removenulls": TransformType_STATUS_RemoveNulls,
	"trim":        TransformType_STATUS_Trim,
	"uppercase":   TransformType_STATUS_Uppercase,
	"urldecode":   TransformType_STATUS_UrlDecode,
	"urlencode":   TransformType_STATUS_UrlEncode,
}

// Describes if the managed rule is in enabled or disabled state.
// +kubebuilder:validation:Enum={"Disabled","Enabled"}
type ManagedRuleEnabledState string

const (
	ManagedRuleEnabledState_Disabled = ManagedRuleEnabledState("Disabled")
	ManagedRuleEnabledState_Enabled  = ManagedRuleEnabledState("Enabled")
)

// Mapping from string to ManagedRuleEnabledState
var managedRuleEnabledState_Values = map[string]ManagedRuleEnabledState{
	"disabled": ManagedRuleEnabledState_Disabled,
	"enabled":  ManagedRuleEnabledState_Enabled,
}

// Describes if the managed rule is in enabled or disabled state.
type ManagedRuleEnabledState_STATUS string

const (
	ManagedRuleEnabledState_STATUS_Disabled = ManagedRuleEnabledState_STATUS("Disabled")
	ManagedRuleEnabledState_STATUS_Enabled  = ManagedRuleEnabledState_STATUS("Enabled")
)

// Mapping from string to ManagedRuleEnabledState_STATUS
var managedRuleEnabledState_STATUS_Values = map[string]ManagedRuleEnabledState_STATUS{
	"disabled": ManagedRuleEnabledState_STATUS_Disabled,
	"enabled":  ManagedRuleEnabledState_STATUS_Enabled,
}

func init() {
	SchemeBuilder.Register(&WebApplicationFirewallPolicy{}, &WebApplicationFirewallPolicyList{})
}
