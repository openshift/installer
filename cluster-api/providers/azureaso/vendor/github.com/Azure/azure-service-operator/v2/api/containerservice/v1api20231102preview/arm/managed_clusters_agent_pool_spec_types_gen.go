// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package arm

import "github.com/Azure/azure-service-operator/v2/pkg/genruntime"

type ManagedClustersAgentPool_Spec struct {
	Name string `json:"name,omitempty"`

	// Properties: Properties of an agent pool.
	Properties *ManagedClusterAgentPoolProfileProperties `json:"properties,omitempty"`
}

var _ genruntime.ARMResourceSpec = &ManagedClustersAgentPool_Spec{}

// GetAPIVersion returns the ARM API version of the resource. This is always "2023-11-02-preview"
func (pool ManagedClustersAgentPool_Spec) GetAPIVersion() string {
	return "2023-11-02-preview"
}

// GetName returns the Name of the resource
func (pool *ManagedClustersAgentPool_Spec) GetName() string {
	return pool.Name
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.ContainerService/managedClusters/agentPools"
func (pool *ManagedClustersAgentPool_Spec) GetType() string {
	return "Microsoft.ContainerService/managedClusters/agentPools"
}

// Properties for the container service agent pool profile.
type ManagedClusterAgentPoolProfileProperties struct {
	// ArtifactStreamingProfile: Configuration for using artifact streaming on AKS.
	ArtifactStreamingProfile *AgentPoolArtifactStreamingProfile `json:"artifactStreamingProfile,omitempty"`

	// AvailabilityZones: The list of Availability zones to use for nodes. This can only be specified if the AgentPoolType
	// property is 'VirtualMachineScaleSets'.
	AvailabilityZones          []string `json:"availabilityZones"`
	CapacityReservationGroupID *string  `json:"capacityReservationGroupID,omitempty"`

	// Count: Number of agents (VMs) to host docker containers. Allowed values must be in the range of 0 to 1000 (inclusive)
	// for user pools and in the range of 1 to 1000 (inclusive) for system pools. The default value is 1.
	Count *int `json:"count,omitempty"`

	// CreationData: CreationData to be used to specify the source Snapshot ID if the node pool will be created/upgraded using
	// a snapshot.
	CreationData *CreationData `json:"creationData,omitempty"`

	// EnableAutoScaling: Whether to enable auto-scaler
	EnableAutoScaling *bool `json:"enableAutoScaling,omitempty"`

	// EnableCustomCATrust: When set to true, AKS adds a label to the node indicating that the feature is enabled and deploys a
	// daemonset along with host services to sync custom certificate authorities from user-provided list of base64 encoded
	// certificates into node trust stores. Defaults to false.
	EnableCustomCATrust *bool `json:"enableCustomCATrust,omitempty"`

	// EnableEncryptionAtHost: This is only supported on certain VM sizes and in certain Azure regions. For more information,
	// see: https://docs.microsoft.com/azure/aks/enable-host-encryption
	EnableEncryptionAtHost *bool `json:"enableEncryptionAtHost,omitempty"`

	// EnableFIPS: See [Add a FIPS-enabled node
	// pool](https://docs.microsoft.com/azure/aks/use-multiple-node-pools#add-a-fips-enabled-node-pool-preview) for more
	// details.
	EnableFIPS *bool `json:"enableFIPS,omitempty"`

	// EnableNodePublicIP: Some scenarios may require nodes in a node pool to receive their own dedicated public IP addresses.
	// A common scenario is for gaming workloads, where a console needs to make a direct connection to a cloud virtual machine
	// to minimize hops. For more information see [assigning a public IP per
	// node](https://docs.microsoft.com/azure/aks/use-multiple-node-pools#assign-a-public-ip-per-node-for-your-node-pools). The
	// default is false.
	EnableNodePublicIP *bool `json:"enableNodePublicIP,omitempty"`

	// EnableUltraSSD: Whether to enable UltraSSD
	EnableUltraSSD *bool `json:"enableUltraSSD,omitempty"`

	// GpuInstanceProfile: GPUInstanceProfile to be used to specify GPU MIG instance profile for supported GPU VM SKU.
	GpuInstanceProfile *GPUInstanceProfile `json:"gpuInstanceProfile,omitempty"`

	// GpuProfile: The GPU settings of an agent pool.
	GpuProfile  *AgentPoolGPUProfile `json:"gpuProfile,omitempty"`
	HostGroupID *string              `json:"hostGroupID,omitempty"`

	// KubeletConfig: The Kubelet configuration on the agent pool nodes.
	KubeletConfig *KubeletConfig `json:"kubeletConfig,omitempty"`

	// KubeletDiskType: Determines the placement of emptyDir volumes, container runtime data root, and Kubelet ephemeral
	// storage.
	KubeletDiskType *KubeletDiskType `json:"kubeletDiskType,omitempty"`

	// LinuxOSConfig: The OS configuration of Linux agent nodes.
	LinuxOSConfig *LinuxOSConfig `json:"linuxOSConfig,omitempty"`

	// MaxCount: The maximum number of nodes for auto-scaling
	MaxCount *int `json:"maxCount,omitempty"`

	// MaxPods: The maximum number of pods that can run on a node.
	MaxPods *int `json:"maxPods,omitempty"`

	// MessageOfTheDay: A base64-encoded string which will be written to /etc/motd after decoding. This allows customization of
	// the message of the day for Linux nodes. It must not be specified for Windows nodes. It must be a static string (i.e.,
	// will be printed raw and not be executed as a script).
	MessageOfTheDay *string `json:"messageOfTheDay,omitempty"`

	// MinCount: The minimum number of nodes for auto-scaling
	MinCount *int `json:"minCount,omitempty"`

	// Mode: A cluster must have at least one 'System' Agent Pool at all times. For additional information on agent pool
	// restrictions  and best practices, see: https://docs.microsoft.com/azure/aks/use-system-pools
	Mode *AgentPoolMode `json:"mode,omitempty"`

	// NetworkProfile: Network-related settings of an agent pool.
	NetworkProfile *AgentPoolNetworkProfile `json:"networkProfile,omitempty"`

	// NodeInitializationTaints: These taints will not be reconciled by AKS and can be removed with a kubectl call. This field
	// can be modified after node pool is created, but nodes will not be recreated with new taints until another operation that
	// requires recreation (e.g. node image upgrade) happens. These taints allow for required configuration to run before the
	// node is ready to accept workloads, for example 'key1=value1:NoSchedule' that then can be removed with `kubectl taint
	// nodes node1 key1=value1:NoSchedule-`
	NodeInitializationTaints []string `json:"nodeInitializationTaints"`

	// NodeLabels: The node labels to be persisted across all nodes in agent pool.
	NodeLabels           map[string]string `json:"nodeLabels" serializationType:"explicitEmptyCollection"`
	NodePublicIPPrefixID *string           `json:"nodePublicIPPrefixID,omitempty"`

	// NodeTaints: The taints added to new nodes during node pool create and scale. For example, key=value:NoSchedule.
	NodeTaints []string `json:"nodeTaints" serializationType:"explicitEmptyCollection"`

	// OrchestratorVersion: Both patch version <major.minor.patch> and <major.minor> are supported. When <major.minor> is
	// specified, the latest supported patch version is chosen automatically. Updating the agent pool with the same
	// <major.minor> once it has been created will not trigger an upgrade, even if a newer patch version is available. As a
	// best practice, you should upgrade all node pools in an AKS cluster to the same Kubernetes version. The node pool version
	// must have the same major version as the control plane. The node pool minor version must be within two minor versions of
	// the control plane version. The node pool version cannot be greater than the control plane version. For more information
	// see [upgrading a node pool](https://docs.microsoft.com/azure/aks/use-multiple-node-pools#upgrade-a-node-pool).
	OrchestratorVersion *string `json:"orchestratorVersion,omitempty"`
	OsDiskSizeGB        *int    `json:"osDiskSizeGB,omitempty"`

	// OsDiskType: The default is 'Ephemeral' if the VM supports it and has a cache disk larger than the requested
	// OSDiskSizeGB. Otherwise,  defaults to 'Managed'. May not be changed after creation. For more information see [Ephemeral
	// OS](https://docs.microsoft.com/azure/aks/cluster-configuration#ephemeral-os).
	OsDiskType *OSDiskType `json:"osDiskType,omitempty"`

	// OsSKU: Specifies the OS SKU used by the agent pool. If not specified, the default is Ubuntu if OSType=Linux or
	// Windows2019 if  OSType=Windows. And the default Windows OSSKU will be changed to Windows2022 after Windows2019 is
	// deprecated.
	OsSKU *OSSKU `json:"osSKU,omitempty"`

	// OsType: The operating system type. The default is Linux.
	OsType      *OSType `json:"osType,omitempty"`
	PodSubnetID *string `json:"podSubnetID,omitempty"`

	// PowerState: When an Agent Pool is first created it is initially Running. The Agent Pool can be stopped by setting this
	// field to Stopped. A stopped Agent Pool stops all of its VMs and does not accrue billing charges. An Agent Pool can only
	// be stopped if it is Running and provisioning state is Succeeded
	PowerState                *PowerState `json:"powerState,omitempty"`
	ProximityPlacementGroupID *string     `json:"proximityPlacementGroupID,omitempty"`

	// ScaleDownMode: This also effects the cluster autoscaler behavior. If not specified, it defaults to Delete.
	ScaleDownMode *ScaleDownMode `json:"scaleDownMode,omitempty"`

	// ScaleSetEvictionPolicy: This cannot be specified unless the scaleSetPriority is 'Spot'. If not specified, the default is
	// 'Delete'.
	ScaleSetEvictionPolicy *ScaleSetEvictionPolicy `json:"scaleSetEvictionPolicy,omitempty"`

	// ScaleSetPriority: The Virtual Machine Scale Set priority. If not specified, the default is 'Regular'.
	ScaleSetPriority *ScaleSetPriority `json:"scaleSetPriority,omitempty"`

	// SecurityProfile: The security settings of an agent pool.
	SecurityProfile *AgentPoolSecurityProfile `json:"securityProfile,omitempty"`

	// SpotMaxPrice: Possible values are any decimal value greater than zero or -1 which indicates the willingness to pay any
	// on-demand price. For more details on spot pricing, see [spot VMs
	// pricing](https://docs.microsoft.com/azure/virtual-machines/spot-vms#pricing)
	SpotMaxPrice *float64 `json:"spotMaxPrice,omitempty"`

	// Tags: The tags to be persisted on the agent pool virtual machine scale set.
	Tags map[string]string `json:"tags" serializationType:"explicitEmptyCollection"`

	// Type: The type of Agent Pool.
	Type *AgentPoolType `json:"type,omitempty"`

	// UpgradeSettings: Settings for upgrading the agentpool
	UpgradeSettings           *AgentPoolUpgradeSettings `json:"upgradeSettings,omitempty"`
	VirtualMachineNodesStatus []VirtualMachineNodes     `json:"virtualMachineNodesStatus"`

	// VirtualMachinesProfile: Specifications on VirtualMachines agent pool.
	VirtualMachinesProfile *VirtualMachinesProfile `json:"virtualMachinesProfile,omitempty"`

	// VmSize: VM size availability varies by region. If a node contains insufficient compute resources (memory, cpu, etc) pods
	// might fail to run correctly. For more details on restricted VM sizes, see:
	// https://docs.microsoft.com/azure/aks/quotas-skus-regions
	VmSize       *string `json:"vmSize,omitempty"`
	VnetSubnetID *string `json:"vnetSubnetID,omitempty"`

	// WindowsProfile: The Windows agent pool's specific profile.
	WindowsProfile *AgentPoolWindowsProfile `json:"windowsProfile,omitempty"`

	// WorkloadRuntime: Determines the type of workload a node can run.
	WorkloadRuntime *WorkloadRuntime `json:"workloadRuntime,omitempty"`
}

type AgentPoolArtifactStreamingProfile struct {
	Enabled *bool `json:"enabled,omitempty"`
}

type AgentPoolGPUProfile struct {
	InstallGPUDriver *bool `json:"installGPUDriver,omitempty"`
}

// +kubebuilder:validation:Enum={"System","User"}
type AgentPoolMode string

const (
	AgentPoolMode_System = AgentPoolMode("System")
	AgentPoolMode_User   = AgentPoolMode("User")
)

// Mapping from string to AgentPoolMode
var agentPoolMode_Values = map[string]AgentPoolMode{
	"system": AgentPoolMode_System,
	"user":   AgentPoolMode_User,
}

type AgentPoolNetworkProfile struct {
	AllowedHostPorts          []PortRange `json:"allowedHostPorts"`
	ApplicationSecurityGroups []string    `json:"applicationSecurityGroups,omitempty"`
	NodePublicIPTags          []IPTag     `json:"nodePublicIPTags"`
}

type AgentPoolSecurityProfile struct {
	EnableSecureBoot *bool               `json:"enableSecureBoot,omitempty"`
	EnableVTPM       *bool               `json:"enableVTPM,omitempty"`
	SshAccess        *AgentPoolSSHAccess `json:"sshAccess,omitempty"`
}

// +kubebuilder:validation:Enum={"AvailabilitySet","VirtualMachineScaleSets","VirtualMachines"}
type AgentPoolType string

const (
	AgentPoolType_AvailabilitySet         = AgentPoolType("AvailabilitySet")
	AgentPoolType_VirtualMachineScaleSets = AgentPoolType("VirtualMachineScaleSets")
	AgentPoolType_VirtualMachines         = AgentPoolType("VirtualMachines")
)

// Mapping from string to AgentPoolType
var agentPoolType_Values = map[string]AgentPoolType{
	"availabilityset":         AgentPoolType_AvailabilitySet,
	"virtualmachinescalesets": AgentPoolType_VirtualMachineScaleSets,
	"virtualmachines":         AgentPoolType_VirtualMachines,
}

type AgentPoolUpgradeSettings struct {
	DrainTimeoutInMinutes     *int    `json:"drainTimeoutInMinutes,omitempty"`
	MaxSurge                  *string `json:"maxSurge,omitempty"`
	NodeSoakDurationInMinutes *int    `json:"nodeSoakDurationInMinutes,omitempty"`
}

type AgentPoolWindowsProfile struct {
	DisableOutboundNat *bool `json:"disableOutboundNat,omitempty"`
}

// +kubebuilder:validation:Enum={"MIG1g","MIG2g","MIG3g","MIG4g","MIG7g"}
type GPUInstanceProfile string

const (
	GPUInstanceProfile_MIG1G = GPUInstanceProfile("MIG1g")
	GPUInstanceProfile_MIG2G = GPUInstanceProfile("MIG2g")
	GPUInstanceProfile_MIG3G = GPUInstanceProfile("MIG3g")
	GPUInstanceProfile_MIG4G = GPUInstanceProfile("MIG4g")
	GPUInstanceProfile_MIG7G = GPUInstanceProfile("MIG7g")
)

// Mapping from string to GPUInstanceProfile
var gPUInstanceProfile_Values = map[string]GPUInstanceProfile{
	"mig1g": GPUInstanceProfile_MIG1G,
	"mig2g": GPUInstanceProfile_MIG2G,
	"mig3g": GPUInstanceProfile_MIG3G,
	"mig4g": GPUInstanceProfile_MIG4G,
	"mig7g": GPUInstanceProfile_MIG7G,
}

type KubeletConfig struct {
	AllowedUnsafeSysctls  []string `json:"allowedUnsafeSysctls"`
	ContainerLogMaxFiles  *int     `json:"containerLogMaxFiles,omitempty"`
	ContainerLogMaxSizeMB *int     `json:"containerLogMaxSizeMB,omitempty"`
	CpuCfsQuota           *bool    `json:"cpuCfsQuota,omitempty"`
	CpuCfsQuotaPeriod     *string  `json:"cpuCfsQuotaPeriod,omitempty"`
	CpuManagerPolicy      *string  `json:"cpuManagerPolicy,omitempty"`
	FailSwapOn            *bool    `json:"failSwapOn,omitempty"`
	ImageGcHighThreshold  *int     `json:"imageGcHighThreshold,omitempty"`
	ImageGcLowThreshold   *int     `json:"imageGcLowThreshold,omitempty"`
	PodMaxPids            *int     `json:"podMaxPids,omitempty"`
	TopologyManagerPolicy *string  `json:"topologyManagerPolicy,omitempty"`
}

// +kubebuilder:validation:Enum={"OS","Temporary"}
type KubeletDiskType string

const (
	KubeletDiskType_OS        = KubeletDiskType("OS")
	KubeletDiskType_Temporary = KubeletDiskType("Temporary")
)

// Mapping from string to KubeletDiskType
var kubeletDiskType_Values = map[string]KubeletDiskType{
	"os":        KubeletDiskType_OS,
	"temporary": KubeletDiskType_Temporary,
}

type LinuxOSConfig struct {
	SwapFileSizeMB             *int          `json:"swapFileSizeMB,omitempty"`
	Sysctls                    *SysctlConfig `json:"sysctls,omitempty"`
	TransparentHugePageDefrag  *string       `json:"transparentHugePageDefrag,omitempty"`
	TransparentHugePageEnabled *string       `json:"transparentHugePageEnabled,omitempty"`
}

// +kubebuilder:validation:Enum={"Ephemeral","Managed"}
type OSDiskType string

const (
	OSDiskType_Ephemeral = OSDiskType("Ephemeral")
	OSDiskType_Managed   = OSDiskType("Managed")
)

// Mapping from string to OSDiskType
var oSDiskType_Values = map[string]OSDiskType{
	"ephemeral": OSDiskType_Ephemeral,
	"managed":   OSDiskType_Managed,
}

// +kubebuilder:validation:Enum={"AzureLinux","CBLMariner","Mariner","Ubuntu","Windows2019","Windows2022","WindowsAnnual"}
type OSSKU string

const (
	OSSKU_AzureLinux    = OSSKU("AzureLinux")
	OSSKU_CBLMariner    = OSSKU("CBLMariner")
	OSSKU_Mariner       = OSSKU("Mariner")
	OSSKU_Ubuntu        = OSSKU("Ubuntu")
	OSSKU_Windows2019   = OSSKU("Windows2019")
	OSSKU_Windows2022   = OSSKU("Windows2022")
	OSSKU_WindowsAnnual = OSSKU("WindowsAnnual")
)

// Mapping from string to OSSKU
var oSSKU_Values = map[string]OSSKU{
	"azurelinux":    OSSKU_AzureLinux,
	"cblmariner":    OSSKU_CBLMariner,
	"mariner":       OSSKU_Mariner,
	"ubuntu":        OSSKU_Ubuntu,
	"windows2019":   OSSKU_Windows2019,
	"windows2022":   OSSKU_Windows2022,
	"windowsannual": OSSKU_WindowsAnnual,
}

// +kubebuilder:validation:Enum={"Linux","Windows"}
type OSType string

const (
	OSType_Linux   = OSType("Linux")
	OSType_Windows = OSType("Windows")
)

// Mapping from string to OSType
var oSType_Values = map[string]OSType{
	"linux":   OSType_Linux,
	"windows": OSType_Windows,
}

type PowerState struct {
	Code *PowerState_Code `json:"code,omitempty"`
}

// +kubebuilder:validation:Enum={"Deallocate","Delete"}
type ScaleDownMode string

const (
	ScaleDownMode_Deallocate = ScaleDownMode("Deallocate")
	ScaleDownMode_Delete     = ScaleDownMode("Delete")
)

// Mapping from string to ScaleDownMode
var scaleDownMode_Values = map[string]ScaleDownMode{
	"deallocate": ScaleDownMode_Deallocate,
	"delete":     ScaleDownMode_Delete,
}

// +kubebuilder:validation:Enum={"Deallocate","Delete"}
type ScaleSetEvictionPolicy string

const (
	ScaleSetEvictionPolicy_Deallocate = ScaleSetEvictionPolicy("Deallocate")
	ScaleSetEvictionPolicy_Delete     = ScaleSetEvictionPolicy("Delete")
)

// Mapping from string to ScaleSetEvictionPolicy
var scaleSetEvictionPolicy_Values = map[string]ScaleSetEvictionPolicy{
	"deallocate": ScaleSetEvictionPolicy_Deallocate,
	"delete":     ScaleSetEvictionPolicy_Delete,
}

// +kubebuilder:validation:Enum={"Regular","Spot"}
type ScaleSetPriority string

const (
	ScaleSetPriority_Regular = ScaleSetPriority("Regular")
	ScaleSetPriority_Spot    = ScaleSetPriority("Spot")
)

// Mapping from string to ScaleSetPriority
var scaleSetPriority_Values = map[string]ScaleSetPriority{
	"regular": ScaleSetPriority_Regular,
	"spot":    ScaleSetPriority_Spot,
}

type VirtualMachineNodes struct {
	Count *int    `json:"count,omitempty"`
	Size  *string `json:"size,omitempty"`
}

type VirtualMachinesProfile struct {
	Scale *ScaleProfile `json:"scale,omitempty"`
}

// +kubebuilder:validation:Enum={"KataMshvVmIsolation","OCIContainer","WasmWasi"}
type WorkloadRuntime string

const (
	WorkloadRuntime_KataMshvVmIsolation = WorkloadRuntime("KataMshvVmIsolation")
	WorkloadRuntime_OCIContainer        = WorkloadRuntime("OCIContainer")
	WorkloadRuntime_WasmWasi            = WorkloadRuntime("WasmWasi")
)

// Mapping from string to WorkloadRuntime
var workloadRuntime_Values = map[string]WorkloadRuntime{
	"katamshvvmisolation": WorkloadRuntime_KataMshvVmIsolation,
	"ocicontainer":        WorkloadRuntime_OCIContainer,
	"wasmwasi":            WorkloadRuntime_WasmWasi,
}

// +kubebuilder:validation:Enum={"Disabled","LocalUser"}
type AgentPoolSSHAccess string

const (
	AgentPoolSSHAccess_Disabled  = AgentPoolSSHAccess("Disabled")
	AgentPoolSSHAccess_LocalUser = AgentPoolSSHAccess("LocalUser")
)

// Mapping from string to AgentPoolSSHAccess
var agentPoolSSHAccess_Values = map[string]AgentPoolSSHAccess{
	"disabled":  AgentPoolSSHAccess_Disabled,
	"localuser": AgentPoolSSHAccess_LocalUser,
}

type IPTag struct {
	IpTagType *string `json:"ipTagType,omitempty"`
	Tag       *string `json:"tag,omitempty"`
}

type PortRange struct {
	PortEnd   *int                `json:"portEnd,omitempty"`
	PortStart *int                `json:"portStart,omitempty"`
	Protocol  *PortRange_Protocol `json:"protocol,omitempty"`
}

// +kubebuilder:validation:Enum={"Running","Stopped"}
type PowerState_Code string

const (
	PowerState_Code_Running = PowerState_Code("Running")
	PowerState_Code_Stopped = PowerState_Code("Stopped")
)

// Mapping from string to PowerState_Code
var powerState_Code_Values = map[string]PowerState_Code{
	"running": PowerState_Code_Running,
	"stopped": PowerState_Code_Stopped,
}

type ScaleProfile struct {
	Manual []ManualScaleProfile `json:"manual"`
}

type SysctlConfig struct {
	FsAioMaxNr                     *int    `json:"fsAioMaxNr,omitempty"`
	FsFileMax                      *int    `json:"fsFileMax,omitempty"`
	FsInotifyMaxUserWatches        *int    `json:"fsInotifyMaxUserWatches,omitempty"`
	FsNrOpen                       *int    `json:"fsNrOpen,omitempty"`
	KernelThreadsMax               *int    `json:"kernelThreadsMax,omitempty"`
	NetCoreNetdevMaxBacklog        *int    `json:"netCoreNetdevMaxBacklog,omitempty"`
	NetCoreOptmemMax               *int    `json:"netCoreOptmemMax,omitempty"`
	NetCoreRmemDefault             *int    `json:"netCoreRmemDefault,omitempty"`
	NetCoreRmemMax                 *int    `json:"netCoreRmemMax,omitempty"`
	NetCoreSomaxconn               *int    `json:"netCoreSomaxconn,omitempty"`
	NetCoreWmemDefault             *int    `json:"netCoreWmemDefault,omitempty"`
	NetCoreWmemMax                 *int    `json:"netCoreWmemMax,omitempty"`
	NetIpv4IpLocalPortRange        *string `json:"netIpv4IpLocalPortRange,omitempty"`
	NetIpv4NeighDefaultGcThresh1   *int    `json:"netIpv4NeighDefaultGcThresh1,omitempty"`
	NetIpv4NeighDefaultGcThresh2   *int    `json:"netIpv4NeighDefaultGcThresh2,omitempty"`
	NetIpv4NeighDefaultGcThresh3   *int    `json:"netIpv4NeighDefaultGcThresh3,omitempty"`
	NetIpv4TcpFinTimeout           *int    `json:"netIpv4TcpFinTimeout,omitempty"`
	NetIpv4TcpKeepaliveProbes      *int    `json:"netIpv4TcpKeepaliveProbes,omitempty"`
	NetIpv4TcpKeepaliveTime        *int    `json:"netIpv4TcpKeepaliveTime,omitempty"`
	NetIpv4TcpMaxSynBacklog        *int    `json:"netIpv4TcpMaxSynBacklog,omitempty"`
	NetIpv4TcpMaxTwBuckets         *int    `json:"netIpv4TcpMaxTwBuckets,omitempty"`
	NetIpv4TcpTwReuse              *bool   `json:"netIpv4TcpTwReuse,omitempty"`
	NetIpv4TcpkeepaliveIntvl       *int    `json:"netIpv4TcpkeepaliveIntvl,omitempty"`
	NetNetfilterNfConntrackBuckets *int    `json:"netNetfilterNfConntrackBuckets,omitempty"`
	NetNetfilterNfConntrackMax     *int    `json:"netNetfilterNfConntrackMax,omitempty"`
	VmMaxMapCount                  *int    `json:"vmMaxMapCount,omitempty"`
	VmSwappiness                   *int    `json:"vmSwappiness,omitempty"`
	VmVfsCachePressure             *int    `json:"vmVfsCachePressure,omitempty"`
}

type ManualScaleProfile struct {
	Count *int     `json:"count,omitempty"`
	Sizes []string `json:"sizes"`
}

// +kubebuilder:validation:Enum={"TCP","UDP"}
type PortRange_Protocol string

const (
	PortRange_Protocol_TCP = PortRange_Protocol("TCP")
	PortRange_Protocol_UDP = PortRange_Protocol("UDP")
)

// Mapping from string to PortRange_Protocol
var portRange_Protocol_Values = map[string]PortRange_Protocol{
	"tcp": PortRange_Protocol_TCP,
	"udp": PortRange_Protocol_UDP,
}
