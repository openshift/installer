// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20230101

import (
	"fmt"
	v20230101s "github.com/Azure/azure-service-operator/v2/api/dataprotection/v1api20230101/storage"
	"github.com/Azure/azure-service-operator/v2/internal/reflecthelpers"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/pkg/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
	"sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Generator information:
// - Generated from: /dataprotection/resource-manager/Microsoft.DataProtection/stable/2023-01-01/dataprotection.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataProtection/backupVaults/{vaultName}/backupPolicies/{backupPolicyName}
type BackupVaultsBackupPolicy struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              BackupVaults_BackupPolicy_Spec   `json:"spec,omitempty"`
	Status            BackupVaults_BackupPolicy_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &BackupVaultsBackupPolicy{}

// GetConditions returns the conditions of the resource
func (policy *BackupVaultsBackupPolicy) GetConditions() conditions.Conditions {
	return policy.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (policy *BackupVaultsBackupPolicy) SetConditions(conditions conditions.Conditions) {
	policy.Status.Conditions = conditions
}

var _ conversion.Convertible = &BackupVaultsBackupPolicy{}

// ConvertFrom populates our BackupVaultsBackupPolicy from the provided hub BackupVaultsBackupPolicy
func (policy *BackupVaultsBackupPolicy) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*v20230101s.BackupVaultsBackupPolicy)
	if !ok {
		return fmt.Errorf("expected dataprotection/v1api20230101/storage/BackupVaultsBackupPolicy but received %T instead", hub)
	}

	return policy.AssignProperties_From_BackupVaultsBackupPolicy(source)
}

// ConvertTo populates the provided hub BackupVaultsBackupPolicy from our BackupVaultsBackupPolicy
func (policy *BackupVaultsBackupPolicy) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*v20230101s.BackupVaultsBackupPolicy)
	if !ok {
		return fmt.Errorf("expected dataprotection/v1api20230101/storage/BackupVaultsBackupPolicy but received %T instead", hub)
	}

	return policy.AssignProperties_To_BackupVaultsBackupPolicy(destination)
}

// +kubebuilder:webhook:path=/mutate-dataprotection-azure-com-v1api20230101-backupvaultsbackuppolicy,mutating=true,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=dataprotection.azure.com,resources=backupvaultsbackuppolicies,verbs=create;update,versions=v1api20230101,name=default.v1api20230101.backupvaultsbackuppolicies.dataprotection.azure.com,admissionReviewVersions=v1

var _ admission.Defaulter = &BackupVaultsBackupPolicy{}

// Default applies defaults to the BackupVaultsBackupPolicy resource
func (policy *BackupVaultsBackupPolicy) Default() {
	policy.defaultImpl()
	var temp any = policy
	if runtimeDefaulter, ok := temp.(genruntime.Defaulter); ok {
		runtimeDefaulter.CustomDefault()
	}
}

// defaultAzureName defaults the Azure name of the resource to the Kubernetes name
func (policy *BackupVaultsBackupPolicy) defaultAzureName() {
	if policy.Spec.AzureName == "" {
		policy.Spec.AzureName = policy.Name
	}
}

// defaultImpl applies the code generated defaults to the BackupVaultsBackupPolicy resource
func (policy *BackupVaultsBackupPolicy) defaultImpl() { policy.defaultAzureName() }

var _ genruntime.ImportableResource = &BackupVaultsBackupPolicy{}

// InitializeSpec initializes the spec for this resource from the given status
func (policy *BackupVaultsBackupPolicy) InitializeSpec(status genruntime.ConvertibleStatus) error {
	if s, ok := status.(*BackupVaults_BackupPolicy_STATUS); ok {
		return policy.Spec.Initialize_From_BackupVaults_BackupPolicy_STATUS(s)
	}

	return fmt.Errorf("expected Status of type BackupVaults_BackupPolicy_STATUS but received %T instead", status)
}

var _ genruntime.KubernetesResource = &BackupVaultsBackupPolicy{}

// AzureName returns the Azure name of the resource
func (policy *BackupVaultsBackupPolicy) AzureName() string {
	return policy.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2023-01-01"
func (policy BackupVaultsBackupPolicy) GetAPIVersion() string {
	return string(APIVersion_Value)
}

// GetResourceScope returns the scope of the resource
func (policy *BackupVaultsBackupPolicy) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (policy *BackupVaultsBackupPolicy) GetSpec() genruntime.ConvertibleSpec {
	return &policy.Spec
}

// GetStatus returns the status of this resource
func (policy *BackupVaultsBackupPolicy) GetStatus() genruntime.ConvertibleStatus {
	return &policy.Status
}

// GetSupportedOperations returns the operations supported by the resource
func (policy *BackupVaultsBackupPolicy) GetSupportedOperations() []genruntime.ResourceOperation {
	return []genruntime.ResourceOperation{
		genruntime.ResourceOperationDelete,
		genruntime.ResourceOperationGet,
		genruntime.ResourceOperationPut,
	}
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.DataProtection/backupVaults/backupPolicies"
func (policy *BackupVaultsBackupPolicy) GetType() string {
	return "Microsoft.DataProtection/backupVaults/backupPolicies"
}

// NewEmptyStatus returns a new empty (blank) status
func (policy *BackupVaultsBackupPolicy) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &BackupVaults_BackupPolicy_STATUS{}
}

// Owner returns the ResourceReference of the owner
func (policy *BackupVaultsBackupPolicy) Owner() *genruntime.ResourceReference {
	group, kind := genruntime.LookupOwnerGroupKind(policy.Spec)
	return policy.Spec.Owner.AsResourceReference(group, kind)
}

// SetStatus sets the status of this resource
func (policy *BackupVaultsBackupPolicy) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*BackupVaults_BackupPolicy_STATUS); ok {
		policy.Status = *st
		return nil
	}

	// Convert status to required version
	var st BackupVaults_BackupPolicy_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return errors.Wrap(err, "failed to convert status")
	}

	policy.Status = st
	return nil
}

// +kubebuilder:webhook:path=/validate-dataprotection-azure-com-v1api20230101-backupvaultsbackuppolicy,mutating=false,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=dataprotection.azure.com,resources=backupvaultsbackuppolicies,verbs=create;update,versions=v1api20230101,name=validate.v1api20230101.backupvaultsbackuppolicies.dataprotection.azure.com,admissionReviewVersions=v1

var _ admission.Validator = &BackupVaultsBackupPolicy{}

// ValidateCreate validates the creation of the resource
func (policy *BackupVaultsBackupPolicy) ValidateCreate() (admission.Warnings, error) {
	validations := policy.createValidations()
	var temp any = policy
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.CreateValidations()...)
	}
	return genruntime.ValidateCreate(validations)
}

// ValidateDelete validates the deletion of the resource
func (policy *BackupVaultsBackupPolicy) ValidateDelete() (admission.Warnings, error) {
	validations := policy.deleteValidations()
	var temp any = policy
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.DeleteValidations()...)
	}
	return genruntime.ValidateDelete(validations)
}

// ValidateUpdate validates an update of the resource
func (policy *BackupVaultsBackupPolicy) ValidateUpdate(old runtime.Object) (admission.Warnings, error) {
	validations := policy.updateValidations()
	var temp any = policy
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.UpdateValidations()...)
	}
	return genruntime.ValidateUpdate(old, validations)
}

// createValidations validates the creation of the resource
func (policy *BackupVaultsBackupPolicy) createValidations() []func() (admission.Warnings, error) {
	return []func() (admission.Warnings, error){policy.validateResourceReferences, policy.validateOwnerReference}
}

// deleteValidations validates the deletion of the resource
func (policy *BackupVaultsBackupPolicy) deleteValidations() []func() (admission.Warnings, error) {
	return nil
}

// updateValidations validates the update of the resource
func (policy *BackupVaultsBackupPolicy) updateValidations() []func(old runtime.Object) (admission.Warnings, error) {
	return []func(old runtime.Object) (admission.Warnings, error){
		func(old runtime.Object) (admission.Warnings, error) {
			return policy.validateResourceReferences()
		},
		policy.validateWriteOnceProperties,
		func(old runtime.Object) (admission.Warnings, error) {
			return policy.validateOwnerReference()
		},
	}
}

// validateOwnerReference validates the owner field
func (policy *BackupVaultsBackupPolicy) validateOwnerReference() (admission.Warnings, error) {
	return genruntime.ValidateOwner(policy)
}

// validateResourceReferences validates all resource references
func (policy *BackupVaultsBackupPolicy) validateResourceReferences() (admission.Warnings, error) {
	refs, err := reflecthelpers.FindResourceReferences(&policy.Spec)
	if err != nil {
		return nil, err
	}
	return genruntime.ValidateResourceReferences(refs)
}

// validateWriteOnceProperties validates all WriteOnce properties
func (policy *BackupVaultsBackupPolicy) validateWriteOnceProperties(old runtime.Object) (admission.Warnings, error) {
	oldObj, ok := old.(*BackupVaultsBackupPolicy)
	if !ok {
		return nil, nil
	}

	return genruntime.ValidateWriteOnceProperties(oldObj, policy)
}

// AssignProperties_From_BackupVaultsBackupPolicy populates our BackupVaultsBackupPolicy from the provided source BackupVaultsBackupPolicy
func (policy *BackupVaultsBackupPolicy) AssignProperties_From_BackupVaultsBackupPolicy(source *v20230101s.BackupVaultsBackupPolicy) error {

	// ObjectMeta
	policy.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec BackupVaults_BackupPolicy_Spec
	err := spec.AssignProperties_From_BackupVaults_BackupPolicy_Spec(&source.Spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_BackupVaults_BackupPolicy_Spec() to populate field Spec")
	}
	policy.Spec = spec

	// Status
	var status BackupVaults_BackupPolicy_STATUS
	err = status.AssignProperties_From_BackupVaults_BackupPolicy_STATUS(&source.Status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_BackupVaults_BackupPolicy_STATUS() to populate field Status")
	}
	policy.Status = status

	// No error
	return nil
}

// AssignProperties_To_BackupVaultsBackupPolicy populates the provided destination BackupVaultsBackupPolicy from our BackupVaultsBackupPolicy
func (policy *BackupVaultsBackupPolicy) AssignProperties_To_BackupVaultsBackupPolicy(destination *v20230101s.BackupVaultsBackupPolicy) error {

	// ObjectMeta
	destination.ObjectMeta = *policy.ObjectMeta.DeepCopy()

	// Spec
	var spec v20230101s.BackupVaults_BackupPolicy_Spec
	err := policy.Spec.AssignProperties_To_BackupVaults_BackupPolicy_Spec(&spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_BackupVaults_BackupPolicy_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status v20230101s.BackupVaults_BackupPolicy_STATUS
	err = policy.Status.AssignProperties_To_BackupVaults_BackupPolicy_STATUS(&status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_BackupVaults_BackupPolicy_STATUS() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (policy *BackupVaultsBackupPolicy) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: policy.Spec.OriginalVersion(),
		Kind:    "BackupVaultsBackupPolicy",
	}
}

// +kubebuilder:object:root=true
// Generator information:
// - Generated from: /dataprotection/resource-manager/Microsoft.DataProtection/stable/2023-01-01/dataprotection.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataProtection/backupVaults/{vaultName}/backupPolicies/{backupPolicyName}
type BackupVaultsBackupPolicyList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []BackupVaultsBackupPolicy `json:"items"`
}

type BackupVaults_BackupPolicy_Spec struct {
	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName string `json:"azureName,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a dataprotection.azure.com/BackupVault resource
	Owner *genruntime.KnownResourceReference `group:"dataprotection.azure.com" json:"owner,omitempty" kind:"BackupVault"`

	// Properties: BaseBackupPolicyResource properties
	Properties *BaseBackupPolicy `json:"properties,omitempty"`
}

var _ genruntime.ARMTransformer = &BackupVaults_BackupPolicy_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (policy *BackupVaults_BackupPolicy_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if policy == nil {
		return nil, nil
	}
	result := &BackupVaults_BackupPolicy_Spec_ARM{}

	// Set property "Name":
	result.Name = resolved.Name

	// Set property "Properties":
	if policy.Properties != nil {
		properties_ARM, err := (*policy.Properties).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		properties := *properties_ARM.(*BaseBackupPolicy_ARM)
		result.Properties = &properties
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (policy *BackupVaults_BackupPolicy_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &BackupVaults_BackupPolicy_Spec_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (policy *BackupVaults_BackupPolicy_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(BackupVaults_BackupPolicy_Spec_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected BackupVaults_BackupPolicy_Spec_ARM, got %T", armInput)
	}

	// Set property "AzureName":
	policy.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property "Owner":
	policy.Owner = &genruntime.KnownResourceReference{
		Name:  owner.Name,
		ARMID: owner.ARMID,
	}

	// Set property "Properties":
	if typedInput.Properties != nil {
		var properties1 BaseBackupPolicy
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		policy.Properties = &properties
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &BackupVaults_BackupPolicy_Spec{}

// ConvertSpecFrom populates our BackupVaults_BackupPolicy_Spec from the provided source
func (policy *BackupVaults_BackupPolicy_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*v20230101s.BackupVaults_BackupPolicy_Spec)
	if ok {
		// Populate our instance from source
		return policy.AssignProperties_From_BackupVaults_BackupPolicy_Spec(src)
	}

	// Convert to an intermediate form
	src = &v20230101s.BackupVaults_BackupPolicy_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = policy.AssignProperties_From_BackupVaults_BackupPolicy_Spec(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our BackupVaults_BackupPolicy_Spec
func (policy *BackupVaults_BackupPolicy_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*v20230101s.BackupVaults_BackupPolicy_Spec)
	if ok {
		// Populate destination from our instance
		return policy.AssignProperties_To_BackupVaults_BackupPolicy_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &v20230101s.BackupVaults_BackupPolicy_Spec{}
	err := policy.AssignProperties_To_BackupVaults_BackupPolicy_Spec(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignProperties_From_BackupVaults_BackupPolicy_Spec populates our BackupVaults_BackupPolicy_Spec from the provided source BackupVaults_BackupPolicy_Spec
func (policy *BackupVaults_BackupPolicy_Spec) AssignProperties_From_BackupVaults_BackupPolicy_Spec(source *v20230101s.BackupVaults_BackupPolicy_Spec) error {

	// AzureName
	policy.AzureName = source.AzureName

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		policy.Owner = &owner
	} else {
		policy.Owner = nil
	}

	// Properties
	if source.Properties != nil {
		var property BaseBackupPolicy
		err := property.AssignProperties_From_BaseBackupPolicy(source.Properties)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_BaseBackupPolicy() to populate field Properties")
		}
		policy.Properties = &property
	} else {
		policy.Properties = nil
	}

	// No error
	return nil
}

// AssignProperties_To_BackupVaults_BackupPolicy_Spec populates the provided destination BackupVaults_BackupPolicy_Spec from our BackupVaults_BackupPolicy_Spec
func (policy *BackupVaults_BackupPolicy_Spec) AssignProperties_To_BackupVaults_BackupPolicy_Spec(destination *v20230101s.BackupVaults_BackupPolicy_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureName
	destination.AzureName = policy.AzureName

	// OriginalVersion
	destination.OriginalVersion = policy.OriginalVersion()

	// Owner
	if policy.Owner != nil {
		owner := policy.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// Properties
	if policy.Properties != nil {
		var property v20230101s.BaseBackupPolicy
		err := policy.Properties.AssignProperties_To_BaseBackupPolicy(&property)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_BaseBackupPolicy() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_BackupVaults_BackupPolicy_STATUS populates our BackupVaults_BackupPolicy_Spec from the provided source BackupVaults_BackupPolicy_STATUS
func (policy *BackupVaults_BackupPolicy_Spec) Initialize_From_BackupVaults_BackupPolicy_STATUS(source *BackupVaults_BackupPolicy_STATUS) error {

	// Properties
	if source.Properties != nil {
		var property BaseBackupPolicy
		err := property.Initialize_From_BaseBackupPolicy_STATUS(source.Properties)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_BaseBackupPolicy_STATUS() to populate field Properties")
		}
		policy.Properties = &property
	} else {
		policy.Properties = nil
	}

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (policy *BackupVaults_BackupPolicy_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (policy *BackupVaults_BackupPolicy_Spec) SetAzureName(azureName string) {
	policy.AzureName = azureName
}

type BackupVaults_BackupPolicy_STATUS struct {
	// Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	// Id: Resource Id represents the complete path to the resource.
	Id *string `json:"id,omitempty"`

	// Name: Resource name associated with the resource.
	Name *string `json:"name,omitempty"`

	// Properties: BaseBackupPolicyResource properties
	Properties *BaseBackupPolicy_STATUS `json:"properties,omitempty"`

	// SystemData: Metadata pertaining to creation and last modification of the resource.
	SystemData *SystemData_STATUS `json:"systemData,omitempty"`

	// Type: Resource type represents the complete path of the form Namespace/ResourceType/ResourceType/...
	Type *string `json:"type,omitempty"`
}

var _ genruntime.ConvertibleStatus = &BackupVaults_BackupPolicy_STATUS{}

// ConvertStatusFrom populates our BackupVaults_BackupPolicy_STATUS from the provided source
func (policy *BackupVaults_BackupPolicy_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*v20230101s.BackupVaults_BackupPolicy_STATUS)
	if ok {
		// Populate our instance from source
		return policy.AssignProperties_From_BackupVaults_BackupPolicy_STATUS(src)
	}

	// Convert to an intermediate form
	src = &v20230101s.BackupVaults_BackupPolicy_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = policy.AssignProperties_From_BackupVaults_BackupPolicy_STATUS(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our BackupVaults_BackupPolicy_STATUS
func (policy *BackupVaults_BackupPolicy_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*v20230101s.BackupVaults_BackupPolicy_STATUS)
	if ok {
		// Populate destination from our instance
		return policy.AssignProperties_To_BackupVaults_BackupPolicy_STATUS(dst)
	}

	// Convert to an intermediate form
	dst = &v20230101s.BackupVaults_BackupPolicy_STATUS{}
	err := policy.AssignProperties_To_BackupVaults_BackupPolicy_STATUS(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &BackupVaults_BackupPolicy_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (policy *BackupVaults_BackupPolicy_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &BackupVaults_BackupPolicy_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (policy *BackupVaults_BackupPolicy_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(BackupVaults_BackupPolicy_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected BackupVaults_BackupPolicy_STATUS_ARM, got %T", armInput)
	}

	// no assignment for property "Conditions"

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		policy.Id = &id
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		policy.Name = &name
	}

	// Set property "Properties":
	if typedInput.Properties != nil {
		var properties1 BaseBackupPolicy_STATUS
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		policy.Properties = &properties
	}

	// Set property "SystemData":
	if typedInput.SystemData != nil {
		var systemData1 SystemData_STATUS
		err := systemData1.PopulateFromARM(owner, *typedInput.SystemData)
		if err != nil {
			return err
		}
		systemData := systemData1
		policy.SystemData = &systemData
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		policy.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_BackupVaults_BackupPolicy_STATUS populates our BackupVaults_BackupPolicy_STATUS from the provided source BackupVaults_BackupPolicy_STATUS
func (policy *BackupVaults_BackupPolicy_STATUS) AssignProperties_From_BackupVaults_BackupPolicy_STATUS(source *v20230101s.BackupVaults_BackupPolicy_STATUS) error {

	// Conditions
	policy.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// Id
	policy.Id = genruntime.ClonePointerToString(source.Id)

	// Name
	policy.Name = genruntime.ClonePointerToString(source.Name)

	// Properties
	if source.Properties != nil {
		var property BaseBackupPolicy_STATUS
		err := property.AssignProperties_From_BaseBackupPolicy_STATUS(source.Properties)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_BaseBackupPolicy_STATUS() to populate field Properties")
		}
		policy.Properties = &property
	} else {
		policy.Properties = nil
	}

	// SystemData
	if source.SystemData != nil {
		var systemDatum SystemData_STATUS
		err := systemDatum.AssignProperties_From_SystemData_STATUS(source.SystemData)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SystemData_STATUS() to populate field SystemData")
		}
		policy.SystemData = &systemDatum
	} else {
		policy.SystemData = nil
	}

	// Type
	policy.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignProperties_To_BackupVaults_BackupPolicy_STATUS populates the provided destination BackupVaults_BackupPolicy_STATUS from our BackupVaults_BackupPolicy_STATUS
func (policy *BackupVaults_BackupPolicy_STATUS) AssignProperties_To_BackupVaults_BackupPolicy_STATUS(destination *v20230101s.BackupVaults_BackupPolicy_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(policy.Conditions)

	// Id
	destination.Id = genruntime.ClonePointerToString(policy.Id)

	// Name
	destination.Name = genruntime.ClonePointerToString(policy.Name)

	// Properties
	if policy.Properties != nil {
		var property v20230101s.BaseBackupPolicy_STATUS
		err := policy.Properties.AssignProperties_To_BaseBackupPolicy_STATUS(&property)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_BaseBackupPolicy_STATUS() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// SystemData
	if policy.SystemData != nil {
		var systemDatum v20230101s.SystemData_STATUS
		err := policy.SystemData.AssignProperties_To_SystemData_STATUS(&systemDatum)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SystemData_STATUS() to populate field SystemData")
		}
		destination.SystemData = &systemDatum
	} else {
		destination.SystemData = nil
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(policy.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type BaseBackupPolicy struct {
	// BackupPolicy: Mutually exclusive with all other properties
	BackupPolicy *BackupPolicy `json:"backupPolicy,omitempty"`
}

var _ genruntime.ARMTransformer = &BaseBackupPolicy{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (policy *BaseBackupPolicy) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if policy == nil {
		return nil, nil
	}
	result := &BaseBackupPolicy_ARM{}

	// Set property "BackupPolicy":
	if policy.BackupPolicy != nil {
		backupPolicy_ARM, err := (*policy.BackupPolicy).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		backupPolicy := *backupPolicy_ARM.(*BackupPolicy_ARM)
		result.BackupPolicy = &backupPolicy
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (policy *BaseBackupPolicy) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &BaseBackupPolicy_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (policy *BaseBackupPolicy) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(BaseBackupPolicy_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected BaseBackupPolicy_ARM, got %T", armInput)
	}

	// Set property "BackupPolicy":
	if typedInput.BackupPolicy != nil {
		var backupPolicy1 BackupPolicy
		err := backupPolicy1.PopulateFromARM(owner, *typedInput.BackupPolicy)
		if err != nil {
			return err
		}
		backupPolicy := backupPolicy1
		policy.BackupPolicy = &backupPolicy
	}

	// No error
	return nil
}

// AssignProperties_From_BaseBackupPolicy populates our BaseBackupPolicy from the provided source BaseBackupPolicy
func (policy *BaseBackupPolicy) AssignProperties_From_BaseBackupPolicy(source *v20230101s.BaseBackupPolicy) error {

	// BackupPolicy
	if source.BackupPolicy != nil {
		var backupPolicy BackupPolicy
		err := backupPolicy.AssignProperties_From_BackupPolicy(source.BackupPolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_BackupPolicy() to populate field BackupPolicy")
		}
		policy.BackupPolicy = &backupPolicy
	} else {
		policy.BackupPolicy = nil
	}

	// No error
	return nil
}

// AssignProperties_To_BaseBackupPolicy populates the provided destination BaseBackupPolicy from our BaseBackupPolicy
func (policy *BaseBackupPolicy) AssignProperties_To_BaseBackupPolicy(destination *v20230101s.BaseBackupPolicy) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BackupPolicy
	if policy.BackupPolicy != nil {
		var backupPolicy v20230101s.BackupPolicy
		err := policy.BackupPolicy.AssignProperties_To_BackupPolicy(&backupPolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_BackupPolicy() to populate field BackupPolicy")
		}
		destination.BackupPolicy = &backupPolicy
	} else {
		destination.BackupPolicy = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_BaseBackupPolicy_STATUS populates our BaseBackupPolicy from the provided source BaseBackupPolicy_STATUS
func (policy *BaseBackupPolicy) Initialize_From_BaseBackupPolicy_STATUS(source *BaseBackupPolicy_STATUS) error {

	// BackupPolicy
	if source.BackupPolicy != nil {
		var backupPolicy BackupPolicy
		err := backupPolicy.Initialize_From_BackupPolicy_STATUS(source.BackupPolicy)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_BackupPolicy_STATUS() to populate field BackupPolicy")
		}
		policy.BackupPolicy = &backupPolicy
	} else {
		policy.BackupPolicy = nil
	}

	// No error
	return nil
}

type BaseBackupPolicy_STATUS struct {
	// BackupPolicy: Mutually exclusive with all other properties
	BackupPolicy *BackupPolicy_STATUS `json:"backupPolicy,omitempty"`
}

var _ genruntime.FromARMConverter = &BaseBackupPolicy_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (policy *BaseBackupPolicy_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &BaseBackupPolicy_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (policy *BaseBackupPolicy_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(BaseBackupPolicy_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected BaseBackupPolicy_STATUS_ARM, got %T", armInput)
	}

	// Set property "BackupPolicy":
	if typedInput.BackupPolicy != nil {
		var backupPolicy1 BackupPolicy_STATUS
		err := backupPolicy1.PopulateFromARM(owner, *typedInput.BackupPolicy)
		if err != nil {
			return err
		}
		backupPolicy := backupPolicy1
		policy.BackupPolicy = &backupPolicy
	}

	// No error
	return nil
}

// AssignProperties_From_BaseBackupPolicy_STATUS populates our BaseBackupPolicy_STATUS from the provided source BaseBackupPolicy_STATUS
func (policy *BaseBackupPolicy_STATUS) AssignProperties_From_BaseBackupPolicy_STATUS(source *v20230101s.BaseBackupPolicy_STATUS) error {

	// BackupPolicy
	if source.BackupPolicy != nil {
		var backupPolicy BackupPolicy_STATUS
		err := backupPolicy.AssignProperties_From_BackupPolicy_STATUS(source.BackupPolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_BackupPolicy_STATUS() to populate field BackupPolicy")
		}
		policy.BackupPolicy = &backupPolicy
	} else {
		policy.BackupPolicy = nil
	}

	// No error
	return nil
}

// AssignProperties_To_BaseBackupPolicy_STATUS populates the provided destination BaseBackupPolicy_STATUS from our BaseBackupPolicy_STATUS
func (policy *BaseBackupPolicy_STATUS) AssignProperties_To_BaseBackupPolicy_STATUS(destination *v20230101s.BaseBackupPolicy_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BackupPolicy
	if policy.BackupPolicy != nil {
		var backupPolicy v20230101s.BackupPolicy_STATUS
		err := policy.BackupPolicy.AssignProperties_To_BackupPolicy_STATUS(&backupPolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_BackupPolicy_STATUS() to populate field BackupPolicy")
		}
		destination.BackupPolicy = &backupPolicy
	} else {
		destination.BackupPolicy = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type BackupPolicy struct {
	// +kubebuilder:validation:Required
	// DatasourceTypes: Type of datasource for the backup management
	DatasourceTypes []string `json:"datasourceTypes,omitempty"`

	// +kubebuilder:validation:Required
	ObjectType *BackupPolicy_ObjectType `json:"objectType,omitempty"`

	// +kubebuilder:validation:Required
	// PolicyRules: Policy rule dictionary that contains rules for each backuptype i.e Full/Incremental/Logs etc
	PolicyRules []BasePolicyRule `json:"policyRules,omitempty"`
}

var _ genruntime.ARMTransformer = &BackupPolicy{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (policy *BackupPolicy) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if policy == nil {
		return nil, nil
	}
	result := &BackupPolicy_ARM{}

	// Set property "DatasourceTypes":
	for _, item := range policy.DatasourceTypes {
		result.DatasourceTypes = append(result.DatasourceTypes, item)
	}

	// Set property "ObjectType":
	if policy.ObjectType != nil {
		result.ObjectType = *policy.ObjectType
	}

	// Set property "PolicyRules":
	for _, item := range policy.PolicyRules {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.PolicyRules = append(result.PolicyRules, *item_ARM.(*BasePolicyRule_ARM))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (policy *BackupPolicy) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &BackupPolicy_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (policy *BackupPolicy) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(BackupPolicy_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected BackupPolicy_ARM, got %T", armInput)
	}

	// Set property "DatasourceTypes":
	for _, item := range typedInput.DatasourceTypes {
		policy.DatasourceTypes = append(policy.DatasourceTypes, item)
	}

	// Set property "ObjectType":
	policy.ObjectType = &typedInput.ObjectType

	// Set property "PolicyRules":
	for _, item := range typedInput.PolicyRules {
		var item1 BasePolicyRule
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		policy.PolicyRules = append(policy.PolicyRules, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_BackupPolicy populates our BackupPolicy from the provided source BackupPolicy
func (policy *BackupPolicy) AssignProperties_From_BackupPolicy(source *v20230101s.BackupPolicy) error {

	// DatasourceTypes
	policy.DatasourceTypes = genruntime.CloneSliceOfString(source.DatasourceTypes)

	// ObjectType
	if source.ObjectType != nil {
		objectType := BackupPolicy_ObjectType(*source.ObjectType)
		policy.ObjectType = &objectType
	} else {
		policy.ObjectType = nil
	}

	// PolicyRules
	if source.PolicyRules != nil {
		policyRuleList := make([]BasePolicyRule, len(source.PolicyRules))
		for policyRuleIndex, policyRuleItem := range source.PolicyRules {
			// Shadow the loop variable to avoid aliasing
			policyRuleItem := policyRuleItem
			var policyRule BasePolicyRule
			err := policyRule.AssignProperties_From_BasePolicyRule(&policyRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_BasePolicyRule() to populate field PolicyRules")
			}
			policyRuleList[policyRuleIndex] = policyRule
		}
		policy.PolicyRules = policyRuleList
	} else {
		policy.PolicyRules = nil
	}

	// No error
	return nil
}

// AssignProperties_To_BackupPolicy populates the provided destination BackupPolicy from our BackupPolicy
func (policy *BackupPolicy) AssignProperties_To_BackupPolicy(destination *v20230101s.BackupPolicy) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DatasourceTypes
	destination.DatasourceTypes = genruntime.CloneSliceOfString(policy.DatasourceTypes)

	// ObjectType
	if policy.ObjectType != nil {
		objectType := string(*policy.ObjectType)
		destination.ObjectType = &objectType
	} else {
		destination.ObjectType = nil
	}

	// PolicyRules
	if policy.PolicyRules != nil {
		policyRuleList := make([]v20230101s.BasePolicyRule, len(policy.PolicyRules))
		for policyRuleIndex, policyRuleItem := range policy.PolicyRules {
			// Shadow the loop variable to avoid aliasing
			policyRuleItem := policyRuleItem
			var policyRule v20230101s.BasePolicyRule
			err := policyRuleItem.AssignProperties_To_BasePolicyRule(&policyRule)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_BasePolicyRule() to populate field PolicyRules")
			}
			policyRuleList[policyRuleIndex] = policyRule
		}
		destination.PolicyRules = policyRuleList
	} else {
		destination.PolicyRules = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_BackupPolicy_STATUS populates our BackupPolicy from the provided source BackupPolicy_STATUS
func (policy *BackupPolicy) Initialize_From_BackupPolicy_STATUS(source *BackupPolicy_STATUS) error {

	// DatasourceTypes
	policy.DatasourceTypes = genruntime.CloneSliceOfString(source.DatasourceTypes)

	// ObjectType
	if source.ObjectType != nil {
		objectType := BackupPolicy_ObjectType(*source.ObjectType)
		policy.ObjectType = &objectType
	} else {
		policy.ObjectType = nil
	}

	// PolicyRules
	if source.PolicyRules != nil {
		policyRuleList := make([]BasePolicyRule, len(source.PolicyRules))
		for policyRuleIndex, policyRuleItem := range source.PolicyRules {
			// Shadow the loop variable to avoid aliasing
			policyRuleItem := policyRuleItem
			var policyRule BasePolicyRule
			err := policyRule.Initialize_From_BasePolicyRule_STATUS(&policyRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_BasePolicyRule_STATUS() to populate field PolicyRules")
			}
			policyRuleList[policyRuleIndex] = policyRule
		}
		policy.PolicyRules = policyRuleList
	} else {
		policy.PolicyRules = nil
	}

	// No error
	return nil
}

type BackupPolicy_STATUS struct {
	// DatasourceTypes: Type of datasource for the backup management
	DatasourceTypes []string                        `json:"datasourceTypes,omitempty"`
	ObjectType      *BackupPolicy_ObjectType_STATUS `json:"objectType,omitempty"`

	// PolicyRules: Policy rule dictionary that contains rules for each backuptype i.e Full/Incremental/Logs etc
	PolicyRules []BasePolicyRule_STATUS `json:"policyRules,omitempty"`
}

var _ genruntime.FromARMConverter = &BackupPolicy_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (policy *BackupPolicy_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &BackupPolicy_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (policy *BackupPolicy_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(BackupPolicy_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected BackupPolicy_STATUS_ARM, got %T", armInput)
	}

	// Set property "DatasourceTypes":
	for _, item := range typedInput.DatasourceTypes {
		policy.DatasourceTypes = append(policy.DatasourceTypes, item)
	}

	// Set property "ObjectType":
	policy.ObjectType = &typedInput.ObjectType

	// Set property "PolicyRules":
	for _, item := range typedInput.PolicyRules {
		var item1 BasePolicyRule_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		policy.PolicyRules = append(policy.PolicyRules, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_BackupPolicy_STATUS populates our BackupPolicy_STATUS from the provided source BackupPolicy_STATUS
func (policy *BackupPolicy_STATUS) AssignProperties_From_BackupPolicy_STATUS(source *v20230101s.BackupPolicy_STATUS) error {

	// DatasourceTypes
	policy.DatasourceTypes = genruntime.CloneSliceOfString(source.DatasourceTypes)

	// ObjectType
	if source.ObjectType != nil {
		objectType := BackupPolicy_ObjectType_STATUS(*source.ObjectType)
		policy.ObjectType = &objectType
	} else {
		policy.ObjectType = nil
	}

	// PolicyRules
	if source.PolicyRules != nil {
		policyRuleList := make([]BasePolicyRule_STATUS, len(source.PolicyRules))
		for policyRuleIndex, policyRuleItem := range source.PolicyRules {
			// Shadow the loop variable to avoid aliasing
			policyRuleItem := policyRuleItem
			var policyRule BasePolicyRule_STATUS
			err := policyRule.AssignProperties_From_BasePolicyRule_STATUS(&policyRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_BasePolicyRule_STATUS() to populate field PolicyRules")
			}
			policyRuleList[policyRuleIndex] = policyRule
		}
		policy.PolicyRules = policyRuleList
	} else {
		policy.PolicyRules = nil
	}

	// No error
	return nil
}

// AssignProperties_To_BackupPolicy_STATUS populates the provided destination BackupPolicy_STATUS from our BackupPolicy_STATUS
func (policy *BackupPolicy_STATUS) AssignProperties_To_BackupPolicy_STATUS(destination *v20230101s.BackupPolicy_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DatasourceTypes
	destination.DatasourceTypes = genruntime.CloneSliceOfString(policy.DatasourceTypes)

	// ObjectType
	if policy.ObjectType != nil {
		objectType := string(*policy.ObjectType)
		destination.ObjectType = &objectType
	} else {
		destination.ObjectType = nil
	}

	// PolicyRules
	if policy.PolicyRules != nil {
		policyRuleList := make([]v20230101s.BasePolicyRule_STATUS, len(policy.PolicyRules))
		for policyRuleIndex, policyRuleItem := range policy.PolicyRules {
			// Shadow the loop variable to avoid aliasing
			policyRuleItem := policyRuleItem
			var policyRule v20230101s.BasePolicyRule_STATUS
			err := policyRuleItem.AssignProperties_To_BasePolicyRule_STATUS(&policyRule)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_BasePolicyRule_STATUS() to populate field PolicyRules")
			}
			policyRuleList[policyRuleIndex] = policyRule
		}
		destination.PolicyRules = policyRuleList
	} else {
		destination.PolicyRules = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type BasePolicyRule struct {
	// AzureBackup: Mutually exclusive with all other properties
	AzureBackup *AzureBackupRule `json:"azureBackupRule,omitempty"`

	// AzureRetention: Mutually exclusive with all other properties
	AzureRetention *AzureRetentionRule `json:"azureRetentionRule,omitempty"`
}

var _ genruntime.ARMTransformer = &BasePolicyRule{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (rule *BasePolicyRule) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if rule == nil {
		return nil, nil
	}
	result := &BasePolicyRule_ARM{}

	// Set property "AzureBackup":
	if rule.AzureBackup != nil {
		azureBackup_ARM, err := (*rule.AzureBackup).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		azureBackup := *azureBackup_ARM.(*AzureBackupRule_ARM)
		result.AzureBackup = &azureBackup
	}

	// Set property "AzureRetention":
	if rule.AzureRetention != nil {
		azureRetention_ARM, err := (*rule.AzureRetention).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		azureRetention := *azureRetention_ARM.(*AzureRetentionRule_ARM)
		result.AzureRetention = &azureRetention
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *BasePolicyRule) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &BasePolicyRule_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *BasePolicyRule) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(BasePolicyRule_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected BasePolicyRule_ARM, got %T", armInput)
	}

	// Set property "AzureBackup":
	if typedInput.AzureBackup != nil {
		var azureBackup1 AzureBackupRule
		err := azureBackup1.PopulateFromARM(owner, *typedInput.AzureBackup)
		if err != nil {
			return err
		}
		azureBackup := azureBackup1
		rule.AzureBackup = &azureBackup
	}

	// Set property "AzureRetention":
	if typedInput.AzureRetention != nil {
		var azureRetention1 AzureRetentionRule
		err := azureRetention1.PopulateFromARM(owner, *typedInput.AzureRetention)
		if err != nil {
			return err
		}
		azureRetention := azureRetention1
		rule.AzureRetention = &azureRetention
	}

	// No error
	return nil
}

// AssignProperties_From_BasePolicyRule populates our BasePolicyRule from the provided source BasePolicyRule
func (rule *BasePolicyRule) AssignProperties_From_BasePolicyRule(source *v20230101s.BasePolicyRule) error {

	// AzureBackup
	if source.AzureBackup != nil {
		var azureBackup AzureBackupRule
		err := azureBackup.AssignProperties_From_AzureBackupRule(source.AzureBackup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AzureBackupRule() to populate field AzureBackup")
		}
		rule.AzureBackup = &azureBackup
	} else {
		rule.AzureBackup = nil
	}

	// AzureRetention
	if source.AzureRetention != nil {
		var azureRetention AzureRetentionRule
		err := azureRetention.AssignProperties_From_AzureRetentionRule(source.AzureRetention)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AzureRetentionRule() to populate field AzureRetention")
		}
		rule.AzureRetention = &azureRetention
	} else {
		rule.AzureRetention = nil
	}

	// No error
	return nil
}

// AssignProperties_To_BasePolicyRule populates the provided destination BasePolicyRule from our BasePolicyRule
func (rule *BasePolicyRule) AssignProperties_To_BasePolicyRule(destination *v20230101s.BasePolicyRule) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureBackup
	if rule.AzureBackup != nil {
		var azureBackup v20230101s.AzureBackupRule
		err := rule.AzureBackup.AssignProperties_To_AzureBackupRule(&azureBackup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AzureBackupRule() to populate field AzureBackup")
		}
		destination.AzureBackup = &azureBackup
	} else {
		destination.AzureBackup = nil
	}

	// AzureRetention
	if rule.AzureRetention != nil {
		var azureRetention v20230101s.AzureRetentionRule
		err := rule.AzureRetention.AssignProperties_To_AzureRetentionRule(&azureRetention)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AzureRetentionRule() to populate field AzureRetention")
		}
		destination.AzureRetention = &azureRetention
	} else {
		destination.AzureRetention = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_BasePolicyRule_STATUS populates our BasePolicyRule from the provided source BasePolicyRule_STATUS
func (rule *BasePolicyRule) Initialize_From_BasePolicyRule_STATUS(source *BasePolicyRule_STATUS) error {

	// AzureBackup
	if source.AzureBackup != nil {
		var azureBackup AzureBackupRule
		err := azureBackup.Initialize_From_AzureBackupRule_STATUS(source.AzureBackup)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_AzureBackupRule_STATUS() to populate field AzureBackup")
		}
		rule.AzureBackup = &azureBackup
	} else {
		rule.AzureBackup = nil
	}

	// AzureRetention
	if source.AzureRetention != nil {
		var azureRetention AzureRetentionRule
		err := azureRetention.Initialize_From_AzureRetentionRule_STATUS(source.AzureRetention)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_AzureRetentionRule_STATUS() to populate field AzureRetention")
		}
		rule.AzureRetention = &azureRetention
	} else {
		rule.AzureRetention = nil
	}

	// No error
	return nil
}

type BasePolicyRule_STATUS struct {
	// AzureBackup: Mutually exclusive with all other properties
	AzureBackup *AzureBackupRule_STATUS `json:"azureBackupRule,omitempty"`

	// AzureRetention: Mutually exclusive with all other properties
	AzureRetention *AzureRetentionRule_STATUS `json:"azureRetentionRule,omitempty"`
}

var _ genruntime.FromARMConverter = &BasePolicyRule_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *BasePolicyRule_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &BasePolicyRule_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *BasePolicyRule_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(BasePolicyRule_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected BasePolicyRule_STATUS_ARM, got %T", armInput)
	}

	// Set property "AzureBackup":
	if typedInput.AzureBackup != nil {
		var azureBackup1 AzureBackupRule_STATUS
		err := azureBackup1.PopulateFromARM(owner, *typedInput.AzureBackup)
		if err != nil {
			return err
		}
		azureBackup := azureBackup1
		rule.AzureBackup = &azureBackup
	}

	// Set property "AzureRetention":
	if typedInput.AzureRetention != nil {
		var azureRetention1 AzureRetentionRule_STATUS
		err := azureRetention1.PopulateFromARM(owner, *typedInput.AzureRetention)
		if err != nil {
			return err
		}
		azureRetention := azureRetention1
		rule.AzureRetention = &azureRetention
	}

	// No error
	return nil
}

// AssignProperties_From_BasePolicyRule_STATUS populates our BasePolicyRule_STATUS from the provided source BasePolicyRule_STATUS
func (rule *BasePolicyRule_STATUS) AssignProperties_From_BasePolicyRule_STATUS(source *v20230101s.BasePolicyRule_STATUS) error {

	// AzureBackup
	if source.AzureBackup != nil {
		var azureBackup AzureBackupRule_STATUS
		err := azureBackup.AssignProperties_From_AzureBackupRule_STATUS(source.AzureBackup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AzureBackupRule_STATUS() to populate field AzureBackup")
		}
		rule.AzureBackup = &azureBackup
	} else {
		rule.AzureBackup = nil
	}

	// AzureRetention
	if source.AzureRetention != nil {
		var azureRetention AzureRetentionRule_STATUS
		err := azureRetention.AssignProperties_From_AzureRetentionRule_STATUS(source.AzureRetention)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AzureRetentionRule_STATUS() to populate field AzureRetention")
		}
		rule.AzureRetention = &azureRetention
	} else {
		rule.AzureRetention = nil
	}

	// No error
	return nil
}

// AssignProperties_To_BasePolicyRule_STATUS populates the provided destination BasePolicyRule_STATUS from our BasePolicyRule_STATUS
func (rule *BasePolicyRule_STATUS) AssignProperties_To_BasePolicyRule_STATUS(destination *v20230101s.BasePolicyRule_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureBackup
	if rule.AzureBackup != nil {
		var azureBackup v20230101s.AzureBackupRule_STATUS
		err := rule.AzureBackup.AssignProperties_To_AzureBackupRule_STATUS(&azureBackup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AzureBackupRule_STATUS() to populate field AzureBackup")
		}
		destination.AzureBackup = &azureBackup
	} else {
		destination.AzureBackup = nil
	}

	// AzureRetention
	if rule.AzureRetention != nil {
		var azureRetention v20230101s.AzureRetentionRule_STATUS
		err := rule.AzureRetention.AssignProperties_To_AzureRetentionRule_STATUS(&azureRetention)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AzureRetentionRule_STATUS() to populate field AzureRetention")
		}
		destination.AzureRetention = &azureRetention
	} else {
		destination.AzureRetention = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type AzureBackupRule struct {
	BackupParameters *BackupParameters `json:"backupParameters,omitempty"`

	// +kubebuilder:validation:Required
	// DataStore: DataStoreInfo base
	DataStore *DataStoreInfoBase `json:"dataStore,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	ObjectType *AzureBackupRule_ObjectType `json:"objectType,omitempty"`

	// +kubebuilder:validation:Required
	Trigger *TriggerContext `json:"trigger,omitempty"`
}

var _ genruntime.ARMTransformer = &AzureBackupRule{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (rule *AzureBackupRule) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if rule == nil {
		return nil, nil
	}
	result := &AzureBackupRule_ARM{}

	// Set property "BackupParameters":
	if rule.BackupParameters != nil {
		backupParameters_ARM, err := (*rule.BackupParameters).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		backupParameters := *backupParameters_ARM.(*BackupParameters_ARM)
		result.BackupParameters = &backupParameters
	}

	// Set property "DataStore":
	if rule.DataStore != nil {
		dataStore_ARM, err := (*rule.DataStore).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		dataStore := *dataStore_ARM.(*DataStoreInfoBase_ARM)
		result.DataStore = &dataStore
	}

	// Set property "Name":
	if rule.Name != nil {
		name := *rule.Name
		result.Name = &name
	}

	// Set property "ObjectType":
	if rule.ObjectType != nil {
		result.ObjectType = *rule.ObjectType
	}

	// Set property "Trigger":
	if rule.Trigger != nil {
		trigger_ARM, err := (*rule.Trigger).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		trigger := *trigger_ARM.(*TriggerContext_ARM)
		result.Trigger = &trigger
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *AzureBackupRule) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &AzureBackupRule_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *AzureBackupRule) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(AzureBackupRule_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected AzureBackupRule_ARM, got %T", armInput)
	}

	// Set property "BackupParameters":
	if typedInput.BackupParameters != nil {
		var backupParameters1 BackupParameters
		err := backupParameters1.PopulateFromARM(owner, *typedInput.BackupParameters)
		if err != nil {
			return err
		}
		backupParameters := backupParameters1
		rule.BackupParameters = &backupParameters
	}

	// Set property "DataStore":
	if typedInput.DataStore != nil {
		var dataStore1 DataStoreInfoBase
		err := dataStore1.PopulateFromARM(owner, *typedInput.DataStore)
		if err != nil {
			return err
		}
		dataStore := dataStore1
		rule.DataStore = &dataStore
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		rule.Name = &name
	}

	// Set property "ObjectType":
	rule.ObjectType = &typedInput.ObjectType

	// Set property "Trigger":
	if typedInput.Trigger != nil {
		var trigger1 TriggerContext
		err := trigger1.PopulateFromARM(owner, *typedInput.Trigger)
		if err != nil {
			return err
		}
		trigger := trigger1
		rule.Trigger = &trigger
	}

	// No error
	return nil
}

// AssignProperties_From_AzureBackupRule populates our AzureBackupRule from the provided source AzureBackupRule
func (rule *AzureBackupRule) AssignProperties_From_AzureBackupRule(source *v20230101s.AzureBackupRule) error {

	// BackupParameters
	if source.BackupParameters != nil {
		var backupParameter BackupParameters
		err := backupParameter.AssignProperties_From_BackupParameters(source.BackupParameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_BackupParameters() to populate field BackupParameters")
		}
		rule.BackupParameters = &backupParameter
	} else {
		rule.BackupParameters = nil
	}

	// DataStore
	if source.DataStore != nil {
		var dataStore DataStoreInfoBase
		err := dataStore.AssignProperties_From_DataStoreInfoBase(source.DataStore)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DataStoreInfoBase() to populate field DataStore")
		}
		rule.DataStore = &dataStore
	} else {
		rule.DataStore = nil
	}

	// Name
	rule.Name = genruntime.ClonePointerToString(source.Name)

	// ObjectType
	if source.ObjectType != nil {
		objectType := AzureBackupRule_ObjectType(*source.ObjectType)
		rule.ObjectType = &objectType
	} else {
		rule.ObjectType = nil
	}

	// Trigger
	if source.Trigger != nil {
		var trigger TriggerContext
		err := trigger.AssignProperties_From_TriggerContext(source.Trigger)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_TriggerContext() to populate field Trigger")
		}
		rule.Trigger = &trigger
	} else {
		rule.Trigger = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AzureBackupRule populates the provided destination AzureBackupRule from our AzureBackupRule
func (rule *AzureBackupRule) AssignProperties_To_AzureBackupRule(destination *v20230101s.AzureBackupRule) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BackupParameters
	if rule.BackupParameters != nil {
		var backupParameter v20230101s.BackupParameters
		err := rule.BackupParameters.AssignProperties_To_BackupParameters(&backupParameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_BackupParameters() to populate field BackupParameters")
		}
		destination.BackupParameters = &backupParameter
	} else {
		destination.BackupParameters = nil
	}

	// DataStore
	if rule.DataStore != nil {
		var dataStore v20230101s.DataStoreInfoBase
		err := rule.DataStore.AssignProperties_To_DataStoreInfoBase(&dataStore)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DataStoreInfoBase() to populate field DataStore")
		}
		destination.DataStore = &dataStore
	} else {
		destination.DataStore = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(rule.Name)

	// ObjectType
	if rule.ObjectType != nil {
		objectType := string(*rule.ObjectType)
		destination.ObjectType = &objectType
	} else {
		destination.ObjectType = nil
	}

	// Trigger
	if rule.Trigger != nil {
		var trigger v20230101s.TriggerContext
		err := rule.Trigger.AssignProperties_To_TriggerContext(&trigger)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_TriggerContext() to populate field Trigger")
		}
		destination.Trigger = &trigger
	} else {
		destination.Trigger = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_AzureBackupRule_STATUS populates our AzureBackupRule from the provided source AzureBackupRule_STATUS
func (rule *AzureBackupRule) Initialize_From_AzureBackupRule_STATUS(source *AzureBackupRule_STATUS) error {

	// BackupParameters
	if source.BackupParameters != nil {
		var backupParameter BackupParameters
		err := backupParameter.Initialize_From_BackupParameters_STATUS(source.BackupParameters)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_BackupParameters_STATUS() to populate field BackupParameters")
		}
		rule.BackupParameters = &backupParameter
	} else {
		rule.BackupParameters = nil
	}

	// DataStore
	if source.DataStore != nil {
		var dataStore DataStoreInfoBase
		err := dataStore.Initialize_From_DataStoreInfoBase_STATUS(source.DataStore)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_DataStoreInfoBase_STATUS() to populate field DataStore")
		}
		rule.DataStore = &dataStore
	} else {
		rule.DataStore = nil
	}

	// Name
	rule.Name = genruntime.ClonePointerToString(source.Name)

	// ObjectType
	if source.ObjectType != nil {
		objectType := AzureBackupRule_ObjectType(*source.ObjectType)
		rule.ObjectType = &objectType
	} else {
		rule.ObjectType = nil
	}

	// Trigger
	if source.Trigger != nil {
		var trigger TriggerContext
		err := trigger.Initialize_From_TriggerContext_STATUS(source.Trigger)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_TriggerContext_STATUS() to populate field Trigger")
		}
		rule.Trigger = &trigger
	} else {
		rule.Trigger = nil
	}

	// No error
	return nil
}

type AzureBackupRule_STATUS struct {
	BackupParameters *BackupParameters_STATUS `json:"backupParameters,omitempty"`

	// DataStore: DataStoreInfo base
	DataStore  *DataStoreInfoBase_STATUS          `json:"dataStore,omitempty"`
	Name       *string                            `json:"name,omitempty"`
	ObjectType *AzureBackupRule_ObjectType_STATUS `json:"objectType,omitempty"`
	Trigger    *TriggerContext_STATUS             `json:"trigger,omitempty"`
}

var _ genruntime.FromARMConverter = &AzureBackupRule_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *AzureBackupRule_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &AzureBackupRule_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *AzureBackupRule_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(AzureBackupRule_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected AzureBackupRule_STATUS_ARM, got %T", armInput)
	}

	// Set property "BackupParameters":
	if typedInput.BackupParameters != nil {
		var backupParameters1 BackupParameters_STATUS
		err := backupParameters1.PopulateFromARM(owner, *typedInput.BackupParameters)
		if err != nil {
			return err
		}
		backupParameters := backupParameters1
		rule.BackupParameters = &backupParameters
	}

	// Set property "DataStore":
	if typedInput.DataStore != nil {
		var dataStore1 DataStoreInfoBase_STATUS
		err := dataStore1.PopulateFromARM(owner, *typedInput.DataStore)
		if err != nil {
			return err
		}
		dataStore := dataStore1
		rule.DataStore = &dataStore
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		rule.Name = &name
	}

	// Set property "ObjectType":
	rule.ObjectType = &typedInput.ObjectType

	// Set property "Trigger":
	if typedInput.Trigger != nil {
		var trigger1 TriggerContext_STATUS
		err := trigger1.PopulateFromARM(owner, *typedInput.Trigger)
		if err != nil {
			return err
		}
		trigger := trigger1
		rule.Trigger = &trigger
	}

	// No error
	return nil
}

// AssignProperties_From_AzureBackupRule_STATUS populates our AzureBackupRule_STATUS from the provided source AzureBackupRule_STATUS
func (rule *AzureBackupRule_STATUS) AssignProperties_From_AzureBackupRule_STATUS(source *v20230101s.AzureBackupRule_STATUS) error {

	// BackupParameters
	if source.BackupParameters != nil {
		var backupParameter BackupParameters_STATUS
		err := backupParameter.AssignProperties_From_BackupParameters_STATUS(source.BackupParameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_BackupParameters_STATUS() to populate field BackupParameters")
		}
		rule.BackupParameters = &backupParameter
	} else {
		rule.BackupParameters = nil
	}

	// DataStore
	if source.DataStore != nil {
		var dataStore DataStoreInfoBase_STATUS
		err := dataStore.AssignProperties_From_DataStoreInfoBase_STATUS(source.DataStore)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DataStoreInfoBase_STATUS() to populate field DataStore")
		}
		rule.DataStore = &dataStore
	} else {
		rule.DataStore = nil
	}

	// Name
	rule.Name = genruntime.ClonePointerToString(source.Name)

	// ObjectType
	if source.ObjectType != nil {
		objectType := AzureBackupRule_ObjectType_STATUS(*source.ObjectType)
		rule.ObjectType = &objectType
	} else {
		rule.ObjectType = nil
	}

	// Trigger
	if source.Trigger != nil {
		var trigger TriggerContext_STATUS
		err := trigger.AssignProperties_From_TriggerContext_STATUS(source.Trigger)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_TriggerContext_STATUS() to populate field Trigger")
		}
		rule.Trigger = &trigger
	} else {
		rule.Trigger = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AzureBackupRule_STATUS populates the provided destination AzureBackupRule_STATUS from our AzureBackupRule_STATUS
func (rule *AzureBackupRule_STATUS) AssignProperties_To_AzureBackupRule_STATUS(destination *v20230101s.AzureBackupRule_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BackupParameters
	if rule.BackupParameters != nil {
		var backupParameter v20230101s.BackupParameters_STATUS
		err := rule.BackupParameters.AssignProperties_To_BackupParameters_STATUS(&backupParameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_BackupParameters_STATUS() to populate field BackupParameters")
		}
		destination.BackupParameters = &backupParameter
	} else {
		destination.BackupParameters = nil
	}

	// DataStore
	if rule.DataStore != nil {
		var dataStore v20230101s.DataStoreInfoBase_STATUS
		err := rule.DataStore.AssignProperties_To_DataStoreInfoBase_STATUS(&dataStore)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DataStoreInfoBase_STATUS() to populate field DataStore")
		}
		destination.DataStore = &dataStore
	} else {
		destination.DataStore = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(rule.Name)

	// ObjectType
	if rule.ObjectType != nil {
		objectType := string(*rule.ObjectType)
		destination.ObjectType = &objectType
	} else {
		destination.ObjectType = nil
	}

	// Trigger
	if rule.Trigger != nil {
		var trigger v20230101s.TriggerContext_STATUS
		err := rule.Trigger.AssignProperties_To_TriggerContext_STATUS(&trigger)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_TriggerContext_STATUS() to populate field Trigger")
		}
		destination.Trigger = &trigger
	} else {
		destination.Trigger = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type AzureRetentionRule struct {
	IsDefault *bool `json:"isDefault,omitempty"`

	// +kubebuilder:validation:Required
	Lifecycles []SourceLifeCycle `json:"lifecycles,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	ObjectType *AzureRetentionRule_ObjectType `json:"objectType,omitempty"`
}

var _ genruntime.ARMTransformer = &AzureRetentionRule{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (rule *AzureRetentionRule) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if rule == nil {
		return nil, nil
	}
	result := &AzureRetentionRule_ARM{}

	// Set property "IsDefault":
	if rule.IsDefault != nil {
		isDefault := *rule.IsDefault
		result.IsDefault = &isDefault
	}

	// Set property "Lifecycles":
	for _, item := range rule.Lifecycles {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Lifecycles = append(result.Lifecycles, *item_ARM.(*SourceLifeCycle_ARM))
	}

	// Set property "Name":
	if rule.Name != nil {
		name := *rule.Name
		result.Name = &name
	}

	// Set property "ObjectType":
	if rule.ObjectType != nil {
		result.ObjectType = *rule.ObjectType
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *AzureRetentionRule) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &AzureRetentionRule_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *AzureRetentionRule) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(AzureRetentionRule_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected AzureRetentionRule_ARM, got %T", armInput)
	}

	// Set property "IsDefault":
	if typedInput.IsDefault != nil {
		isDefault := *typedInput.IsDefault
		rule.IsDefault = &isDefault
	}

	// Set property "Lifecycles":
	for _, item := range typedInput.Lifecycles {
		var item1 SourceLifeCycle
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		rule.Lifecycles = append(rule.Lifecycles, item1)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		rule.Name = &name
	}

	// Set property "ObjectType":
	rule.ObjectType = &typedInput.ObjectType

	// No error
	return nil
}

// AssignProperties_From_AzureRetentionRule populates our AzureRetentionRule from the provided source AzureRetentionRule
func (rule *AzureRetentionRule) AssignProperties_From_AzureRetentionRule(source *v20230101s.AzureRetentionRule) error {

	// IsDefault
	if source.IsDefault != nil {
		isDefault := *source.IsDefault
		rule.IsDefault = &isDefault
	} else {
		rule.IsDefault = nil
	}

	// Lifecycles
	if source.Lifecycles != nil {
		lifecycleList := make([]SourceLifeCycle, len(source.Lifecycles))
		for lifecycleIndex, lifecycleItem := range source.Lifecycles {
			// Shadow the loop variable to avoid aliasing
			lifecycleItem := lifecycleItem
			var lifecycle SourceLifeCycle
			err := lifecycle.AssignProperties_From_SourceLifeCycle(&lifecycleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SourceLifeCycle() to populate field Lifecycles")
			}
			lifecycleList[lifecycleIndex] = lifecycle
		}
		rule.Lifecycles = lifecycleList
	} else {
		rule.Lifecycles = nil
	}

	// Name
	rule.Name = genruntime.ClonePointerToString(source.Name)

	// ObjectType
	if source.ObjectType != nil {
		objectType := AzureRetentionRule_ObjectType(*source.ObjectType)
		rule.ObjectType = &objectType
	} else {
		rule.ObjectType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AzureRetentionRule populates the provided destination AzureRetentionRule from our AzureRetentionRule
func (rule *AzureRetentionRule) AssignProperties_To_AzureRetentionRule(destination *v20230101s.AzureRetentionRule) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// IsDefault
	if rule.IsDefault != nil {
		isDefault := *rule.IsDefault
		destination.IsDefault = &isDefault
	} else {
		destination.IsDefault = nil
	}

	// Lifecycles
	if rule.Lifecycles != nil {
		lifecycleList := make([]v20230101s.SourceLifeCycle, len(rule.Lifecycles))
		for lifecycleIndex, lifecycleItem := range rule.Lifecycles {
			// Shadow the loop variable to avoid aliasing
			lifecycleItem := lifecycleItem
			var lifecycle v20230101s.SourceLifeCycle
			err := lifecycleItem.AssignProperties_To_SourceLifeCycle(&lifecycle)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SourceLifeCycle() to populate field Lifecycles")
			}
			lifecycleList[lifecycleIndex] = lifecycle
		}
		destination.Lifecycles = lifecycleList
	} else {
		destination.Lifecycles = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(rule.Name)

	// ObjectType
	if rule.ObjectType != nil {
		objectType := string(*rule.ObjectType)
		destination.ObjectType = &objectType
	} else {
		destination.ObjectType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_AzureRetentionRule_STATUS populates our AzureRetentionRule from the provided source AzureRetentionRule_STATUS
func (rule *AzureRetentionRule) Initialize_From_AzureRetentionRule_STATUS(source *AzureRetentionRule_STATUS) error {

	// IsDefault
	if source.IsDefault != nil {
		isDefault := *source.IsDefault
		rule.IsDefault = &isDefault
	} else {
		rule.IsDefault = nil
	}

	// Lifecycles
	if source.Lifecycles != nil {
		lifecycleList := make([]SourceLifeCycle, len(source.Lifecycles))
		for lifecycleIndex, lifecycleItem := range source.Lifecycles {
			// Shadow the loop variable to avoid aliasing
			lifecycleItem := lifecycleItem
			var lifecycle SourceLifeCycle
			err := lifecycle.Initialize_From_SourceLifeCycle_STATUS(&lifecycleItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_SourceLifeCycle_STATUS() to populate field Lifecycles")
			}
			lifecycleList[lifecycleIndex] = lifecycle
		}
		rule.Lifecycles = lifecycleList
	} else {
		rule.Lifecycles = nil
	}

	// Name
	rule.Name = genruntime.ClonePointerToString(source.Name)

	// ObjectType
	if source.ObjectType != nil {
		objectType := AzureRetentionRule_ObjectType(*source.ObjectType)
		rule.ObjectType = &objectType
	} else {
		rule.ObjectType = nil
	}

	// No error
	return nil
}

type AzureRetentionRule_STATUS struct {
	IsDefault  *bool                                 `json:"isDefault,omitempty"`
	Lifecycles []SourceLifeCycle_STATUS              `json:"lifecycles,omitempty"`
	Name       *string                               `json:"name,omitempty"`
	ObjectType *AzureRetentionRule_ObjectType_STATUS `json:"objectType,omitempty"`
}

var _ genruntime.FromARMConverter = &AzureRetentionRule_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *AzureRetentionRule_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &AzureRetentionRule_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *AzureRetentionRule_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(AzureRetentionRule_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected AzureRetentionRule_STATUS_ARM, got %T", armInput)
	}

	// Set property "IsDefault":
	if typedInput.IsDefault != nil {
		isDefault := *typedInput.IsDefault
		rule.IsDefault = &isDefault
	}

	// Set property "Lifecycles":
	for _, item := range typedInput.Lifecycles {
		var item1 SourceLifeCycle_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		rule.Lifecycles = append(rule.Lifecycles, item1)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		rule.Name = &name
	}

	// Set property "ObjectType":
	rule.ObjectType = &typedInput.ObjectType

	// No error
	return nil
}

// AssignProperties_From_AzureRetentionRule_STATUS populates our AzureRetentionRule_STATUS from the provided source AzureRetentionRule_STATUS
func (rule *AzureRetentionRule_STATUS) AssignProperties_From_AzureRetentionRule_STATUS(source *v20230101s.AzureRetentionRule_STATUS) error {

	// IsDefault
	if source.IsDefault != nil {
		isDefault := *source.IsDefault
		rule.IsDefault = &isDefault
	} else {
		rule.IsDefault = nil
	}

	// Lifecycles
	if source.Lifecycles != nil {
		lifecycleList := make([]SourceLifeCycle_STATUS, len(source.Lifecycles))
		for lifecycleIndex, lifecycleItem := range source.Lifecycles {
			// Shadow the loop variable to avoid aliasing
			lifecycleItem := lifecycleItem
			var lifecycle SourceLifeCycle_STATUS
			err := lifecycle.AssignProperties_From_SourceLifeCycle_STATUS(&lifecycleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SourceLifeCycle_STATUS() to populate field Lifecycles")
			}
			lifecycleList[lifecycleIndex] = lifecycle
		}
		rule.Lifecycles = lifecycleList
	} else {
		rule.Lifecycles = nil
	}

	// Name
	rule.Name = genruntime.ClonePointerToString(source.Name)

	// ObjectType
	if source.ObjectType != nil {
		objectType := AzureRetentionRule_ObjectType_STATUS(*source.ObjectType)
		rule.ObjectType = &objectType
	} else {
		rule.ObjectType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AzureRetentionRule_STATUS populates the provided destination AzureRetentionRule_STATUS from our AzureRetentionRule_STATUS
func (rule *AzureRetentionRule_STATUS) AssignProperties_To_AzureRetentionRule_STATUS(destination *v20230101s.AzureRetentionRule_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// IsDefault
	if rule.IsDefault != nil {
		isDefault := *rule.IsDefault
		destination.IsDefault = &isDefault
	} else {
		destination.IsDefault = nil
	}

	// Lifecycles
	if rule.Lifecycles != nil {
		lifecycleList := make([]v20230101s.SourceLifeCycle_STATUS, len(rule.Lifecycles))
		for lifecycleIndex, lifecycleItem := range rule.Lifecycles {
			// Shadow the loop variable to avoid aliasing
			lifecycleItem := lifecycleItem
			var lifecycle v20230101s.SourceLifeCycle_STATUS
			err := lifecycleItem.AssignProperties_To_SourceLifeCycle_STATUS(&lifecycle)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SourceLifeCycle_STATUS() to populate field Lifecycles")
			}
			lifecycleList[lifecycleIndex] = lifecycle
		}
		destination.Lifecycles = lifecycleList
	} else {
		destination.Lifecycles = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(rule.Name)

	// ObjectType
	if rule.ObjectType != nil {
		objectType := string(*rule.ObjectType)
		destination.ObjectType = &objectType
	} else {
		destination.ObjectType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type BackupParameters struct {
	// AzureBackupParams: Mutually exclusive with all other properties
	AzureBackupParams *AzureBackupParams `json:"azureBackupParams,omitempty"`
}

var _ genruntime.ARMTransformer = &BackupParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameters *BackupParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameters == nil {
		return nil, nil
	}
	result := &BackupParameters_ARM{}

	// Set property "AzureBackupParams":
	if parameters.AzureBackupParams != nil {
		azureBackupParams_ARM, err := (*parameters.AzureBackupParams).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		azureBackupParams := *azureBackupParams_ARM.(*AzureBackupParams_ARM)
		result.AzureBackupParams = &azureBackupParams
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *BackupParameters) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &BackupParameters_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *BackupParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(BackupParameters_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected BackupParameters_ARM, got %T", armInput)
	}

	// Set property "AzureBackupParams":
	if typedInput.AzureBackupParams != nil {
		var azureBackupParams1 AzureBackupParams
		err := azureBackupParams1.PopulateFromARM(owner, *typedInput.AzureBackupParams)
		if err != nil {
			return err
		}
		azureBackupParams := azureBackupParams1
		parameters.AzureBackupParams = &azureBackupParams
	}

	// No error
	return nil
}

// AssignProperties_From_BackupParameters populates our BackupParameters from the provided source BackupParameters
func (parameters *BackupParameters) AssignProperties_From_BackupParameters(source *v20230101s.BackupParameters) error {

	// AzureBackupParams
	if source.AzureBackupParams != nil {
		var azureBackupParam AzureBackupParams
		err := azureBackupParam.AssignProperties_From_AzureBackupParams(source.AzureBackupParams)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AzureBackupParams() to populate field AzureBackupParams")
		}
		parameters.AzureBackupParams = &azureBackupParam
	} else {
		parameters.AzureBackupParams = nil
	}

	// No error
	return nil
}

// AssignProperties_To_BackupParameters populates the provided destination BackupParameters from our BackupParameters
func (parameters *BackupParameters) AssignProperties_To_BackupParameters(destination *v20230101s.BackupParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureBackupParams
	if parameters.AzureBackupParams != nil {
		var azureBackupParam v20230101s.AzureBackupParams
		err := parameters.AzureBackupParams.AssignProperties_To_AzureBackupParams(&azureBackupParam)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AzureBackupParams() to populate field AzureBackupParams")
		}
		destination.AzureBackupParams = &azureBackupParam
	} else {
		destination.AzureBackupParams = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_BackupParameters_STATUS populates our BackupParameters from the provided source BackupParameters_STATUS
func (parameters *BackupParameters) Initialize_From_BackupParameters_STATUS(source *BackupParameters_STATUS) error {

	// AzureBackupParams
	if source.AzureBackupParams != nil {
		var azureBackupParam AzureBackupParams
		err := azureBackupParam.Initialize_From_AzureBackupParams_STATUS(source.AzureBackupParams)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_AzureBackupParams_STATUS() to populate field AzureBackupParams")
		}
		parameters.AzureBackupParams = &azureBackupParam
	} else {
		parameters.AzureBackupParams = nil
	}

	// No error
	return nil
}

type BackupParameters_STATUS struct {
	// AzureBackupParams: Mutually exclusive with all other properties
	AzureBackupParams *AzureBackupParams_STATUS `json:"azureBackupParams,omitempty"`
}

var _ genruntime.FromARMConverter = &BackupParameters_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *BackupParameters_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &BackupParameters_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *BackupParameters_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(BackupParameters_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected BackupParameters_STATUS_ARM, got %T", armInput)
	}

	// Set property "AzureBackupParams":
	if typedInput.AzureBackupParams != nil {
		var azureBackupParams1 AzureBackupParams_STATUS
		err := azureBackupParams1.PopulateFromARM(owner, *typedInput.AzureBackupParams)
		if err != nil {
			return err
		}
		azureBackupParams := azureBackupParams1
		parameters.AzureBackupParams = &azureBackupParams
	}

	// No error
	return nil
}

// AssignProperties_From_BackupParameters_STATUS populates our BackupParameters_STATUS from the provided source BackupParameters_STATUS
func (parameters *BackupParameters_STATUS) AssignProperties_From_BackupParameters_STATUS(source *v20230101s.BackupParameters_STATUS) error {

	// AzureBackupParams
	if source.AzureBackupParams != nil {
		var azureBackupParam AzureBackupParams_STATUS
		err := azureBackupParam.AssignProperties_From_AzureBackupParams_STATUS(source.AzureBackupParams)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AzureBackupParams_STATUS() to populate field AzureBackupParams")
		}
		parameters.AzureBackupParams = &azureBackupParam
	} else {
		parameters.AzureBackupParams = nil
	}

	// No error
	return nil
}

// AssignProperties_To_BackupParameters_STATUS populates the provided destination BackupParameters_STATUS from our BackupParameters_STATUS
func (parameters *BackupParameters_STATUS) AssignProperties_To_BackupParameters_STATUS(destination *v20230101s.BackupParameters_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureBackupParams
	if parameters.AzureBackupParams != nil {
		var azureBackupParam v20230101s.AzureBackupParams_STATUS
		err := parameters.AzureBackupParams.AssignProperties_To_AzureBackupParams_STATUS(&azureBackupParam)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AzureBackupParams_STATUS() to populate field AzureBackupParams")
		}
		destination.AzureBackupParams = &azureBackupParam
	} else {
		destination.AzureBackupParams = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// DataStoreInfo base
type DataStoreInfoBase struct {
	// +kubebuilder:validation:Required
	// DataStoreType: type of datastore; Operational/Vault/Archive
	DataStoreType *DataStoreInfoBase_DataStoreType `json:"dataStoreType,omitempty"`

	// +kubebuilder:validation:Required
	// ObjectType: Type of Datasource object, used to initialize the right inherited type
	ObjectType *string `json:"objectType,omitempty"`
}

var _ genruntime.ARMTransformer = &DataStoreInfoBase{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (base *DataStoreInfoBase) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if base == nil {
		return nil, nil
	}
	result := &DataStoreInfoBase_ARM{}

	// Set property "DataStoreType":
	if base.DataStoreType != nil {
		dataStoreType := *base.DataStoreType
		result.DataStoreType = &dataStoreType
	}

	// Set property "ObjectType":
	if base.ObjectType != nil {
		objectType := *base.ObjectType
		result.ObjectType = &objectType
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (base *DataStoreInfoBase) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DataStoreInfoBase_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (base *DataStoreInfoBase) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DataStoreInfoBase_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DataStoreInfoBase_ARM, got %T", armInput)
	}

	// Set property "DataStoreType":
	if typedInput.DataStoreType != nil {
		dataStoreType := *typedInput.DataStoreType
		base.DataStoreType = &dataStoreType
	}

	// Set property "ObjectType":
	if typedInput.ObjectType != nil {
		objectType := *typedInput.ObjectType
		base.ObjectType = &objectType
	}

	// No error
	return nil
}

// AssignProperties_From_DataStoreInfoBase populates our DataStoreInfoBase from the provided source DataStoreInfoBase
func (base *DataStoreInfoBase) AssignProperties_From_DataStoreInfoBase(source *v20230101s.DataStoreInfoBase) error {

	// DataStoreType
	if source.DataStoreType != nil {
		dataStoreType := DataStoreInfoBase_DataStoreType(*source.DataStoreType)
		base.DataStoreType = &dataStoreType
	} else {
		base.DataStoreType = nil
	}

	// ObjectType
	base.ObjectType = genruntime.ClonePointerToString(source.ObjectType)

	// No error
	return nil
}

// AssignProperties_To_DataStoreInfoBase populates the provided destination DataStoreInfoBase from our DataStoreInfoBase
func (base *DataStoreInfoBase) AssignProperties_To_DataStoreInfoBase(destination *v20230101s.DataStoreInfoBase) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DataStoreType
	if base.DataStoreType != nil {
		dataStoreType := string(*base.DataStoreType)
		destination.DataStoreType = &dataStoreType
	} else {
		destination.DataStoreType = nil
	}

	// ObjectType
	destination.ObjectType = genruntime.ClonePointerToString(base.ObjectType)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DataStoreInfoBase_STATUS populates our DataStoreInfoBase from the provided source DataStoreInfoBase_STATUS
func (base *DataStoreInfoBase) Initialize_From_DataStoreInfoBase_STATUS(source *DataStoreInfoBase_STATUS) error {

	// DataStoreType
	if source.DataStoreType != nil {
		dataStoreType := DataStoreInfoBase_DataStoreType(*source.DataStoreType)
		base.DataStoreType = &dataStoreType
	} else {
		base.DataStoreType = nil
	}

	// ObjectType
	base.ObjectType = genruntime.ClonePointerToString(source.ObjectType)

	// No error
	return nil
}

// DataStoreInfo base
type DataStoreInfoBase_STATUS struct {
	// DataStoreType: type of datastore; Operational/Vault/Archive
	DataStoreType *DataStoreInfoBase_DataStoreType_STATUS `json:"dataStoreType,omitempty"`

	// ObjectType: Type of Datasource object, used to initialize the right inherited type
	ObjectType *string `json:"objectType,omitempty"`
}

var _ genruntime.FromARMConverter = &DataStoreInfoBase_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (base *DataStoreInfoBase_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DataStoreInfoBase_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (base *DataStoreInfoBase_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DataStoreInfoBase_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DataStoreInfoBase_STATUS_ARM, got %T", armInput)
	}

	// Set property "DataStoreType":
	if typedInput.DataStoreType != nil {
		dataStoreType := *typedInput.DataStoreType
		base.DataStoreType = &dataStoreType
	}

	// Set property "ObjectType":
	if typedInput.ObjectType != nil {
		objectType := *typedInput.ObjectType
		base.ObjectType = &objectType
	}

	// No error
	return nil
}

// AssignProperties_From_DataStoreInfoBase_STATUS populates our DataStoreInfoBase_STATUS from the provided source DataStoreInfoBase_STATUS
func (base *DataStoreInfoBase_STATUS) AssignProperties_From_DataStoreInfoBase_STATUS(source *v20230101s.DataStoreInfoBase_STATUS) error {

	// DataStoreType
	if source.DataStoreType != nil {
		dataStoreType := DataStoreInfoBase_DataStoreType_STATUS(*source.DataStoreType)
		base.DataStoreType = &dataStoreType
	} else {
		base.DataStoreType = nil
	}

	// ObjectType
	base.ObjectType = genruntime.ClonePointerToString(source.ObjectType)

	// No error
	return nil
}

// AssignProperties_To_DataStoreInfoBase_STATUS populates the provided destination DataStoreInfoBase_STATUS from our DataStoreInfoBase_STATUS
func (base *DataStoreInfoBase_STATUS) AssignProperties_To_DataStoreInfoBase_STATUS(destination *v20230101s.DataStoreInfoBase_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DataStoreType
	if base.DataStoreType != nil {
		dataStoreType := string(*base.DataStoreType)
		destination.DataStoreType = &dataStoreType
	} else {
		destination.DataStoreType = nil
	}

	// ObjectType
	destination.ObjectType = genruntime.ClonePointerToString(base.ObjectType)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Source LifeCycle
type SourceLifeCycle struct {
	// +kubebuilder:validation:Required
	DeleteAfter *DeleteOption `json:"deleteAfter,omitempty"`

	// +kubebuilder:validation:Required
	// SourceDataStore: DataStoreInfo base
	SourceDataStore             *DataStoreInfoBase  `json:"sourceDataStore,omitempty"`
	TargetDataStoreCopySettings []TargetCopySetting `json:"targetDataStoreCopySettings,omitempty"`
}

var _ genruntime.ARMTransformer = &SourceLifeCycle{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (cycle *SourceLifeCycle) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if cycle == nil {
		return nil, nil
	}
	result := &SourceLifeCycle_ARM{}

	// Set property "DeleteAfter":
	if cycle.DeleteAfter != nil {
		deleteAfter_ARM, err := (*cycle.DeleteAfter).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		deleteAfter := *deleteAfter_ARM.(*DeleteOption_ARM)
		result.DeleteAfter = &deleteAfter
	}

	// Set property "SourceDataStore":
	if cycle.SourceDataStore != nil {
		sourceDataStore_ARM, err := (*cycle.SourceDataStore).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		sourceDataStore := *sourceDataStore_ARM.(*DataStoreInfoBase_ARM)
		result.SourceDataStore = &sourceDataStore
	}

	// Set property "TargetDataStoreCopySettings":
	for _, item := range cycle.TargetDataStoreCopySettings {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.TargetDataStoreCopySettings = append(result.TargetDataStoreCopySettings, *item_ARM.(*TargetCopySetting_ARM))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (cycle *SourceLifeCycle) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &SourceLifeCycle_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (cycle *SourceLifeCycle) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(SourceLifeCycle_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected SourceLifeCycle_ARM, got %T", armInput)
	}

	// Set property "DeleteAfter":
	if typedInput.DeleteAfter != nil {
		var deleteAfter1 DeleteOption
		err := deleteAfter1.PopulateFromARM(owner, *typedInput.DeleteAfter)
		if err != nil {
			return err
		}
		deleteAfter := deleteAfter1
		cycle.DeleteAfter = &deleteAfter
	}

	// Set property "SourceDataStore":
	if typedInput.SourceDataStore != nil {
		var sourceDataStore1 DataStoreInfoBase
		err := sourceDataStore1.PopulateFromARM(owner, *typedInput.SourceDataStore)
		if err != nil {
			return err
		}
		sourceDataStore := sourceDataStore1
		cycle.SourceDataStore = &sourceDataStore
	}

	// Set property "TargetDataStoreCopySettings":
	for _, item := range typedInput.TargetDataStoreCopySettings {
		var item1 TargetCopySetting
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		cycle.TargetDataStoreCopySettings = append(cycle.TargetDataStoreCopySettings, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_SourceLifeCycle populates our SourceLifeCycle from the provided source SourceLifeCycle
func (cycle *SourceLifeCycle) AssignProperties_From_SourceLifeCycle(source *v20230101s.SourceLifeCycle) error {

	// DeleteAfter
	if source.DeleteAfter != nil {
		var deleteAfter DeleteOption
		err := deleteAfter.AssignProperties_From_DeleteOption(source.DeleteAfter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeleteOption() to populate field DeleteAfter")
		}
		cycle.DeleteAfter = &deleteAfter
	} else {
		cycle.DeleteAfter = nil
	}

	// SourceDataStore
	if source.SourceDataStore != nil {
		var sourceDataStore DataStoreInfoBase
		err := sourceDataStore.AssignProperties_From_DataStoreInfoBase(source.SourceDataStore)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DataStoreInfoBase() to populate field SourceDataStore")
		}
		cycle.SourceDataStore = &sourceDataStore
	} else {
		cycle.SourceDataStore = nil
	}

	// TargetDataStoreCopySettings
	if source.TargetDataStoreCopySettings != nil {
		targetDataStoreCopySettingList := make([]TargetCopySetting, len(source.TargetDataStoreCopySettings))
		for targetDataStoreCopySettingIndex, targetDataStoreCopySettingItem := range source.TargetDataStoreCopySettings {
			// Shadow the loop variable to avoid aliasing
			targetDataStoreCopySettingItem := targetDataStoreCopySettingItem
			var targetDataStoreCopySetting TargetCopySetting
			err := targetDataStoreCopySetting.AssignProperties_From_TargetCopySetting(&targetDataStoreCopySettingItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_TargetCopySetting() to populate field TargetDataStoreCopySettings")
			}
			targetDataStoreCopySettingList[targetDataStoreCopySettingIndex] = targetDataStoreCopySetting
		}
		cycle.TargetDataStoreCopySettings = targetDataStoreCopySettingList
	} else {
		cycle.TargetDataStoreCopySettings = nil
	}

	// No error
	return nil
}

// AssignProperties_To_SourceLifeCycle populates the provided destination SourceLifeCycle from our SourceLifeCycle
func (cycle *SourceLifeCycle) AssignProperties_To_SourceLifeCycle(destination *v20230101s.SourceLifeCycle) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DeleteAfter
	if cycle.DeleteAfter != nil {
		var deleteAfter v20230101s.DeleteOption
		err := cycle.DeleteAfter.AssignProperties_To_DeleteOption(&deleteAfter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeleteOption() to populate field DeleteAfter")
		}
		destination.DeleteAfter = &deleteAfter
	} else {
		destination.DeleteAfter = nil
	}

	// SourceDataStore
	if cycle.SourceDataStore != nil {
		var sourceDataStore v20230101s.DataStoreInfoBase
		err := cycle.SourceDataStore.AssignProperties_To_DataStoreInfoBase(&sourceDataStore)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DataStoreInfoBase() to populate field SourceDataStore")
		}
		destination.SourceDataStore = &sourceDataStore
	} else {
		destination.SourceDataStore = nil
	}

	// TargetDataStoreCopySettings
	if cycle.TargetDataStoreCopySettings != nil {
		targetDataStoreCopySettingList := make([]v20230101s.TargetCopySetting, len(cycle.TargetDataStoreCopySettings))
		for targetDataStoreCopySettingIndex, targetDataStoreCopySettingItem := range cycle.TargetDataStoreCopySettings {
			// Shadow the loop variable to avoid aliasing
			targetDataStoreCopySettingItem := targetDataStoreCopySettingItem
			var targetDataStoreCopySetting v20230101s.TargetCopySetting
			err := targetDataStoreCopySettingItem.AssignProperties_To_TargetCopySetting(&targetDataStoreCopySetting)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_TargetCopySetting() to populate field TargetDataStoreCopySettings")
			}
			targetDataStoreCopySettingList[targetDataStoreCopySettingIndex] = targetDataStoreCopySetting
		}
		destination.TargetDataStoreCopySettings = targetDataStoreCopySettingList
	} else {
		destination.TargetDataStoreCopySettings = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_SourceLifeCycle_STATUS populates our SourceLifeCycle from the provided source SourceLifeCycle_STATUS
func (cycle *SourceLifeCycle) Initialize_From_SourceLifeCycle_STATUS(source *SourceLifeCycle_STATUS) error {

	// DeleteAfter
	if source.DeleteAfter != nil {
		var deleteAfter DeleteOption
		err := deleteAfter.Initialize_From_DeleteOption_STATUS(source.DeleteAfter)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_DeleteOption_STATUS() to populate field DeleteAfter")
		}
		cycle.DeleteAfter = &deleteAfter
	} else {
		cycle.DeleteAfter = nil
	}

	// SourceDataStore
	if source.SourceDataStore != nil {
		var sourceDataStore DataStoreInfoBase
		err := sourceDataStore.Initialize_From_DataStoreInfoBase_STATUS(source.SourceDataStore)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_DataStoreInfoBase_STATUS() to populate field SourceDataStore")
		}
		cycle.SourceDataStore = &sourceDataStore
	} else {
		cycle.SourceDataStore = nil
	}

	// TargetDataStoreCopySettings
	if source.TargetDataStoreCopySettings != nil {
		targetDataStoreCopySettingList := make([]TargetCopySetting, len(source.TargetDataStoreCopySettings))
		for targetDataStoreCopySettingIndex, targetDataStoreCopySettingItem := range source.TargetDataStoreCopySettings {
			// Shadow the loop variable to avoid aliasing
			targetDataStoreCopySettingItem := targetDataStoreCopySettingItem
			var targetDataStoreCopySetting TargetCopySetting
			err := targetDataStoreCopySetting.Initialize_From_TargetCopySetting_STATUS(&targetDataStoreCopySettingItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_TargetCopySetting_STATUS() to populate field TargetDataStoreCopySettings")
			}
			targetDataStoreCopySettingList[targetDataStoreCopySettingIndex] = targetDataStoreCopySetting
		}
		cycle.TargetDataStoreCopySettings = targetDataStoreCopySettingList
	} else {
		cycle.TargetDataStoreCopySettings = nil
	}

	// No error
	return nil
}

// Source LifeCycle
type SourceLifeCycle_STATUS struct {
	DeleteAfter *DeleteOption_STATUS `json:"deleteAfter,omitempty"`

	// SourceDataStore: DataStoreInfo base
	SourceDataStore             *DataStoreInfoBase_STATUS  `json:"sourceDataStore,omitempty"`
	TargetDataStoreCopySettings []TargetCopySetting_STATUS `json:"targetDataStoreCopySettings,omitempty"`
}

var _ genruntime.FromARMConverter = &SourceLifeCycle_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (cycle *SourceLifeCycle_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &SourceLifeCycle_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (cycle *SourceLifeCycle_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(SourceLifeCycle_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected SourceLifeCycle_STATUS_ARM, got %T", armInput)
	}

	// Set property "DeleteAfter":
	if typedInput.DeleteAfter != nil {
		var deleteAfter1 DeleteOption_STATUS
		err := deleteAfter1.PopulateFromARM(owner, *typedInput.DeleteAfter)
		if err != nil {
			return err
		}
		deleteAfter := deleteAfter1
		cycle.DeleteAfter = &deleteAfter
	}

	// Set property "SourceDataStore":
	if typedInput.SourceDataStore != nil {
		var sourceDataStore1 DataStoreInfoBase_STATUS
		err := sourceDataStore1.PopulateFromARM(owner, *typedInput.SourceDataStore)
		if err != nil {
			return err
		}
		sourceDataStore := sourceDataStore1
		cycle.SourceDataStore = &sourceDataStore
	}

	// Set property "TargetDataStoreCopySettings":
	for _, item := range typedInput.TargetDataStoreCopySettings {
		var item1 TargetCopySetting_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		cycle.TargetDataStoreCopySettings = append(cycle.TargetDataStoreCopySettings, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_SourceLifeCycle_STATUS populates our SourceLifeCycle_STATUS from the provided source SourceLifeCycle_STATUS
func (cycle *SourceLifeCycle_STATUS) AssignProperties_From_SourceLifeCycle_STATUS(source *v20230101s.SourceLifeCycle_STATUS) error {

	// DeleteAfter
	if source.DeleteAfter != nil {
		var deleteAfter DeleteOption_STATUS
		err := deleteAfter.AssignProperties_From_DeleteOption_STATUS(source.DeleteAfter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeleteOption_STATUS() to populate field DeleteAfter")
		}
		cycle.DeleteAfter = &deleteAfter
	} else {
		cycle.DeleteAfter = nil
	}

	// SourceDataStore
	if source.SourceDataStore != nil {
		var sourceDataStore DataStoreInfoBase_STATUS
		err := sourceDataStore.AssignProperties_From_DataStoreInfoBase_STATUS(source.SourceDataStore)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DataStoreInfoBase_STATUS() to populate field SourceDataStore")
		}
		cycle.SourceDataStore = &sourceDataStore
	} else {
		cycle.SourceDataStore = nil
	}

	// TargetDataStoreCopySettings
	if source.TargetDataStoreCopySettings != nil {
		targetDataStoreCopySettingList := make([]TargetCopySetting_STATUS, len(source.TargetDataStoreCopySettings))
		for targetDataStoreCopySettingIndex, targetDataStoreCopySettingItem := range source.TargetDataStoreCopySettings {
			// Shadow the loop variable to avoid aliasing
			targetDataStoreCopySettingItem := targetDataStoreCopySettingItem
			var targetDataStoreCopySetting TargetCopySetting_STATUS
			err := targetDataStoreCopySetting.AssignProperties_From_TargetCopySetting_STATUS(&targetDataStoreCopySettingItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_TargetCopySetting_STATUS() to populate field TargetDataStoreCopySettings")
			}
			targetDataStoreCopySettingList[targetDataStoreCopySettingIndex] = targetDataStoreCopySetting
		}
		cycle.TargetDataStoreCopySettings = targetDataStoreCopySettingList
	} else {
		cycle.TargetDataStoreCopySettings = nil
	}

	// No error
	return nil
}

// AssignProperties_To_SourceLifeCycle_STATUS populates the provided destination SourceLifeCycle_STATUS from our SourceLifeCycle_STATUS
func (cycle *SourceLifeCycle_STATUS) AssignProperties_To_SourceLifeCycle_STATUS(destination *v20230101s.SourceLifeCycle_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DeleteAfter
	if cycle.DeleteAfter != nil {
		var deleteAfter v20230101s.DeleteOption_STATUS
		err := cycle.DeleteAfter.AssignProperties_To_DeleteOption_STATUS(&deleteAfter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeleteOption_STATUS() to populate field DeleteAfter")
		}
		destination.DeleteAfter = &deleteAfter
	} else {
		destination.DeleteAfter = nil
	}

	// SourceDataStore
	if cycle.SourceDataStore != nil {
		var sourceDataStore v20230101s.DataStoreInfoBase_STATUS
		err := cycle.SourceDataStore.AssignProperties_To_DataStoreInfoBase_STATUS(&sourceDataStore)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DataStoreInfoBase_STATUS() to populate field SourceDataStore")
		}
		destination.SourceDataStore = &sourceDataStore
	} else {
		destination.SourceDataStore = nil
	}

	// TargetDataStoreCopySettings
	if cycle.TargetDataStoreCopySettings != nil {
		targetDataStoreCopySettingList := make([]v20230101s.TargetCopySetting_STATUS, len(cycle.TargetDataStoreCopySettings))
		for targetDataStoreCopySettingIndex, targetDataStoreCopySettingItem := range cycle.TargetDataStoreCopySettings {
			// Shadow the loop variable to avoid aliasing
			targetDataStoreCopySettingItem := targetDataStoreCopySettingItem
			var targetDataStoreCopySetting v20230101s.TargetCopySetting_STATUS
			err := targetDataStoreCopySettingItem.AssignProperties_To_TargetCopySetting_STATUS(&targetDataStoreCopySetting)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_TargetCopySetting_STATUS() to populate field TargetDataStoreCopySettings")
			}
			targetDataStoreCopySettingList[targetDataStoreCopySettingIndex] = targetDataStoreCopySetting
		}
		destination.TargetDataStoreCopySettings = targetDataStoreCopySettingList
	} else {
		destination.TargetDataStoreCopySettings = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type TriggerContext struct {
	// Adhoc: Mutually exclusive with all other properties
	Adhoc *AdhocBasedTriggerContext `json:"adhocBasedTriggerContext,omitempty"`

	// Schedule: Mutually exclusive with all other properties
	Schedule *ScheduleBasedTriggerContext `json:"scheduleBasedTriggerContext,omitempty"`
}

var _ genruntime.ARMTransformer = &TriggerContext{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (context *TriggerContext) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if context == nil {
		return nil, nil
	}
	result := &TriggerContext_ARM{}

	// Set property "Adhoc":
	if context.Adhoc != nil {
		adhoc_ARM, err := (*context.Adhoc).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		adhoc := *adhoc_ARM.(*AdhocBasedTriggerContext_ARM)
		result.Adhoc = &adhoc
	}

	// Set property "Schedule":
	if context.Schedule != nil {
		schedule_ARM, err := (*context.Schedule).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		schedule := *schedule_ARM.(*ScheduleBasedTriggerContext_ARM)
		result.Schedule = &schedule
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (context *TriggerContext) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &TriggerContext_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (context *TriggerContext) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(TriggerContext_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected TriggerContext_ARM, got %T", armInput)
	}

	// Set property "Adhoc":
	if typedInput.Adhoc != nil {
		var adhoc1 AdhocBasedTriggerContext
		err := adhoc1.PopulateFromARM(owner, *typedInput.Adhoc)
		if err != nil {
			return err
		}
		adhoc := adhoc1
		context.Adhoc = &adhoc
	}

	// Set property "Schedule":
	if typedInput.Schedule != nil {
		var schedule1 ScheduleBasedTriggerContext
		err := schedule1.PopulateFromARM(owner, *typedInput.Schedule)
		if err != nil {
			return err
		}
		schedule := schedule1
		context.Schedule = &schedule
	}

	// No error
	return nil
}

// AssignProperties_From_TriggerContext populates our TriggerContext from the provided source TriggerContext
func (context *TriggerContext) AssignProperties_From_TriggerContext(source *v20230101s.TriggerContext) error {

	// Adhoc
	if source.Adhoc != nil {
		var adhoc AdhocBasedTriggerContext
		err := adhoc.AssignProperties_From_AdhocBasedTriggerContext(source.Adhoc)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AdhocBasedTriggerContext() to populate field Adhoc")
		}
		context.Adhoc = &adhoc
	} else {
		context.Adhoc = nil
	}

	// Schedule
	if source.Schedule != nil {
		var schedule ScheduleBasedTriggerContext
		err := schedule.AssignProperties_From_ScheduleBasedTriggerContext(source.Schedule)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ScheduleBasedTriggerContext() to populate field Schedule")
		}
		context.Schedule = &schedule
	} else {
		context.Schedule = nil
	}

	// No error
	return nil
}

// AssignProperties_To_TriggerContext populates the provided destination TriggerContext from our TriggerContext
func (context *TriggerContext) AssignProperties_To_TriggerContext(destination *v20230101s.TriggerContext) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Adhoc
	if context.Adhoc != nil {
		var adhoc v20230101s.AdhocBasedTriggerContext
		err := context.Adhoc.AssignProperties_To_AdhocBasedTriggerContext(&adhoc)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AdhocBasedTriggerContext() to populate field Adhoc")
		}
		destination.Adhoc = &adhoc
	} else {
		destination.Adhoc = nil
	}

	// Schedule
	if context.Schedule != nil {
		var schedule v20230101s.ScheduleBasedTriggerContext
		err := context.Schedule.AssignProperties_To_ScheduleBasedTriggerContext(&schedule)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ScheduleBasedTriggerContext() to populate field Schedule")
		}
		destination.Schedule = &schedule
	} else {
		destination.Schedule = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_TriggerContext_STATUS populates our TriggerContext from the provided source TriggerContext_STATUS
func (context *TriggerContext) Initialize_From_TriggerContext_STATUS(source *TriggerContext_STATUS) error {

	// Adhoc
	if source.Adhoc != nil {
		var adhoc AdhocBasedTriggerContext
		err := adhoc.Initialize_From_AdhocBasedTriggerContext_STATUS(source.Adhoc)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_AdhocBasedTriggerContext_STATUS() to populate field Adhoc")
		}
		context.Adhoc = &adhoc
	} else {
		context.Adhoc = nil
	}

	// Schedule
	if source.Schedule != nil {
		var schedule ScheduleBasedTriggerContext
		err := schedule.Initialize_From_ScheduleBasedTriggerContext_STATUS(source.Schedule)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_ScheduleBasedTriggerContext_STATUS() to populate field Schedule")
		}
		context.Schedule = &schedule
	} else {
		context.Schedule = nil
	}

	// No error
	return nil
}

type TriggerContext_STATUS struct {
	// Adhoc: Mutually exclusive with all other properties
	Adhoc *AdhocBasedTriggerContext_STATUS `json:"adhocBasedTriggerContext,omitempty"`

	// Schedule: Mutually exclusive with all other properties
	Schedule *ScheduleBasedTriggerContext_STATUS `json:"scheduleBasedTriggerContext,omitempty"`
}

var _ genruntime.FromARMConverter = &TriggerContext_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (context *TriggerContext_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &TriggerContext_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (context *TriggerContext_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(TriggerContext_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected TriggerContext_STATUS_ARM, got %T", armInput)
	}

	// Set property "Adhoc":
	if typedInput.Adhoc != nil {
		var adhoc1 AdhocBasedTriggerContext_STATUS
		err := adhoc1.PopulateFromARM(owner, *typedInput.Adhoc)
		if err != nil {
			return err
		}
		adhoc := adhoc1
		context.Adhoc = &adhoc
	}

	// Set property "Schedule":
	if typedInput.Schedule != nil {
		var schedule1 ScheduleBasedTriggerContext_STATUS
		err := schedule1.PopulateFromARM(owner, *typedInput.Schedule)
		if err != nil {
			return err
		}
		schedule := schedule1
		context.Schedule = &schedule
	}

	// No error
	return nil
}

// AssignProperties_From_TriggerContext_STATUS populates our TriggerContext_STATUS from the provided source TriggerContext_STATUS
func (context *TriggerContext_STATUS) AssignProperties_From_TriggerContext_STATUS(source *v20230101s.TriggerContext_STATUS) error {

	// Adhoc
	if source.Adhoc != nil {
		var adhoc AdhocBasedTriggerContext_STATUS
		err := adhoc.AssignProperties_From_AdhocBasedTriggerContext_STATUS(source.Adhoc)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AdhocBasedTriggerContext_STATUS() to populate field Adhoc")
		}
		context.Adhoc = &adhoc
	} else {
		context.Adhoc = nil
	}

	// Schedule
	if source.Schedule != nil {
		var schedule ScheduleBasedTriggerContext_STATUS
		err := schedule.AssignProperties_From_ScheduleBasedTriggerContext_STATUS(source.Schedule)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ScheduleBasedTriggerContext_STATUS() to populate field Schedule")
		}
		context.Schedule = &schedule
	} else {
		context.Schedule = nil
	}

	// No error
	return nil
}

// AssignProperties_To_TriggerContext_STATUS populates the provided destination TriggerContext_STATUS from our TriggerContext_STATUS
func (context *TriggerContext_STATUS) AssignProperties_To_TriggerContext_STATUS(destination *v20230101s.TriggerContext_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Adhoc
	if context.Adhoc != nil {
		var adhoc v20230101s.AdhocBasedTriggerContext_STATUS
		err := context.Adhoc.AssignProperties_To_AdhocBasedTriggerContext_STATUS(&adhoc)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AdhocBasedTriggerContext_STATUS() to populate field Adhoc")
		}
		destination.Adhoc = &adhoc
	} else {
		destination.Adhoc = nil
	}

	// Schedule
	if context.Schedule != nil {
		var schedule v20230101s.ScheduleBasedTriggerContext_STATUS
		err := context.Schedule.AssignProperties_To_ScheduleBasedTriggerContext_STATUS(&schedule)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ScheduleBasedTriggerContext_STATUS() to populate field Schedule")
		}
		destination.Schedule = &schedule
	} else {
		destination.Schedule = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type AdhocBasedTriggerContext struct {
	// +kubebuilder:validation:Required
	// ObjectType: Type of the specific object - used for deserializing
	ObjectType *AdhocBasedTriggerContext_ObjectType `json:"objectType,omitempty"`

	// +kubebuilder:validation:Required
	// TaggingCriteria: Tagging Criteria containing retention tag for adhoc backup.
	TaggingCriteria *AdhocBasedTaggingCriteria `json:"taggingCriteria,omitempty"`
}

var _ genruntime.ARMTransformer = &AdhocBasedTriggerContext{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (context *AdhocBasedTriggerContext) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if context == nil {
		return nil, nil
	}
	result := &AdhocBasedTriggerContext_ARM{}

	// Set property "ObjectType":
	if context.ObjectType != nil {
		result.ObjectType = *context.ObjectType
	}

	// Set property "TaggingCriteria":
	if context.TaggingCriteria != nil {
		taggingCriteria_ARM, err := (*context.TaggingCriteria).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		taggingCriteria := *taggingCriteria_ARM.(*AdhocBasedTaggingCriteria_ARM)
		result.TaggingCriteria = &taggingCriteria
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (context *AdhocBasedTriggerContext) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &AdhocBasedTriggerContext_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (context *AdhocBasedTriggerContext) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(AdhocBasedTriggerContext_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected AdhocBasedTriggerContext_ARM, got %T", armInput)
	}

	// Set property "ObjectType":
	context.ObjectType = &typedInput.ObjectType

	// Set property "TaggingCriteria":
	if typedInput.TaggingCriteria != nil {
		var taggingCriteria1 AdhocBasedTaggingCriteria
		err := taggingCriteria1.PopulateFromARM(owner, *typedInput.TaggingCriteria)
		if err != nil {
			return err
		}
		taggingCriteria := taggingCriteria1
		context.TaggingCriteria = &taggingCriteria
	}

	// No error
	return nil
}

// AssignProperties_From_AdhocBasedTriggerContext populates our AdhocBasedTriggerContext from the provided source AdhocBasedTriggerContext
func (context *AdhocBasedTriggerContext) AssignProperties_From_AdhocBasedTriggerContext(source *v20230101s.AdhocBasedTriggerContext) error {

	// ObjectType
	if source.ObjectType != nil {
		objectType := AdhocBasedTriggerContext_ObjectType(*source.ObjectType)
		context.ObjectType = &objectType
	} else {
		context.ObjectType = nil
	}

	// TaggingCriteria
	if source.TaggingCriteria != nil {
		var taggingCriterion AdhocBasedTaggingCriteria
		err := taggingCriterion.AssignProperties_From_AdhocBasedTaggingCriteria(source.TaggingCriteria)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AdhocBasedTaggingCriteria() to populate field TaggingCriteria")
		}
		context.TaggingCriteria = &taggingCriterion
	} else {
		context.TaggingCriteria = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AdhocBasedTriggerContext populates the provided destination AdhocBasedTriggerContext from our AdhocBasedTriggerContext
func (context *AdhocBasedTriggerContext) AssignProperties_To_AdhocBasedTriggerContext(destination *v20230101s.AdhocBasedTriggerContext) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ObjectType
	if context.ObjectType != nil {
		objectType := string(*context.ObjectType)
		destination.ObjectType = &objectType
	} else {
		destination.ObjectType = nil
	}

	// TaggingCriteria
	if context.TaggingCriteria != nil {
		var taggingCriterion v20230101s.AdhocBasedTaggingCriteria
		err := context.TaggingCriteria.AssignProperties_To_AdhocBasedTaggingCriteria(&taggingCriterion)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AdhocBasedTaggingCriteria() to populate field TaggingCriteria")
		}
		destination.TaggingCriteria = &taggingCriterion
	} else {
		destination.TaggingCriteria = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_AdhocBasedTriggerContext_STATUS populates our AdhocBasedTriggerContext from the provided source AdhocBasedTriggerContext_STATUS
func (context *AdhocBasedTriggerContext) Initialize_From_AdhocBasedTriggerContext_STATUS(source *AdhocBasedTriggerContext_STATUS) error {

	// ObjectType
	if source.ObjectType != nil {
		objectType := AdhocBasedTriggerContext_ObjectType(*source.ObjectType)
		context.ObjectType = &objectType
	} else {
		context.ObjectType = nil
	}

	// TaggingCriteria
	if source.TaggingCriteria != nil {
		var taggingCriterion AdhocBasedTaggingCriteria
		err := taggingCriterion.Initialize_From_AdhocBasedTaggingCriteria_STATUS(source.TaggingCriteria)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_AdhocBasedTaggingCriteria_STATUS() to populate field TaggingCriteria")
		}
		context.TaggingCriteria = &taggingCriterion
	} else {
		context.TaggingCriteria = nil
	}

	// No error
	return nil
}

type AdhocBasedTriggerContext_STATUS struct {
	// ObjectType: Type of the specific object - used for deserializing
	ObjectType *AdhocBasedTriggerContext_ObjectType_STATUS `json:"objectType,omitempty"`

	// TaggingCriteria: Tagging Criteria containing retention tag for adhoc backup.
	TaggingCriteria *AdhocBasedTaggingCriteria_STATUS `json:"taggingCriteria,omitempty"`
}

var _ genruntime.FromARMConverter = &AdhocBasedTriggerContext_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (context *AdhocBasedTriggerContext_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &AdhocBasedTriggerContext_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (context *AdhocBasedTriggerContext_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(AdhocBasedTriggerContext_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected AdhocBasedTriggerContext_STATUS_ARM, got %T", armInput)
	}

	// Set property "ObjectType":
	context.ObjectType = &typedInput.ObjectType

	// Set property "TaggingCriteria":
	if typedInput.TaggingCriteria != nil {
		var taggingCriteria1 AdhocBasedTaggingCriteria_STATUS
		err := taggingCriteria1.PopulateFromARM(owner, *typedInput.TaggingCriteria)
		if err != nil {
			return err
		}
		taggingCriteria := taggingCriteria1
		context.TaggingCriteria = &taggingCriteria
	}

	// No error
	return nil
}

// AssignProperties_From_AdhocBasedTriggerContext_STATUS populates our AdhocBasedTriggerContext_STATUS from the provided source AdhocBasedTriggerContext_STATUS
func (context *AdhocBasedTriggerContext_STATUS) AssignProperties_From_AdhocBasedTriggerContext_STATUS(source *v20230101s.AdhocBasedTriggerContext_STATUS) error {

	// ObjectType
	if source.ObjectType != nil {
		objectType := AdhocBasedTriggerContext_ObjectType_STATUS(*source.ObjectType)
		context.ObjectType = &objectType
	} else {
		context.ObjectType = nil
	}

	// TaggingCriteria
	if source.TaggingCriteria != nil {
		var taggingCriterion AdhocBasedTaggingCriteria_STATUS
		err := taggingCriterion.AssignProperties_From_AdhocBasedTaggingCriteria_STATUS(source.TaggingCriteria)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AdhocBasedTaggingCriteria_STATUS() to populate field TaggingCriteria")
		}
		context.TaggingCriteria = &taggingCriterion
	} else {
		context.TaggingCriteria = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AdhocBasedTriggerContext_STATUS populates the provided destination AdhocBasedTriggerContext_STATUS from our AdhocBasedTriggerContext_STATUS
func (context *AdhocBasedTriggerContext_STATUS) AssignProperties_To_AdhocBasedTriggerContext_STATUS(destination *v20230101s.AdhocBasedTriggerContext_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ObjectType
	if context.ObjectType != nil {
		objectType := string(*context.ObjectType)
		destination.ObjectType = &objectType
	} else {
		destination.ObjectType = nil
	}

	// TaggingCriteria
	if context.TaggingCriteria != nil {
		var taggingCriterion v20230101s.AdhocBasedTaggingCriteria_STATUS
		err := context.TaggingCriteria.AssignProperties_To_AdhocBasedTaggingCriteria_STATUS(&taggingCriterion)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AdhocBasedTaggingCriteria_STATUS() to populate field TaggingCriteria")
		}
		destination.TaggingCriteria = &taggingCriterion
	} else {
		destination.TaggingCriteria = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type AzureBackupParams struct {
	// +kubebuilder:validation:Required
	// BackupType: BackupType ; Full/Incremental etc
	BackupType *string `json:"backupType,omitempty"`

	// +kubebuilder:validation:Required
	// ObjectType: Type of the specific object - used for deserializing
	ObjectType *AzureBackupParams_ObjectType `json:"objectType,omitempty"`
}

var _ genruntime.ARMTransformer = &AzureBackupParams{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (params *AzureBackupParams) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if params == nil {
		return nil, nil
	}
	result := &AzureBackupParams_ARM{}

	// Set property "BackupType":
	if params.BackupType != nil {
		backupType := *params.BackupType
		result.BackupType = &backupType
	}

	// Set property "ObjectType":
	if params.ObjectType != nil {
		result.ObjectType = *params.ObjectType
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (params *AzureBackupParams) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &AzureBackupParams_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (params *AzureBackupParams) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(AzureBackupParams_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected AzureBackupParams_ARM, got %T", armInput)
	}

	// Set property "BackupType":
	if typedInput.BackupType != nil {
		backupType := *typedInput.BackupType
		params.BackupType = &backupType
	}

	// Set property "ObjectType":
	params.ObjectType = &typedInput.ObjectType

	// No error
	return nil
}

// AssignProperties_From_AzureBackupParams populates our AzureBackupParams from the provided source AzureBackupParams
func (params *AzureBackupParams) AssignProperties_From_AzureBackupParams(source *v20230101s.AzureBackupParams) error {

	// BackupType
	params.BackupType = genruntime.ClonePointerToString(source.BackupType)

	// ObjectType
	if source.ObjectType != nil {
		objectType := AzureBackupParams_ObjectType(*source.ObjectType)
		params.ObjectType = &objectType
	} else {
		params.ObjectType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AzureBackupParams populates the provided destination AzureBackupParams from our AzureBackupParams
func (params *AzureBackupParams) AssignProperties_To_AzureBackupParams(destination *v20230101s.AzureBackupParams) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BackupType
	destination.BackupType = genruntime.ClonePointerToString(params.BackupType)

	// ObjectType
	if params.ObjectType != nil {
		objectType := string(*params.ObjectType)
		destination.ObjectType = &objectType
	} else {
		destination.ObjectType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_AzureBackupParams_STATUS populates our AzureBackupParams from the provided source AzureBackupParams_STATUS
func (params *AzureBackupParams) Initialize_From_AzureBackupParams_STATUS(source *AzureBackupParams_STATUS) error {

	// BackupType
	params.BackupType = genruntime.ClonePointerToString(source.BackupType)

	// ObjectType
	if source.ObjectType != nil {
		objectType := AzureBackupParams_ObjectType(*source.ObjectType)
		params.ObjectType = &objectType
	} else {
		params.ObjectType = nil
	}

	// No error
	return nil
}

type AzureBackupParams_STATUS struct {
	// BackupType: BackupType ; Full/Incremental etc
	BackupType *string `json:"backupType,omitempty"`

	// ObjectType: Type of the specific object - used for deserializing
	ObjectType *AzureBackupParams_ObjectType_STATUS `json:"objectType,omitempty"`
}

var _ genruntime.FromARMConverter = &AzureBackupParams_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (params *AzureBackupParams_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &AzureBackupParams_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (params *AzureBackupParams_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(AzureBackupParams_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected AzureBackupParams_STATUS_ARM, got %T", armInput)
	}

	// Set property "BackupType":
	if typedInput.BackupType != nil {
		backupType := *typedInput.BackupType
		params.BackupType = &backupType
	}

	// Set property "ObjectType":
	params.ObjectType = &typedInput.ObjectType

	// No error
	return nil
}

// AssignProperties_From_AzureBackupParams_STATUS populates our AzureBackupParams_STATUS from the provided source AzureBackupParams_STATUS
func (params *AzureBackupParams_STATUS) AssignProperties_From_AzureBackupParams_STATUS(source *v20230101s.AzureBackupParams_STATUS) error {

	// BackupType
	params.BackupType = genruntime.ClonePointerToString(source.BackupType)

	// ObjectType
	if source.ObjectType != nil {
		objectType := AzureBackupParams_ObjectType_STATUS(*source.ObjectType)
		params.ObjectType = &objectType
	} else {
		params.ObjectType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AzureBackupParams_STATUS populates the provided destination AzureBackupParams_STATUS from our AzureBackupParams_STATUS
func (params *AzureBackupParams_STATUS) AssignProperties_To_AzureBackupParams_STATUS(destination *v20230101s.AzureBackupParams_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BackupType
	destination.BackupType = genruntime.ClonePointerToString(params.BackupType)

	// ObjectType
	if params.ObjectType != nil {
		objectType := string(*params.ObjectType)
		destination.ObjectType = &objectType
	} else {
		destination.ObjectType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type DeleteOption struct {
	// AbsoluteDeleteOption: Mutually exclusive with all other properties
	AbsoluteDeleteOption *AbsoluteDeleteOption `json:"absoluteDeleteOption,omitempty"`
}

var _ genruntime.ARMTransformer = &DeleteOption{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (option *DeleteOption) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if option == nil {
		return nil, nil
	}
	result := &DeleteOption_ARM{}

	// Set property "AbsoluteDeleteOption":
	if option.AbsoluteDeleteOption != nil {
		absoluteDeleteOption_ARM, err := (*option.AbsoluteDeleteOption).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		absoluteDeleteOption := *absoluteDeleteOption_ARM.(*AbsoluteDeleteOption_ARM)
		result.AbsoluteDeleteOption = &absoluteDeleteOption
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (option *DeleteOption) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DeleteOption_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (option *DeleteOption) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DeleteOption_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DeleteOption_ARM, got %T", armInput)
	}

	// Set property "AbsoluteDeleteOption":
	if typedInput.AbsoluteDeleteOption != nil {
		var absoluteDeleteOption1 AbsoluteDeleteOption
		err := absoluteDeleteOption1.PopulateFromARM(owner, *typedInput.AbsoluteDeleteOption)
		if err != nil {
			return err
		}
		absoluteDeleteOption := absoluteDeleteOption1
		option.AbsoluteDeleteOption = &absoluteDeleteOption
	}

	// No error
	return nil
}

// AssignProperties_From_DeleteOption populates our DeleteOption from the provided source DeleteOption
func (option *DeleteOption) AssignProperties_From_DeleteOption(source *v20230101s.DeleteOption) error {

	// AbsoluteDeleteOption
	if source.AbsoluteDeleteOption != nil {
		var absoluteDeleteOption AbsoluteDeleteOption
		err := absoluteDeleteOption.AssignProperties_From_AbsoluteDeleteOption(source.AbsoluteDeleteOption)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AbsoluteDeleteOption() to populate field AbsoluteDeleteOption")
		}
		option.AbsoluteDeleteOption = &absoluteDeleteOption
	} else {
		option.AbsoluteDeleteOption = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeleteOption populates the provided destination DeleteOption from our DeleteOption
func (option *DeleteOption) AssignProperties_To_DeleteOption(destination *v20230101s.DeleteOption) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AbsoluteDeleteOption
	if option.AbsoluteDeleteOption != nil {
		var absoluteDeleteOption v20230101s.AbsoluteDeleteOption
		err := option.AbsoluteDeleteOption.AssignProperties_To_AbsoluteDeleteOption(&absoluteDeleteOption)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AbsoluteDeleteOption() to populate field AbsoluteDeleteOption")
		}
		destination.AbsoluteDeleteOption = &absoluteDeleteOption
	} else {
		destination.AbsoluteDeleteOption = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DeleteOption_STATUS populates our DeleteOption from the provided source DeleteOption_STATUS
func (option *DeleteOption) Initialize_From_DeleteOption_STATUS(source *DeleteOption_STATUS) error {

	// AbsoluteDeleteOption
	if source.AbsoluteDeleteOption != nil {
		var absoluteDeleteOption AbsoluteDeleteOption
		err := absoluteDeleteOption.Initialize_From_AbsoluteDeleteOption_STATUS(source.AbsoluteDeleteOption)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_AbsoluteDeleteOption_STATUS() to populate field AbsoluteDeleteOption")
		}
		option.AbsoluteDeleteOption = &absoluteDeleteOption
	} else {
		option.AbsoluteDeleteOption = nil
	}

	// No error
	return nil
}

type DeleteOption_STATUS struct {
	// AbsoluteDeleteOption: Mutually exclusive with all other properties
	AbsoluteDeleteOption *AbsoluteDeleteOption_STATUS `json:"absoluteDeleteOption,omitempty"`
}

var _ genruntime.FromARMConverter = &DeleteOption_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (option *DeleteOption_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DeleteOption_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (option *DeleteOption_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DeleteOption_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DeleteOption_STATUS_ARM, got %T", armInput)
	}

	// Set property "AbsoluteDeleteOption":
	if typedInput.AbsoluteDeleteOption != nil {
		var absoluteDeleteOption1 AbsoluteDeleteOption_STATUS
		err := absoluteDeleteOption1.PopulateFromARM(owner, *typedInput.AbsoluteDeleteOption)
		if err != nil {
			return err
		}
		absoluteDeleteOption := absoluteDeleteOption1
		option.AbsoluteDeleteOption = &absoluteDeleteOption
	}

	// No error
	return nil
}

// AssignProperties_From_DeleteOption_STATUS populates our DeleteOption_STATUS from the provided source DeleteOption_STATUS
func (option *DeleteOption_STATUS) AssignProperties_From_DeleteOption_STATUS(source *v20230101s.DeleteOption_STATUS) error {

	// AbsoluteDeleteOption
	if source.AbsoluteDeleteOption != nil {
		var absoluteDeleteOption AbsoluteDeleteOption_STATUS
		err := absoluteDeleteOption.AssignProperties_From_AbsoluteDeleteOption_STATUS(source.AbsoluteDeleteOption)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AbsoluteDeleteOption_STATUS() to populate field AbsoluteDeleteOption")
		}
		option.AbsoluteDeleteOption = &absoluteDeleteOption
	} else {
		option.AbsoluteDeleteOption = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeleteOption_STATUS populates the provided destination DeleteOption_STATUS from our DeleteOption_STATUS
func (option *DeleteOption_STATUS) AssignProperties_To_DeleteOption_STATUS(destination *v20230101s.DeleteOption_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AbsoluteDeleteOption
	if option.AbsoluteDeleteOption != nil {
		var absoluteDeleteOption v20230101s.AbsoluteDeleteOption_STATUS
		err := option.AbsoluteDeleteOption.AssignProperties_To_AbsoluteDeleteOption_STATUS(&absoluteDeleteOption)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AbsoluteDeleteOption_STATUS() to populate field AbsoluteDeleteOption")
		}
		destination.AbsoluteDeleteOption = &absoluteDeleteOption
	} else {
		destination.AbsoluteDeleteOption = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ScheduleBasedTriggerContext struct {
	// +kubebuilder:validation:Required
	// ObjectType: Type of the specific object - used for deserializing
	ObjectType *ScheduleBasedTriggerContext_ObjectType `json:"objectType,omitempty"`

	// +kubebuilder:validation:Required
	// Schedule: Schedule for this backup
	Schedule *BackupSchedule `json:"schedule,omitempty"`

	// +kubebuilder:validation:Required
	// TaggingCriteria: List of tags that can be applicable for given schedule.
	TaggingCriteria []TaggingCriteria `json:"taggingCriteria,omitempty"`
}

var _ genruntime.ARMTransformer = &ScheduleBasedTriggerContext{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (context *ScheduleBasedTriggerContext) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if context == nil {
		return nil, nil
	}
	result := &ScheduleBasedTriggerContext_ARM{}

	// Set property "ObjectType":
	if context.ObjectType != nil {
		result.ObjectType = *context.ObjectType
	}

	// Set property "Schedule":
	if context.Schedule != nil {
		schedule_ARM, err := (*context.Schedule).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		schedule := *schedule_ARM.(*BackupSchedule_ARM)
		result.Schedule = &schedule
	}

	// Set property "TaggingCriteria":
	for _, item := range context.TaggingCriteria {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.TaggingCriteria = append(result.TaggingCriteria, *item_ARM.(*TaggingCriteria_ARM))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (context *ScheduleBasedTriggerContext) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ScheduleBasedTriggerContext_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (context *ScheduleBasedTriggerContext) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ScheduleBasedTriggerContext_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ScheduleBasedTriggerContext_ARM, got %T", armInput)
	}

	// Set property "ObjectType":
	context.ObjectType = &typedInput.ObjectType

	// Set property "Schedule":
	if typedInput.Schedule != nil {
		var schedule1 BackupSchedule
		err := schedule1.PopulateFromARM(owner, *typedInput.Schedule)
		if err != nil {
			return err
		}
		schedule := schedule1
		context.Schedule = &schedule
	}

	// Set property "TaggingCriteria":
	for _, item := range typedInput.TaggingCriteria {
		var item1 TaggingCriteria
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		context.TaggingCriteria = append(context.TaggingCriteria, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_ScheduleBasedTriggerContext populates our ScheduleBasedTriggerContext from the provided source ScheduleBasedTriggerContext
func (context *ScheduleBasedTriggerContext) AssignProperties_From_ScheduleBasedTriggerContext(source *v20230101s.ScheduleBasedTriggerContext) error {

	// ObjectType
	if source.ObjectType != nil {
		objectType := ScheduleBasedTriggerContext_ObjectType(*source.ObjectType)
		context.ObjectType = &objectType
	} else {
		context.ObjectType = nil
	}

	// Schedule
	if source.Schedule != nil {
		var schedule BackupSchedule
		err := schedule.AssignProperties_From_BackupSchedule(source.Schedule)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_BackupSchedule() to populate field Schedule")
		}
		context.Schedule = &schedule
	} else {
		context.Schedule = nil
	}

	// TaggingCriteria
	if source.TaggingCriteria != nil {
		taggingCriterionList := make([]TaggingCriteria, len(source.TaggingCriteria))
		for taggingCriterionIndex, taggingCriterionItem := range source.TaggingCriteria {
			// Shadow the loop variable to avoid aliasing
			taggingCriterionItem := taggingCriterionItem
			var taggingCriterion TaggingCriteria
			err := taggingCriterion.AssignProperties_From_TaggingCriteria(&taggingCriterionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_TaggingCriteria() to populate field TaggingCriteria")
			}
			taggingCriterionList[taggingCriterionIndex] = taggingCriterion
		}
		context.TaggingCriteria = taggingCriterionList
	} else {
		context.TaggingCriteria = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ScheduleBasedTriggerContext populates the provided destination ScheduleBasedTriggerContext from our ScheduleBasedTriggerContext
func (context *ScheduleBasedTriggerContext) AssignProperties_To_ScheduleBasedTriggerContext(destination *v20230101s.ScheduleBasedTriggerContext) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ObjectType
	if context.ObjectType != nil {
		objectType := string(*context.ObjectType)
		destination.ObjectType = &objectType
	} else {
		destination.ObjectType = nil
	}

	// Schedule
	if context.Schedule != nil {
		var schedule v20230101s.BackupSchedule
		err := context.Schedule.AssignProperties_To_BackupSchedule(&schedule)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_BackupSchedule() to populate field Schedule")
		}
		destination.Schedule = &schedule
	} else {
		destination.Schedule = nil
	}

	// TaggingCriteria
	if context.TaggingCriteria != nil {
		taggingCriterionList := make([]v20230101s.TaggingCriteria, len(context.TaggingCriteria))
		for taggingCriterionIndex, taggingCriterionItem := range context.TaggingCriteria {
			// Shadow the loop variable to avoid aliasing
			taggingCriterionItem := taggingCriterionItem
			var taggingCriterion v20230101s.TaggingCriteria
			err := taggingCriterionItem.AssignProperties_To_TaggingCriteria(&taggingCriterion)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_TaggingCriteria() to populate field TaggingCriteria")
			}
			taggingCriterionList[taggingCriterionIndex] = taggingCriterion
		}
		destination.TaggingCriteria = taggingCriterionList
	} else {
		destination.TaggingCriteria = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ScheduleBasedTriggerContext_STATUS populates our ScheduleBasedTriggerContext from the provided source ScheduleBasedTriggerContext_STATUS
func (context *ScheduleBasedTriggerContext) Initialize_From_ScheduleBasedTriggerContext_STATUS(source *ScheduleBasedTriggerContext_STATUS) error {

	// ObjectType
	if source.ObjectType != nil {
		objectType := ScheduleBasedTriggerContext_ObjectType(*source.ObjectType)
		context.ObjectType = &objectType
	} else {
		context.ObjectType = nil
	}

	// Schedule
	if source.Schedule != nil {
		var schedule BackupSchedule
		err := schedule.Initialize_From_BackupSchedule_STATUS(source.Schedule)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_BackupSchedule_STATUS() to populate field Schedule")
		}
		context.Schedule = &schedule
	} else {
		context.Schedule = nil
	}

	// TaggingCriteria
	if source.TaggingCriteria != nil {
		taggingCriterionList := make([]TaggingCriteria, len(source.TaggingCriteria))
		for taggingCriterionIndex, taggingCriterionItem := range source.TaggingCriteria {
			// Shadow the loop variable to avoid aliasing
			taggingCriterionItem := taggingCriterionItem
			var taggingCriterion TaggingCriteria
			err := taggingCriterion.Initialize_From_TaggingCriteria_STATUS(&taggingCriterionItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_TaggingCriteria_STATUS() to populate field TaggingCriteria")
			}
			taggingCriterionList[taggingCriterionIndex] = taggingCriterion
		}
		context.TaggingCriteria = taggingCriterionList
	} else {
		context.TaggingCriteria = nil
	}

	// No error
	return nil
}

type ScheduleBasedTriggerContext_STATUS struct {
	// ObjectType: Type of the specific object - used for deserializing
	ObjectType *ScheduleBasedTriggerContext_ObjectType_STATUS `json:"objectType,omitempty"`

	// Schedule: Schedule for this backup
	Schedule *BackupSchedule_STATUS `json:"schedule,omitempty"`

	// TaggingCriteria: List of tags that can be applicable for given schedule.
	TaggingCriteria []TaggingCriteria_STATUS `json:"taggingCriteria,omitempty"`
}

var _ genruntime.FromARMConverter = &ScheduleBasedTriggerContext_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (context *ScheduleBasedTriggerContext_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ScheduleBasedTriggerContext_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (context *ScheduleBasedTriggerContext_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ScheduleBasedTriggerContext_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ScheduleBasedTriggerContext_STATUS_ARM, got %T", armInput)
	}

	// Set property "ObjectType":
	context.ObjectType = &typedInput.ObjectType

	// Set property "Schedule":
	if typedInput.Schedule != nil {
		var schedule1 BackupSchedule_STATUS
		err := schedule1.PopulateFromARM(owner, *typedInput.Schedule)
		if err != nil {
			return err
		}
		schedule := schedule1
		context.Schedule = &schedule
	}

	// Set property "TaggingCriteria":
	for _, item := range typedInput.TaggingCriteria {
		var item1 TaggingCriteria_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		context.TaggingCriteria = append(context.TaggingCriteria, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_ScheduleBasedTriggerContext_STATUS populates our ScheduleBasedTriggerContext_STATUS from the provided source ScheduleBasedTriggerContext_STATUS
func (context *ScheduleBasedTriggerContext_STATUS) AssignProperties_From_ScheduleBasedTriggerContext_STATUS(source *v20230101s.ScheduleBasedTriggerContext_STATUS) error {

	// ObjectType
	if source.ObjectType != nil {
		objectType := ScheduleBasedTriggerContext_ObjectType_STATUS(*source.ObjectType)
		context.ObjectType = &objectType
	} else {
		context.ObjectType = nil
	}

	// Schedule
	if source.Schedule != nil {
		var schedule BackupSchedule_STATUS
		err := schedule.AssignProperties_From_BackupSchedule_STATUS(source.Schedule)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_BackupSchedule_STATUS() to populate field Schedule")
		}
		context.Schedule = &schedule
	} else {
		context.Schedule = nil
	}

	// TaggingCriteria
	if source.TaggingCriteria != nil {
		taggingCriterionList := make([]TaggingCriteria_STATUS, len(source.TaggingCriteria))
		for taggingCriterionIndex, taggingCriterionItem := range source.TaggingCriteria {
			// Shadow the loop variable to avoid aliasing
			taggingCriterionItem := taggingCriterionItem
			var taggingCriterion TaggingCriteria_STATUS
			err := taggingCriterion.AssignProperties_From_TaggingCriteria_STATUS(&taggingCriterionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_TaggingCriteria_STATUS() to populate field TaggingCriteria")
			}
			taggingCriterionList[taggingCriterionIndex] = taggingCriterion
		}
		context.TaggingCriteria = taggingCriterionList
	} else {
		context.TaggingCriteria = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ScheduleBasedTriggerContext_STATUS populates the provided destination ScheduleBasedTriggerContext_STATUS from our ScheduleBasedTriggerContext_STATUS
func (context *ScheduleBasedTriggerContext_STATUS) AssignProperties_To_ScheduleBasedTriggerContext_STATUS(destination *v20230101s.ScheduleBasedTriggerContext_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ObjectType
	if context.ObjectType != nil {
		objectType := string(*context.ObjectType)
		destination.ObjectType = &objectType
	} else {
		destination.ObjectType = nil
	}

	// Schedule
	if context.Schedule != nil {
		var schedule v20230101s.BackupSchedule_STATUS
		err := context.Schedule.AssignProperties_To_BackupSchedule_STATUS(&schedule)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_BackupSchedule_STATUS() to populate field Schedule")
		}
		destination.Schedule = &schedule
	} else {
		destination.Schedule = nil
	}

	// TaggingCriteria
	if context.TaggingCriteria != nil {
		taggingCriterionList := make([]v20230101s.TaggingCriteria_STATUS, len(context.TaggingCriteria))
		for taggingCriterionIndex, taggingCriterionItem := range context.TaggingCriteria {
			// Shadow the loop variable to avoid aliasing
			taggingCriterionItem := taggingCriterionItem
			var taggingCriterion v20230101s.TaggingCriteria_STATUS
			err := taggingCriterionItem.AssignProperties_To_TaggingCriteria_STATUS(&taggingCriterion)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_TaggingCriteria_STATUS() to populate field TaggingCriteria")
			}
			taggingCriterionList[taggingCriterionIndex] = taggingCriterion
		}
		destination.TaggingCriteria = taggingCriterionList
	} else {
		destination.TaggingCriteria = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Target copy settings
type TargetCopySetting struct {
	// +kubebuilder:validation:Required
	// CopyAfter: It can be CustomCopyOption or ImmediateCopyOption.
	CopyAfter *CopyOption `json:"copyAfter,omitempty"`

	// +kubebuilder:validation:Required
	// DataStore: Info of target datastore
	DataStore *DataStoreInfoBase `json:"dataStore,omitempty"`
}

var _ genruntime.ARMTransformer = &TargetCopySetting{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (setting *TargetCopySetting) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if setting == nil {
		return nil, nil
	}
	result := &TargetCopySetting_ARM{}

	// Set property "CopyAfter":
	if setting.CopyAfter != nil {
		copyAfter_ARM, err := (*setting.CopyAfter).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		copyAfter := *copyAfter_ARM.(*CopyOption_ARM)
		result.CopyAfter = &copyAfter
	}

	// Set property "DataStore":
	if setting.DataStore != nil {
		dataStore_ARM, err := (*setting.DataStore).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		dataStore := *dataStore_ARM.(*DataStoreInfoBase_ARM)
		result.DataStore = &dataStore
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (setting *TargetCopySetting) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &TargetCopySetting_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (setting *TargetCopySetting) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(TargetCopySetting_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected TargetCopySetting_ARM, got %T", armInput)
	}

	// Set property "CopyAfter":
	if typedInput.CopyAfter != nil {
		var copyAfter1 CopyOption
		err := copyAfter1.PopulateFromARM(owner, *typedInput.CopyAfter)
		if err != nil {
			return err
		}
		copyAfter := copyAfter1
		setting.CopyAfter = &copyAfter
	}

	// Set property "DataStore":
	if typedInput.DataStore != nil {
		var dataStore1 DataStoreInfoBase
		err := dataStore1.PopulateFromARM(owner, *typedInput.DataStore)
		if err != nil {
			return err
		}
		dataStore := dataStore1
		setting.DataStore = &dataStore
	}

	// No error
	return nil
}

// AssignProperties_From_TargetCopySetting populates our TargetCopySetting from the provided source TargetCopySetting
func (setting *TargetCopySetting) AssignProperties_From_TargetCopySetting(source *v20230101s.TargetCopySetting) error {

	// CopyAfter
	if source.CopyAfter != nil {
		var copyAfter CopyOption
		err := copyAfter.AssignProperties_From_CopyOption(source.CopyAfter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_CopyOption() to populate field CopyAfter")
		}
		setting.CopyAfter = &copyAfter
	} else {
		setting.CopyAfter = nil
	}

	// DataStore
	if source.DataStore != nil {
		var dataStore DataStoreInfoBase
		err := dataStore.AssignProperties_From_DataStoreInfoBase(source.DataStore)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DataStoreInfoBase() to populate field DataStore")
		}
		setting.DataStore = &dataStore
	} else {
		setting.DataStore = nil
	}

	// No error
	return nil
}

// AssignProperties_To_TargetCopySetting populates the provided destination TargetCopySetting from our TargetCopySetting
func (setting *TargetCopySetting) AssignProperties_To_TargetCopySetting(destination *v20230101s.TargetCopySetting) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CopyAfter
	if setting.CopyAfter != nil {
		var copyAfter v20230101s.CopyOption
		err := setting.CopyAfter.AssignProperties_To_CopyOption(&copyAfter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_CopyOption() to populate field CopyAfter")
		}
		destination.CopyAfter = &copyAfter
	} else {
		destination.CopyAfter = nil
	}

	// DataStore
	if setting.DataStore != nil {
		var dataStore v20230101s.DataStoreInfoBase
		err := setting.DataStore.AssignProperties_To_DataStoreInfoBase(&dataStore)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DataStoreInfoBase() to populate field DataStore")
		}
		destination.DataStore = &dataStore
	} else {
		destination.DataStore = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_TargetCopySetting_STATUS populates our TargetCopySetting from the provided source TargetCopySetting_STATUS
func (setting *TargetCopySetting) Initialize_From_TargetCopySetting_STATUS(source *TargetCopySetting_STATUS) error {

	// CopyAfter
	if source.CopyAfter != nil {
		var copyAfter CopyOption
		err := copyAfter.Initialize_From_CopyOption_STATUS(source.CopyAfter)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_CopyOption_STATUS() to populate field CopyAfter")
		}
		setting.CopyAfter = &copyAfter
	} else {
		setting.CopyAfter = nil
	}

	// DataStore
	if source.DataStore != nil {
		var dataStore DataStoreInfoBase
		err := dataStore.Initialize_From_DataStoreInfoBase_STATUS(source.DataStore)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_DataStoreInfoBase_STATUS() to populate field DataStore")
		}
		setting.DataStore = &dataStore
	} else {
		setting.DataStore = nil
	}

	// No error
	return nil
}

// Target copy settings
type TargetCopySetting_STATUS struct {
	// CopyAfter: It can be CustomCopyOption or ImmediateCopyOption.
	CopyAfter *CopyOption_STATUS `json:"copyAfter,omitempty"`

	// DataStore: Info of target datastore
	DataStore *DataStoreInfoBase_STATUS `json:"dataStore,omitempty"`
}

var _ genruntime.FromARMConverter = &TargetCopySetting_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (setting *TargetCopySetting_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &TargetCopySetting_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (setting *TargetCopySetting_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(TargetCopySetting_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected TargetCopySetting_STATUS_ARM, got %T", armInput)
	}

	// Set property "CopyAfter":
	if typedInput.CopyAfter != nil {
		var copyAfter1 CopyOption_STATUS
		err := copyAfter1.PopulateFromARM(owner, *typedInput.CopyAfter)
		if err != nil {
			return err
		}
		copyAfter := copyAfter1
		setting.CopyAfter = &copyAfter
	}

	// Set property "DataStore":
	if typedInput.DataStore != nil {
		var dataStore1 DataStoreInfoBase_STATUS
		err := dataStore1.PopulateFromARM(owner, *typedInput.DataStore)
		if err != nil {
			return err
		}
		dataStore := dataStore1
		setting.DataStore = &dataStore
	}

	// No error
	return nil
}

// AssignProperties_From_TargetCopySetting_STATUS populates our TargetCopySetting_STATUS from the provided source TargetCopySetting_STATUS
func (setting *TargetCopySetting_STATUS) AssignProperties_From_TargetCopySetting_STATUS(source *v20230101s.TargetCopySetting_STATUS) error {

	// CopyAfter
	if source.CopyAfter != nil {
		var copyAfter CopyOption_STATUS
		err := copyAfter.AssignProperties_From_CopyOption_STATUS(source.CopyAfter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_CopyOption_STATUS() to populate field CopyAfter")
		}
		setting.CopyAfter = &copyAfter
	} else {
		setting.CopyAfter = nil
	}

	// DataStore
	if source.DataStore != nil {
		var dataStore DataStoreInfoBase_STATUS
		err := dataStore.AssignProperties_From_DataStoreInfoBase_STATUS(source.DataStore)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DataStoreInfoBase_STATUS() to populate field DataStore")
		}
		setting.DataStore = &dataStore
	} else {
		setting.DataStore = nil
	}

	// No error
	return nil
}

// AssignProperties_To_TargetCopySetting_STATUS populates the provided destination TargetCopySetting_STATUS from our TargetCopySetting_STATUS
func (setting *TargetCopySetting_STATUS) AssignProperties_To_TargetCopySetting_STATUS(destination *v20230101s.TargetCopySetting_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CopyAfter
	if setting.CopyAfter != nil {
		var copyAfter v20230101s.CopyOption_STATUS
		err := setting.CopyAfter.AssignProperties_To_CopyOption_STATUS(&copyAfter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_CopyOption_STATUS() to populate field CopyAfter")
		}
		destination.CopyAfter = &copyAfter
	} else {
		destination.CopyAfter = nil
	}

	// DataStore
	if setting.DataStore != nil {
		var dataStore v20230101s.DataStoreInfoBase_STATUS
		err := setting.DataStore.AssignProperties_To_DataStoreInfoBase_STATUS(&dataStore)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DataStoreInfoBase_STATUS() to populate field DataStore")
		}
		destination.DataStore = &dataStore
	} else {
		destination.DataStore = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type AbsoluteDeleteOption struct {
	// +kubebuilder:validation:Required
	// Duration: Duration of deletion after given timespan
	Duration *string `json:"duration,omitempty"`

	// +kubebuilder:validation:Required
	// ObjectType: Type of the specific object - used for deserializing
	ObjectType *AbsoluteDeleteOption_ObjectType `json:"objectType,omitempty"`
}

var _ genruntime.ARMTransformer = &AbsoluteDeleteOption{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (option *AbsoluteDeleteOption) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if option == nil {
		return nil, nil
	}
	result := &AbsoluteDeleteOption_ARM{}

	// Set property "Duration":
	if option.Duration != nil {
		duration := *option.Duration
		result.Duration = &duration
	}

	// Set property "ObjectType":
	if option.ObjectType != nil {
		result.ObjectType = *option.ObjectType
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (option *AbsoluteDeleteOption) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &AbsoluteDeleteOption_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (option *AbsoluteDeleteOption) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(AbsoluteDeleteOption_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected AbsoluteDeleteOption_ARM, got %T", armInput)
	}

	// Set property "Duration":
	if typedInput.Duration != nil {
		duration := *typedInput.Duration
		option.Duration = &duration
	}

	// Set property "ObjectType":
	option.ObjectType = &typedInput.ObjectType

	// No error
	return nil
}

// AssignProperties_From_AbsoluteDeleteOption populates our AbsoluteDeleteOption from the provided source AbsoluteDeleteOption
func (option *AbsoluteDeleteOption) AssignProperties_From_AbsoluteDeleteOption(source *v20230101s.AbsoluteDeleteOption) error {

	// Duration
	option.Duration = genruntime.ClonePointerToString(source.Duration)

	// ObjectType
	if source.ObjectType != nil {
		objectType := AbsoluteDeleteOption_ObjectType(*source.ObjectType)
		option.ObjectType = &objectType
	} else {
		option.ObjectType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AbsoluteDeleteOption populates the provided destination AbsoluteDeleteOption from our AbsoluteDeleteOption
func (option *AbsoluteDeleteOption) AssignProperties_To_AbsoluteDeleteOption(destination *v20230101s.AbsoluteDeleteOption) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Duration
	destination.Duration = genruntime.ClonePointerToString(option.Duration)

	// ObjectType
	if option.ObjectType != nil {
		objectType := string(*option.ObjectType)
		destination.ObjectType = &objectType
	} else {
		destination.ObjectType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_AbsoluteDeleteOption_STATUS populates our AbsoluteDeleteOption from the provided source AbsoluteDeleteOption_STATUS
func (option *AbsoluteDeleteOption) Initialize_From_AbsoluteDeleteOption_STATUS(source *AbsoluteDeleteOption_STATUS) error {

	// Duration
	option.Duration = genruntime.ClonePointerToString(source.Duration)

	// ObjectType
	if source.ObjectType != nil {
		objectType := AbsoluteDeleteOption_ObjectType(*source.ObjectType)
		option.ObjectType = &objectType
	} else {
		option.ObjectType = nil
	}

	// No error
	return nil
}

type AbsoluteDeleteOption_STATUS struct {
	// Duration: Duration of deletion after given timespan
	Duration *string `json:"duration,omitempty"`

	// ObjectType: Type of the specific object - used for deserializing
	ObjectType *AbsoluteDeleteOption_ObjectType_STATUS `json:"objectType,omitempty"`
}

var _ genruntime.FromARMConverter = &AbsoluteDeleteOption_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (option *AbsoluteDeleteOption_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &AbsoluteDeleteOption_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (option *AbsoluteDeleteOption_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(AbsoluteDeleteOption_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected AbsoluteDeleteOption_STATUS_ARM, got %T", armInput)
	}

	// Set property "Duration":
	if typedInput.Duration != nil {
		duration := *typedInput.Duration
		option.Duration = &duration
	}

	// Set property "ObjectType":
	option.ObjectType = &typedInput.ObjectType

	// No error
	return nil
}

// AssignProperties_From_AbsoluteDeleteOption_STATUS populates our AbsoluteDeleteOption_STATUS from the provided source AbsoluteDeleteOption_STATUS
func (option *AbsoluteDeleteOption_STATUS) AssignProperties_From_AbsoluteDeleteOption_STATUS(source *v20230101s.AbsoluteDeleteOption_STATUS) error {

	// Duration
	option.Duration = genruntime.ClonePointerToString(source.Duration)

	// ObjectType
	if source.ObjectType != nil {
		objectType := AbsoluteDeleteOption_ObjectType_STATUS(*source.ObjectType)
		option.ObjectType = &objectType
	} else {
		option.ObjectType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AbsoluteDeleteOption_STATUS populates the provided destination AbsoluteDeleteOption_STATUS from our AbsoluteDeleteOption_STATUS
func (option *AbsoluteDeleteOption_STATUS) AssignProperties_To_AbsoluteDeleteOption_STATUS(destination *v20230101s.AbsoluteDeleteOption_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Duration
	destination.Duration = genruntime.ClonePointerToString(option.Duration)

	// ObjectType
	if option.ObjectType != nil {
		objectType := string(*option.ObjectType)
		destination.ObjectType = &objectType
	} else {
		destination.ObjectType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Adhoc backup tagging criteria
type AdhocBasedTaggingCriteria struct {
	// TagInfo: Retention tag information
	TagInfo *RetentionTag `json:"tagInfo,omitempty"`
}

var _ genruntime.ARMTransformer = &AdhocBasedTaggingCriteria{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (criteria *AdhocBasedTaggingCriteria) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if criteria == nil {
		return nil, nil
	}
	result := &AdhocBasedTaggingCriteria_ARM{}

	// Set property "TagInfo":
	if criteria.TagInfo != nil {
		tagInfo_ARM, err := (*criteria.TagInfo).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		tagInfo := *tagInfo_ARM.(*RetentionTag_ARM)
		result.TagInfo = &tagInfo
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (criteria *AdhocBasedTaggingCriteria) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &AdhocBasedTaggingCriteria_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (criteria *AdhocBasedTaggingCriteria) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(AdhocBasedTaggingCriteria_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected AdhocBasedTaggingCriteria_ARM, got %T", armInput)
	}

	// Set property "TagInfo":
	if typedInput.TagInfo != nil {
		var tagInfo1 RetentionTag
		err := tagInfo1.PopulateFromARM(owner, *typedInput.TagInfo)
		if err != nil {
			return err
		}
		tagInfo := tagInfo1
		criteria.TagInfo = &tagInfo
	}

	// No error
	return nil
}

// AssignProperties_From_AdhocBasedTaggingCriteria populates our AdhocBasedTaggingCriteria from the provided source AdhocBasedTaggingCriteria
func (criteria *AdhocBasedTaggingCriteria) AssignProperties_From_AdhocBasedTaggingCriteria(source *v20230101s.AdhocBasedTaggingCriteria) error {

	// TagInfo
	if source.TagInfo != nil {
		var tagInfo RetentionTag
		err := tagInfo.AssignProperties_From_RetentionTag(source.TagInfo)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_RetentionTag() to populate field TagInfo")
		}
		criteria.TagInfo = &tagInfo
	} else {
		criteria.TagInfo = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AdhocBasedTaggingCriteria populates the provided destination AdhocBasedTaggingCriteria from our AdhocBasedTaggingCriteria
func (criteria *AdhocBasedTaggingCriteria) AssignProperties_To_AdhocBasedTaggingCriteria(destination *v20230101s.AdhocBasedTaggingCriteria) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// TagInfo
	if criteria.TagInfo != nil {
		var tagInfo v20230101s.RetentionTag
		err := criteria.TagInfo.AssignProperties_To_RetentionTag(&tagInfo)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_RetentionTag() to populate field TagInfo")
		}
		destination.TagInfo = &tagInfo
	} else {
		destination.TagInfo = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_AdhocBasedTaggingCriteria_STATUS populates our AdhocBasedTaggingCriteria from the provided source AdhocBasedTaggingCriteria_STATUS
func (criteria *AdhocBasedTaggingCriteria) Initialize_From_AdhocBasedTaggingCriteria_STATUS(source *AdhocBasedTaggingCriteria_STATUS) error {

	// TagInfo
	if source.TagInfo != nil {
		var tagInfo RetentionTag
		err := tagInfo.Initialize_From_RetentionTag_STATUS(source.TagInfo)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_RetentionTag_STATUS() to populate field TagInfo")
		}
		criteria.TagInfo = &tagInfo
	} else {
		criteria.TagInfo = nil
	}

	// No error
	return nil
}

// Adhoc backup tagging criteria
type AdhocBasedTaggingCriteria_STATUS struct {
	// TagInfo: Retention tag information
	TagInfo *RetentionTag_STATUS `json:"tagInfo,omitempty"`
}

var _ genruntime.FromARMConverter = &AdhocBasedTaggingCriteria_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (criteria *AdhocBasedTaggingCriteria_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &AdhocBasedTaggingCriteria_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (criteria *AdhocBasedTaggingCriteria_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(AdhocBasedTaggingCriteria_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected AdhocBasedTaggingCriteria_STATUS_ARM, got %T", armInput)
	}

	// Set property "TagInfo":
	if typedInput.TagInfo != nil {
		var tagInfo1 RetentionTag_STATUS
		err := tagInfo1.PopulateFromARM(owner, *typedInput.TagInfo)
		if err != nil {
			return err
		}
		tagInfo := tagInfo1
		criteria.TagInfo = &tagInfo
	}

	// No error
	return nil
}

// AssignProperties_From_AdhocBasedTaggingCriteria_STATUS populates our AdhocBasedTaggingCriteria_STATUS from the provided source AdhocBasedTaggingCriteria_STATUS
func (criteria *AdhocBasedTaggingCriteria_STATUS) AssignProperties_From_AdhocBasedTaggingCriteria_STATUS(source *v20230101s.AdhocBasedTaggingCriteria_STATUS) error {

	// TagInfo
	if source.TagInfo != nil {
		var tagInfo RetentionTag_STATUS
		err := tagInfo.AssignProperties_From_RetentionTag_STATUS(source.TagInfo)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_RetentionTag_STATUS() to populate field TagInfo")
		}
		criteria.TagInfo = &tagInfo
	} else {
		criteria.TagInfo = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AdhocBasedTaggingCriteria_STATUS populates the provided destination AdhocBasedTaggingCriteria_STATUS from our AdhocBasedTaggingCriteria_STATUS
func (criteria *AdhocBasedTaggingCriteria_STATUS) AssignProperties_To_AdhocBasedTaggingCriteria_STATUS(destination *v20230101s.AdhocBasedTaggingCriteria_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// TagInfo
	if criteria.TagInfo != nil {
		var tagInfo v20230101s.RetentionTag_STATUS
		err := criteria.TagInfo.AssignProperties_To_RetentionTag_STATUS(&tagInfo)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_RetentionTag_STATUS() to populate field TagInfo")
		}
		destination.TagInfo = &tagInfo
	} else {
		destination.TagInfo = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Schedule for backup
type BackupSchedule struct {
	// +kubebuilder:validation:Required
	// RepeatingTimeIntervals: ISO 8601 repeating time interval format
	RepeatingTimeIntervals []string `json:"repeatingTimeIntervals,omitempty"`

	// TimeZone: Time zone for a schedule. Example: Pacific Standard Time
	TimeZone *string `json:"timeZone,omitempty"`
}

var _ genruntime.ARMTransformer = &BackupSchedule{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (schedule *BackupSchedule) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if schedule == nil {
		return nil, nil
	}
	result := &BackupSchedule_ARM{}

	// Set property "RepeatingTimeIntervals":
	for _, item := range schedule.RepeatingTimeIntervals {
		result.RepeatingTimeIntervals = append(result.RepeatingTimeIntervals, item)
	}

	// Set property "TimeZone":
	if schedule.TimeZone != nil {
		timeZone := *schedule.TimeZone
		result.TimeZone = &timeZone
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (schedule *BackupSchedule) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &BackupSchedule_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (schedule *BackupSchedule) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(BackupSchedule_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected BackupSchedule_ARM, got %T", armInput)
	}

	// Set property "RepeatingTimeIntervals":
	for _, item := range typedInput.RepeatingTimeIntervals {
		schedule.RepeatingTimeIntervals = append(schedule.RepeatingTimeIntervals, item)
	}

	// Set property "TimeZone":
	if typedInput.TimeZone != nil {
		timeZone := *typedInput.TimeZone
		schedule.TimeZone = &timeZone
	}

	// No error
	return nil
}

// AssignProperties_From_BackupSchedule populates our BackupSchedule from the provided source BackupSchedule
func (schedule *BackupSchedule) AssignProperties_From_BackupSchedule(source *v20230101s.BackupSchedule) error {

	// RepeatingTimeIntervals
	schedule.RepeatingTimeIntervals = genruntime.CloneSliceOfString(source.RepeatingTimeIntervals)

	// TimeZone
	schedule.TimeZone = genruntime.ClonePointerToString(source.TimeZone)

	// No error
	return nil
}

// AssignProperties_To_BackupSchedule populates the provided destination BackupSchedule from our BackupSchedule
func (schedule *BackupSchedule) AssignProperties_To_BackupSchedule(destination *v20230101s.BackupSchedule) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// RepeatingTimeIntervals
	destination.RepeatingTimeIntervals = genruntime.CloneSliceOfString(schedule.RepeatingTimeIntervals)

	// TimeZone
	destination.TimeZone = genruntime.ClonePointerToString(schedule.TimeZone)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_BackupSchedule_STATUS populates our BackupSchedule from the provided source BackupSchedule_STATUS
func (schedule *BackupSchedule) Initialize_From_BackupSchedule_STATUS(source *BackupSchedule_STATUS) error {

	// RepeatingTimeIntervals
	schedule.RepeatingTimeIntervals = genruntime.CloneSliceOfString(source.RepeatingTimeIntervals)

	// TimeZone
	schedule.TimeZone = genruntime.ClonePointerToString(source.TimeZone)

	// No error
	return nil
}

// Schedule for backup
type BackupSchedule_STATUS struct {
	// RepeatingTimeIntervals: ISO 8601 repeating time interval format
	RepeatingTimeIntervals []string `json:"repeatingTimeIntervals,omitempty"`

	// TimeZone: Time zone for a schedule. Example: Pacific Standard Time
	TimeZone *string `json:"timeZone,omitempty"`
}

var _ genruntime.FromARMConverter = &BackupSchedule_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (schedule *BackupSchedule_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &BackupSchedule_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (schedule *BackupSchedule_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(BackupSchedule_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected BackupSchedule_STATUS_ARM, got %T", armInput)
	}

	// Set property "RepeatingTimeIntervals":
	for _, item := range typedInput.RepeatingTimeIntervals {
		schedule.RepeatingTimeIntervals = append(schedule.RepeatingTimeIntervals, item)
	}

	// Set property "TimeZone":
	if typedInput.TimeZone != nil {
		timeZone := *typedInput.TimeZone
		schedule.TimeZone = &timeZone
	}

	// No error
	return nil
}

// AssignProperties_From_BackupSchedule_STATUS populates our BackupSchedule_STATUS from the provided source BackupSchedule_STATUS
func (schedule *BackupSchedule_STATUS) AssignProperties_From_BackupSchedule_STATUS(source *v20230101s.BackupSchedule_STATUS) error {

	// RepeatingTimeIntervals
	schedule.RepeatingTimeIntervals = genruntime.CloneSliceOfString(source.RepeatingTimeIntervals)

	// TimeZone
	schedule.TimeZone = genruntime.ClonePointerToString(source.TimeZone)

	// No error
	return nil
}

// AssignProperties_To_BackupSchedule_STATUS populates the provided destination BackupSchedule_STATUS from our BackupSchedule_STATUS
func (schedule *BackupSchedule_STATUS) AssignProperties_To_BackupSchedule_STATUS(destination *v20230101s.BackupSchedule_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// RepeatingTimeIntervals
	destination.RepeatingTimeIntervals = genruntime.CloneSliceOfString(schedule.RepeatingTimeIntervals)

	// TimeZone
	destination.TimeZone = genruntime.ClonePointerToString(schedule.TimeZone)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type CopyOption struct {
	// CopyOnExpiry: Mutually exclusive with all other properties
	CopyOnExpiry *CopyOnExpiryOption `json:"copyOnExpiryOption,omitempty"`

	// CustomCopy: Mutually exclusive with all other properties
	CustomCopy *CustomCopyOption `json:"customCopyOption,omitempty"`

	// ImmediateCopy: Mutually exclusive with all other properties
	ImmediateCopy *ImmediateCopyOption `json:"immediateCopyOption,omitempty"`
}

var _ genruntime.ARMTransformer = &CopyOption{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (option *CopyOption) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if option == nil {
		return nil, nil
	}
	result := &CopyOption_ARM{}

	// Set property "CopyOnExpiry":
	if option.CopyOnExpiry != nil {
		copyOnExpiry_ARM, err := (*option.CopyOnExpiry).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		copyOnExpiry := *copyOnExpiry_ARM.(*CopyOnExpiryOption_ARM)
		result.CopyOnExpiry = &copyOnExpiry
	}

	// Set property "CustomCopy":
	if option.CustomCopy != nil {
		customCopy_ARM, err := (*option.CustomCopy).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		customCopy := *customCopy_ARM.(*CustomCopyOption_ARM)
		result.CustomCopy = &customCopy
	}

	// Set property "ImmediateCopy":
	if option.ImmediateCopy != nil {
		immediateCopy_ARM, err := (*option.ImmediateCopy).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		immediateCopy := *immediateCopy_ARM.(*ImmediateCopyOption_ARM)
		result.ImmediateCopy = &immediateCopy
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (option *CopyOption) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &CopyOption_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (option *CopyOption) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(CopyOption_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected CopyOption_ARM, got %T", armInput)
	}

	// Set property "CopyOnExpiry":
	if typedInput.CopyOnExpiry != nil {
		var copyOnExpiry1 CopyOnExpiryOption
		err := copyOnExpiry1.PopulateFromARM(owner, *typedInput.CopyOnExpiry)
		if err != nil {
			return err
		}
		copyOnExpiry := copyOnExpiry1
		option.CopyOnExpiry = &copyOnExpiry
	}

	// Set property "CustomCopy":
	if typedInput.CustomCopy != nil {
		var customCopy1 CustomCopyOption
		err := customCopy1.PopulateFromARM(owner, *typedInput.CustomCopy)
		if err != nil {
			return err
		}
		customCopy := customCopy1
		option.CustomCopy = &customCopy
	}

	// Set property "ImmediateCopy":
	if typedInput.ImmediateCopy != nil {
		var immediateCopy1 ImmediateCopyOption
		err := immediateCopy1.PopulateFromARM(owner, *typedInput.ImmediateCopy)
		if err != nil {
			return err
		}
		immediateCopy := immediateCopy1
		option.ImmediateCopy = &immediateCopy
	}

	// No error
	return nil
}

// AssignProperties_From_CopyOption populates our CopyOption from the provided source CopyOption
func (option *CopyOption) AssignProperties_From_CopyOption(source *v20230101s.CopyOption) error {

	// CopyOnExpiry
	if source.CopyOnExpiry != nil {
		var copyOnExpiry CopyOnExpiryOption
		err := copyOnExpiry.AssignProperties_From_CopyOnExpiryOption(source.CopyOnExpiry)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_CopyOnExpiryOption() to populate field CopyOnExpiry")
		}
		option.CopyOnExpiry = &copyOnExpiry
	} else {
		option.CopyOnExpiry = nil
	}

	// CustomCopy
	if source.CustomCopy != nil {
		var customCopy CustomCopyOption
		err := customCopy.AssignProperties_From_CustomCopyOption(source.CustomCopy)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_CustomCopyOption() to populate field CustomCopy")
		}
		option.CustomCopy = &customCopy
	} else {
		option.CustomCopy = nil
	}

	// ImmediateCopy
	if source.ImmediateCopy != nil {
		var immediateCopy ImmediateCopyOption
		err := immediateCopy.AssignProperties_From_ImmediateCopyOption(source.ImmediateCopy)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ImmediateCopyOption() to populate field ImmediateCopy")
		}
		option.ImmediateCopy = &immediateCopy
	} else {
		option.ImmediateCopy = nil
	}

	// No error
	return nil
}

// AssignProperties_To_CopyOption populates the provided destination CopyOption from our CopyOption
func (option *CopyOption) AssignProperties_To_CopyOption(destination *v20230101s.CopyOption) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CopyOnExpiry
	if option.CopyOnExpiry != nil {
		var copyOnExpiry v20230101s.CopyOnExpiryOption
		err := option.CopyOnExpiry.AssignProperties_To_CopyOnExpiryOption(&copyOnExpiry)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_CopyOnExpiryOption() to populate field CopyOnExpiry")
		}
		destination.CopyOnExpiry = &copyOnExpiry
	} else {
		destination.CopyOnExpiry = nil
	}

	// CustomCopy
	if option.CustomCopy != nil {
		var customCopy v20230101s.CustomCopyOption
		err := option.CustomCopy.AssignProperties_To_CustomCopyOption(&customCopy)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_CustomCopyOption() to populate field CustomCopy")
		}
		destination.CustomCopy = &customCopy
	} else {
		destination.CustomCopy = nil
	}

	// ImmediateCopy
	if option.ImmediateCopy != nil {
		var immediateCopy v20230101s.ImmediateCopyOption
		err := option.ImmediateCopy.AssignProperties_To_ImmediateCopyOption(&immediateCopy)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ImmediateCopyOption() to populate field ImmediateCopy")
		}
		destination.ImmediateCopy = &immediateCopy
	} else {
		destination.ImmediateCopy = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_CopyOption_STATUS populates our CopyOption from the provided source CopyOption_STATUS
func (option *CopyOption) Initialize_From_CopyOption_STATUS(source *CopyOption_STATUS) error {

	// CopyOnExpiry
	if source.CopyOnExpiry != nil {
		var copyOnExpiry CopyOnExpiryOption
		err := copyOnExpiry.Initialize_From_CopyOnExpiryOption_STATUS(source.CopyOnExpiry)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_CopyOnExpiryOption_STATUS() to populate field CopyOnExpiry")
		}
		option.CopyOnExpiry = &copyOnExpiry
	} else {
		option.CopyOnExpiry = nil
	}

	// CustomCopy
	if source.CustomCopy != nil {
		var customCopy CustomCopyOption
		err := customCopy.Initialize_From_CustomCopyOption_STATUS(source.CustomCopy)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_CustomCopyOption_STATUS() to populate field CustomCopy")
		}
		option.CustomCopy = &customCopy
	} else {
		option.CustomCopy = nil
	}

	// ImmediateCopy
	if source.ImmediateCopy != nil {
		var immediateCopy ImmediateCopyOption
		err := immediateCopy.Initialize_From_ImmediateCopyOption_STATUS(source.ImmediateCopy)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_ImmediateCopyOption_STATUS() to populate field ImmediateCopy")
		}
		option.ImmediateCopy = &immediateCopy
	} else {
		option.ImmediateCopy = nil
	}

	// No error
	return nil
}

type CopyOption_STATUS struct {
	// CopyOnExpiry: Mutually exclusive with all other properties
	CopyOnExpiry *CopyOnExpiryOption_STATUS `json:"copyOnExpiryOption,omitempty"`

	// CustomCopy: Mutually exclusive with all other properties
	CustomCopy *CustomCopyOption_STATUS `json:"customCopyOption,omitempty"`

	// ImmediateCopy: Mutually exclusive with all other properties
	ImmediateCopy *ImmediateCopyOption_STATUS `json:"immediateCopyOption,omitempty"`
}

var _ genruntime.FromARMConverter = &CopyOption_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (option *CopyOption_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &CopyOption_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (option *CopyOption_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(CopyOption_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected CopyOption_STATUS_ARM, got %T", armInput)
	}

	// Set property "CopyOnExpiry":
	if typedInput.CopyOnExpiry != nil {
		var copyOnExpiry1 CopyOnExpiryOption_STATUS
		err := copyOnExpiry1.PopulateFromARM(owner, *typedInput.CopyOnExpiry)
		if err != nil {
			return err
		}
		copyOnExpiry := copyOnExpiry1
		option.CopyOnExpiry = &copyOnExpiry
	}

	// Set property "CustomCopy":
	if typedInput.CustomCopy != nil {
		var customCopy1 CustomCopyOption_STATUS
		err := customCopy1.PopulateFromARM(owner, *typedInput.CustomCopy)
		if err != nil {
			return err
		}
		customCopy := customCopy1
		option.CustomCopy = &customCopy
	}

	// Set property "ImmediateCopy":
	if typedInput.ImmediateCopy != nil {
		var immediateCopy1 ImmediateCopyOption_STATUS
		err := immediateCopy1.PopulateFromARM(owner, *typedInput.ImmediateCopy)
		if err != nil {
			return err
		}
		immediateCopy := immediateCopy1
		option.ImmediateCopy = &immediateCopy
	}

	// No error
	return nil
}

// AssignProperties_From_CopyOption_STATUS populates our CopyOption_STATUS from the provided source CopyOption_STATUS
func (option *CopyOption_STATUS) AssignProperties_From_CopyOption_STATUS(source *v20230101s.CopyOption_STATUS) error {

	// CopyOnExpiry
	if source.CopyOnExpiry != nil {
		var copyOnExpiry CopyOnExpiryOption_STATUS
		err := copyOnExpiry.AssignProperties_From_CopyOnExpiryOption_STATUS(source.CopyOnExpiry)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_CopyOnExpiryOption_STATUS() to populate field CopyOnExpiry")
		}
		option.CopyOnExpiry = &copyOnExpiry
	} else {
		option.CopyOnExpiry = nil
	}

	// CustomCopy
	if source.CustomCopy != nil {
		var customCopy CustomCopyOption_STATUS
		err := customCopy.AssignProperties_From_CustomCopyOption_STATUS(source.CustomCopy)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_CustomCopyOption_STATUS() to populate field CustomCopy")
		}
		option.CustomCopy = &customCopy
	} else {
		option.CustomCopy = nil
	}

	// ImmediateCopy
	if source.ImmediateCopy != nil {
		var immediateCopy ImmediateCopyOption_STATUS
		err := immediateCopy.AssignProperties_From_ImmediateCopyOption_STATUS(source.ImmediateCopy)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ImmediateCopyOption_STATUS() to populate field ImmediateCopy")
		}
		option.ImmediateCopy = &immediateCopy
	} else {
		option.ImmediateCopy = nil
	}

	// No error
	return nil
}

// AssignProperties_To_CopyOption_STATUS populates the provided destination CopyOption_STATUS from our CopyOption_STATUS
func (option *CopyOption_STATUS) AssignProperties_To_CopyOption_STATUS(destination *v20230101s.CopyOption_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CopyOnExpiry
	if option.CopyOnExpiry != nil {
		var copyOnExpiry v20230101s.CopyOnExpiryOption_STATUS
		err := option.CopyOnExpiry.AssignProperties_To_CopyOnExpiryOption_STATUS(&copyOnExpiry)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_CopyOnExpiryOption_STATUS() to populate field CopyOnExpiry")
		}
		destination.CopyOnExpiry = &copyOnExpiry
	} else {
		destination.CopyOnExpiry = nil
	}

	// CustomCopy
	if option.CustomCopy != nil {
		var customCopy v20230101s.CustomCopyOption_STATUS
		err := option.CustomCopy.AssignProperties_To_CustomCopyOption_STATUS(&customCopy)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_CustomCopyOption_STATUS() to populate field CustomCopy")
		}
		destination.CustomCopy = &customCopy
	} else {
		destination.CustomCopy = nil
	}

	// ImmediateCopy
	if option.ImmediateCopy != nil {
		var immediateCopy v20230101s.ImmediateCopyOption_STATUS
		err := option.ImmediateCopy.AssignProperties_To_ImmediateCopyOption_STATUS(&immediateCopy)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ImmediateCopyOption_STATUS() to populate field ImmediateCopy")
		}
		destination.ImmediateCopy = &immediateCopy
	} else {
		destination.ImmediateCopy = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Tagging criteria
type TaggingCriteria struct {
	// Criteria: Criteria which decides whether the tag can be applied to a triggered backup.
	Criteria []BackupCriteria `json:"criteria,omitempty"`

	// +kubebuilder:validation:Required
	// IsDefault: Specifies if tag is default.
	IsDefault *bool `json:"isDefault,omitempty"`

	// +kubebuilder:validation:Required
	// TagInfo: Retention tag information
	TagInfo *RetentionTag `json:"tagInfo,omitempty"`

	// +kubebuilder:validation:Required
	// TaggingPriority: Retention Tag priority.
	TaggingPriority *int `json:"taggingPriority,omitempty"`
}

var _ genruntime.ARMTransformer = &TaggingCriteria{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (criteria *TaggingCriteria) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if criteria == nil {
		return nil, nil
	}
	result := &TaggingCriteria_ARM{}

	// Set property "Criteria":
	for _, item := range criteria.Criteria {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Criteria = append(result.Criteria, *item_ARM.(*BackupCriteria_ARM))
	}

	// Set property "IsDefault":
	if criteria.IsDefault != nil {
		isDefault := *criteria.IsDefault
		result.IsDefault = &isDefault
	}

	// Set property "TagInfo":
	if criteria.TagInfo != nil {
		tagInfo_ARM, err := (*criteria.TagInfo).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		tagInfo := *tagInfo_ARM.(*RetentionTag_ARM)
		result.TagInfo = &tagInfo
	}

	// Set property "TaggingPriority":
	if criteria.TaggingPriority != nil {
		taggingPriority := *criteria.TaggingPriority
		result.TaggingPriority = &taggingPriority
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (criteria *TaggingCriteria) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &TaggingCriteria_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (criteria *TaggingCriteria) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(TaggingCriteria_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected TaggingCriteria_ARM, got %T", armInput)
	}

	// Set property "Criteria":
	for _, item := range typedInput.Criteria {
		var item1 BackupCriteria
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		criteria.Criteria = append(criteria.Criteria, item1)
	}

	// Set property "IsDefault":
	if typedInput.IsDefault != nil {
		isDefault := *typedInput.IsDefault
		criteria.IsDefault = &isDefault
	}

	// Set property "TagInfo":
	if typedInput.TagInfo != nil {
		var tagInfo1 RetentionTag
		err := tagInfo1.PopulateFromARM(owner, *typedInput.TagInfo)
		if err != nil {
			return err
		}
		tagInfo := tagInfo1
		criteria.TagInfo = &tagInfo
	}

	// Set property "TaggingPriority":
	if typedInput.TaggingPriority != nil {
		taggingPriority := *typedInput.TaggingPriority
		criteria.TaggingPriority = &taggingPriority
	}

	// No error
	return nil
}

// AssignProperties_From_TaggingCriteria populates our TaggingCriteria from the provided source TaggingCriteria
func (criteria *TaggingCriteria) AssignProperties_From_TaggingCriteria(source *v20230101s.TaggingCriteria) error {

	// Criteria
	if source.Criteria != nil {
		criterionList := make([]BackupCriteria, len(source.Criteria))
		for criterionIndex, criterionItem := range source.Criteria {
			// Shadow the loop variable to avoid aliasing
			criterionItem := criterionItem
			var criterion BackupCriteria
			err := criterion.AssignProperties_From_BackupCriteria(&criterionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_BackupCriteria() to populate field Criteria")
			}
			criterionList[criterionIndex] = criterion
		}
		criteria.Criteria = criterionList
	} else {
		criteria.Criteria = nil
	}

	// IsDefault
	if source.IsDefault != nil {
		isDefault := *source.IsDefault
		criteria.IsDefault = &isDefault
	} else {
		criteria.IsDefault = nil
	}

	// TagInfo
	if source.TagInfo != nil {
		var tagInfo RetentionTag
		err := tagInfo.AssignProperties_From_RetentionTag(source.TagInfo)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_RetentionTag() to populate field TagInfo")
		}
		criteria.TagInfo = &tagInfo
	} else {
		criteria.TagInfo = nil
	}

	// TaggingPriority
	criteria.TaggingPriority = genruntime.ClonePointerToInt(source.TaggingPriority)

	// No error
	return nil
}

// AssignProperties_To_TaggingCriteria populates the provided destination TaggingCriteria from our TaggingCriteria
func (criteria *TaggingCriteria) AssignProperties_To_TaggingCriteria(destination *v20230101s.TaggingCriteria) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Criteria
	if criteria.Criteria != nil {
		criterionList := make([]v20230101s.BackupCriteria, len(criteria.Criteria))
		for criterionIndex, criterionItem := range criteria.Criteria {
			// Shadow the loop variable to avoid aliasing
			criterionItem := criterionItem
			var criterion v20230101s.BackupCriteria
			err := criterionItem.AssignProperties_To_BackupCriteria(&criterion)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_BackupCriteria() to populate field Criteria")
			}
			criterionList[criterionIndex] = criterion
		}
		destination.Criteria = criterionList
	} else {
		destination.Criteria = nil
	}

	// IsDefault
	if criteria.IsDefault != nil {
		isDefault := *criteria.IsDefault
		destination.IsDefault = &isDefault
	} else {
		destination.IsDefault = nil
	}

	// TagInfo
	if criteria.TagInfo != nil {
		var tagInfo v20230101s.RetentionTag
		err := criteria.TagInfo.AssignProperties_To_RetentionTag(&tagInfo)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_RetentionTag() to populate field TagInfo")
		}
		destination.TagInfo = &tagInfo
	} else {
		destination.TagInfo = nil
	}

	// TaggingPriority
	destination.TaggingPriority = genruntime.ClonePointerToInt(criteria.TaggingPriority)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_TaggingCriteria_STATUS populates our TaggingCriteria from the provided source TaggingCriteria_STATUS
func (criteria *TaggingCriteria) Initialize_From_TaggingCriteria_STATUS(source *TaggingCriteria_STATUS) error {

	// Criteria
	if source.Criteria != nil {
		criterionList := make([]BackupCriteria, len(source.Criteria))
		for criterionIndex, criterionItem := range source.Criteria {
			// Shadow the loop variable to avoid aliasing
			criterionItem := criterionItem
			var criterion BackupCriteria
			err := criterion.Initialize_From_BackupCriteria_STATUS(&criterionItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_BackupCriteria_STATUS() to populate field Criteria")
			}
			criterionList[criterionIndex] = criterion
		}
		criteria.Criteria = criterionList
	} else {
		criteria.Criteria = nil
	}

	// IsDefault
	if source.IsDefault != nil {
		isDefault := *source.IsDefault
		criteria.IsDefault = &isDefault
	} else {
		criteria.IsDefault = nil
	}

	// TagInfo
	if source.TagInfo != nil {
		var tagInfo RetentionTag
		err := tagInfo.Initialize_From_RetentionTag_STATUS(source.TagInfo)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_RetentionTag_STATUS() to populate field TagInfo")
		}
		criteria.TagInfo = &tagInfo
	} else {
		criteria.TagInfo = nil
	}

	// TaggingPriority
	criteria.TaggingPriority = genruntime.ClonePointerToInt(source.TaggingPriority)

	// No error
	return nil
}

// Tagging criteria
type TaggingCriteria_STATUS struct {
	// Criteria: Criteria which decides whether the tag can be applied to a triggered backup.
	Criteria []BackupCriteria_STATUS `json:"criteria,omitempty"`

	// IsDefault: Specifies if tag is default.
	IsDefault *bool `json:"isDefault,omitempty"`

	// TagInfo: Retention tag information
	TagInfo *RetentionTag_STATUS `json:"tagInfo,omitempty"`

	// TaggingPriority: Retention Tag priority.
	TaggingPriority *int `json:"taggingPriority,omitempty"`
}

var _ genruntime.FromARMConverter = &TaggingCriteria_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (criteria *TaggingCriteria_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &TaggingCriteria_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (criteria *TaggingCriteria_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(TaggingCriteria_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected TaggingCriteria_STATUS_ARM, got %T", armInput)
	}

	// Set property "Criteria":
	for _, item := range typedInput.Criteria {
		var item1 BackupCriteria_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		criteria.Criteria = append(criteria.Criteria, item1)
	}

	// Set property "IsDefault":
	if typedInput.IsDefault != nil {
		isDefault := *typedInput.IsDefault
		criteria.IsDefault = &isDefault
	}

	// Set property "TagInfo":
	if typedInput.TagInfo != nil {
		var tagInfo1 RetentionTag_STATUS
		err := tagInfo1.PopulateFromARM(owner, *typedInput.TagInfo)
		if err != nil {
			return err
		}
		tagInfo := tagInfo1
		criteria.TagInfo = &tagInfo
	}

	// Set property "TaggingPriority":
	if typedInput.TaggingPriority != nil {
		taggingPriority := *typedInput.TaggingPriority
		criteria.TaggingPriority = &taggingPriority
	}

	// No error
	return nil
}

// AssignProperties_From_TaggingCriteria_STATUS populates our TaggingCriteria_STATUS from the provided source TaggingCriteria_STATUS
func (criteria *TaggingCriteria_STATUS) AssignProperties_From_TaggingCriteria_STATUS(source *v20230101s.TaggingCriteria_STATUS) error {

	// Criteria
	if source.Criteria != nil {
		criterionList := make([]BackupCriteria_STATUS, len(source.Criteria))
		for criterionIndex, criterionItem := range source.Criteria {
			// Shadow the loop variable to avoid aliasing
			criterionItem := criterionItem
			var criterion BackupCriteria_STATUS
			err := criterion.AssignProperties_From_BackupCriteria_STATUS(&criterionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_BackupCriteria_STATUS() to populate field Criteria")
			}
			criterionList[criterionIndex] = criterion
		}
		criteria.Criteria = criterionList
	} else {
		criteria.Criteria = nil
	}

	// IsDefault
	if source.IsDefault != nil {
		isDefault := *source.IsDefault
		criteria.IsDefault = &isDefault
	} else {
		criteria.IsDefault = nil
	}

	// TagInfo
	if source.TagInfo != nil {
		var tagInfo RetentionTag_STATUS
		err := tagInfo.AssignProperties_From_RetentionTag_STATUS(source.TagInfo)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_RetentionTag_STATUS() to populate field TagInfo")
		}
		criteria.TagInfo = &tagInfo
	} else {
		criteria.TagInfo = nil
	}

	// TaggingPriority
	criteria.TaggingPriority = genruntime.ClonePointerToInt(source.TaggingPriority)

	// No error
	return nil
}

// AssignProperties_To_TaggingCriteria_STATUS populates the provided destination TaggingCriteria_STATUS from our TaggingCriteria_STATUS
func (criteria *TaggingCriteria_STATUS) AssignProperties_To_TaggingCriteria_STATUS(destination *v20230101s.TaggingCriteria_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Criteria
	if criteria.Criteria != nil {
		criterionList := make([]v20230101s.BackupCriteria_STATUS, len(criteria.Criteria))
		for criterionIndex, criterionItem := range criteria.Criteria {
			// Shadow the loop variable to avoid aliasing
			criterionItem := criterionItem
			var criterion v20230101s.BackupCriteria_STATUS
			err := criterionItem.AssignProperties_To_BackupCriteria_STATUS(&criterion)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_BackupCriteria_STATUS() to populate field Criteria")
			}
			criterionList[criterionIndex] = criterion
		}
		destination.Criteria = criterionList
	} else {
		destination.Criteria = nil
	}

	// IsDefault
	if criteria.IsDefault != nil {
		isDefault := *criteria.IsDefault
		destination.IsDefault = &isDefault
	} else {
		destination.IsDefault = nil
	}

	// TagInfo
	if criteria.TagInfo != nil {
		var tagInfo v20230101s.RetentionTag_STATUS
		err := criteria.TagInfo.AssignProperties_To_RetentionTag_STATUS(&tagInfo)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_RetentionTag_STATUS() to populate field TagInfo")
		}
		destination.TagInfo = &tagInfo
	} else {
		destination.TagInfo = nil
	}

	// TaggingPriority
	destination.TaggingPriority = genruntime.ClonePointerToInt(criteria.TaggingPriority)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type BackupCriteria struct {
	// ScheduleBasedBackupCriteria: Mutually exclusive with all other properties
	ScheduleBasedBackupCriteria *ScheduleBasedBackupCriteria `json:"scheduleBasedBackupCriteria,omitempty"`
}

var _ genruntime.ARMTransformer = &BackupCriteria{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (criteria *BackupCriteria) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if criteria == nil {
		return nil, nil
	}
	result := &BackupCriteria_ARM{}

	// Set property "ScheduleBasedBackupCriteria":
	if criteria.ScheduleBasedBackupCriteria != nil {
		scheduleBasedBackupCriteria_ARM, err := (*criteria.ScheduleBasedBackupCriteria).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		scheduleBasedBackupCriteria := *scheduleBasedBackupCriteria_ARM.(*ScheduleBasedBackupCriteria_ARM)
		result.ScheduleBasedBackupCriteria = &scheduleBasedBackupCriteria
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (criteria *BackupCriteria) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &BackupCriteria_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (criteria *BackupCriteria) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(BackupCriteria_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected BackupCriteria_ARM, got %T", armInput)
	}

	// Set property "ScheduleBasedBackupCriteria":
	if typedInput.ScheduleBasedBackupCriteria != nil {
		var scheduleBasedBackupCriteria1 ScheduleBasedBackupCriteria
		err := scheduleBasedBackupCriteria1.PopulateFromARM(owner, *typedInput.ScheduleBasedBackupCriteria)
		if err != nil {
			return err
		}
		scheduleBasedBackupCriteria := scheduleBasedBackupCriteria1
		criteria.ScheduleBasedBackupCriteria = &scheduleBasedBackupCriteria
	}

	// No error
	return nil
}

// AssignProperties_From_BackupCriteria populates our BackupCriteria from the provided source BackupCriteria
func (criteria *BackupCriteria) AssignProperties_From_BackupCriteria(source *v20230101s.BackupCriteria) error {

	// ScheduleBasedBackupCriteria
	if source.ScheduleBasedBackupCriteria != nil {
		var scheduleBasedBackupCriterion ScheduleBasedBackupCriteria
		err := scheduleBasedBackupCriterion.AssignProperties_From_ScheduleBasedBackupCriteria(source.ScheduleBasedBackupCriteria)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ScheduleBasedBackupCriteria() to populate field ScheduleBasedBackupCriteria")
		}
		criteria.ScheduleBasedBackupCriteria = &scheduleBasedBackupCriterion
	} else {
		criteria.ScheduleBasedBackupCriteria = nil
	}

	// No error
	return nil
}

// AssignProperties_To_BackupCriteria populates the provided destination BackupCriteria from our BackupCriteria
func (criteria *BackupCriteria) AssignProperties_To_BackupCriteria(destination *v20230101s.BackupCriteria) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ScheduleBasedBackupCriteria
	if criteria.ScheduleBasedBackupCriteria != nil {
		var scheduleBasedBackupCriterion v20230101s.ScheduleBasedBackupCriteria
		err := criteria.ScheduleBasedBackupCriteria.AssignProperties_To_ScheduleBasedBackupCriteria(&scheduleBasedBackupCriterion)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ScheduleBasedBackupCriteria() to populate field ScheduleBasedBackupCriteria")
		}
		destination.ScheduleBasedBackupCriteria = &scheduleBasedBackupCriterion
	} else {
		destination.ScheduleBasedBackupCriteria = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_BackupCriteria_STATUS populates our BackupCriteria from the provided source BackupCriteria_STATUS
func (criteria *BackupCriteria) Initialize_From_BackupCriteria_STATUS(source *BackupCriteria_STATUS) error {

	// ScheduleBasedBackupCriteria
	if source.ScheduleBasedBackupCriteria != nil {
		var scheduleBasedBackupCriterion ScheduleBasedBackupCriteria
		err := scheduleBasedBackupCriterion.Initialize_From_ScheduleBasedBackupCriteria_STATUS(source.ScheduleBasedBackupCriteria)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_ScheduleBasedBackupCriteria_STATUS() to populate field ScheduleBasedBackupCriteria")
		}
		criteria.ScheduleBasedBackupCriteria = &scheduleBasedBackupCriterion
	} else {
		criteria.ScheduleBasedBackupCriteria = nil
	}

	// No error
	return nil
}

type BackupCriteria_STATUS struct {
	// ScheduleBasedBackupCriteria: Mutually exclusive with all other properties
	ScheduleBasedBackupCriteria *ScheduleBasedBackupCriteria_STATUS `json:"scheduleBasedBackupCriteria,omitempty"`
}

var _ genruntime.FromARMConverter = &BackupCriteria_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (criteria *BackupCriteria_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &BackupCriteria_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (criteria *BackupCriteria_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(BackupCriteria_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected BackupCriteria_STATUS_ARM, got %T", armInput)
	}

	// Set property "ScheduleBasedBackupCriteria":
	if typedInput.ScheduleBasedBackupCriteria != nil {
		var scheduleBasedBackupCriteria1 ScheduleBasedBackupCriteria_STATUS
		err := scheduleBasedBackupCriteria1.PopulateFromARM(owner, *typedInput.ScheduleBasedBackupCriteria)
		if err != nil {
			return err
		}
		scheduleBasedBackupCriteria := scheduleBasedBackupCriteria1
		criteria.ScheduleBasedBackupCriteria = &scheduleBasedBackupCriteria
	}

	// No error
	return nil
}

// AssignProperties_From_BackupCriteria_STATUS populates our BackupCriteria_STATUS from the provided source BackupCriteria_STATUS
func (criteria *BackupCriteria_STATUS) AssignProperties_From_BackupCriteria_STATUS(source *v20230101s.BackupCriteria_STATUS) error {

	// ScheduleBasedBackupCriteria
	if source.ScheduleBasedBackupCriteria != nil {
		var scheduleBasedBackupCriterion ScheduleBasedBackupCriteria_STATUS
		err := scheduleBasedBackupCriterion.AssignProperties_From_ScheduleBasedBackupCriteria_STATUS(source.ScheduleBasedBackupCriteria)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ScheduleBasedBackupCriteria_STATUS() to populate field ScheduleBasedBackupCriteria")
		}
		criteria.ScheduleBasedBackupCriteria = &scheduleBasedBackupCriterion
	} else {
		criteria.ScheduleBasedBackupCriteria = nil
	}

	// No error
	return nil
}

// AssignProperties_To_BackupCriteria_STATUS populates the provided destination BackupCriteria_STATUS from our BackupCriteria_STATUS
func (criteria *BackupCriteria_STATUS) AssignProperties_To_BackupCriteria_STATUS(destination *v20230101s.BackupCriteria_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ScheduleBasedBackupCriteria
	if criteria.ScheduleBasedBackupCriteria != nil {
		var scheduleBasedBackupCriterion v20230101s.ScheduleBasedBackupCriteria_STATUS
		err := criteria.ScheduleBasedBackupCriteria.AssignProperties_To_ScheduleBasedBackupCriteria_STATUS(&scheduleBasedBackupCriterion)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ScheduleBasedBackupCriteria_STATUS() to populate field ScheduleBasedBackupCriteria")
		}
		destination.ScheduleBasedBackupCriteria = &scheduleBasedBackupCriterion
	} else {
		destination.ScheduleBasedBackupCriteria = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type CopyOnExpiryOption struct {
	// +kubebuilder:validation:Required
	// ObjectType: Type of the specific object - used for deserializing
	ObjectType *CopyOnExpiryOption_ObjectType `json:"objectType,omitempty"`
}

var _ genruntime.ARMTransformer = &CopyOnExpiryOption{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (option *CopyOnExpiryOption) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if option == nil {
		return nil, nil
	}
	result := &CopyOnExpiryOption_ARM{}

	// Set property "ObjectType":
	if option.ObjectType != nil {
		result.ObjectType = *option.ObjectType
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (option *CopyOnExpiryOption) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &CopyOnExpiryOption_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (option *CopyOnExpiryOption) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(CopyOnExpiryOption_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected CopyOnExpiryOption_ARM, got %T", armInput)
	}

	// Set property "ObjectType":
	option.ObjectType = &typedInput.ObjectType

	// No error
	return nil
}

// AssignProperties_From_CopyOnExpiryOption populates our CopyOnExpiryOption from the provided source CopyOnExpiryOption
func (option *CopyOnExpiryOption) AssignProperties_From_CopyOnExpiryOption(source *v20230101s.CopyOnExpiryOption) error {

	// ObjectType
	if source.ObjectType != nil {
		objectType := CopyOnExpiryOption_ObjectType(*source.ObjectType)
		option.ObjectType = &objectType
	} else {
		option.ObjectType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_CopyOnExpiryOption populates the provided destination CopyOnExpiryOption from our CopyOnExpiryOption
func (option *CopyOnExpiryOption) AssignProperties_To_CopyOnExpiryOption(destination *v20230101s.CopyOnExpiryOption) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ObjectType
	if option.ObjectType != nil {
		objectType := string(*option.ObjectType)
		destination.ObjectType = &objectType
	} else {
		destination.ObjectType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_CopyOnExpiryOption_STATUS populates our CopyOnExpiryOption from the provided source CopyOnExpiryOption_STATUS
func (option *CopyOnExpiryOption) Initialize_From_CopyOnExpiryOption_STATUS(source *CopyOnExpiryOption_STATUS) error {

	// ObjectType
	if source.ObjectType != nil {
		objectType := CopyOnExpiryOption_ObjectType(*source.ObjectType)
		option.ObjectType = &objectType
	} else {
		option.ObjectType = nil
	}

	// No error
	return nil
}

type CopyOnExpiryOption_STATUS struct {
	// ObjectType: Type of the specific object - used for deserializing
	ObjectType *CopyOnExpiryOption_ObjectType_STATUS `json:"objectType,omitempty"`
}

var _ genruntime.FromARMConverter = &CopyOnExpiryOption_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (option *CopyOnExpiryOption_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &CopyOnExpiryOption_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (option *CopyOnExpiryOption_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(CopyOnExpiryOption_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected CopyOnExpiryOption_STATUS_ARM, got %T", armInput)
	}

	// Set property "ObjectType":
	option.ObjectType = &typedInput.ObjectType

	// No error
	return nil
}

// AssignProperties_From_CopyOnExpiryOption_STATUS populates our CopyOnExpiryOption_STATUS from the provided source CopyOnExpiryOption_STATUS
func (option *CopyOnExpiryOption_STATUS) AssignProperties_From_CopyOnExpiryOption_STATUS(source *v20230101s.CopyOnExpiryOption_STATUS) error {

	// ObjectType
	if source.ObjectType != nil {
		objectType := CopyOnExpiryOption_ObjectType_STATUS(*source.ObjectType)
		option.ObjectType = &objectType
	} else {
		option.ObjectType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_CopyOnExpiryOption_STATUS populates the provided destination CopyOnExpiryOption_STATUS from our CopyOnExpiryOption_STATUS
func (option *CopyOnExpiryOption_STATUS) AssignProperties_To_CopyOnExpiryOption_STATUS(destination *v20230101s.CopyOnExpiryOption_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ObjectType
	if option.ObjectType != nil {
		objectType := string(*option.ObjectType)
		destination.ObjectType = &objectType
	} else {
		destination.ObjectType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type CustomCopyOption struct {
	// Duration: Data copied after given timespan
	Duration *string `json:"duration,omitempty"`

	// +kubebuilder:validation:Required
	// ObjectType: Type of the specific object - used for deserializing
	ObjectType *CustomCopyOption_ObjectType `json:"objectType,omitempty"`
}

var _ genruntime.ARMTransformer = &CustomCopyOption{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (option *CustomCopyOption) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if option == nil {
		return nil, nil
	}
	result := &CustomCopyOption_ARM{}

	// Set property "Duration":
	if option.Duration != nil {
		duration := *option.Duration
		result.Duration = &duration
	}

	// Set property "ObjectType":
	if option.ObjectType != nil {
		result.ObjectType = *option.ObjectType
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (option *CustomCopyOption) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &CustomCopyOption_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (option *CustomCopyOption) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(CustomCopyOption_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected CustomCopyOption_ARM, got %T", armInput)
	}

	// Set property "Duration":
	if typedInput.Duration != nil {
		duration := *typedInput.Duration
		option.Duration = &duration
	}

	// Set property "ObjectType":
	option.ObjectType = &typedInput.ObjectType

	// No error
	return nil
}

// AssignProperties_From_CustomCopyOption populates our CustomCopyOption from the provided source CustomCopyOption
func (option *CustomCopyOption) AssignProperties_From_CustomCopyOption(source *v20230101s.CustomCopyOption) error {

	// Duration
	option.Duration = genruntime.ClonePointerToString(source.Duration)

	// ObjectType
	if source.ObjectType != nil {
		objectType := CustomCopyOption_ObjectType(*source.ObjectType)
		option.ObjectType = &objectType
	} else {
		option.ObjectType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_CustomCopyOption populates the provided destination CustomCopyOption from our CustomCopyOption
func (option *CustomCopyOption) AssignProperties_To_CustomCopyOption(destination *v20230101s.CustomCopyOption) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Duration
	destination.Duration = genruntime.ClonePointerToString(option.Duration)

	// ObjectType
	if option.ObjectType != nil {
		objectType := string(*option.ObjectType)
		destination.ObjectType = &objectType
	} else {
		destination.ObjectType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_CustomCopyOption_STATUS populates our CustomCopyOption from the provided source CustomCopyOption_STATUS
func (option *CustomCopyOption) Initialize_From_CustomCopyOption_STATUS(source *CustomCopyOption_STATUS) error {

	// Duration
	option.Duration = genruntime.ClonePointerToString(source.Duration)

	// ObjectType
	if source.ObjectType != nil {
		objectType := CustomCopyOption_ObjectType(*source.ObjectType)
		option.ObjectType = &objectType
	} else {
		option.ObjectType = nil
	}

	// No error
	return nil
}

type CustomCopyOption_STATUS struct {
	// Duration: Data copied after given timespan
	Duration *string `json:"duration,omitempty"`

	// ObjectType: Type of the specific object - used for deserializing
	ObjectType *CustomCopyOption_ObjectType_STATUS `json:"objectType,omitempty"`
}

var _ genruntime.FromARMConverter = &CustomCopyOption_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (option *CustomCopyOption_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &CustomCopyOption_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (option *CustomCopyOption_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(CustomCopyOption_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected CustomCopyOption_STATUS_ARM, got %T", armInput)
	}

	// Set property "Duration":
	if typedInput.Duration != nil {
		duration := *typedInput.Duration
		option.Duration = &duration
	}

	// Set property "ObjectType":
	option.ObjectType = &typedInput.ObjectType

	// No error
	return nil
}

// AssignProperties_From_CustomCopyOption_STATUS populates our CustomCopyOption_STATUS from the provided source CustomCopyOption_STATUS
func (option *CustomCopyOption_STATUS) AssignProperties_From_CustomCopyOption_STATUS(source *v20230101s.CustomCopyOption_STATUS) error {

	// Duration
	option.Duration = genruntime.ClonePointerToString(source.Duration)

	// ObjectType
	if source.ObjectType != nil {
		objectType := CustomCopyOption_ObjectType_STATUS(*source.ObjectType)
		option.ObjectType = &objectType
	} else {
		option.ObjectType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_CustomCopyOption_STATUS populates the provided destination CustomCopyOption_STATUS from our CustomCopyOption_STATUS
func (option *CustomCopyOption_STATUS) AssignProperties_To_CustomCopyOption_STATUS(destination *v20230101s.CustomCopyOption_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Duration
	destination.Duration = genruntime.ClonePointerToString(option.Duration)

	// ObjectType
	if option.ObjectType != nil {
		objectType := string(*option.ObjectType)
		destination.ObjectType = &objectType
	} else {
		destination.ObjectType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ImmediateCopyOption struct {
	// +kubebuilder:validation:Required
	// ObjectType: Type of the specific object - used for deserializing
	ObjectType *ImmediateCopyOption_ObjectType `json:"objectType,omitempty"`
}

var _ genruntime.ARMTransformer = &ImmediateCopyOption{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (option *ImmediateCopyOption) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if option == nil {
		return nil, nil
	}
	result := &ImmediateCopyOption_ARM{}

	// Set property "ObjectType":
	if option.ObjectType != nil {
		result.ObjectType = *option.ObjectType
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (option *ImmediateCopyOption) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ImmediateCopyOption_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (option *ImmediateCopyOption) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ImmediateCopyOption_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ImmediateCopyOption_ARM, got %T", armInput)
	}

	// Set property "ObjectType":
	option.ObjectType = &typedInput.ObjectType

	// No error
	return nil
}

// AssignProperties_From_ImmediateCopyOption populates our ImmediateCopyOption from the provided source ImmediateCopyOption
func (option *ImmediateCopyOption) AssignProperties_From_ImmediateCopyOption(source *v20230101s.ImmediateCopyOption) error {

	// ObjectType
	if source.ObjectType != nil {
		objectType := ImmediateCopyOption_ObjectType(*source.ObjectType)
		option.ObjectType = &objectType
	} else {
		option.ObjectType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ImmediateCopyOption populates the provided destination ImmediateCopyOption from our ImmediateCopyOption
func (option *ImmediateCopyOption) AssignProperties_To_ImmediateCopyOption(destination *v20230101s.ImmediateCopyOption) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ObjectType
	if option.ObjectType != nil {
		objectType := string(*option.ObjectType)
		destination.ObjectType = &objectType
	} else {
		destination.ObjectType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ImmediateCopyOption_STATUS populates our ImmediateCopyOption from the provided source ImmediateCopyOption_STATUS
func (option *ImmediateCopyOption) Initialize_From_ImmediateCopyOption_STATUS(source *ImmediateCopyOption_STATUS) error {

	// ObjectType
	if source.ObjectType != nil {
		objectType := ImmediateCopyOption_ObjectType(*source.ObjectType)
		option.ObjectType = &objectType
	} else {
		option.ObjectType = nil
	}

	// No error
	return nil
}

type ImmediateCopyOption_STATUS struct {
	// ObjectType: Type of the specific object - used for deserializing
	ObjectType *ImmediateCopyOption_ObjectType_STATUS `json:"objectType,omitempty"`
}

var _ genruntime.FromARMConverter = &ImmediateCopyOption_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (option *ImmediateCopyOption_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ImmediateCopyOption_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (option *ImmediateCopyOption_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ImmediateCopyOption_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ImmediateCopyOption_STATUS_ARM, got %T", armInput)
	}

	// Set property "ObjectType":
	option.ObjectType = &typedInput.ObjectType

	// No error
	return nil
}

// AssignProperties_From_ImmediateCopyOption_STATUS populates our ImmediateCopyOption_STATUS from the provided source ImmediateCopyOption_STATUS
func (option *ImmediateCopyOption_STATUS) AssignProperties_From_ImmediateCopyOption_STATUS(source *v20230101s.ImmediateCopyOption_STATUS) error {

	// ObjectType
	if source.ObjectType != nil {
		objectType := ImmediateCopyOption_ObjectType_STATUS(*source.ObjectType)
		option.ObjectType = &objectType
	} else {
		option.ObjectType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ImmediateCopyOption_STATUS populates the provided destination ImmediateCopyOption_STATUS from our ImmediateCopyOption_STATUS
func (option *ImmediateCopyOption_STATUS) AssignProperties_To_ImmediateCopyOption_STATUS(destination *v20230101s.ImmediateCopyOption_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ObjectType
	if option.ObjectType != nil {
		objectType := string(*option.ObjectType)
		destination.ObjectType = &objectType
	} else {
		destination.ObjectType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Retention tag
type RetentionTag struct {
	// +kubebuilder:validation:Required
	// TagName: Retention Tag Name to relate it to retention rule.
	TagName *string `json:"tagName,omitempty"`
}

var _ genruntime.ARMTransformer = &RetentionTag{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (retentionTag *RetentionTag) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if retentionTag == nil {
		return nil, nil
	}
	result := &RetentionTag_ARM{}

	// Set property "TagName":
	if retentionTag.TagName != nil {
		tagName := *retentionTag.TagName
		result.TagName = &tagName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (retentionTag *RetentionTag) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &RetentionTag_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (retentionTag *RetentionTag) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(RetentionTag_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected RetentionTag_ARM, got %T", armInput)
	}

	// Set property "TagName":
	if typedInput.TagName != nil {
		tagName := *typedInput.TagName
		retentionTag.TagName = &tagName
	}

	// No error
	return nil
}

// AssignProperties_From_RetentionTag populates our RetentionTag from the provided source RetentionTag
func (retentionTag *RetentionTag) AssignProperties_From_RetentionTag(source *v20230101s.RetentionTag) error {

	// TagName
	retentionTag.TagName = genruntime.ClonePointerToString(source.TagName)

	// No error
	return nil
}

// AssignProperties_To_RetentionTag populates the provided destination RetentionTag from our RetentionTag
func (retentionTag *RetentionTag) AssignProperties_To_RetentionTag(destination *v20230101s.RetentionTag) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// TagName
	destination.TagName = genruntime.ClonePointerToString(retentionTag.TagName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_RetentionTag_STATUS populates our RetentionTag from the provided source RetentionTag_STATUS
func (retentionTag *RetentionTag) Initialize_From_RetentionTag_STATUS(source *RetentionTag_STATUS) error {

	// TagName
	retentionTag.TagName = genruntime.ClonePointerToString(source.TagName)

	// No error
	return nil
}

// Retention tag
type RetentionTag_STATUS struct {
	// ETag: Retention Tag version.
	ETag *string `json:"eTag,omitempty"`

	// Id: Retention Tag version.
	Id *string `json:"id,omitempty"`

	// TagName: Retention Tag Name to relate it to retention rule.
	TagName *string `json:"tagName,omitempty"`
}

var _ genruntime.FromARMConverter = &RetentionTag_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (retentionTag *RetentionTag_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &RetentionTag_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (retentionTag *RetentionTag_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(RetentionTag_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected RetentionTag_STATUS_ARM, got %T", armInput)
	}

	// Set property "ETag":
	if typedInput.ETag != nil {
		eTag := *typedInput.ETag
		retentionTag.ETag = &eTag
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		retentionTag.Id = &id
	}

	// Set property "TagName":
	if typedInput.TagName != nil {
		tagName := *typedInput.TagName
		retentionTag.TagName = &tagName
	}

	// No error
	return nil
}

// AssignProperties_From_RetentionTag_STATUS populates our RetentionTag_STATUS from the provided source RetentionTag_STATUS
func (retentionTag *RetentionTag_STATUS) AssignProperties_From_RetentionTag_STATUS(source *v20230101s.RetentionTag_STATUS) error {

	// ETag
	retentionTag.ETag = genruntime.ClonePointerToString(source.ETag)

	// Id
	retentionTag.Id = genruntime.ClonePointerToString(source.Id)

	// TagName
	retentionTag.TagName = genruntime.ClonePointerToString(source.TagName)

	// No error
	return nil
}

// AssignProperties_To_RetentionTag_STATUS populates the provided destination RetentionTag_STATUS from our RetentionTag_STATUS
func (retentionTag *RetentionTag_STATUS) AssignProperties_To_RetentionTag_STATUS(destination *v20230101s.RetentionTag_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ETag
	destination.ETag = genruntime.ClonePointerToString(retentionTag.ETag)

	// Id
	destination.Id = genruntime.ClonePointerToString(retentionTag.Id)

	// TagName
	destination.TagName = genruntime.ClonePointerToString(retentionTag.TagName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ScheduleBasedBackupCriteria struct {
	// AbsoluteCriteria: it contains absolute values like "AllBackup" / "FirstOfDay" / "FirstOfWeek" / "FirstOfMonth"
	// and should be part of AbsoluteMarker enum
	AbsoluteCriteria []ScheduleBasedBackupCriteria_AbsoluteCriteria `json:"absoluteCriteria,omitempty"`

	// DaysOfMonth: This is day of the month from 1 to 28 other wise last of month
	DaysOfMonth []Day `json:"daysOfMonth,omitempty"`

	// DaysOfTheWeek: It should be Sunday/Monday/T..../Saturday
	DaysOfTheWeek []ScheduleBasedBackupCriteria_DaysOfTheWeek `json:"daysOfTheWeek,omitempty"`

	// MonthsOfYear: It should be January/February/....../December
	MonthsOfYear []ScheduleBasedBackupCriteria_MonthsOfYear `json:"monthsOfYear,omitempty"`

	// +kubebuilder:validation:Required
	// ObjectType: Type of the specific object - used for deserializing
	ObjectType *ScheduleBasedBackupCriteria_ObjectType `json:"objectType,omitempty"`

	// ScheduleTimes: List of schedule times for backup
	ScheduleTimes []string `json:"scheduleTimes,omitempty"`

	// WeeksOfTheMonth: It should be First/Second/Third/Fourth/Last
	WeeksOfTheMonth []ScheduleBasedBackupCriteria_WeeksOfTheMonth `json:"weeksOfTheMonth,omitempty"`
}

var _ genruntime.ARMTransformer = &ScheduleBasedBackupCriteria{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (criteria *ScheduleBasedBackupCriteria) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if criteria == nil {
		return nil, nil
	}
	result := &ScheduleBasedBackupCriteria_ARM{}

	// Set property "AbsoluteCriteria":
	for _, item := range criteria.AbsoluteCriteria {
		result.AbsoluteCriteria = append(result.AbsoluteCriteria, item)
	}

	// Set property "DaysOfMonth":
	for _, item := range criteria.DaysOfMonth {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.DaysOfMonth = append(result.DaysOfMonth, *item_ARM.(*Day_ARM))
	}

	// Set property "DaysOfTheWeek":
	for _, item := range criteria.DaysOfTheWeek {
		result.DaysOfTheWeek = append(result.DaysOfTheWeek, item)
	}

	// Set property "MonthsOfYear":
	for _, item := range criteria.MonthsOfYear {
		result.MonthsOfYear = append(result.MonthsOfYear, item)
	}

	// Set property "ObjectType":
	if criteria.ObjectType != nil {
		result.ObjectType = *criteria.ObjectType
	}

	// Set property "ScheduleTimes":
	for _, item := range criteria.ScheduleTimes {
		result.ScheduleTimes = append(result.ScheduleTimes, item)
	}

	// Set property "WeeksOfTheMonth":
	for _, item := range criteria.WeeksOfTheMonth {
		result.WeeksOfTheMonth = append(result.WeeksOfTheMonth, item)
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (criteria *ScheduleBasedBackupCriteria) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ScheduleBasedBackupCriteria_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (criteria *ScheduleBasedBackupCriteria) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ScheduleBasedBackupCriteria_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ScheduleBasedBackupCriteria_ARM, got %T", armInput)
	}

	// Set property "AbsoluteCriteria":
	for _, item := range typedInput.AbsoluteCriteria {
		criteria.AbsoluteCriteria = append(criteria.AbsoluteCriteria, item)
	}

	// Set property "DaysOfMonth":
	for _, item := range typedInput.DaysOfMonth {
		var item1 Day
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		criteria.DaysOfMonth = append(criteria.DaysOfMonth, item1)
	}

	// Set property "DaysOfTheWeek":
	for _, item := range typedInput.DaysOfTheWeek {
		criteria.DaysOfTheWeek = append(criteria.DaysOfTheWeek, item)
	}

	// Set property "MonthsOfYear":
	for _, item := range typedInput.MonthsOfYear {
		criteria.MonthsOfYear = append(criteria.MonthsOfYear, item)
	}

	// Set property "ObjectType":
	criteria.ObjectType = &typedInput.ObjectType

	// Set property "ScheduleTimes":
	for _, item := range typedInput.ScheduleTimes {
		criteria.ScheduleTimes = append(criteria.ScheduleTimes, item)
	}

	// Set property "WeeksOfTheMonth":
	for _, item := range typedInput.WeeksOfTheMonth {
		criteria.WeeksOfTheMonth = append(criteria.WeeksOfTheMonth, item)
	}

	// No error
	return nil
}

// AssignProperties_From_ScheduleBasedBackupCriteria populates our ScheduleBasedBackupCriteria from the provided source ScheduleBasedBackupCriteria
func (criteria *ScheduleBasedBackupCriteria) AssignProperties_From_ScheduleBasedBackupCriteria(source *v20230101s.ScheduleBasedBackupCriteria) error {

	// AbsoluteCriteria
	if source.AbsoluteCriteria != nil {
		absoluteCriterionList := make([]ScheduleBasedBackupCriteria_AbsoluteCriteria, len(source.AbsoluteCriteria))
		for absoluteCriterionIndex, absoluteCriterionItem := range source.AbsoluteCriteria {
			// Shadow the loop variable to avoid aliasing
			absoluteCriterionItem := absoluteCriterionItem
			absoluteCriterionList[absoluteCriterionIndex] = ScheduleBasedBackupCriteria_AbsoluteCriteria(absoluteCriterionItem)
		}
		criteria.AbsoluteCriteria = absoluteCriterionList
	} else {
		criteria.AbsoluteCriteria = nil
	}

	// DaysOfMonth
	if source.DaysOfMonth != nil {
		daysOfMonthList := make([]Day, len(source.DaysOfMonth))
		for daysOfMonthIndex, daysOfMonthItem := range source.DaysOfMonth {
			// Shadow the loop variable to avoid aliasing
			daysOfMonthItem := daysOfMonthItem
			var daysOfMonth Day
			err := daysOfMonth.AssignProperties_From_Day(&daysOfMonthItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_Day() to populate field DaysOfMonth")
			}
			daysOfMonthList[daysOfMonthIndex] = daysOfMonth
		}
		criteria.DaysOfMonth = daysOfMonthList
	} else {
		criteria.DaysOfMonth = nil
	}

	// DaysOfTheWeek
	if source.DaysOfTheWeek != nil {
		daysOfTheWeekList := make([]ScheduleBasedBackupCriteria_DaysOfTheWeek, len(source.DaysOfTheWeek))
		for daysOfTheWeekIndex, daysOfTheWeekItem := range source.DaysOfTheWeek {
			// Shadow the loop variable to avoid aliasing
			daysOfTheWeekItem := daysOfTheWeekItem
			daysOfTheWeekList[daysOfTheWeekIndex] = ScheduleBasedBackupCriteria_DaysOfTheWeek(daysOfTheWeekItem)
		}
		criteria.DaysOfTheWeek = daysOfTheWeekList
	} else {
		criteria.DaysOfTheWeek = nil
	}

	// MonthsOfYear
	if source.MonthsOfYear != nil {
		monthsOfYearList := make([]ScheduleBasedBackupCriteria_MonthsOfYear, len(source.MonthsOfYear))
		for monthsOfYearIndex, monthsOfYearItem := range source.MonthsOfYear {
			// Shadow the loop variable to avoid aliasing
			monthsOfYearItem := monthsOfYearItem
			monthsOfYearList[monthsOfYearIndex] = ScheduleBasedBackupCriteria_MonthsOfYear(monthsOfYearItem)
		}
		criteria.MonthsOfYear = monthsOfYearList
	} else {
		criteria.MonthsOfYear = nil
	}

	// ObjectType
	if source.ObjectType != nil {
		objectType := ScheduleBasedBackupCriteria_ObjectType(*source.ObjectType)
		criteria.ObjectType = &objectType
	} else {
		criteria.ObjectType = nil
	}

	// ScheduleTimes
	criteria.ScheduleTimes = genruntime.CloneSliceOfString(source.ScheduleTimes)

	// WeeksOfTheMonth
	if source.WeeksOfTheMonth != nil {
		weeksOfTheMonthList := make([]ScheduleBasedBackupCriteria_WeeksOfTheMonth, len(source.WeeksOfTheMonth))
		for weeksOfTheMonthIndex, weeksOfTheMonthItem := range source.WeeksOfTheMonth {
			// Shadow the loop variable to avoid aliasing
			weeksOfTheMonthItem := weeksOfTheMonthItem
			weeksOfTheMonthList[weeksOfTheMonthIndex] = ScheduleBasedBackupCriteria_WeeksOfTheMonth(weeksOfTheMonthItem)
		}
		criteria.WeeksOfTheMonth = weeksOfTheMonthList
	} else {
		criteria.WeeksOfTheMonth = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ScheduleBasedBackupCriteria populates the provided destination ScheduleBasedBackupCriteria from our ScheduleBasedBackupCriteria
func (criteria *ScheduleBasedBackupCriteria) AssignProperties_To_ScheduleBasedBackupCriteria(destination *v20230101s.ScheduleBasedBackupCriteria) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AbsoluteCriteria
	if criteria.AbsoluteCriteria != nil {
		absoluteCriterionList := make([]string, len(criteria.AbsoluteCriteria))
		for absoluteCriterionIndex, absoluteCriterionItem := range criteria.AbsoluteCriteria {
			// Shadow the loop variable to avoid aliasing
			absoluteCriterionItem := absoluteCriterionItem
			absoluteCriterionList[absoluteCriterionIndex] = string(absoluteCriterionItem)
		}
		destination.AbsoluteCriteria = absoluteCriterionList
	} else {
		destination.AbsoluteCriteria = nil
	}

	// DaysOfMonth
	if criteria.DaysOfMonth != nil {
		daysOfMonthList := make([]v20230101s.Day, len(criteria.DaysOfMonth))
		for daysOfMonthIndex, daysOfMonthItem := range criteria.DaysOfMonth {
			// Shadow the loop variable to avoid aliasing
			daysOfMonthItem := daysOfMonthItem
			var daysOfMonth v20230101s.Day
			err := daysOfMonthItem.AssignProperties_To_Day(&daysOfMonth)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_Day() to populate field DaysOfMonth")
			}
			daysOfMonthList[daysOfMonthIndex] = daysOfMonth
		}
		destination.DaysOfMonth = daysOfMonthList
	} else {
		destination.DaysOfMonth = nil
	}

	// DaysOfTheWeek
	if criteria.DaysOfTheWeek != nil {
		daysOfTheWeekList := make([]string, len(criteria.DaysOfTheWeek))
		for daysOfTheWeekIndex, daysOfTheWeekItem := range criteria.DaysOfTheWeek {
			// Shadow the loop variable to avoid aliasing
			daysOfTheWeekItem := daysOfTheWeekItem
			daysOfTheWeekList[daysOfTheWeekIndex] = string(daysOfTheWeekItem)
		}
		destination.DaysOfTheWeek = daysOfTheWeekList
	} else {
		destination.DaysOfTheWeek = nil
	}

	// MonthsOfYear
	if criteria.MonthsOfYear != nil {
		monthsOfYearList := make([]string, len(criteria.MonthsOfYear))
		for monthsOfYearIndex, monthsOfYearItem := range criteria.MonthsOfYear {
			// Shadow the loop variable to avoid aliasing
			monthsOfYearItem := monthsOfYearItem
			monthsOfYearList[monthsOfYearIndex] = string(monthsOfYearItem)
		}
		destination.MonthsOfYear = monthsOfYearList
	} else {
		destination.MonthsOfYear = nil
	}

	// ObjectType
	if criteria.ObjectType != nil {
		objectType := string(*criteria.ObjectType)
		destination.ObjectType = &objectType
	} else {
		destination.ObjectType = nil
	}

	// ScheduleTimes
	destination.ScheduleTimes = genruntime.CloneSliceOfString(criteria.ScheduleTimes)

	// WeeksOfTheMonth
	if criteria.WeeksOfTheMonth != nil {
		weeksOfTheMonthList := make([]string, len(criteria.WeeksOfTheMonth))
		for weeksOfTheMonthIndex, weeksOfTheMonthItem := range criteria.WeeksOfTheMonth {
			// Shadow the loop variable to avoid aliasing
			weeksOfTheMonthItem := weeksOfTheMonthItem
			weeksOfTheMonthList[weeksOfTheMonthIndex] = string(weeksOfTheMonthItem)
		}
		destination.WeeksOfTheMonth = weeksOfTheMonthList
	} else {
		destination.WeeksOfTheMonth = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ScheduleBasedBackupCriteria_STATUS populates our ScheduleBasedBackupCriteria from the provided source ScheduleBasedBackupCriteria_STATUS
func (criteria *ScheduleBasedBackupCriteria) Initialize_From_ScheduleBasedBackupCriteria_STATUS(source *ScheduleBasedBackupCriteria_STATUS) error {

	// AbsoluteCriteria
	if source.AbsoluteCriteria != nil {
		absoluteCriterionList := make([]ScheduleBasedBackupCriteria_AbsoluteCriteria, len(source.AbsoluteCriteria))
		for absoluteCriterionIndex, absoluteCriterionItem := range source.AbsoluteCriteria {
			// Shadow the loop variable to avoid aliasing
			absoluteCriterionItem := absoluteCriterionItem
			absoluteCriterion := ScheduleBasedBackupCriteria_AbsoluteCriteria(absoluteCriterionItem)
			absoluteCriterionList[absoluteCriterionIndex] = absoluteCriterion
		}
		criteria.AbsoluteCriteria = absoluteCriterionList
	} else {
		criteria.AbsoluteCriteria = nil
	}

	// DaysOfMonth
	if source.DaysOfMonth != nil {
		daysOfMonthList := make([]Day, len(source.DaysOfMonth))
		for daysOfMonthIndex, daysOfMonthItem := range source.DaysOfMonth {
			// Shadow the loop variable to avoid aliasing
			daysOfMonthItem := daysOfMonthItem
			var daysOfMonth Day
			err := daysOfMonth.Initialize_From_Day_STATUS(&daysOfMonthItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_Day_STATUS() to populate field DaysOfMonth")
			}
			daysOfMonthList[daysOfMonthIndex] = daysOfMonth
		}
		criteria.DaysOfMonth = daysOfMonthList
	} else {
		criteria.DaysOfMonth = nil
	}

	// DaysOfTheWeek
	if source.DaysOfTheWeek != nil {
		daysOfTheWeekList := make([]ScheduleBasedBackupCriteria_DaysOfTheWeek, len(source.DaysOfTheWeek))
		for daysOfTheWeekIndex, daysOfTheWeekItem := range source.DaysOfTheWeek {
			// Shadow the loop variable to avoid aliasing
			daysOfTheWeekItem := daysOfTheWeekItem
			daysOfTheWeek := ScheduleBasedBackupCriteria_DaysOfTheWeek(daysOfTheWeekItem)
			daysOfTheWeekList[daysOfTheWeekIndex] = daysOfTheWeek
		}
		criteria.DaysOfTheWeek = daysOfTheWeekList
	} else {
		criteria.DaysOfTheWeek = nil
	}

	// MonthsOfYear
	if source.MonthsOfYear != nil {
		monthsOfYearList := make([]ScheduleBasedBackupCriteria_MonthsOfYear, len(source.MonthsOfYear))
		for monthsOfYearIndex, monthsOfYearItem := range source.MonthsOfYear {
			// Shadow the loop variable to avoid aliasing
			monthsOfYearItem := monthsOfYearItem
			monthsOfYear := ScheduleBasedBackupCriteria_MonthsOfYear(monthsOfYearItem)
			monthsOfYearList[monthsOfYearIndex] = monthsOfYear
		}
		criteria.MonthsOfYear = monthsOfYearList
	} else {
		criteria.MonthsOfYear = nil
	}

	// ObjectType
	if source.ObjectType != nil {
		objectType := ScheduleBasedBackupCriteria_ObjectType(*source.ObjectType)
		criteria.ObjectType = &objectType
	} else {
		criteria.ObjectType = nil
	}

	// ScheduleTimes
	criteria.ScheduleTimes = genruntime.CloneSliceOfString(source.ScheduleTimes)

	// WeeksOfTheMonth
	if source.WeeksOfTheMonth != nil {
		weeksOfTheMonthList := make([]ScheduleBasedBackupCriteria_WeeksOfTheMonth, len(source.WeeksOfTheMonth))
		for weeksOfTheMonthIndex, weeksOfTheMonthItem := range source.WeeksOfTheMonth {
			// Shadow the loop variable to avoid aliasing
			weeksOfTheMonthItem := weeksOfTheMonthItem
			weeksOfTheMonth := ScheduleBasedBackupCriteria_WeeksOfTheMonth(weeksOfTheMonthItem)
			weeksOfTheMonthList[weeksOfTheMonthIndex] = weeksOfTheMonth
		}
		criteria.WeeksOfTheMonth = weeksOfTheMonthList
	} else {
		criteria.WeeksOfTheMonth = nil
	}

	// No error
	return nil
}

type ScheduleBasedBackupCriteria_STATUS struct {
	// AbsoluteCriteria: it contains absolute values like "AllBackup" / "FirstOfDay" / "FirstOfWeek" / "FirstOfMonth"
	// and should be part of AbsoluteMarker enum
	AbsoluteCriteria []ScheduleBasedBackupCriteria_AbsoluteCriteria_STATUS `json:"absoluteCriteria,omitempty"`

	// DaysOfMonth: This is day of the month from 1 to 28 other wise last of month
	DaysOfMonth []Day_STATUS `json:"daysOfMonth,omitempty"`

	// DaysOfTheWeek: It should be Sunday/Monday/T..../Saturday
	DaysOfTheWeek []ScheduleBasedBackupCriteria_DaysOfTheWeek_STATUS `json:"daysOfTheWeek,omitempty"`

	// MonthsOfYear: It should be January/February/....../December
	MonthsOfYear []ScheduleBasedBackupCriteria_MonthsOfYear_STATUS `json:"monthsOfYear,omitempty"`

	// ObjectType: Type of the specific object - used for deserializing
	ObjectType *ScheduleBasedBackupCriteria_ObjectType_STATUS `json:"objectType,omitempty"`

	// ScheduleTimes: List of schedule times for backup
	ScheduleTimes []string `json:"scheduleTimes,omitempty"`

	// WeeksOfTheMonth: It should be First/Second/Third/Fourth/Last
	WeeksOfTheMonth []ScheduleBasedBackupCriteria_WeeksOfTheMonth_STATUS `json:"weeksOfTheMonth,omitempty"`
}

var _ genruntime.FromARMConverter = &ScheduleBasedBackupCriteria_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (criteria *ScheduleBasedBackupCriteria_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ScheduleBasedBackupCriteria_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (criteria *ScheduleBasedBackupCriteria_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ScheduleBasedBackupCriteria_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ScheduleBasedBackupCriteria_STATUS_ARM, got %T", armInput)
	}

	// Set property "AbsoluteCriteria":
	for _, item := range typedInput.AbsoluteCriteria {
		criteria.AbsoluteCriteria = append(criteria.AbsoluteCriteria, item)
	}

	// Set property "DaysOfMonth":
	for _, item := range typedInput.DaysOfMonth {
		var item1 Day_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		criteria.DaysOfMonth = append(criteria.DaysOfMonth, item1)
	}

	// Set property "DaysOfTheWeek":
	for _, item := range typedInput.DaysOfTheWeek {
		criteria.DaysOfTheWeek = append(criteria.DaysOfTheWeek, item)
	}

	// Set property "MonthsOfYear":
	for _, item := range typedInput.MonthsOfYear {
		criteria.MonthsOfYear = append(criteria.MonthsOfYear, item)
	}

	// Set property "ObjectType":
	criteria.ObjectType = &typedInput.ObjectType

	// Set property "ScheduleTimes":
	for _, item := range typedInput.ScheduleTimes {
		criteria.ScheduleTimes = append(criteria.ScheduleTimes, item)
	}

	// Set property "WeeksOfTheMonth":
	for _, item := range typedInput.WeeksOfTheMonth {
		criteria.WeeksOfTheMonth = append(criteria.WeeksOfTheMonth, item)
	}

	// No error
	return nil
}

// AssignProperties_From_ScheduleBasedBackupCriteria_STATUS populates our ScheduleBasedBackupCriteria_STATUS from the provided source ScheduleBasedBackupCriteria_STATUS
func (criteria *ScheduleBasedBackupCriteria_STATUS) AssignProperties_From_ScheduleBasedBackupCriteria_STATUS(source *v20230101s.ScheduleBasedBackupCriteria_STATUS) error {

	// AbsoluteCriteria
	if source.AbsoluteCriteria != nil {
		absoluteCriterionList := make([]ScheduleBasedBackupCriteria_AbsoluteCriteria_STATUS, len(source.AbsoluteCriteria))
		for absoluteCriterionIndex, absoluteCriterionItem := range source.AbsoluteCriteria {
			// Shadow the loop variable to avoid aliasing
			absoluteCriterionItem := absoluteCriterionItem
			absoluteCriterionList[absoluteCriterionIndex] = ScheduleBasedBackupCriteria_AbsoluteCriteria_STATUS(absoluteCriterionItem)
		}
		criteria.AbsoluteCriteria = absoluteCriterionList
	} else {
		criteria.AbsoluteCriteria = nil
	}

	// DaysOfMonth
	if source.DaysOfMonth != nil {
		daysOfMonthList := make([]Day_STATUS, len(source.DaysOfMonth))
		for daysOfMonthIndex, daysOfMonthItem := range source.DaysOfMonth {
			// Shadow the loop variable to avoid aliasing
			daysOfMonthItem := daysOfMonthItem
			var daysOfMonth Day_STATUS
			err := daysOfMonth.AssignProperties_From_Day_STATUS(&daysOfMonthItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_Day_STATUS() to populate field DaysOfMonth")
			}
			daysOfMonthList[daysOfMonthIndex] = daysOfMonth
		}
		criteria.DaysOfMonth = daysOfMonthList
	} else {
		criteria.DaysOfMonth = nil
	}

	// DaysOfTheWeek
	if source.DaysOfTheWeek != nil {
		daysOfTheWeekList := make([]ScheduleBasedBackupCriteria_DaysOfTheWeek_STATUS, len(source.DaysOfTheWeek))
		for daysOfTheWeekIndex, daysOfTheWeekItem := range source.DaysOfTheWeek {
			// Shadow the loop variable to avoid aliasing
			daysOfTheWeekItem := daysOfTheWeekItem
			daysOfTheWeekList[daysOfTheWeekIndex] = ScheduleBasedBackupCriteria_DaysOfTheWeek_STATUS(daysOfTheWeekItem)
		}
		criteria.DaysOfTheWeek = daysOfTheWeekList
	} else {
		criteria.DaysOfTheWeek = nil
	}

	// MonthsOfYear
	if source.MonthsOfYear != nil {
		monthsOfYearList := make([]ScheduleBasedBackupCriteria_MonthsOfYear_STATUS, len(source.MonthsOfYear))
		for monthsOfYearIndex, monthsOfYearItem := range source.MonthsOfYear {
			// Shadow the loop variable to avoid aliasing
			monthsOfYearItem := monthsOfYearItem
			monthsOfYearList[monthsOfYearIndex] = ScheduleBasedBackupCriteria_MonthsOfYear_STATUS(monthsOfYearItem)
		}
		criteria.MonthsOfYear = monthsOfYearList
	} else {
		criteria.MonthsOfYear = nil
	}

	// ObjectType
	if source.ObjectType != nil {
		objectType := ScheduleBasedBackupCriteria_ObjectType_STATUS(*source.ObjectType)
		criteria.ObjectType = &objectType
	} else {
		criteria.ObjectType = nil
	}

	// ScheduleTimes
	criteria.ScheduleTimes = genruntime.CloneSliceOfString(source.ScheduleTimes)

	// WeeksOfTheMonth
	if source.WeeksOfTheMonth != nil {
		weeksOfTheMonthList := make([]ScheduleBasedBackupCriteria_WeeksOfTheMonth_STATUS, len(source.WeeksOfTheMonth))
		for weeksOfTheMonthIndex, weeksOfTheMonthItem := range source.WeeksOfTheMonth {
			// Shadow the loop variable to avoid aliasing
			weeksOfTheMonthItem := weeksOfTheMonthItem
			weeksOfTheMonthList[weeksOfTheMonthIndex] = ScheduleBasedBackupCriteria_WeeksOfTheMonth_STATUS(weeksOfTheMonthItem)
		}
		criteria.WeeksOfTheMonth = weeksOfTheMonthList
	} else {
		criteria.WeeksOfTheMonth = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ScheduleBasedBackupCriteria_STATUS populates the provided destination ScheduleBasedBackupCriteria_STATUS from our ScheduleBasedBackupCriteria_STATUS
func (criteria *ScheduleBasedBackupCriteria_STATUS) AssignProperties_To_ScheduleBasedBackupCriteria_STATUS(destination *v20230101s.ScheduleBasedBackupCriteria_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AbsoluteCriteria
	if criteria.AbsoluteCriteria != nil {
		absoluteCriterionList := make([]string, len(criteria.AbsoluteCriteria))
		for absoluteCriterionIndex, absoluteCriterionItem := range criteria.AbsoluteCriteria {
			// Shadow the loop variable to avoid aliasing
			absoluteCriterionItem := absoluteCriterionItem
			absoluteCriterionList[absoluteCriterionIndex] = string(absoluteCriterionItem)
		}
		destination.AbsoluteCriteria = absoluteCriterionList
	} else {
		destination.AbsoluteCriteria = nil
	}

	// DaysOfMonth
	if criteria.DaysOfMonth != nil {
		daysOfMonthList := make([]v20230101s.Day_STATUS, len(criteria.DaysOfMonth))
		for daysOfMonthIndex, daysOfMonthItem := range criteria.DaysOfMonth {
			// Shadow the loop variable to avoid aliasing
			daysOfMonthItem := daysOfMonthItem
			var daysOfMonth v20230101s.Day_STATUS
			err := daysOfMonthItem.AssignProperties_To_Day_STATUS(&daysOfMonth)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_Day_STATUS() to populate field DaysOfMonth")
			}
			daysOfMonthList[daysOfMonthIndex] = daysOfMonth
		}
		destination.DaysOfMonth = daysOfMonthList
	} else {
		destination.DaysOfMonth = nil
	}

	// DaysOfTheWeek
	if criteria.DaysOfTheWeek != nil {
		daysOfTheWeekList := make([]string, len(criteria.DaysOfTheWeek))
		for daysOfTheWeekIndex, daysOfTheWeekItem := range criteria.DaysOfTheWeek {
			// Shadow the loop variable to avoid aliasing
			daysOfTheWeekItem := daysOfTheWeekItem
			daysOfTheWeekList[daysOfTheWeekIndex] = string(daysOfTheWeekItem)
		}
		destination.DaysOfTheWeek = daysOfTheWeekList
	} else {
		destination.DaysOfTheWeek = nil
	}

	// MonthsOfYear
	if criteria.MonthsOfYear != nil {
		monthsOfYearList := make([]string, len(criteria.MonthsOfYear))
		for monthsOfYearIndex, monthsOfYearItem := range criteria.MonthsOfYear {
			// Shadow the loop variable to avoid aliasing
			monthsOfYearItem := monthsOfYearItem
			monthsOfYearList[monthsOfYearIndex] = string(monthsOfYearItem)
		}
		destination.MonthsOfYear = monthsOfYearList
	} else {
		destination.MonthsOfYear = nil
	}

	// ObjectType
	if criteria.ObjectType != nil {
		objectType := string(*criteria.ObjectType)
		destination.ObjectType = &objectType
	} else {
		destination.ObjectType = nil
	}

	// ScheduleTimes
	destination.ScheduleTimes = genruntime.CloneSliceOfString(criteria.ScheduleTimes)

	// WeeksOfTheMonth
	if criteria.WeeksOfTheMonth != nil {
		weeksOfTheMonthList := make([]string, len(criteria.WeeksOfTheMonth))
		for weeksOfTheMonthIndex, weeksOfTheMonthItem := range criteria.WeeksOfTheMonth {
			// Shadow the loop variable to avoid aliasing
			weeksOfTheMonthItem := weeksOfTheMonthItem
			weeksOfTheMonthList[weeksOfTheMonthIndex] = string(weeksOfTheMonthItem)
		}
		destination.WeeksOfTheMonth = weeksOfTheMonthList
	} else {
		destination.WeeksOfTheMonth = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Day of the week
type Day struct {
	// Date: Date of the month
	Date *int `json:"date,omitempty"`

	// IsLast: Whether Date is last date of month
	IsLast *bool `json:"isLast,omitempty"`
}

var _ genruntime.ARMTransformer = &Day{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (day *Day) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if day == nil {
		return nil, nil
	}
	result := &Day_ARM{}

	// Set property "Date":
	if day.Date != nil {
		date := *day.Date
		result.Date = &date
	}

	// Set property "IsLast":
	if day.IsLast != nil {
		isLast := *day.IsLast
		result.IsLast = &isLast
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (day *Day) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Day_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (day *Day) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Day_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Day_ARM, got %T", armInput)
	}

	// Set property "Date":
	if typedInput.Date != nil {
		date := *typedInput.Date
		day.Date = &date
	}

	// Set property "IsLast":
	if typedInput.IsLast != nil {
		isLast := *typedInput.IsLast
		day.IsLast = &isLast
	}

	// No error
	return nil
}

// AssignProperties_From_Day populates our Day from the provided source Day
func (day *Day) AssignProperties_From_Day(source *v20230101s.Day) error {

	// Date
	day.Date = genruntime.ClonePointerToInt(source.Date)

	// IsLast
	if source.IsLast != nil {
		isLast := *source.IsLast
		day.IsLast = &isLast
	} else {
		day.IsLast = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Day populates the provided destination Day from our Day
func (day *Day) AssignProperties_To_Day(destination *v20230101s.Day) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Date
	destination.Date = genruntime.ClonePointerToInt(day.Date)

	// IsLast
	if day.IsLast != nil {
		isLast := *day.IsLast
		destination.IsLast = &isLast
	} else {
		destination.IsLast = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_Day_STATUS populates our Day from the provided source Day_STATUS
func (day *Day) Initialize_From_Day_STATUS(source *Day_STATUS) error {

	// Date
	day.Date = genruntime.ClonePointerToInt(source.Date)

	// IsLast
	if source.IsLast != nil {
		isLast := *source.IsLast
		day.IsLast = &isLast
	} else {
		day.IsLast = nil
	}

	// No error
	return nil
}

// Day of the week
type Day_STATUS struct {
	// Date: Date of the month
	Date *int `json:"date,omitempty"`

	// IsLast: Whether Date is last date of month
	IsLast *bool `json:"isLast,omitempty"`
}

var _ genruntime.FromARMConverter = &Day_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (day *Day_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Day_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (day *Day_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Day_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Day_STATUS_ARM, got %T", armInput)
	}

	// Set property "Date":
	if typedInput.Date != nil {
		date := *typedInput.Date
		day.Date = &date
	}

	// Set property "IsLast":
	if typedInput.IsLast != nil {
		isLast := *typedInput.IsLast
		day.IsLast = &isLast
	}

	// No error
	return nil
}

// AssignProperties_From_Day_STATUS populates our Day_STATUS from the provided source Day_STATUS
func (day *Day_STATUS) AssignProperties_From_Day_STATUS(source *v20230101s.Day_STATUS) error {

	// Date
	day.Date = genruntime.ClonePointerToInt(source.Date)

	// IsLast
	if source.IsLast != nil {
		isLast := *source.IsLast
		day.IsLast = &isLast
	} else {
		day.IsLast = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Day_STATUS populates the provided destination Day_STATUS from our Day_STATUS
func (day *Day_STATUS) AssignProperties_To_Day_STATUS(destination *v20230101s.Day_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Date
	destination.Date = genruntime.ClonePointerToInt(day.Date)

	// IsLast
	if day.IsLast != nil {
		isLast := *day.IsLast
		destination.IsLast = &isLast
	} else {
		destination.IsLast = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

func init() {
	SchemeBuilder.Register(&BackupVaultsBackupPolicy{}, &BackupVaultsBackupPolicyList{})
}
