// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20230101

import (
	"fmt"
	arm "github.com/Azure/azure-service-operator/v2/api/dataprotection/v1api20230101/arm"
	storage "github.com/Azure/azure-service-operator/v2/api/dataprotection/v1api20230101/storage"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/configmaps"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/core"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/secrets"
	"github.com/rotisserie/eris"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
)

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Generator information:
// - Generated from: /dataprotection/resource-manager/Microsoft.DataProtection/stable/2023-01-01/dataprotection.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataProtection/backupVaults/{vaultName}/backupPolicies/{backupPolicyName}
type BackupVaultsBackupPolicy struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              BackupVaultsBackupPolicy_Spec   `json:"spec,omitempty"`
	Status            BackupVaultsBackupPolicy_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &BackupVaultsBackupPolicy{}

// GetConditions returns the conditions of the resource
func (policy *BackupVaultsBackupPolicy) GetConditions() conditions.Conditions {
	return policy.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (policy *BackupVaultsBackupPolicy) SetConditions(conditions conditions.Conditions) {
	policy.Status.Conditions = conditions
}

var _ conversion.Convertible = &BackupVaultsBackupPolicy{}

// ConvertFrom populates our BackupVaultsBackupPolicy from the provided hub BackupVaultsBackupPolicy
func (policy *BackupVaultsBackupPolicy) ConvertFrom(hub conversion.Hub) error {
	// intermediate variable for conversion
	var source storage.BackupVaultsBackupPolicy

	err := source.ConvertFrom(hub)
	if err != nil {
		return eris.Wrap(err, "converting from hub to source")
	}

	err = policy.AssignProperties_From_BackupVaultsBackupPolicy(&source)
	if err != nil {
		return eris.Wrap(err, "converting from source to policy")
	}

	return nil
}

// ConvertTo populates the provided hub BackupVaultsBackupPolicy from our BackupVaultsBackupPolicy
func (policy *BackupVaultsBackupPolicy) ConvertTo(hub conversion.Hub) error {
	// intermediate variable for conversion
	var destination storage.BackupVaultsBackupPolicy
	err := policy.AssignProperties_To_BackupVaultsBackupPolicy(&destination)
	if err != nil {
		return eris.Wrap(err, "converting to destination from policy")
	}
	err = destination.ConvertTo(hub)
	if err != nil {
		return eris.Wrap(err, "converting from destination to hub")
	}

	return nil
}

var _ configmaps.Exporter = &BackupVaultsBackupPolicy{}

// ConfigMapDestinationExpressions returns the Spec.OperatorSpec.ConfigMapExpressions property
func (policy *BackupVaultsBackupPolicy) ConfigMapDestinationExpressions() []*core.DestinationExpression {
	if policy.Spec.OperatorSpec == nil {
		return nil
	}
	return policy.Spec.OperatorSpec.ConfigMapExpressions
}

var _ secrets.Exporter = &BackupVaultsBackupPolicy{}

// SecretDestinationExpressions returns the Spec.OperatorSpec.SecretExpressions property
func (policy *BackupVaultsBackupPolicy) SecretDestinationExpressions() []*core.DestinationExpression {
	if policy.Spec.OperatorSpec == nil {
		return nil
	}
	return policy.Spec.OperatorSpec.SecretExpressions
}

var _ genruntime.KubernetesResource = &BackupVaultsBackupPolicy{}

// AzureName returns the Azure name of the resource
func (policy *BackupVaultsBackupPolicy) AzureName() string {
	return policy.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2023-01-01"
func (policy BackupVaultsBackupPolicy) GetAPIVersion() string {
	return "2023-01-01"
}

// GetResourceScope returns the scope of the resource
func (policy *BackupVaultsBackupPolicy) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (policy *BackupVaultsBackupPolicy) GetSpec() genruntime.ConvertibleSpec {
	return &policy.Spec
}

// GetStatus returns the status of this resource
func (policy *BackupVaultsBackupPolicy) GetStatus() genruntime.ConvertibleStatus {
	return &policy.Status
}

// GetSupportedOperations returns the operations supported by the resource
func (policy *BackupVaultsBackupPolicy) GetSupportedOperations() []genruntime.ResourceOperation {
	return []genruntime.ResourceOperation{
		genruntime.ResourceOperationDelete,
		genruntime.ResourceOperationGet,
		genruntime.ResourceOperationPut,
	}
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.DataProtection/backupVaults/backupPolicies"
func (policy *BackupVaultsBackupPolicy) GetType() string {
	return "Microsoft.DataProtection/backupVaults/backupPolicies"
}

// NewEmptyStatus returns a new empty (blank) status
func (policy *BackupVaultsBackupPolicy) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &BackupVaultsBackupPolicy_STATUS{}
}

// Owner returns the ResourceReference of the owner
func (policy *BackupVaultsBackupPolicy) Owner() *genruntime.ResourceReference {
	if policy.Spec.Owner == nil {
		return nil
	}

	group, kind := genruntime.LookupOwnerGroupKind(policy.Spec)
	return policy.Spec.Owner.AsResourceReference(group, kind)
}

// SetStatus sets the status of this resource
func (policy *BackupVaultsBackupPolicy) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*BackupVaultsBackupPolicy_STATUS); ok {
		policy.Status = *st
		return nil
	}

	// Convert status to required version
	var st BackupVaultsBackupPolicy_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return eris.Wrap(err, "failed to convert status")
	}

	policy.Status = st
	return nil
}

// AssignProperties_From_BackupVaultsBackupPolicy populates our BackupVaultsBackupPolicy from the provided source BackupVaultsBackupPolicy
func (policy *BackupVaultsBackupPolicy) AssignProperties_From_BackupVaultsBackupPolicy(source *storage.BackupVaultsBackupPolicy) error {

	// ObjectMeta
	policy.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec BackupVaultsBackupPolicy_Spec
	err := spec.AssignProperties_From_BackupVaultsBackupPolicy_Spec(&source.Spec)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_From_BackupVaultsBackupPolicy_Spec() to populate field Spec")
	}
	policy.Spec = spec

	// Status
	var status BackupVaultsBackupPolicy_STATUS
	err = status.AssignProperties_From_BackupVaultsBackupPolicy_STATUS(&source.Status)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_From_BackupVaultsBackupPolicy_STATUS() to populate field Status")
	}
	policy.Status = status

	// No error
	return nil
}

// AssignProperties_To_BackupVaultsBackupPolicy populates the provided destination BackupVaultsBackupPolicy from our BackupVaultsBackupPolicy
func (policy *BackupVaultsBackupPolicy) AssignProperties_To_BackupVaultsBackupPolicy(destination *storage.BackupVaultsBackupPolicy) error {

	// ObjectMeta
	destination.ObjectMeta = *policy.ObjectMeta.DeepCopy()

	// Spec
	var spec storage.BackupVaultsBackupPolicy_Spec
	err := policy.Spec.AssignProperties_To_BackupVaultsBackupPolicy_Spec(&spec)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_To_BackupVaultsBackupPolicy_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status storage.BackupVaultsBackupPolicy_STATUS
	err = policy.Status.AssignProperties_To_BackupVaultsBackupPolicy_STATUS(&status)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_To_BackupVaultsBackupPolicy_STATUS() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (policy *BackupVaultsBackupPolicy) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: policy.Spec.OriginalVersion(),
		Kind:    "BackupVaultsBackupPolicy",
	}
}

// +kubebuilder:object:root=true
// Generator information:
// - Generated from: /dataprotection/resource-manager/Microsoft.DataProtection/stable/2023-01-01/dataprotection.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataProtection/backupVaults/{vaultName}/backupPolicies/{backupPolicyName}
type BackupVaultsBackupPolicyList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []BackupVaultsBackupPolicy `json:"items"`
}

type BackupVaultsBackupPolicy_Spec struct {
	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName string `json:"azureName,omitempty"`

	// OperatorSpec: The specification for configuring operator behavior. This field is interpreted by the operator and not
	// passed directly to Azure
	OperatorSpec *BackupVaultsBackupPolicyOperatorSpec `json:"operatorSpec,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a dataprotection.azure.com/BackupVault resource
	Owner *genruntime.KnownResourceReference `group:"dataprotection.azure.com" json:"owner,omitempty" kind:"BackupVault"`

	// Properties: BaseBackupPolicyResource properties
	Properties *BaseBackupPolicy `json:"properties,omitempty"`
}

var _ genruntime.ARMTransformer = &BackupVaultsBackupPolicy_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (policy *BackupVaultsBackupPolicy_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if policy == nil {
		return nil, nil
	}
	result := &arm.BackupVaultsBackupPolicy_Spec{}

	// Set property "Name":
	result.Name = resolved.Name

	// Set property "Properties":
	if policy.Properties != nil {
		properties_ARM, err := (*policy.Properties).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		properties := *properties_ARM.(*arm.BaseBackupPolicy)
		result.Properties = &properties
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (policy *BackupVaultsBackupPolicy_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.BackupVaultsBackupPolicy_Spec{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (policy *BackupVaultsBackupPolicy_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.BackupVaultsBackupPolicy_Spec)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.BackupVaultsBackupPolicy_Spec, got %T", armInput)
	}

	// Set property "AzureName":
	policy.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// no assignment for property "OperatorSpec"

	// Set property "Owner":
	policy.Owner = &genruntime.KnownResourceReference{
		Name:  owner.Name,
		ARMID: owner.ARMID,
	}

	// Set property "Properties":
	if typedInput.Properties != nil {
		var properties1 BaseBackupPolicy
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		policy.Properties = &properties
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &BackupVaultsBackupPolicy_Spec{}

// ConvertSpecFrom populates our BackupVaultsBackupPolicy_Spec from the provided source
func (policy *BackupVaultsBackupPolicy_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*storage.BackupVaultsBackupPolicy_Spec)
	if ok {
		// Populate our instance from source
		return policy.AssignProperties_From_BackupVaultsBackupPolicy_Spec(src)
	}

	// Convert to an intermediate form
	src = &storage.BackupVaultsBackupPolicy_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = policy.AssignProperties_From_BackupVaultsBackupPolicy_Spec(src)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our BackupVaultsBackupPolicy_Spec
func (policy *BackupVaultsBackupPolicy_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*storage.BackupVaultsBackupPolicy_Spec)
	if ok {
		// Populate destination from our instance
		return policy.AssignProperties_To_BackupVaultsBackupPolicy_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &storage.BackupVaultsBackupPolicy_Spec{}
	err := policy.AssignProperties_To_BackupVaultsBackupPolicy_Spec(dst)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignProperties_From_BackupVaultsBackupPolicy_Spec populates our BackupVaultsBackupPolicy_Spec from the provided source BackupVaultsBackupPolicy_Spec
func (policy *BackupVaultsBackupPolicy_Spec) AssignProperties_From_BackupVaultsBackupPolicy_Spec(source *storage.BackupVaultsBackupPolicy_Spec) error {

	// AzureName
	policy.AzureName = source.AzureName

	// OperatorSpec
	if source.OperatorSpec != nil {
		var operatorSpec BackupVaultsBackupPolicyOperatorSpec
		err := operatorSpec.AssignProperties_From_BackupVaultsBackupPolicyOperatorSpec(source.OperatorSpec)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_BackupVaultsBackupPolicyOperatorSpec() to populate field OperatorSpec")
		}
		policy.OperatorSpec = &operatorSpec
	} else {
		policy.OperatorSpec = nil
	}

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		policy.Owner = &owner
	} else {
		policy.Owner = nil
	}

	// Properties
	if source.Properties != nil {
		var property BaseBackupPolicy
		err := property.AssignProperties_From_BaseBackupPolicy(source.Properties)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_BaseBackupPolicy() to populate field Properties")
		}
		policy.Properties = &property
	} else {
		policy.Properties = nil
	}

	// No error
	return nil
}

// AssignProperties_To_BackupVaultsBackupPolicy_Spec populates the provided destination BackupVaultsBackupPolicy_Spec from our BackupVaultsBackupPolicy_Spec
func (policy *BackupVaultsBackupPolicy_Spec) AssignProperties_To_BackupVaultsBackupPolicy_Spec(destination *storage.BackupVaultsBackupPolicy_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureName
	destination.AzureName = policy.AzureName

	// OperatorSpec
	if policy.OperatorSpec != nil {
		var operatorSpec storage.BackupVaultsBackupPolicyOperatorSpec
		err := policy.OperatorSpec.AssignProperties_To_BackupVaultsBackupPolicyOperatorSpec(&operatorSpec)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_BackupVaultsBackupPolicyOperatorSpec() to populate field OperatorSpec")
		}
		destination.OperatorSpec = &operatorSpec
	} else {
		destination.OperatorSpec = nil
	}

	// OriginalVersion
	destination.OriginalVersion = policy.OriginalVersion()

	// Owner
	if policy.Owner != nil {
		owner := policy.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// Properties
	if policy.Properties != nil {
		var property storage.BaseBackupPolicy
		err := policy.Properties.AssignProperties_To_BaseBackupPolicy(&property)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_BaseBackupPolicy() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (policy *BackupVaultsBackupPolicy_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (policy *BackupVaultsBackupPolicy_Spec) SetAzureName(azureName string) {
	policy.AzureName = azureName
}

type BackupVaultsBackupPolicy_STATUS struct {
	// Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	// Id: Resource Id represents the complete path to the resource.
	Id *string `json:"id,omitempty"`

	// Name: Resource name associated with the resource.
	Name *string `json:"name,omitempty"`

	// Properties: BaseBackupPolicyResource properties
	Properties *BaseBackupPolicy_STATUS `json:"properties,omitempty"`

	// SystemData: Metadata pertaining to creation and last modification of the resource.
	SystemData *SystemData_STATUS `json:"systemData,omitempty"`

	// Type: Resource type represents the complete path of the form Namespace/ResourceType/ResourceType/...
	Type *string `json:"type,omitempty"`
}

var _ genruntime.ConvertibleStatus = &BackupVaultsBackupPolicy_STATUS{}

// ConvertStatusFrom populates our BackupVaultsBackupPolicy_STATUS from the provided source
func (policy *BackupVaultsBackupPolicy_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*storage.BackupVaultsBackupPolicy_STATUS)
	if ok {
		// Populate our instance from source
		return policy.AssignProperties_From_BackupVaultsBackupPolicy_STATUS(src)
	}

	// Convert to an intermediate form
	src = &storage.BackupVaultsBackupPolicy_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = policy.AssignProperties_From_BackupVaultsBackupPolicy_STATUS(src)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our BackupVaultsBackupPolicy_STATUS
func (policy *BackupVaultsBackupPolicy_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*storage.BackupVaultsBackupPolicy_STATUS)
	if ok {
		// Populate destination from our instance
		return policy.AssignProperties_To_BackupVaultsBackupPolicy_STATUS(dst)
	}

	// Convert to an intermediate form
	dst = &storage.BackupVaultsBackupPolicy_STATUS{}
	err := policy.AssignProperties_To_BackupVaultsBackupPolicy_STATUS(dst)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &BackupVaultsBackupPolicy_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (policy *BackupVaultsBackupPolicy_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.BackupVaultsBackupPolicy_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (policy *BackupVaultsBackupPolicy_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.BackupVaultsBackupPolicy_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.BackupVaultsBackupPolicy_STATUS, got %T", armInput)
	}

	// no assignment for property "Conditions"

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		policy.Id = &id
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		policy.Name = &name
	}

	// Set property "Properties":
	if typedInput.Properties != nil {
		var properties1 BaseBackupPolicy_STATUS
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		policy.Properties = &properties
	}

	// Set property "SystemData":
	if typedInput.SystemData != nil {
		var systemData1 SystemData_STATUS
		err := systemData1.PopulateFromARM(owner, *typedInput.SystemData)
		if err != nil {
			return err
		}
		systemData := systemData1
		policy.SystemData = &systemData
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		policy.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_BackupVaultsBackupPolicy_STATUS populates our BackupVaultsBackupPolicy_STATUS from the provided source BackupVaultsBackupPolicy_STATUS
func (policy *BackupVaultsBackupPolicy_STATUS) AssignProperties_From_BackupVaultsBackupPolicy_STATUS(source *storage.BackupVaultsBackupPolicy_STATUS) error {

	// Conditions
	policy.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// Id
	policy.Id = genruntime.ClonePointerToString(source.Id)

	// Name
	policy.Name = genruntime.ClonePointerToString(source.Name)

	// Properties
	if source.Properties != nil {
		var property BaseBackupPolicy_STATUS
		err := property.AssignProperties_From_BaseBackupPolicy_STATUS(source.Properties)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_BaseBackupPolicy_STATUS() to populate field Properties")
		}
		policy.Properties = &property
	} else {
		policy.Properties = nil
	}

	// SystemData
	if source.SystemData != nil {
		var systemDatum SystemData_STATUS
		err := systemDatum.AssignProperties_From_SystemData_STATUS(source.SystemData)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_SystemData_STATUS() to populate field SystemData")
		}
		policy.SystemData = &systemDatum
	} else {
		policy.SystemData = nil
	}

	// Type
	policy.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignProperties_To_BackupVaultsBackupPolicy_STATUS populates the provided destination BackupVaultsBackupPolicy_STATUS from our BackupVaultsBackupPolicy_STATUS
func (policy *BackupVaultsBackupPolicy_STATUS) AssignProperties_To_BackupVaultsBackupPolicy_STATUS(destination *storage.BackupVaultsBackupPolicy_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(policy.Conditions)

	// Id
	destination.Id = genruntime.ClonePointerToString(policy.Id)

	// Name
	destination.Name = genruntime.ClonePointerToString(policy.Name)

	// Properties
	if policy.Properties != nil {
		var property storage.BaseBackupPolicy_STATUS
		err := policy.Properties.AssignProperties_To_BaseBackupPolicy_STATUS(&property)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_BaseBackupPolicy_STATUS() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// SystemData
	if policy.SystemData != nil {
		var systemDatum storage.SystemData_STATUS
		err := policy.SystemData.AssignProperties_To_SystemData_STATUS(&systemDatum)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_SystemData_STATUS() to populate field SystemData")
		}
		destination.SystemData = &systemDatum
	} else {
		destination.SystemData = nil
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(policy.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Details for configuring operator behavior. Fields in this struct are interpreted by the operator directly rather than being passed to Azure
type BackupVaultsBackupPolicyOperatorSpec struct {
	// ConfigMapExpressions: configures where to place operator written dynamic ConfigMaps (created with CEL expressions).
	ConfigMapExpressions []*core.DestinationExpression `json:"configMapExpressions,omitempty"`

	// SecretExpressions: configures where to place operator written dynamic secrets (created with CEL expressions).
	SecretExpressions []*core.DestinationExpression `json:"secretExpressions,omitempty"`
}

// AssignProperties_From_BackupVaultsBackupPolicyOperatorSpec populates our BackupVaultsBackupPolicyOperatorSpec from the provided source BackupVaultsBackupPolicyOperatorSpec
func (operator *BackupVaultsBackupPolicyOperatorSpec) AssignProperties_From_BackupVaultsBackupPolicyOperatorSpec(source *storage.BackupVaultsBackupPolicyOperatorSpec) error {

	// ConfigMapExpressions
	if source.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(source.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range source.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		operator.ConfigMapExpressions = configMapExpressionList
	} else {
		operator.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if source.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(source.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range source.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		operator.SecretExpressions = secretExpressionList
	} else {
		operator.SecretExpressions = nil
	}

	// No error
	return nil
}

// AssignProperties_To_BackupVaultsBackupPolicyOperatorSpec populates the provided destination BackupVaultsBackupPolicyOperatorSpec from our BackupVaultsBackupPolicyOperatorSpec
func (operator *BackupVaultsBackupPolicyOperatorSpec) AssignProperties_To_BackupVaultsBackupPolicyOperatorSpec(destination *storage.BackupVaultsBackupPolicyOperatorSpec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ConfigMapExpressions
	if operator.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(operator.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range operator.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		destination.ConfigMapExpressions = configMapExpressionList
	} else {
		destination.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if operator.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(operator.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range operator.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		destination.SecretExpressions = secretExpressionList
	} else {
		destination.SecretExpressions = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type BaseBackupPolicy struct {
	// BackupPolicy: Mutually exclusive with all other properties
	BackupPolicy *BackupPolicy `json:"backupPolicy,omitempty"`
}

var _ genruntime.ARMTransformer = &BaseBackupPolicy{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (policy *BaseBackupPolicy) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if policy == nil {
		return nil, nil
	}
	result := &arm.BaseBackupPolicy{}

	// Set property "BackupPolicy":
	if policy.BackupPolicy != nil {
		backupPolicy_ARM, err := (*policy.BackupPolicy).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		backupPolicy := *backupPolicy_ARM.(*arm.BackupPolicy)
		result.BackupPolicy = &backupPolicy
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (policy *BaseBackupPolicy) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.BaseBackupPolicy{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (policy *BaseBackupPolicy) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.BaseBackupPolicy)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.BaseBackupPolicy, got %T", armInput)
	}

	// Set property "BackupPolicy":
	if typedInput.BackupPolicy != nil {
		var backupPolicy1 BackupPolicy
		err := backupPolicy1.PopulateFromARM(owner, *typedInput.BackupPolicy)
		if err != nil {
			return err
		}
		backupPolicy := backupPolicy1
		policy.BackupPolicy = &backupPolicy
	}

	// No error
	return nil
}

// AssignProperties_From_BaseBackupPolicy populates our BaseBackupPolicy from the provided source BaseBackupPolicy
func (policy *BaseBackupPolicy) AssignProperties_From_BaseBackupPolicy(source *storage.BaseBackupPolicy) error {

	// BackupPolicy
	if source.BackupPolicy != nil {
		var backupPolicy BackupPolicy
		err := backupPolicy.AssignProperties_From_BackupPolicy(source.BackupPolicy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_BackupPolicy() to populate field BackupPolicy")
		}
		policy.BackupPolicy = &backupPolicy
	} else {
		policy.BackupPolicy = nil
	}

	// No error
	return nil
}

// AssignProperties_To_BaseBackupPolicy populates the provided destination BaseBackupPolicy from our BaseBackupPolicy
func (policy *BaseBackupPolicy) AssignProperties_To_BaseBackupPolicy(destination *storage.BaseBackupPolicy) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BackupPolicy
	if policy.BackupPolicy != nil {
		var backupPolicy storage.BackupPolicy
		err := policy.BackupPolicy.AssignProperties_To_BackupPolicy(&backupPolicy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_BackupPolicy() to populate field BackupPolicy")
		}
		destination.BackupPolicy = &backupPolicy
	} else {
		destination.BackupPolicy = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type BaseBackupPolicy_STATUS struct {
	// BackupPolicy: Mutually exclusive with all other properties
	BackupPolicy *BackupPolicy_STATUS `json:"backupPolicy,omitempty"`
}

var _ genruntime.FromARMConverter = &BaseBackupPolicy_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (policy *BaseBackupPolicy_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.BaseBackupPolicy_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (policy *BaseBackupPolicy_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.BaseBackupPolicy_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.BaseBackupPolicy_STATUS, got %T", armInput)
	}

	// Set property "BackupPolicy":
	if typedInput.BackupPolicy != nil {
		var backupPolicy1 BackupPolicy_STATUS
		err := backupPolicy1.PopulateFromARM(owner, *typedInput.BackupPolicy)
		if err != nil {
			return err
		}
		backupPolicy := backupPolicy1
		policy.BackupPolicy = &backupPolicy
	}

	// No error
	return nil
}

// AssignProperties_From_BaseBackupPolicy_STATUS populates our BaseBackupPolicy_STATUS from the provided source BaseBackupPolicy_STATUS
func (policy *BaseBackupPolicy_STATUS) AssignProperties_From_BaseBackupPolicy_STATUS(source *storage.BaseBackupPolicy_STATUS) error {

	// BackupPolicy
	if source.BackupPolicy != nil {
		var backupPolicy BackupPolicy_STATUS
		err := backupPolicy.AssignProperties_From_BackupPolicy_STATUS(source.BackupPolicy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_BackupPolicy_STATUS() to populate field BackupPolicy")
		}
		policy.BackupPolicy = &backupPolicy
	} else {
		policy.BackupPolicy = nil
	}

	// No error
	return nil
}

// AssignProperties_To_BaseBackupPolicy_STATUS populates the provided destination BaseBackupPolicy_STATUS from our BaseBackupPolicy_STATUS
func (policy *BaseBackupPolicy_STATUS) AssignProperties_To_BaseBackupPolicy_STATUS(destination *storage.BaseBackupPolicy_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BackupPolicy
	if policy.BackupPolicy != nil {
		var backupPolicy storage.BackupPolicy_STATUS
		err := policy.BackupPolicy.AssignProperties_To_BackupPolicy_STATUS(&backupPolicy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_BackupPolicy_STATUS() to populate field BackupPolicy")
		}
		destination.BackupPolicy = &backupPolicy
	} else {
		destination.BackupPolicy = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type BackupPolicy struct {
	// +kubebuilder:validation:Required
	// DatasourceTypes: Type of datasource for the backup management
	DatasourceTypes []string `json:"datasourceTypes,omitempty"`

	// +kubebuilder:validation:Required
	ObjectType *BackupPolicy_ObjectType `json:"objectType,omitempty"`

	// +kubebuilder:validation:Required
	// PolicyRules: Policy rule dictionary that contains rules for each backuptype i.e Full/Incremental/Logs etc
	PolicyRules []BasePolicyRule `json:"policyRules,omitempty"`
}

var _ genruntime.ARMTransformer = &BackupPolicy{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (policy *BackupPolicy) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if policy == nil {
		return nil, nil
	}
	result := &arm.BackupPolicy{}

	// Set property "DatasourceTypes":
	for _, item := range policy.DatasourceTypes {
		result.DatasourceTypes = append(result.DatasourceTypes, item)
	}

	// Set property "ObjectType":
	if policy.ObjectType != nil {
		var temp arm.BackupPolicy_ObjectType
		var temp1 string
		temp1 = string(*policy.ObjectType)
		temp = arm.BackupPolicy_ObjectType(temp1)
		result.ObjectType = temp
	}

	// Set property "PolicyRules":
	for _, item := range policy.PolicyRules {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.PolicyRules = append(result.PolicyRules, *item_ARM.(*arm.BasePolicyRule))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (policy *BackupPolicy) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.BackupPolicy{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (policy *BackupPolicy) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.BackupPolicy)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.BackupPolicy, got %T", armInput)
	}

	// Set property "DatasourceTypes":
	for _, item := range typedInput.DatasourceTypes {
		policy.DatasourceTypes = append(policy.DatasourceTypes, item)
	}

	// Set property "ObjectType":
	var temp BackupPolicy_ObjectType
	var temp1 string
	temp1 = string(typedInput.ObjectType)
	temp = BackupPolicy_ObjectType(temp1)
	policy.ObjectType = &temp

	// Set property "PolicyRules":
	for _, item := range typedInput.PolicyRules {
		var item1 BasePolicyRule
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		policy.PolicyRules = append(policy.PolicyRules, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_BackupPolicy populates our BackupPolicy from the provided source BackupPolicy
func (policy *BackupPolicy) AssignProperties_From_BackupPolicy(source *storage.BackupPolicy) error {

	// DatasourceTypes
	policy.DatasourceTypes = genruntime.CloneSliceOfString(source.DatasourceTypes)

	// ObjectType
	if source.ObjectType != nil {
		objectType := *source.ObjectType
		objectTypeTemp := genruntime.ToEnum(objectType, backupPolicy_ObjectType_Values)
		policy.ObjectType = &objectTypeTemp
	} else {
		policy.ObjectType = nil
	}

	// PolicyRules
	if source.PolicyRules != nil {
		policyRuleList := make([]BasePolicyRule, len(source.PolicyRules))
		for policyRuleIndex, policyRuleItem := range source.PolicyRules {
			// Shadow the loop variable to avoid aliasing
			policyRuleItem := policyRuleItem
			var policyRule BasePolicyRule
			err := policyRule.AssignProperties_From_BasePolicyRule(&policyRuleItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_BasePolicyRule() to populate field PolicyRules")
			}
			policyRuleList[policyRuleIndex] = policyRule
		}
		policy.PolicyRules = policyRuleList
	} else {
		policy.PolicyRules = nil
	}

	// No error
	return nil
}

// AssignProperties_To_BackupPolicy populates the provided destination BackupPolicy from our BackupPolicy
func (policy *BackupPolicy) AssignProperties_To_BackupPolicy(destination *storage.BackupPolicy) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DatasourceTypes
	destination.DatasourceTypes = genruntime.CloneSliceOfString(policy.DatasourceTypes)

	// ObjectType
	if policy.ObjectType != nil {
		objectType := string(*policy.ObjectType)
		destination.ObjectType = &objectType
	} else {
		destination.ObjectType = nil
	}

	// PolicyRules
	if policy.PolicyRules != nil {
		policyRuleList := make([]storage.BasePolicyRule, len(policy.PolicyRules))
		for policyRuleIndex, policyRuleItem := range policy.PolicyRules {
			// Shadow the loop variable to avoid aliasing
			policyRuleItem := policyRuleItem
			var policyRule storage.BasePolicyRule
			err := policyRuleItem.AssignProperties_To_BasePolicyRule(&policyRule)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_BasePolicyRule() to populate field PolicyRules")
			}
			policyRuleList[policyRuleIndex] = policyRule
		}
		destination.PolicyRules = policyRuleList
	} else {
		destination.PolicyRules = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type BackupPolicy_STATUS struct {
	// DatasourceTypes: Type of datasource for the backup management
	DatasourceTypes []string                        `json:"datasourceTypes,omitempty"`
	ObjectType      *BackupPolicy_ObjectType_STATUS `json:"objectType,omitempty"`

	// PolicyRules: Policy rule dictionary that contains rules for each backuptype i.e Full/Incremental/Logs etc
	PolicyRules []BasePolicyRule_STATUS `json:"policyRules,omitempty"`
}

var _ genruntime.FromARMConverter = &BackupPolicy_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (policy *BackupPolicy_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.BackupPolicy_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (policy *BackupPolicy_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.BackupPolicy_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.BackupPolicy_STATUS, got %T", armInput)
	}

	// Set property "DatasourceTypes":
	for _, item := range typedInput.DatasourceTypes {
		policy.DatasourceTypes = append(policy.DatasourceTypes, item)
	}

	// Set property "ObjectType":
	var temp BackupPolicy_ObjectType_STATUS
	var temp1 string
	temp1 = string(typedInput.ObjectType)
	temp = BackupPolicy_ObjectType_STATUS(temp1)
	policy.ObjectType = &temp

	// Set property "PolicyRules":
	for _, item := range typedInput.PolicyRules {
		var item1 BasePolicyRule_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		policy.PolicyRules = append(policy.PolicyRules, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_BackupPolicy_STATUS populates our BackupPolicy_STATUS from the provided source BackupPolicy_STATUS
func (policy *BackupPolicy_STATUS) AssignProperties_From_BackupPolicy_STATUS(source *storage.BackupPolicy_STATUS) error {

	// DatasourceTypes
	policy.DatasourceTypes = genruntime.CloneSliceOfString(source.DatasourceTypes)

	// ObjectType
	if source.ObjectType != nil {
		objectType := *source.ObjectType
		objectTypeTemp := genruntime.ToEnum(objectType, backupPolicy_ObjectType_STATUS_Values)
		policy.ObjectType = &objectTypeTemp
	} else {
		policy.ObjectType = nil
	}

	// PolicyRules
	if source.PolicyRules != nil {
		policyRuleList := make([]BasePolicyRule_STATUS, len(source.PolicyRules))
		for policyRuleIndex, policyRuleItem := range source.PolicyRules {
			// Shadow the loop variable to avoid aliasing
			policyRuleItem := policyRuleItem
			var policyRule BasePolicyRule_STATUS
			err := policyRule.AssignProperties_From_BasePolicyRule_STATUS(&policyRuleItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_BasePolicyRule_STATUS() to populate field PolicyRules")
			}
			policyRuleList[policyRuleIndex] = policyRule
		}
		policy.PolicyRules = policyRuleList
	} else {
		policy.PolicyRules = nil
	}

	// No error
	return nil
}

// AssignProperties_To_BackupPolicy_STATUS populates the provided destination BackupPolicy_STATUS from our BackupPolicy_STATUS
func (policy *BackupPolicy_STATUS) AssignProperties_To_BackupPolicy_STATUS(destination *storage.BackupPolicy_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DatasourceTypes
	destination.DatasourceTypes = genruntime.CloneSliceOfString(policy.DatasourceTypes)

	// ObjectType
	if policy.ObjectType != nil {
		objectType := string(*policy.ObjectType)
		destination.ObjectType = &objectType
	} else {
		destination.ObjectType = nil
	}

	// PolicyRules
	if policy.PolicyRules != nil {
		policyRuleList := make([]storage.BasePolicyRule_STATUS, len(policy.PolicyRules))
		for policyRuleIndex, policyRuleItem := range policy.PolicyRules {
			// Shadow the loop variable to avoid aliasing
			policyRuleItem := policyRuleItem
			var policyRule storage.BasePolicyRule_STATUS
			err := policyRuleItem.AssignProperties_To_BasePolicyRule_STATUS(&policyRule)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_BasePolicyRule_STATUS() to populate field PolicyRules")
			}
			policyRuleList[policyRuleIndex] = policyRule
		}
		destination.PolicyRules = policyRuleList
	} else {
		destination.PolicyRules = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"BackupPolicy"}
type BackupPolicy_ObjectType string

const BackupPolicy_ObjectType_BackupPolicy = BackupPolicy_ObjectType("BackupPolicy")

// Mapping from string to BackupPolicy_ObjectType
var backupPolicy_ObjectType_Values = map[string]BackupPolicy_ObjectType{
	"backuppolicy": BackupPolicy_ObjectType_BackupPolicy,
}

type BackupPolicy_ObjectType_STATUS string

const BackupPolicy_ObjectType_STATUS_BackupPolicy = BackupPolicy_ObjectType_STATUS("BackupPolicy")

// Mapping from string to BackupPolicy_ObjectType_STATUS
var backupPolicy_ObjectType_STATUS_Values = map[string]BackupPolicy_ObjectType_STATUS{
	"backuppolicy": BackupPolicy_ObjectType_STATUS_BackupPolicy,
}

type BasePolicyRule struct {
	// AzureBackup: Mutually exclusive with all other properties
	AzureBackup *AzureBackupRule `json:"azureBackupRule,omitempty"`

	// AzureRetention: Mutually exclusive with all other properties
	AzureRetention *AzureRetentionRule `json:"azureRetentionRule,omitempty"`
}

var _ genruntime.ARMTransformer = &BasePolicyRule{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (rule *BasePolicyRule) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if rule == nil {
		return nil, nil
	}
	result := &arm.BasePolicyRule{}

	// Set property "AzureBackup":
	if rule.AzureBackup != nil {
		azureBackup_ARM, err := (*rule.AzureBackup).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		azureBackup := *azureBackup_ARM.(*arm.AzureBackupRule)
		result.AzureBackup = &azureBackup
	}

	// Set property "AzureRetention":
	if rule.AzureRetention != nil {
		azureRetention_ARM, err := (*rule.AzureRetention).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		azureRetention := *azureRetention_ARM.(*arm.AzureRetentionRule)
		result.AzureRetention = &azureRetention
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *BasePolicyRule) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.BasePolicyRule{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *BasePolicyRule) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.BasePolicyRule)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.BasePolicyRule, got %T", armInput)
	}

	// Set property "AzureBackup":
	if typedInput.AzureBackup != nil {
		var azureBackup1 AzureBackupRule
		err := azureBackup1.PopulateFromARM(owner, *typedInput.AzureBackup)
		if err != nil {
			return err
		}
		azureBackup := azureBackup1
		rule.AzureBackup = &azureBackup
	}

	// Set property "AzureRetention":
	if typedInput.AzureRetention != nil {
		var azureRetention1 AzureRetentionRule
		err := azureRetention1.PopulateFromARM(owner, *typedInput.AzureRetention)
		if err != nil {
			return err
		}
		azureRetention := azureRetention1
		rule.AzureRetention = &azureRetention
	}

	// No error
	return nil
}

// AssignProperties_From_BasePolicyRule populates our BasePolicyRule from the provided source BasePolicyRule
func (rule *BasePolicyRule) AssignProperties_From_BasePolicyRule(source *storage.BasePolicyRule) error {

	// AzureBackup
	if source.AzureBackup != nil {
		var azureBackup AzureBackupRule
		err := azureBackup.AssignProperties_From_AzureBackupRule(source.AzureBackup)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AzureBackupRule() to populate field AzureBackup")
		}
		rule.AzureBackup = &azureBackup
	} else {
		rule.AzureBackup = nil
	}

	// AzureRetention
	if source.AzureRetention != nil {
		var azureRetention AzureRetentionRule
		err := azureRetention.AssignProperties_From_AzureRetentionRule(source.AzureRetention)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AzureRetentionRule() to populate field AzureRetention")
		}
		rule.AzureRetention = &azureRetention
	} else {
		rule.AzureRetention = nil
	}

	// No error
	return nil
}

// AssignProperties_To_BasePolicyRule populates the provided destination BasePolicyRule from our BasePolicyRule
func (rule *BasePolicyRule) AssignProperties_To_BasePolicyRule(destination *storage.BasePolicyRule) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureBackup
	if rule.AzureBackup != nil {
		var azureBackup storage.AzureBackupRule
		err := rule.AzureBackup.AssignProperties_To_AzureBackupRule(&azureBackup)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AzureBackupRule() to populate field AzureBackup")
		}
		destination.AzureBackup = &azureBackup
	} else {
		destination.AzureBackup = nil
	}

	// AzureRetention
	if rule.AzureRetention != nil {
		var azureRetention storage.AzureRetentionRule
		err := rule.AzureRetention.AssignProperties_To_AzureRetentionRule(&azureRetention)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AzureRetentionRule() to populate field AzureRetention")
		}
		destination.AzureRetention = &azureRetention
	} else {
		destination.AzureRetention = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type BasePolicyRule_STATUS struct {
	// AzureBackup: Mutually exclusive with all other properties
	AzureBackup *AzureBackupRule_STATUS `json:"azureBackupRule,omitempty"`

	// AzureRetention: Mutually exclusive with all other properties
	AzureRetention *AzureRetentionRule_STATUS `json:"azureRetentionRule,omitempty"`
}

var _ genruntime.FromARMConverter = &BasePolicyRule_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *BasePolicyRule_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.BasePolicyRule_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *BasePolicyRule_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.BasePolicyRule_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.BasePolicyRule_STATUS, got %T", armInput)
	}

	// Set property "AzureBackup":
	if typedInput.AzureBackup != nil {
		var azureBackup1 AzureBackupRule_STATUS
		err := azureBackup1.PopulateFromARM(owner, *typedInput.AzureBackup)
		if err != nil {
			return err
		}
		azureBackup := azureBackup1
		rule.AzureBackup = &azureBackup
	}

	// Set property "AzureRetention":
	if typedInput.AzureRetention != nil {
		var azureRetention1 AzureRetentionRule_STATUS
		err := azureRetention1.PopulateFromARM(owner, *typedInput.AzureRetention)
		if err != nil {
			return err
		}
		azureRetention := azureRetention1
		rule.AzureRetention = &azureRetention
	}

	// No error
	return nil
}

// AssignProperties_From_BasePolicyRule_STATUS populates our BasePolicyRule_STATUS from the provided source BasePolicyRule_STATUS
func (rule *BasePolicyRule_STATUS) AssignProperties_From_BasePolicyRule_STATUS(source *storage.BasePolicyRule_STATUS) error {

	// AzureBackup
	if source.AzureBackup != nil {
		var azureBackup AzureBackupRule_STATUS
		err := azureBackup.AssignProperties_From_AzureBackupRule_STATUS(source.AzureBackup)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AzureBackupRule_STATUS() to populate field AzureBackup")
		}
		rule.AzureBackup = &azureBackup
	} else {
		rule.AzureBackup = nil
	}

	// AzureRetention
	if source.AzureRetention != nil {
		var azureRetention AzureRetentionRule_STATUS
		err := azureRetention.AssignProperties_From_AzureRetentionRule_STATUS(source.AzureRetention)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AzureRetentionRule_STATUS() to populate field AzureRetention")
		}
		rule.AzureRetention = &azureRetention
	} else {
		rule.AzureRetention = nil
	}

	// No error
	return nil
}

// AssignProperties_To_BasePolicyRule_STATUS populates the provided destination BasePolicyRule_STATUS from our BasePolicyRule_STATUS
func (rule *BasePolicyRule_STATUS) AssignProperties_To_BasePolicyRule_STATUS(destination *storage.BasePolicyRule_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureBackup
	if rule.AzureBackup != nil {
		var azureBackup storage.AzureBackupRule_STATUS
		err := rule.AzureBackup.AssignProperties_To_AzureBackupRule_STATUS(&azureBackup)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AzureBackupRule_STATUS() to populate field AzureBackup")
		}
		destination.AzureBackup = &azureBackup
	} else {
		destination.AzureBackup = nil
	}

	// AzureRetention
	if rule.AzureRetention != nil {
		var azureRetention storage.AzureRetentionRule_STATUS
		err := rule.AzureRetention.AssignProperties_To_AzureRetentionRule_STATUS(&azureRetention)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AzureRetentionRule_STATUS() to populate field AzureRetention")
		}
		destination.AzureRetention = &azureRetention
	} else {
		destination.AzureRetention = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type AzureBackupRule struct {
	BackupParameters *BackupParameters `json:"backupParameters,omitempty"`

	// +kubebuilder:validation:Required
	// DataStore: DataStoreInfo base
	DataStore *DataStoreInfoBase `json:"dataStore,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	ObjectType *AzureBackupRule_ObjectType `json:"objectType,omitempty"`

	// +kubebuilder:validation:Required
	Trigger *TriggerContext `json:"trigger,omitempty"`
}

var _ genruntime.ARMTransformer = &AzureBackupRule{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (rule *AzureBackupRule) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if rule == nil {
		return nil, nil
	}
	result := &arm.AzureBackupRule{}

	// Set property "BackupParameters":
	if rule.BackupParameters != nil {
		backupParameters_ARM, err := (*rule.BackupParameters).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		backupParameters := *backupParameters_ARM.(*arm.BackupParameters)
		result.BackupParameters = &backupParameters
	}

	// Set property "DataStore":
	if rule.DataStore != nil {
		dataStore_ARM, err := (*rule.DataStore).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		dataStore := *dataStore_ARM.(*arm.DataStoreInfoBase)
		result.DataStore = &dataStore
	}

	// Set property "Name":
	if rule.Name != nil {
		name := *rule.Name
		result.Name = &name
	}

	// Set property "ObjectType":
	if rule.ObjectType != nil {
		var temp arm.AzureBackupRule_ObjectType
		var temp1 string
		temp1 = string(*rule.ObjectType)
		temp = arm.AzureBackupRule_ObjectType(temp1)
		result.ObjectType = temp
	}

	// Set property "Trigger":
	if rule.Trigger != nil {
		trigger_ARM, err := (*rule.Trigger).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		trigger := *trigger_ARM.(*arm.TriggerContext)
		result.Trigger = &trigger
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *AzureBackupRule) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AzureBackupRule{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *AzureBackupRule) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AzureBackupRule)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AzureBackupRule, got %T", armInput)
	}

	// Set property "BackupParameters":
	if typedInput.BackupParameters != nil {
		var backupParameters1 BackupParameters
		err := backupParameters1.PopulateFromARM(owner, *typedInput.BackupParameters)
		if err != nil {
			return err
		}
		backupParameters := backupParameters1
		rule.BackupParameters = &backupParameters
	}

	// Set property "DataStore":
	if typedInput.DataStore != nil {
		var dataStore1 DataStoreInfoBase
		err := dataStore1.PopulateFromARM(owner, *typedInput.DataStore)
		if err != nil {
			return err
		}
		dataStore := dataStore1
		rule.DataStore = &dataStore
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		rule.Name = &name
	}

	// Set property "ObjectType":
	var temp AzureBackupRule_ObjectType
	var temp1 string
	temp1 = string(typedInput.ObjectType)
	temp = AzureBackupRule_ObjectType(temp1)
	rule.ObjectType = &temp

	// Set property "Trigger":
	if typedInput.Trigger != nil {
		var trigger1 TriggerContext
		err := trigger1.PopulateFromARM(owner, *typedInput.Trigger)
		if err != nil {
			return err
		}
		trigger := trigger1
		rule.Trigger = &trigger
	}

	// No error
	return nil
}

// AssignProperties_From_AzureBackupRule populates our AzureBackupRule from the provided source AzureBackupRule
func (rule *AzureBackupRule) AssignProperties_From_AzureBackupRule(source *storage.AzureBackupRule) error {

	// BackupParameters
	if source.BackupParameters != nil {
		var backupParameter BackupParameters
		err := backupParameter.AssignProperties_From_BackupParameters(source.BackupParameters)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_BackupParameters() to populate field BackupParameters")
		}
		rule.BackupParameters = &backupParameter
	} else {
		rule.BackupParameters = nil
	}

	// DataStore
	if source.DataStore != nil {
		var dataStore DataStoreInfoBase
		err := dataStore.AssignProperties_From_DataStoreInfoBase(source.DataStore)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_DataStoreInfoBase() to populate field DataStore")
		}
		rule.DataStore = &dataStore
	} else {
		rule.DataStore = nil
	}

	// Name
	rule.Name = genruntime.ClonePointerToString(source.Name)

	// ObjectType
	if source.ObjectType != nil {
		objectType := *source.ObjectType
		objectTypeTemp := genruntime.ToEnum(objectType, azureBackupRule_ObjectType_Values)
		rule.ObjectType = &objectTypeTemp
	} else {
		rule.ObjectType = nil
	}

	// Trigger
	if source.Trigger != nil {
		var trigger TriggerContext
		err := trigger.AssignProperties_From_TriggerContext(source.Trigger)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_TriggerContext() to populate field Trigger")
		}
		rule.Trigger = &trigger
	} else {
		rule.Trigger = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AzureBackupRule populates the provided destination AzureBackupRule from our AzureBackupRule
func (rule *AzureBackupRule) AssignProperties_To_AzureBackupRule(destination *storage.AzureBackupRule) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BackupParameters
	if rule.BackupParameters != nil {
		var backupParameter storage.BackupParameters
		err := rule.BackupParameters.AssignProperties_To_BackupParameters(&backupParameter)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_BackupParameters() to populate field BackupParameters")
		}
		destination.BackupParameters = &backupParameter
	} else {
		destination.BackupParameters = nil
	}

	// DataStore
	if rule.DataStore != nil {
		var dataStore storage.DataStoreInfoBase
		err := rule.DataStore.AssignProperties_To_DataStoreInfoBase(&dataStore)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_DataStoreInfoBase() to populate field DataStore")
		}
		destination.DataStore = &dataStore
	} else {
		destination.DataStore = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(rule.Name)

	// ObjectType
	if rule.ObjectType != nil {
		objectType := string(*rule.ObjectType)
		destination.ObjectType = &objectType
	} else {
		destination.ObjectType = nil
	}

	// Trigger
	if rule.Trigger != nil {
		var trigger storage.TriggerContext
		err := rule.Trigger.AssignProperties_To_TriggerContext(&trigger)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_TriggerContext() to populate field Trigger")
		}
		destination.Trigger = &trigger
	} else {
		destination.Trigger = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type AzureBackupRule_STATUS struct {
	BackupParameters *BackupParameters_STATUS `json:"backupParameters,omitempty"`

	// DataStore: DataStoreInfo base
	DataStore  *DataStoreInfoBase_STATUS          `json:"dataStore,omitempty"`
	Name       *string                            `json:"name,omitempty"`
	ObjectType *AzureBackupRule_ObjectType_STATUS `json:"objectType,omitempty"`
	Trigger    *TriggerContext_STATUS             `json:"trigger,omitempty"`
}

var _ genruntime.FromARMConverter = &AzureBackupRule_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *AzureBackupRule_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AzureBackupRule_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *AzureBackupRule_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AzureBackupRule_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AzureBackupRule_STATUS, got %T", armInput)
	}

	// Set property "BackupParameters":
	if typedInput.BackupParameters != nil {
		var backupParameters1 BackupParameters_STATUS
		err := backupParameters1.PopulateFromARM(owner, *typedInput.BackupParameters)
		if err != nil {
			return err
		}
		backupParameters := backupParameters1
		rule.BackupParameters = &backupParameters
	}

	// Set property "DataStore":
	if typedInput.DataStore != nil {
		var dataStore1 DataStoreInfoBase_STATUS
		err := dataStore1.PopulateFromARM(owner, *typedInput.DataStore)
		if err != nil {
			return err
		}
		dataStore := dataStore1
		rule.DataStore = &dataStore
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		rule.Name = &name
	}

	// Set property "ObjectType":
	var temp AzureBackupRule_ObjectType_STATUS
	var temp1 string
	temp1 = string(typedInput.ObjectType)
	temp = AzureBackupRule_ObjectType_STATUS(temp1)
	rule.ObjectType = &temp

	// Set property "Trigger":
	if typedInput.Trigger != nil {
		var trigger1 TriggerContext_STATUS
		err := trigger1.PopulateFromARM(owner, *typedInput.Trigger)
		if err != nil {
			return err
		}
		trigger := trigger1
		rule.Trigger = &trigger
	}

	// No error
	return nil
}

// AssignProperties_From_AzureBackupRule_STATUS populates our AzureBackupRule_STATUS from the provided source AzureBackupRule_STATUS
func (rule *AzureBackupRule_STATUS) AssignProperties_From_AzureBackupRule_STATUS(source *storage.AzureBackupRule_STATUS) error {

	// BackupParameters
	if source.BackupParameters != nil {
		var backupParameter BackupParameters_STATUS
		err := backupParameter.AssignProperties_From_BackupParameters_STATUS(source.BackupParameters)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_BackupParameters_STATUS() to populate field BackupParameters")
		}
		rule.BackupParameters = &backupParameter
	} else {
		rule.BackupParameters = nil
	}

	// DataStore
	if source.DataStore != nil {
		var dataStore DataStoreInfoBase_STATUS
		err := dataStore.AssignProperties_From_DataStoreInfoBase_STATUS(source.DataStore)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_DataStoreInfoBase_STATUS() to populate field DataStore")
		}
		rule.DataStore = &dataStore
	} else {
		rule.DataStore = nil
	}

	// Name
	rule.Name = genruntime.ClonePointerToString(source.Name)

	// ObjectType
	if source.ObjectType != nil {
		objectType := *source.ObjectType
		objectTypeTemp := genruntime.ToEnum(objectType, azureBackupRule_ObjectType_STATUS_Values)
		rule.ObjectType = &objectTypeTemp
	} else {
		rule.ObjectType = nil
	}

	// Trigger
	if source.Trigger != nil {
		var trigger TriggerContext_STATUS
		err := trigger.AssignProperties_From_TriggerContext_STATUS(source.Trigger)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_TriggerContext_STATUS() to populate field Trigger")
		}
		rule.Trigger = &trigger
	} else {
		rule.Trigger = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AzureBackupRule_STATUS populates the provided destination AzureBackupRule_STATUS from our AzureBackupRule_STATUS
func (rule *AzureBackupRule_STATUS) AssignProperties_To_AzureBackupRule_STATUS(destination *storage.AzureBackupRule_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BackupParameters
	if rule.BackupParameters != nil {
		var backupParameter storage.BackupParameters_STATUS
		err := rule.BackupParameters.AssignProperties_To_BackupParameters_STATUS(&backupParameter)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_BackupParameters_STATUS() to populate field BackupParameters")
		}
		destination.BackupParameters = &backupParameter
	} else {
		destination.BackupParameters = nil
	}

	// DataStore
	if rule.DataStore != nil {
		var dataStore storage.DataStoreInfoBase_STATUS
		err := rule.DataStore.AssignProperties_To_DataStoreInfoBase_STATUS(&dataStore)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_DataStoreInfoBase_STATUS() to populate field DataStore")
		}
		destination.DataStore = &dataStore
	} else {
		destination.DataStore = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(rule.Name)

	// ObjectType
	if rule.ObjectType != nil {
		objectType := string(*rule.ObjectType)
		destination.ObjectType = &objectType
	} else {
		destination.ObjectType = nil
	}

	// Trigger
	if rule.Trigger != nil {
		var trigger storage.TriggerContext_STATUS
		err := rule.Trigger.AssignProperties_To_TriggerContext_STATUS(&trigger)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_TriggerContext_STATUS() to populate field Trigger")
		}
		destination.Trigger = &trigger
	} else {
		destination.Trigger = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type AzureRetentionRule struct {
	IsDefault *bool `json:"isDefault,omitempty"`

	// +kubebuilder:validation:Required
	Lifecycles []SourceLifeCycle `json:"lifecycles,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	ObjectType *AzureRetentionRule_ObjectType `json:"objectType,omitempty"`
}

var _ genruntime.ARMTransformer = &AzureRetentionRule{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (rule *AzureRetentionRule) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if rule == nil {
		return nil, nil
	}
	result := &arm.AzureRetentionRule{}

	// Set property "IsDefault":
	if rule.IsDefault != nil {
		isDefault := *rule.IsDefault
		result.IsDefault = &isDefault
	}

	// Set property "Lifecycles":
	for _, item := range rule.Lifecycles {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Lifecycles = append(result.Lifecycles, *item_ARM.(*arm.SourceLifeCycle))
	}

	// Set property "Name":
	if rule.Name != nil {
		name := *rule.Name
		result.Name = &name
	}

	// Set property "ObjectType":
	if rule.ObjectType != nil {
		var temp arm.AzureRetentionRule_ObjectType
		var temp1 string
		temp1 = string(*rule.ObjectType)
		temp = arm.AzureRetentionRule_ObjectType(temp1)
		result.ObjectType = temp
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *AzureRetentionRule) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AzureRetentionRule{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *AzureRetentionRule) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AzureRetentionRule)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AzureRetentionRule, got %T", armInput)
	}

	// Set property "IsDefault":
	if typedInput.IsDefault != nil {
		isDefault := *typedInput.IsDefault
		rule.IsDefault = &isDefault
	}

	// Set property "Lifecycles":
	for _, item := range typedInput.Lifecycles {
		var item1 SourceLifeCycle
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		rule.Lifecycles = append(rule.Lifecycles, item1)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		rule.Name = &name
	}

	// Set property "ObjectType":
	var temp AzureRetentionRule_ObjectType
	var temp1 string
	temp1 = string(typedInput.ObjectType)
	temp = AzureRetentionRule_ObjectType(temp1)
	rule.ObjectType = &temp

	// No error
	return nil
}

// AssignProperties_From_AzureRetentionRule populates our AzureRetentionRule from the provided source AzureRetentionRule
func (rule *AzureRetentionRule) AssignProperties_From_AzureRetentionRule(source *storage.AzureRetentionRule) error {

	// IsDefault
	if source.IsDefault != nil {
		isDefault := *source.IsDefault
		rule.IsDefault = &isDefault
	} else {
		rule.IsDefault = nil
	}

	// Lifecycles
	if source.Lifecycles != nil {
		lifecycleList := make([]SourceLifeCycle, len(source.Lifecycles))
		for lifecycleIndex, lifecycleItem := range source.Lifecycles {
			// Shadow the loop variable to avoid aliasing
			lifecycleItem := lifecycleItem
			var lifecycle SourceLifeCycle
			err := lifecycle.AssignProperties_From_SourceLifeCycle(&lifecycleItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_SourceLifeCycle() to populate field Lifecycles")
			}
			lifecycleList[lifecycleIndex] = lifecycle
		}
		rule.Lifecycles = lifecycleList
	} else {
		rule.Lifecycles = nil
	}

	// Name
	rule.Name = genruntime.ClonePointerToString(source.Name)

	// ObjectType
	if source.ObjectType != nil {
		objectType := *source.ObjectType
		objectTypeTemp := genruntime.ToEnum(objectType, azureRetentionRule_ObjectType_Values)
		rule.ObjectType = &objectTypeTemp
	} else {
		rule.ObjectType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AzureRetentionRule populates the provided destination AzureRetentionRule from our AzureRetentionRule
func (rule *AzureRetentionRule) AssignProperties_To_AzureRetentionRule(destination *storage.AzureRetentionRule) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// IsDefault
	if rule.IsDefault != nil {
		isDefault := *rule.IsDefault
		destination.IsDefault = &isDefault
	} else {
		destination.IsDefault = nil
	}

	// Lifecycles
	if rule.Lifecycles != nil {
		lifecycleList := make([]storage.SourceLifeCycle, len(rule.Lifecycles))
		for lifecycleIndex, lifecycleItem := range rule.Lifecycles {
			// Shadow the loop variable to avoid aliasing
			lifecycleItem := lifecycleItem
			var lifecycle storage.SourceLifeCycle
			err := lifecycleItem.AssignProperties_To_SourceLifeCycle(&lifecycle)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_SourceLifeCycle() to populate field Lifecycles")
			}
			lifecycleList[lifecycleIndex] = lifecycle
		}
		destination.Lifecycles = lifecycleList
	} else {
		destination.Lifecycles = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(rule.Name)

	// ObjectType
	if rule.ObjectType != nil {
		objectType := string(*rule.ObjectType)
		destination.ObjectType = &objectType
	} else {
		destination.ObjectType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type AzureRetentionRule_STATUS struct {
	IsDefault  *bool                                 `json:"isDefault,omitempty"`
	Lifecycles []SourceLifeCycle_STATUS              `json:"lifecycles,omitempty"`
	Name       *string                               `json:"name,omitempty"`
	ObjectType *AzureRetentionRule_ObjectType_STATUS `json:"objectType,omitempty"`
}

var _ genruntime.FromARMConverter = &AzureRetentionRule_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *AzureRetentionRule_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AzureRetentionRule_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *AzureRetentionRule_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AzureRetentionRule_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AzureRetentionRule_STATUS, got %T", armInput)
	}

	// Set property "IsDefault":
	if typedInput.IsDefault != nil {
		isDefault := *typedInput.IsDefault
		rule.IsDefault = &isDefault
	}

	// Set property "Lifecycles":
	for _, item := range typedInput.Lifecycles {
		var item1 SourceLifeCycle_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		rule.Lifecycles = append(rule.Lifecycles, item1)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		rule.Name = &name
	}

	// Set property "ObjectType":
	var temp AzureRetentionRule_ObjectType_STATUS
	var temp1 string
	temp1 = string(typedInput.ObjectType)
	temp = AzureRetentionRule_ObjectType_STATUS(temp1)
	rule.ObjectType = &temp

	// No error
	return nil
}

// AssignProperties_From_AzureRetentionRule_STATUS populates our AzureRetentionRule_STATUS from the provided source AzureRetentionRule_STATUS
func (rule *AzureRetentionRule_STATUS) AssignProperties_From_AzureRetentionRule_STATUS(source *storage.AzureRetentionRule_STATUS) error {

	// IsDefault
	if source.IsDefault != nil {
		isDefault := *source.IsDefault
		rule.IsDefault = &isDefault
	} else {
		rule.IsDefault = nil
	}

	// Lifecycles
	if source.Lifecycles != nil {
		lifecycleList := make([]SourceLifeCycle_STATUS, len(source.Lifecycles))
		for lifecycleIndex, lifecycleItem := range source.Lifecycles {
			// Shadow the loop variable to avoid aliasing
			lifecycleItem := lifecycleItem
			var lifecycle SourceLifeCycle_STATUS
			err := lifecycle.AssignProperties_From_SourceLifeCycle_STATUS(&lifecycleItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_SourceLifeCycle_STATUS() to populate field Lifecycles")
			}
			lifecycleList[lifecycleIndex] = lifecycle
		}
		rule.Lifecycles = lifecycleList
	} else {
		rule.Lifecycles = nil
	}

	// Name
	rule.Name = genruntime.ClonePointerToString(source.Name)

	// ObjectType
	if source.ObjectType != nil {
		objectType := *source.ObjectType
		objectTypeTemp := genruntime.ToEnum(objectType, azureRetentionRule_ObjectType_STATUS_Values)
		rule.ObjectType = &objectTypeTemp
	} else {
		rule.ObjectType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AzureRetentionRule_STATUS populates the provided destination AzureRetentionRule_STATUS from our AzureRetentionRule_STATUS
func (rule *AzureRetentionRule_STATUS) AssignProperties_To_AzureRetentionRule_STATUS(destination *storage.AzureRetentionRule_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// IsDefault
	if rule.IsDefault != nil {
		isDefault := *rule.IsDefault
		destination.IsDefault = &isDefault
	} else {
		destination.IsDefault = nil
	}

	// Lifecycles
	if rule.Lifecycles != nil {
		lifecycleList := make([]storage.SourceLifeCycle_STATUS, len(rule.Lifecycles))
		for lifecycleIndex, lifecycleItem := range rule.Lifecycles {
			// Shadow the loop variable to avoid aliasing
			lifecycleItem := lifecycleItem
			var lifecycle storage.SourceLifeCycle_STATUS
			err := lifecycleItem.AssignProperties_To_SourceLifeCycle_STATUS(&lifecycle)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_SourceLifeCycle_STATUS() to populate field Lifecycles")
			}
			lifecycleList[lifecycleIndex] = lifecycle
		}
		destination.Lifecycles = lifecycleList
	} else {
		destination.Lifecycles = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(rule.Name)

	// ObjectType
	if rule.ObjectType != nil {
		objectType := string(*rule.ObjectType)
		destination.ObjectType = &objectType
	} else {
		destination.ObjectType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"AzureBackupRule"}
type AzureBackupRule_ObjectType string

const AzureBackupRule_ObjectType_AzureBackupRule = AzureBackupRule_ObjectType("AzureBackupRule")

// Mapping from string to AzureBackupRule_ObjectType
var azureBackupRule_ObjectType_Values = map[string]AzureBackupRule_ObjectType{
	"azurebackuprule": AzureBackupRule_ObjectType_AzureBackupRule,
}

type AzureBackupRule_ObjectType_STATUS string

const AzureBackupRule_ObjectType_STATUS_AzureBackupRule = AzureBackupRule_ObjectType_STATUS("AzureBackupRule")

// Mapping from string to AzureBackupRule_ObjectType_STATUS
var azureBackupRule_ObjectType_STATUS_Values = map[string]AzureBackupRule_ObjectType_STATUS{
	"azurebackuprule": AzureBackupRule_ObjectType_STATUS_AzureBackupRule,
}

// +kubebuilder:validation:Enum={"AzureRetentionRule"}
type AzureRetentionRule_ObjectType string

const AzureRetentionRule_ObjectType_AzureRetentionRule = AzureRetentionRule_ObjectType("AzureRetentionRule")

// Mapping from string to AzureRetentionRule_ObjectType
var azureRetentionRule_ObjectType_Values = map[string]AzureRetentionRule_ObjectType{
	"azureretentionrule": AzureRetentionRule_ObjectType_AzureRetentionRule,
}

type AzureRetentionRule_ObjectType_STATUS string

const AzureRetentionRule_ObjectType_STATUS_AzureRetentionRule = AzureRetentionRule_ObjectType_STATUS("AzureRetentionRule")

// Mapping from string to AzureRetentionRule_ObjectType_STATUS
var azureRetentionRule_ObjectType_STATUS_Values = map[string]AzureRetentionRule_ObjectType_STATUS{
	"azureretentionrule": AzureRetentionRule_ObjectType_STATUS_AzureRetentionRule,
}

type BackupParameters struct {
	// AzureBackupParams: Mutually exclusive with all other properties
	AzureBackupParams *AzureBackupParams `json:"azureBackupParams,omitempty"`
}

var _ genruntime.ARMTransformer = &BackupParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameters *BackupParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameters == nil {
		return nil, nil
	}
	result := &arm.BackupParameters{}

	// Set property "AzureBackupParams":
	if parameters.AzureBackupParams != nil {
		azureBackupParams_ARM, err := (*parameters.AzureBackupParams).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		azureBackupParams := *azureBackupParams_ARM.(*arm.AzureBackupParams)
		result.AzureBackupParams = &azureBackupParams
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *BackupParameters) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.BackupParameters{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *BackupParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.BackupParameters)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.BackupParameters, got %T", armInput)
	}

	// Set property "AzureBackupParams":
	if typedInput.AzureBackupParams != nil {
		var azureBackupParams1 AzureBackupParams
		err := azureBackupParams1.PopulateFromARM(owner, *typedInput.AzureBackupParams)
		if err != nil {
			return err
		}
		azureBackupParams := azureBackupParams1
		parameters.AzureBackupParams = &azureBackupParams
	}

	// No error
	return nil
}

// AssignProperties_From_BackupParameters populates our BackupParameters from the provided source BackupParameters
func (parameters *BackupParameters) AssignProperties_From_BackupParameters(source *storage.BackupParameters) error {

	// AzureBackupParams
	if source.AzureBackupParams != nil {
		var azureBackupParam AzureBackupParams
		err := azureBackupParam.AssignProperties_From_AzureBackupParams(source.AzureBackupParams)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AzureBackupParams() to populate field AzureBackupParams")
		}
		parameters.AzureBackupParams = &azureBackupParam
	} else {
		parameters.AzureBackupParams = nil
	}

	// No error
	return nil
}

// AssignProperties_To_BackupParameters populates the provided destination BackupParameters from our BackupParameters
func (parameters *BackupParameters) AssignProperties_To_BackupParameters(destination *storage.BackupParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureBackupParams
	if parameters.AzureBackupParams != nil {
		var azureBackupParam storage.AzureBackupParams
		err := parameters.AzureBackupParams.AssignProperties_To_AzureBackupParams(&azureBackupParam)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AzureBackupParams() to populate field AzureBackupParams")
		}
		destination.AzureBackupParams = &azureBackupParam
	} else {
		destination.AzureBackupParams = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type BackupParameters_STATUS struct {
	// AzureBackupParams: Mutually exclusive with all other properties
	AzureBackupParams *AzureBackupParams_STATUS `json:"azureBackupParams,omitempty"`
}

var _ genruntime.FromARMConverter = &BackupParameters_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *BackupParameters_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.BackupParameters_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *BackupParameters_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.BackupParameters_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.BackupParameters_STATUS, got %T", armInput)
	}

	// Set property "AzureBackupParams":
	if typedInput.AzureBackupParams != nil {
		var azureBackupParams1 AzureBackupParams_STATUS
		err := azureBackupParams1.PopulateFromARM(owner, *typedInput.AzureBackupParams)
		if err != nil {
			return err
		}
		azureBackupParams := azureBackupParams1
		parameters.AzureBackupParams = &azureBackupParams
	}

	// No error
	return nil
}

// AssignProperties_From_BackupParameters_STATUS populates our BackupParameters_STATUS from the provided source BackupParameters_STATUS
func (parameters *BackupParameters_STATUS) AssignProperties_From_BackupParameters_STATUS(source *storage.BackupParameters_STATUS) error {

	// AzureBackupParams
	if source.AzureBackupParams != nil {
		var azureBackupParam AzureBackupParams_STATUS
		err := azureBackupParam.AssignProperties_From_AzureBackupParams_STATUS(source.AzureBackupParams)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AzureBackupParams_STATUS() to populate field AzureBackupParams")
		}
		parameters.AzureBackupParams = &azureBackupParam
	} else {
		parameters.AzureBackupParams = nil
	}

	// No error
	return nil
}

// AssignProperties_To_BackupParameters_STATUS populates the provided destination BackupParameters_STATUS from our BackupParameters_STATUS
func (parameters *BackupParameters_STATUS) AssignProperties_To_BackupParameters_STATUS(destination *storage.BackupParameters_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureBackupParams
	if parameters.AzureBackupParams != nil {
		var azureBackupParam storage.AzureBackupParams_STATUS
		err := parameters.AzureBackupParams.AssignProperties_To_AzureBackupParams_STATUS(&azureBackupParam)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AzureBackupParams_STATUS() to populate field AzureBackupParams")
		}
		destination.AzureBackupParams = &azureBackupParam
	} else {
		destination.AzureBackupParams = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// DataStoreInfo base
type DataStoreInfoBase struct {
	// +kubebuilder:validation:Required
	// DataStoreType: type of datastore; Operational/Vault/Archive
	DataStoreType *DataStoreInfoBase_DataStoreType `json:"dataStoreType,omitempty"`

	// +kubebuilder:validation:Required
	// ObjectType: Type of Datasource object, used to initialize the right inherited type
	ObjectType *string `json:"objectType,omitempty"`
}

var _ genruntime.ARMTransformer = &DataStoreInfoBase{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (base *DataStoreInfoBase) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if base == nil {
		return nil, nil
	}
	result := &arm.DataStoreInfoBase{}

	// Set property "DataStoreType":
	if base.DataStoreType != nil {
		var temp string
		temp = string(*base.DataStoreType)
		dataStoreType := arm.DataStoreInfoBase_DataStoreType(temp)
		result.DataStoreType = &dataStoreType
	}

	// Set property "ObjectType":
	if base.ObjectType != nil {
		objectType := *base.ObjectType
		result.ObjectType = &objectType
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (base *DataStoreInfoBase) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DataStoreInfoBase{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (base *DataStoreInfoBase) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DataStoreInfoBase)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DataStoreInfoBase, got %T", armInput)
	}

	// Set property "DataStoreType":
	if typedInput.DataStoreType != nil {
		var temp string
		temp = string(*typedInput.DataStoreType)
		dataStoreType := DataStoreInfoBase_DataStoreType(temp)
		base.DataStoreType = &dataStoreType
	}

	// Set property "ObjectType":
	if typedInput.ObjectType != nil {
		objectType := *typedInput.ObjectType
		base.ObjectType = &objectType
	}

	// No error
	return nil
}

// AssignProperties_From_DataStoreInfoBase populates our DataStoreInfoBase from the provided source DataStoreInfoBase
func (base *DataStoreInfoBase) AssignProperties_From_DataStoreInfoBase(source *storage.DataStoreInfoBase) error {

	// DataStoreType
	if source.DataStoreType != nil {
		dataStoreType := *source.DataStoreType
		dataStoreTypeTemp := genruntime.ToEnum(dataStoreType, dataStoreInfoBase_DataStoreType_Values)
		base.DataStoreType = &dataStoreTypeTemp
	} else {
		base.DataStoreType = nil
	}

	// ObjectType
	base.ObjectType = genruntime.ClonePointerToString(source.ObjectType)

	// No error
	return nil
}

// AssignProperties_To_DataStoreInfoBase populates the provided destination DataStoreInfoBase from our DataStoreInfoBase
func (base *DataStoreInfoBase) AssignProperties_To_DataStoreInfoBase(destination *storage.DataStoreInfoBase) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DataStoreType
	if base.DataStoreType != nil {
		dataStoreType := string(*base.DataStoreType)
		destination.DataStoreType = &dataStoreType
	} else {
		destination.DataStoreType = nil
	}

	// ObjectType
	destination.ObjectType = genruntime.ClonePointerToString(base.ObjectType)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// DataStoreInfo base
type DataStoreInfoBase_STATUS struct {
	// DataStoreType: type of datastore; Operational/Vault/Archive
	DataStoreType *DataStoreInfoBase_DataStoreType_STATUS `json:"dataStoreType,omitempty"`

	// ObjectType: Type of Datasource object, used to initialize the right inherited type
	ObjectType *string `json:"objectType,omitempty"`
}

var _ genruntime.FromARMConverter = &DataStoreInfoBase_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (base *DataStoreInfoBase_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DataStoreInfoBase_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (base *DataStoreInfoBase_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DataStoreInfoBase_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DataStoreInfoBase_STATUS, got %T", armInput)
	}

	// Set property "DataStoreType":
	if typedInput.DataStoreType != nil {
		var temp string
		temp = string(*typedInput.DataStoreType)
		dataStoreType := DataStoreInfoBase_DataStoreType_STATUS(temp)
		base.DataStoreType = &dataStoreType
	}

	// Set property "ObjectType":
	if typedInput.ObjectType != nil {
		objectType := *typedInput.ObjectType
		base.ObjectType = &objectType
	}

	// No error
	return nil
}

// AssignProperties_From_DataStoreInfoBase_STATUS populates our DataStoreInfoBase_STATUS from the provided source DataStoreInfoBase_STATUS
func (base *DataStoreInfoBase_STATUS) AssignProperties_From_DataStoreInfoBase_STATUS(source *storage.DataStoreInfoBase_STATUS) error {

	// DataStoreType
	if source.DataStoreType != nil {
		dataStoreType := *source.DataStoreType
		dataStoreTypeTemp := genruntime.ToEnum(dataStoreType, dataStoreInfoBase_DataStoreType_STATUS_Values)
		base.DataStoreType = &dataStoreTypeTemp
	} else {
		base.DataStoreType = nil
	}

	// ObjectType
	base.ObjectType = genruntime.ClonePointerToString(source.ObjectType)

	// No error
	return nil
}

// AssignProperties_To_DataStoreInfoBase_STATUS populates the provided destination DataStoreInfoBase_STATUS from our DataStoreInfoBase_STATUS
func (base *DataStoreInfoBase_STATUS) AssignProperties_To_DataStoreInfoBase_STATUS(destination *storage.DataStoreInfoBase_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DataStoreType
	if base.DataStoreType != nil {
		dataStoreType := string(*base.DataStoreType)
		destination.DataStoreType = &dataStoreType
	} else {
		destination.DataStoreType = nil
	}

	// ObjectType
	destination.ObjectType = genruntime.ClonePointerToString(base.ObjectType)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Source LifeCycle
type SourceLifeCycle struct {
	// +kubebuilder:validation:Required
	DeleteAfter *DeleteOption `json:"deleteAfter,omitempty"`

	// +kubebuilder:validation:Required
	// SourceDataStore: DataStoreInfo base
	SourceDataStore             *DataStoreInfoBase  `json:"sourceDataStore,omitempty"`
	TargetDataStoreCopySettings []TargetCopySetting `json:"targetDataStoreCopySettings,omitempty"`
}

var _ genruntime.ARMTransformer = &SourceLifeCycle{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (cycle *SourceLifeCycle) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if cycle == nil {
		return nil, nil
	}
	result := &arm.SourceLifeCycle{}

	// Set property "DeleteAfter":
	if cycle.DeleteAfter != nil {
		deleteAfter_ARM, err := (*cycle.DeleteAfter).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		deleteAfter := *deleteAfter_ARM.(*arm.DeleteOption)
		result.DeleteAfter = &deleteAfter
	}

	// Set property "SourceDataStore":
	if cycle.SourceDataStore != nil {
		sourceDataStore_ARM, err := (*cycle.SourceDataStore).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		sourceDataStore := *sourceDataStore_ARM.(*arm.DataStoreInfoBase)
		result.SourceDataStore = &sourceDataStore
	}

	// Set property "TargetDataStoreCopySettings":
	for _, item := range cycle.TargetDataStoreCopySettings {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.TargetDataStoreCopySettings = append(result.TargetDataStoreCopySettings, *item_ARM.(*arm.TargetCopySetting))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (cycle *SourceLifeCycle) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SourceLifeCycle{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (cycle *SourceLifeCycle) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SourceLifeCycle)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SourceLifeCycle, got %T", armInput)
	}

	// Set property "DeleteAfter":
	if typedInput.DeleteAfter != nil {
		var deleteAfter1 DeleteOption
		err := deleteAfter1.PopulateFromARM(owner, *typedInput.DeleteAfter)
		if err != nil {
			return err
		}
		deleteAfter := deleteAfter1
		cycle.DeleteAfter = &deleteAfter
	}

	// Set property "SourceDataStore":
	if typedInput.SourceDataStore != nil {
		var sourceDataStore1 DataStoreInfoBase
		err := sourceDataStore1.PopulateFromARM(owner, *typedInput.SourceDataStore)
		if err != nil {
			return err
		}
		sourceDataStore := sourceDataStore1
		cycle.SourceDataStore = &sourceDataStore
	}

	// Set property "TargetDataStoreCopySettings":
	for _, item := range typedInput.TargetDataStoreCopySettings {
		var item1 TargetCopySetting
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		cycle.TargetDataStoreCopySettings = append(cycle.TargetDataStoreCopySettings, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_SourceLifeCycle populates our SourceLifeCycle from the provided source SourceLifeCycle
func (cycle *SourceLifeCycle) AssignProperties_From_SourceLifeCycle(source *storage.SourceLifeCycle) error {

	// DeleteAfter
	if source.DeleteAfter != nil {
		var deleteAfter DeleteOption
		err := deleteAfter.AssignProperties_From_DeleteOption(source.DeleteAfter)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_DeleteOption() to populate field DeleteAfter")
		}
		cycle.DeleteAfter = &deleteAfter
	} else {
		cycle.DeleteAfter = nil
	}

	// SourceDataStore
	if source.SourceDataStore != nil {
		var sourceDataStore DataStoreInfoBase
		err := sourceDataStore.AssignProperties_From_DataStoreInfoBase(source.SourceDataStore)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_DataStoreInfoBase() to populate field SourceDataStore")
		}
		cycle.SourceDataStore = &sourceDataStore
	} else {
		cycle.SourceDataStore = nil
	}

	// TargetDataStoreCopySettings
	if source.TargetDataStoreCopySettings != nil {
		targetDataStoreCopySettingList := make([]TargetCopySetting, len(source.TargetDataStoreCopySettings))
		for targetDataStoreCopySettingIndex, targetDataStoreCopySettingItem := range source.TargetDataStoreCopySettings {
			// Shadow the loop variable to avoid aliasing
			targetDataStoreCopySettingItem := targetDataStoreCopySettingItem
			var targetDataStoreCopySetting TargetCopySetting
			err := targetDataStoreCopySetting.AssignProperties_From_TargetCopySetting(&targetDataStoreCopySettingItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_TargetCopySetting() to populate field TargetDataStoreCopySettings")
			}
			targetDataStoreCopySettingList[targetDataStoreCopySettingIndex] = targetDataStoreCopySetting
		}
		cycle.TargetDataStoreCopySettings = targetDataStoreCopySettingList
	} else {
		cycle.TargetDataStoreCopySettings = nil
	}

	// No error
	return nil
}

// AssignProperties_To_SourceLifeCycle populates the provided destination SourceLifeCycle from our SourceLifeCycle
func (cycle *SourceLifeCycle) AssignProperties_To_SourceLifeCycle(destination *storage.SourceLifeCycle) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DeleteAfter
	if cycle.DeleteAfter != nil {
		var deleteAfter storage.DeleteOption
		err := cycle.DeleteAfter.AssignProperties_To_DeleteOption(&deleteAfter)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_DeleteOption() to populate field DeleteAfter")
		}
		destination.DeleteAfter = &deleteAfter
	} else {
		destination.DeleteAfter = nil
	}

	// SourceDataStore
	if cycle.SourceDataStore != nil {
		var sourceDataStore storage.DataStoreInfoBase
		err := cycle.SourceDataStore.AssignProperties_To_DataStoreInfoBase(&sourceDataStore)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_DataStoreInfoBase() to populate field SourceDataStore")
		}
		destination.SourceDataStore = &sourceDataStore
	} else {
		destination.SourceDataStore = nil
	}

	// TargetDataStoreCopySettings
	if cycle.TargetDataStoreCopySettings != nil {
		targetDataStoreCopySettingList := make([]storage.TargetCopySetting, len(cycle.TargetDataStoreCopySettings))
		for targetDataStoreCopySettingIndex, targetDataStoreCopySettingItem := range cycle.TargetDataStoreCopySettings {
			// Shadow the loop variable to avoid aliasing
			targetDataStoreCopySettingItem := targetDataStoreCopySettingItem
			var targetDataStoreCopySetting storage.TargetCopySetting
			err := targetDataStoreCopySettingItem.AssignProperties_To_TargetCopySetting(&targetDataStoreCopySetting)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_TargetCopySetting() to populate field TargetDataStoreCopySettings")
			}
			targetDataStoreCopySettingList[targetDataStoreCopySettingIndex] = targetDataStoreCopySetting
		}
		destination.TargetDataStoreCopySettings = targetDataStoreCopySettingList
	} else {
		destination.TargetDataStoreCopySettings = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Source LifeCycle
type SourceLifeCycle_STATUS struct {
	DeleteAfter *DeleteOption_STATUS `json:"deleteAfter,omitempty"`

	// SourceDataStore: DataStoreInfo base
	SourceDataStore             *DataStoreInfoBase_STATUS  `json:"sourceDataStore,omitempty"`
	TargetDataStoreCopySettings []TargetCopySetting_STATUS `json:"targetDataStoreCopySettings,omitempty"`
}

var _ genruntime.FromARMConverter = &SourceLifeCycle_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (cycle *SourceLifeCycle_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SourceLifeCycle_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (cycle *SourceLifeCycle_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SourceLifeCycle_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SourceLifeCycle_STATUS, got %T", armInput)
	}

	// Set property "DeleteAfter":
	if typedInput.DeleteAfter != nil {
		var deleteAfter1 DeleteOption_STATUS
		err := deleteAfter1.PopulateFromARM(owner, *typedInput.DeleteAfter)
		if err != nil {
			return err
		}
		deleteAfter := deleteAfter1
		cycle.DeleteAfter = &deleteAfter
	}

	// Set property "SourceDataStore":
	if typedInput.SourceDataStore != nil {
		var sourceDataStore1 DataStoreInfoBase_STATUS
		err := sourceDataStore1.PopulateFromARM(owner, *typedInput.SourceDataStore)
		if err != nil {
			return err
		}
		sourceDataStore := sourceDataStore1
		cycle.SourceDataStore = &sourceDataStore
	}

	// Set property "TargetDataStoreCopySettings":
	for _, item := range typedInput.TargetDataStoreCopySettings {
		var item1 TargetCopySetting_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		cycle.TargetDataStoreCopySettings = append(cycle.TargetDataStoreCopySettings, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_SourceLifeCycle_STATUS populates our SourceLifeCycle_STATUS from the provided source SourceLifeCycle_STATUS
func (cycle *SourceLifeCycle_STATUS) AssignProperties_From_SourceLifeCycle_STATUS(source *storage.SourceLifeCycle_STATUS) error {

	// DeleteAfter
	if source.DeleteAfter != nil {
		var deleteAfter DeleteOption_STATUS
		err := deleteAfter.AssignProperties_From_DeleteOption_STATUS(source.DeleteAfter)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_DeleteOption_STATUS() to populate field DeleteAfter")
		}
		cycle.DeleteAfter = &deleteAfter
	} else {
		cycle.DeleteAfter = nil
	}

	// SourceDataStore
	if source.SourceDataStore != nil {
		var sourceDataStore DataStoreInfoBase_STATUS
		err := sourceDataStore.AssignProperties_From_DataStoreInfoBase_STATUS(source.SourceDataStore)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_DataStoreInfoBase_STATUS() to populate field SourceDataStore")
		}
		cycle.SourceDataStore = &sourceDataStore
	} else {
		cycle.SourceDataStore = nil
	}

	// TargetDataStoreCopySettings
	if source.TargetDataStoreCopySettings != nil {
		targetDataStoreCopySettingList := make([]TargetCopySetting_STATUS, len(source.TargetDataStoreCopySettings))
		for targetDataStoreCopySettingIndex, targetDataStoreCopySettingItem := range source.TargetDataStoreCopySettings {
			// Shadow the loop variable to avoid aliasing
			targetDataStoreCopySettingItem := targetDataStoreCopySettingItem
			var targetDataStoreCopySetting TargetCopySetting_STATUS
			err := targetDataStoreCopySetting.AssignProperties_From_TargetCopySetting_STATUS(&targetDataStoreCopySettingItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_TargetCopySetting_STATUS() to populate field TargetDataStoreCopySettings")
			}
			targetDataStoreCopySettingList[targetDataStoreCopySettingIndex] = targetDataStoreCopySetting
		}
		cycle.TargetDataStoreCopySettings = targetDataStoreCopySettingList
	} else {
		cycle.TargetDataStoreCopySettings = nil
	}

	// No error
	return nil
}

// AssignProperties_To_SourceLifeCycle_STATUS populates the provided destination SourceLifeCycle_STATUS from our SourceLifeCycle_STATUS
func (cycle *SourceLifeCycle_STATUS) AssignProperties_To_SourceLifeCycle_STATUS(destination *storage.SourceLifeCycle_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DeleteAfter
	if cycle.DeleteAfter != nil {
		var deleteAfter storage.DeleteOption_STATUS
		err := cycle.DeleteAfter.AssignProperties_To_DeleteOption_STATUS(&deleteAfter)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_DeleteOption_STATUS() to populate field DeleteAfter")
		}
		destination.DeleteAfter = &deleteAfter
	} else {
		destination.DeleteAfter = nil
	}

	// SourceDataStore
	if cycle.SourceDataStore != nil {
		var sourceDataStore storage.DataStoreInfoBase_STATUS
		err := cycle.SourceDataStore.AssignProperties_To_DataStoreInfoBase_STATUS(&sourceDataStore)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_DataStoreInfoBase_STATUS() to populate field SourceDataStore")
		}
		destination.SourceDataStore = &sourceDataStore
	} else {
		destination.SourceDataStore = nil
	}

	// TargetDataStoreCopySettings
	if cycle.TargetDataStoreCopySettings != nil {
		targetDataStoreCopySettingList := make([]storage.TargetCopySetting_STATUS, len(cycle.TargetDataStoreCopySettings))
		for targetDataStoreCopySettingIndex, targetDataStoreCopySettingItem := range cycle.TargetDataStoreCopySettings {
			// Shadow the loop variable to avoid aliasing
			targetDataStoreCopySettingItem := targetDataStoreCopySettingItem
			var targetDataStoreCopySetting storage.TargetCopySetting_STATUS
			err := targetDataStoreCopySettingItem.AssignProperties_To_TargetCopySetting_STATUS(&targetDataStoreCopySetting)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_TargetCopySetting_STATUS() to populate field TargetDataStoreCopySettings")
			}
			targetDataStoreCopySettingList[targetDataStoreCopySettingIndex] = targetDataStoreCopySetting
		}
		destination.TargetDataStoreCopySettings = targetDataStoreCopySettingList
	} else {
		destination.TargetDataStoreCopySettings = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type TriggerContext struct {
	// Adhoc: Mutually exclusive with all other properties
	Adhoc *AdhocBasedTriggerContext `json:"adhocBasedTriggerContext,omitempty"`

	// Schedule: Mutually exclusive with all other properties
	Schedule *ScheduleBasedTriggerContext `json:"scheduleBasedTriggerContext,omitempty"`
}

var _ genruntime.ARMTransformer = &TriggerContext{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (context *TriggerContext) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if context == nil {
		return nil, nil
	}
	result := &arm.TriggerContext{}

	// Set property "Adhoc":
	if context.Adhoc != nil {
		adhoc_ARM, err := (*context.Adhoc).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		adhoc := *adhoc_ARM.(*arm.AdhocBasedTriggerContext)
		result.Adhoc = &adhoc
	}

	// Set property "Schedule":
	if context.Schedule != nil {
		schedule_ARM, err := (*context.Schedule).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		schedule := *schedule_ARM.(*arm.ScheduleBasedTriggerContext)
		result.Schedule = &schedule
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (context *TriggerContext) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.TriggerContext{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (context *TriggerContext) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.TriggerContext)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.TriggerContext, got %T", armInput)
	}

	// Set property "Adhoc":
	if typedInput.Adhoc != nil {
		var adhoc1 AdhocBasedTriggerContext
		err := adhoc1.PopulateFromARM(owner, *typedInput.Adhoc)
		if err != nil {
			return err
		}
		adhoc := adhoc1
		context.Adhoc = &adhoc
	}

	// Set property "Schedule":
	if typedInput.Schedule != nil {
		var schedule1 ScheduleBasedTriggerContext
		err := schedule1.PopulateFromARM(owner, *typedInput.Schedule)
		if err != nil {
			return err
		}
		schedule := schedule1
		context.Schedule = &schedule
	}

	// No error
	return nil
}

// AssignProperties_From_TriggerContext populates our TriggerContext from the provided source TriggerContext
func (context *TriggerContext) AssignProperties_From_TriggerContext(source *storage.TriggerContext) error {

	// Adhoc
	if source.Adhoc != nil {
		var adhoc AdhocBasedTriggerContext
		err := adhoc.AssignProperties_From_AdhocBasedTriggerContext(source.Adhoc)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AdhocBasedTriggerContext() to populate field Adhoc")
		}
		context.Adhoc = &adhoc
	} else {
		context.Adhoc = nil
	}

	// Schedule
	if source.Schedule != nil {
		var schedule ScheduleBasedTriggerContext
		err := schedule.AssignProperties_From_ScheduleBasedTriggerContext(source.Schedule)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ScheduleBasedTriggerContext() to populate field Schedule")
		}
		context.Schedule = &schedule
	} else {
		context.Schedule = nil
	}

	// No error
	return nil
}

// AssignProperties_To_TriggerContext populates the provided destination TriggerContext from our TriggerContext
func (context *TriggerContext) AssignProperties_To_TriggerContext(destination *storage.TriggerContext) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Adhoc
	if context.Adhoc != nil {
		var adhoc storage.AdhocBasedTriggerContext
		err := context.Adhoc.AssignProperties_To_AdhocBasedTriggerContext(&adhoc)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AdhocBasedTriggerContext() to populate field Adhoc")
		}
		destination.Adhoc = &adhoc
	} else {
		destination.Adhoc = nil
	}

	// Schedule
	if context.Schedule != nil {
		var schedule storage.ScheduleBasedTriggerContext
		err := context.Schedule.AssignProperties_To_ScheduleBasedTriggerContext(&schedule)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ScheduleBasedTriggerContext() to populate field Schedule")
		}
		destination.Schedule = &schedule
	} else {
		destination.Schedule = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type TriggerContext_STATUS struct {
	// Adhoc: Mutually exclusive with all other properties
	Adhoc *AdhocBasedTriggerContext_STATUS `json:"adhocBasedTriggerContext,omitempty"`

	// Schedule: Mutually exclusive with all other properties
	Schedule *ScheduleBasedTriggerContext_STATUS `json:"scheduleBasedTriggerContext,omitempty"`
}

var _ genruntime.FromARMConverter = &TriggerContext_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (context *TriggerContext_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.TriggerContext_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (context *TriggerContext_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.TriggerContext_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.TriggerContext_STATUS, got %T", armInput)
	}

	// Set property "Adhoc":
	if typedInput.Adhoc != nil {
		var adhoc1 AdhocBasedTriggerContext_STATUS
		err := adhoc1.PopulateFromARM(owner, *typedInput.Adhoc)
		if err != nil {
			return err
		}
		adhoc := adhoc1
		context.Adhoc = &adhoc
	}

	// Set property "Schedule":
	if typedInput.Schedule != nil {
		var schedule1 ScheduleBasedTriggerContext_STATUS
		err := schedule1.PopulateFromARM(owner, *typedInput.Schedule)
		if err != nil {
			return err
		}
		schedule := schedule1
		context.Schedule = &schedule
	}

	// No error
	return nil
}

// AssignProperties_From_TriggerContext_STATUS populates our TriggerContext_STATUS from the provided source TriggerContext_STATUS
func (context *TriggerContext_STATUS) AssignProperties_From_TriggerContext_STATUS(source *storage.TriggerContext_STATUS) error {

	// Adhoc
	if source.Adhoc != nil {
		var adhoc AdhocBasedTriggerContext_STATUS
		err := adhoc.AssignProperties_From_AdhocBasedTriggerContext_STATUS(source.Adhoc)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AdhocBasedTriggerContext_STATUS() to populate field Adhoc")
		}
		context.Adhoc = &adhoc
	} else {
		context.Adhoc = nil
	}

	// Schedule
	if source.Schedule != nil {
		var schedule ScheduleBasedTriggerContext_STATUS
		err := schedule.AssignProperties_From_ScheduleBasedTriggerContext_STATUS(source.Schedule)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ScheduleBasedTriggerContext_STATUS() to populate field Schedule")
		}
		context.Schedule = &schedule
	} else {
		context.Schedule = nil
	}

	// No error
	return nil
}

// AssignProperties_To_TriggerContext_STATUS populates the provided destination TriggerContext_STATUS from our TriggerContext_STATUS
func (context *TriggerContext_STATUS) AssignProperties_To_TriggerContext_STATUS(destination *storage.TriggerContext_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Adhoc
	if context.Adhoc != nil {
		var adhoc storage.AdhocBasedTriggerContext_STATUS
		err := context.Adhoc.AssignProperties_To_AdhocBasedTriggerContext_STATUS(&adhoc)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AdhocBasedTriggerContext_STATUS() to populate field Adhoc")
		}
		destination.Adhoc = &adhoc
	} else {
		destination.Adhoc = nil
	}

	// Schedule
	if context.Schedule != nil {
		var schedule storage.ScheduleBasedTriggerContext_STATUS
		err := context.Schedule.AssignProperties_To_ScheduleBasedTriggerContext_STATUS(&schedule)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ScheduleBasedTriggerContext_STATUS() to populate field Schedule")
		}
		destination.Schedule = &schedule
	} else {
		destination.Schedule = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type AdhocBasedTriggerContext struct {
	// +kubebuilder:validation:Required
	// ObjectType: Type of the specific object - used for deserializing
	ObjectType *AdhocBasedTriggerContext_ObjectType `json:"objectType,omitempty"`

	// +kubebuilder:validation:Required
	// TaggingCriteria: Tagging Criteria containing retention tag for adhoc backup.
	TaggingCriteria *AdhocBasedTaggingCriteria `json:"taggingCriteria,omitempty"`
}

var _ genruntime.ARMTransformer = &AdhocBasedTriggerContext{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (context *AdhocBasedTriggerContext) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if context == nil {
		return nil, nil
	}
	result := &arm.AdhocBasedTriggerContext{}

	// Set property "ObjectType":
	if context.ObjectType != nil {
		var temp arm.AdhocBasedTriggerContext_ObjectType
		var temp1 string
		temp1 = string(*context.ObjectType)
		temp = arm.AdhocBasedTriggerContext_ObjectType(temp1)
		result.ObjectType = temp
	}

	// Set property "TaggingCriteria":
	if context.TaggingCriteria != nil {
		taggingCriteria_ARM, err := (*context.TaggingCriteria).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		taggingCriteria := *taggingCriteria_ARM.(*arm.AdhocBasedTaggingCriteria)
		result.TaggingCriteria = &taggingCriteria
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (context *AdhocBasedTriggerContext) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AdhocBasedTriggerContext{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (context *AdhocBasedTriggerContext) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AdhocBasedTriggerContext)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AdhocBasedTriggerContext, got %T", armInput)
	}

	// Set property "ObjectType":
	var temp AdhocBasedTriggerContext_ObjectType
	var temp1 string
	temp1 = string(typedInput.ObjectType)
	temp = AdhocBasedTriggerContext_ObjectType(temp1)
	context.ObjectType = &temp

	// Set property "TaggingCriteria":
	if typedInput.TaggingCriteria != nil {
		var taggingCriteria1 AdhocBasedTaggingCriteria
		err := taggingCriteria1.PopulateFromARM(owner, *typedInput.TaggingCriteria)
		if err != nil {
			return err
		}
		taggingCriteria := taggingCriteria1
		context.TaggingCriteria = &taggingCriteria
	}

	// No error
	return nil
}

// AssignProperties_From_AdhocBasedTriggerContext populates our AdhocBasedTriggerContext from the provided source AdhocBasedTriggerContext
func (context *AdhocBasedTriggerContext) AssignProperties_From_AdhocBasedTriggerContext(source *storage.AdhocBasedTriggerContext) error {

	// ObjectType
	if source.ObjectType != nil {
		objectType := *source.ObjectType
		objectTypeTemp := genruntime.ToEnum(objectType, adhocBasedTriggerContext_ObjectType_Values)
		context.ObjectType = &objectTypeTemp
	} else {
		context.ObjectType = nil
	}

	// TaggingCriteria
	if source.TaggingCriteria != nil {
		var taggingCriterion AdhocBasedTaggingCriteria
		err := taggingCriterion.AssignProperties_From_AdhocBasedTaggingCriteria(source.TaggingCriteria)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AdhocBasedTaggingCriteria() to populate field TaggingCriteria")
		}
		context.TaggingCriteria = &taggingCriterion
	} else {
		context.TaggingCriteria = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AdhocBasedTriggerContext populates the provided destination AdhocBasedTriggerContext from our AdhocBasedTriggerContext
func (context *AdhocBasedTriggerContext) AssignProperties_To_AdhocBasedTriggerContext(destination *storage.AdhocBasedTriggerContext) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ObjectType
	if context.ObjectType != nil {
		objectType := string(*context.ObjectType)
		destination.ObjectType = &objectType
	} else {
		destination.ObjectType = nil
	}

	// TaggingCriteria
	if context.TaggingCriteria != nil {
		var taggingCriterion storage.AdhocBasedTaggingCriteria
		err := context.TaggingCriteria.AssignProperties_To_AdhocBasedTaggingCriteria(&taggingCriterion)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AdhocBasedTaggingCriteria() to populate field TaggingCriteria")
		}
		destination.TaggingCriteria = &taggingCriterion
	} else {
		destination.TaggingCriteria = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type AdhocBasedTriggerContext_STATUS struct {
	// ObjectType: Type of the specific object - used for deserializing
	ObjectType *AdhocBasedTriggerContext_ObjectType_STATUS `json:"objectType,omitempty"`

	// TaggingCriteria: Tagging Criteria containing retention tag for adhoc backup.
	TaggingCriteria *AdhocBasedTaggingCriteria_STATUS `json:"taggingCriteria,omitempty"`
}

var _ genruntime.FromARMConverter = &AdhocBasedTriggerContext_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (context *AdhocBasedTriggerContext_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AdhocBasedTriggerContext_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (context *AdhocBasedTriggerContext_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AdhocBasedTriggerContext_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AdhocBasedTriggerContext_STATUS, got %T", armInput)
	}

	// Set property "ObjectType":
	var temp AdhocBasedTriggerContext_ObjectType_STATUS
	var temp1 string
	temp1 = string(typedInput.ObjectType)
	temp = AdhocBasedTriggerContext_ObjectType_STATUS(temp1)
	context.ObjectType = &temp

	// Set property "TaggingCriteria":
	if typedInput.TaggingCriteria != nil {
		var taggingCriteria1 AdhocBasedTaggingCriteria_STATUS
		err := taggingCriteria1.PopulateFromARM(owner, *typedInput.TaggingCriteria)
		if err != nil {
			return err
		}
		taggingCriteria := taggingCriteria1
		context.TaggingCriteria = &taggingCriteria
	}

	// No error
	return nil
}

// AssignProperties_From_AdhocBasedTriggerContext_STATUS populates our AdhocBasedTriggerContext_STATUS from the provided source AdhocBasedTriggerContext_STATUS
func (context *AdhocBasedTriggerContext_STATUS) AssignProperties_From_AdhocBasedTriggerContext_STATUS(source *storage.AdhocBasedTriggerContext_STATUS) error {

	// ObjectType
	if source.ObjectType != nil {
		objectType := *source.ObjectType
		objectTypeTemp := genruntime.ToEnum(objectType, adhocBasedTriggerContext_ObjectType_STATUS_Values)
		context.ObjectType = &objectTypeTemp
	} else {
		context.ObjectType = nil
	}

	// TaggingCriteria
	if source.TaggingCriteria != nil {
		var taggingCriterion AdhocBasedTaggingCriteria_STATUS
		err := taggingCriterion.AssignProperties_From_AdhocBasedTaggingCriteria_STATUS(source.TaggingCriteria)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AdhocBasedTaggingCriteria_STATUS() to populate field TaggingCriteria")
		}
		context.TaggingCriteria = &taggingCriterion
	} else {
		context.TaggingCriteria = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AdhocBasedTriggerContext_STATUS populates the provided destination AdhocBasedTriggerContext_STATUS from our AdhocBasedTriggerContext_STATUS
func (context *AdhocBasedTriggerContext_STATUS) AssignProperties_To_AdhocBasedTriggerContext_STATUS(destination *storage.AdhocBasedTriggerContext_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ObjectType
	if context.ObjectType != nil {
		objectType := string(*context.ObjectType)
		destination.ObjectType = &objectType
	} else {
		destination.ObjectType = nil
	}

	// TaggingCriteria
	if context.TaggingCriteria != nil {
		var taggingCriterion storage.AdhocBasedTaggingCriteria_STATUS
		err := context.TaggingCriteria.AssignProperties_To_AdhocBasedTaggingCriteria_STATUS(&taggingCriterion)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AdhocBasedTaggingCriteria_STATUS() to populate field TaggingCriteria")
		}
		destination.TaggingCriteria = &taggingCriterion
	} else {
		destination.TaggingCriteria = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type AzureBackupParams struct {
	// +kubebuilder:validation:Required
	// BackupType: BackupType ; Full/Incremental etc
	BackupType *string `json:"backupType,omitempty"`

	// +kubebuilder:validation:Required
	// ObjectType: Type of the specific object - used for deserializing
	ObjectType *AzureBackupParams_ObjectType `json:"objectType,omitempty"`
}

var _ genruntime.ARMTransformer = &AzureBackupParams{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (params *AzureBackupParams) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if params == nil {
		return nil, nil
	}
	result := &arm.AzureBackupParams{}

	// Set property "BackupType":
	if params.BackupType != nil {
		backupType := *params.BackupType
		result.BackupType = &backupType
	}

	// Set property "ObjectType":
	if params.ObjectType != nil {
		var temp arm.AzureBackupParams_ObjectType
		var temp1 string
		temp1 = string(*params.ObjectType)
		temp = arm.AzureBackupParams_ObjectType(temp1)
		result.ObjectType = temp
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (params *AzureBackupParams) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AzureBackupParams{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (params *AzureBackupParams) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AzureBackupParams)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AzureBackupParams, got %T", armInput)
	}

	// Set property "BackupType":
	if typedInput.BackupType != nil {
		backupType := *typedInput.BackupType
		params.BackupType = &backupType
	}

	// Set property "ObjectType":
	var temp AzureBackupParams_ObjectType
	var temp1 string
	temp1 = string(typedInput.ObjectType)
	temp = AzureBackupParams_ObjectType(temp1)
	params.ObjectType = &temp

	// No error
	return nil
}

// AssignProperties_From_AzureBackupParams populates our AzureBackupParams from the provided source AzureBackupParams
func (params *AzureBackupParams) AssignProperties_From_AzureBackupParams(source *storage.AzureBackupParams) error {

	// BackupType
	params.BackupType = genruntime.ClonePointerToString(source.BackupType)

	// ObjectType
	if source.ObjectType != nil {
		objectType := *source.ObjectType
		objectTypeTemp := genruntime.ToEnum(objectType, azureBackupParams_ObjectType_Values)
		params.ObjectType = &objectTypeTemp
	} else {
		params.ObjectType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AzureBackupParams populates the provided destination AzureBackupParams from our AzureBackupParams
func (params *AzureBackupParams) AssignProperties_To_AzureBackupParams(destination *storage.AzureBackupParams) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BackupType
	destination.BackupType = genruntime.ClonePointerToString(params.BackupType)

	// ObjectType
	if params.ObjectType != nil {
		objectType := string(*params.ObjectType)
		destination.ObjectType = &objectType
	} else {
		destination.ObjectType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type AzureBackupParams_STATUS struct {
	// BackupType: BackupType ; Full/Incremental etc
	BackupType *string `json:"backupType,omitempty"`

	// ObjectType: Type of the specific object - used for deserializing
	ObjectType *AzureBackupParams_ObjectType_STATUS `json:"objectType,omitempty"`
}

var _ genruntime.FromARMConverter = &AzureBackupParams_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (params *AzureBackupParams_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AzureBackupParams_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (params *AzureBackupParams_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AzureBackupParams_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AzureBackupParams_STATUS, got %T", armInput)
	}

	// Set property "BackupType":
	if typedInput.BackupType != nil {
		backupType := *typedInput.BackupType
		params.BackupType = &backupType
	}

	// Set property "ObjectType":
	var temp AzureBackupParams_ObjectType_STATUS
	var temp1 string
	temp1 = string(typedInput.ObjectType)
	temp = AzureBackupParams_ObjectType_STATUS(temp1)
	params.ObjectType = &temp

	// No error
	return nil
}

// AssignProperties_From_AzureBackupParams_STATUS populates our AzureBackupParams_STATUS from the provided source AzureBackupParams_STATUS
func (params *AzureBackupParams_STATUS) AssignProperties_From_AzureBackupParams_STATUS(source *storage.AzureBackupParams_STATUS) error {

	// BackupType
	params.BackupType = genruntime.ClonePointerToString(source.BackupType)

	// ObjectType
	if source.ObjectType != nil {
		objectType := *source.ObjectType
		objectTypeTemp := genruntime.ToEnum(objectType, azureBackupParams_ObjectType_STATUS_Values)
		params.ObjectType = &objectTypeTemp
	} else {
		params.ObjectType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AzureBackupParams_STATUS populates the provided destination AzureBackupParams_STATUS from our AzureBackupParams_STATUS
func (params *AzureBackupParams_STATUS) AssignProperties_To_AzureBackupParams_STATUS(destination *storage.AzureBackupParams_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BackupType
	destination.BackupType = genruntime.ClonePointerToString(params.BackupType)

	// ObjectType
	if params.ObjectType != nil {
		objectType := string(*params.ObjectType)
		destination.ObjectType = &objectType
	} else {
		destination.ObjectType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"ArchiveStore","OperationalStore","VaultStore"}
type DataStoreInfoBase_DataStoreType string

const (
	DataStoreInfoBase_DataStoreType_ArchiveStore     = DataStoreInfoBase_DataStoreType("ArchiveStore")
	DataStoreInfoBase_DataStoreType_OperationalStore = DataStoreInfoBase_DataStoreType("OperationalStore")
	DataStoreInfoBase_DataStoreType_VaultStore       = DataStoreInfoBase_DataStoreType("VaultStore")
)

// Mapping from string to DataStoreInfoBase_DataStoreType
var dataStoreInfoBase_DataStoreType_Values = map[string]DataStoreInfoBase_DataStoreType{
	"archivestore":     DataStoreInfoBase_DataStoreType_ArchiveStore,
	"operationalstore": DataStoreInfoBase_DataStoreType_OperationalStore,
	"vaultstore":       DataStoreInfoBase_DataStoreType_VaultStore,
}

type DataStoreInfoBase_DataStoreType_STATUS string

const (
	DataStoreInfoBase_DataStoreType_STATUS_ArchiveStore     = DataStoreInfoBase_DataStoreType_STATUS("ArchiveStore")
	DataStoreInfoBase_DataStoreType_STATUS_OperationalStore = DataStoreInfoBase_DataStoreType_STATUS("OperationalStore")
	DataStoreInfoBase_DataStoreType_STATUS_VaultStore       = DataStoreInfoBase_DataStoreType_STATUS("VaultStore")
)

// Mapping from string to DataStoreInfoBase_DataStoreType_STATUS
var dataStoreInfoBase_DataStoreType_STATUS_Values = map[string]DataStoreInfoBase_DataStoreType_STATUS{
	"archivestore":     DataStoreInfoBase_DataStoreType_STATUS_ArchiveStore,
	"operationalstore": DataStoreInfoBase_DataStoreType_STATUS_OperationalStore,
	"vaultstore":       DataStoreInfoBase_DataStoreType_STATUS_VaultStore,
}

type DeleteOption struct {
	// AbsoluteDeleteOption: Mutually exclusive with all other properties
	AbsoluteDeleteOption *AbsoluteDeleteOption `json:"absoluteDeleteOption,omitempty"`
}

var _ genruntime.ARMTransformer = &DeleteOption{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (option *DeleteOption) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if option == nil {
		return nil, nil
	}
	result := &arm.DeleteOption{}

	// Set property "AbsoluteDeleteOption":
	if option.AbsoluteDeleteOption != nil {
		absoluteDeleteOption_ARM, err := (*option.AbsoluteDeleteOption).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		absoluteDeleteOption := *absoluteDeleteOption_ARM.(*arm.AbsoluteDeleteOption)
		result.AbsoluteDeleteOption = &absoluteDeleteOption
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (option *DeleteOption) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DeleteOption{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (option *DeleteOption) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DeleteOption)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DeleteOption, got %T", armInput)
	}

	// Set property "AbsoluteDeleteOption":
	if typedInput.AbsoluteDeleteOption != nil {
		var absoluteDeleteOption1 AbsoluteDeleteOption
		err := absoluteDeleteOption1.PopulateFromARM(owner, *typedInput.AbsoluteDeleteOption)
		if err != nil {
			return err
		}
		absoluteDeleteOption := absoluteDeleteOption1
		option.AbsoluteDeleteOption = &absoluteDeleteOption
	}

	// No error
	return nil
}

// AssignProperties_From_DeleteOption populates our DeleteOption from the provided source DeleteOption
func (option *DeleteOption) AssignProperties_From_DeleteOption(source *storage.DeleteOption) error {

	// AbsoluteDeleteOption
	if source.AbsoluteDeleteOption != nil {
		var absoluteDeleteOption AbsoluteDeleteOption
		err := absoluteDeleteOption.AssignProperties_From_AbsoluteDeleteOption(source.AbsoluteDeleteOption)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AbsoluteDeleteOption() to populate field AbsoluteDeleteOption")
		}
		option.AbsoluteDeleteOption = &absoluteDeleteOption
	} else {
		option.AbsoluteDeleteOption = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeleteOption populates the provided destination DeleteOption from our DeleteOption
func (option *DeleteOption) AssignProperties_To_DeleteOption(destination *storage.DeleteOption) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AbsoluteDeleteOption
	if option.AbsoluteDeleteOption != nil {
		var absoluteDeleteOption storage.AbsoluteDeleteOption
		err := option.AbsoluteDeleteOption.AssignProperties_To_AbsoluteDeleteOption(&absoluteDeleteOption)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AbsoluteDeleteOption() to populate field AbsoluteDeleteOption")
		}
		destination.AbsoluteDeleteOption = &absoluteDeleteOption
	} else {
		destination.AbsoluteDeleteOption = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type DeleteOption_STATUS struct {
	// AbsoluteDeleteOption: Mutually exclusive with all other properties
	AbsoluteDeleteOption *AbsoluteDeleteOption_STATUS `json:"absoluteDeleteOption,omitempty"`
}

var _ genruntime.FromARMConverter = &DeleteOption_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (option *DeleteOption_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DeleteOption_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (option *DeleteOption_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DeleteOption_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DeleteOption_STATUS, got %T", armInput)
	}

	// Set property "AbsoluteDeleteOption":
	if typedInput.AbsoluteDeleteOption != nil {
		var absoluteDeleteOption1 AbsoluteDeleteOption_STATUS
		err := absoluteDeleteOption1.PopulateFromARM(owner, *typedInput.AbsoluteDeleteOption)
		if err != nil {
			return err
		}
		absoluteDeleteOption := absoluteDeleteOption1
		option.AbsoluteDeleteOption = &absoluteDeleteOption
	}

	// No error
	return nil
}

// AssignProperties_From_DeleteOption_STATUS populates our DeleteOption_STATUS from the provided source DeleteOption_STATUS
func (option *DeleteOption_STATUS) AssignProperties_From_DeleteOption_STATUS(source *storage.DeleteOption_STATUS) error {

	// AbsoluteDeleteOption
	if source.AbsoluteDeleteOption != nil {
		var absoluteDeleteOption AbsoluteDeleteOption_STATUS
		err := absoluteDeleteOption.AssignProperties_From_AbsoluteDeleteOption_STATUS(source.AbsoluteDeleteOption)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AbsoluteDeleteOption_STATUS() to populate field AbsoluteDeleteOption")
		}
		option.AbsoluteDeleteOption = &absoluteDeleteOption
	} else {
		option.AbsoluteDeleteOption = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeleteOption_STATUS populates the provided destination DeleteOption_STATUS from our DeleteOption_STATUS
func (option *DeleteOption_STATUS) AssignProperties_To_DeleteOption_STATUS(destination *storage.DeleteOption_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AbsoluteDeleteOption
	if option.AbsoluteDeleteOption != nil {
		var absoluteDeleteOption storage.AbsoluteDeleteOption_STATUS
		err := option.AbsoluteDeleteOption.AssignProperties_To_AbsoluteDeleteOption_STATUS(&absoluteDeleteOption)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AbsoluteDeleteOption_STATUS() to populate field AbsoluteDeleteOption")
		}
		destination.AbsoluteDeleteOption = &absoluteDeleteOption
	} else {
		destination.AbsoluteDeleteOption = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ScheduleBasedTriggerContext struct {
	// +kubebuilder:validation:Required
	// ObjectType: Type of the specific object - used for deserializing
	ObjectType *ScheduleBasedTriggerContext_ObjectType `json:"objectType,omitempty"`

	// +kubebuilder:validation:Required
	// Schedule: Schedule for this backup
	Schedule *BackupSchedule `json:"schedule,omitempty"`

	// +kubebuilder:validation:Required
	// TaggingCriteria: List of tags that can be applicable for given schedule.
	TaggingCriteria []TaggingCriteria `json:"taggingCriteria,omitempty"`
}

var _ genruntime.ARMTransformer = &ScheduleBasedTriggerContext{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (context *ScheduleBasedTriggerContext) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if context == nil {
		return nil, nil
	}
	result := &arm.ScheduleBasedTriggerContext{}

	// Set property "ObjectType":
	if context.ObjectType != nil {
		var temp arm.ScheduleBasedTriggerContext_ObjectType
		var temp1 string
		temp1 = string(*context.ObjectType)
		temp = arm.ScheduleBasedTriggerContext_ObjectType(temp1)
		result.ObjectType = temp
	}

	// Set property "Schedule":
	if context.Schedule != nil {
		schedule_ARM, err := (*context.Schedule).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		schedule := *schedule_ARM.(*arm.BackupSchedule)
		result.Schedule = &schedule
	}

	// Set property "TaggingCriteria":
	for _, item := range context.TaggingCriteria {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.TaggingCriteria = append(result.TaggingCriteria, *item_ARM.(*arm.TaggingCriteria))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (context *ScheduleBasedTriggerContext) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ScheduleBasedTriggerContext{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (context *ScheduleBasedTriggerContext) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ScheduleBasedTriggerContext)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ScheduleBasedTriggerContext, got %T", armInput)
	}

	// Set property "ObjectType":
	var temp ScheduleBasedTriggerContext_ObjectType
	var temp1 string
	temp1 = string(typedInput.ObjectType)
	temp = ScheduleBasedTriggerContext_ObjectType(temp1)
	context.ObjectType = &temp

	// Set property "Schedule":
	if typedInput.Schedule != nil {
		var schedule1 BackupSchedule
		err := schedule1.PopulateFromARM(owner, *typedInput.Schedule)
		if err != nil {
			return err
		}
		schedule := schedule1
		context.Schedule = &schedule
	}

	// Set property "TaggingCriteria":
	for _, item := range typedInput.TaggingCriteria {
		var item1 TaggingCriteria
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		context.TaggingCriteria = append(context.TaggingCriteria, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_ScheduleBasedTriggerContext populates our ScheduleBasedTriggerContext from the provided source ScheduleBasedTriggerContext
func (context *ScheduleBasedTriggerContext) AssignProperties_From_ScheduleBasedTriggerContext(source *storage.ScheduleBasedTriggerContext) error {

	// ObjectType
	if source.ObjectType != nil {
		objectType := *source.ObjectType
		objectTypeTemp := genruntime.ToEnum(objectType, scheduleBasedTriggerContext_ObjectType_Values)
		context.ObjectType = &objectTypeTemp
	} else {
		context.ObjectType = nil
	}

	// Schedule
	if source.Schedule != nil {
		var schedule BackupSchedule
		err := schedule.AssignProperties_From_BackupSchedule(source.Schedule)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_BackupSchedule() to populate field Schedule")
		}
		context.Schedule = &schedule
	} else {
		context.Schedule = nil
	}

	// TaggingCriteria
	if source.TaggingCriteria != nil {
		taggingCriterionList := make([]TaggingCriteria, len(source.TaggingCriteria))
		for taggingCriterionIndex, taggingCriterionItem := range source.TaggingCriteria {
			// Shadow the loop variable to avoid aliasing
			taggingCriterionItem := taggingCriterionItem
			var taggingCriterion TaggingCriteria
			err := taggingCriterion.AssignProperties_From_TaggingCriteria(&taggingCriterionItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_TaggingCriteria() to populate field TaggingCriteria")
			}
			taggingCriterionList[taggingCriterionIndex] = taggingCriterion
		}
		context.TaggingCriteria = taggingCriterionList
	} else {
		context.TaggingCriteria = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ScheduleBasedTriggerContext populates the provided destination ScheduleBasedTriggerContext from our ScheduleBasedTriggerContext
func (context *ScheduleBasedTriggerContext) AssignProperties_To_ScheduleBasedTriggerContext(destination *storage.ScheduleBasedTriggerContext) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ObjectType
	if context.ObjectType != nil {
		objectType := string(*context.ObjectType)
		destination.ObjectType = &objectType
	} else {
		destination.ObjectType = nil
	}

	// Schedule
	if context.Schedule != nil {
		var schedule storage.BackupSchedule
		err := context.Schedule.AssignProperties_To_BackupSchedule(&schedule)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_BackupSchedule() to populate field Schedule")
		}
		destination.Schedule = &schedule
	} else {
		destination.Schedule = nil
	}

	// TaggingCriteria
	if context.TaggingCriteria != nil {
		taggingCriterionList := make([]storage.TaggingCriteria, len(context.TaggingCriteria))
		for taggingCriterionIndex, taggingCriterionItem := range context.TaggingCriteria {
			// Shadow the loop variable to avoid aliasing
			taggingCriterionItem := taggingCriterionItem
			var taggingCriterion storage.TaggingCriteria
			err := taggingCriterionItem.AssignProperties_To_TaggingCriteria(&taggingCriterion)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_TaggingCriteria() to populate field TaggingCriteria")
			}
			taggingCriterionList[taggingCriterionIndex] = taggingCriterion
		}
		destination.TaggingCriteria = taggingCriterionList
	} else {
		destination.TaggingCriteria = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ScheduleBasedTriggerContext_STATUS struct {
	// ObjectType: Type of the specific object - used for deserializing
	ObjectType *ScheduleBasedTriggerContext_ObjectType_STATUS `json:"objectType,omitempty"`

	// Schedule: Schedule for this backup
	Schedule *BackupSchedule_STATUS `json:"schedule,omitempty"`

	// TaggingCriteria: List of tags that can be applicable for given schedule.
	TaggingCriteria []TaggingCriteria_STATUS `json:"taggingCriteria,omitempty"`
}

var _ genruntime.FromARMConverter = &ScheduleBasedTriggerContext_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (context *ScheduleBasedTriggerContext_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ScheduleBasedTriggerContext_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (context *ScheduleBasedTriggerContext_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ScheduleBasedTriggerContext_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ScheduleBasedTriggerContext_STATUS, got %T", armInput)
	}

	// Set property "ObjectType":
	var temp ScheduleBasedTriggerContext_ObjectType_STATUS
	var temp1 string
	temp1 = string(typedInput.ObjectType)
	temp = ScheduleBasedTriggerContext_ObjectType_STATUS(temp1)
	context.ObjectType = &temp

	// Set property "Schedule":
	if typedInput.Schedule != nil {
		var schedule1 BackupSchedule_STATUS
		err := schedule1.PopulateFromARM(owner, *typedInput.Schedule)
		if err != nil {
			return err
		}
		schedule := schedule1
		context.Schedule = &schedule
	}

	// Set property "TaggingCriteria":
	for _, item := range typedInput.TaggingCriteria {
		var item1 TaggingCriteria_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		context.TaggingCriteria = append(context.TaggingCriteria, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_ScheduleBasedTriggerContext_STATUS populates our ScheduleBasedTriggerContext_STATUS from the provided source ScheduleBasedTriggerContext_STATUS
func (context *ScheduleBasedTriggerContext_STATUS) AssignProperties_From_ScheduleBasedTriggerContext_STATUS(source *storage.ScheduleBasedTriggerContext_STATUS) error {

	// ObjectType
	if source.ObjectType != nil {
		objectType := *source.ObjectType
		objectTypeTemp := genruntime.ToEnum(objectType, scheduleBasedTriggerContext_ObjectType_STATUS_Values)
		context.ObjectType = &objectTypeTemp
	} else {
		context.ObjectType = nil
	}

	// Schedule
	if source.Schedule != nil {
		var schedule BackupSchedule_STATUS
		err := schedule.AssignProperties_From_BackupSchedule_STATUS(source.Schedule)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_BackupSchedule_STATUS() to populate field Schedule")
		}
		context.Schedule = &schedule
	} else {
		context.Schedule = nil
	}

	// TaggingCriteria
	if source.TaggingCriteria != nil {
		taggingCriterionList := make([]TaggingCriteria_STATUS, len(source.TaggingCriteria))
		for taggingCriterionIndex, taggingCriterionItem := range source.TaggingCriteria {
			// Shadow the loop variable to avoid aliasing
			taggingCriterionItem := taggingCriterionItem
			var taggingCriterion TaggingCriteria_STATUS
			err := taggingCriterion.AssignProperties_From_TaggingCriteria_STATUS(&taggingCriterionItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_TaggingCriteria_STATUS() to populate field TaggingCriteria")
			}
			taggingCriterionList[taggingCriterionIndex] = taggingCriterion
		}
		context.TaggingCriteria = taggingCriterionList
	} else {
		context.TaggingCriteria = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ScheduleBasedTriggerContext_STATUS populates the provided destination ScheduleBasedTriggerContext_STATUS from our ScheduleBasedTriggerContext_STATUS
func (context *ScheduleBasedTriggerContext_STATUS) AssignProperties_To_ScheduleBasedTriggerContext_STATUS(destination *storage.ScheduleBasedTriggerContext_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ObjectType
	if context.ObjectType != nil {
		objectType := string(*context.ObjectType)
		destination.ObjectType = &objectType
	} else {
		destination.ObjectType = nil
	}

	// Schedule
	if context.Schedule != nil {
		var schedule storage.BackupSchedule_STATUS
		err := context.Schedule.AssignProperties_To_BackupSchedule_STATUS(&schedule)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_BackupSchedule_STATUS() to populate field Schedule")
		}
		destination.Schedule = &schedule
	} else {
		destination.Schedule = nil
	}

	// TaggingCriteria
	if context.TaggingCriteria != nil {
		taggingCriterionList := make([]storage.TaggingCriteria_STATUS, len(context.TaggingCriteria))
		for taggingCriterionIndex, taggingCriterionItem := range context.TaggingCriteria {
			// Shadow the loop variable to avoid aliasing
			taggingCriterionItem := taggingCriterionItem
			var taggingCriterion storage.TaggingCriteria_STATUS
			err := taggingCriterionItem.AssignProperties_To_TaggingCriteria_STATUS(&taggingCriterion)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_TaggingCriteria_STATUS() to populate field TaggingCriteria")
			}
			taggingCriterionList[taggingCriterionIndex] = taggingCriterion
		}
		destination.TaggingCriteria = taggingCriterionList
	} else {
		destination.TaggingCriteria = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Target copy settings
type TargetCopySetting struct {
	// +kubebuilder:validation:Required
	// CopyAfter: It can be CustomCopyOption or ImmediateCopyOption.
	CopyAfter *CopyOption `json:"copyAfter,omitempty"`

	// +kubebuilder:validation:Required
	// DataStore: Info of target datastore
	DataStore *DataStoreInfoBase `json:"dataStore,omitempty"`
}

var _ genruntime.ARMTransformer = &TargetCopySetting{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (setting *TargetCopySetting) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if setting == nil {
		return nil, nil
	}
	result := &arm.TargetCopySetting{}

	// Set property "CopyAfter":
	if setting.CopyAfter != nil {
		copyAfter_ARM, err := (*setting.CopyAfter).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		copyAfter := *copyAfter_ARM.(*arm.CopyOption)
		result.CopyAfter = &copyAfter
	}

	// Set property "DataStore":
	if setting.DataStore != nil {
		dataStore_ARM, err := (*setting.DataStore).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		dataStore := *dataStore_ARM.(*arm.DataStoreInfoBase)
		result.DataStore = &dataStore
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (setting *TargetCopySetting) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.TargetCopySetting{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (setting *TargetCopySetting) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.TargetCopySetting)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.TargetCopySetting, got %T", armInput)
	}

	// Set property "CopyAfter":
	if typedInput.CopyAfter != nil {
		var copyAfter1 CopyOption
		err := copyAfter1.PopulateFromARM(owner, *typedInput.CopyAfter)
		if err != nil {
			return err
		}
		copyAfter := copyAfter1
		setting.CopyAfter = &copyAfter
	}

	// Set property "DataStore":
	if typedInput.DataStore != nil {
		var dataStore1 DataStoreInfoBase
		err := dataStore1.PopulateFromARM(owner, *typedInput.DataStore)
		if err != nil {
			return err
		}
		dataStore := dataStore1
		setting.DataStore = &dataStore
	}

	// No error
	return nil
}

// AssignProperties_From_TargetCopySetting populates our TargetCopySetting from the provided source TargetCopySetting
func (setting *TargetCopySetting) AssignProperties_From_TargetCopySetting(source *storage.TargetCopySetting) error {

	// CopyAfter
	if source.CopyAfter != nil {
		var copyAfter CopyOption
		err := copyAfter.AssignProperties_From_CopyOption(source.CopyAfter)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_CopyOption() to populate field CopyAfter")
		}
		setting.CopyAfter = &copyAfter
	} else {
		setting.CopyAfter = nil
	}

	// DataStore
	if source.DataStore != nil {
		var dataStore DataStoreInfoBase
		err := dataStore.AssignProperties_From_DataStoreInfoBase(source.DataStore)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_DataStoreInfoBase() to populate field DataStore")
		}
		setting.DataStore = &dataStore
	} else {
		setting.DataStore = nil
	}

	// No error
	return nil
}

// AssignProperties_To_TargetCopySetting populates the provided destination TargetCopySetting from our TargetCopySetting
func (setting *TargetCopySetting) AssignProperties_To_TargetCopySetting(destination *storage.TargetCopySetting) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CopyAfter
	if setting.CopyAfter != nil {
		var copyAfter storage.CopyOption
		err := setting.CopyAfter.AssignProperties_To_CopyOption(&copyAfter)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_CopyOption() to populate field CopyAfter")
		}
		destination.CopyAfter = &copyAfter
	} else {
		destination.CopyAfter = nil
	}

	// DataStore
	if setting.DataStore != nil {
		var dataStore storage.DataStoreInfoBase
		err := setting.DataStore.AssignProperties_To_DataStoreInfoBase(&dataStore)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_DataStoreInfoBase() to populate field DataStore")
		}
		destination.DataStore = &dataStore
	} else {
		destination.DataStore = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Target copy settings
type TargetCopySetting_STATUS struct {
	// CopyAfter: It can be CustomCopyOption or ImmediateCopyOption.
	CopyAfter *CopyOption_STATUS `json:"copyAfter,omitempty"`

	// DataStore: Info of target datastore
	DataStore *DataStoreInfoBase_STATUS `json:"dataStore,omitempty"`
}

var _ genruntime.FromARMConverter = &TargetCopySetting_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (setting *TargetCopySetting_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.TargetCopySetting_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (setting *TargetCopySetting_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.TargetCopySetting_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.TargetCopySetting_STATUS, got %T", armInput)
	}

	// Set property "CopyAfter":
	if typedInput.CopyAfter != nil {
		var copyAfter1 CopyOption_STATUS
		err := copyAfter1.PopulateFromARM(owner, *typedInput.CopyAfter)
		if err != nil {
			return err
		}
		copyAfter := copyAfter1
		setting.CopyAfter = &copyAfter
	}

	// Set property "DataStore":
	if typedInput.DataStore != nil {
		var dataStore1 DataStoreInfoBase_STATUS
		err := dataStore1.PopulateFromARM(owner, *typedInput.DataStore)
		if err != nil {
			return err
		}
		dataStore := dataStore1
		setting.DataStore = &dataStore
	}

	// No error
	return nil
}

// AssignProperties_From_TargetCopySetting_STATUS populates our TargetCopySetting_STATUS from the provided source TargetCopySetting_STATUS
func (setting *TargetCopySetting_STATUS) AssignProperties_From_TargetCopySetting_STATUS(source *storage.TargetCopySetting_STATUS) error {

	// CopyAfter
	if source.CopyAfter != nil {
		var copyAfter CopyOption_STATUS
		err := copyAfter.AssignProperties_From_CopyOption_STATUS(source.CopyAfter)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_CopyOption_STATUS() to populate field CopyAfter")
		}
		setting.CopyAfter = &copyAfter
	} else {
		setting.CopyAfter = nil
	}

	// DataStore
	if source.DataStore != nil {
		var dataStore DataStoreInfoBase_STATUS
		err := dataStore.AssignProperties_From_DataStoreInfoBase_STATUS(source.DataStore)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_DataStoreInfoBase_STATUS() to populate field DataStore")
		}
		setting.DataStore = &dataStore
	} else {
		setting.DataStore = nil
	}

	// No error
	return nil
}

// AssignProperties_To_TargetCopySetting_STATUS populates the provided destination TargetCopySetting_STATUS from our TargetCopySetting_STATUS
func (setting *TargetCopySetting_STATUS) AssignProperties_To_TargetCopySetting_STATUS(destination *storage.TargetCopySetting_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CopyAfter
	if setting.CopyAfter != nil {
		var copyAfter storage.CopyOption_STATUS
		err := setting.CopyAfter.AssignProperties_To_CopyOption_STATUS(&copyAfter)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_CopyOption_STATUS() to populate field CopyAfter")
		}
		destination.CopyAfter = &copyAfter
	} else {
		destination.CopyAfter = nil
	}

	// DataStore
	if setting.DataStore != nil {
		var dataStore storage.DataStoreInfoBase_STATUS
		err := setting.DataStore.AssignProperties_To_DataStoreInfoBase_STATUS(&dataStore)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_DataStoreInfoBase_STATUS() to populate field DataStore")
		}
		destination.DataStore = &dataStore
	} else {
		destination.DataStore = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type AbsoluteDeleteOption struct {
	// +kubebuilder:validation:Required
	// Duration: Duration of deletion after given timespan
	Duration *string `json:"duration,omitempty"`

	// +kubebuilder:validation:Required
	// ObjectType: Type of the specific object - used for deserializing
	ObjectType *AbsoluteDeleteOption_ObjectType `json:"objectType,omitempty"`
}

var _ genruntime.ARMTransformer = &AbsoluteDeleteOption{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (option *AbsoluteDeleteOption) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if option == nil {
		return nil, nil
	}
	result := &arm.AbsoluteDeleteOption{}

	// Set property "Duration":
	if option.Duration != nil {
		duration := *option.Duration
		result.Duration = &duration
	}

	// Set property "ObjectType":
	if option.ObjectType != nil {
		var temp arm.AbsoluteDeleteOption_ObjectType
		var temp1 string
		temp1 = string(*option.ObjectType)
		temp = arm.AbsoluteDeleteOption_ObjectType(temp1)
		result.ObjectType = temp
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (option *AbsoluteDeleteOption) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AbsoluteDeleteOption{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (option *AbsoluteDeleteOption) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AbsoluteDeleteOption)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AbsoluteDeleteOption, got %T", armInput)
	}

	// Set property "Duration":
	if typedInput.Duration != nil {
		duration := *typedInput.Duration
		option.Duration = &duration
	}

	// Set property "ObjectType":
	var temp AbsoluteDeleteOption_ObjectType
	var temp1 string
	temp1 = string(typedInput.ObjectType)
	temp = AbsoluteDeleteOption_ObjectType(temp1)
	option.ObjectType = &temp

	// No error
	return nil
}

// AssignProperties_From_AbsoluteDeleteOption populates our AbsoluteDeleteOption from the provided source AbsoluteDeleteOption
func (option *AbsoluteDeleteOption) AssignProperties_From_AbsoluteDeleteOption(source *storage.AbsoluteDeleteOption) error {

	// Duration
	option.Duration = genruntime.ClonePointerToString(source.Duration)

	// ObjectType
	if source.ObjectType != nil {
		objectType := *source.ObjectType
		objectTypeTemp := genruntime.ToEnum(objectType, absoluteDeleteOption_ObjectType_Values)
		option.ObjectType = &objectTypeTemp
	} else {
		option.ObjectType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AbsoluteDeleteOption populates the provided destination AbsoluteDeleteOption from our AbsoluteDeleteOption
func (option *AbsoluteDeleteOption) AssignProperties_To_AbsoluteDeleteOption(destination *storage.AbsoluteDeleteOption) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Duration
	destination.Duration = genruntime.ClonePointerToString(option.Duration)

	// ObjectType
	if option.ObjectType != nil {
		objectType := string(*option.ObjectType)
		destination.ObjectType = &objectType
	} else {
		destination.ObjectType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type AbsoluteDeleteOption_STATUS struct {
	// Duration: Duration of deletion after given timespan
	Duration *string `json:"duration,omitempty"`

	// ObjectType: Type of the specific object - used for deserializing
	ObjectType *AbsoluteDeleteOption_ObjectType_STATUS `json:"objectType,omitempty"`
}

var _ genruntime.FromARMConverter = &AbsoluteDeleteOption_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (option *AbsoluteDeleteOption_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AbsoluteDeleteOption_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (option *AbsoluteDeleteOption_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AbsoluteDeleteOption_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AbsoluteDeleteOption_STATUS, got %T", armInput)
	}

	// Set property "Duration":
	if typedInput.Duration != nil {
		duration := *typedInput.Duration
		option.Duration = &duration
	}

	// Set property "ObjectType":
	var temp AbsoluteDeleteOption_ObjectType_STATUS
	var temp1 string
	temp1 = string(typedInput.ObjectType)
	temp = AbsoluteDeleteOption_ObjectType_STATUS(temp1)
	option.ObjectType = &temp

	// No error
	return nil
}

// AssignProperties_From_AbsoluteDeleteOption_STATUS populates our AbsoluteDeleteOption_STATUS from the provided source AbsoluteDeleteOption_STATUS
func (option *AbsoluteDeleteOption_STATUS) AssignProperties_From_AbsoluteDeleteOption_STATUS(source *storage.AbsoluteDeleteOption_STATUS) error {

	// Duration
	option.Duration = genruntime.ClonePointerToString(source.Duration)

	// ObjectType
	if source.ObjectType != nil {
		objectType := *source.ObjectType
		objectTypeTemp := genruntime.ToEnum(objectType, absoluteDeleteOption_ObjectType_STATUS_Values)
		option.ObjectType = &objectTypeTemp
	} else {
		option.ObjectType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AbsoluteDeleteOption_STATUS populates the provided destination AbsoluteDeleteOption_STATUS from our AbsoluteDeleteOption_STATUS
func (option *AbsoluteDeleteOption_STATUS) AssignProperties_To_AbsoluteDeleteOption_STATUS(destination *storage.AbsoluteDeleteOption_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Duration
	destination.Duration = genruntime.ClonePointerToString(option.Duration)

	// ObjectType
	if option.ObjectType != nil {
		objectType := string(*option.ObjectType)
		destination.ObjectType = &objectType
	} else {
		destination.ObjectType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Adhoc backup tagging criteria
type AdhocBasedTaggingCriteria struct {
	// TagInfo: Retention tag information
	TagInfo *RetentionTag `json:"tagInfo,omitempty"`
}

var _ genruntime.ARMTransformer = &AdhocBasedTaggingCriteria{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (criteria *AdhocBasedTaggingCriteria) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if criteria == nil {
		return nil, nil
	}
	result := &arm.AdhocBasedTaggingCriteria{}

	// Set property "TagInfo":
	if criteria.TagInfo != nil {
		tagInfo_ARM, err := (*criteria.TagInfo).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		tagInfo := *tagInfo_ARM.(*arm.RetentionTag)
		result.TagInfo = &tagInfo
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (criteria *AdhocBasedTaggingCriteria) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AdhocBasedTaggingCriteria{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (criteria *AdhocBasedTaggingCriteria) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AdhocBasedTaggingCriteria)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AdhocBasedTaggingCriteria, got %T", armInput)
	}

	// Set property "TagInfo":
	if typedInput.TagInfo != nil {
		var tagInfo1 RetentionTag
		err := tagInfo1.PopulateFromARM(owner, *typedInput.TagInfo)
		if err != nil {
			return err
		}
		tagInfo := tagInfo1
		criteria.TagInfo = &tagInfo
	}

	// No error
	return nil
}

// AssignProperties_From_AdhocBasedTaggingCriteria populates our AdhocBasedTaggingCriteria from the provided source AdhocBasedTaggingCriteria
func (criteria *AdhocBasedTaggingCriteria) AssignProperties_From_AdhocBasedTaggingCriteria(source *storage.AdhocBasedTaggingCriteria) error {

	// TagInfo
	if source.TagInfo != nil {
		var tagInfo RetentionTag
		err := tagInfo.AssignProperties_From_RetentionTag(source.TagInfo)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_RetentionTag() to populate field TagInfo")
		}
		criteria.TagInfo = &tagInfo
	} else {
		criteria.TagInfo = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AdhocBasedTaggingCriteria populates the provided destination AdhocBasedTaggingCriteria from our AdhocBasedTaggingCriteria
func (criteria *AdhocBasedTaggingCriteria) AssignProperties_To_AdhocBasedTaggingCriteria(destination *storage.AdhocBasedTaggingCriteria) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// TagInfo
	if criteria.TagInfo != nil {
		var tagInfo storage.RetentionTag
		err := criteria.TagInfo.AssignProperties_To_RetentionTag(&tagInfo)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_RetentionTag() to populate field TagInfo")
		}
		destination.TagInfo = &tagInfo
	} else {
		destination.TagInfo = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Adhoc backup tagging criteria
type AdhocBasedTaggingCriteria_STATUS struct {
	// TagInfo: Retention tag information
	TagInfo *RetentionTag_STATUS `json:"tagInfo,omitempty"`
}

var _ genruntime.FromARMConverter = &AdhocBasedTaggingCriteria_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (criteria *AdhocBasedTaggingCriteria_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AdhocBasedTaggingCriteria_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (criteria *AdhocBasedTaggingCriteria_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AdhocBasedTaggingCriteria_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AdhocBasedTaggingCriteria_STATUS, got %T", armInput)
	}

	// Set property "TagInfo":
	if typedInput.TagInfo != nil {
		var tagInfo1 RetentionTag_STATUS
		err := tagInfo1.PopulateFromARM(owner, *typedInput.TagInfo)
		if err != nil {
			return err
		}
		tagInfo := tagInfo1
		criteria.TagInfo = &tagInfo
	}

	// No error
	return nil
}

// AssignProperties_From_AdhocBasedTaggingCriteria_STATUS populates our AdhocBasedTaggingCriteria_STATUS from the provided source AdhocBasedTaggingCriteria_STATUS
func (criteria *AdhocBasedTaggingCriteria_STATUS) AssignProperties_From_AdhocBasedTaggingCriteria_STATUS(source *storage.AdhocBasedTaggingCriteria_STATUS) error {

	// TagInfo
	if source.TagInfo != nil {
		var tagInfo RetentionTag_STATUS
		err := tagInfo.AssignProperties_From_RetentionTag_STATUS(source.TagInfo)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_RetentionTag_STATUS() to populate field TagInfo")
		}
		criteria.TagInfo = &tagInfo
	} else {
		criteria.TagInfo = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AdhocBasedTaggingCriteria_STATUS populates the provided destination AdhocBasedTaggingCriteria_STATUS from our AdhocBasedTaggingCriteria_STATUS
func (criteria *AdhocBasedTaggingCriteria_STATUS) AssignProperties_To_AdhocBasedTaggingCriteria_STATUS(destination *storage.AdhocBasedTaggingCriteria_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// TagInfo
	if criteria.TagInfo != nil {
		var tagInfo storage.RetentionTag_STATUS
		err := criteria.TagInfo.AssignProperties_To_RetentionTag_STATUS(&tagInfo)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_RetentionTag_STATUS() to populate field TagInfo")
		}
		destination.TagInfo = &tagInfo
	} else {
		destination.TagInfo = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"AdhocBasedTriggerContext"}
type AdhocBasedTriggerContext_ObjectType string

const AdhocBasedTriggerContext_ObjectType_AdhocBasedTriggerContext = AdhocBasedTriggerContext_ObjectType("AdhocBasedTriggerContext")

// Mapping from string to AdhocBasedTriggerContext_ObjectType
var adhocBasedTriggerContext_ObjectType_Values = map[string]AdhocBasedTriggerContext_ObjectType{
	"adhocbasedtriggercontext": AdhocBasedTriggerContext_ObjectType_AdhocBasedTriggerContext,
}

type AdhocBasedTriggerContext_ObjectType_STATUS string

const AdhocBasedTriggerContext_ObjectType_STATUS_AdhocBasedTriggerContext = AdhocBasedTriggerContext_ObjectType_STATUS("AdhocBasedTriggerContext")

// Mapping from string to AdhocBasedTriggerContext_ObjectType_STATUS
var adhocBasedTriggerContext_ObjectType_STATUS_Values = map[string]AdhocBasedTriggerContext_ObjectType_STATUS{
	"adhocbasedtriggercontext": AdhocBasedTriggerContext_ObjectType_STATUS_AdhocBasedTriggerContext,
}

// +kubebuilder:validation:Enum={"AzureBackupParams"}
type AzureBackupParams_ObjectType string

const AzureBackupParams_ObjectType_AzureBackupParams = AzureBackupParams_ObjectType("AzureBackupParams")

// Mapping from string to AzureBackupParams_ObjectType
var azureBackupParams_ObjectType_Values = map[string]AzureBackupParams_ObjectType{
	"azurebackupparams": AzureBackupParams_ObjectType_AzureBackupParams,
}

type AzureBackupParams_ObjectType_STATUS string

const AzureBackupParams_ObjectType_STATUS_AzureBackupParams = AzureBackupParams_ObjectType_STATUS("AzureBackupParams")

// Mapping from string to AzureBackupParams_ObjectType_STATUS
var azureBackupParams_ObjectType_STATUS_Values = map[string]AzureBackupParams_ObjectType_STATUS{
	"azurebackupparams": AzureBackupParams_ObjectType_STATUS_AzureBackupParams,
}

// Schedule for backup
type BackupSchedule struct {
	// +kubebuilder:validation:Required
	// RepeatingTimeIntervals: ISO 8601 repeating time interval format
	RepeatingTimeIntervals []string `json:"repeatingTimeIntervals,omitempty"`

	// TimeZone: Time zone for a schedule. Example: Pacific Standard Time
	TimeZone *string `json:"timeZone,omitempty"`
}

var _ genruntime.ARMTransformer = &BackupSchedule{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (schedule *BackupSchedule) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if schedule == nil {
		return nil, nil
	}
	result := &arm.BackupSchedule{}

	// Set property "RepeatingTimeIntervals":
	for _, item := range schedule.RepeatingTimeIntervals {
		result.RepeatingTimeIntervals = append(result.RepeatingTimeIntervals, item)
	}

	// Set property "TimeZone":
	if schedule.TimeZone != nil {
		timeZone := *schedule.TimeZone
		result.TimeZone = &timeZone
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (schedule *BackupSchedule) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.BackupSchedule{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (schedule *BackupSchedule) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.BackupSchedule)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.BackupSchedule, got %T", armInput)
	}

	// Set property "RepeatingTimeIntervals":
	for _, item := range typedInput.RepeatingTimeIntervals {
		schedule.RepeatingTimeIntervals = append(schedule.RepeatingTimeIntervals, item)
	}

	// Set property "TimeZone":
	if typedInput.TimeZone != nil {
		timeZone := *typedInput.TimeZone
		schedule.TimeZone = &timeZone
	}

	// No error
	return nil
}

// AssignProperties_From_BackupSchedule populates our BackupSchedule from the provided source BackupSchedule
func (schedule *BackupSchedule) AssignProperties_From_BackupSchedule(source *storage.BackupSchedule) error {

	// RepeatingTimeIntervals
	schedule.RepeatingTimeIntervals = genruntime.CloneSliceOfString(source.RepeatingTimeIntervals)

	// TimeZone
	schedule.TimeZone = genruntime.ClonePointerToString(source.TimeZone)

	// No error
	return nil
}

// AssignProperties_To_BackupSchedule populates the provided destination BackupSchedule from our BackupSchedule
func (schedule *BackupSchedule) AssignProperties_To_BackupSchedule(destination *storage.BackupSchedule) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// RepeatingTimeIntervals
	destination.RepeatingTimeIntervals = genruntime.CloneSliceOfString(schedule.RepeatingTimeIntervals)

	// TimeZone
	destination.TimeZone = genruntime.ClonePointerToString(schedule.TimeZone)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Schedule for backup
type BackupSchedule_STATUS struct {
	// RepeatingTimeIntervals: ISO 8601 repeating time interval format
	RepeatingTimeIntervals []string `json:"repeatingTimeIntervals,omitempty"`

	// TimeZone: Time zone for a schedule. Example: Pacific Standard Time
	TimeZone *string `json:"timeZone,omitempty"`
}

var _ genruntime.FromARMConverter = &BackupSchedule_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (schedule *BackupSchedule_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.BackupSchedule_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (schedule *BackupSchedule_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.BackupSchedule_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.BackupSchedule_STATUS, got %T", armInput)
	}

	// Set property "RepeatingTimeIntervals":
	for _, item := range typedInput.RepeatingTimeIntervals {
		schedule.RepeatingTimeIntervals = append(schedule.RepeatingTimeIntervals, item)
	}

	// Set property "TimeZone":
	if typedInput.TimeZone != nil {
		timeZone := *typedInput.TimeZone
		schedule.TimeZone = &timeZone
	}

	// No error
	return nil
}

// AssignProperties_From_BackupSchedule_STATUS populates our BackupSchedule_STATUS from the provided source BackupSchedule_STATUS
func (schedule *BackupSchedule_STATUS) AssignProperties_From_BackupSchedule_STATUS(source *storage.BackupSchedule_STATUS) error {

	// RepeatingTimeIntervals
	schedule.RepeatingTimeIntervals = genruntime.CloneSliceOfString(source.RepeatingTimeIntervals)

	// TimeZone
	schedule.TimeZone = genruntime.ClonePointerToString(source.TimeZone)

	// No error
	return nil
}

// AssignProperties_To_BackupSchedule_STATUS populates the provided destination BackupSchedule_STATUS from our BackupSchedule_STATUS
func (schedule *BackupSchedule_STATUS) AssignProperties_To_BackupSchedule_STATUS(destination *storage.BackupSchedule_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// RepeatingTimeIntervals
	destination.RepeatingTimeIntervals = genruntime.CloneSliceOfString(schedule.RepeatingTimeIntervals)

	// TimeZone
	destination.TimeZone = genruntime.ClonePointerToString(schedule.TimeZone)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type CopyOption struct {
	// CopyOnExpiry: Mutually exclusive with all other properties
	CopyOnExpiry *CopyOnExpiryOption `json:"copyOnExpiryOption,omitempty"`

	// CustomCopy: Mutually exclusive with all other properties
	CustomCopy *CustomCopyOption `json:"customCopyOption,omitempty"`

	// ImmediateCopy: Mutually exclusive with all other properties
	ImmediateCopy *ImmediateCopyOption `json:"immediateCopyOption,omitempty"`
}

var _ genruntime.ARMTransformer = &CopyOption{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (option *CopyOption) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if option == nil {
		return nil, nil
	}
	result := &arm.CopyOption{}

	// Set property "CopyOnExpiry":
	if option.CopyOnExpiry != nil {
		copyOnExpiry_ARM, err := (*option.CopyOnExpiry).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		copyOnExpiry := *copyOnExpiry_ARM.(*arm.CopyOnExpiryOption)
		result.CopyOnExpiry = &copyOnExpiry
	}

	// Set property "CustomCopy":
	if option.CustomCopy != nil {
		customCopy_ARM, err := (*option.CustomCopy).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		customCopy := *customCopy_ARM.(*arm.CustomCopyOption)
		result.CustomCopy = &customCopy
	}

	// Set property "ImmediateCopy":
	if option.ImmediateCopy != nil {
		immediateCopy_ARM, err := (*option.ImmediateCopy).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		immediateCopy := *immediateCopy_ARM.(*arm.ImmediateCopyOption)
		result.ImmediateCopy = &immediateCopy
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (option *CopyOption) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.CopyOption{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (option *CopyOption) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.CopyOption)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.CopyOption, got %T", armInput)
	}

	// Set property "CopyOnExpiry":
	if typedInput.CopyOnExpiry != nil {
		var copyOnExpiry1 CopyOnExpiryOption
		err := copyOnExpiry1.PopulateFromARM(owner, *typedInput.CopyOnExpiry)
		if err != nil {
			return err
		}
		copyOnExpiry := copyOnExpiry1
		option.CopyOnExpiry = &copyOnExpiry
	}

	// Set property "CustomCopy":
	if typedInput.CustomCopy != nil {
		var customCopy1 CustomCopyOption
		err := customCopy1.PopulateFromARM(owner, *typedInput.CustomCopy)
		if err != nil {
			return err
		}
		customCopy := customCopy1
		option.CustomCopy = &customCopy
	}

	// Set property "ImmediateCopy":
	if typedInput.ImmediateCopy != nil {
		var immediateCopy1 ImmediateCopyOption
		err := immediateCopy1.PopulateFromARM(owner, *typedInput.ImmediateCopy)
		if err != nil {
			return err
		}
		immediateCopy := immediateCopy1
		option.ImmediateCopy = &immediateCopy
	}

	// No error
	return nil
}

// AssignProperties_From_CopyOption populates our CopyOption from the provided source CopyOption
func (option *CopyOption) AssignProperties_From_CopyOption(source *storage.CopyOption) error {

	// CopyOnExpiry
	if source.CopyOnExpiry != nil {
		var copyOnExpiry CopyOnExpiryOption
		err := copyOnExpiry.AssignProperties_From_CopyOnExpiryOption(source.CopyOnExpiry)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_CopyOnExpiryOption() to populate field CopyOnExpiry")
		}
		option.CopyOnExpiry = &copyOnExpiry
	} else {
		option.CopyOnExpiry = nil
	}

	// CustomCopy
	if source.CustomCopy != nil {
		var customCopy CustomCopyOption
		err := customCopy.AssignProperties_From_CustomCopyOption(source.CustomCopy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_CustomCopyOption() to populate field CustomCopy")
		}
		option.CustomCopy = &customCopy
	} else {
		option.CustomCopy = nil
	}

	// ImmediateCopy
	if source.ImmediateCopy != nil {
		var immediateCopy ImmediateCopyOption
		err := immediateCopy.AssignProperties_From_ImmediateCopyOption(source.ImmediateCopy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ImmediateCopyOption() to populate field ImmediateCopy")
		}
		option.ImmediateCopy = &immediateCopy
	} else {
		option.ImmediateCopy = nil
	}

	// No error
	return nil
}

// AssignProperties_To_CopyOption populates the provided destination CopyOption from our CopyOption
func (option *CopyOption) AssignProperties_To_CopyOption(destination *storage.CopyOption) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CopyOnExpiry
	if option.CopyOnExpiry != nil {
		var copyOnExpiry storage.CopyOnExpiryOption
		err := option.CopyOnExpiry.AssignProperties_To_CopyOnExpiryOption(&copyOnExpiry)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_CopyOnExpiryOption() to populate field CopyOnExpiry")
		}
		destination.CopyOnExpiry = &copyOnExpiry
	} else {
		destination.CopyOnExpiry = nil
	}

	// CustomCopy
	if option.CustomCopy != nil {
		var customCopy storage.CustomCopyOption
		err := option.CustomCopy.AssignProperties_To_CustomCopyOption(&customCopy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_CustomCopyOption() to populate field CustomCopy")
		}
		destination.CustomCopy = &customCopy
	} else {
		destination.CustomCopy = nil
	}

	// ImmediateCopy
	if option.ImmediateCopy != nil {
		var immediateCopy storage.ImmediateCopyOption
		err := option.ImmediateCopy.AssignProperties_To_ImmediateCopyOption(&immediateCopy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ImmediateCopyOption() to populate field ImmediateCopy")
		}
		destination.ImmediateCopy = &immediateCopy
	} else {
		destination.ImmediateCopy = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type CopyOption_STATUS struct {
	// CopyOnExpiry: Mutually exclusive with all other properties
	CopyOnExpiry *CopyOnExpiryOption_STATUS `json:"copyOnExpiryOption,omitempty"`

	// CustomCopy: Mutually exclusive with all other properties
	CustomCopy *CustomCopyOption_STATUS `json:"customCopyOption,omitempty"`

	// ImmediateCopy: Mutually exclusive with all other properties
	ImmediateCopy *ImmediateCopyOption_STATUS `json:"immediateCopyOption,omitempty"`
}

var _ genruntime.FromARMConverter = &CopyOption_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (option *CopyOption_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.CopyOption_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (option *CopyOption_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.CopyOption_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.CopyOption_STATUS, got %T", armInput)
	}

	// Set property "CopyOnExpiry":
	if typedInput.CopyOnExpiry != nil {
		var copyOnExpiry1 CopyOnExpiryOption_STATUS
		err := copyOnExpiry1.PopulateFromARM(owner, *typedInput.CopyOnExpiry)
		if err != nil {
			return err
		}
		copyOnExpiry := copyOnExpiry1
		option.CopyOnExpiry = &copyOnExpiry
	}

	// Set property "CustomCopy":
	if typedInput.CustomCopy != nil {
		var customCopy1 CustomCopyOption_STATUS
		err := customCopy1.PopulateFromARM(owner, *typedInput.CustomCopy)
		if err != nil {
			return err
		}
		customCopy := customCopy1
		option.CustomCopy = &customCopy
	}

	// Set property "ImmediateCopy":
	if typedInput.ImmediateCopy != nil {
		var immediateCopy1 ImmediateCopyOption_STATUS
		err := immediateCopy1.PopulateFromARM(owner, *typedInput.ImmediateCopy)
		if err != nil {
			return err
		}
		immediateCopy := immediateCopy1
		option.ImmediateCopy = &immediateCopy
	}

	// No error
	return nil
}

// AssignProperties_From_CopyOption_STATUS populates our CopyOption_STATUS from the provided source CopyOption_STATUS
func (option *CopyOption_STATUS) AssignProperties_From_CopyOption_STATUS(source *storage.CopyOption_STATUS) error {

	// CopyOnExpiry
	if source.CopyOnExpiry != nil {
		var copyOnExpiry CopyOnExpiryOption_STATUS
		err := copyOnExpiry.AssignProperties_From_CopyOnExpiryOption_STATUS(source.CopyOnExpiry)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_CopyOnExpiryOption_STATUS() to populate field CopyOnExpiry")
		}
		option.CopyOnExpiry = &copyOnExpiry
	} else {
		option.CopyOnExpiry = nil
	}

	// CustomCopy
	if source.CustomCopy != nil {
		var customCopy CustomCopyOption_STATUS
		err := customCopy.AssignProperties_From_CustomCopyOption_STATUS(source.CustomCopy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_CustomCopyOption_STATUS() to populate field CustomCopy")
		}
		option.CustomCopy = &customCopy
	} else {
		option.CustomCopy = nil
	}

	// ImmediateCopy
	if source.ImmediateCopy != nil {
		var immediateCopy ImmediateCopyOption_STATUS
		err := immediateCopy.AssignProperties_From_ImmediateCopyOption_STATUS(source.ImmediateCopy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ImmediateCopyOption_STATUS() to populate field ImmediateCopy")
		}
		option.ImmediateCopy = &immediateCopy
	} else {
		option.ImmediateCopy = nil
	}

	// No error
	return nil
}

// AssignProperties_To_CopyOption_STATUS populates the provided destination CopyOption_STATUS from our CopyOption_STATUS
func (option *CopyOption_STATUS) AssignProperties_To_CopyOption_STATUS(destination *storage.CopyOption_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CopyOnExpiry
	if option.CopyOnExpiry != nil {
		var copyOnExpiry storage.CopyOnExpiryOption_STATUS
		err := option.CopyOnExpiry.AssignProperties_To_CopyOnExpiryOption_STATUS(&copyOnExpiry)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_CopyOnExpiryOption_STATUS() to populate field CopyOnExpiry")
		}
		destination.CopyOnExpiry = &copyOnExpiry
	} else {
		destination.CopyOnExpiry = nil
	}

	// CustomCopy
	if option.CustomCopy != nil {
		var customCopy storage.CustomCopyOption_STATUS
		err := option.CustomCopy.AssignProperties_To_CustomCopyOption_STATUS(&customCopy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_CustomCopyOption_STATUS() to populate field CustomCopy")
		}
		destination.CustomCopy = &customCopy
	} else {
		destination.CustomCopy = nil
	}

	// ImmediateCopy
	if option.ImmediateCopy != nil {
		var immediateCopy storage.ImmediateCopyOption_STATUS
		err := option.ImmediateCopy.AssignProperties_To_ImmediateCopyOption_STATUS(&immediateCopy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ImmediateCopyOption_STATUS() to populate field ImmediateCopy")
		}
		destination.ImmediateCopy = &immediateCopy
	} else {
		destination.ImmediateCopy = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"ScheduleBasedTriggerContext"}
type ScheduleBasedTriggerContext_ObjectType string

const ScheduleBasedTriggerContext_ObjectType_ScheduleBasedTriggerContext = ScheduleBasedTriggerContext_ObjectType("ScheduleBasedTriggerContext")

// Mapping from string to ScheduleBasedTriggerContext_ObjectType
var scheduleBasedTriggerContext_ObjectType_Values = map[string]ScheduleBasedTriggerContext_ObjectType{
	"schedulebasedtriggercontext": ScheduleBasedTriggerContext_ObjectType_ScheduleBasedTriggerContext,
}

type ScheduleBasedTriggerContext_ObjectType_STATUS string

const ScheduleBasedTriggerContext_ObjectType_STATUS_ScheduleBasedTriggerContext = ScheduleBasedTriggerContext_ObjectType_STATUS("ScheduleBasedTriggerContext")

// Mapping from string to ScheduleBasedTriggerContext_ObjectType_STATUS
var scheduleBasedTriggerContext_ObjectType_STATUS_Values = map[string]ScheduleBasedTriggerContext_ObjectType_STATUS{
	"schedulebasedtriggercontext": ScheduleBasedTriggerContext_ObjectType_STATUS_ScheduleBasedTriggerContext,
}

// Tagging criteria
type TaggingCriteria struct {
	// Criteria: Criteria which decides whether the tag can be applied to a triggered backup.
	Criteria []BackupCriteria `json:"criteria,omitempty"`

	// +kubebuilder:validation:Required
	// IsDefault: Specifies if tag is default.
	IsDefault *bool `json:"isDefault,omitempty"`

	// +kubebuilder:validation:Required
	// TagInfo: Retention tag information
	TagInfo *RetentionTag `json:"tagInfo,omitempty"`

	// +kubebuilder:validation:Required
	// TaggingPriority: Retention Tag priority.
	TaggingPriority *int `json:"taggingPriority,omitempty"`
}

var _ genruntime.ARMTransformer = &TaggingCriteria{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (criteria *TaggingCriteria) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if criteria == nil {
		return nil, nil
	}
	result := &arm.TaggingCriteria{}

	// Set property "Criteria":
	for _, item := range criteria.Criteria {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Criteria = append(result.Criteria, *item_ARM.(*arm.BackupCriteria))
	}

	// Set property "IsDefault":
	if criteria.IsDefault != nil {
		isDefault := *criteria.IsDefault
		result.IsDefault = &isDefault
	}

	// Set property "TagInfo":
	if criteria.TagInfo != nil {
		tagInfo_ARM, err := (*criteria.TagInfo).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		tagInfo := *tagInfo_ARM.(*arm.RetentionTag)
		result.TagInfo = &tagInfo
	}

	// Set property "TaggingPriority":
	if criteria.TaggingPriority != nil {
		taggingPriority := *criteria.TaggingPriority
		result.TaggingPriority = &taggingPriority
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (criteria *TaggingCriteria) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.TaggingCriteria{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (criteria *TaggingCriteria) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.TaggingCriteria)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.TaggingCriteria, got %T", armInput)
	}

	// Set property "Criteria":
	for _, item := range typedInput.Criteria {
		var item1 BackupCriteria
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		criteria.Criteria = append(criteria.Criteria, item1)
	}

	// Set property "IsDefault":
	if typedInput.IsDefault != nil {
		isDefault := *typedInput.IsDefault
		criteria.IsDefault = &isDefault
	}

	// Set property "TagInfo":
	if typedInput.TagInfo != nil {
		var tagInfo1 RetentionTag
		err := tagInfo1.PopulateFromARM(owner, *typedInput.TagInfo)
		if err != nil {
			return err
		}
		tagInfo := tagInfo1
		criteria.TagInfo = &tagInfo
	}

	// Set property "TaggingPriority":
	if typedInput.TaggingPriority != nil {
		taggingPriority := *typedInput.TaggingPriority
		criteria.TaggingPriority = &taggingPriority
	}

	// No error
	return nil
}

// AssignProperties_From_TaggingCriteria populates our TaggingCriteria from the provided source TaggingCriteria
func (criteria *TaggingCriteria) AssignProperties_From_TaggingCriteria(source *storage.TaggingCriteria) error {

	// Criteria
	if source.Criteria != nil {
		criterionList := make([]BackupCriteria, len(source.Criteria))
		for criterionIndex, criterionItem := range source.Criteria {
			// Shadow the loop variable to avoid aliasing
			criterionItem := criterionItem
			var criterion BackupCriteria
			err := criterion.AssignProperties_From_BackupCriteria(&criterionItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_BackupCriteria() to populate field Criteria")
			}
			criterionList[criterionIndex] = criterion
		}
		criteria.Criteria = criterionList
	} else {
		criteria.Criteria = nil
	}

	// IsDefault
	if source.IsDefault != nil {
		isDefault := *source.IsDefault
		criteria.IsDefault = &isDefault
	} else {
		criteria.IsDefault = nil
	}

	// TagInfo
	if source.TagInfo != nil {
		var tagInfo RetentionTag
		err := tagInfo.AssignProperties_From_RetentionTag(source.TagInfo)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_RetentionTag() to populate field TagInfo")
		}
		criteria.TagInfo = &tagInfo
	} else {
		criteria.TagInfo = nil
	}

	// TaggingPriority
	criteria.TaggingPriority = genruntime.ClonePointerToInt(source.TaggingPriority)

	// No error
	return nil
}

// AssignProperties_To_TaggingCriteria populates the provided destination TaggingCriteria from our TaggingCriteria
func (criteria *TaggingCriteria) AssignProperties_To_TaggingCriteria(destination *storage.TaggingCriteria) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Criteria
	if criteria.Criteria != nil {
		criterionList := make([]storage.BackupCriteria, len(criteria.Criteria))
		for criterionIndex, criterionItem := range criteria.Criteria {
			// Shadow the loop variable to avoid aliasing
			criterionItem := criterionItem
			var criterion storage.BackupCriteria
			err := criterionItem.AssignProperties_To_BackupCriteria(&criterion)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_BackupCriteria() to populate field Criteria")
			}
			criterionList[criterionIndex] = criterion
		}
		destination.Criteria = criterionList
	} else {
		destination.Criteria = nil
	}

	// IsDefault
	if criteria.IsDefault != nil {
		isDefault := *criteria.IsDefault
		destination.IsDefault = &isDefault
	} else {
		destination.IsDefault = nil
	}

	// TagInfo
	if criteria.TagInfo != nil {
		var tagInfo storage.RetentionTag
		err := criteria.TagInfo.AssignProperties_To_RetentionTag(&tagInfo)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_RetentionTag() to populate field TagInfo")
		}
		destination.TagInfo = &tagInfo
	} else {
		destination.TagInfo = nil
	}

	// TaggingPriority
	destination.TaggingPriority = genruntime.ClonePointerToInt(criteria.TaggingPriority)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Tagging criteria
type TaggingCriteria_STATUS struct {
	// Criteria: Criteria which decides whether the tag can be applied to a triggered backup.
	Criteria []BackupCriteria_STATUS `json:"criteria,omitempty"`

	// IsDefault: Specifies if tag is default.
	IsDefault *bool `json:"isDefault,omitempty"`

	// TagInfo: Retention tag information
	TagInfo *RetentionTag_STATUS `json:"tagInfo,omitempty"`

	// TaggingPriority: Retention Tag priority.
	TaggingPriority *int `json:"taggingPriority,omitempty"`
}

var _ genruntime.FromARMConverter = &TaggingCriteria_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (criteria *TaggingCriteria_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.TaggingCriteria_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (criteria *TaggingCriteria_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.TaggingCriteria_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.TaggingCriteria_STATUS, got %T", armInput)
	}

	// Set property "Criteria":
	for _, item := range typedInput.Criteria {
		var item1 BackupCriteria_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		criteria.Criteria = append(criteria.Criteria, item1)
	}

	// Set property "IsDefault":
	if typedInput.IsDefault != nil {
		isDefault := *typedInput.IsDefault
		criteria.IsDefault = &isDefault
	}

	// Set property "TagInfo":
	if typedInput.TagInfo != nil {
		var tagInfo1 RetentionTag_STATUS
		err := tagInfo1.PopulateFromARM(owner, *typedInput.TagInfo)
		if err != nil {
			return err
		}
		tagInfo := tagInfo1
		criteria.TagInfo = &tagInfo
	}

	// Set property "TaggingPriority":
	if typedInput.TaggingPriority != nil {
		taggingPriority := *typedInput.TaggingPriority
		criteria.TaggingPriority = &taggingPriority
	}

	// No error
	return nil
}

// AssignProperties_From_TaggingCriteria_STATUS populates our TaggingCriteria_STATUS from the provided source TaggingCriteria_STATUS
func (criteria *TaggingCriteria_STATUS) AssignProperties_From_TaggingCriteria_STATUS(source *storage.TaggingCriteria_STATUS) error {

	// Criteria
	if source.Criteria != nil {
		criterionList := make([]BackupCriteria_STATUS, len(source.Criteria))
		for criterionIndex, criterionItem := range source.Criteria {
			// Shadow the loop variable to avoid aliasing
			criterionItem := criterionItem
			var criterion BackupCriteria_STATUS
			err := criterion.AssignProperties_From_BackupCriteria_STATUS(&criterionItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_BackupCriteria_STATUS() to populate field Criteria")
			}
			criterionList[criterionIndex] = criterion
		}
		criteria.Criteria = criterionList
	} else {
		criteria.Criteria = nil
	}

	// IsDefault
	if source.IsDefault != nil {
		isDefault := *source.IsDefault
		criteria.IsDefault = &isDefault
	} else {
		criteria.IsDefault = nil
	}

	// TagInfo
	if source.TagInfo != nil {
		var tagInfo RetentionTag_STATUS
		err := tagInfo.AssignProperties_From_RetentionTag_STATUS(source.TagInfo)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_RetentionTag_STATUS() to populate field TagInfo")
		}
		criteria.TagInfo = &tagInfo
	} else {
		criteria.TagInfo = nil
	}

	// TaggingPriority
	criteria.TaggingPriority = genruntime.ClonePointerToInt(source.TaggingPriority)

	// No error
	return nil
}

// AssignProperties_To_TaggingCriteria_STATUS populates the provided destination TaggingCriteria_STATUS from our TaggingCriteria_STATUS
func (criteria *TaggingCriteria_STATUS) AssignProperties_To_TaggingCriteria_STATUS(destination *storage.TaggingCriteria_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Criteria
	if criteria.Criteria != nil {
		criterionList := make([]storage.BackupCriteria_STATUS, len(criteria.Criteria))
		for criterionIndex, criterionItem := range criteria.Criteria {
			// Shadow the loop variable to avoid aliasing
			criterionItem := criterionItem
			var criterion storage.BackupCriteria_STATUS
			err := criterionItem.AssignProperties_To_BackupCriteria_STATUS(&criterion)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_BackupCriteria_STATUS() to populate field Criteria")
			}
			criterionList[criterionIndex] = criterion
		}
		destination.Criteria = criterionList
	} else {
		destination.Criteria = nil
	}

	// IsDefault
	if criteria.IsDefault != nil {
		isDefault := *criteria.IsDefault
		destination.IsDefault = &isDefault
	} else {
		destination.IsDefault = nil
	}

	// TagInfo
	if criteria.TagInfo != nil {
		var tagInfo storage.RetentionTag_STATUS
		err := criteria.TagInfo.AssignProperties_To_RetentionTag_STATUS(&tagInfo)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_RetentionTag_STATUS() to populate field TagInfo")
		}
		destination.TagInfo = &tagInfo
	} else {
		destination.TagInfo = nil
	}

	// TaggingPriority
	destination.TaggingPriority = genruntime.ClonePointerToInt(criteria.TaggingPriority)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"AbsoluteDeleteOption"}
type AbsoluteDeleteOption_ObjectType string

const AbsoluteDeleteOption_ObjectType_AbsoluteDeleteOption = AbsoluteDeleteOption_ObjectType("AbsoluteDeleteOption")

// Mapping from string to AbsoluteDeleteOption_ObjectType
var absoluteDeleteOption_ObjectType_Values = map[string]AbsoluteDeleteOption_ObjectType{
	"absolutedeleteoption": AbsoluteDeleteOption_ObjectType_AbsoluteDeleteOption,
}

type AbsoluteDeleteOption_ObjectType_STATUS string

const AbsoluteDeleteOption_ObjectType_STATUS_AbsoluteDeleteOption = AbsoluteDeleteOption_ObjectType_STATUS("AbsoluteDeleteOption")

// Mapping from string to AbsoluteDeleteOption_ObjectType_STATUS
var absoluteDeleteOption_ObjectType_STATUS_Values = map[string]AbsoluteDeleteOption_ObjectType_STATUS{
	"absolutedeleteoption": AbsoluteDeleteOption_ObjectType_STATUS_AbsoluteDeleteOption,
}

type BackupCriteria struct {
	// ScheduleBasedBackupCriteria: Mutually exclusive with all other properties
	ScheduleBasedBackupCriteria *ScheduleBasedBackupCriteria `json:"scheduleBasedBackupCriteria,omitempty"`
}

var _ genruntime.ARMTransformer = &BackupCriteria{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (criteria *BackupCriteria) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if criteria == nil {
		return nil, nil
	}
	result := &arm.BackupCriteria{}

	// Set property "ScheduleBasedBackupCriteria":
	if criteria.ScheduleBasedBackupCriteria != nil {
		scheduleBasedBackupCriteria_ARM, err := (*criteria.ScheduleBasedBackupCriteria).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		scheduleBasedBackupCriteria := *scheduleBasedBackupCriteria_ARM.(*arm.ScheduleBasedBackupCriteria)
		result.ScheduleBasedBackupCriteria = &scheduleBasedBackupCriteria
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (criteria *BackupCriteria) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.BackupCriteria{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (criteria *BackupCriteria) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.BackupCriteria)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.BackupCriteria, got %T", armInput)
	}

	// Set property "ScheduleBasedBackupCriteria":
	if typedInput.ScheduleBasedBackupCriteria != nil {
		var scheduleBasedBackupCriteria1 ScheduleBasedBackupCriteria
		err := scheduleBasedBackupCriteria1.PopulateFromARM(owner, *typedInput.ScheduleBasedBackupCriteria)
		if err != nil {
			return err
		}
		scheduleBasedBackupCriteria := scheduleBasedBackupCriteria1
		criteria.ScheduleBasedBackupCriteria = &scheduleBasedBackupCriteria
	}

	// No error
	return nil
}

// AssignProperties_From_BackupCriteria populates our BackupCriteria from the provided source BackupCriteria
func (criteria *BackupCriteria) AssignProperties_From_BackupCriteria(source *storage.BackupCriteria) error {

	// ScheduleBasedBackupCriteria
	if source.ScheduleBasedBackupCriteria != nil {
		var scheduleBasedBackupCriterion ScheduleBasedBackupCriteria
		err := scheduleBasedBackupCriterion.AssignProperties_From_ScheduleBasedBackupCriteria(source.ScheduleBasedBackupCriteria)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ScheduleBasedBackupCriteria() to populate field ScheduleBasedBackupCriteria")
		}
		criteria.ScheduleBasedBackupCriteria = &scheduleBasedBackupCriterion
	} else {
		criteria.ScheduleBasedBackupCriteria = nil
	}

	// No error
	return nil
}

// AssignProperties_To_BackupCriteria populates the provided destination BackupCriteria from our BackupCriteria
func (criteria *BackupCriteria) AssignProperties_To_BackupCriteria(destination *storage.BackupCriteria) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ScheduleBasedBackupCriteria
	if criteria.ScheduleBasedBackupCriteria != nil {
		var scheduleBasedBackupCriterion storage.ScheduleBasedBackupCriteria
		err := criteria.ScheduleBasedBackupCriteria.AssignProperties_To_ScheduleBasedBackupCriteria(&scheduleBasedBackupCriterion)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ScheduleBasedBackupCriteria() to populate field ScheduleBasedBackupCriteria")
		}
		destination.ScheduleBasedBackupCriteria = &scheduleBasedBackupCriterion
	} else {
		destination.ScheduleBasedBackupCriteria = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type BackupCriteria_STATUS struct {
	// ScheduleBasedBackupCriteria: Mutually exclusive with all other properties
	ScheduleBasedBackupCriteria *ScheduleBasedBackupCriteria_STATUS `json:"scheduleBasedBackupCriteria,omitempty"`
}

var _ genruntime.FromARMConverter = &BackupCriteria_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (criteria *BackupCriteria_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.BackupCriteria_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (criteria *BackupCriteria_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.BackupCriteria_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.BackupCriteria_STATUS, got %T", armInput)
	}

	// Set property "ScheduleBasedBackupCriteria":
	if typedInput.ScheduleBasedBackupCriteria != nil {
		var scheduleBasedBackupCriteria1 ScheduleBasedBackupCriteria_STATUS
		err := scheduleBasedBackupCriteria1.PopulateFromARM(owner, *typedInput.ScheduleBasedBackupCriteria)
		if err != nil {
			return err
		}
		scheduleBasedBackupCriteria := scheduleBasedBackupCriteria1
		criteria.ScheduleBasedBackupCriteria = &scheduleBasedBackupCriteria
	}

	// No error
	return nil
}

// AssignProperties_From_BackupCriteria_STATUS populates our BackupCriteria_STATUS from the provided source BackupCriteria_STATUS
func (criteria *BackupCriteria_STATUS) AssignProperties_From_BackupCriteria_STATUS(source *storage.BackupCriteria_STATUS) error {

	// ScheduleBasedBackupCriteria
	if source.ScheduleBasedBackupCriteria != nil {
		var scheduleBasedBackupCriterion ScheduleBasedBackupCriteria_STATUS
		err := scheduleBasedBackupCriterion.AssignProperties_From_ScheduleBasedBackupCriteria_STATUS(source.ScheduleBasedBackupCriteria)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ScheduleBasedBackupCriteria_STATUS() to populate field ScheduleBasedBackupCriteria")
		}
		criteria.ScheduleBasedBackupCriteria = &scheduleBasedBackupCriterion
	} else {
		criteria.ScheduleBasedBackupCriteria = nil
	}

	// No error
	return nil
}

// AssignProperties_To_BackupCriteria_STATUS populates the provided destination BackupCriteria_STATUS from our BackupCriteria_STATUS
func (criteria *BackupCriteria_STATUS) AssignProperties_To_BackupCriteria_STATUS(destination *storage.BackupCriteria_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ScheduleBasedBackupCriteria
	if criteria.ScheduleBasedBackupCriteria != nil {
		var scheduleBasedBackupCriterion storage.ScheduleBasedBackupCriteria_STATUS
		err := criteria.ScheduleBasedBackupCriteria.AssignProperties_To_ScheduleBasedBackupCriteria_STATUS(&scheduleBasedBackupCriterion)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ScheduleBasedBackupCriteria_STATUS() to populate field ScheduleBasedBackupCriteria")
		}
		destination.ScheduleBasedBackupCriteria = &scheduleBasedBackupCriterion
	} else {
		destination.ScheduleBasedBackupCriteria = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type CopyOnExpiryOption struct {
	// +kubebuilder:validation:Required
	// ObjectType: Type of the specific object - used for deserializing
	ObjectType *CopyOnExpiryOption_ObjectType `json:"objectType,omitempty"`
}

var _ genruntime.ARMTransformer = &CopyOnExpiryOption{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (option *CopyOnExpiryOption) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if option == nil {
		return nil, nil
	}
	result := &arm.CopyOnExpiryOption{}

	// Set property "ObjectType":
	if option.ObjectType != nil {
		var temp arm.CopyOnExpiryOption_ObjectType
		var temp1 string
		temp1 = string(*option.ObjectType)
		temp = arm.CopyOnExpiryOption_ObjectType(temp1)
		result.ObjectType = temp
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (option *CopyOnExpiryOption) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.CopyOnExpiryOption{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (option *CopyOnExpiryOption) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.CopyOnExpiryOption)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.CopyOnExpiryOption, got %T", armInput)
	}

	// Set property "ObjectType":
	var temp CopyOnExpiryOption_ObjectType
	var temp1 string
	temp1 = string(typedInput.ObjectType)
	temp = CopyOnExpiryOption_ObjectType(temp1)
	option.ObjectType = &temp

	// No error
	return nil
}

// AssignProperties_From_CopyOnExpiryOption populates our CopyOnExpiryOption from the provided source CopyOnExpiryOption
func (option *CopyOnExpiryOption) AssignProperties_From_CopyOnExpiryOption(source *storage.CopyOnExpiryOption) error {

	// ObjectType
	if source.ObjectType != nil {
		objectType := *source.ObjectType
		objectTypeTemp := genruntime.ToEnum(objectType, copyOnExpiryOption_ObjectType_Values)
		option.ObjectType = &objectTypeTemp
	} else {
		option.ObjectType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_CopyOnExpiryOption populates the provided destination CopyOnExpiryOption from our CopyOnExpiryOption
func (option *CopyOnExpiryOption) AssignProperties_To_CopyOnExpiryOption(destination *storage.CopyOnExpiryOption) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ObjectType
	if option.ObjectType != nil {
		objectType := string(*option.ObjectType)
		destination.ObjectType = &objectType
	} else {
		destination.ObjectType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type CopyOnExpiryOption_STATUS struct {
	// ObjectType: Type of the specific object - used for deserializing
	ObjectType *CopyOnExpiryOption_ObjectType_STATUS `json:"objectType,omitempty"`
}

var _ genruntime.FromARMConverter = &CopyOnExpiryOption_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (option *CopyOnExpiryOption_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.CopyOnExpiryOption_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (option *CopyOnExpiryOption_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.CopyOnExpiryOption_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.CopyOnExpiryOption_STATUS, got %T", armInput)
	}

	// Set property "ObjectType":
	var temp CopyOnExpiryOption_ObjectType_STATUS
	var temp1 string
	temp1 = string(typedInput.ObjectType)
	temp = CopyOnExpiryOption_ObjectType_STATUS(temp1)
	option.ObjectType = &temp

	// No error
	return nil
}

// AssignProperties_From_CopyOnExpiryOption_STATUS populates our CopyOnExpiryOption_STATUS from the provided source CopyOnExpiryOption_STATUS
func (option *CopyOnExpiryOption_STATUS) AssignProperties_From_CopyOnExpiryOption_STATUS(source *storage.CopyOnExpiryOption_STATUS) error {

	// ObjectType
	if source.ObjectType != nil {
		objectType := *source.ObjectType
		objectTypeTemp := genruntime.ToEnum(objectType, copyOnExpiryOption_ObjectType_STATUS_Values)
		option.ObjectType = &objectTypeTemp
	} else {
		option.ObjectType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_CopyOnExpiryOption_STATUS populates the provided destination CopyOnExpiryOption_STATUS from our CopyOnExpiryOption_STATUS
func (option *CopyOnExpiryOption_STATUS) AssignProperties_To_CopyOnExpiryOption_STATUS(destination *storage.CopyOnExpiryOption_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ObjectType
	if option.ObjectType != nil {
		objectType := string(*option.ObjectType)
		destination.ObjectType = &objectType
	} else {
		destination.ObjectType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type CustomCopyOption struct {
	// Duration: Data copied after given timespan
	Duration *string `json:"duration,omitempty"`

	// +kubebuilder:validation:Required
	// ObjectType: Type of the specific object - used for deserializing
	ObjectType *CustomCopyOption_ObjectType `json:"objectType,omitempty"`
}

var _ genruntime.ARMTransformer = &CustomCopyOption{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (option *CustomCopyOption) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if option == nil {
		return nil, nil
	}
	result := &arm.CustomCopyOption{}

	// Set property "Duration":
	if option.Duration != nil {
		duration := *option.Duration
		result.Duration = &duration
	}

	// Set property "ObjectType":
	if option.ObjectType != nil {
		var temp arm.CustomCopyOption_ObjectType
		var temp1 string
		temp1 = string(*option.ObjectType)
		temp = arm.CustomCopyOption_ObjectType(temp1)
		result.ObjectType = temp
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (option *CustomCopyOption) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.CustomCopyOption{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (option *CustomCopyOption) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.CustomCopyOption)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.CustomCopyOption, got %T", armInput)
	}

	// Set property "Duration":
	if typedInput.Duration != nil {
		duration := *typedInput.Duration
		option.Duration = &duration
	}

	// Set property "ObjectType":
	var temp CustomCopyOption_ObjectType
	var temp1 string
	temp1 = string(typedInput.ObjectType)
	temp = CustomCopyOption_ObjectType(temp1)
	option.ObjectType = &temp

	// No error
	return nil
}

// AssignProperties_From_CustomCopyOption populates our CustomCopyOption from the provided source CustomCopyOption
func (option *CustomCopyOption) AssignProperties_From_CustomCopyOption(source *storage.CustomCopyOption) error {

	// Duration
	option.Duration = genruntime.ClonePointerToString(source.Duration)

	// ObjectType
	if source.ObjectType != nil {
		objectType := *source.ObjectType
		objectTypeTemp := genruntime.ToEnum(objectType, customCopyOption_ObjectType_Values)
		option.ObjectType = &objectTypeTemp
	} else {
		option.ObjectType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_CustomCopyOption populates the provided destination CustomCopyOption from our CustomCopyOption
func (option *CustomCopyOption) AssignProperties_To_CustomCopyOption(destination *storage.CustomCopyOption) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Duration
	destination.Duration = genruntime.ClonePointerToString(option.Duration)

	// ObjectType
	if option.ObjectType != nil {
		objectType := string(*option.ObjectType)
		destination.ObjectType = &objectType
	} else {
		destination.ObjectType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type CustomCopyOption_STATUS struct {
	// Duration: Data copied after given timespan
	Duration *string `json:"duration,omitempty"`

	// ObjectType: Type of the specific object - used for deserializing
	ObjectType *CustomCopyOption_ObjectType_STATUS `json:"objectType,omitempty"`
}

var _ genruntime.FromARMConverter = &CustomCopyOption_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (option *CustomCopyOption_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.CustomCopyOption_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (option *CustomCopyOption_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.CustomCopyOption_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.CustomCopyOption_STATUS, got %T", armInput)
	}

	// Set property "Duration":
	if typedInput.Duration != nil {
		duration := *typedInput.Duration
		option.Duration = &duration
	}

	// Set property "ObjectType":
	var temp CustomCopyOption_ObjectType_STATUS
	var temp1 string
	temp1 = string(typedInput.ObjectType)
	temp = CustomCopyOption_ObjectType_STATUS(temp1)
	option.ObjectType = &temp

	// No error
	return nil
}

// AssignProperties_From_CustomCopyOption_STATUS populates our CustomCopyOption_STATUS from the provided source CustomCopyOption_STATUS
func (option *CustomCopyOption_STATUS) AssignProperties_From_CustomCopyOption_STATUS(source *storage.CustomCopyOption_STATUS) error {

	// Duration
	option.Duration = genruntime.ClonePointerToString(source.Duration)

	// ObjectType
	if source.ObjectType != nil {
		objectType := *source.ObjectType
		objectTypeTemp := genruntime.ToEnum(objectType, customCopyOption_ObjectType_STATUS_Values)
		option.ObjectType = &objectTypeTemp
	} else {
		option.ObjectType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_CustomCopyOption_STATUS populates the provided destination CustomCopyOption_STATUS from our CustomCopyOption_STATUS
func (option *CustomCopyOption_STATUS) AssignProperties_To_CustomCopyOption_STATUS(destination *storage.CustomCopyOption_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Duration
	destination.Duration = genruntime.ClonePointerToString(option.Duration)

	// ObjectType
	if option.ObjectType != nil {
		objectType := string(*option.ObjectType)
		destination.ObjectType = &objectType
	} else {
		destination.ObjectType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ImmediateCopyOption struct {
	// +kubebuilder:validation:Required
	// ObjectType: Type of the specific object - used for deserializing
	ObjectType *ImmediateCopyOption_ObjectType `json:"objectType,omitempty"`
}

var _ genruntime.ARMTransformer = &ImmediateCopyOption{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (option *ImmediateCopyOption) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if option == nil {
		return nil, nil
	}
	result := &arm.ImmediateCopyOption{}

	// Set property "ObjectType":
	if option.ObjectType != nil {
		var temp arm.ImmediateCopyOption_ObjectType
		var temp1 string
		temp1 = string(*option.ObjectType)
		temp = arm.ImmediateCopyOption_ObjectType(temp1)
		result.ObjectType = temp
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (option *ImmediateCopyOption) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ImmediateCopyOption{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (option *ImmediateCopyOption) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ImmediateCopyOption)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ImmediateCopyOption, got %T", armInput)
	}

	// Set property "ObjectType":
	var temp ImmediateCopyOption_ObjectType
	var temp1 string
	temp1 = string(typedInput.ObjectType)
	temp = ImmediateCopyOption_ObjectType(temp1)
	option.ObjectType = &temp

	// No error
	return nil
}

// AssignProperties_From_ImmediateCopyOption populates our ImmediateCopyOption from the provided source ImmediateCopyOption
func (option *ImmediateCopyOption) AssignProperties_From_ImmediateCopyOption(source *storage.ImmediateCopyOption) error {

	// ObjectType
	if source.ObjectType != nil {
		objectType := *source.ObjectType
		objectTypeTemp := genruntime.ToEnum(objectType, immediateCopyOption_ObjectType_Values)
		option.ObjectType = &objectTypeTemp
	} else {
		option.ObjectType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ImmediateCopyOption populates the provided destination ImmediateCopyOption from our ImmediateCopyOption
func (option *ImmediateCopyOption) AssignProperties_To_ImmediateCopyOption(destination *storage.ImmediateCopyOption) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ObjectType
	if option.ObjectType != nil {
		objectType := string(*option.ObjectType)
		destination.ObjectType = &objectType
	} else {
		destination.ObjectType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ImmediateCopyOption_STATUS struct {
	// ObjectType: Type of the specific object - used for deserializing
	ObjectType *ImmediateCopyOption_ObjectType_STATUS `json:"objectType,omitempty"`
}

var _ genruntime.FromARMConverter = &ImmediateCopyOption_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (option *ImmediateCopyOption_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ImmediateCopyOption_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (option *ImmediateCopyOption_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ImmediateCopyOption_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ImmediateCopyOption_STATUS, got %T", armInput)
	}

	// Set property "ObjectType":
	var temp ImmediateCopyOption_ObjectType_STATUS
	var temp1 string
	temp1 = string(typedInput.ObjectType)
	temp = ImmediateCopyOption_ObjectType_STATUS(temp1)
	option.ObjectType = &temp

	// No error
	return nil
}

// AssignProperties_From_ImmediateCopyOption_STATUS populates our ImmediateCopyOption_STATUS from the provided source ImmediateCopyOption_STATUS
func (option *ImmediateCopyOption_STATUS) AssignProperties_From_ImmediateCopyOption_STATUS(source *storage.ImmediateCopyOption_STATUS) error {

	// ObjectType
	if source.ObjectType != nil {
		objectType := *source.ObjectType
		objectTypeTemp := genruntime.ToEnum(objectType, immediateCopyOption_ObjectType_STATUS_Values)
		option.ObjectType = &objectTypeTemp
	} else {
		option.ObjectType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ImmediateCopyOption_STATUS populates the provided destination ImmediateCopyOption_STATUS from our ImmediateCopyOption_STATUS
func (option *ImmediateCopyOption_STATUS) AssignProperties_To_ImmediateCopyOption_STATUS(destination *storage.ImmediateCopyOption_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ObjectType
	if option.ObjectType != nil {
		objectType := string(*option.ObjectType)
		destination.ObjectType = &objectType
	} else {
		destination.ObjectType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Retention tag
type RetentionTag struct {
	// +kubebuilder:validation:Required
	// TagName: Retention Tag Name to relate it to retention rule.
	TagName *string `json:"tagName,omitempty"`
}

var _ genruntime.ARMTransformer = &RetentionTag{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (retentionTag *RetentionTag) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if retentionTag == nil {
		return nil, nil
	}
	result := &arm.RetentionTag{}

	// Set property "TagName":
	if retentionTag.TagName != nil {
		tagName := *retentionTag.TagName
		result.TagName = &tagName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (retentionTag *RetentionTag) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.RetentionTag{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (retentionTag *RetentionTag) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.RetentionTag)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.RetentionTag, got %T", armInput)
	}

	// Set property "TagName":
	if typedInput.TagName != nil {
		tagName := *typedInput.TagName
		retentionTag.TagName = &tagName
	}

	// No error
	return nil
}

// AssignProperties_From_RetentionTag populates our RetentionTag from the provided source RetentionTag
func (retentionTag *RetentionTag) AssignProperties_From_RetentionTag(source *storage.RetentionTag) error {

	// TagName
	retentionTag.TagName = genruntime.ClonePointerToString(source.TagName)

	// No error
	return nil
}

// AssignProperties_To_RetentionTag populates the provided destination RetentionTag from our RetentionTag
func (retentionTag *RetentionTag) AssignProperties_To_RetentionTag(destination *storage.RetentionTag) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// TagName
	destination.TagName = genruntime.ClonePointerToString(retentionTag.TagName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Retention tag
type RetentionTag_STATUS struct {
	// ETag: Retention Tag version.
	ETag *string `json:"eTag,omitempty"`

	// Id: Retention Tag version.
	Id *string `json:"id,omitempty"`

	// TagName: Retention Tag Name to relate it to retention rule.
	TagName *string `json:"tagName,omitempty"`
}

var _ genruntime.FromARMConverter = &RetentionTag_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (retentionTag *RetentionTag_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.RetentionTag_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (retentionTag *RetentionTag_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.RetentionTag_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.RetentionTag_STATUS, got %T", armInput)
	}

	// Set property "ETag":
	if typedInput.ETag != nil {
		eTag := *typedInput.ETag
		retentionTag.ETag = &eTag
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		retentionTag.Id = &id
	}

	// Set property "TagName":
	if typedInput.TagName != nil {
		tagName := *typedInput.TagName
		retentionTag.TagName = &tagName
	}

	// No error
	return nil
}

// AssignProperties_From_RetentionTag_STATUS populates our RetentionTag_STATUS from the provided source RetentionTag_STATUS
func (retentionTag *RetentionTag_STATUS) AssignProperties_From_RetentionTag_STATUS(source *storage.RetentionTag_STATUS) error {

	// ETag
	retentionTag.ETag = genruntime.ClonePointerToString(source.ETag)

	// Id
	retentionTag.Id = genruntime.ClonePointerToString(source.Id)

	// TagName
	retentionTag.TagName = genruntime.ClonePointerToString(source.TagName)

	// No error
	return nil
}

// AssignProperties_To_RetentionTag_STATUS populates the provided destination RetentionTag_STATUS from our RetentionTag_STATUS
func (retentionTag *RetentionTag_STATUS) AssignProperties_To_RetentionTag_STATUS(destination *storage.RetentionTag_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ETag
	destination.ETag = genruntime.ClonePointerToString(retentionTag.ETag)

	// Id
	destination.Id = genruntime.ClonePointerToString(retentionTag.Id)

	// TagName
	destination.TagName = genruntime.ClonePointerToString(retentionTag.TagName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"CopyOnExpiryOption"}
type CopyOnExpiryOption_ObjectType string

const CopyOnExpiryOption_ObjectType_CopyOnExpiryOption = CopyOnExpiryOption_ObjectType("CopyOnExpiryOption")

// Mapping from string to CopyOnExpiryOption_ObjectType
var copyOnExpiryOption_ObjectType_Values = map[string]CopyOnExpiryOption_ObjectType{
	"copyonexpiryoption": CopyOnExpiryOption_ObjectType_CopyOnExpiryOption,
}

type CopyOnExpiryOption_ObjectType_STATUS string

const CopyOnExpiryOption_ObjectType_STATUS_CopyOnExpiryOption = CopyOnExpiryOption_ObjectType_STATUS("CopyOnExpiryOption")

// Mapping from string to CopyOnExpiryOption_ObjectType_STATUS
var copyOnExpiryOption_ObjectType_STATUS_Values = map[string]CopyOnExpiryOption_ObjectType_STATUS{
	"copyonexpiryoption": CopyOnExpiryOption_ObjectType_STATUS_CopyOnExpiryOption,
}

// +kubebuilder:validation:Enum={"CustomCopyOption"}
type CustomCopyOption_ObjectType string

const CustomCopyOption_ObjectType_CustomCopyOption = CustomCopyOption_ObjectType("CustomCopyOption")

// Mapping from string to CustomCopyOption_ObjectType
var customCopyOption_ObjectType_Values = map[string]CustomCopyOption_ObjectType{
	"customcopyoption": CustomCopyOption_ObjectType_CustomCopyOption,
}

type CustomCopyOption_ObjectType_STATUS string

const CustomCopyOption_ObjectType_STATUS_CustomCopyOption = CustomCopyOption_ObjectType_STATUS("CustomCopyOption")

// Mapping from string to CustomCopyOption_ObjectType_STATUS
var customCopyOption_ObjectType_STATUS_Values = map[string]CustomCopyOption_ObjectType_STATUS{
	"customcopyoption": CustomCopyOption_ObjectType_STATUS_CustomCopyOption,
}

// +kubebuilder:validation:Enum={"ImmediateCopyOption"}
type ImmediateCopyOption_ObjectType string

const ImmediateCopyOption_ObjectType_ImmediateCopyOption = ImmediateCopyOption_ObjectType("ImmediateCopyOption")

// Mapping from string to ImmediateCopyOption_ObjectType
var immediateCopyOption_ObjectType_Values = map[string]ImmediateCopyOption_ObjectType{
	"immediatecopyoption": ImmediateCopyOption_ObjectType_ImmediateCopyOption,
}

type ImmediateCopyOption_ObjectType_STATUS string

const ImmediateCopyOption_ObjectType_STATUS_ImmediateCopyOption = ImmediateCopyOption_ObjectType_STATUS("ImmediateCopyOption")

// Mapping from string to ImmediateCopyOption_ObjectType_STATUS
var immediateCopyOption_ObjectType_STATUS_Values = map[string]ImmediateCopyOption_ObjectType_STATUS{
	"immediatecopyoption": ImmediateCopyOption_ObjectType_STATUS_ImmediateCopyOption,
}

type ScheduleBasedBackupCriteria struct {
	// AbsoluteCriteria: it contains absolute values like "AllBackup" / "FirstOfDay" / "FirstOfWeek" / "FirstOfMonth"
	// and should be part of AbsoluteMarker enum
	AbsoluteCriteria []ScheduleBasedBackupCriteria_AbsoluteCriteria `json:"absoluteCriteria,omitempty"`

	// DaysOfMonth: This is day of the month from 1 to 28 other wise last of month
	DaysOfMonth []Day `json:"daysOfMonth,omitempty"`

	// DaysOfTheWeek: It should be Sunday/Monday/T..../Saturday
	DaysOfTheWeek []ScheduleBasedBackupCriteria_DaysOfTheWeek `json:"daysOfTheWeek,omitempty"`

	// MonthsOfYear: It should be January/February/....../December
	MonthsOfYear []ScheduleBasedBackupCriteria_MonthsOfYear `json:"monthsOfYear,omitempty"`

	// +kubebuilder:validation:Required
	// ObjectType: Type of the specific object - used for deserializing
	ObjectType *ScheduleBasedBackupCriteria_ObjectType `json:"objectType,omitempty"`

	// ScheduleTimes: List of schedule times for backup
	ScheduleTimes []string `json:"scheduleTimes,omitempty"`

	// WeeksOfTheMonth: It should be First/Second/Third/Fourth/Last
	WeeksOfTheMonth []ScheduleBasedBackupCriteria_WeeksOfTheMonth `json:"weeksOfTheMonth,omitempty"`
}

var _ genruntime.ARMTransformer = &ScheduleBasedBackupCriteria{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (criteria *ScheduleBasedBackupCriteria) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if criteria == nil {
		return nil, nil
	}
	result := &arm.ScheduleBasedBackupCriteria{}

	// Set property "AbsoluteCriteria":
	for _, item := range criteria.AbsoluteCriteria {
		var temp string
		temp = string(item)
		result.AbsoluteCriteria = append(result.AbsoluteCriteria, arm.ScheduleBasedBackupCriteria_AbsoluteCriteria(temp))
	}

	// Set property "DaysOfMonth":
	for _, item := range criteria.DaysOfMonth {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.DaysOfMonth = append(result.DaysOfMonth, *item_ARM.(*arm.Day))
	}

	// Set property "DaysOfTheWeek":
	for _, item := range criteria.DaysOfTheWeek {
		var temp string
		temp = string(item)
		result.DaysOfTheWeek = append(result.DaysOfTheWeek, arm.ScheduleBasedBackupCriteria_DaysOfTheWeek(temp))
	}

	// Set property "MonthsOfYear":
	for _, item := range criteria.MonthsOfYear {
		var temp string
		temp = string(item)
		result.MonthsOfYear = append(result.MonthsOfYear, arm.ScheduleBasedBackupCriteria_MonthsOfYear(temp))
	}

	// Set property "ObjectType":
	if criteria.ObjectType != nil {
		var temp arm.ScheduleBasedBackupCriteria_ObjectType
		var temp1 string
		temp1 = string(*criteria.ObjectType)
		temp = arm.ScheduleBasedBackupCriteria_ObjectType(temp1)
		result.ObjectType = temp
	}

	// Set property "ScheduleTimes":
	for _, item := range criteria.ScheduleTimes {
		result.ScheduleTimes = append(result.ScheduleTimes, item)
	}

	// Set property "WeeksOfTheMonth":
	for _, item := range criteria.WeeksOfTheMonth {
		var temp string
		temp = string(item)
		result.WeeksOfTheMonth = append(result.WeeksOfTheMonth, arm.ScheduleBasedBackupCriteria_WeeksOfTheMonth(temp))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (criteria *ScheduleBasedBackupCriteria) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ScheduleBasedBackupCriteria{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (criteria *ScheduleBasedBackupCriteria) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ScheduleBasedBackupCriteria)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ScheduleBasedBackupCriteria, got %T", armInput)
	}

	// Set property "AbsoluteCriteria":
	for _, item := range typedInput.AbsoluteCriteria {
		var temp string
		temp = string(item)
		criteria.AbsoluteCriteria = append(criteria.AbsoluteCriteria, ScheduleBasedBackupCriteria_AbsoluteCriteria(temp))
	}

	// Set property "DaysOfMonth":
	for _, item := range typedInput.DaysOfMonth {
		var item1 Day
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		criteria.DaysOfMonth = append(criteria.DaysOfMonth, item1)
	}

	// Set property "DaysOfTheWeek":
	for _, item := range typedInput.DaysOfTheWeek {
		var temp string
		temp = string(item)
		criteria.DaysOfTheWeek = append(criteria.DaysOfTheWeek, ScheduleBasedBackupCriteria_DaysOfTheWeek(temp))
	}

	// Set property "MonthsOfYear":
	for _, item := range typedInput.MonthsOfYear {
		var temp string
		temp = string(item)
		criteria.MonthsOfYear = append(criteria.MonthsOfYear, ScheduleBasedBackupCriteria_MonthsOfYear(temp))
	}

	// Set property "ObjectType":
	var temp ScheduleBasedBackupCriteria_ObjectType
	var temp1 string
	temp1 = string(typedInput.ObjectType)
	temp = ScheduleBasedBackupCriteria_ObjectType(temp1)
	criteria.ObjectType = &temp

	// Set property "ScheduleTimes":
	for _, item := range typedInput.ScheduleTimes {
		criteria.ScheduleTimes = append(criteria.ScheduleTimes, item)
	}

	// Set property "WeeksOfTheMonth":
	for _, item := range typedInput.WeeksOfTheMonth {
		var itemTemp string
		itemTemp = string(item)
		criteria.WeeksOfTheMonth = append(criteria.WeeksOfTheMonth, ScheduleBasedBackupCriteria_WeeksOfTheMonth(itemTemp))
	}

	// No error
	return nil
}

// AssignProperties_From_ScheduleBasedBackupCriteria populates our ScheduleBasedBackupCriteria from the provided source ScheduleBasedBackupCriteria
func (criteria *ScheduleBasedBackupCriteria) AssignProperties_From_ScheduleBasedBackupCriteria(source *storage.ScheduleBasedBackupCriteria) error {

	// AbsoluteCriteria
	if source.AbsoluteCriteria != nil {
		absoluteCriterionList := make([]ScheduleBasedBackupCriteria_AbsoluteCriteria, len(source.AbsoluteCriteria))
		for absoluteCriterionIndex, absoluteCriterionItem := range source.AbsoluteCriteria {
			// Shadow the loop variable to avoid aliasing
			absoluteCriterionItem := absoluteCriterionItem
			absoluteCriterionList[absoluteCriterionIndex] = genruntime.ToEnum(absoluteCriterionItem, scheduleBasedBackupCriteria_AbsoluteCriteria_Values)
		}
		criteria.AbsoluteCriteria = absoluteCriterionList
	} else {
		criteria.AbsoluteCriteria = nil
	}

	// DaysOfMonth
	if source.DaysOfMonth != nil {
		daysOfMonthList := make([]Day, len(source.DaysOfMonth))
		for daysOfMonthIndex, daysOfMonthItem := range source.DaysOfMonth {
			// Shadow the loop variable to avoid aliasing
			daysOfMonthItem := daysOfMonthItem
			var daysOfMonth Day
			err := daysOfMonth.AssignProperties_From_Day(&daysOfMonthItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_Day() to populate field DaysOfMonth")
			}
			daysOfMonthList[daysOfMonthIndex] = daysOfMonth
		}
		criteria.DaysOfMonth = daysOfMonthList
	} else {
		criteria.DaysOfMonth = nil
	}

	// DaysOfTheWeek
	if source.DaysOfTheWeek != nil {
		daysOfTheWeekList := make([]ScheduleBasedBackupCriteria_DaysOfTheWeek, len(source.DaysOfTheWeek))
		for daysOfTheWeekIndex, daysOfTheWeekItem := range source.DaysOfTheWeek {
			// Shadow the loop variable to avoid aliasing
			daysOfTheWeekItem := daysOfTheWeekItem
			daysOfTheWeekList[daysOfTheWeekIndex] = genruntime.ToEnum(daysOfTheWeekItem, scheduleBasedBackupCriteria_DaysOfTheWeek_Values)
		}
		criteria.DaysOfTheWeek = daysOfTheWeekList
	} else {
		criteria.DaysOfTheWeek = nil
	}

	// MonthsOfYear
	if source.MonthsOfYear != nil {
		monthsOfYearList := make([]ScheduleBasedBackupCriteria_MonthsOfYear, len(source.MonthsOfYear))
		for monthsOfYearIndex, monthsOfYearItem := range source.MonthsOfYear {
			// Shadow the loop variable to avoid aliasing
			monthsOfYearItem := monthsOfYearItem
			monthsOfYearList[monthsOfYearIndex] = genruntime.ToEnum(monthsOfYearItem, scheduleBasedBackupCriteria_MonthsOfYear_Values)
		}
		criteria.MonthsOfYear = monthsOfYearList
	} else {
		criteria.MonthsOfYear = nil
	}

	// ObjectType
	if source.ObjectType != nil {
		objectType := *source.ObjectType
		objectTypeTemp := genruntime.ToEnum(objectType, scheduleBasedBackupCriteria_ObjectType_Values)
		criteria.ObjectType = &objectTypeTemp
	} else {
		criteria.ObjectType = nil
	}

	// ScheduleTimes
	criteria.ScheduleTimes = genruntime.CloneSliceOfString(source.ScheduleTimes)

	// WeeksOfTheMonth
	if source.WeeksOfTheMonth != nil {
		weeksOfTheMonthList := make([]ScheduleBasedBackupCriteria_WeeksOfTheMonth, len(source.WeeksOfTheMonth))
		for weeksOfTheMonthIndex, weeksOfTheMonthItem := range source.WeeksOfTheMonth {
			// Shadow the loop variable to avoid aliasing
			weeksOfTheMonthItem := weeksOfTheMonthItem
			weeksOfTheMonthList[weeksOfTheMonthIndex] = genruntime.ToEnum(weeksOfTheMonthItem, scheduleBasedBackupCriteria_WeeksOfTheMonth_Values)
		}
		criteria.WeeksOfTheMonth = weeksOfTheMonthList
	} else {
		criteria.WeeksOfTheMonth = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ScheduleBasedBackupCriteria populates the provided destination ScheduleBasedBackupCriteria from our ScheduleBasedBackupCriteria
func (criteria *ScheduleBasedBackupCriteria) AssignProperties_To_ScheduleBasedBackupCriteria(destination *storage.ScheduleBasedBackupCriteria) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AbsoluteCriteria
	if criteria.AbsoluteCriteria != nil {
		absoluteCriterionList := make([]string, len(criteria.AbsoluteCriteria))
		for absoluteCriterionIndex, absoluteCriterionItem := range criteria.AbsoluteCriteria {
			// Shadow the loop variable to avoid aliasing
			absoluteCriterionItem := absoluteCriterionItem
			absoluteCriterionList[absoluteCriterionIndex] = string(absoluteCriterionItem)
		}
		destination.AbsoluteCriteria = absoluteCriterionList
	} else {
		destination.AbsoluteCriteria = nil
	}

	// DaysOfMonth
	if criteria.DaysOfMonth != nil {
		daysOfMonthList := make([]storage.Day, len(criteria.DaysOfMonth))
		for daysOfMonthIndex, daysOfMonthItem := range criteria.DaysOfMonth {
			// Shadow the loop variable to avoid aliasing
			daysOfMonthItem := daysOfMonthItem
			var daysOfMonth storage.Day
			err := daysOfMonthItem.AssignProperties_To_Day(&daysOfMonth)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_Day() to populate field DaysOfMonth")
			}
			daysOfMonthList[daysOfMonthIndex] = daysOfMonth
		}
		destination.DaysOfMonth = daysOfMonthList
	} else {
		destination.DaysOfMonth = nil
	}

	// DaysOfTheWeek
	if criteria.DaysOfTheWeek != nil {
		daysOfTheWeekList := make([]string, len(criteria.DaysOfTheWeek))
		for daysOfTheWeekIndex, daysOfTheWeekItem := range criteria.DaysOfTheWeek {
			// Shadow the loop variable to avoid aliasing
			daysOfTheWeekItem := daysOfTheWeekItem
			daysOfTheWeekList[daysOfTheWeekIndex] = string(daysOfTheWeekItem)
		}
		destination.DaysOfTheWeek = daysOfTheWeekList
	} else {
		destination.DaysOfTheWeek = nil
	}

	// MonthsOfYear
	if criteria.MonthsOfYear != nil {
		monthsOfYearList := make([]string, len(criteria.MonthsOfYear))
		for monthsOfYearIndex, monthsOfYearItem := range criteria.MonthsOfYear {
			// Shadow the loop variable to avoid aliasing
			monthsOfYearItem := monthsOfYearItem
			monthsOfYearList[monthsOfYearIndex] = string(monthsOfYearItem)
		}
		destination.MonthsOfYear = monthsOfYearList
	} else {
		destination.MonthsOfYear = nil
	}

	// ObjectType
	if criteria.ObjectType != nil {
		objectType := string(*criteria.ObjectType)
		destination.ObjectType = &objectType
	} else {
		destination.ObjectType = nil
	}

	// ScheduleTimes
	destination.ScheduleTimes = genruntime.CloneSliceOfString(criteria.ScheduleTimes)

	// WeeksOfTheMonth
	if criteria.WeeksOfTheMonth != nil {
		weeksOfTheMonthList := make([]string, len(criteria.WeeksOfTheMonth))
		for weeksOfTheMonthIndex, weeksOfTheMonthItem := range criteria.WeeksOfTheMonth {
			// Shadow the loop variable to avoid aliasing
			weeksOfTheMonthItem := weeksOfTheMonthItem
			weeksOfTheMonthList[weeksOfTheMonthIndex] = string(weeksOfTheMonthItem)
		}
		destination.WeeksOfTheMonth = weeksOfTheMonthList
	} else {
		destination.WeeksOfTheMonth = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ScheduleBasedBackupCriteria_STATUS struct {
	// AbsoluteCriteria: it contains absolute values like "AllBackup" / "FirstOfDay" / "FirstOfWeek" / "FirstOfMonth"
	// and should be part of AbsoluteMarker enum
	AbsoluteCriteria []ScheduleBasedBackupCriteria_AbsoluteCriteria_STATUS `json:"absoluteCriteria,omitempty"`

	// DaysOfMonth: This is day of the month from 1 to 28 other wise last of month
	DaysOfMonth []Day_STATUS `json:"daysOfMonth,omitempty"`

	// DaysOfTheWeek: It should be Sunday/Monday/T..../Saturday
	DaysOfTheWeek []ScheduleBasedBackupCriteria_DaysOfTheWeek_STATUS `json:"daysOfTheWeek,omitempty"`

	// MonthsOfYear: It should be January/February/....../December
	MonthsOfYear []ScheduleBasedBackupCriteria_MonthsOfYear_STATUS `json:"monthsOfYear,omitempty"`

	// ObjectType: Type of the specific object - used for deserializing
	ObjectType *ScheduleBasedBackupCriteria_ObjectType_STATUS `json:"objectType,omitempty"`

	// ScheduleTimes: List of schedule times for backup
	ScheduleTimes []string `json:"scheduleTimes,omitempty"`

	// WeeksOfTheMonth: It should be First/Second/Third/Fourth/Last
	WeeksOfTheMonth []ScheduleBasedBackupCriteria_WeeksOfTheMonth_STATUS `json:"weeksOfTheMonth,omitempty"`
}

var _ genruntime.FromARMConverter = &ScheduleBasedBackupCriteria_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (criteria *ScheduleBasedBackupCriteria_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ScheduleBasedBackupCriteria_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (criteria *ScheduleBasedBackupCriteria_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ScheduleBasedBackupCriteria_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ScheduleBasedBackupCriteria_STATUS, got %T", armInput)
	}

	// Set property "AbsoluteCriteria":
	for _, item := range typedInput.AbsoluteCriteria {
		var temp string
		temp = string(item)
		criteria.AbsoluteCriteria = append(criteria.AbsoluteCriteria, ScheduleBasedBackupCriteria_AbsoluteCriteria_STATUS(temp))
	}

	// Set property "DaysOfMonth":
	for _, item := range typedInput.DaysOfMonth {
		var item1 Day_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		criteria.DaysOfMonth = append(criteria.DaysOfMonth, item1)
	}

	// Set property "DaysOfTheWeek":
	for _, item := range typedInput.DaysOfTheWeek {
		var temp string
		temp = string(item)
		criteria.DaysOfTheWeek = append(criteria.DaysOfTheWeek, ScheduleBasedBackupCriteria_DaysOfTheWeek_STATUS(temp))
	}

	// Set property "MonthsOfYear":
	for _, item := range typedInput.MonthsOfYear {
		var temp string
		temp = string(item)
		criteria.MonthsOfYear = append(criteria.MonthsOfYear, ScheduleBasedBackupCriteria_MonthsOfYear_STATUS(temp))
	}

	// Set property "ObjectType":
	var temp ScheduleBasedBackupCriteria_ObjectType_STATUS
	var temp1 string
	temp1 = string(typedInput.ObjectType)
	temp = ScheduleBasedBackupCriteria_ObjectType_STATUS(temp1)
	criteria.ObjectType = &temp

	// Set property "ScheduleTimes":
	for _, item := range typedInput.ScheduleTimes {
		criteria.ScheduleTimes = append(criteria.ScheduleTimes, item)
	}

	// Set property "WeeksOfTheMonth":
	for _, item := range typedInput.WeeksOfTheMonth {
		var itemTemp string
		itemTemp = string(item)
		criteria.WeeksOfTheMonth = append(criteria.WeeksOfTheMonth, ScheduleBasedBackupCriteria_WeeksOfTheMonth_STATUS(itemTemp))
	}

	// No error
	return nil
}

// AssignProperties_From_ScheduleBasedBackupCriteria_STATUS populates our ScheduleBasedBackupCriteria_STATUS from the provided source ScheduleBasedBackupCriteria_STATUS
func (criteria *ScheduleBasedBackupCriteria_STATUS) AssignProperties_From_ScheduleBasedBackupCriteria_STATUS(source *storage.ScheduleBasedBackupCriteria_STATUS) error {

	// AbsoluteCriteria
	if source.AbsoluteCriteria != nil {
		absoluteCriterionList := make([]ScheduleBasedBackupCriteria_AbsoluteCriteria_STATUS, len(source.AbsoluteCriteria))
		for absoluteCriterionIndex, absoluteCriterionItem := range source.AbsoluteCriteria {
			// Shadow the loop variable to avoid aliasing
			absoluteCriterionItem := absoluteCriterionItem
			absoluteCriterionList[absoluteCriterionIndex] = genruntime.ToEnum(absoluteCriterionItem, scheduleBasedBackupCriteria_AbsoluteCriteria_STATUS_Values)
		}
		criteria.AbsoluteCriteria = absoluteCriterionList
	} else {
		criteria.AbsoluteCriteria = nil
	}

	// DaysOfMonth
	if source.DaysOfMonth != nil {
		daysOfMonthList := make([]Day_STATUS, len(source.DaysOfMonth))
		for daysOfMonthIndex, daysOfMonthItem := range source.DaysOfMonth {
			// Shadow the loop variable to avoid aliasing
			daysOfMonthItem := daysOfMonthItem
			var daysOfMonth Day_STATUS
			err := daysOfMonth.AssignProperties_From_Day_STATUS(&daysOfMonthItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_Day_STATUS() to populate field DaysOfMonth")
			}
			daysOfMonthList[daysOfMonthIndex] = daysOfMonth
		}
		criteria.DaysOfMonth = daysOfMonthList
	} else {
		criteria.DaysOfMonth = nil
	}

	// DaysOfTheWeek
	if source.DaysOfTheWeek != nil {
		daysOfTheWeekList := make([]ScheduleBasedBackupCriteria_DaysOfTheWeek_STATUS, len(source.DaysOfTheWeek))
		for daysOfTheWeekIndex, daysOfTheWeekItem := range source.DaysOfTheWeek {
			// Shadow the loop variable to avoid aliasing
			daysOfTheWeekItem := daysOfTheWeekItem
			daysOfTheWeekList[daysOfTheWeekIndex] = genruntime.ToEnum(daysOfTheWeekItem, scheduleBasedBackupCriteria_DaysOfTheWeek_STATUS_Values)
		}
		criteria.DaysOfTheWeek = daysOfTheWeekList
	} else {
		criteria.DaysOfTheWeek = nil
	}

	// MonthsOfYear
	if source.MonthsOfYear != nil {
		monthsOfYearList := make([]ScheduleBasedBackupCriteria_MonthsOfYear_STATUS, len(source.MonthsOfYear))
		for monthsOfYearIndex, monthsOfYearItem := range source.MonthsOfYear {
			// Shadow the loop variable to avoid aliasing
			monthsOfYearItem := monthsOfYearItem
			monthsOfYearList[monthsOfYearIndex] = genruntime.ToEnum(monthsOfYearItem, scheduleBasedBackupCriteria_MonthsOfYear_STATUS_Values)
		}
		criteria.MonthsOfYear = monthsOfYearList
	} else {
		criteria.MonthsOfYear = nil
	}

	// ObjectType
	if source.ObjectType != nil {
		objectType := *source.ObjectType
		objectTypeTemp := genruntime.ToEnum(objectType, scheduleBasedBackupCriteria_ObjectType_STATUS_Values)
		criteria.ObjectType = &objectTypeTemp
	} else {
		criteria.ObjectType = nil
	}

	// ScheduleTimes
	criteria.ScheduleTimes = genruntime.CloneSliceOfString(source.ScheduleTimes)

	// WeeksOfTheMonth
	if source.WeeksOfTheMonth != nil {
		weeksOfTheMonthList := make([]ScheduleBasedBackupCriteria_WeeksOfTheMonth_STATUS, len(source.WeeksOfTheMonth))
		for weeksOfTheMonthIndex, weeksOfTheMonthItem := range source.WeeksOfTheMonth {
			// Shadow the loop variable to avoid aliasing
			weeksOfTheMonthItem := weeksOfTheMonthItem
			weeksOfTheMonthList[weeksOfTheMonthIndex] = genruntime.ToEnum(weeksOfTheMonthItem, scheduleBasedBackupCriteria_WeeksOfTheMonth_STATUS_Values)
		}
		criteria.WeeksOfTheMonth = weeksOfTheMonthList
	} else {
		criteria.WeeksOfTheMonth = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ScheduleBasedBackupCriteria_STATUS populates the provided destination ScheduleBasedBackupCriteria_STATUS from our ScheduleBasedBackupCriteria_STATUS
func (criteria *ScheduleBasedBackupCriteria_STATUS) AssignProperties_To_ScheduleBasedBackupCriteria_STATUS(destination *storage.ScheduleBasedBackupCriteria_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AbsoluteCriteria
	if criteria.AbsoluteCriteria != nil {
		absoluteCriterionList := make([]string, len(criteria.AbsoluteCriteria))
		for absoluteCriterionIndex, absoluteCriterionItem := range criteria.AbsoluteCriteria {
			// Shadow the loop variable to avoid aliasing
			absoluteCriterionItem := absoluteCriterionItem
			absoluteCriterionList[absoluteCriterionIndex] = string(absoluteCriterionItem)
		}
		destination.AbsoluteCriteria = absoluteCriterionList
	} else {
		destination.AbsoluteCriteria = nil
	}

	// DaysOfMonth
	if criteria.DaysOfMonth != nil {
		daysOfMonthList := make([]storage.Day_STATUS, len(criteria.DaysOfMonth))
		for daysOfMonthIndex, daysOfMonthItem := range criteria.DaysOfMonth {
			// Shadow the loop variable to avoid aliasing
			daysOfMonthItem := daysOfMonthItem
			var daysOfMonth storage.Day_STATUS
			err := daysOfMonthItem.AssignProperties_To_Day_STATUS(&daysOfMonth)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_Day_STATUS() to populate field DaysOfMonth")
			}
			daysOfMonthList[daysOfMonthIndex] = daysOfMonth
		}
		destination.DaysOfMonth = daysOfMonthList
	} else {
		destination.DaysOfMonth = nil
	}

	// DaysOfTheWeek
	if criteria.DaysOfTheWeek != nil {
		daysOfTheWeekList := make([]string, len(criteria.DaysOfTheWeek))
		for daysOfTheWeekIndex, daysOfTheWeekItem := range criteria.DaysOfTheWeek {
			// Shadow the loop variable to avoid aliasing
			daysOfTheWeekItem := daysOfTheWeekItem
			daysOfTheWeekList[daysOfTheWeekIndex] = string(daysOfTheWeekItem)
		}
		destination.DaysOfTheWeek = daysOfTheWeekList
	} else {
		destination.DaysOfTheWeek = nil
	}

	// MonthsOfYear
	if criteria.MonthsOfYear != nil {
		monthsOfYearList := make([]string, len(criteria.MonthsOfYear))
		for monthsOfYearIndex, monthsOfYearItem := range criteria.MonthsOfYear {
			// Shadow the loop variable to avoid aliasing
			monthsOfYearItem := monthsOfYearItem
			monthsOfYearList[monthsOfYearIndex] = string(monthsOfYearItem)
		}
		destination.MonthsOfYear = monthsOfYearList
	} else {
		destination.MonthsOfYear = nil
	}

	// ObjectType
	if criteria.ObjectType != nil {
		objectType := string(*criteria.ObjectType)
		destination.ObjectType = &objectType
	} else {
		destination.ObjectType = nil
	}

	// ScheduleTimes
	destination.ScheduleTimes = genruntime.CloneSliceOfString(criteria.ScheduleTimes)

	// WeeksOfTheMonth
	if criteria.WeeksOfTheMonth != nil {
		weeksOfTheMonthList := make([]string, len(criteria.WeeksOfTheMonth))
		for weeksOfTheMonthIndex, weeksOfTheMonthItem := range criteria.WeeksOfTheMonth {
			// Shadow the loop variable to avoid aliasing
			weeksOfTheMonthItem := weeksOfTheMonthItem
			weeksOfTheMonthList[weeksOfTheMonthIndex] = string(weeksOfTheMonthItem)
		}
		destination.WeeksOfTheMonth = weeksOfTheMonthList
	} else {
		destination.WeeksOfTheMonth = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Day of the week
type Day struct {
	// Date: Date of the month
	Date *int `json:"date,omitempty"`

	// IsLast: Whether Date is last date of month
	IsLast *bool `json:"isLast,omitempty"`
}

var _ genruntime.ARMTransformer = &Day{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (day *Day) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if day == nil {
		return nil, nil
	}
	result := &arm.Day{}

	// Set property "Date":
	if day.Date != nil {
		date := *day.Date
		result.Date = &date
	}

	// Set property "IsLast":
	if day.IsLast != nil {
		isLast := *day.IsLast
		result.IsLast = &isLast
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (day *Day) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Day{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (day *Day) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Day)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Day, got %T", armInput)
	}

	// Set property "Date":
	if typedInput.Date != nil {
		date := *typedInput.Date
		day.Date = &date
	}

	// Set property "IsLast":
	if typedInput.IsLast != nil {
		isLast := *typedInput.IsLast
		day.IsLast = &isLast
	}

	// No error
	return nil
}

// AssignProperties_From_Day populates our Day from the provided source Day
func (day *Day) AssignProperties_From_Day(source *storage.Day) error {

	// Date
	day.Date = genruntime.ClonePointerToInt(source.Date)

	// IsLast
	if source.IsLast != nil {
		isLast := *source.IsLast
		day.IsLast = &isLast
	} else {
		day.IsLast = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Day populates the provided destination Day from our Day
func (day *Day) AssignProperties_To_Day(destination *storage.Day) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Date
	destination.Date = genruntime.ClonePointerToInt(day.Date)

	// IsLast
	if day.IsLast != nil {
		isLast := *day.IsLast
		destination.IsLast = &isLast
	} else {
		destination.IsLast = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Day of the week
type Day_STATUS struct {
	// Date: Date of the month
	Date *int `json:"date,omitempty"`

	// IsLast: Whether Date is last date of month
	IsLast *bool `json:"isLast,omitempty"`
}

var _ genruntime.FromARMConverter = &Day_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (day *Day_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Day_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (day *Day_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Day_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Day_STATUS, got %T", armInput)
	}

	// Set property "Date":
	if typedInput.Date != nil {
		date := *typedInput.Date
		day.Date = &date
	}

	// Set property "IsLast":
	if typedInput.IsLast != nil {
		isLast := *typedInput.IsLast
		day.IsLast = &isLast
	}

	// No error
	return nil
}

// AssignProperties_From_Day_STATUS populates our Day_STATUS from the provided source Day_STATUS
func (day *Day_STATUS) AssignProperties_From_Day_STATUS(source *storage.Day_STATUS) error {

	// Date
	day.Date = genruntime.ClonePointerToInt(source.Date)

	// IsLast
	if source.IsLast != nil {
		isLast := *source.IsLast
		day.IsLast = &isLast
	} else {
		day.IsLast = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Day_STATUS populates the provided destination Day_STATUS from our Day_STATUS
func (day *Day_STATUS) AssignProperties_To_Day_STATUS(destination *storage.Day_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Date
	destination.Date = genruntime.ClonePointerToInt(day.Date)

	// IsLast
	if day.IsLast != nil {
		isLast := *day.IsLast
		destination.IsLast = &isLast
	} else {
		destination.IsLast = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"AllBackup","FirstOfDay","FirstOfMonth","FirstOfWeek","FirstOfYear"}
type ScheduleBasedBackupCriteria_AbsoluteCriteria string

const (
	ScheduleBasedBackupCriteria_AbsoluteCriteria_AllBackup    = ScheduleBasedBackupCriteria_AbsoluteCriteria("AllBackup")
	ScheduleBasedBackupCriteria_AbsoluteCriteria_FirstOfDay   = ScheduleBasedBackupCriteria_AbsoluteCriteria("FirstOfDay")
	ScheduleBasedBackupCriteria_AbsoluteCriteria_FirstOfMonth = ScheduleBasedBackupCriteria_AbsoluteCriteria("FirstOfMonth")
	ScheduleBasedBackupCriteria_AbsoluteCriteria_FirstOfWeek  = ScheduleBasedBackupCriteria_AbsoluteCriteria("FirstOfWeek")
	ScheduleBasedBackupCriteria_AbsoluteCriteria_FirstOfYear  = ScheduleBasedBackupCriteria_AbsoluteCriteria("FirstOfYear")
)

// Mapping from string to ScheduleBasedBackupCriteria_AbsoluteCriteria
var scheduleBasedBackupCriteria_AbsoluteCriteria_Values = map[string]ScheduleBasedBackupCriteria_AbsoluteCriteria{
	"allbackup":    ScheduleBasedBackupCriteria_AbsoluteCriteria_AllBackup,
	"firstofday":   ScheduleBasedBackupCriteria_AbsoluteCriteria_FirstOfDay,
	"firstofmonth": ScheduleBasedBackupCriteria_AbsoluteCriteria_FirstOfMonth,
	"firstofweek":  ScheduleBasedBackupCriteria_AbsoluteCriteria_FirstOfWeek,
	"firstofyear":  ScheduleBasedBackupCriteria_AbsoluteCriteria_FirstOfYear,
}

type ScheduleBasedBackupCriteria_AbsoluteCriteria_STATUS string

const (
	ScheduleBasedBackupCriteria_AbsoluteCriteria_STATUS_AllBackup    = ScheduleBasedBackupCriteria_AbsoluteCriteria_STATUS("AllBackup")
	ScheduleBasedBackupCriteria_AbsoluteCriteria_STATUS_FirstOfDay   = ScheduleBasedBackupCriteria_AbsoluteCriteria_STATUS("FirstOfDay")
	ScheduleBasedBackupCriteria_AbsoluteCriteria_STATUS_FirstOfMonth = ScheduleBasedBackupCriteria_AbsoluteCriteria_STATUS("FirstOfMonth")
	ScheduleBasedBackupCriteria_AbsoluteCriteria_STATUS_FirstOfWeek  = ScheduleBasedBackupCriteria_AbsoluteCriteria_STATUS("FirstOfWeek")
	ScheduleBasedBackupCriteria_AbsoluteCriteria_STATUS_FirstOfYear  = ScheduleBasedBackupCriteria_AbsoluteCriteria_STATUS("FirstOfYear")
)

// Mapping from string to ScheduleBasedBackupCriteria_AbsoluteCriteria_STATUS
var scheduleBasedBackupCriteria_AbsoluteCriteria_STATUS_Values = map[string]ScheduleBasedBackupCriteria_AbsoluteCriteria_STATUS{
	"allbackup":    ScheduleBasedBackupCriteria_AbsoluteCriteria_STATUS_AllBackup,
	"firstofday":   ScheduleBasedBackupCriteria_AbsoluteCriteria_STATUS_FirstOfDay,
	"firstofmonth": ScheduleBasedBackupCriteria_AbsoluteCriteria_STATUS_FirstOfMonth,
	"firstofweek":  ScheduleBasedBackupCriteria_AbsoluteCriteria_STATUS_FirstOfWeek,
	"firstofyear":  ScheduleBasedBackupCriteria_AbsoluteCriteria_STATUS_FirstOfYear,
}

// +kubebuilder:validation:Enum={"Friday","Monday","Saturday","Sunday","Thursday","Tuesday","Wednesday"}
type ScheduleBasedBackupCriteria_DaysOfTheWeek string

const (
	ScheduleBasedBackupCriteria_DaysOfTheWeek_Friday    = ScheduleBasedBackupCriteria_DaysOfTheWeek("Friday")
	ScheduleBasedBackupCriteria_DaysOfTheWeek_Monday    = ScheduleBasedBackupCriteria_DaysOfTheWeek("Monday")
	ScheduleBasedBackupCriteria_DaysOfTheWeek_Saturday  = ScheduleBasedBackupCriteria_DaysOfTheWeek("Saturday")
	ScheduleBasedBackupCriteria_DaysOfTheWeek_Sunday    = ScheduleBasedBackupCriteria_DaysOfTheWeek("Sunday")
	ScheduleBasedBackupCriteria_DaysOfTheWeek_Thursday  = ScheduleBasedBackupCriteria_DaysOfTheWeek("Thursday")
	ScheduleBasedBackupCriteria_DaysOfTheWeek_Tuesday   = ScheduleBasedBackupCriteria_DaysOfTheWeek("Tuesday")
	ScheduleBasedBackupCriteria_DaysOfTheWeek_Wednesday = ScheduleBasedBackupCriteria_DaysOfTheWeek("Wednesday")
)

// Mapping from string to ScheduleBasedBackupCriteria_DaysOfTheWeek
var scheduleBasedBackupCriteria_DaysOfTheWeek_Values = map[string]ScheduleBasedBackupCriteria_DaysOfTheWeek{
	"friday":    ScheduleBasedBackupCriteria_DaysOfTheWeek_Friday,
	"monday":    ScheduleBasedBackupCriteria_DaysOfTheWeek_Monday,
	"saturday":  ScheduleBasedBackupCriteria_DaysOfTheWeek_Saturday,
	"sunday":    ScheduleBasedBackupCriteria_DaysOfTheWeek_Sunday,
	"thursday":  ScheduleBasedBackupCriteria_DaysOfTheWeek_Thursday,
	"tuesday":   ScheduleBasedBackupCriteria_DaysOfTheWeek_Tuesday,
	"wednesday": ScheduleBasedBackupCriteria_DaysOfTheWeek_Wednesday,
}

type ScheduleBasedBackupCriteria_DaysOfTheWeek_STATUS string

const (
	ScheduleBasedBackupCriteria_DaysOfTheWeek_STATUS_Friday    = ScheduleBasedBackupCriteria_DaysOfTheWeek_STATUS("Friday")
	ScheduleBasedBackupCriteria_DaysOfTheWeek_STATUS_Monday    = ScheduleBasedBackupCriteria_DaysOfTheWeek_STATUS("Monday")
	ScheduleBasedBackupCriteria_DaysOfTheWeek_STATUS_Saturday  = ScheduleBasedBackupCriteria_DaysOfTheWeek_STATUS("Saturday")
	ScheduleBasedBackupCriteria_DaysOfTheWeek_STATUS_Sunday    = ScheduleBasedBackupCriteria_DaysOfTheWeek_STATUS("Sunday")
	ScheduleBasedBackupCriteria_DaysOfTheWeek_STATUS_Thursday  = ScheduleBasedBackupCriteria_DaysOfTheWeek_STATUS("Thursday")
	ScheduleBasedBackupCriteria_DaysOfTheWeek_STATUS_Tuesday   = ScheduleBasedBackupCriteria_DaysOfTheWeek_STATUS("Tuesday")
	ScheduleBasedBackupCriteria_DaysOfTheWeek_STATUS_Wednesday = ScheduleBasedBackupCriteria_DaysOfTheWeek_STATUS("Wednesday")
)

// Mapping from string to ScheduleBasedBackupCriteria_DaysOfTheWeek_STATUS
var scheduleBasedBackupCriteria_DaysOfTheWeek_STATUS_Values = map[string]ScheduleBasedBackupCriteria_DaysOfTheWeek_STATUS{
	"friday":    ScheduleBasedBackupCriteria_DaysOfTheWeek_STATUS_Friday,
	"monday":    ScheduleBasedBackupCriteria_DaysOfTheWeek_STATUS_Monday,
	"saturday":  ScheduleBasedBackupCriteria_DaysOfTheWeek_STATUS_Saturday,
	"sunday":    ScheduleBasedBackupCriteria_DaysOfTheWeek_STATUS_Sunday,
	"thursday":  ScheduleBasedBackupCriteria_DaysOfTheWeek_STATUS_Thursday,
	"tuesday":   ScheduleBasedBackupCriteria_DaysOfTheWeek_STATUS_Tuesday,
	"wednesday": ScheduleBasedBackupCriteria_DaysOfTheWeek_STATUS_Wednesday,
}

// +kubebuilder:validation:Enum={"April","August","December","February","January","July","June","March","May","November","October","September"}
type ScheduleBasedBackupCriteria_MonthsOfYear string

const (
	ScheduleBasedBackupCriteria_MonthsOfYear_April     = ScheduleBasedBackupCriteria_MonthsOfYear("April")
	ScheduleBasedBackupCriteria_MonthsOfYear_August    = ScheduleBasedBackupCriteria_MonthsOfYear("August")
	ScheduleBasedBackupCriteria_MonthsOfYear_December  = ScheduleBasedBackupCriteria_MonthsOfYear("December")
	ScheduleBasedBackupCriteria_MonthsOfYear_February  = ScheduleBasedBackupCriteria_MonthsOfYear("February")
	ScheduleBasedBackupCriteria_MonthsOfYear_January   = ScheduleBasedBackupCriteria_MonthsOfYear("January")
	ScheduleBasedBackupCriteria_MonthsOfYear_July      = ScheduleBasedBackupCriteria_MonthsOfYear("July")
	ScheduleBasedBackupCriteria_MonthsOfYear_June      = ScheduleBasedBackupCriteria_MonthsOfYear("June")
	ScheduleBasedBackupCriteria_MonthsOfYear_March     = ScheduleBasedBackupCriteria_MonthsOfYear("March")
	ScheduleBasedBackupCriteria_MonthsOfYear_May       = ScheduleBasedBackupCriteria_MonthsOfYear("May")
	ScheduleBasedBackupCriteria_MonthsOfYear_November  = ScheduleBasedBackupCriteria_MonthsOfYear("November")
	ScheduleBasedBackupCriteria_MonthsOfYear_October   = ScheduleBasedBackupCriteria_MonthsOfYear("October")
	ScheduleBasedBackupCriteria_MonthsOfYear_September = ScheduleBasedBackupCriteria_MonthsOfYear("September")
)

// Mapping from string to ScheduleBasedBackupCriteria_MonthsOfYear
var scheduleBasedBackupCriteria_MonthsOfYear_Values = map[string]ScheduleBasedBackupCriteria_MonthsOfYear{
	"april":     ScheduleBasedBackupCriteria_MonthsOfYear_April,
	"august":    ScheduleBasedBackupCriteria_MonthsOfYear_August,
	"december":  ScheduleBasedBackupCriteria_MonthsOfYear_December,
	"february":  ScheduleBasedBackupCriteria_MonthsOfYear_February,
	"january":   ScheduleBasedBackupCriteria_MonthsOfYear_January,
	"july":      ScheduleBasedBackupCriteria_MonthsOfYear_July,
	"june":      ScheduleBasedBackupCriteria_MonthsOfYear_June,
	"march":     ScheduleBasedBackupCriteria_MonthsOfYear_March,
	"may":       ScheduleBasedBackupCriteria_MonthsOfYear_May,
	"november":  ScheduleBasedBackupCriteria_MonthsOfYear_November,
	"october":   ScheduleBasedBackupCriteria_MonthsOfYear_October,
	"september": ScheduleBasedBackupCriteria_MonthsOfYear_September,
}

type ScheduleBasedBackupCriteria_MonthsOfYear_STATUS string

const (
	ScheduleBasedBackupCriteria_MonthsOfYear_STATUS_April     = ScheduleBasedBackupCriteria_MonthsOfYear_STATUS("April")
	ScheduleBasedBackupCriteria_MonthsOfYear_STATUS_August    = ScheduleBasedBackupCriteria_MonthsOfYear_STATUS("August")
	ScheduleBasedBackupCriteria_MonthsOfYear_STATUS_December  = ScheduleBasedBackupCriteria_MonthsOfYear_STATUS("December")
	ScheduleBasedBackupCriteria_MonthsOfYear_STATUS_February  = ScheduleBasedBackupCriteria_MonthsOfYear_STATUS("February")
	ScheduleBasedBackupCriteria_MonthsOfYear_STATUS_January   = ScheduleBasedBackupCriteria_MonthsOfYear_STATUS("January")
	ScheduleBasedBackupCriteria_MonthsOfYear_STATUS_July      = ScheduleBasedBackupCriteria_MonthsOfYear_STATUS("July")
	ScheduleBasedBackupCriteria_MonthsOfYear_STATUS_June      = ScheduleBasedBackupCriteria_MonthsOfYear_STATUS("June")
	ScheduleBasedBackupCriteria_MonthsOfYear_STATUS_March     = ScheduleBasedBackupCriteria_MonthsOfYear_STATUS("March")
	ScheduleBasedBackupCriteria_MonthsOfYear_STATUS_May       = ScheduleBasedBackupCriteria_MonthsOfYear_STATUS("May")
	ScheduleBasedBackupCriteria_MonthsOfYear_STATUS_November  = ScheduleBasedBackupCriteria_MonthsOfYear_STATUS("November")
	ScheduleBasedBackupCriteria_MonthsOfYear_STATUS_October   = ScheduleBasedBackupCriteria_MonthsOfYear_STATUS("October")
	ScheduleBasedBackupCriteria_MonthsOfYear_STATUS_September = ScheduleBasedBackupCriteria_MonthsOfYear_STATUS("September")
)

// Mapping from string to ScheduleBasedBackupCriteria_MonthsOfYear_STATUS
var scheduleBasedBackupCriteria_MonthsOfYear_STATUS_Values = map[string]ScheduleBasedBackupCriteria_MonthsOfYear_STATUS{
	"april":     ScheduleBasedBackupCriteria_MonthsOfYear_STATUS_April,
	"august":    ScheduleBasedBackupCriteria_MonthsOfYear_STATUS_August,
	"december":  ScheduleBasedBackupCriteria_MonthsOfYear_STATUS_December,
	"february":  ScheduleBasedBackupCriteria_MonthsOfYear_STATUS_February,
	"january":   ScheduleBasedBackupCriteria_MonthsOfYear_STATUS_January,
	"july":      ScheduleBasedBackupCriteria_MonthsOfYear_STATUS_July,
	"june":      ScheduleBasedBackupCriteria_MonthsOfYear_STATUS_June,
	"march":     ScheduleBasedBackupCriteria_MonthsOfYear_STATUS_March,
	"may":       ScheduleBasedBackupCriteria_MonthsOfYear_STATUS_May,
	"november":  ScheduleBasedBackupCriteria_MonthsOfYear_STATUS_November,
	"october":   ScheduleBasedBackupCriteria_MonthsOfYear_STATUS_October,
	"september": ScheduleBasedBackupCriteria_MonthsOfYear_STATUS_September,
}

// +kubebuilder:validation:Enum={"ScheduleBasedBackupCriteria"}
type ScheduleBasedBackupCriteria_ObjectType string

const ScheduleBasedBackupCriteria_ObjectType_ScheduleBasedBackupCriteria = ScheduleBasedBackupCriteria_ObjectType("ScheduleBasedBackupCriteria")

// Mapping from string to ScheduleBasedBackupCriteria_ObjectType
var scheduleBasedBackupCriteria_ObjectType_Values = map[string]ScheduleBasedBackupCriteria_ObjectType{
	"schedulebasedbackupcriteria": ScheduleBasedBackupCriteria_ObjectType_ScheduleBasedBackupCriteria,
}

type ScheduleBasedBackupCriteria_ObjectType_STATUS string

const ScheduleBasedBackupCriteria_ObjectType_STATUS_ScheduleBasedBackupCriteria = ScheduleBasedBackupCriteria_ObjectType_STATUS("ScheduleBasedBackupCriteria")

// Mapping from string to ScheduleBasedBackupCriteria_ObjectType_STATUS
var scheduleBasedBackupCriteria_ObjectType_STATUS_Values = map[string]ScheduleBasedBackupCriteria_ObjectType_STATUS{
	"schedulebasedbackupcriteria": ScheduleBasedBackupCriteria_ObjectType_STATUS_ScheduleBasedBackupCriteria,
}

// +kubebuilder:validation:Enum={"First","Fourth","Last","Second","Third"}
type ScheduleBasedBackupCriteria_WeeksOfTheMonth string

const (
	ScheduleBasedBackupCriteria_WeeksOfTheMonth_First  = ScheduleBasedBackupCriteria_WeeksOfTheMonth("First")
	ScheduleBasedBackupCriteria_WeeksOfTheMonth_Fourth = ScheduleBasedBackupCriteria_WeeksOfTheMonth("Fourth")
	ScheduleBasedBackupCriteria_WeeksOfTheMonth_Last   = ScheduleBasedBackupCriteria_WeeksOfTheMonth("Last")
	ScheduleBasedBackupCriteria_WeeksOfTheMonth_Second = ScheduleBasedBackupCriteria_WeeksOfTheMonth("Second")
	ScheduleBasedBackupCriteria_WeeksOfTheMonth_Third  = ScheduleBasedBackupCriteria_WeeksOfTheMonth("Third")
)

// Mapping from string to ScheduleBasedBackupCriteria_WeeksOfTheMonth
var scheduleBasedBackupCriteria_WeeksOfTheMonth_Values = map[string]ScheduleBasedBackupCriteria_WeeksOfTheMonth{
	"first":  ScheduleBasedBackupCriteria_WeeksOfTheMonth_First,
	"fourth": ScheduleBasedBackupCriteria_WeeksOfTheMonth_Fourth,
	"last":   ScheduleBasedBackupCriteria_WeeksOfTheMonth_Last,
	"second": ScheduleBasedBackupCriteria_WeeksOfTheMonth_Second,
	"third":  ScheduleBasedBackupCriteria_WeeksOfTheMonth_Third,
}

type ScheduleBasedBackupCriteria_WeeksOfTheMonth_STATUS string

const (
	ScheduleBasedBackupCriteria_WeeksOfTheMonth_STATUS_First  = ScheduleBasedBackupCriteria_WeeksOfTheMonth_STATUS("First")
	ScheduleBasedBackupCriteria_WeeksOfTheMonth_STATUS_Fourth = ScheduleBasedBackupCriteria_WeeksOfTheMonth_STATUS("Fourth")
	ScheduleBasedBackupCriteria_WeeksOfTheMonth_STATUS_Last   = ScheduleBasedBackupCriteria_WeeksOfTheMonth_STATUS("Last")
	ScheduleBasedBackupCriteria_WeeksOfTheMonth_STATUS_Second = ScheduleBasedBackupCriteria_WeeksOfTheMonth_STATUS("Second")
	ScheduleBasedBackupCriteria_WeeksOfTheMonth_STATUS_Third  = ScheduleBasedBackupCriteria_WeeksOfTheMonth_STATUS("Third")
)

// Mapping from string to ScheduleBasedBackupCriteria_WeeksOfTheMonth_STATUS
var scheduleBasedBackupCriteria_WeeksOfTheMonth_STATUS_Values = map[string]ScheduleBasedBackupCriteria_WeeksOfTheMonth_STATUS{
	"first":  ScheduleBasedBackupCriteria_WeeksOfTheMonth_STATUS_First,
	"fourth": ScheduleBasedBackupCriteria_WeeksOfTheMonth_STATUS_Fourth,
	"last":   ScheduleBasedBackupCriteria_WeeksOfTheMonth_STATUS_Last,
	"second": ScheduleBasedBackupCriteria_WeeksOfTheMonth_STATUS_Second,
	"third":  ScheduleBasedBackupCriteria_WeeksOfTheMonth_STATUS_Third,
}

func init() {
	SchemeBuilder.Register(&BackupVaultsBackupPolicy{}, &BackupVaultsBackupPolicyList{})
}
