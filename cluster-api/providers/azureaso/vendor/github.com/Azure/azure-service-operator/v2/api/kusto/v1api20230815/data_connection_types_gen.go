// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20230815

import (
	"fmt"
	arm "github.com/Azure/azure-service-operator/v2/api/kusto/v1api20230815/arm"
	storage "github.com/Azure/azure-service-operator/v2/api/kusto/v1api20230815/storage"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/configmaps"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/core"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/secrets"
	"github.com/rotisserie/eris"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
)

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Generator information:
// - Generated from: /azure-kusto/resource-manager/Microsoft.Kusto/stable/2023-08-15/kusto.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/databases/{databaseName}/dataConnections/{dataConnectionName}
type DataConnection struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              DataConnection_Spec   `json:"spec,omitempty"`
	Status            DataConnection_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &DataConnection{}

// GetConditions returns the conditions of the resource
func (connection *DataConnection) GetConditions() conditions.Conditions {
	return connection.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (connection *DataConnection) SetConditions(conditions conditions.Conditions) {
	connection.Status.Conditions = conditions
}

var _ conversion.Convertible = &DataConnection{}

// ConvertFrom populates our DataConnection from the provided hub DataConnection
func (connection *DataConnection) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*storage.DataConnection)
	if !ok {
		return fmt.Errorf("expected kusto/v1api20230815/storage/DataConnection but received %T instead", hub)
	}

	return connection.AssignProperties_From_DataConnection(source)
}

// ConvertTo populates the provided hub DataConnection from our DataConnection
func (connection *DataConnection) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*storage.DataConnection)
	if !ok {
		return fmt.Errorf("expected kusto/v1api20230815/storage/DataConnection but received %T instead", hub)
	}

	return connection.AssignProperties_To_DataConnection(destination)
}

var _ configmaps.Exporter = &DataConnection{}

// ConfigMapDestinationExpressions returns the Spec.OperatorSpec.ConfigMapExpressions property
func (connection *DataConnection) ConfigMapDestinationExpressions() []*core.DestinationExpression {
	if connection.Spec.OperatorSpec == nil {
		return nil
	}
	return connection.Spec.OperatorSpec.ConfigMapExpressions
}

var _ secrets.Exporter = &DataConnection{}

// SecretDestinationExpressions returns the Spec.OperatorSpec.SecretExpressions property
func (connection *DataConnection) SecretDestinationExpressions() []*core.DestinationExpression {
	if connection.Spec.OperatorSpec == nil {
		return nil
	}
	return connection.Spec.OperatorSpec.SecretExpressions
}

var _ genruntime.ImportableResource = &DataConnection{}

// InitializeSpec initializes the spec for this resource from the given status
func (connection *DataConnection) InitializeSpec(status genruntime.ConvertibleStatus) error {
	if s, ok := status.(*DataConnection_STATUS); ok {
		return connection.Spec.Initialize_From_DataConnection_STATUS(s)
	}

	return fmt.Errorf("expected Status of type DataConnection_STATUS but received %T instead", status)
}

var _ genruntime.KubernetesResource = &DataConnection{}

// AzureName returns the Azure name of the resource
func (connection *DataConnection) AzureName() string {
	return connection.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2023-08-15"
func (connection DataConnection) GetAPIVersion() string {
	return "2023-08-15"
}

// GetResourceScope returns the scope of the resource
func (connection *DataConnection) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (connection *DataConnection) GetSpec() genruntime.ConvertibleSpec {
	return &connection.Spec
}

// GetStatus returns the status of this resource
func (connection *DataConnection) GetStatus() genruntime.ConvertibleStatus {
	return &connection.Status
}

// GetSupportedOperations returns the operations supported by the resource
func (connection *DataConnection) GetSupportedOperations() []genruntime.ResourceOperation {
	return []genruntime.ResourceOperation{
		genruntime.ResourceOperationDelete,
		genruntime.ResourceOperationGet,
		genruntime.ResourceOperationPut,
	}
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.Kusto/clusters/databases/dataConnections"
func (connection *DataConnection) GetType() string {
	return "Microsoft.Kusto/clusters/databases/dataConnections"
}

// NewEmptyStatus returns a new empty (blank) status
func (connection *DataConnection) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &DataConnection_STATUS{}
}

// Owner returns the ResourceReference of the owner
func (connection *DataConnection) Owner() *genruntime.ResourceReference {
	if connection.Spec.Owner == nil {
		return nil
	}

	group, kind := genruntime.LookupOwnerGroupKind(connection.Spec)
	return connection.Spec.Owner.AsResourceReference(group, kind)
}

// SetStatus sets the status of this resource
func (connection *DataConnection) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*DataConnection_STATUS); ok {
		connection.Status = *st
		return nil
	}

	// Convert status to required version
	var st DataConnection_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return eris.Wrap(err, "failed to convert status")
	}

	connection.Status = st
	return nil
}

// AssignProperties_From_DataConnection populates our DataConnection from the provided source DataConnection
func (connection *DataConnection) AssignProperties_From_DataConnection(source *storage.DataConnection) error {

	// ObjectMeta
	connection.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec DataConnection_Spec
	err := spec.AssignProperties_From_DataConnection_Spec(&source.Spec)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_From_DataConnection_Spec() to populate field Spec")
	}
	connection.Spec = spec

	// Status
	var status DataConnection_STATUS
	err = status.AssignProperties_From_DataConnection_STATUS(&source.Status)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_From_DataConnection_STATUS() to populate field Status")
	}
	connection.Status = status

	// No error
	return nil
}

// AssignProperties_To_DataConnection populates the provided destination DataConnection from our DataConnection
func (connection *DataConnection) AssignProperties_To_DataConnection(destination *storage.DataConnection) error {

	// ObjectMeta
	destination.ObjectMeta = *connection.ObjectMeta.DeepCopy()

	// Spec
	var spec storage.DataConnection_Spec
	err := connection.Spec.AssignProperties_To_DataConnection_Spec(&spec)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_To_DataConnection_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status storage.DataConnection_STATUS
	err = connection.Status.AssignProperties_To_DataConnection_STATUS(&status)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_To_DataConnection_STATUS() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (connection *DataConnection) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: connection.Spec.OriginalVersion(),
		Kind:    "DataConnection",
	}
}

// +kubebuilder:object:root=true
// Generator information:
// - Generated from: /azure-kusto/resource-manager/Microsoft.Kusto/stable/2023-08-15/kusto.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/databases/{databaseName}/dataConnections/{dataConnectionName}
type DataConnectionList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []DataConnection `json:"items"`
}

type DataConnection_Spec struct {
	// +kubebuilder:validation:Pattern="^.*$"
	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName string `json:"azureName,omitempty"`

	// CosmosDb: Mutually exclusive with all other properties
	CosmosDb *CosmosDbDataConnection `json:"cosmosDbDataConnection,omitempty"`

	// EventGrid: Mutually exclusive with all other properties
	EventGrid *EventGridDataConnection `json:"eventGridDataConnection,omitempty"`

	// EventHub: Mutually exclusive with all other properties
	EventHub *EventHubDataConnection `json:"eventHubDataConnection,omitempty"`

	// IotHub: Mutually exclusive with all other properties
	IotHub *IotHubDataConnection `json:"iotHubDataConnection,omitempty"`

	// OperatorSpec: The specification for configuring operator behavior. This field is interpreted by the operator and not
	// passed directly to Azure
	OperatorSpec *DataConnectionOperatorSpec `json:"operatorSpec,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a kusto.azure.com/Database resource
	Owner *genruntime.KnownResourceReference `group:"kusto.azure.com" json:"owner,omitempty" kind:"Database"`
}

var _ genruntime.ARMTransformer = &DataConnection_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (connection *DataConnection_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if connection == nil {
		return nil, nil
	}
	result := &arm.DataConnection_Spec{}

	// Set property "CosmosDb":
	if connection.CosmosDb != nil {
		cosmosDb_ARM, err := (*connection.CosmosDb).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		cosmosDb := *cosmosDb_ARM.(*arm.CosmosDbDataConnection)
		result.CosmosDb = &cosmosDb
		result.CosmosDb.Name = connection.AzureName
	}

	// Set property "EventGrid":
	if connection.EventGrid != nil {
		eventGrid_ARM, err := (*connection.EventGrid).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		eventGrid := *eventGrid_ARM.(*arm.EventGridDataConnection)
		result.EventGrid = &eventGrid
		result.EventGrid.Name = connection.AzureName
	}

	// Set property "EventHub":
	if connection.EventHub != nil {
		eventHub_ARM, err := (*connection.EventHub).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		eventHub := *eventHub_ARM.(*arm.EventHubDataConnection)
		result.EventHub = &eventHub
		result.EventHub.Name = connection.AzureName
	}

	// Set property "IotHub":
	if connection.IotHub != nil {
		iotHub_ARM, err := (*connection.IotHub).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		iotHub := *iotHub_ARM.(*arm.IotHubDataConnection)
		result.IotHub = &iotHub
		result.IotHub.Name = connection.AzureName
	}

	// Set property "Name":
	result.Name = resolved.Name
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (connection *DataConnection_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DataConnection_Spec{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (connection *DataConnection_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DataConnection_Spec)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DataConnection_Spec, got %T", armInput)
	}

	// Set property "AzureName":
	connection.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property "CosmosDb":
	if typedInput.CosmosDb != nil {
		var cosmosDb1 CosmosDbDataConnection
		err := cosmosDb1.PopulateFromARM(owner, *typedInput.CosmosDb)
		if err != nil {
			return err
		}
		cosmosDb := cosmosDb1
		connection.CosmosDb = &cosmosDb
		connection.AzureName = typedInput.CosmosDb.Name
	}

	// Set property "EventGrid":
	if typedInput.EventGrid != nil {
		var eventGrid1 EventGridDataConnection
		err := eventGrid1.PopulateFromARM(owner, *typedInput.EventGrid)
		if err != nil {
			return err
		}
		eventGrid := eventGrid1
		connection.EventGrid = &eventGrid
		connection.AzureName = typedInput.EventGrid.Name
	}

	// Set property "EventHub":
	if typedInput.EventHub != nil {
		var eventHub1 EventHubDataConnection
		err := eventHub1.PopulateFromARM(owner, *typedInput.EventHub)
		if err != nil {
			return err
		}
		eventHub := eventHub1
		connection.EventHub = &eventHub
		connection.AzureName = typedInput.EventHub.Name
	}

	// Set property "IotHub":
	if typedInput.IotHub != nil {
		var iotHub1 IotHubDataConnection
		err := iotHub1.PopulateFromARM(owner, *typedInput.IotHub)
		if err != nil {
			return err
		}
		iotHub := iotHub1
		connection.IotHub = &iotHub
		connection.AzureName = typedInput.IotHub.Name
	}

	// no assignment for property "OperatorSpec"

	// Set property "Owner":
	connection.Owner = &genruntime.KnownResourceReference{
		Name:  owner.Name,
		ARMID: owner.ARMID,
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &DataConnection_Spec{}

// ConvertSpecFrom populates our DataConnection_Spec from the provided source
func (connection *DataConnection_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*storage.DataConnection_Spec)
	if ok {
		// Populate our instance from source
		return connection.AssignProperties_From_DataConnection_Spec(src)
	}

	// Convert to an intermediate form
	src = &storage.DataConnection_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = connection.AssignProperties_From_DataConnection_Spec(src)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our DataConnection_Spec
func (connection *DataConnection_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*storage.DataConnection_Spec)
	if ok {
		// Populate destination from our instance
		return connection.AssignProperties_To_DataConnection_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &storage.DataConnection_Spec{}
	err := connection.AssignProperties_To_DataConnection_Spec(dst)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignProperties_From_DataConnection_Spec populates our DataConnection_Spec from the provided source DataConnection_Spec
func (connection *DataConnection_Spec) AssignProperties_From_DataConnection_Spec(source *storage.DataConnection_Spec) error {

	// AzureName
	connection.AzureName = source.AzureName

	// CosmosDb
	if source.CosmosDb != nil {
		var cosmosDb CosmosDbDataConnection
		err := cosmosDb.AssignProperties_From_CosmosDbDataConnection(source.CosmosDb)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_CosmosDbDataConnection() to populate field CosmosDb")
		}
		connection.CosmosDb = &cosmosDb
	} else {
		connection.CosmosDb = nil
	}

	// EventGrid
	if source.EventGrid != nil {
		var eventGrid EventGridDataConnection
		err := eventGrid.AssignProperties_From_EventGridDataConnection(source.EventGrid)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_EventGridDataConnection() to populate field EventGrid")
		}
		connection.EventGrid = &eventGrid
	} else {
		connection.EventGrid = nil
	}

	// EventHub
	if source.EventHub != nil {
		var eventHub EventHubDataConnection
		err := eventHub.AssignProperties_From_EventHubDataConnection(source.EventHub)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_EventHubDataConnection() to populate field EventHub")
		}
		connection.EventHub = &eventHub
	} else {
		connection.EventHub = nil
	}

	// IotHub
	if source.IotHub != nil {
		var iotHub IotHubDataConnection
		err := iotHub.AssignProperties_From_IotHubDataConnection(source.IotHub)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_IotHubDataConnection() to populate field IotHub")
		}
		connection.IotHub = &iotHub
	} else {
		connection.IotHub = nil
	}

	// OperatorSpec
	if source.OperatorSpec != nil {
		var operatorSpec DataConnectionOperatorSpec
		err := operatorSpec.AssignProperties_From_DataConnectionOperatorSpec(source.OperatorSpec)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_DataConnectionOperatorSpec() to populate field OperatorSpec")
		}
		connection.OperatorSpec = &operatorSpec
	} else {
		connection.OperatorSpec = nil
	}

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		connection.Owner = &owner
	} else {
		connection.Owner = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DataConnection_Spec populates the provided destination DataConnection_Spec from our DataConnection_Spec
func (connection *DataConnection_Spec) AssignProperties_To_DataConnection_Spec(destination *storage.DataConnection_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureName
	destination.AzureName = connection.AzureName

	// CosmosDb
	if connection.CosmosDb != nil {
		var cosmosDb storage.CosmosDbDataConnection
		err := connection.CosmosDb.AssignProperties_To_CosmosDbDataConnection(&cosmosDb)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_CosmosDbDataConnection() to populate field CosmosDb")
		}
		destination.CosmosDb = &cosmosDb
	} else {
		destination.CosmosDb = nil
	}

	// EventGrid
	if connection.EventGrid != nil {
		var eventGrid storage.EventGridDataConnection
		err := connection.EventGrid.AssignProperties_To_EventGridDataConnection(&eventGrid)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_EventGridDataConnection() to populate field EventGrid")
		}
		destination.EventGrid = &eventGrid
	} else {
		destination.EventGrid = nil
	}

	// EventHub
	if connection.EventHub != nil {
		var eventHub storage.EventHubDataConnection
		err := connection.EventHub.AssignProperties_To_EventHubDataConnection(&eventHub)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_EventHubDataConnection() to populate field EventHub")
		}
		destination.EventHub = &eventHub
	} else {
		destination.EventHub = nil
	}

	// IotHub
	if connection.IotHub != nil {
		var iotHub storage.IotHubDataConnection
		err := connection.IotHub.AssignProperties_To_IotHubDataConnection(&iotHub)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_IotHubDataConnection() to populate field IotHub")
		}
		destination.IotHub = &iotHub
	} else {
		destination.IotHub = nil
	}

	// OperatorSpec
	if connection.OperatorSpec != nil {
		var operatorSpec storage.DataConnectionOperatorSpec
		err := connection.OperatorSpec.AssignProperties_To_DataConnectionOperatorSpec(&operatorSpec)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_DataConnectionOperatorSpec() to populate field OperatorSpec")
		}
		destination.OperatorSpec = &operatorSpec
	} else {
		destination.OperatorSpec = nil
	}

	// OriginalVersion
	destination.OriginalVersion = connection.OriginalVersion()

	// Owner
	if connection.Owner != nil {
		owner := connection.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DataConnection_STATUS populates our DataConnection_Spec from the provided source DataConnection_STATUS
func (connection *DataConnection_Spec) Initialize_From_DataConnection_STATUS(source *DataConnection_STATUS) error {

	// CosmosDb
	if source.CosmosDb != nil {
		var cosmosDb CosmosDbDataConnection
		err := cosmosDb.Initialize_From_CosmosDbDataConnection_STATUS(source.CosmosDb)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_CosmosDbDataConnection_STATUS() to populate field CosmosDb")
		}
		connection.CosmosDb = &cosmosDb
	} else {
		connection.CosmosDb = nil
	}

	// EventGrid
	if source.EventGrid != nil {
		var eventGrid EventGridDataConnection
		err := eventGrid.Initialize_From_EventGridDataConnection_STATUS(source.EventGrid)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_EventGridDataConnection_STATUS() to populate field EventGrid")
		}
		connection.EventGrid = &eventGrid
	} else {
		connection.EventGrid = nil
	}

	// EventHub
	if source.EventHub != nil {
		var eventHub EventHubDataConnection
		err := eventHub.Initialize_From_EventHubDataConnection_STATUS(source.EventHub)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_EventHubDataConnection_STATUS() to populate field EventHub")
		}
		connection.EventHub = &eventHub
	} else {
		connection.EventHub = nil
	}

	// IotHub
	if source.IotHub != nil {
		var iotHub IotHubDataConnection
		err := iotHub.Initialize_From_IotHubDataConnection_STATUS(source.IotHub)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_IotHubDataConnection_STATUS() to populate field IotHub")
		}
		connection.IotHub = &iotHub
	} else {
		connection.IotHub = nil
	}

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (connection *DataConnection_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (connection *DataConnection_Spec) SetAzureName(azureName string) {
	connection.AzureName = azureName
}

type DataConnection_STATUS struct {
	// Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	// CosmosDb: Mutually exclusive with all other properties
	CosmosDb *CosmosDbDataConnection_STATUS `json:"cosmosDb,omitempty"`

	// EventGrid: Mutually exclusive with all other properties
	EventGrid *EventGridDataConnection_STATUS `json:"eventGrid,omitempty"`

	// EventHub: Mutually exclusive with all other properties
	EventHub *EventHubDataConnection_STATUS `json:"eventHub,omitempty"`

	// IotHub: Mutually exclusive with all other properties
	IotHub *IotHubDataConnection_STATUS `json:"iotHub,omitempty"`

	// Name: The name of the resource
	Name *string `json:"name,omitempty"`
}

var _ genruntime.ConvertibleStatus = &DataConnection_STATUS{}

// ConvertStatusFrom populates our DataConnection_STATUS from the provided source
func (connection *DataConnection_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*storage.DataConnection_STATUS)
	if ok {
		// Populate our instance from source
		return connection.AssignProperties_From_DataConnection_STATUS(src)
	}

	// Convert to an intermediate form
	src = &storage.DataConnection_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = connection.AssignProperties_From_DataConnection_STATUS(src)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our DataConnection_STATUS
func (connection *DataConnection_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*storage.DataConnection_STATUS)
	if ok {
		// Populate destination from our instance
		return connection.AssignProperties_To_DataConnection_STATUS(dst)
	}

	// Convert to an intermediate form
	dst = &storage.DataConnection_STATUS{}
	err := connection.AssignProperties_To_DataConnection_STATUS(dst)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &DataConnection_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (connection *DataConnection_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DataConnection_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (connection *DataConnection_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DataConnection_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DataConnection_STATUS, got %T", armInput)
	}

	// no assignment for property "Conditions"

	// Set property "CosmosDb":
	if typedInput.CosmosDb != nil {
		var cosmosDb1 CosmosDbDataConnection_STATUS
		err := cosmosDb1.PopulateFromARM(owner, *typedInput.CosmosDb)
		if err != nil {
			return err
		}
		cosmosDb := cosmosDb1
		connection.CosmosDb = &cosmosDb
		connection.Name = typedInput.CosmosDb.Name
	}

	// Set property "EventGrid":
	if typedInput.EventGrid != nil {
		var eventGrid1 EventGridDataConnection_STATUS
		err := eventGrid1.PopulateFromARM(owner, *typedInput.EventGrid)
		if err != nil {
			return err
		}
		eventGrid := eventGrid1
		connection.EventGrid = &eventGrid
		connection.Name = typedInput.EventGrid.Name
	}

	// Set property "EventHub":
	if typedInput.EventHub != nil {
		var eventHub1 EventHubDataConnection_STATUS
		err := eventHub1.PopulateFromARM(owner, *typedInput.EventHub)
		if err != nil {
			return err
		}
		eventHub := eventHub1
		connection.EventHub = &eventHub
		connection.Name = typedInput.EventHub.Name
	}

	// Set property "IotHub":
	if typedInput.IotHub != nil {
		var iotHub1 IotHubDataConnection_STATUS
		err := iotHub1.PopulateFromARM(owner, *typedInput.IotHub)
		if err != nil {
			return err
		}
		iotHub := iotHub1
		connection.IotHub = &iotHub
		connection.Name = typedInput.IotHub.Name
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		connection.Name = &name
	}

	// No error
	return nil
}

// AssignProperties_From_DataConnection_STATUS populates our DataConnection_STATUS from the provided source DataConnection_STATUS
func (connection *DataConnection_STATUS) AssignProperties_From_DataConnection_STATUS(source *storage.DataConnection_STATUS) error {

	// Conditions
	connection.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// CosmosDb
	if source.CosmosDb != nil {
		var cosmosDb CosmosDbDataConnection_STATUS
		err := cosmosDb.AssignProperties_From_CosmosDbDataConnection_STATUS(source.CosmosDb)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_CosmosDbDataConnection_STATUS() to populate field CosmosDb")
		}
		connection.CosmosDb = &cosmosDb
	} else {
		connection.CosmosDb = nil
	}

	// EventGrid
	if source.EventGrid != nil {
		var eventGrid EventGridDataConnection_STATUS
		err := eventGrid.AssignProperties_From_EventGridDataConnection_STATUS(source.EventGrid)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_EventGridDataConnection_STATUS() to populate field EventGrid")
		}
		connection.EventGrid = &eventGrid
	} else {
		connection.EventGrid = nil
	}

	// EventHub
	if source.EventHub != nil {
		var eventHub EventHubDataConnection_STATUS
		err := eventHub.AssignProperties_From_EventHubDataConnection_STATUS(source.EventHub)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_EventHubDataConnection_STATUS() to populate field EventHub")
		}
		connection.EventHub = &eventHub
	} else {
		connection.EventHub = nil
	}

	// IotHub
	if source.IotHub != nil {
		var iotHub IotHubDataConnection_STATUS
		err := iotHub.AssignProperties_From_IotHubDataConnection_STATUS(source.IotHub)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_IotHubDataConnection_STATUS() to populate field IotHub")
		}
		connection.IotHub = &iotHub
	} else {
		connection.IotHub = nil
	}

	// Name
	connection.Name = genruntime.ClonePointerToString(source.Name)

	// No error
	return nil
}

// AssignProperties_To_DataConnection_STATUS populates the provided destination DataConnection_STATUS from our DataConnection_STATUS
func (connection *DataConnection_STATUS) AssignProperties_To_DataConnection_STATUS(destination *storage.DataConnection_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(connection.Conditions)

	// CosmosDb
	if connection.CosmosDb != nil {
		var cosmosDb storage.CosmosDbDataConnection_STATUS
		err := connection.CosmosDb.AssignProperties_To_CosmosDbDataConnection_STATUS(&cosmosDb)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_CosmosDbDataConnection_STATUS() to populate field CosmosDb")
		}
		destination.CosmosDb = &cosmosDb
	} else {
		destination.CosmosDb = nil
	}

	// EventGrid
	if connection.EventGrid != nil {
		var eventGrid storage.EventGridDataConnection_STATUS
		err := connection.EventGrid.AssignProperties_To_EventGridDataConnection_STATUS(&eventGrid)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_EventGridDataConnection_STATUS() to populate field EventGrid")
		}
		destination.EventGrid = &eventGrid
	} else {
		destination.EventGrid = nil
	}

	// EventHub
	if connection.EventHub != nil {
		var eventHub storage.EventHubDataConnection_STATUS
		err := connection.EventHub.AssignProperties_To_EventHubDataConnection_STATUS(&eventHub)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_EventHubDataConnection_STATUS() to populate field EventHub")
		}
		destination.EventHub = &eventHub
	} else {
		destination.EventHub = nil
	}

	// IotHub
	if connection.IotHub != nil {
		var iotHub storage.IotHubDataConnection_STATUS
		err := connection.IotHub.AssignProperties_To_IotHubDataConnection_STATUS(&iotHub)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_IotHubDataConnection_STATUS() to populate field IotHub")
		}
		destination.IotHub = &iotHub
	} else {
		destination.IotHub = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(connection.Name)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type CosmosDbDataConnection struct {
	// +kubebuilder:validation:Required
	// CosmosDbAccountResourceReference: The resource ID of the Cosmos DB account used to create the data connection.
	CosmosDbAccountResourceReference *genruntime.ResourceReference `armReference:"CosmosDbAccountResourceId" json:"cosmosDbAccountResourceReference,omitempty"`

	// +kubebuilder:validation:Required
	// CosmosDbContainer: The name of an existing container in the Cosmos DB database.
	CosmosDbContainer *string `json:"cosmosDbContainer,omitempty"`

	// +kubebuilder:validation:Required
	// CosmosDbDatabase: The name of an existing database in the Cosmos DB account.
	CosmosDbDatabase *string `json:"cosmosDbDatabase,omitempty"`

	// +kubebuilder:validation:Required
	// Kind: Kind of the endpoint for the data connection
	Kind *CosmosDbDataConnection_Kind `json:"kind,omitempty"`

	// Location: Resource location.
	Location *string `json:"location,omitempty"`

	// +kubebuilder:validation:Required
	// ManagedIdentityResourceReference: The resource ID of a managed system or user-assigned identity. The identity is used to
	// authenticate with Cosmos DB.
	ManagedIdentityResourceReference *genruntime.ResourceReference `armReference:"ManagedIdentityResourceId" json:"managedIdentityResourceReference,omitempty"`

	// MappingRuleName: The name of an existing mapping rule to use when ingesting the retrieved data.
	MappingRuleName *string `json:"mappingRuleName,omitempty"`

	// RetrievalStartDate: Optional. If defined, the data connection retrieves Cosmos DB documents created or updated after the
	// specified retrieval start date.
	RetrievalStartDate *string `json:"retrievalStartDate,omitempty"`

	// +kubebuilder:validation:Required
	// TableName: The case-sensitive name of the existing target table in your cluster. Retrieved data is ingested into this
	// table.
	TableName *string `json:"tableName,omitempty"`
}

var _ genruntime.ARMTransformer = &CosmosDbDataConnection{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (connection *CosmosDbDataConnection) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if connection == nil {
		return nil, nil
	}
	result := &arm.CosmosDbDataConnection{}

	// Set property "Kind":
	if connection.Kind != nil {
		var temp arm.CosmosDbDataConnection_Kind
		var temp1 string
		temp1 = string(*connection.Kind)
		temp = arm.CosmosDbDataConnection_Kind(temp1)
		result.Kind = temp
	}

	// Set property "Location":
	if connection.Location != nil {
		location := *connection.Location
		result.Location = &location
	}

	// no assignment for property "Name"

	// Set property "Properties":
	if connection.CosmosDbAccountResourceReference != nil ||
		connection.CosmosDbContainer != nil ||
		connection.CosmosDbDatabase != nil ||
		connection.ManagedIdentityResourceReference != nil ||
		connection.MappingRuleName != nil ||
		connection.RetrievalStartDate != nil ||
		connection.TableName != nil {
		result.Properties = &arm.CosmosDbDataConnectionProperties{}
	}
	if connection.CosmosDbAccountResourceReference != nil {
		cosmosDbAccountResourceIdARMID, err := resolved.ResolvedReferences.Lookup(*connection.CosmosDbAccountResourceReference)
		if err != nil {
			return nil, err
		}
		cosmosDbAccountResourceId := cosmosDbAccountResourceIdARMID
		result.Properties.CosmosDbAccountResourceId = &cosmosDbAccountResourceId
	}
	if connection.CosmosDbContainer != nil {
		cosmosDbContainer := *connection.CosmosDbContainer
		result.Properties.CosmosDbContainer = &cosmosDbContainer
	}
	if connection.CosmosDbDatabase != nil {
		cosmosDbDatabase := *connection.CosmosDbDatabase
		result.Properties.CosmosDbDatabase = &cosmosDbDatabase
	}
	if connection.ManagedIdentityResourceReference != nil {
		managedIdentityResourceIdARMID, err := resolved.ResolvedReferences.Lookup(*connection.ManagedIdentityResourceReference)
		if err != nil {
			return nil, err
		}
		managedIdentityResourceId := managedIdentityResourceIdARMID
		result.Properties.ManagedIdentityResourceId = &managedIdentityResourceId
	}
	if connection.MappingRuleName != nil {
		mappingRuleName := *connection.MappingRuleName
		result.Properties.MappingRuleName = &mappingRuleName
	}
	if connection.RetrievalStartDate != nil {
		retrievalStartDate := *connection.RetrievalStartDate
		result.Properties.RetrievalStartDate = &retrievalStartDate
	}
	if connection.TableName != nil {
		tableName := *connection.TableName
		result.Properties.TableName = &tableName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (connection *CosmosDbDataConnection) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.CosmosDbDataConnection{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (connection *CosmosDbDataConnection) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.CosmosDbDataConnection)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.CosmosDbDataConnection, got %T", armInput)
	}

	// no assignment for property "CosmosDbAccountResourceReference"

	// Set property "CosmosDbContainer":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.CosmosDbContainer != nil {
			cosmosDbContainer := *typedInput.Properties.CosmosDbContainer
			connection.CosmosDbContainer = &cosmosDbContainer
		}
	}

	// Set property "CosmosDbDatabase":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.CosmosDbDatabase != nil {
			cosmosDbDatabase := *typedInput.Properties.CosmosDbDatabase
			connection.CosmosDbDatabase = &cosmosDbDatabase
		}
	}

	// Set property "Kind":
	var temp CosmosDbDataConnection_Kind
	var temp1 string
	temp1 = string(typedInput.Kind)
	temp = CosmosDbDataConnection_Kind(temp1)
	connection.Kind = &temp

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		connection.Location = &location
	}

	// no assignment for property "ManagedIdentityResourceReference"

	// Set property "MappingRuleName":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MappingRuleName != nil {
			mappingRuleName := *typedInput.Properties.MappingRuleName
			connection.MappingRuleName = &mappingRuleName
		}
	}

	// Set property "RetrievalStartDate":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.RetrievalStartDate != nil {
			retrievalStartDate := *typedInput.Properties.RetrievalStartDate
			connection.RetrievalStartDate = &retrievalStartDate
		}
	}

	// Set property "TableName":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.TableName != nil {
			tableName := *typedInput.Properties.TableName
			connection.TableName = &tableName
		}
	}

	// No error
	return nil
}

// AssignProperties_From_CosmosDbDataConnection populates our CosmosDbDataConnection from the provided source CosmosDbDataConnection
func (connection *CosmosDbDataConnection) AssignProperties_From_CosmosDbDataConnection(source *storage.CosmosDbDataConnection) error {

	// CosmosDbAccountResourceReference
	if source.CosmosDbAccountResourceReference != nil {
		cosmosDbAccountResourceReference := source.CosmosDbAccountResourceReference.Copy()
		connection.CosmosDbAccountResourceReference = &cosmosDbAccountResourceReference
	} else {
		connection.CosmosDbAccountResourceReference = nil
	}

	// CosmosDbContainer
	connection.CosmosDbContainer = genruntime.ClonePointerToString(source.CosmosDbContainer)

	// CosmosDbDatabase
	connection.CosmosDbDatabase = genruntime.ClonePointerToString(source.CosmosDbDatabase)

	// Kind
	if source.Kind != nil {
		kind := *source.Kind
		kindTemp := genruntime.ToEnum(kind, cosmosDbDataConnection_Kind_Values)
		connection.Kind = &kindTemp
	} else {
		connection.Kind = nil
	}

	// Location
	connection.Location = genruntime.ClonePointerToString(source.Location)

	// ManagedIdentityResourceReference
	if source.ManagedIdentityResourceReference != nil {
		managedIdentityResourceReference := source.ManagedIdentityResourceReference.Copy()
		connection.ManagedIdentityResourceReference = &managedIdentityResourceReference
	} else {
		connection.ManagedIdentityResourceReference = nil
	}

	// MappingRuleName
	connection.MappingRuleName = genruntime.ClonePointerToString(source.MappingRuleName)

	// RetrievalStartDate
	connection.RetrievalStartDate = genruntime.ClonePointerToString(source.RetrievalStartDate)

	// TableName
	connection.TableName = genruntime.ClonePointerToString(source.TableName)

	// No error
	return nil
}

// AssignProperties_To_CosmosDbDataConnection populates the provided destination CosmosDbDataConnection from our CosmosDbDataConnection
func (connection *CosmosDbDataConnection) AssignProperties_To_CosmosDbDataConnection(destination *storage.CosmosDbDataConnection) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CosmosDbAccountResourceReference
	if connection.CosmosDbAccountResourceReference != nil {
		cosmosDbAccountResourceReference := connection.CosmosDbAccountResourceReference.Copy()
		destination.CosmosDbAccountResourceReference = &cosmosDbAccountResourceReference
	} else {
		destination.CosmosDbAccountResourceReference = nil
	}

	// CosmosDbContainer
	destination.CosmosDbContainer = genruntime.ClonePointerToString(connection.CosmosDbContainer)

	// CosmosDbDatabase
	destination.CosmosDbDatabase = genruntime.ClonePointerToString(connection.CosmosDbDatabase)

	// Kind
	if connection.Kind != nil {
		kind := string(*connection.Kind)
		destination.Kind = &kind
	} else {
		destination.Kind = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(connection.Location)

	// ManagedIdentityResourceReference
	if connection.ManagedIdentityResourceReference != nil {
		managedIdentityResourceReference := connection.ManagedIdentityResourceReference.Copy()
		destination.ManagedIdentityResourceReference = &managedIdentityResourceReference
	} else {
		destination.ManagedIdentityResourceReference = nil
	}

	// MappingRuleName
	destination.MappingRuleName = genruntime.ClonePointerToString(connection.MappingRuleName)

	// RetrievalStartDate
	destination.RetrievalStartDate = genruntime.ClonePointerToString(connection.RetrievalStartDate)

	// TableName
	destination.TableName = genruntime.ClonePointerToString(connection.TableName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_CosmosDbDataConnection_STATUS populates our CosmosDbDataConnection from the provided source CosmosDbDataConnection_STATUS
func (connection *CosmosDbDataConnection) Initialize_From_CosmosDbDataConnection_STATUS(source *CosmosDbDataConnection_STATUS) error {

	// CosmosDbAccountResourceReference
	if source.CosmosDbAccountResourceId != nil {
		cosmosDbAccountResourceReference := genruntime.CreateResourceReferenceFromARMID(*source.CosmosDbAccountResourceId)
		connection.CosmosDbAccountResourceReference = &cosmosDbAccountResourceReference
	} else {
		connection.CosmosDbAccountResourceReference = nil
	}

	// CosmosDbContainer
	connection.CosmosDbContainer = genruntime.ClonePointerToString(source.CosmosDbContainer)

	// CosmosDbDatabase
	connection.CosmosDbDatabase = genruntime.ClonePointerToString(source.CosmosDbDatabase)

	// Kind
	if source.Kind != nil {
		kind := genruntime.ToEnum(string(*source.Kind), cosmosDbDataConnection_Kind_Values)
		connection.Kind = &kind
	} else {
		connection.Kind = nil
	}

	// Location
	connection.Location = genruntime.ClonePointerToString(source.Location)

	// ManagedIdentityResourceReference
	if source.ManagedIdentityResourceId != nil {
		managedIdentityResourceReference := genruntime.CreateResourceReferenceFromARMID(*source.ManagedIdentityResourceId)
		connection.ManagedIdentityResourceReference = &managedIdentityResourceReference
	} else {
		connection.ManagedIdentityResourceReference = nil
	}

	// MappingRuleName
	connection.MappingRuleName = genruntime.ClonePointerToString(source.MappingRuleName)

	// RetrievalStartDate
	connection.RetrievalStartDate = genruntime.ClonePointerToString(source.RetrievalStartDate)

	// TableName
	connection.TableName = genruntime.ClonePointerToString(source.TableName)

	// No error
	return nil
}

type CosmosDbDataConnection_STATUS struct {
	// CosmosDbAccountResourceId: The resource ID of the Cosmos DB account used to create the data connection.
	CosmosDbAccountResourceId *string `json:"cosmosDbAccountResourceId,omitempty"`

	// CosmosDbContainer: The name of an existing container in the Cosmos DB database.
	CosmosDbContainer *string `json:"cosmosDbContainer,omitempty"`

	// CosmosDbDatabase: The name of an existing database in the Cosmos DB account.
	CosmosDbDatabase *string `json:"cosmosDbDatabase,omitempty"`

	// Id: Fully qualified resource ID for the resource. Ex -
	// /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	Id *string `json:"id,omitempty"`

	// Kind: Kind of the endpoint for the data connection
	Kind *CosmosDbDataConnection_Kind_STATUS `json:"kind,omitempty"`

	// Location: Resource location.
	Location *string `json:"location,omitempty"`

	// ManagedIdentityObjectId: The object ID of the managed identity resource.
	ManagedIdentityObjectId *string `json:"managedIdentityObjectId,omitempty"`

	// ManagedIdentityResourceId: The resource ID of a managed system or user-assigned identity. The identity is used to
	// authenticate with Cosmos DB.
	ManagedIdentityResourceId *string `json:"managedIdentityResourceId,omitempty"`

	// MappingRuleName: The name of an existing mapping rule to use when ingesting the retrieved data.
	MappingRuleName *string `json:"mappingRuleName,omitempty"`

	// ProvisioningState: The provisioned state of the resource.
	ProvisioningState *ProvisioningState_STATUS `json:"provisioningState,omitempty"`

	// RetrievalStartDate: Optional. If defined, the data connection retrieves Cosmos DB documents created or updated after the
	// specified retrieval start date.
	RetrievalStartDate *string `json:"retrievalStartDate,omitempty"`

	// TableName: The case-sensitive name of the existing target table in your cluster. Retrieved data is ingested into this
	// table.
	TableName *string `json:"tableName,omitempty"`

	// Type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &CosmosDbDataConnection_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (connection *CosmosDbDataConnection_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.CosmosDbDataConnection_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (connection *CosmosDbDataConnection_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.CosmosDbDataConnection_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.CosmosDbDataConnection_STATUS, got %T", armInput)
	}

	// Set property "CosmosDbAccountResourceId":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.CosmosDbAccountResourceId != nil {
			cosmosDbAccountResourceId := *typedInput.Properties.CosmosDbAccountResourceId
			connection.CosmosDbAccountResourceId = &cosmosDbAccountResourceId
		}
	}

	// Set property "CosmosDbContainer":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.CosmosDbContainer != nil {
			cosmosDbContainer := *typedInput.Properties.CosmosDbContainer
			connection.CosmosDbContainer = &cosmosDbContainer
		}
	}

	// Set property "CosmosDbDatabase":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.CosmosDbDatabase != nil {
			cosmosDbDatabase := *typedInput.Properties.CosmosDbDatabase
			connection.CosmosDbDatabase = &cosmosDbDatabase
		}
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		connection.Id = &id
	}

	// Set property "Kind":
	var temp CosmosDbDataConnection_Kind_STATUS
	var temp1 string
	temp1 = string(typedInput.Kind)
	temp = CosmosDbDataConnection_Kind_STATUS(temp1)
	connection.Kind = &temp

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		connection.Location = &location
	}

	// Set property "ManagedIdentityObjectId":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ManagedIdentityObjectId != nil {
			managedIdentityObjectId := *typedInput.Properties.ManagedIdentityObjectId
			connection.ManagedIdentityObjectId = &managedIdentityObjectId
		}
	}

	// Set property "ManagedIdentityResourceId":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ManagedIdentityResourceId != nil {
			managedIdentityResourceId := *typedInput.Properties.ManagedIdentityResourceId
			connection.ManagedIdentityResourceId = &managedIdentityResourceId
		}
	}

	// Set property "MappingRuleName":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MappingRuleName != nil {
			mappingRuleName := *typedInput.Properties.MappingRuleName
			connection.MappingRuleName = &mappingRuleName
		}
	}

	// Set property "ProvisioningState":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			var provisioningStateTemp string
			provisioningStateTemp = string(*typedInput.Properties.ProvisioningState)
			provisioningState := ProvisioningState_STATUS(provisioningStateTemp)
			connection.ProvisioningState = &provisioningState
		}
	}

	// Set property "RetrievalStartDate":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.RetrievalStartDate != nil {
			retrievalStartDate := *typedInput.Properties.RetrievalStartDate
			connection.RetrievalStartDate = &retrievalStartDate
		}
	}

	// Set property "TableName":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.TableName != nil {
			tableName := *typedInput.Properties.TableName
			connection.TableName = &tableName
		}
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		connection.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_CosmosDbDataConnection_STATUS populates our CosmosDbDataConnection_STATUS from the provided source CosmosDbDataConnection_STATUS
func (connection *CosmosDbDataConnection_STATUS) AssignProperties_From_CosmosDbDataConnection_STATUS(source *storage.CosmosDbDataConnection_STATUS) error {

	// CosmosDbAccountResourceId
	connection.CosmosDbAccountResourceId = genruntime.ClonePointerToString(source.CosmosDbAccountResourceId)

	// CosmosDbContainer
	connection.CosmosDbContainer = genruntime.ClonePointerToString(source.CosmosDbContainer)

	// CosmosDbDatabase
	connection.CosmosDbDatabase = genruntime.ClonePointerToString(source.CosmosDbDatabase)

	// Id
	connection.Id = genruntime.ClonePointerToString(source.Id)

	// Kind
	if source.Kind != nil {
		kind := *source.Kind
		kindTemp := genruntime.ToEnum(kind, cosmosDbDataConnection_Kind_STATUS_Values)
		connection.Kind = &kindTemp
	} else {
		connection.Kind = nil
	}

	// Location
	connection.Location = genruntime.ClonePointerToString(source.Location)

	// ManagedIdentityObjectId
	connection.ManagedIdentityObjectId = genruntime.ClonePointerToString(source.ManagedIdentityObjectId)

	// ManagedIdentityResourceId
	connection.ManagedIdentityResourceId = genruntime.ClonePointerToString(source.ManagedIdentityResourceId)

	// MappingRuleName
	connection.MappingRuleName = genruntime.ClonePointerToString(source.MappingRuleName)

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := *source.ProvisioningState
		provisioningStateTemp := genruntime.ToEnum(provisioningState, provisioningState_STATUS_Values)
		connection.ProvisioningState = &provisioningStateTemp
	} else {
		connection.ProvisioningState = nil
	}

	// RetrievalStartDate
	connection.RetrievalStartDate = genruntime.ClonePointerToString(source.RetrievalStartDate)

	// TableName
	connection.TableName = genruntime.ClonePointerToString(source.TableName)

	// Type
	connection.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignProperties_To_CosmosDbDataConnection_STATUS populates the provided destination CosmosDbDataConnection_STATUS from our CosmosDbDataConnection_STATUS
func (connection *CosmosDbDataConnection_STATUS) AssignProperties_To_CosmosDbDataConnection_STATUS(destination *storage.CosmosDbDataConnection_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CosmosDbAccountResourceId
	destination.CosmosDbAccountResourceId = genruntime.ClonePointerToString(connection.CosmosDbAccountResourceId)

	// CosmosDbContainer
	destination.CosmosDbContainer = genruntime.ClonePointerToString(connection.CosmosDbContainer)

	// CosmosDbDatabase
	destination.CosmosDbDatabase = genruntime.ClonePointerToString(connection.CosmosDbDatabase)

	// Id
	destination.Id = genruntime.ClonePointerToString(connection.Id)

	// Kind
	if connection.Kind != nil {
		kind := string(*connection.Kind)
		destination.Kind = &kind
	} else {
		destination.Kind = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(connection.Location)

	// ManagedIdentityObjectId
	destination.ManagedIdentityObjectId = genruntime.ClonePointerToString(connection.ManagedIdentityObjectId)

	// ManagedIdentityResourceId
	destination.ManagedIdentityResourceId = genruntime.ClonePointerToString(connection.ManagedIdentityResourceId)

	// MappingRuleName
	destination.MappingRuleName = genruntime.ClonePointerToString(connection.MappingRuleName)

	// ProvisioningState
	if connection.ProvisioningState != nil {
		provisioningState := string(*connection.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// RetrievalStartDate
	destination.RetrievalStartDate = genruntime.ClonePointerToString(connection.RetrievalStartDate)

	// TableName
	destination.TableName = genruntime.ClonePointerToString(connection.TableName)

	// Type
	destination.Type = genruntime.ClonePointerToString(connection.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Details for configuring operator behavior. Fields in this struct are interpreted by the operator directly rather than being passed to Azure
type DataConnectionOperatorSpec struct {
	// ConfigMapExpressions: configures where to place operator written dynamic ConfigMaps (created with CEL expressions).
	ConfigMapExpressions []*core.DestinationExpression `json:"configMapExpressions,omitempty"`

	// SecretExpressions: configures where to place operator written dynamic secrets (created with CEL expressions).
	SecretExpressions []*core.DestinationExpression `json:"secretExpressions,omitempty"`
}

// AssignProperties_From_DataConnectionOperatorSpec populates our DataConnectionOperatorSpec from the provided source DataConnectionOperatorSpec
func (operator *DataConnectionOperatorSpec) AssignProperties_From_DataConnectionOperatorSpec(source *storage.DataConnectionOperatorSpec) error {

	// ConfigMapExpressions
	if source.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(source.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range source.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		operator.ConfigMapExpressions = configMapExpressionList
	} else {
		operator.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if source.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(source.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range source.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		operator.SecretExpressions = secretExpressionList
	} else {
		operator.SecretExpressions = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DataConnectionOperatorSpec populates the provided destination DataConnectionOperatorSpec from our DataConnectionOperatorSpec
func (operator *DataConnectionOperatorSpec) AssignProperties_To_DataConnectionOperatorSpec(destination *storage.DataConnectionOperatorSpec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ConfigMapExpressions
	if operator.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(operator.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range operator.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		destination.ConfigMapExpressions = configMapExpressionList
	} else {
		destination.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if operator.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(operator.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range operator.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		destination.SecretExpressions = secretExpressionList
	} else {
		destination.SecretExpressions = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type EventGridDataConnection struct {
	// BlobStorageEventType: The name of blob storage event type to process.
	BlobStorageEventType *BlobStorageEventType `json:"blobStorageEventType,omitempty"`

	// +kubebuilder:validation:Required
	// ConsumerGroup: The event hub consumer group.
	ConsumerGroup *string `json:"consumerGroup,omitempty"`

	// DataFormat: The data format of the message. Optionally the data format can be added to each message.
	DataFormat *EventGridDataFormat `json:"dataFormat,omitempty"`

	// DatabaseRouting: Indication for database routing information from the data connection, by default only database routing
	// information is allowed
	DatabaseRouting *EventGridConnectionProperties_DatabaseRouting `json:"databaseRouting,omitempty"`

	// EventGridResourceReference: The resource ID of the event grid that is subscribed to the storage account events.
	EventGridResourceReference *genruntime.ResourceReference `armReference:"EventGridResourceId" json:"eventGridResourceReference,omitempty"`

	// +kubebuilder:validation:Required
	// EventHubResourceReference: The resource ID where the event grid is configured to send events.
	EventHubResourceReference *genruntime.ResourceReference `armReference:"EventHubResourceId" json:"eventHubResourceReference,omitempty"`

	// IgnoreFirstRecord: A Boolean value that, if set to true, indicates that ingestion should ignore the first record of
	// every file
	IgnoreFirstRecord *bool `json:"ignoreFirstRecord,omitempty"`

	// +kubebuilder:validation:Required
	// Kind: Kind of the endpoint for the data connection
	Kind *EventGridDataConnection_Kind `json:"kind,omitempty"`

	// Location: Resource location.
	Location *string `json:"location,omitempty"`

	// ManagedIdentityResourceReference: The resource ID of a managed identity (system or user assigned) to be used to
	// authenticate with event hub and storage account.
	ManagedIdentityResourceReference *genruntime.ResourceReference `armReference:"ManagedIdentityResourceId" json:"managedIdentityResourceReference,omitempty"`

	// MappingRuleName: The mapping rule to be used to ingest the data. Optionally the mapping information can be added to each
	// message.
	MappingRuleName *string `json:"mappingRuleName,omitempty"`

	// +kubebuilder:validation:Required
	// StorageAccountResourceReference: The resource ID of the storage account where the data resides.
	StorageAccountResourceReference *genruntime.ResourceReference `armReference:"StorageAccountResourceId" json:"storageAccountResourceReference,omitempty"`

	// TableName: The table where the data should be ingested. Optionally the table information can be added to each message.
	TableName *string `json:"tableName,omitempty"`
}

var _ genruntime.ARMTransformer = &EventGridDataConnection{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (connection *EventGridDataConnection) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if connection == nil {
		return nil, nil
	}
	result := &arm.EventGridDataConnection{}

	// Set property "Kind":
	if connection.Kind != nil {
		var temp arm.EventGridDataConnection_Kind
		var temp1 string
		temp1 = string(*connection.Kind)
		temp = arm.EventGridDataConnection_Kind(temp1)
		result.Kind = temp
	}

	// Set property "Location":
	if connection.Location != nil {
		location := *connection.Location
		result.Location = &location
	}

	// no assignment for property "Name"

	// Set property "Properties":
	if connection.BlobStorageEventType != nil ||
		connection.ConsumerGroup != nil ||
		connection.DataFormat != nil ||
		connection.DatabaseRouting != nil ||
		connection.EventGridResourceReference != nil ||
		connection.EventHubResourceReference != nil ||
		connection.IgnoreFirstRecord != nil ||
		connection.ManagedIdentityResourceReference != nil ||
		connection.MappingRuleName != nil ||
		connection.StorageAccountResourceReference != nil ||
		connection.TableName != nil {
		result.Properties = &arm.EventGridConnectionProperties{}
	}
	if connection.BlobStorageEventType != nil {
		var temp string
		temp = string(*connection.BlobStorageEventType)
		blobStorageEventType := arm.BlobStorageEventType(temp)
		result.Properties.BlobStorageEventType = &blobStorageEventType
	}
	if connection.ConsumerGroup != nil {
		consumerGroup := *connection.ConsumerGroup
		result.Properties.ConsumerGroup = &consumerGroup
	}
	if connection.DataFormat != nil {
		var temp string
		temp = string(*connection.DataFormat)
		dataFormat := arm.EventGridDataFormat(temp)
		result.Properties.DataFormat = &dataFormat
	}
	if connection.DatabaseRouting != nil {
		var temp string
		temp = string(*connection.DatabaseRouting)
		databaseRouting := arm.EventGridConnectionProperties_DatabaseRouting(temp)
		result.Properties.DatabaseRouting = &databaseRouting
	}
	if connection.EventGridResourceReference != nil {
		eventGridResourceIdARMID, err := resolved.ResolvedReferences.Lookup(*connection.EventGridResourceReference)
		if err != nil {
			return nil, err
		}
		eventGridResourceId := eventGridResourceIdARMID
		result.Properties.EventGridResourceId = &eventGridResourceId
	}
	if connection.EventHubResourceReference != nil {
		eventHubResourceIdARMID, err := resolved.ResolvedReferences.Lookup(*connection.EventHubResourceReference)
		if err != nil {
			return nil, err
		}
		eventHubResourceId := eventHubResourceIdARMID
		result.Properties.EventHubResourceId = &eventHubResourceId
	}
	if connection.IgnoreFirstRecord != nil {
		ignoreFirstRecord := *connection.IgnoreFirstRecord
		result.Properties.IgnoreFirstRecord = &ignoreFirstRecord
	}
	if connection.ManagedIdentityResourceReference != nil {
		managedIdentityResourceIdARMID, err := resolved.ResolvedReferences.Lookup(*connection.ManagedIdentityResourceReference)
		if err != nil {
			return nil, err
		}
		managedIdentityResourceId := managedIdentityResourceIdARMID
		result.Properties.ManagedIdentityResourceId = &managedIdentityResourceId
	}
	if connection.MappingRuleName != nil {
		mappingRuleName := *connection.MappingRuleName
		result.Properties.MappingRuleName = &mappingRuleName
	}
	if connection.StorageAccountResourceReference != nil {
		storageAccountResourceIdARMID, err := resolved.ResolvedReferences.Lookup(*connection.StorageAccountResourceReference)
		if err != nil {
			return nil, err
		}
		storageAccountResourceId := storageAccountResourceIdARMID
		result.Properties.StorageAccountResourceId = &storageAccountResourceId
	}
	if connection.TableName != nil {
		tableName := *connection.TableName
		result.Properties.TableName = &tableName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (connection *EventGridDataConnection) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.EventGridDataConnection{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (connection *EventGridDataConnection) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.EventGridDataConnection)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.EventGridDataConnection, got %T", armInput)
	}

	// Set property "BlobStorageEventType":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.BlobStorageEventType != nil {
			var temp string
			temp = string(*typedInput.Properties.BlobStorageEventType)
			blobStorageEventType := BlobStorageEventType(temp)
			connection.BlobStorageEventType = &blobStorageEventType
		}
	}

	// Set property "ConsumerGroup":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ConsumerGroup != nil {
			consumerGroup := *typedInput.Properties.ConsumerGroup
			connection.ConsumerGroup = &consumerGroup
		}
	}

	// Set property "DataFormat":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DataFormat != nil {
			var temp string
			temp = string(*typedInput.Properties.DataFormat)
			dataFormat := EventGridDataFormat(temp)
			connection.DataFormat = &dataFormat
		}
	}

	// Set property "DatabaseRouting":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DatabaseRouting != nil {
			var temp string
			temp = string(*typedInput.Properties.DatabaseRouting)
			databaseRouting := EventGridConnectionProperties_DatabaseRouting(temp)
			connection.DatabaseRouting = &databaseRouting
		}
	}

	// no assignment for property "EventGridResourceReference"

	// no assignment for property "EventHubResourceReference"

	// Set property "IgnoreFirstRecord":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IgnoreFirstRecord != nil {
			ignoreFirstRecord := *typedInput.Properties.IgnoreFirstRecord
			connection.IgnoreFirstRecord = &ignoreFirstRecord
		}
	}

	// Set property "Kind":
	var temp EventGridDataConnection_Kind
	var temp1 string
	temp1 = string(typedInput.Kind)
	temp = EventGridDataConnection_Kind(temp1)
	connection.Kind = &temp

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		connection.Location = &location
	}

	// no assignment for property "ManagedIdentityResourceReference"

	// Set property "MappingRuleName":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MappingRuleName != nil {
			mappingRuleName := *typedInput.Properties.MappingRuleName
			connection.MappingRuleName = &mappingRuleName
		}
	}

	// no assignment for property "StorageAccountResourceReference"

	// Set property "TableName":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.TableName != nil {
			tableName := *typedInput.Properties.TableName
			connection.TableName = &tableName
		}
	}

	// No error
	return nil
}

// AssignProperties_From_EventGridDataConnection populates our EventGridDataConnection from the provided source EventGridDataConnection
func (connection *EventGridDataConnection) AssignProperties_From_EventGridDataConnection(source *storage.EventGridDataConnection) error {

	// BlobStorageEventType
	if source.BlobStorageEventType != nil {
		blobStorageEventType := *source.BlobStorageEventType
		blobStorageEventTypeTemp := genruntime.ToEnum(blobStorageEventType, blobStorageEventType_Values)
		connection.BlobStorageEventType = &blobStorageEventTypeTemp
	} else {
		connection.BlobStorageEventType = nil
	}

	// ConsumerGroup
	connection.ConsumerGroup = genruntime.ClonePointerToString(source.ConsumerGroup)

	// DataFormat
	if source.DataFormat != nil {
		dataFormat := *source.DataFormat
		dataFormatTemp := genruntime.ToEnum(dataFormat, eventGridDataFormat_Values)
		connection.DataFormat = &dataFormatTemp
	} else {
		connection.DataFormat = nil
	}

	// DatabaseRouting
	if source.DatabaseRouting != nil {
		databaseRouting := *source.DatabaseRouting
		databaseRoutingTemp := genruntime.ToEnum(databaseRouting, eventGridConnectionProperties_DatabaseRouting_Values)
		connection.DatabaseRouting = &databaseRoutingTemp
	} else {
		connection.DatabaseRouting = nil
	}

	// EventGridResourceReference
	if source.EventGridResourceReference != nil {
		eventGridResourceReference := source.EventGridResourceReference.Copy()
		connection.EventGridResourceReference = &eventGridResourceReference
	} else {
		connection.EventGridResourceReference = nil
	}

	// EventHubResourceReference
	if source.EventHubResourceReference != nil {
		eventHubResourceReference := source.EventHubResourceReference.Copy()
		connection.EventHubResourceReference = &eventHubResourceReference
	} else {
		connection.EventHubResourceReference = nil
	}

	// IgnoreFirstRecord
	if source.IgnoreFirstRecord != nil {
		ignoreFirstRecord := *source.IgnoreFirstRecord
		connection.IgnoreFirstRecord = &ignoreFirstRecord
	} else {
		connection.IgnoreFirstRecord = nil
	}

	// Kind
	if source.Kind != nil {
		kind := *source.Kind
		kindTemp := genruntime.ToEnum(kind, eventGridDataConnection_Kind_Values)
		connection.Kind = &kindTemp
	} else {
		connection.Kind = nil
	}

	// Location
	connection.Location = genruntime.ClonePointerToString(source.Location)

	// ManagedIdentityResourceReference
	if source.ManagedIdentityResourceReference != nil {
		managedIdentityResourceReference := source.ManagedIdentityResourceReference.Copy()
		connection.ManagedIdentityResourceReference = &managedIdentityResourceReference
	} else {
		connection.ManagedIdentityResourceReference = nil
	}

	// MappingRuleName
	connection.MappingRuleName = genruntime.ClonePointerToString(source.MappingRuleName)

	// StorageAccountResourceReference
	if source.StorageAccountResourceReference != nil {
		storageAccountResourceReference := source.StorageAccountResourceReference.Copy()
		connection.StorageAccountResourceReference = &storageAccountResourceReference
	} else {
		connection.StorageAccountResourceReference = nil
	}

	// TableName
	connection.TableName = genruntime.ClonePointerToString(source.TableName)

	// No error
	return nil
}

// AssignProperties_To_EventGridDataConnection populates the provided destination EventGridDataConnection from our EventGridDataConnection
func (connection *EventGridDataConnection) AssignProperties_To_EventGridDataConnection(destination *storage.EventGridDataConnection) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BlobStorageEventType
	if connection.BlobStorageEventType != nil {
		blobStorageEventType := string(*connection.BlobStorageEventType)
		destination.BlobStorageEventType = &blobStorageEventType
	} else {
		destination.BlobStorageEventType = nil
	}

	// ConsumerGroup
	destination.ConsumerGroup = genruntime.ClonePointerToString(connection.ConsumerGroup)

	// DataFormat
	if connection.DataFormat != nil {
		dataFormat := string(*connection.DataFormat)
		destination.DataFormat = &dataFormat
	} else {
		destination.DataFormat = nil
	}

	// DatabaseRouting
	if connection.DatabaseRouting != nil {
		databaseRouting := string(*connection.DatabaseRouting)
		destination.DatabaseRouting = &databaseRouting
	} else {
		destination.DatabaseRouting = nil
	}

	// EventGridResourceReference
	if connection.EventGridResourceReference != nil {
		eventGridResourceReference := connection.EventGridResourceReference.Copy()
		destination.EventGridResourceReference = &eventGridResourceReference
	} else {
		destination.EventGridResourceReference = nil
	}

	// EventHubResourceReference
	if connection.EventHubResourceReference != nil {
		eventHubResourceReference := connection.EventHubResourceReference.Copy()
		destination.EventHubResourceReference = &eventHubResourceReference
	} else {
		destination.EventHubResourceReference = nil
	}

	// IgnoreFirstRecord
	if connection.IgnoreFirstRecord != nil {
		ignoreFirstRecord := *connection.IgnoreFirstRecord
		destination.IgnoreFirstRecord = &ignoreFirstRecord
	} else {
		destination.IgnoreFirstRecord = nil
	}

	// Kind
	if connection.Kind != nil {
		kind := string(*connection.Kind)
		destination.Kind = &kind
	} else {
		destination.Kind = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(connection.Location)

	// ManagedIdentityResourceReference
	if connection.ManagedIdentityResourceReference != nil {
		managedIdentityResourceReference := connection.ManagedIdentityResourceReference.Copy()
		destination.ManagedIdentityResourceReference = &managedIdentityResourceReference
	} else {
		destination.ManagedIdentityResourceReference = nil
	}

	// MappingRuleName
	destination.MappingRuleName = genruntime.ClonePointerToString(connection.MappingRuleName)

	// StorageAccountResourceReference
	if connection.StorageAccountResourceReference != nil {
		storageAccountResourceReference := connection.StorageAccountResourceReference.Copy()
		destination.StorageAccountResourceReference = &storageAccountResourceReference
	} else {
		destination.StorageAccountResourceReference = nil
	}

	// TableName
	destination.TableName = genruntime.ClonePointerToString(connection.TableName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_EventGridDataConnection_STATUS populates our EventGridDataConnection from the provided source EventGridDataConnection_STATUS
func (connection *EventGridDataConnection) Initialize_From_EventGridDataConnection_STATUS(source *EventGridDataConnection_STATUS) error {

	// BlobStorageEventType
	if source.BlobStorageEventType != nil {
		blobStorageEventType := genruntime.ToEnum(string(*source.BlobStorageEventType), blobStorageEventType_Values)
		connection.BlobStorageEventType = &blobStorageEventType
	} else {
		connection.BlobStorageEventType = nil
	}

	// ConsumerGroup
	connection.ConsumerGroup = genruntime.ClonePointerToString(source.ConsumerGroup)

	// DataFormat
	if source.DataFormat != nil {
		dataFormat := genruntime.ToEnum(string(*source.DataFormat), eventGridDataFormat_Values)
		connection.DataFormat = &dataFormat
	} else {
		connection.DataFormat = nil
	}

	// DatabaseRouting
	if source.DatabaseRouting != nil {
		databaseRouting := genruntime.ToEnum(string(*source.DatabaseRouting), eventGridConnectionProperties_DatabaseRouting_Values)
		connection.DatabaseRouting = &databaseRouting
	} else {
		connection.DatabaseRouting = nil
	}

	// EventGridResourceReference
	if source.EventGridResourceId != nil {
		eventGridResourceReference := genruntime.CreateResourceReferenceFromARMID(*source.EventGridResourceId)
		connection.EventGridResourceReference = &eventGridResourceReference
	} else {
		connection.EventGridResourceReference = nil
	}

	// EventHubResourceReference
	if source.EventHubResourceId != nil {
		eventHubResourceReference := genruntime.CreateResourceReferenceFromARMID(*source.EventHubResourceId)
		connection.EventHubResourceReference = &eventHubResourceReference
	} else {
		connection.EventHubResourceReference = nil
	}

	// IgnoreFirstRecord
	if source.IgnoreFirstRecord != nil {
		ignoreFirstRecord := *source.IgnoreFirstRecord
		connection.IgnoreFirstRecord = &ignoreFirstRecord
	} else {
		connection.IgnoreFirstRecord = nil
	}

	// Kind
	if source.Kind != nil {
		kind := genruntime.ToEnum(string(*source.Kind), eventGridDataConnection_Kind_Values)
		connection.Kind = &kind
	} else {
		connection.Kind = nil
	}

	// Location
	connection.Location = genruntime.ClonePointerToString(source.Location)

	// ManagedIdentityResourceReference
	if source.ManagedIdentityResourceId != nil {
		managedIdentityResourceReference := genruntime.CreateResourceReferenceFromARMID(*source.ManagedIdentityResourceId)
		connection.ManagedIdentityResourceReference = &managedIdentityResourceReference
	} else {
		connection.ManagedIdentityResourceReference = nil
	}

	// MappingRuleName
	connection.MappingRuleName = genruntime.ClonePointerToString(source.MappingRuleName)

	// StorageAccountResourceReference
	if source.StorageAccountResourceId != nil {
		storageAccountResourceReference := genruntime.CreateResourceReferenceFromARMID(*source.StorageAccountResourceId)
		connection.StorageAccountResourceReference = &storageAccountResourceReference
	} else {
		connection.StorageAccountResourceReference = nil
	}

	// TableName
	connection.TableName = genruntime.ClonePointerToString(source.TableName)

	// No error
	return nil
}

type EventGridDataConnection_STATUS struct {
	// BlobStorageEventType: The name of blob storage event type to process.
	BlobStorageEventType *BlobStorageEventType_STATUS `json:"blobStorageEventType,omitempty"`

	// ConsumerGroup: The event hub consumer group.
	ConsumerGroup *string `json:"consumerGroup,omitempty"`

	// DataFormat: The data format of the message. Optionally the data format can be added to each message.
	DataFormat *EventGridDataFormat_STATUS `json:"dataFormat,omitempty"`

	// DatabaseRouting: Indication for database routing information from the data connection, by default only database routing
	// information is allowed
	DatabaseRouting *EventGridConnectionProperties_DatabaseRouting_STATUS `json:"databaseRouting,omitempty"`

	// EventGridResourceId: The resource ID of the event grid that is subscribed to the storage account events.
	EventGridResourceId *string `json:"eventGridResourceId,omitempty"`

	// EventHubResourceId: The resource ID where the event grid is configured to send events.
	EventHubResourceId *string `json:"eventHubResourceId,omitempty"`

	// Id: Fully qualified resource ID for the resource. Ex -
	// /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	Id *string `json:"id,omitempty"`

	// IgnoreFirstRecord: A Boolean value that, if set to true, indicates that ingestion should ignore the first record of
	// every file
	IgnoreFirstRecord *bool `json:"ignoreFirstRecord,omitempty"`

	// Kind: Kind of the endpoint for the data connection
	Kind *EventGridDataConnection_Kind_STATUS `json:"kind,omitempty"`

	// Location: Resource location.
	Location *string `json:"location,omitempty"`

	// ManagedIdentityObjectId: The object ID of managedIdentityResourceId
	ManagedIdentityObjectId *string `json:"managedIdentityObjectId,omitempty"`

	// ManagedIdentityResourceId: The resource ID of a managed identity (system or user assigned) to be used to authenticate
	// with event hub and storage account.
	ManagedIdentityResourceId *string `json:"managedIdentityResourceId,omitempty"`

	// MappingRuleName: The mapping rule to be used to ingest the data. Optionally the mapping information can be added to each
	// message.
	MappingRuleName *string `json:"mappingRuleName,omitempty"`

	// ProvisioningState: The provisioned state of the resource.
	ProvisioningState *ProvisioningState_STATUS `json:"provisioningState,omitempty"`

	// StorageAccountResourceId: The resource ID of the storage account where the data resides.
	StorageAccountResourceId *string `json:"storageAccountResourceId,omitempty"`

	// TableName: The table where the data should be ingested. Optionally the table information can be added to each message.
	TableName *string `json:"tableName,omitempty"`

	// Type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &EventGridDataConnection_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (connection *EventGridDataConnection_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.EventGridDataConnection_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (connection *EventGridDataConnection_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.EventGridDataConnection_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.EventGridDataConnection_STATUS, got %T", armInput)
	}

	// Set property "BlobStorageEventType":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.BlobStorageEventType != nil {
			var temp string
			temp = string(*typedInput.Properties.BlobStorageEventType)
			blobStorageEventType := BlobStorageEventType_STATUS(temp)
			connection.BlobStorageEventType = &blobStorageEventType
		}
	}

	// Set property "ConsumerGroup":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ConsumerGroup != nil {
			consumerGroup := *typedInput.Properties.ConsumerGroup
			connection.ConsumerGroup = &consumerGroup
		}
	}

	// Set property "DataFormat":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DataFormat != nil {
			var temp string
			temp = string(*typedInput.Properties.DataFormat)
			dataFormat := EventGridDataFormat_STATUS(temp)
			connection.DataFormat = &dataFormat
		}
	}

	// Set property "DatabaseRouting":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DatabaseRouting != nil {
			var temp string
			temp = string(*typedInput.Properties.DatabaseRouting)
			databaseRouting := EventGridConnectionProperties_DatabaseRouting_STATUS(temp)
			connection.DatabaseRouting = &databaseRouting
		}
	}

	// Set property "EventGridResourceId":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EventGridResourceId != nil {
			eventGridResourceId := *typedInput.Properties.EventGridResourceId
			connection.EventGridResourceId = &eventGridResourceId
		}
	}

	// Set property "EventHubResourceId":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EventHubResourceId != nil {
			eventHubResourceId := *typedInput.Properties.EventHubResourceId
			connection.EventHubResourceId = &eventHubResourceId
		}
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		connection.Id = &id
	}

	// Set property "IgnoreFirstRecord":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IgnoreFirstRecord != nil {
			ignoreFirstRecord := *typedInput.Properties.IgnoreFirstRecord
			connection.IgnoreFirstRecord = &ignoreFirstRecord
		}
	}

	// Set property "Kind":
	var temp EventGridDataConnection_Kind_STATUS
	var temp1 string
	temp1 = string(typedInput.Kind)
	temp = EventGridDataConnection_Kind_STATUS(temp1)
	connection.Kind = &temp

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		connection.Location = &location
	}

	// Set property "ManagedIdentityObjectId":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ManagedIdentityObjectId != nil {
			managedIdentityObjectId := *typedInput.Properties.ManagedIdentityObjectId
			connection.ManagedIdentityObjectId = &managedIdentityObjectId
		}
	}

	// Set property "ManagedIdentityResourceId":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ManagedIdentityResourceId != nil {
			managedIdentityResourceId := *typedInput.Properties.ManagedIdentityResourceId
			connection.ManagedIdentityResourceId = &managedIdentityResourceId
		}
	}

	// Set property "MappingRuleName":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MappingRuleName != nil {
			mappingRuleName := *typedInput.Properties.MappingRuleName
			connection.MappingRuleName = &mappingRuleName
		}
	}

	// Set property "ProvisioningState":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			var provisioningStateTemp string
			provisioningStateTemp = string(*typedInput.Properties.ProvisioningState)
			provisioningState := ProvisioningState_STATUS(provisioningStateTemp)
			connection.ProvisioningState = &provisioningState
		}
	}

	// Set property "StorageAccountResourceId":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.StorageAccountResourceId != nil {
			storageAccountResourceId := *typedInput.Properties.StorageAccountResourceId
			connection.StorageAccountResourceId = &storageAccountResourceId
		}
	}

	// Set property "TableName":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.TableName != nil {
			tableName := *typedInput.Properties.TableName
			connection.TableName = &tableName
		}
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		connection.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_EventGridDataConnection_STATUS populates our EventGridDataConnection_STATUS from the provided source EventGridDataConnection_STATUS
func (connection *EventGridDataConnection_STATUS) AssignProperties_From_EventGridDataConnection_STATUS(source *storage.EventGridDataConnection_STATUS) error {

	// BlobStorageEventType
	if source.BlobStorageEventType != nil {
		blobStorageEventType := *source.BlobStorageEventType
		blobStorageEventTypeTemp := genruntime.ToEnum(blobStorageEventType, blobStorageEventType_STATUS_Values)
		connection.BlobStorageEventType = &blobStorageEventTypeTemp
	} else {
		connection.BlobStorageEventType = nil
	}

	// ConsumerGroup
	connection.ConsumerGroup = genruntime.ClonePointerToString(source.ConsumerGroup)

	// DataFormat
	if source.DataFormat != nil {
		dataFormat := *source.DataFormat
		dataFormatTemp := genruntime.ToEnum(dataFormat, eventGridDataFormat_STATUS_Values)
		connection.DataFormat = &dataFormatTemp
	} else {
		connection.DataFormat = nil
	}

	// DatabaseRouting
	if source.DatabaseRouting != nil {
		databaseRouting := *source.DatabaseRouting
		databaseRoutingTemp := genruntime.ToEnum(databaseRouting, eventGridConnectionProperties_DatabaseRouting_STATUS_Values)
		connection.DatabaseRouting = &databaseRoutingTemp
	} else {
		connection.DatabaseRouting = nil
	}

	// EventGridResourceId
	connection.EventGridResourceId = genruntime.ClonePointerToString(source.EventGridResourceId)

	// EventHubResourceId
	connection.EventHubResourceId = genruntime.ClonePointerToString(source.EventHubResourceId)

	// Id
	connection.Id = genruntime.ClonePointerToString(source.Id)

	// IgnoreFirstRecord
	if source.IgnoreFirstRecord != nil {
		ignoreFirstRecord := *source.IgnoreFirstRecord
		connection.IgnoreFirstRecord = &ignoreFirstRecord
	} else {
		connection.IgnoreFirstRecord = nil
	}

	// Kind
	if source.Kind != nil {
		kind := *source.Kind
		kindTemp := genruntime.ToEnum(kind, eventGridDataConnection_Kind_STATUS_Values)
		connection.Kind = &kindTemp
	} else {
		connection.Kind = nil
	}

	// Location
	connection.Location = genruntime.ClonePointerToString(source.Location)

	// ManagedIdentityObjectId
	connection.ManagedIdentityObjectId = genruntime.ClonePointerToString(source.ManagedIdentityObjectId)

	// ManagedIdentityResourceId
	connection.ManagedIdentityResourceId = genruntime.ClonePointerToString(source.ManagedIdentityResourceId)

	// MappingRuleName
	connection.MappingRuleName = genruntime.ClonePointerToString(source.MappingRuleName)

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := *source.ProvisioningState
		provisioningStateTemp := genruntime.ToEnum(provisioningState, provisioningState_STATUS_Values)
		connection.ProvisioningState = &provisioningStateTemp
	} else {
		connection.ProvisioningState = nil
	}

	// StorageAccountResourceId
	connection.StorageAccountResourceId = genruntime.ClonePointerToString(source.StorageAccountResourceId)

	// TableName
	connection.TableName = genruntime.ClonePointerToString(source.TableName)

	// Type
	connection.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignProperties_To_EventGridDataConnection_STATUS populates the provided destination EventGridDataConnection_STATUS from our EventGridDataConnection_STATUS
func (connection *EventGridDataConnection_STATUS) AssignProperties_To_EventGridDataConnection_STATUS(destination *storage.EventGridDataConnection_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BlobStorageEventType
	if connection.BlobStorageEventType != nil {
		blobStorageEventType := string(*connection.BlobStorageEventType)
		destination.BlobStorageEventType = &blobStorageEventType
	} else {
		destination.BlobStorageEventType = nil
	}

	// ConsumerGroup
	destination.ConsumerGroup = genruntime.ClonePointerToString(connection.ConsumerGroup)

	// DataFormat
	if connection.DataFormat != nil {
		dataFormat := string(*connection.DataFormat)
		destination.DataFormat = &dataFormat
	} else {
		destination.DataFormat = nil
	}

	// DatabaseRouting
	if connection.DatabaseRouting != nil {
		databaseRouting := string(*connection.DatabaseRouting)
		destination.DatabaseRouting = &databaseRouting
	} else {
		destination.DatabaseRouting = nil
	}

	// EventGridResourceId
	destination.EventGridResourceId = genruntime.ClonePointerToString(connection.EventGridResourceId)

	// EventHubResourceId
	destination.EventHubResourceId = genruntime.ClonePointerToString(connection.EventHubResourceId)

	// Id
	destination.Id = genruntime.ClonePointerToString(connection.Id)

	// IgnoreFirstRecord
	if connection.IgnoreFirstRecord != nil {
		ignoreFirstRecord := *connection.IgnoreFirstRecord
		destination.IgnoreFirstRecord = &ignoreFirstRecord
	} else {
		destination.IgnoreFirstRecord = nil
	}

	// Kind
	if connection.Kind != nil {
		kind := string(*connection.Kind)
		destination.Kind = &kind
	} else {
		destination.Kind = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(connection.Location)

	// ManagedIdentityObjectId
	destination.ManagedIdentityObjectId = genruntime.ClonePointerToString(connection.ManagedIdentityObjectId)

	// ManagedIdentityResourceId
	destination.ManagedIdentityResourceId = genruntime.ClonePointerToString(connection.ManagedIdentityResourceId)

	// MappingRuleName
	destination.MappingRuleName = genruntime.ClonePointerToString(connection.MappingRuleName)

	// ProvisioningState
	if connection.ProvisioningState != nil {
		provisioningState := string(*connection.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// StorageAccountResourceId
	destination.StorageAccountResourceId = genruntime.ClonePointerToString(connection.StorageAccountResourceId)

	// TableName
	destination.TableName = genruntime.ClonePointerToString(connection.TableName)

	// Type
	destination.Type = genruntime.ClonePointerToString(connection.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type EventHubDataConnection struct {
	// Compression: The event hub messages compression type
	Compression *Compression `json:"compression,omitempty"`

	// +kubebuilder:validation:Required
	// ConsumerGroup: The event hub consumer group.
	ConsumerGroup *string `json:"consumerGroup,omitempty"`

	// DataFormat: The data format of the message. Optionally the data format can be added to each message.
	DataFormat *EventHubDataFormat `json:"dataFormat,omitempty"`

	// DatabaseRouting: Indication for database routing information from the data connection, by default only database routing
	// information is allowed
	DatabaseRouting *EventHubConnectionProperties_DatabaseRouting `json:"databaseRouting,omitempty"`

	// +kubebuilder:validation:Required
	// EventHubResourceReference: The resource ID of the event hub to be used to create a data connection.
	EventHubResourceReference *genruntime.ResourceReference `armReference:"EventHubResourceId" json:"eventHubResourceReference,omitempty"`

	// EventSystemProperties: System properties of the event hub
	EventSystemProperties []string `json:"eventSystemProperties,omitempty"`

	// +kubebuilder:validation:Required
	// Kind: Kind of the endpoint for the data connection
	Kind *EventHubDataConnection_Kind `json:"kind,omitempty"`

	// Location: Resource location.
	Location *string `json:"location,omitempty"`

	// ManagedIdentityResourceReference: The resource ID of a managed identity (system or user assigned) to be used to
	// authenticate with event hub.
	ManagedIdentityResourceReference *genruntime.ResourceReference `armReference:"ManagedIdentityResourceId" json:"managedIdentityResourceReference,omitempty"`

	// MappingRuleName: The mapping rule to be used to ingest the data. Optionally the mapping information can be added to each
	// message.
	MappingRuleName *string `json:"mappingRuleName,omitempty"`

	// RetrievalStartDate: When defined, the data connection retrieves existing Event hub events created since the Retrieval
	// start date. It can only retrieve events retained by the Event hub, based on its retention period.
	RetrievalStartDate *string `json:"retrievalStartDate,omitempty"`

	// TableName: The table where the data should be ingested. Optionally the table information can be added to each message.
	TableName *string `json:"tableName,omitempty"`
}

var _ genruntime.ARMTransformer = &EventHubDataConnection{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (connection *EventHubDataConnection) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if connection == nil {
		return nil, nil
	}
	result := &arm.EventHubDataConnection{}

	// Set property "Kind":
	if connection.Kind != nil {
		var temp arm.EventHubDataConnection_Kind
		var temp1 string
		temp1 = string(*connection.Kind)
		temp = arm.EventHubDataConnection_Kind(temp1)
		result.Kind = temp
	}

	// Set property "Location":
	if connection.Location != nil {
		location := *connection.Location
		result.Location = &location
	}

	// no assignment for property "Name"

	// Set property "Properties":
	if connection.Compression != nil ||
		connection.ConsumerGroup != nil ||
		connection.DataFormat != nil ||
		connection.DatabaseRouting != nil ||
		connection.EventHubResourceReference != nil ||
		connection.EventSystemProperties != nil ||
		connection.ManagedIdentityResourceReference != nil ||
		connection.MappingRuleName != nil ||
		connection.RetrievalStartDate != nil ||
		connection.TableName != nil {
		result.Properties = &arm.EventHubConnectionProperties{}
	}
	if connection.Compression != nil {
		var temp string
		temp = string(*connection.Compression)
		compression := arm.Compression(temp)
		result.Properties.Compression = &compression
	}
	if connection.ConsumerGroup != nil {
		consumerGroup := *connection.ConsumerGroup
		result.Properties.ConsumerGroup = &consumerGroup
	}
	if connection.DataFormat != nil {
		var temp string
		temp = string(*connection.DataFormat)
		dataFormat := arm.EventHubDataFormat(temp)
		result.Properties.DataFormat = &dataFormat
	}
	if connection.DatabaseRouting != nil {
		var temp string
		temp = string(*connection.DatabaseRouting)
		databaseRouting := arm.EventHubConnectionProperties_DatabaseRouting(temp)
		result.Properties.DatabaseRouting = &databaseRouting
	}
	if connection.EventHubResourceReference != nil {
		eventHubResourceIdARMID, err := resolved.ResolvedReferences.Lookup(*connection.EventHubResourceReference)
		if err != nil {
			return nil, err
		}
		eventHubResourceId := eventHubResourceIdARMID
		result.Properties.EventHubResourceId = &eventHubResourceId
	}
	for _, item := range connection.EventSystemProperties {
		result.Properties.EventSystemProperties = append(result.Properties.EventSystemProperties, item)
	}
	if connection.ManagedIdentityResourceReference != nil {
		managedIdentityResourceIdARMID, err := resolved.ResolvedReferences.Lookup(*connection.ManagedIdentityResourceReference)
		if err != nil {
			return nil, err
		}
		managedIdentityResourceId := managedIdentityResourceIdARMID
		result.Properties.ManagedIdentityResourceId = &managedIdentityResourceId
	}
	if connection.MappingRuleName != nil {
		mappingRuleName := *connection.MappingRuleName
		result.Properties.MappingRuleName = &mappingRuleName
	}
	if connection.RetrievalStartDate != nil {
		retrievalStartDate := *connection.RetrievalStartDate
		result.Properties.RetrievalStartDate = &retrievalStartDate
	}
	if connection.TableName != nil {
		tableName := *connection.TableName
		result.Properties.TableName = &tableName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (connection *EventHubDataConnection) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.EventHubDataConnection{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (connection *EventHubDataConnection) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.EventHubDataConnection)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.EventHubDataConnection, got %T", armInput)
	}

	// Set property "Compression":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Compression != nil {
			var temp string
			temp = string(*typedInput.Properties.Compression)
			compression := Compression(temp)
			connection.Compression = &compression
		}
	}

	// Set property "ConsumerGroup":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ConsumerGroup != nil {
			consumerGroup := *typedInput.Properties.ConsumerGroup
			connection.ConsumerGroup = &consumerGroup
		}
	}

	// Set property "DataFormat":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DataFormat != nil {
			var temp string
			temp = string(*typedInput.Properties.DataFormat)
			dataFormat := EventHubDataFormat(temp)
			connection.DataFormat = &dataFormat
		}
	}

	// Set property "DatabaseRouting":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DatabaseRouting != nil {
			var temp string
			temp = string(*typedInput.Properties.DatabaseRouting)
			databaseRouting := EventHubConnectionProperties_DatabaseRouting(temp)
			connection.DatabaseRouting = &databaseRouting
		}
	}

	// no assignment for property "EventHubResourceReference"

	// Set property "EventSystemProperties":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.EventSystemProperties {
			connection.EventSystemProperties = append(connection.EventSystemProperties, item)
		}
	}

	// Set property "Kind":
	var temp EventHubDataConnection_Kind
	var temp1 string
	temp1 = string(typedInput.Kind)
	temp = EventHubDataConnection_Kind(temp1)
	connection.Kind = &temp

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		connection.Location = &location
	}

	// no assignment for property "ManagedIdentityResourceReference"

	// Set property "MappingRuleName":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MappingRuleName != nil {
			mappingRuleName := *typedInput.Properties.MappingRuleName
			connection.MappingRuleName = &mappingRuleName
		}
	}

	// Set property "RetrievalStartDate":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.RetrievalStartDate != nil {
			retrievalStartDate := *typedInput.Properties.RetrievalStartDate
			connection.RetrievalStartDate = &retrievalStartDate
		}
	}

	// Set property "TableName":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.TableName != nil {
			tableName := *typedInput.Properties.TableName
			connection.TableName = &tableName
		}
	}

	// No error
	return nil
}

// AssignProperties_From_EventHubDataConnection populates our EventHubDataConnection from the provided source EventHubDataConnection
func (connection *EventHubDataConnection) AssignProperties_From_EventHubDataConnection(source *storage.EventHubDataConnection) error {

	// Compression
	if source.Compression != nil {
		compression := *source.Compression
		compressionTemp := genruntime.ToEnum(compression, compression_Values)
		connection.Compression = &compressionTemp
	} else {
		connection.Compression = nil
	}

	// ConsumerGroup
	connection.ConsumerGroup = genruntime.ClonePointerToString(source.ConsumerGroup)

	// DataFormat
	if source.DataFormat != nil {
		dataFormat := *source.DataFormat
		dataFormatTemp := genruntime.ToEnum(dataFormat, eventHubDataFormat_Values)
		connection.DataFormat = &dataFormatTemp
	} else {
		connection.DataFormat = nil
	}

	// DatabaseRouting
	if source.DatabaseRouting != nil {
		databaseRouting := *source.DatabaseRouting
		databaseRoutingTemp := genruntime.ToEnum(databaseRouting, eventHubConnectionProperties_DatabaseRouting_Values)
		connection.DatabaseRouting = &databaseRoutingTemp
	} else {
		connection.DatabaseRouting = nil
	}

	// EventHubResourceReference
	if source.EventHubResourceReference != nil {
		eventHubResourceReference := source.EventHubResourceReference.Copy()
		connection.EventHubResourceReference = &eventHubResourceReference
	} else {
		connection.EventHubResourceReference = nil
	}

	// EventSystemProperties
	connection.EventSystemProperties = genruntime.CloneSliceOfString(source.EventSystemProperties)

	// Kind
	if source.Kind != nil {
		kind := *source.Kind
		kindTemp := genruntime.ToEnum(kind, eventHubDataConnection_Kind_Values)
		connection.Kind = &kindTemp
	} else {
		connection.Kind = nil
	}

	// Location
	connection.Location = genruntime.ClonePointerToString(source.Location)

	// ManagedIdentityResourceReference
	if source.ManagedIdentityResourceReference != nil {
		managedIdentityResourceReference := source.ManagedIdentityResourceReference.Copy()
		connection.ManagedIdentityResourceReference = &managedIdentityResourceReference
	} else {
		connection.ManagedIdentityResourceReference = nil
	}

	// MappingRuleName
	connection.MappingRuleName = genruntime.ClonePointerToString(source.MappingRuleName)

	// RetrievalStartDate
	connection.RetrievalStartDate = genruntime.ClonePointerToString(source.RetrievalStartDate)

	// TableName
	connection.TableName = genruntime.ClonePointerToString(source.TableName)

	// No error
	return nil
}

// AssignProperties_To_EventHubDataConnection populates the provided destination EventHubDataConnection from our EventHubDataConnection
func (connection *EventHubDataConnection) AssignProperties_To_EventHubDataConnection(destination *storage.EventHubDataConnection) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Compression
	if connection.Compression != nil {
		compression := string(*connection.Compression)
		destination.Compression = &compression
	} else {
		destination.Compression = nil
	}

	// ConsumerGroup
	destination.ConsumerGroup = genruntime.ClonePointerToString(connection.ConsumerGroup)

	// DataFormat
	if connection.DataFormat != nil {
		dataFormat := string(*connection.DataFormat)
		destination.DataFormat = &dataFormat
	} else {
		destination.DataFormat = nil
	}

	// DatabaseRouting
	if connection.DatabaseRouting != nil {
		databaseRouting := string(*connection.DatabaseRouting)
		destination.DatabaseRouting = &databaseRouting
	} else {
		destination.DatabaseRouting = nil
	}

	// EventHubResourceReference
	if connection.EventHubResourceReference != nil {
		eventHubResourceReference := connection.EventHubResourceReference.Copy()
		destination.EventHubResourceReference = &eventHubResourceReference
	} else {
		destination.EventHubResourceReference = nil
	}

	// EventSystemProperties
	destination.EventSystemProperties = genruntime.CloneSliceOfString(connection.EventSystemProperties)

	// Kind
	if connection.Kind != nil {
		kind := string(*connection.Kind)
		destination.Kind = &kind
	} else {
		destination.Kind = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(connection.Location)

	// ManagedIdentityResourceReference
	if connection.ManagedIdentityResourceReference != nil {
		managedIdentityResourceReference := connection.ManagedIdentityResourceReference.Copy()
		destination.ManagedIdentityResourceReference = &managedIdentityResourceReference
	} else {
		destination.ManagedIdentityResourceReference = nil
	}

	// MappingRuleName
	destination.MappingRuleName = genruntime.ClonePointerToString(connection.MappingRuleName)

	// RetrievalStartDate
	destination.RetrievalStartDate = genruntime.ClonePointerToString(connection.RetrievalStartDate)

	// TableName
	destination.TableName = genruntime.ClonePointerToString(connection.TableName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_EventHubDataConnection_STATUS populates our EventHubDataConnection from the provided source EventHubDataConnection_STATUS
func (connection *EventHubDataConnection) Initialize_From_EventHubDataConnection_STATUS(source *EventHubDataConnection_STATUS) error {

	// Compression
	if source.Compression != nil {
		compression := genruntime.ToEnum(string(*source.Compression), compression_Values)
		connection.Compression = &compression
	} else {
		connection.Compression = nil
	}

	// ConsumerGroup
	connection.ConsumerGroup = genruntime.ClonePointerToString(source.ConsumerGroup)

	// DataFormat
	if source.DataFormat != nil {
		dataFormat := genruntime.ToEnum(string(*source.DataFormat), eventHubDataFormat_Values)
		connection.DataFormat = &dataFormat
	} else {
		connection.DataFormat = nil
	}

	// DatabaseRouting
	if source.DatabaseRouting != nil {
		databaseRouting := genruntime.ToEnum(string(*source.DatabaseRouting), eventHubConnectionProperties_DatabaseRouting_Values)
		connection.DatabaseRouting = &databaseRouting
	} else {
		connection.DatabaseRouting = nil
	}

	// EventHubResourceReference
	if source.EventHubResourceId != nil {
		eventHubResourceReference := genruntime.CreateResourceReferenceFromARMID(*source.EventHubResourceId)
		connection.EventHubResourceReference = &eventHubResourceReference
	} else {
		connection.EventHubResourceReference = nil
	}

	// EventSystemProperties
	connection.EventSystemProperties = genruntime.CloneSliceOfString(source.EventSystemProperties)

	// Kind
	if source.Kind != nil {
		kind := genruntime.ToEnum(string(*source.Kind), eventHubDataConnection_Kind_Values)
		connection.Kind = &kind
	} else {
		connection.Kind = nil
	}

	// Location
	connection.Location = genruntime.ClonePointerToString(source.Location)

	// ManagedIdentityResourceReference
	if source.ManagedIdentityResourceId != nil {
		managedIdentityResourceReference := genruntime.CreateResourceReferenceFromARMID(*source.ManagedIdentityResourceId)
		connection.ManagedIdentityResourceReference = &managedIdentityResourceReference
	} else {
		connection.ManagedIdentityResourceReference = nil
	}

	// MappingRuleName
	connection.MappingRuleName = genruntime.ClonePointerToString(source.MappingRuleName)

	// RetrievalStartDate
	connection.RetrievalStartDate = genruntime.ClonePointerToString(source.RetrievalStartDate)

	// TableName
	connection.TableName = genruntime.ClonePointerToString(source.TableName)

	// No error
	return nil
}

type EventHubDataConnection_STATUS struct {
	// Compression: The event hub messages compression type
	Compression *Compression_STATUS `json:"compression,omitempty"`

	// ConsumerGroup: The event hub consumer group.
	ConsumerGroup *string `json:"consumerGroup,omitempty"`

	// DataFormat: The data format of the message. Optionally the data format can be added to each message.
	DataFormat *EventHubDataFormat_STATUS `json:"dataFormat,omitempty"`

	// DatabaseRouting: Indication for database routing information from the data connection, by default only database routing
	// information is allowed
	DatabaseRouting *EventHubConnectionProperties_DatabaseRouting_STATUS `json:"databaseRouting,omitempty"`

	// EventHubResourceId: The resource ID of the event hub to be used to create a data connection.
	EventHubResourceId *string `json:"eventHubResourceId,omitempty"`

	// EventSystemProperties: System properties of the event hub
	EventSystemProperties []string `json:"eventSystemProperties,omitempty"`

	// Id: Fully qualified resource ID for the resource. Ex -
	// /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	Id *string `json:"id,omitempty"`

	// Kind: Kind of the endpoint for the data connection
	Kind *EventHubDataConnection_Kind_STATUS `json:"kind,omitempty"`

	// Location: Resource location.
	Location *string `json:"location,omitempty"`

	// ManagedIdentityObjectId: The object ID of the managedIdentityResourceId
	ManagedIdentityObjectId *string `json:"managedIdentityObjectId,omitempty"`

	// ManagedIdentityResourceId: The resource ID of a managed identity (system or user assigned) to be used to authenticate
	// with event hub.
	ManagedIdentityResourceId *string `json:"managedIdentityResourceId,omitempty"`

	// MappingRuleName: The mapping rule to be used to ingest the data. Optionally the mapping information can be added to each
	// message.
	MappingRuleName *string `json:"mappingRuleName,omitempty"`

	// ProvisioningState: The provisioned state of the resource.
	ProvisioningState *ProvisioningState_STATUS `json:"provisioningState,omitempty"`

	// RetrievalStartDate: When defined, the data connection retrieves existing Event hub events created since the Retrieval
	// start date. It can only retrieve events retained by the Event hub, based on its retention period.
	RetrievalStartDate *string `json:"retrievalStartDate,omitempty"`

	// TableName: The table where the data should be ingested. Optionally the table information can be added to each message.
	TableName *string `json:"tableName,omitempty"`

	// Type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &EventHubDataConnection_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (connection *EventHubDataConnection_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.EventHubDataConnection_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (connection *EventHubDataConnection_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.EventHubDataConnection_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.EventHubDataConnection_STATUS, got %T", armInput)
	}

	// Set property "Compression":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Compression != nil {
			var temp string
			temp = string(*typedInput.Properties.Compression)
			compression := Compression_STATUS(temp)
			connection.Compression = &compression
		}
	}

	// Set property "ConsumerGroup":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ConsumerGroup != nil {
			consumerGroup := *typedInput.Properties.ConsumerGroup
			connection.ConsumerGroup = &consumerGroup
		}
	}

	// Set property "DataFormat":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DataFormat != nil {
			var temp string
			temp = string(*typedInput.Properties.DataFormat)
			dataFormat := EventHubDataFormat_STATUS(temp)
			connection.DataFormat = &dataFormat
		}
	}

	// Set property "DatabaseRouting":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DatabaseRouting != nil {
			var temp string
			temp = string(*typedInput.Properties.DatabaseRouting)
			databaseRouting := EventHubConnectionProperties_DatabaseRouting_STATUS(temp)
			connection.DatabaseRouting = &databaseRouting
		}
	}

	// Set property "EventHubResourceId":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EventHubResourceId != nil {
			eventHubResourceId := *typedInput.Properties.EventHubResourceId
			connection.EventHubResourceId = &eventHubResourceId
		}
	}

	// Set property "EventSystemProperties":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.EventSystemProperties {
			connection.EventSystemProperties = append(connection.EventSystemProperties, item)
		}
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		connection.Id = &id
	}

	// Set property "Kind":
	var temp EventHubDataConnection_Kind_STATUS
	var temp1 string
	temp1 = string(typedInput.Kind)
	temp = EventHubDataConnection_Kind_STATUS(temp1)
	connection.Kind = &temp

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		connection.Location = &location
	}

	// Set property "ManagedIdentityObjectId":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ManagedIdentityObjectId != nil {
			managedIdentityObjectId := *typedInput.Properties.ManagedIdentityObjectId
			connection.ManagedIdentityObjectId = &managedIdentityObjectId
		}
	}

	// Set property "ManagedIdentityResourceId":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ManagedIdentityResourceId != nil {
			managedIdentityResourceId := *typedInput.Properties.ManagedIdentityResourceId
			connection.ManagedIdentityResourceId = &managedIdentityResourceId
		}
	}

	// Set property "MappingRuleName":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MappingRuleName != nil {
			mappingRuleName := *typedInput.Properties.MappingRuleName
			connection.MappingRuleName = &mappingRuleName
		}
	}

	// Set property "ProvisioningState":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			var provisioningStateTemp string
			provisioningStateTemp = string(*typedInput.Properties.ProvisioningState)
			provisioningState := ProvisioningState_STATUS(provisioningStateTemp)
			connection.ProvisioningState = &provisioningState
		}
	}

	// Set property "RetrievalStartDate":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.RetrievalStartDate != nil {
			retrievalStartDate := *typedInput.Properties.RetrievalStartDate
			connection.RetrievalStartDate = &retrievalStartDate
		}
	}

	// Set property "TableName":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.TableName != nil {
			tableName := *typedInput.Properties.TableName
			connection.TableName = &tableName
		}
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		connection.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_EventHubDataConnection_STATUS populates our EventHubDataConnection_STATUS from the provided source EventHubDataConnection_STATUS
func (connection *EventHubDataConnection_STATUS) AssignProperties_From_EventHubDataConnection_STATUS(source *storage.EventHubDataConnection_STATUS) error {

	// Compression
	if source.Compression != nil {
		compression := *source.Compression
		compressionTemp := genruntime.ToEnum(compression, compression_STATUS_Values)
		connection.Compression = &compressionTemp
	} else {
		connection.Compression = nil
	}

	// ConsumerGroup
	connection.ConsumerGroup = genruntime.ClonePointerToString(source.ConsumerGroup)

	// DataFormat
	if source.DataFormat != nil {
		dataFormat := *source.DataFormat
		dataFormatTemp := genruntime.ToEnum(dataFormat, eventHubDataFormat_STATUS_Values)
		connection.DataFormat = &dataFormatTemp
	} else {
		connection.DataFormat = nil
	}

	// DatabaseRouting
	if source.DatabaseRouting != nil {
		databaseRouting := *source.DatabaseRouting
		databaseRoutingTemp := genruntime.ToEnum(databaseRouting, eventHubConnectionProperties_DatabaseRouting_STATUS_Values)
		connection.DatabaseRouting = &databaseRoutingTemp
	} else {
		connection.DatabaseRouting = nil
	}

	// EventHubResourceId
	connection.EventHubResourceId = genruntime.ClonePointerToString(source.EventHubResourceId)

	// EventSystemProperties
	connection.EventSystemProperties = genruntime.CloneSliceOfString(source.EventSystemProperties)

	// Id
	connection.Id = genruntime.ClonePointerToString(source.Id)

	// Kind
	if source.Kind != nil {
		kind := *source.Kind
		kindTemp := genruntime.ToEnum(kind, eventHubDataConnection_Kind_STATUS_Values)
		connection.Kind = &kindTemp
	} else {
		connection.Kind = nil
	}

	// Location
	connection.Location = genruntime.ClonePointerToString(source.Location)

	// ManagedIdentityObjectId
	connection.ManagedIdentityObjectId = genruntime.ClonePointerToString(source.ManagedIdentityObjectId)

	// ManagedIdentityResourceId
	connection.ManagedIdentityResourceId = genruntime.ClonePointerToString(source.ManagedIdentityResourceId)

	// MappingRuleName
	connection.MappingRuleName = genruntime.ClonePointerToString(source.MappingRuleName)

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := *source.ProvisioningState
		provisioningStateTemp := genruntime.ToEnum(provisioningState, provisioningState_STATUS_Values)
		connection.ProvisioningState = &provisioningStateTemp
	} else {
		connection.ProvisioningState = nil
	}

	// RetrievalStartDate
	connection.RetrievalStartDate = genruntime.ClonePointerToString(source.RetrievalStartDate)

	// TableName
	connection.TableName = genruntime.ClonePointerToString(source.TableName)

	// Type
	connection.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignProperties_To_EventHubDataConnection_STATUS populates the provided destination EventHubDataConnection_STATUS from our EventHubDataConnection_STATUS
func (connection *EventHubDataConnection_STATUS) AssignProperties_To_EventHubDataConnection_STATUS(destination *storage.EventHubDataConnection_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Compression
	if connection.Compression != nil {
		compression := string(*connection.Compression)
		destination.Compression = &compression
	} else {
		destination.Compression = nil
	}

	// ConsumerGroup
	destination.ConsumerGroup = genruntime.ClonePointerToString(connection.ConsumerGroup)

	// DataFormat
	if connection.DataFormat != nil {
		dataFormat := string(*connection.DataFormat)
		destination.DataFormat = &dataFormat
	} else {
		destination.DataFormat = nil
	}

	// DatabaseRouting
	if connection.DatabaseRouting != nil {
		databaseRouting := string(*connection.DatabaseRouting)
		destination.DatabaseRouting = &databaseRouting
	} else {
		destination.DatabaseRouting = nil
	}

	// EventHubResourceId
	destination.EventHubResourceId = genruntime.ClonePointerToString(connection.EventHubResourceId)

	// EventSystemProperties
	destination.EventSystemProperties = genruntime.CloneSliceOfString(connection.EventSystemProperties)

	// Id
	destination.Id = genruntime.ClonePointerToString(connection.Id)

	// Kind
	if connection.Kind != nil {
		kind := string(*connection.Kind)
		destination.Kind = &kind
	} else {
		destination.Kind = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(connection.Location)

	// ManagedIdentityObjectId
	destination.ManagedIdentityObjectId = genruntime.ClonePointerToString(connection.ManagedIdentityObjectId)

	// ManagedIdentityResourceId
	destination.ManagedIdentityResourceId = genruntime.ClonePointerToString(connection.ManagedIdentityResourceId)

	// MappingRuleName
	destination.MappingRuleName = genruntime.ClonePointerToString(connection.MappingRuleName)

	// ProvisioningState
	if connection.ProvisioningState != nil {
		provisioningState := string(*connection.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// RetrievalStartDate
	destination.RetrievalStartDate = genruntime.ClonePointerToString(connection.RetrievalStartDate)

	// TableName
	destination.TableName = genruntime.ClonePointerToString(connection.TableName)

	// Type
	destination.Type = genruntime.ClonePointerToString(connection.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type IotHubDataConnection struct {
	// +kubebuilder:validation:Required
	// ConsumerGroup: The iot hub consumer group.
	ConsumerGroup *string `json:"consumerGroup,omitempty"`

	// DataFormat: The data format of the message. Optionally the data format can be added to each message.
	DataFormat *IotHubDataFormat `json:"dataFormat,omitempty"`

	// DatabaseRouting: Indication for database routing information from the data connection, by default only database routing
	// information is allowed
	DatabaseRouting *IotHubConnectionProperties_DatabaseRouting `json:"databaseRouting,omitempty"`

	// EventSystemProperties: System properties of the iot hub
	EventSystemProperties []string `json:"eventSystemProperties,omitempty"`

	// +kubebuilder:validation:Required
	// IotHubResourceReference: The resource ID of the Iot hub to be used to create a data connection.
	IotHubResourceReference *genruntime.ResourceReference `armReference:"IotHubResourceId" json:"iotHubResourceReference,omitempty"`

	// +kubebuilder:validation:Required
	// Kind: Kind of the endpoint for the data connection
	Kind *IotHubDataConnection_Kind `json:"kind,omitempty"`

	// Location: Resource location.
	Location *string `json:"location,omitempty"`

	// MappingRuleName: The mapping rule to be used to ingest the data. Optionally the mapping information can be added to each
	// message.
	MappingRuleName *string `json:"mappingRuleName,omitempty"`

	// RetrievalStartDate: When defined, the data connection retrieves existing Event hub events created since the Retrieval
	// start date. It can only retrieve events retained by the Event hub, based on its retention period.
	RetrievalStartDate *string `json:"retrievalStartDate,omitempty"`

	// +kubebuilder:validation:Required
	// SharedAccessPolicyName: The name of the share access policy
	SharedAccessPolicyName *string `json:"sharedAccessPolicyName,omitempty"`

	// TableName: The table where the data should be ingested. Optionally the table information can be added to each message.
	TableName *string `json:"tableName,omitempty"`
}

var _ genruntime.ARMTransformer = &IotHubDataConnection{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (connection *IotHubDataConnection) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if connection == nil {
		return nil, nil
	}
	result := &arm.IotHubDataConnection{}

	// Set property "Kind":
	if connection.Kind != nil {
		var temp arm.IotHubDataConnection_Kind
		var temp1 string
		temp1 = string(*connection.Kind)
		temp = arm.IotHubDataConnection_Kind(temp1)
		result.Kind = temp
	}

	// Set property "Location":
	if connection.Location != nil {
		location := *connection.Location
		result.Location = &location
	}

	// no assignment for property "Name"

	// Set property "Properties":
	if connection.ConsumerGroup != nil ||
		connection.DataFormat != nil ||
		connection.DatabaseRouting != nil ||
		connection.EventSystemProperties != nil ||
		connection.IotHubResourceReference != nil ||
		connection.MappingRuleName != nil ||
		connection.RetrievalStartDate != nil ||
		connection.SharedAccessPolicyName != nil ||
		connection.TableName != nil {
		result.Properties = &arm.IotHubConnectionProperties{}
	}
	if connection.ConsumerGroup != nil {
		consumerGroup := *connection.ConsumerGroup
		result.Properties.ConsumerGroup = &consumerGroup
	}
	if connection.DataFormat != nil {
		var temp string
		temp = string(*connection.DataFormat)
		dataFormat := arm.IotHubDataFormat(temp)
		result.Properties.DataFormat = &dataFormat
	}
	if connection.DatabaseRouting != nil {
		var temp string
		temp = string(*connection.DatabaseRouting)
		databaseRouting := arm.IotHubConnectionProperties_DatabaseRouting(temp)
		result.Properties.DatabaseRouting = &databaseRouting
	}
	for _, item := range connection.EventSystemProperties {
		result.Properties.EventSystemProperties = append(result.Properties.EventSystemProperties, item)
	}
	if connection.IotHubResourceReference != nil {
		iotHubResourceIdARMID, err := resolved.ResolvedReferences.Lookup(*connection.IotHubResourceReference)
		if err != nil {
			return nil, err
		}
		iotHubResourceId := iotHubResourceIdARMID
		result.Properties.IotHubResourceId = &iotHubResourceId
	}
	if connection.MappingRuleName != nil {
		mappingRuleName := *connection.MappingRuleName
		result.Properties.MappingRuleName = &mappingRuleName
	}
	if connection.RetrievalStartDate != nil {
		retrievalStartDate := *connection.RetrievalStartDate
		result.Properties.RetrievalStartDate = &retrievalStartDate
	}
	if connection.SharedAccessPolicyName != nil {
		sharedAccessPolicyName := *connection.SharedAccessPolicyName
		result.Properties.SharedAccessPolicyName = &sharedAccessPolicyName
	}
	if connection.TableName != nil {
		tableName := *connection.TableName
		result.Properties.TableName = &tableName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (connection *IotHubDataConnection) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.IotHubDataConnection{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (connection *IotHubDataConnection) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.IotHubDataConnection)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.IotHubDataConnection, got %T", armInput)
	}

	// Set property "ConsumerGroup":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ConsumerGroup != nil {
			consumerGroup := *typedInput.Properties.ConsumerGroup
			connection.ConsumerGroup = &consumerGroup
		}
	}

	// Set property "DataFormat":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DataFormat != nil {
			var temp string
			temp = string(*typedInput.Properties.DataFormat)
			dataFormat := IotHubDataFormat(temp)
			connection.DataFormat = &dataFormat
		}
	}

	// Set property "DatabaseRouting":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DatabaseRouting != nil {
			var temp string
			temp = string(*typedInput.Properties.DatabaseRouting)
			databaseRouting := IotHubConnectionProperties_DatabaseRouting(temp)
			connection.DatabaseRouting = &databaseRouting
		}
	}

	// Set property "EventSystemProperties":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.EventSystemProperties {
			connection.EventSystemProperties = append(connection.EventSystemProperties, item)
		}
	}

	// no assignment for property "IotHubResourceReference"

	// Set property "Kind":
	var temp IotHubDataConnection_Kind
	var temp1 string
	temp1 = string(typedInput.Kind)
	temp = IotHubDataConnection_Kind(temp1)
	connection.Kind = &temp

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		connection.Location = &location
	}

	// Set property "MappingRuleName":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MappingRuleName != nil {
			mappingRuleName := *typedInput.Properties.MappingRuleName
			connection.MappingRuleName = &mappingRuleName
		}
	}

	// Set property "RetrievalStartDate":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.RetrievalStartDate != nil {
			retrievalStartDate := *typedInput.Properties.RetrievalStartDate
			connection.RetrievalStartDate = &retrievalStartDate
		}
	}

	// Set property "SharedAccessPolicyName":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.SharedAccessPolicyName != nil {
			sharedAccessPolicyName := *typedInput.Properties.SharedAccessPolicyName
			connection.SharedAccessPolicyName = &sharedAccessPolicyName
		}
	}

	// Set property "TableName":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.TableName != nil {
			tableName := *typedInput.Properties.TableName
			connection.TableName = &tableName
		}
	}

	// No error
	return nil
}

// AssignProperties_From_IotHubDataConnection populates our IotHubDataConnection from the provided source IotHubDataConnection
func (connection *IotHubDataConnection) AssignProperties_From_IotHubDataConnection(source *storage.IotHubDataConnection) error {

	// ConsumerGroup
	connection.ConsumerGroup = genruntime.ClonePointerToString(source.ConsumerGroup)

	// DataFormat
	if source.DataFormat != nil {
		dataFormat := *source.DataFormat
		dataFormatTemp := genruntime.ToEnum(dataFormat, iotHubDataFormat_Values)
		connection.DataFormat = &dataFormatTemp
	} else {
		connection.DataFormat = nil
	}

	// DatabaseRouting
	if source.DatabaseRouting != nil {
		databaseRouting := *source.DatabaseRouting
		databaseRoutingTemp := genruntime.ToEnum(databaseRouting, iotHubConnectionProperties_DatabaseRouting_Values)
		connection.DatabaseRouting = &databaseRoutingTemp
	} else {
		connection.DatabaseRouting = nil
	}

	// EventSystemProperties
	connection.EventSystemProperties = genruntime.CloneSliceOfString(source.EventSystemProperties)

	// IotHubResourceReference
	if source.IotHubResourceReference != nil {
		iotHubResourceReference := source.IotHubResourceReference.Copy()
		connection.IotHubResourceReference = &iotHubResourceReference
	} else {
		connection.IotHubResourceReference = nil
	}

	// Kind
	if source.Kind != nil {
		kind := *source.Kind
		kindTemp := genruntime.ToEnum(kind, iotHubDataConnection_Kind_Values)
		connection.Kind = &kindTemp
	} else {
		connection.Kind = nil
	}

	// Location
	connection.Location = genruntime.ClonePointerToString(source.Location)

	// MappingRuleName
	connection.MappingRuleName = genruntime.ClonePointerToString(source.MappingRuleName)

	// RetrievalStartDate
	connection.RetrievalStartDate = genruntime.ClonePointerToString(source.RetrievalStartDate)

	// SharedAccessPolicyName
	connection.SharedAccessPolicyName = genruntime.ClonePointerToString(source.SharedAccessPolicyName)

	// TableName
	connection.TableName = genruntime.ClonePointerToString(source.TableName)

	// No error
	return nil
}

// AssignProperties_To_IotHubDataConnection populates the provided destination IotHubDataConnection from our IotHubDataConnection
func (connection *IotHubDataConnection) AssignProperties_To_IotHubDataConnection(destination *storage.IotHubDataConnection) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ConsumerGroup
	destination.ConsumerGroup = genruntime.ClonePointerToString(connection.ConsumerGroup)

	// DataFormat
	if connection.DataFormat != nil {
		dataFormat := string(*connection.DataFormat)
		destination.DataFormat = &dataFormat
	} else {
		destination.DataFormat = nil
	}

	// DatabaseRouting
	if connection.DatabaseRouting != nil {
		databaseRouting := string(*connection.DatabaseRouting)
		destination.DatabaseRouting = &databaseRouting
	} else {
		destination.DatabaseRouting = nil
	}

	// EventSystemProperties
	destination.EventSystemProperties = genruntime.CloneSliceOfString(connection.EventSystemProperties)

	// IotHubResourceReference
	if connection.IotHubResourceReference != nil {
		iotHubResourceReference := connection.IotHubResourceReference.Copy()
		destination.IotHubResourceReference = &iotHubResourceReference
	} else {
		destination.IotHubResourceReference = nil
	}

	// Kind
	if connection.Kind != nil {
		kind := string(*connection.Kind)
		destination.Kind = &kind
	} else {
		destination.Kind = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(connection.Location)

	// MappingRuleName
	destination.MappingRuleName = genruntime.ClonePointerToString(connection.MappingRuleName)

	// RetrievalStartDate
	destination.RetrievalStartDate = genruntime.ClonePointerToString(connection.RetrievalStartDate)

	// SharedAccessPolicyName
	destination.SharedAccessPolicyName = genruntime.ClonePointerToString(connection.SharedAccessPolicyName)

	// TableName
	destination.TableName = genruntime.ClonePointerToString(connection.TableName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_IotHubDataConnection_STATUS populates our IotHubDataConnection from the provided source IotHubDataConnection_STATUS
func (connection *IotHubDataConnection) Initialize_From_IotHubDataConnection_STATUS(source *IotHubDataConnection_STATUS) error {

	// ConsumerGroup
	connection.ConsumerGroup = genruntime.ClonePointerToString(source.ConsumerGroup)

	// DataFormat
	if source.DataFormat != nil {
		dataFormat := genruntime.ToEnum(string(*source.DataFormat), iotHubDataFormat_Values)
		connection.DataFormat = &dataFormat
	} else {
		connection.DataFormat = nil
	}

	// DatabaseRouting
	if source.DatabaseRouting != nil {
		databaseRouting := genruntime.ToEnum(string(*source.DatabaseRouting), iotHubConnectionProperties_DatabaseRouting_Values)
		connection.DatabaseRouting = &databaseRouting
	} else {
		connection.DatabaseRouting = nil
	}

	// EventSystemProperties
	connection.EventSystemProperties = genruntime.CloneSliceOfString(source.EventSystemProperties)

	// IotHubResourceReference
	if source.IotHubResourceId != nil {
		iotHubResourceReference := genruntime.CreateResourceReferenceFromARMID(*source.IotHubResourceId)
		connection.IotHubResourceReference = &iotHubResourceReference
	} else {
		connection.IotHubResourceReference = nil
	}

	// Kind
	if source.Kind != nil {
		kind := genruntime.ToEnum(string(*source.Kind), iotHubDataConnection_Kind_Values)
		connection.Kind = &kind
	} else {
		connection.Kind = nil
	}

	// Location
	connection.Location = genruntime.ClonePointerToString(source.Location)

	// MappingRuleName
	connection.MappingRuleName = genruntime.ClonePointerToString(source.MappingRuleName)

	// RetrievalStartDate
	connection.RetrievalStartDate = genruntime.ClonePointerToString(source.RetrievalStartDate)

	// SharedAccessPolicyName
	connection.SharedAccessPolicyName = genruntime.ClonePointerToString(source.SharedAccessPolicyName)

	// TableName
	connection.TableName = genruntime.ClonePointerToString(source.TableName)

	// No error
	return nil
}

type IotHubDataConnection_STATUS struct {
	// ConsumerGroup: The iot hub consumer group.
	ConsumerGroup *string `json:"consumerGroup,omitempty"`

	// DataFormat: The data format of the message. Optionally the data format can be added to each message.
	DataFormat *IotHubDataFormat_STATUS `json:"dataFormat,omitempty"`

	// DatabaseRouting: Indication for database routing information from the data connection, by default only database routing
	// information is allowed
	DatabaseRouting *IotHubConnectionProperties_DatabaseRouting_STATUS `json:"databaseRouting,omitempty"`

	// EventSystemProperties: System properties of the iot hub
	EventSystemProperties []string `json:"eventSystemProperties,omitempty"`

	// Id: Fully qualified resource ID for the resource. Ex -
	// /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	Id *string `json:"id,omitempty"`

	// IotHubResourceId: The resource ID of the Iot hub to be used to create a data connection.
	IotHubResourceId *string `json:"iotHubResourceId,omitempty"`

	// Kind: Kind of the endpoint for the data connection
	Kind *IotHubDataConnection_Kind_STATUS `json:"kind,omitempty"`

	// Location: Resource location.
	Location *string `json:"location,omitempty"`

	// MappingRuleName: The mapping rule to be used to ingest the data. Optionally the mapping information can be added to each
	// message.
	MappingRuleName *string `json:"mappingRuleName,omitempty"`

	// ProvisioningState: The provisioned state of the resource.
	ProvisioningState *ProvisioningState_STATUS `json:"provisioningState,omitempty"`

	// RetrievalStartDate: When defined, the data connection retrieves existing Event hub events created since the Retrieval
	// start date. It can only retrieve events retained by the Event hub, based on its retention period.
	RetrievalStartDate *string `json:"retrievalStartDate,omitempty"`

	// SharedAccessPolicyName: The name of the share access policy
	SharedAccessPolicyName *string `json:"sharedAccessPolicyName,omitempty"`

	// TableName: The table where the data should be ingested. Optionally the table information can be added to each message.
	TableName *string `json:"tableName,omitempty"`

	// Type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &IotHubDataConnection_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (connection *IotHubDataConnection_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.IotHubDataConnection_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (connection *IotHubDataConnection_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.IotHubDataConnection_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.IotHubDataConnection_STATUS, got %T", armInput)
	}

	// Set property "ConsumerGroup":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ConsumerGroup != nil {
			consumerGroup := *typedInput.Properties.ConsumerGroup
			connection.ConsumerGroup = &consumerGroup
		}
	}

	// Set property "DataFormat":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DataFormat != nil {
			var temp string
			temp = string(*typedInput.Properties.DataFormat)
			dataFormat := IotHubDataFormat_STATUS(temp)
			connection.DataFormat = &dataFormat
		}
	}

	// Set property "DatabaseRouting":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DatabaseRouting != nil {
			var temp string
			temp = string(*typedInput.Properties.DatabaseRouting)
			databaseRouting := IotHubConnectionProperties_DatabaseRouting_STATUS(temp)
			connection.DatabaseRouting = &databaseRouting
		}
	}

	// Set property "EventSystemProperties":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.EventSystemProperties {
			connection.EventSystemProperties = append(connection.EventSystemProperties, item)
		}
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		connection.Id = &id
	}

	// Set property "IotHubResourceId":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IotHubResourceId != nil {
			iotHubResourceId := *typedInput.Properties.IotHubResourceId
			connection.IotHubResourceId = &iotHubResourceId
		}
	}

	// Set property "Kind":
	var temp IotHubDataConnection_Kind_STATUS
	var temp1 string
	temp1 = string(typedInput.Kind)
	temp = IotHubDataConnection_Kind_STATUS(temp1)
	connection.Kind = &temp

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		connection.Location = &location
	}

	// Set property "MappingRuleName":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MappingRuleName != nil {
			mappingRuleName := *typedInput.Properties.MappingRuleName
			connection.MappingRuleName = &mappingRuleName
		}
	}

	// Set property "ProvisioningState":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			var provisioningStateTemp string
			provisioningStateTemp = string(*typedInput.Properties.ProvisioningState)
			provisioningState := ProvisioningState_STATUS(provisioningStateTemp)
			connection.ProvisioningState = &provisioningState
		}
	}

	// Set property "RetrievalStartDate":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.RetrievalStartDate != nil {
			retrievalStartDate := *typedInput.Properties.RetrievalStartDate
			connection.RetrievalStartDate = &retrievalStartDate
		}
	}

	// Set property "SharedAccessPolicyName":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.SharedAccessPolicyName != nil {
			sharedAccessPolicyName := *typedInput.Properties.SharedAccessPolicyName
			connection.SharedAccessPolicyName = &sharedAccessPolicyName
		}
	}

	// Set property "TableName":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.TableName != nil {
			tableName := *typedInput.Properties.TableName
			connection.TableName = &tableName
		}
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		connection.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_IotHubDataConnection_STATUS populates our IotHubDataConnection_STATUS from the provided source IotHubDataConnection_STATUS
func (connection *IotHubDataConnection_STATUS) AssignProperties_From_IotHubDataConnection_STATUS(source *storage.IotHubDataConnection_STATUS) error {

	// ConsumerGroup
	connection.ConsumerGroup = genruntime.ClonePointerToString(source.ConsumerGroup)

	// DataFormat
	if source.DataFormat != nil {
		dataFormat := *source.DataFormat
		dataFormatTemp := genruntime.ToEnum(dataFormat, iotHubDataFormat_STATUS_Values)
		connection.DataFormat = &dataFormatTemp
	} else {
		connection.DataFormat = nil
	}

	// DatabaseRouting
	if source.DatabaseRouting != nil {
		databaseRouting := *source.DatabaseRouting
		databaseRoutingTemp := genruntime.ToEnum(databaseRouting, iotHubConnectionProperties_DatabaseRouting_STATUS_Values)
		connection.DatabaseRouting = &databaseRoutingTemp
	} else {
		connection.DatabaseRouting = nil
	}

	// EventSystemProperties
	connection.EventSystemProperties = genruntime.CloneSliceOfString(source.EventSystemProperties)

	// Id
	connection.Id = genruntime.ClonePointerToString(source.Id)

	// IotHubResourceId
	connection.IotHubResourceId = genruntime.ClonePointerToString(source.IotHubResourceId)

	// Kind
	if source.Kind != nil {
		kind := *source.Kind
		kindTemp := genruntime.ToEnum(kind, iotHubDataConnection_Kind_STATUS_Values)
		connection.Kind = &kindTemp
	} else {
		connection.Kind = nil
	}

	// Location
	connection.Location = genruntime.ClonePointerToString(source.Location)

	// MappingRuleName
	connection.MappingRuleName = genruntime.ClonePointerToString(source.MappingRuleName)

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := *source.ProvisioningState
		provisioningStateTemp := genruntime.ToEnum(provisioningState, provisioningState_STATUS_Values)
		connection.ProvisioningState = &provisioningStateTemp
	} else {
		connection.ProvisioningState = nil
	}

	// RetrievalStartDate
	connection.RetrievalStartDate = genruntime.ClonePointerToString(source.RetrievalStartDate)

	// SharedAccessPolicyName
	connection.SharedAccessPolicyName = genruntime.ClonePointerToString(source.SharedAccessPolicyName)

	// TableName
	connection.TableName = genruntime.ClonePointerToString(source.TableName)

	// Type
	connection.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignProperties_To_IotHubDataConnection_STATUS populates the provided destination IotHubDataConnection_STATUS from our IotHubDataConnection_STATUS
func (connection *IotHubDataConnection_STATUS) AssignProperties_To_IotHubDataConnection_STATUS(destination *storage.IotHubDataConnection_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ConsumerGroup
	destination.ConsumerGroup = genruntime.ClonePointerToString(connection.ConsumerGroup)

	// DataFormat
	if connection.DataFormat != nil {
		dataFormat := string(*connection.DataFormat)
		destination.DataFormat = &dataFormat
	} else {
		destination.DataFormat = nil
	}

	// DatabaseRouting
	if connection.DatabaseRouting != nil {
		databaseRouting := string(*connection.DatabaseRouting)
		destination.DatabaseRouting = &databaseRouting
	} else {
		destination.DatabaseRouting = nil
	}

	// EventSystemProperties
	destination.EventSystemProperties = genruntime.CloneSliceOfString(connection.EventSystemProperties)

	// Id
	destination.Id = genruntime.ClonePointerToString(connection.Id)

	// IotHubResourceId
	destination.IotHubResourceId = genruntime.ClonePointerToString(connection.IotHubResourceId)

	// Kind
	if connection.Kind != nil {
		kind := string(*connection.Kind)
		destination.Kind = &kind
	} else {
		destination.Kind = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(connection.Location)

	// MappingRuleName
	destination.MappingRuleName = genruntime.ClonePointerToString(connection.MappingRuleName)

	// ProvisioningState
	if connection.ProvisioningState != nil {
		provisioningState := string(*connection.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// RetrievalStartDate
	destination.RetrievalStartDate = genruntime.ClonePointerToString(connection.RetrievalStartDate)

	// SharedAccessPolicyName
	destination.SharedAccessPolicyName = genruntime.ClonePointerToString(connection.SharedAccessPolicyName)

	// TableName
	destination.TableName = genruntime.ClonePointerToString(connection.TableName)

	// Type
	destination.Type = genruntime.ClonePointerToString(connection.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The name of blob storage event type to process.
// +kubebuilder:validation:Enum={"Microsoft.Storage.BlobCreated","Microsoft.Storage.BlobRenamed"}
type BlobStorageEventType string

const (
	BlobStorageEventType_MicrosoftStorageBlobCreated = BlobStorageEventType("Microsoft.Storage.BlobCreated")
	BlobStorageEventType_MicrosoftStorageBlobRenamed = BlobStorageEventType("Microsoft.Storage.BlobRenamed")
)

// Mapping from string to BlobStorageEventType
var blobStorageEventType_Values = map[string]BlobStorageEventType{
	"microsoft.storage.blobcreated": BlobStorageEventType_MicrosoftStorageBlobCreated,
	"microsoft.storage.blobrenamed": BlobStorageEventType_MicrosoftStorageBlobRenamed,
}

// The name of blob storage event type to process.
type BlobStorageEventType_STATUS string

const (
	BlobStorageEventType_STATUS_MicrosoftStorageBlobCreated = BlobStorageEventType_STATUS("Microsoft.Storage.BlobCreated")
	BlobStorageEventType_STATUS_MicrosoftStorageBlobRenamed = BlobStorageEventType_STATUS("Microsoft.Storage.BlobRenamed")
)

// Mapping from string to BlobStorageEventType_STATUS
var blobStorageEventType_STATUS_Values = map[string]BlobStorageEventType_STATUS{
	"microsoft.storage.blobcreated": BlobStorageEventType_STATUS_MicrosoftStorageBlobCreated,
	"microsoft.storage.blobrenamed": BlobStorageEventType_STATUS_MicrosoftStorageBlobRenamed,
}

// The compression type
// +kubebuilder:validation:Enum={"GZip","None"}
type Compression string

const (
	Compression_GZip = Compression("GZip")
	Compression_None = Compression("None")
)

// Mapping from string to Compression
var compression_Values = map[string]Compression{
	"gzip": Compression_GZip,
	"none": Compression_None,
}

// The compression type
type Compression_STATUS string

const (
	Compression_STATUS_GZip = Compression_STATUS("GZip")
	Compression_STATUS_None = Compression_STATUS("None")
)

// Mapping from string to Compression_STATUS
var compression_STATUS_Values = map[string]Compression_STATUS{
	"gzip": Compression_STATUS_GZip,
	"none": Compression_STATUS_None,
}

// +kubebuilder:validation:Enum={"CosmosDb"}
type CosmosDbDataConnection_Kind string

const CosmosDbDataConnection_Kind_CosmosDb = CosmosDbDataConnection_Kind("CosmosDb")

// Mapping from string to CosmosDbDataConnection_Kind
var cosmosDbDataConnection_Kind_Values = map[string]CosmosDbDataConnection_Kind{
	"cosmosdb": CosmosDbDataConnection_Kind_CosmosDb,
}

type CosmosDbDataConnection_Kind_STATUS string

const CosmosDbDataConnection_Kind_STATUS_CosmosDb = CosmosDbDataConnection_Kind_STATUS("CosmosDb")

// Mapping from string to CosmosDbDataConnection_Kind_STATUS
var cosmosDbDataConnection_Kind_STATUS_Values = map[string]CosmosDbDataConnection_Kind_STATUS{
	"cosmosdb": CosmosDbDataConnection_Kind_STATUS_CosmosDb,
}

// +kubebuilder:validation:Enum={"Multi","Single"}
type EventGridConnectionProperties_DatabaseRouting string

const (
	EventGridConnectionProperties_DatabaseRouting_Multi  = EventGridConnectionProperties_DatabaseRouting("Multi")
	EventGridConnectionProperties_DatabaseRouting_Single = EventGridConnectionProperties_DatabaseRouting("Single")
)

// Mapping from string to EventGridConnectionProperties_DatabaseRouting
var eventGridConnectionProperties_DatabaseRouting_Values = map[string]EventGridConnectionProperties_DatabaseRouting{
	"multi":  EventGridConnectionProperties_DatabaseRouting_Multi,
	"single": EventGridConnectionProperties_DatabaseRouting_Single,
}

type EventGridConnectionProperties_DatabaseRouting_STATUS string

const (
	EventGridConnectionProperties_DatabaseRouting_STATUS_Multi  = EventGridConnectionProperties_DatabaseRouting_STATUS("Multi")
	EventGridConnectionProperties_DatabaseRouting_STATUS_Single = EventGridConnectionProperties_DatabaseRouting_STATUS("Single")
)

// Mapping from string to EventGridConnectionProperties_DatabaseRouting_STATUS
var eventGridConnectionProperties_DatabaseRouting_STATUS_Values = map[string]EventGridConnectionProperties_DatabaseRouting_STATUS{
	"multi":  EventGridConnectionProperties_DatabaseRouting_STATUS_Multi,
	"single": EventGridConnectionProperties_DatabaseRouting_STATUS_Single,
}

// +kubebuilder:validation:Enum={"EventGrid"}
type EventGridDataConnection_Kind string

const EventGridDataConnection_Kind_EventGrid = EventGridDataConnection_Kind("EventGrid")

// Mapping from string to EventGridDataConnection_Kind
var eventGridDataConnection_Kind_Values = map[string]EventGridDataConnection_Kind{
	"eventgrid": EventGridDataConnection_Kind_EventGrid,
}

type EventGridDataConnection_Kind_STATUS string

const EventGridDataConnection_Kind_STATUS_EventGrid = EventGridDataConnection_Kind_STATUS("EventGrid")

// Mapping from string to EventGridDataConnection_Kind_STATUS
var eventGridDataConnection_Kind_STATUS_Values = map[string]EventGridDataConnection_Kind_STATUS{
	"eventgrid": EventGridDataConnection_Kind_STATUS_EventGrid,
}

// The data format of the message. Optionally the data format can be added to each message.
// +kubebuilder:validation:Enum={"APACHEAVRO","AVRO","CSV","JSON","MULTIJSON","ORC","PARQUET","PSV","RAW","SCSV","SINGLEJSON","SOHSV","TSV","TSVE","TXT","W3CLOGFILE"}
type EventGridDataFormat string

const (
	EventGridDataFormat_APACHEAVRO = EventGridDataFormat("APACHEAVRO")
	EventGridDataFormat_AVRO       = EventGridDataFormat("AVRO")
	EventGridDataFormat_CSV        = EventGridDataFormat("CSV")
	EventGridDataFormat_JSON       = EventGridDataFormat("JSON")
	EventGridDataFormat_MULTIJSON  = EventGridDataFormat("MULTIJSON")
	EventGridDataFormat_ORC        = EventGridDataFormat("ORC")
	EventGridDataFormat_PARQUET    = EventGridDataFormat("PARQUET")
	EventGridDataFormat_PSV        = EventGridDataFormat("PSV")
	EventGridDataFormat_RAW        = EventGridDataFormat("RAW")
	EventGridDataFormat_SCSV       = EventGridDataFormat("SCSV")
	EventGridDataFormat_SINGLEJSON = EventGridDataFormat("SINGLEJSON")
	EventGridDataFormat_SOHSV      = EventGridDataFormat("SOHSV")
	EventGridDataFormat_TSV        = EventGridDataFormat("TSV")
	EventGridDataFormat_TSVE       = EventGridDataFormat("TSVE")
	EventGridDataFormat_TXT        = EventGridDataFormat("TXT")
	EventGridDataFormat_W3CLOGFILE = EventGridDataFormat("W3CLOGFILE")
)

// Mapping from string to EventGridDataFormat
var eventGridDataFormat_Values = map[string]EventGridDataFormat{
	"apacheavro": EventGridDataFormat_APACHEAVRO,
	"avro":       EventGridDataFormat_AVRO,
	"csv":        EventGridDataFormat_CSV,
	"json":       EventGridDataFormat_JSON,
	"multijson":  EventGridDataFormat_MULTIJSON,
	"orc":        EventGridDataFormat_ORC,
	"parquet":    EventGridDataFormat_PARQUET,
	"psv":        EventGridDataFormat_PSV,
	"raw":        EventGridDataFormat_RAW,
	"scsv":       EventGridDataFormat_SCSV,
	"singlejson": EventGridDataFormat_SINGLEJSON,
	"sohsv":      EventGridDataFormat_SOHSV,
	"tsv":        EventGridDataFormat_TSV,
	"tsve":       EventGridDataFormat_TSVE,
	"txt":        EventGridDataFormat_TXT,
	"w3clogfile": EventGridDataFormat_W3CLOGFILE,
}

// The data format of the message. Optionally the data format can be added to each message.
type EventGridDataFormat_STATUS string

const (
	EventGridDataFormat_STATUS_APACHEAVRO = EventGridDataFormat_STATUS("APACHEAVRO")
	EventGridDataFormat_STATUS_AVRO       = EventGridDataFormat_STATUS("AVRO")
	EventGridDataFormat_STATUS_CSV        = EventGridDataFormat_STATUS("CSV")
	EventGridDataFormat_STATUS_JSON       = EventGridDataFormat_STATUS("JSON")
	EventGridDataFormat_STATUS_MULTIJSON  = EventGridDataFormat_STATUS("MULTIJSON")
	EventGridDataFormat_STATUS_ORC        = EventGridDataFormat_STATUS("ORC")
	EventGridDataFormat_STATUS_PARQUET    = EventGridDataFormat_STATUS("PARQUET")
	EventGridDataFormat_STATUS_PSV        = EventGridDataFormat_STATUS("PSV")
	EventGridDataFormat_STATUS_RAW        = EventGridDataFormat_STATUS("RAW")
	EventGridDataFormat_STATUS_SCSV       = EventGridDataFormat_STATUS("SCSV")
	EventGridDataFormat_STATUS_SINGLEJSON = EventGridDataFormat_STATUS("SINGLEJSON")
	EventGridDataFormat_STATUS_SOHSV      = EventGridDataFormat_STATUS("SOHSV")
	EventGridDataFormat_STATUS_TSV        = EventGridDataFormat_STATUS("TSV")
	EventGridDataFormat_STATUS_TSVE       = EventGridDataFormat_STATUS("TSVE")
	EventGridDataFormat_STATUS_TXT        = EventGridDataFormat_STATUS("TXT")
	EventGridDataFormat_STATUS_W3CLOGFILE = EventGridDataFormat_STATUS("W3CLOGFILE")
)

// Mapping from string to EventGridDataFormat_STATUS
var eventGridDataFormat_STATUS_Values = map[string]EventGridDataFormat_STATUS{
	"apacheavro": EventGridDataFormat_STATUS_APACHEAVRO,
	"avro":       EventGridDataFormat_STATUS_AVRO,
	"csv":        EventGridDataFormat_STATUS_CSV,
	"json":       EventGridDataFormat_STATUS_JSON,
	"multijson":  EventGridDataFormat_STATUS_MULTIJSON,
	"orc":        EventGridDataFormat_STATUS_ORC,
	"parquet":    EventGridDataFormat_STATUS_PARQUET,
	"psv":        EventGridDataFormat_STATUS_PSV,
	"raw":        EventGridDataFormat_STATUS_RAW,
	"scsv":       EventGridDataFormat_STATUS_SCSV,
	"singlejson": EventGridDataFormat_STATUS_SINGLEJSON,
	"sohsv":      EventGridDataFormat_STATUS_SOHSV,
	"tsv":        EventGridDataFormat_STATUS_TSV,
	"tsve":       EventGridDataFormat_STATUS_TSVE,
	"txt":        EventGridDataFormat_STATUS_TXT,
	"w3clogfile": EventGridDataFormat_STATUS_W3CLOGFILE,
}

// +kubebuilder:validation:Enum={"Multi","Single"}
type EventHubConnectionProperties_DatabaseRouting string

const (
	EventHubConnectionProperties_DatabaseRouting_Multi  = EventHubConnectionProperties_DatabaseRouting("Multi")
	EventHubConnectionProperties_DatabaseRouting_Single = EventHubConnectionProperties_DatabaseRouting("Single")
)

// Mapping from string to EventHubConnectionProperties_DatabaseRouting
var eventHubConnectionProperties_DatabaseRouting_Values = map[string]EventHubConnectionProperties_DatabaseRouting{
	"multi":  EventHubConnectionProperties_DatabaseRouting_Multi,
	"single": EventHubConnectionProperties_DatabaseRouting_Single,
}

type EventHubConnectionProperties_DatabaseRouting_STATUS string

const (
	EventHubConnectionProperties_DatabaseRouting_STATUS_Multi  = EventHubConnectionProperties_DatabaseRouting_STATUS("Multi")
	EventHubConnectionProperties_DatabaseRouting_STATUS_Single = EventHubConnectionProperties_DatabaseRouting_STATUS("Single")
)

// Mapping from string to EventHubConnectionProperties_DatabaseRouting_STATUS
var eventHubConnectionProperties_DatabaseRouting_STATUS_Values = map[string]EventHubConnectionProperties_DatabaseRouting_STATUS{
	"multi":  EventHubConnectionProperties_DatabaseRouting_STATUS_Multi,
	"single": EventHubConnectionProperties_DatabaseRouting_STATUS_Single,
}

// +kubebuilder:validation:Enum={"EventHub"}
type EventHubDataConnection_Kind string

const EventHubDataConnection_Kind_EventHub = EventHubDataConnection_Kind("EventHub")

// Mapping from string to EventHubDataConnection_Kind
var eventHubDataConnection_Kind_Values = map[string]EventHubDataConnection_Kind{
	"eventhub": EventHubDataConnection_Kind_EventHub,
}

type EventHubDataConnection_Kind_STATUS string

const EventHubDataConnection_Kind_STATUS_EventHub = EventHubDataConnection_Kind_STATUS("EventHub")

// Mapping from string to EventHubDataConnection_Kind_STATUS
var eventHubDataConnection_Kind_STATUS_Values = map[string]EventHubDataConnection_Kind_STATUS{
	"eventhub": EventHubDataConnection_Kind_STATUS_EventHub,
}

// The data format of the message. Optionally the data format can be added to each message.
// +kubebuilder:validation:Enum={"APACHEAVRO","AVRO","CSV","JSON","MULTIJSON","ORC","PARQUET","PSV","RAW","SCSV","SINGLEJSON","SOHSV","TSV","TSVE","TXT","W3CLOGFILE"}
type EventHubDataFormat string

const (
	EventHubDataFormat_APACHEAVRO = EventHubDataFormat("APACHEAVRO")
	EventHubDataFormat_AVRO       = EventHubDataFormat("AVRO")
	EventHubDataFormat_CSV        = EventHubDataFormat("CSV")
	EventHubDataFormat_JSON       = EventHubDataFormat("JSON")
	EventHubDataFormat_MULTIJSON  = EventHubDataFormat("MULTIJSON")
	EventHubDataFormat_ORC        = EventHubDataFormat("ORC")
	EventHubDataFormat_PARQUET    = EventHubDataFormat("PARQUET")
	EventHubDataFormat_PSV        = EventHubDataFormat("PSV")
	EventHubDataFormat_RAW        = EventHubDataFormat("RAW")
	EventHubDataFormat_SCSV       = EventHubDataFormat("SCSV")
	EventHubDataFormat_SINGLEJSON = EventHubDataFormat("SINGLEJSON")
	EventHubDataFormat_SOHSV      = EventHubDataFormat("SOHSV")
	EventHubDataFormat_TSV        = EventHubDataFormat("TSV")
	EventHubDataFormat_TSVE       = EventHubDataFormat("TSVE")
	EventHubDataFormat_TXT        = EventHubDataFormat("TXT")
	EventHubDataFormat_W3CLOGFILE = EventHubDataFormat("W3CLOGFILE")
)

// Mapping from string to EventHubDataFormat
var eventHubDataFormat_Values = map[string]EventHubDataFormat{
	"apacheavro": EventHubDataFormat_APACHEAVRO,
	"avro":       EventHubDataFormat_AVRO,
	"csv":        EventHubDataFormat_CSV,
	"json":       EventHubDataFormat_JSON,
	"multijson":  EventHubDataFormat_MULTIJSON,
	"orc":        EventHubDataFormat_ORC,
	"parquet":    EventHubDataFormat_PARQUET,
	"psv":        EventHubDataFormat_PSV,
	"raw":        EventHubDataFormat_RAW,
	"scsv":       EventHubDataFormat_SCSV,
	"singlejson": EventHubDataFormat_SINGLEJSON,
	"sohsv":      EventHubDataFormat_SOHSV,
	"tsv":        EventHubDataFormat_TSV,
	"tsve":       EventHubDataFormat_TSVE,
	"txt":        EventHubDataFormat_TXT,
	"w3clogfile": EventHubDataFormat_W3CLOGFILE,
}

// The data format of the message. Optionally the data format can be added to each message.
type EventHubDataFormat_STATUS string

const (
	EventHubDataFormat_STATUS_APACHEAVRO = EventHubDataFormat_STATUS("APACHEAVRO")
	EventHubDataFormat_STATUS_AVRO       = EventHubDataFormat_STATUS("AVRO")
	EventHubDataFormat_STATUS_CSV        = EventHubDataFormat_STATUS("CSV")
	EventHubDataFormat_STATUS_JSON       = EventHubDataFormat_STATUS("JSON")
	EventHubDataFormat_STATUS_MULTIJSON  = EventHubDataFormat_STATUS("MULTIJSON")
	EventHubDataFormat_STATUS_ORC        = EventHubDataFormat_STATUS("ORC")
	EventHubDataFormat_STATUS_PARQUET    = EventHubDataFormat_STATUS("PARQUET")
	EventHubDataFormat_STATUS_PSV        = EventHubDataFormat_STATUS("PSV")
	EventHubDataFormat_STATUS_RAW        = EventHubDataFormat_STATUS("RAW")
	EventHubDataFormat_STATUS_SCSV       = EventHubDataFormat_STATUS("SCSV")
	EventHubDataFormat_STATUS_SINGLEJSON = EventHubDataFormat_STATUS("SINGLEJSON")
	EventHubDataFormat_STATUS_SOHSV      = EventHubDataFormat_STATUS("SOHSV")
	EventHubDataFormat_STATUS_TSV        = EventHubDataFormat_STATUS("TSV")
	EventHubDataFormat_STATUS_TSVE       = EventHubDataFormat_STATUS("TSVE")
	EventHubDataFormat_STATUS_TXT        = EventHubDataFormat_STATUS("TXT")
	EventHubDataFormat_STATUS_W3CLOGFILE = EventHubDataFormat_STATUS("W3CLOGFILE")
)

// Mapping from string to EventHubDataFormat_STATUS
var eventHubDataFormat_STATUS_Values = map[string]EventHubDataFormat_STATUS{
	"apacheavro": EventHubDataFormat_STATUS_APACHEAVRO,
	"avro":       EventHubDataFormat_STATUS_AVRO,
	"csv":        EventHubDataFormat_STATUS_CSV,
	"json":       EventHubDataFormat_STATUS_JSON,
	"multijson":  EventHubDataFormat_STATUS_MULTIJSON,
	"orc":        EventHubDataFormat_STATUS_ORC,
	"parquet":    EventHubDataFormat_STATUS_PARQUET,
	"psv":        EventHubDataFormat_STATUS_PSV,
	"raw":        EventHubDataFormat_STATUS_RAW,
	"scsv":       EventHubDataFormat_STATUS_SCSV,
	"singlejson": EventHubDataFormat_STATUS_SINGLEJSON,
	"sohsv":      EventHubDataFormat_STATUS_SOHSV,
	"tsv":        EventHubDataFormat_STATUS_TSV,
	"tsve":       EventHubDataFormat_STATUS_TSVE,
	"txt":        EventHubDataFormat_STATUS_TXT,
	"w3clogfile": EventHubDataFormat_STATUS_W3CLOGFILE,
}

// +kubebuilder:validation:Enum={"Multi","Single"}
type IotHubConnectionProperties_DatabaseRouting string

const (
	IotHubConnectionProperties_DatabaseRouting_Multi  = IotHubConnectionProperties_DatabaseRouting("Multi")
	IotHubConnectionProperties_DatabaseRouting_Single = IotHubConnectionProperties_DatabaseRouting("Single")
)

// Mapping from string to IotHubConnectionProperties_DatabaseRouting
var iotHubConnectionProperties_DatabaseRouting_Values = map[string]IotHubConnectionProperties_DatabaseRouting{
	"multi":  IotHubConnectionProperties_DatabaseRouting_Multi,
	"single": IotHubConnectionProperties_DatabaseRouting_Single,
}

type IotHubConnectionProperties_DatabaseRouting_STATUS string

const (
	IotHubConnectionProperties_DatabaseRouting_STATUS_Multi  = IotHubConnectionProperties_DatabaseRouting_STATUS("Multi")
	IotHubConnectionProperties_DatabaseRouting_STATUS_Single = IotHubConnectionProperties_DatabaseRouting_STATUS("Single")
)

// Mapping from string to IotHubConnectionProperties_DatabaseRouting_STATUS
var iotHubConnectionProperties_DatabaseRouting_STATUS_Values = map[string]IotHubConnectionProperties_DatabaseRouting_STATUS{
	"multi":  IotHubConnectionProperties_DatabaseRouting_STATUS_Multi,
	"single": IotHubConnectionProperties_DatabaseRouting_STATUS_Single,
}

// +kubebuilder:validation:Enum={"IotHub"}
type IotHubDataConnection_Kind string

const IotHubDataConnection_Kind_IotHub = IotHubDataConnection_Kind("IotHub")

// Mapping from string to IotHubDataConnection_Kind
var iotHubDataConnection_Kind_Values = map[string]IotHubDataConnection_Kind{
	"iothub": IotHubDataConnection_Kind_IotHub,
}

type IotHubDataConnection_Kind_STATUS string

const IotHubDataConnection_Kind_STATUS_IotHub = IotHubDataConnection_Kind_STATUS("IotHub")

// Mapping from string to IotHubDataConnection_Kind_STATUS
var iotHubDataConnection_Kind_STATUS_Values = map[string]IotHubDataConnection_Kind_STATUS{
	"iothub": IotHubDataConnection_Kind_STATUS_IotHub,
}

// The data format of the message. Optionally the data format can be added to each message.
// +kubebuilder:validation:Enum={"APACHEAVRO","AVRO","CSV","JSON","MULTIJSON","ORC","PARQUET","PSV","RAW","SCSV","SINGLEJSON","SOHSV","TSV","TSVE","TXT","W3CLOGFILE"}
type IotHubDataFormat string

const (
	IotHubDataFormat_APACHEAVRO = IotHubDataFormat("APACHEAVRO")
	IotHubDataFormat_AVRO       = IotHubDataFormat("AVRO")
	IotHubDataFormat_CSV        = IotHubDataFormat("CSV")
	IotHubDataFormat_JSON       = IotHubDataFormat("JSON")
	IotHubDataFormat_MULTIJSON  = IotHubDataFormat("MULTIJSON")
	IotHubDataFormat_ORC        = IotHubDataFormat("ORC")
	IotHubDataFormat_PARQUET    = IotHubDataFormat("PARQUET")
	IotHubDataFormat_PSV        = IotHubDataFormat("PSV")
	IotHubDataFormat_RAW        = IotHubDataFormat("RAW")
	IotHubDataFormat_SCSV       = IotHubDataFormat("SCSV")
	IotHubDataFormat_SINGLEJSON = IotHubDataFormat("SINGLEJSON")
	IotHubDataFormat_SOHSV      = IotHubDataFormat("SOHSV")
	IotHubDataFormat_TSV        = IotHubDataFormat("TSV")
	IotHubDataFormat_TSVE       = IotHubDataFormat("TSVE")
	IotHubDataFormat_TXT        = IotHubDataFormat("TXT")
	IotHubDataFormat_W3CLOGFILE = IotHubDataFormat("W3CLOGFILE")
)

// Mapping from string to IotHubDataFormat
var iotHubDataFormat_Values = map[string]IotHubDataFormat{
	"apacheavro": IotHubDataFormat_APACHEAVRO,
	"avro":       IotHubDataFormat_AVRO,
	"csv":        IotHubDataFormat_CSV,
	"json":       IotHubDataFormat_JSON,
	"multijson":  IotHubDataFormat_MULTIJSON,
	"orc":        IotHubDataFormat_ORC,
	"parquet":    IotHubDataFormat_PARQUET,
	"psv":        IotHubDataFormat_PSV,
	"raw":        IotHubDataFormat_RAW,
	"scsv":       IotHubDataFormat_SCSV,
	"singlejson": IotHubDataFormat_SINGLEJSON,
	"sohsv":      IotHubDataFormat_SOHSV,
	"tsv":        IotHubDataFormat_TSV,
	"tsve":       IotHubDataFormat_TSVE,
	"txt":        IotHubDataFormat_TXT,
	"w3clogfile": IotHubDataFormat_W3CLOGFILE,
}

// The data format of the message. Optionally the data format can be added to each message.
type IotHubDataFormat_STATUS string

const (
	IotHubDataFormat_STATUS_APACHEAVRO = IotHubDataFormat_STATUS("APACHEAVRO")
	IotHubDataFormat_STATUS_AVRO       = IotHubDataFormat_STATUS("AVRO")
	IotHubDataFormat_STATUS_CSV        = IotHubDataFormat_STATUS("CSV")
	IotHubDataFormat_STATUS_JSON       = IotHubDataFormat_STATUS("JSON")
	IotHubDataFormat_STATUS_MULTIJSON  = IotHubDataFormat_STATUS("MULTIJSON")
	IotHubDataFormat_STATUS_ORC        = IotHubDataFormat_STATUS("ORC")
	IotHubDataFormat_STATUS_PARQUET    = IotHubDataFormat_STATUS("PARQUET")
	IotHubDataFormat_STATUS_PSV        = IotHubDataFormat_STATUS("PSV")
	IotHubDataFormat_STATUS_RAW        = IotHubDataFormat_STATUS("RAW")
	IotHubDataFormat_STATUS_SCSV       = IotHubDataFormat_STATUS("SCSV")
	IotHubDataFormat_STATUS_SINGLEJSON = IotHubDataFormat_STATUS("SINGLEJSON")
	IotHubDataFormat_STATUS_SOHSV      = IotHubDataFormat_STATUS("SOHSV")
	IotHubDataFormat_STATUS_TSV        = IotHubDataFormat_STATUS("TSV")
	IotHubDataFormat_STATUS_TSVE       = IotHubDataFormat_STATUS("TSVE")
	IotHubDataFormat_STATUS_TXT        = IotHubDataFormat_STATUS("TXT")
	IotHubDataFormat_STATUS_W3CLOGFILE = IotHubDataFormat_STATUS("W3CLOGFILE")
)

// Mapping from string to IotHubDataFormat_STATUS
var iotHubDataFormat_STATUS_Values = map[string]IotHubDataFormat_STATUS{
	"apacheavro": IotHubDataFormat_STATUS_APACHEAVRO,
	"avro":       IotHubDataFormat_STATUS_AVRO,
	"csv":        IotHubDataFormat_STATUS_CSV,
	"json":       IotHubDataFormat_STATUS_JSON,
	"multijson":  IotHubDataFormat_STATUS_MULTIJSON,
	"orc":        IotHubDataFormat_STATUS_ORC,
	"parquet":    IotHubDataFormat_STATUS_PARQUET,
	"psv":        IotHubDataFormat_STATUS_PSV,
	"raw":        IotHubDataFormat_STATUS_RAW,
	"scsv":       IotHubDataFormat_STATUS_SCSV,
	"singlejson": IotHubDataFormat_STATUS_SINGLEJSON,
	"sohsv":      IotHubDataFormat_STATUS_SOHSV,
	"tsv":        IotHubDataFormat_STATUS_TSV,
	"tsve":       IotHubDataFormat_STATUS_TSVE,
	"txt":        IotHubDataFormat_STATUS_TXT,
	"w3clogfile": IotHubDataFormat_STATUS_W3CLOGFILE,
}

func init() {
	SchemeBuilder.Register(&DataConnection{}, &DataConnectionList{})
}
