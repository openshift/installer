// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20220301

import (
	"fmt"
	v20220301s "github.com/Azure/azure-service-operator/v2/api/web/v1api20220301/storage"
	"github.com/Azure/azure-service-operator/v2/internal/reflecthelpers"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/pkg/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
	"sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Generator information:
// - Generated from: /web/resource-manager/Microsoft.Web/stable/2022-03-01/WebApps.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}
type Site struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              Site_Spec   `json:"spec,omitempty"`
	Status            Site_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &Site{}

// GetConditions returns the conditions of the resource
func (site *Site) GetConditions() conditions.Conditions {
	return site.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (site *Site) SetConditions(conditions conditions.Conditions) {
	site.Status.Conditions = conditions
}

var _ conversion.Convertible = &Site{}

// ConvertFrom populates our Site from the provided hub Site
func (site *Site) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*v20220301s.Site)
	if !ok {
		return fmt.Errorf("expected web/v1api20220301/storage/Site but received %T instead", hub)
	}

	return site.AssignProperties_From_Site(source)
}

// ConvertTo populates the provided hub Site from our Site
func (site *Site) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*v20220301s.Site)
	if !ok {
		return fmt.Errorf("expected web/v1api20220301/storage/Site but received %T instead", hub)
	}

	return site.AssignProperties_To_Site(destination)
}

// +kubebuilder:webhook:path=/mutate-web-azure-com-v1api20220301-site,mutating=true,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=web.azure.com,resources=sites,verbs=create;update,versions=v1api20220301,name=default.v1api20220301.sites.web.azure.com,admissionReviewVersions=v1

var _ admission.Defaulter = &Site{}

// Default applies defaults to the Site resource
func (site *Site) Default() {
	site.defaultImpl()
	var temp any = site
	if runtimeDefaulter, ok := temp.(genruntime.Defaulter); ok {
		runtimeDefaulter.CustomDefault()
	}
}

// defaultAzureName defaults the Azure name of the resource to the Kubernetes name
func (site *Site) defaultAzureName() {
	if site.Spec.AzureName == "" {
		site.Spec.AzureName = site.Name
	}
}

// defaultImpl applies the code generated defaults to the Site resource
func (site *Site) defaultImpl() { site.defaultAzureName() }

var _ genruntime.ImportableResource = &Site{}

// InitializeSpec initializes the spec for this resource from the given status
func (site *Site) InitializeSpec(status genruntime.ConvertibleStatus) error {
	if s, ok := status.(*Site_STATUS); ok {
		return site.Spec.Initialize_From_Site_STATUS(s)
	}

	return fmt.Errorf("expected Status of type Site_STATUS but received %T instead", status)
}

var _ genruntime.KubernetesResource = &Site{}

// AzureName returns the Azure name of the resource
func (site *Site) AzureName() string {
	return site.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2022-03-01"
func (site Site) GetAPIVersion() string {
	return string(APIVersion_Value)
}

// GetResourceScope returns the scope of the resource
func (site *Site) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (site *Site) GetSpec() genruntime.ConvertibleSpec {
	return &site.Spec
}

// GetStatus returns the status of this resource
func (site *Site) GetStatus() genruntime.ConvertibleStatus {
	return &site.Status
}

// GetSupportedOperations returns the operations supported by the resource
func (site *Site) GetSupportedOperations() []genruntime.ResourceOperation {
	return []genruntime.ResourceOperation{
		genruntime.ResourceOperationDelete,
		genruntime.ResourceOperationGet,
		genruntime.ResourceOperationPut,
	}
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.Web/sites"
func (site *Site) GetType() string {
	return "Microsoft.Web/sites"
}

// NewEmptyStatus returns a new empty (blank) status
func (site *Site) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &Site_STATUS{}
}

// Owner returns the ResourceReference of the owner
func (site *Site) Owner() *genruntime.ResourceReference {
	group, kind := genruntime.LookupOwnerGroupKind(site.Spec)
	return site.Spec.Owner.AsResourceReference(group, kind)
}

// SetStatus sets the status of this resource
func (site *Site) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*Site_STATUS); ok {
		site.Status = *st
		return nil
	}

	// Convert status to required version
	var st Site_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return errors.Wrap(err, "failed to convert status")
	}

	site.Status = st
	return nil
}

// +kubebuilder:webhook:path=/validate-web-azure-com-v1api20220301-site,mutating=false,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=web.azure.com,resources=sites,verbs=create;update,versions=v1api20220301,name=validate.v1api20220301.sites.web.azure.com,admissionReviewVersions=v1

var _ admission.Validator = &Site{}

// ValidateCreate validates the creation of the resource
func (site *Site) ValidateCreate() (admission.Warnings, error) {
	validations := site.createValidations()
	var temp any = site
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.CreateValidations()...)
	}
	return genruntime.ValidateCreate(validations)
}

// ValidateDelete validates the deletion of the resource
func (site *Site) ValidateDelete() (admission.Warnings, error) {
	validations := site.deleteValidations()
	var temp any = site
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.DeleteValidations()...)
	}
	return genruntime.ValidateDelete(validations)
}

// ValidateUpdate validates an update of the resource
func (site *Site) ValidateUpdate(old runtime.Object) (admission.Warnings, error) {
	validations := site.updateValidations()
	var temp any = site
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.UpdateValidations()...)
	}
	return genruntime.ValidateUpdate(old, validations)
}

// createValidations validates the creation of the resource
func (site *Site) createValidations() []func() (admission.Warnings, error) {
	return []func() (admission.Warnings, error){site.validateResourceReferences, site.validateOwnerReference}
}

// deleteValidations validates the deletion of the resource
func (site *Site) deleteValidations() []func() (admission.Warnings, error) {
	return nil
}

// updateValidations validates the update of the resource
func (site *Site) updateValidations() []func(old runtime.Object) (admission.Warnings, error) {
	return []func(old runtime.Object) (admission.Warnings, error){
		func(old runtime.Object) (admission.Warnings, error) {
			return site.validateResourceReferences()
		},
		site.validateWriteOnceProperties,
		func(old runtime.Object) (admission.Warnings, error) {
			return site.validateOwnerReference()
		},
	}
}

// validateOwnerReference validates the owner field
func (site *Site) validateOwnerReference() (admission.Warnings, error) {
	return genruntime.ValidateOwner(site)
}

// validateResourceReferences validates all resource references
func (site *Site) validateResourceReferences() (admission.Warnings, error) {
	refs, err := reflecthelpers.FindResourceReferences(&site.Spec)
	if err != nil {
		return nil, err
	}
	return genruntime.ValidateResourceReferences(refs)
}

// validateWriteOnceProperties validates all WriteOnce properties
func (site *Site) validateWriteOnceProperties(old runtime.Object) (admission.Warnings, error) {
	oldObj, ok := old.(*Site)
	if !ok {
		return nil, nil
	}

	return genruntime.ValidateWriteOnceProperties(oldObj, site)
}

// AssignProperties_From_Site populates our Site from the provided source Site
func (site *Site) AssignProperties_From_Site(source *v20220301s.Site) error {

	// ObjectMeta
	site.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec Site_Spec
	err := spec.AssignProperties_From_Site_Spec(&source.Spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_Site_Spec() to populate field Spec")
	}
	site.Spec = spec

	// Status
	var status Site_STATUS
	err = status.AssignProperties_From_Site_STATUS(&source.Status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_Site_STATUS() to populate field Status")
	}
	site.Status = status

	// No error
	return nil
}

// AssignProperties_To_Site populates the provided destination Site from our Site
func (site *Site) AssignProperties_To_Site(destination *v20220301s.Site) error {

	// ObjectMeta
	destination.ObjectMeta = *site.ObjectMeta.DeepCopy()

	// Spec
	var spec v20220301s.Site_Spec
	err := site.Spec.AssignProperties_To_Site_Spec(&spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_Site_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status v20220301s.Site_STATUS
	err = site.Status.AssignProperties_To_Site_STATUS(&status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_Site_STATUS() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (site *Site) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: site.Spec.OriginalVersion(),
		Kind:    "Site",
	}
}

// +kubebuilder:object:root=true
// Generator information:
// - Generated from: /web/resource-manager/Microsoft.Web/stable/2022-03-01/WebApps.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}
type SiteList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Site `json:"items"`
}

type Site_Spec struct {
	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName string `json:"azureName,omitempty"`

	// ClientAffinityEnabled: <code>true</code> to enable client affinity; <code>false</code> to stop sending session affinity
	// cookies, which route client requests in the same session to the same instance. Default is <code>true</code>.
	ClientAffinityEnabled *bool `json:"clientAffinityEnabled,omitempty"`

	// ClientCertEnabled: <code>true</code> to enable client certificate authentication (TLS mutual authentication); otherwise,
	// <code>false</code>. Default is <code>false</code>.
	ClientCertEnabled *bool `json:"clientCertEnabled,omitempty"`

	// ClientCertExclusionPaths: client certificate authentication comma-separated exclusion paths
	ClientCertExclusionPaths *string `json:"clientCertExclusionPaths,omitempty"`

	// ClientCertMode: This composes with ClientCertEnabled setting.
	// - ClientCertEnabled: false means ClientCert is ignored.
	// - ClientCertEnabled: true and ClientCertMode: Required means ClientCert is required.
	// - ClientCertEnabled: true and ClientCertMode: Optional means ClientCert is optional or accepted.
	ClientCertMode *Site_Properties_ClientCertMode_Spec `json:"clientCertMode,omitempty"`

	// CloningInfo: If specified during app creation, the app is cloned from a source app.
	CloningInfo *CloningInfo `json:"cloningInfo,omitempty"`

	// ContainerSize: Size of the function container.
	ContainerSize *int `json:"containerSize,omitempty"`

	// CustomDomainVerificationId: Unique identifier that verifies the custom domains assigned to the app. Customer will add
	// this id to a txt record for verification.
	CustomDomainVerificationId *string `json:"customDomainVerificationId,omitempty"`

	// DailyMemoryTimeQuota: Maximum allowed daily memory-time quota (applicable on dynamic apps only).
	DailyMemoryTimeQuota *int `json:"dailyMemoryTimeQuota,omitempty"`

	// Enabled: <code>true</code> if the app is enabled; otherwise, <code>false</code>. Setting this value to false disables
	// the app (takes the app offline).
	Enabled *bool `json:"enabled,omitempty"`

	// ExtendedLocation: Extended Location.
	ExtendedLocation *ExtendedLocation `json:"extendedLocation,omitempty"`

	// HostNameSslStates: Hostname SSL states are used to manage the SSL bindings for app's hostnames.
	HostNameSslStates []HostNameSslState `json:"hostNameSslStates,omitempty"`

	// HostNamesDisabled: <code>true</code> to disable the public hostnames of the app; otherwise, <code>false</code>.
	// If <code>true</code>, the app is only accessible via API management process.
	HostNamesDisabled *bool `json:"hostNamesDisabled,omitempty"`

	// HostingEnvironmentProfile: App Service Environment to use for the app.
	HostingEnvironmentProfile *HostingEnvironmentProfile `json:"hostingEnvironmentProfile,omitempty"`

	// HttpsOnly: HttpsOnly: configures a web site to accept only https requests. Issues redirect for
	// http requests
	HttpsOnly *bool `json:"httpsOnly,omitempty"`

	// HyperV: Hyper-V sandbox.
	HyperV *bool `json:"hyperV,omitempty"`

	// Identity: Managed service identity.
	Identity *ManagedServiceIdentity `json:"identity,omitempty"`

	// IsXenon: Obsolete: Hyper-V sandbox.
	IsXenon *bool `json:"isXenon,omitempty"`

	// KeyVaultReferenceIdentity: Identity to use for Key Vault Reference authentication.
	KeyVaultReferenceIdentity *string `json:"keyVaultReferenceIdentity,omitempty"`

	// Kind: Kind of resource.
	Kind *string `json:"kind,omitempty"`

	// +kubebuilder:validation:Required
	// Location: Resource Location.
	Location *string `json:"location,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a resources.azure.com/ResourceGroup resource
	Owner *genruntime.KnownResourceReference `group:"resources.azure.com" json:"owner,omitempty" kind:"ResourceGroup"`

	// PublicNetworkAccess: Property to allow or block all public traffic. Allowed Values: 'Enabled', 'Disabled' or an empty
	// string.
	PublicNetworkAccess *string `json:"publicNetworkAccess,omitempty"`

	// RedundancyMode: Site redundancy mode
	RedundancyMode *Site_Properties_RedundancyMode_Spec `json:"redundancyMode,omitempty"`

	// Reserved: <code>true</code> if reserved; otherwise, <code>false</code>.
	Reserved *bool `json:"reserved,omitempty"`

	// ScmSiteAlsoStopped: <code>true</code> to stop SCM (KUDU) site when the app is stopped; otherwise, <code>false</code>.
	// The default is <code>false</code>.
	ScmSiteAlsoStopped *bool `json:"scmSiteAlsoStopped,omitempty"`

	// ServerFarmReference: Resource ID of the associated App Service plan, formatted as:
	// "/subscriptions/{subscriptionID}/resourceGroups/{groupName}/providers/Microsoft.Web/serverfarms/{appServicePlanName}".
	ServerFarmReference *genruntime.ResourceReference `armReference:"ServerFarmId" json:"serverFarmReference,omitempty"`

	// SiteConfig: Configuration of the app.
	SiteConfig *SiteConfig `json:"siteConfig,omitempty"`

	// StorageAccountRequired: Checks if Customer provided storage account is required
	StorageAccountRequired *bool `json:"storageAccountRequired,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`

	// VirtualNetworkSubnetReference: Azure Resource Manager ID of the Virtual network and subnet to be joined by Regional VNET
	// Integration.
	// This must be of the form
	// /subscriptions/{subscriptionName}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{vnetName}/subnets/{subnetName}
	VirtualNetworkSubnetReference *genruntime.ResourceReference `armReference:"VirtualNetworkSubnetId" json:"virtualNetworkSubnetReference,omitempty"`

	// VnetContentShareEnabled: To enable accessing content over virtual network
	VnetContentShareEnabled *bool `json:"vnetContentShareEnabled,omitempty"`

	// VnetImagePullEnabled: To enable pulling image over Virtual Network
	VnetImagePullEnabled *bool `json:"vnetImagePullEnabled,omitempty"`

	// VnetRouteAllEnabled: Virtual Network Route All enabled. This causes all outbound traffic to have Virtual Network
	// Security Groups and User Defined Routes applied.
	VnetRouteAllEnabled *bool `json:"vnetRouteAllEnabled,omitempty"`
}

var _ genruntime.ARMTransformer = &Site_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (site *Site_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if site == nil {
		return nil, nil
	}
	result := &Site_Spec_ARM{}

	// Set property "ExtendedLocation":
	if site.ExtendedLocation != nil {
		extendedLocation_ARM, err := (*site.ExtendedLocation).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		extendedLocation := *extendedLocation_ARM.(*ExtendedLocation_ARM)
		result.ExtendedLocation = &extendedLocation
	}

	// Set property "Identity":
	if site.Identity != nil {
		identity_ARM, err := (*site.Identity).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		identity := *identity_ARM.(*ManagedServiceIdentity_ARM)
		result.Identity = &identity
	}

	// Set property "Kind":
	if site.Kind != nil {
		kind := *site.Kind
		result.Kind = &kind
	}

	// Set property "Location":
	if site.Location != nil {
		location := *site.Location
		result.Location = &location
	}

	// Set property "Name":
	result.Name = resolved.Name

	// Set property "Properties":
	if site.ClientAffinityEnabled != nil ||
		site.ClientCertEnabled != nil ||
		site.ClientCertExclusionPaths != nil ||
		site.ClientCertMode != nil ||
		site.CloningInfo != nil ||
		site.ContainerSize != nil ||
		site.CustomDomainVerificationId != nil ||
		site.DailyMemoryTimeQuota != nil ||
		site.Enabled != nil ||
		site.HostNameSslStates != nil ||
		site.HostNamesDisabled != nil ||
		site.HostingEnvironmentProfile != nil ||
		site.HttpsOnly != nil ||
		site.HyperV != nil ||
		site.IsXenon != nil ||
		site.KeyVaultReferenceIdentity != nil ||
		site.PublicNetworkAccess != nil ||
		site.RedundancyMode != nil ||
		site.Reserved != nil ||
		site.ScmSiteAlsoStopped != nil ||
		site.ServerFarmReference != nil ||
		site.SiteConfig != nil ||
		site.StorageAccountRequired != nil ||
		site.VirtualNetworkSubnetReference != nil ||
		site.VnetContentShareEnabled != nil ||
		site.VnetImagePullEnabled != nil ||
		site.VnetRouteAllEnabled != nil {
		result.Properties = &Site_Properties_Spec_ARM{}
	}
	if site.ClientAffinityEnabled != nil {
		clientAffinityEnabled := *site.ClientAffinityEnabled
		result.Properties.ClientAffinityEnabled = &clientAffinityEnabled
	}
	if site.ClientCertEnabled != nil {
		clientCertEnabled := *site.ClientCertEnabled
		result.Properties.ClientCertEnabled = &clientCertEnabled
	}
	if site.ClientCertExclusionPaths != nil {
		clientCertExclusionPaths := *site.ClientCertExclusionPaths
		result.Properties.ClientCertExclusionPaths = &clientCertExclusionPaths
	}
	if site.ClientCertMode != nil {
		clientCertMode := *site.ClientCertMode
		result.Properties.ClientCertMode = &clientCertMode
	}
	if site.CloningInfo != nil {
		cloningInfo_ARM, err := (*site.CloningInfo).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		cloningInfo := *cloningInfo_ARM.(*CloningInfo_ARM)
		result.Properties.CloningInfo = &cloningInfo
	}
	if site.ContainerSize != nil {
		containerSize := *site.ContainerSize
		result.Properties.ContainerSize = &containerSize
	}
	if site.CustomDomainVerificationId != nil {
		customDomainVerificationId := *site.CustomDomainVerificationId
		result.Properties.CustomDomainVerificationId = &customDomainVerificationId
	}
	if site.DailyMemoryTimeQuota != nil {
		dailyMemoryTimeQuota := *site.DailyMemoryTimeQuota
		result.Properties.DailyMemoryTimeQuota = &dailyMemoryTimeQuota
	}
	if site.Enabled != nil {
		enabled := *site.Enabled
		result.Properties.Enabled = &enabled
	}
	for _, item := range site.HostNameSslStates {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.HostNameSslStates = append(result.Properties.HostNameSslStates, *item_ARM.(*HostNameSslState_ARM))
	}
	if site.HostNamesDisabled != nil {
		hostNamesDisabled := *site.HostNamesDisabled
		result.Properties.HostNamesDisabled = &hostNamesDisabled
	}
	if site.HostingEnvironmentProfile != nil {
		hostingEnvironmentProfile_ARM, err := (*site.HostingEnvironmentProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		hostingEnvironmentProfile := *hostingEnvironmentProfile_ARM.(*HostingEnvironmentProfile_ARM)
		result.Properties.HostingEnvironmentProfile = &hostingEnvironmentProfile
	}
	if site.HttpsOnly != nil {
		httpsOnly := *site.HttpsOnly
		result.Properties.HttpsOnly = &httpsOnly
	}
	if site.HyperV != nil {
		hyperV := *site.HyperV
		result.Properties.HyperV = &hyperV
	}
	if site.IsXenon != nil {
		isXenon := *site.IsXenon
		result.Properties.IsXenon = &isXenon
	}
	if site.KeyVaultReferenceIdentity != nil {
		keyVaultReferenceIdentity := *site.KeyVaultReferenceIdentity
		result.Properties.KeyVaultReferenceIdentity = &keyVaultReferenceIdentity
	}
	if site.PublicNetworkAccess != nil {
		publicNetworkAccess := *site.PublicNetworkAccess
		result.Properties.PublicNetworkAccess = &publicNetworkAccess
	}
	if site.RedundancyMode != nil {
		redundancyMode := *site.RedundancyMode
		result.Properties.RedundancyMode = &redundancyMode
	}
	if site.Reserved != nil {
		reserved := *site.Reserved
		result.Properties.Reserved = &reserved
	}
	if site.ScmSiteAlsoStopped != nil {
		scmSiteAlsoStopped := *site.ScmSiteAlsoStopped
		result.Properties.ScmSiteAlsoStopped = &scmSiteAlsoStopped
	}
	if site.ServerFarmReference != nil {
		serverFarmIdARMID, err := resolved.ResolvedReferences.Lookup(*site.ServerFarmReference)
		if err != nil {
			return nil, err
		}
		serverFarmId := serverFarmIdARMID
		result.Properties.ServerFarmId = &serverFarmId
	}
	if site.SiteConfig != nil {
		siteConfig_ARM, err := (*site.SiteConfig).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		siteConfig := *siteConfig_ARM.(*SiteConfig_ARM)
		result.Properties.SiteConfig = &siteConfig
	}
	if site.StorageAccountRequired != nil {
		storageAccountRequired := *site.StorageAccountRequired
		result.Properties.StorageAccountRequired = &storageAccountRequired
	}
	if site.VirtualNetworkSubnetReference != nil {
		virtualNetworkSubnetIdARMID, err := resolved.ResolvedReferences.Lookup(*site.VirtualNetworkSubnetReference)
		if err != nil {
			return nil, err
		}
		virtualNetworkSubnetId := virtualNetworkSubnetIdARMID
		result.Properties.VirtualNetworkSubnetId = &virtualNetworkSubnetId
	}
	if site.VnetContentShareEnabled != nil {
		vnetContentShareEnabled := *site.VnetContentShareEnabled
		result.Properties.VnetContentShareEnabled = &vnetContentShareEnabled
	}
	if site.VnetImagePullEnabled != nil {
		vnetImagePullEnabled := *site.VnetImagePullEnabled
		result.Properties.VnetImagePullEnabled = &vnetImagePullEnabled
	}
	if site.VnetRouteAllEnabled != nil {
		vnetRouteAllEnabled := *site.VnetRouteAllEnabled
		result.Properties.VnetRouteAllEnabled = &vnetRouteAllEnabled
	}

	// Set property "Tags":
	if site.Tags != nil {
		result.Tags = make(map[string]string, len(site.Tags))
		for key, value := range site.Tags {
			result.Tags[key] = value
		}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (site *Site_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Site_Spec_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (site *Site_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Site_Spec_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Site_Spec_ARM, got %T", armInput)
	}

	// Set property "AzureName":
	site.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property "ClientAffinityEnabled":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ClientAffinityEnabled != nil {
			clientAffinityEnabled := *typedInput.Properties.ClientAffinityEnabled
			site.ClientAffinityEnabled = &clientAffinityEnabled
		}
	}

	// Set property "ClientCertEnabled":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ClientCertEnabled != nil {
			clientCertEnabled := *typedInput.Properties.ClientCertEnabled
			site.ClientCertEnabled = &clientCertEnabled
		}
	}

	// Set property "ClientCertExclusionPaths":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ClientCertExclusionPaths != nil {
			clientCertExclusionPaths := *typedInput.Properties.ClientCertExclusionPaths
			site.ClientCertExclusionPaths = &clientCertExclusionPaths
		}
	}

	// Set property "ClientCertMode":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ClientCertMode != nil {
			clientCertMode := *typedInput.Properties.ClientCertMode
			site.ClientCertMode = &clientCertMode
		}
	}

	// Set property "CloningInfo":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.CloningInfo != nil {
			var cloningInfo1 CloningInfo
			err := cloningInfo1.PopulateFromARM(owner, *typedInput.Properties.CloningInfo)
			if err != nil {
				return err
			}
			cloningInfo := cloningInfo1
			site.CloningInfo = &cloningInfo
		}
	}

	// Set property "ContainerSize":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ContainerSize != nil {
			containerSize := *typedInput.Properties.ContainerSize
			site.ContainerSize = &containerSize
		}
	}

	// Set property "CustomDomainVerificationId":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.CustomDomainVerificationId != nil {
			customDomainVerificationId := *typedInput.Properties.CustomDomainVerificationId
			site.CustomDomainVerificationId = &customDomainVerificationId
		}
	}

	// Set property "DailyMemoryTimeQuota":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DailyMemoryTimeQuota != nil {
			dailyMemoryTimeQuota := *typedInput.Properties.DailyMemoryTimeQuota
			site.DailyMemoryTimeQuota = &dailyMemoryTimeQuota
		}
	}

	// Set property "Enabled":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Enabled != nil {
			enabled := *typedInput.Properties.Enabled
			site.Enabled = &enabled
		}
	}

	// Set property "ExtendedLocation":
	if typedInput.ExtendedLocation != nil {
		var extendedLocation1 ExtendedLocation
		err := extendedLocation1.PopulateFromARM(owner, *typedInput.ExtendedLocation)
		if err != nil {
			return err
		}
		extendedLocation := extendedLocation1
		site.ExtendedLocation = &extendedLocation
	}

	// Set property "HostNameSslStates":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.HostNameSslStates {
			var item1 HostNameSslState
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			site.HostNameSslStates = append(site.HostNameSslStates, item1)
		}
	}

	// Set property "HostNamesDisabled":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HostNamesDisabled != nil {
			hostNamesDisabled := *typedInput.Properties.HostNamesDisabled
			site.HostNamesDisabled = &hostNamesDisabled
		}
	}

	// Set property "HostingEnvironmentProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HostingEnvironmentProfile != nil {
			var hostingEnvironmentProfile1 HostingEnvironmentProfile
			err := hostingEnvironmentProfile1.PopulateFromARM(owner, *typedInput.Properties.HostingEnvironmentProfile)
			if err != nil {
				return err
			}
			hostingEnvironmentProfile := hostingEnvironmentProfile1
			site.HostingEnvironmentProfile = &hostingEnvironmentProfile
		}
	}

	// Set property "HttpsOnly":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HttpsOnly != nil {
			httpsOnly := *typedInput.Properties.HttpsOnly
			site.HttpsOnly = &httpsOnly
		}
	}

	// Set property "HyperV":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HyperV != nil {
			hyperV := *typedInput.Properties.HyperV
			site.HyperV = &hyperV
		}
	}

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 ManagedServiceIdentity
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		site.Identity = &identity
	}

	// Set property "IsXenon":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IsXenon != nil {
			isXenon := *typedInput.Properties.IsXenon
			site.IsXenon = &isXenon
		}
	}

	// Set property "KeyVaultReferenceIdentity":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.KeyVaultReferenceIdentity != nil {
			keyVaultReferenceIdentity := *typedInput.Properties.KeyVaultReferenceIdentity
			site.KeyVaultReferenceIdentity = &keyVaultReferenceIdentity
		}
	}

	// Set property "Kind":
	if typedInput.Kind != nil {
		kind := *typedInput.Kind
		site.Kind = &kind
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		site.Location = &location
	}

	// Set property "Owner":
	site.Owner = &genruntime.KnownResourceReference{
		Name:  owner.Name,
		ARMID: owner.ARMID,
	}

	// Set property "PublicNetworkAccess":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicNetworkAccess != nil {
			publicNetworkAccess := *typedInput.Properties.PublicNetworkAccess
			site.PublicNetworkAccess = &publicNetworkAccess
		}
	}

	// Set property "RedundancyMode":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.RedundancyMode != nil {
			redundancyMode := *typedInput.Properties.RedundancyMode
			site.RedundancyMode = &redundancyMode
		}
	}

	// Set property "Reserved":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Reserved != nil {
			reserved := *typedInput.Properties.Reserved
			site.Reserved = &reserved
		}
	}

	// Set property "ScmSiteAlsoStopped":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ScmSiteAlsoStopped != nil {
			scmSiteAlsoStopped := *typedInput.Properties.ScmSiteAlsoStopped
			site.ScmSiteAlsoStopped = &scmSiteAlsoStopped
		}
	}

	// no assignment for property "ServerFarmReference"

	// Set property "SiteConfig":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.SiteConfig != nil {
			var siteConfig1 SiteConfig
			err := siteConfig1.PopulateFromARM(owner, *typedInput.Properties.SiteConfig)
			if err != nil {
				return err
			}
			siteConfig := siteConfig1
			site.SiteConfig = &siteConfig
		}
	}

	// Set property "StorageAccountRequired":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.StorageAccountRequired != nil {
			storageAccountRequired := *typedInput.Properties.StorageAccountRequired
			site.StorageAccountRequired = &storageAccountRequired
		}
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		site.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			site.Tags[key] = value
		}
	}

	// no assignment for property "VirtualNetworkSubnetReference"

	// Set property "VnetContentShareEnabled":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.VnetContentShareEnabled != nil {
			vnetContentShareEnabled := *typedInput.Properties.VnetContentShareEnabled
			site.VnetContentShareEnabled = &vnetContentShareEnabled
		}
	}

	// Set property "VnetImagePullEnabled":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.VnetImagePullEnabled != nil {
			vnetImagePullEnabled := *typedInput.Properties.VnetImagePullEnabled
			site.VnetImagePullEnabled = &vnetImagePullEnabled
		}
	}

	// Set property "VnetRouteAllEnabled":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.VnetRouteAllEnabled != nil {
			vnetRouteAllEnabled := *typedInput.Properties.VnetRouteAllEnabled
			site.VnetRouteAllEnabled = &vnetRouteAllEnabled
		}
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &Site_Spec{}

// ConvertSpecFrom populates our Site_Spec from the provided source
func (site *Site_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*v20220301s.Site_Spec)
	if ok {
		// Populate our instance from source
		return site.AssignProperties_From_Site_Spec(src)
	}

	// Convert to an intermediate form
	src = &v20220301s.Site_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = site.AssignProperties_From_Site_Spec(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our Site_Spec
func (site *Site_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*v20220301s.Site_Spec)
	if ok {
		// Populate destination from our instance
		return site.AssignProperties_To_Site_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &v20220301s.Site_Spec{}
	err := site.AssignProperties_To_Site_Spec(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignProperties_From_Site_Spec populates our Site_Spec from the provided source Site_Spec
func (site *Site_Spec) AssignProperties_From_Site_Spec(source *v20220301s.Site_Spec) error {

	// AzureName
	site.AzureName = source.AzureName

	// ClientAffinityEnabled
	if source.ClientAffinityEnabled != nil {
		clientAffinityEnabled := *source.ClientAffinityEnabled
		site.ClientAffinityEnabled = &clientAffinityEnabled
	} else {
		site.ClientAffinityEnabled = nil
	}

	// ClientCertEnabled
	if source.ClientCertEnabled != nil {
		clientCertEnabled := *source.ClientCertEnabled
		site.ClientCertEnabled = &clientCertEnabled
	} else {
		site.ClientCertEnabled = nil
	}

	// ClientCertExclusionPaths
	site.ClientCertExclusionPaths = genruntime.ClonePointerToString(source.ClientCertExclusionPaths)

	// ClientCertMode
	if source.ClientCertMode != nil {
		clientCertMode := Site_Properties_ClientCertMode_Spec(*source.ClientCertMode)
		site.ClientCertMode = &clientCertMode
	} else {
		site.ClientCertMode = nil
	}

	// CloningInfo
	if source.CloningInfo != nil {
		var cloningInfo CloningInfo
		err := cloningInfo.AssignProperties_From_CloningInfo(source.CloningInfo)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_CloningInfo() to populate field CloningInfo")
		}
		site.CloningInfo = &cloningInfo
	} else {
		site.CloningInfo = nil
	}

	// ContainerSize
	site.ContainerSize = genruntime.ClonePointerToInt(source.ContainerSize)

	// CustomDomainVerificationId
	site.CustomDomainVerificationId = genruntime.ClonePointerToString(source.CustomDomainVerificationId)

	// DailyMemoryTimeQuota
	site.DailyMemoryTimeQuota = genruntime.ClonePointerToInt(source.DailyMemoryTimeQuota)

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		site.Enabled = &enabled
	} else {
		site.Enabled = nil
	}

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocation ExtendedLocation
		err := extendedLocation.AssignProperties_From_ExtendedLocation(source.ExtendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ExtendedLocation() to populate field ExtendedLocation")
		}
		site.ExtendedLocation = &extendedLocation
	} else {
		site.ExtendedLocation = nil
	}

	// HostNameSslStates
	if source.HostNameSslStates != nil {
		hostNameSslStateList := make([]HostNameSslState, len(source.HostNameSslStates))
		for hostNameSslStateIndex, hostNameSslStateItem := range source.HostNameSslStates {
			// Shadow the loop variable to avoid aliasing
			hostNameSslStateItem := hostNameSslStateItem
			var hostNameSslState HostNameSslState
			err := hostNameSslState.AssignProperties_From_HostNameSslState(&hostNameSslStateItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_HostNameSslState() to populate field HostNameSslStates")
			}
			hostNameSslStateList[hostNameSslStateIndex] = hostNameSslState
		}
		site.HostNameSslStates = hostNameSslStateList
	} else {
		site.HostNameSslStates = nil
	}

	// HostNamesDisabled
	if source.HostNamesDisabled != nil {
		hostNamesDisabled := *source.HostNamesDisabled
		site.HostNamesDisabled = &hostNamesDisabled
	} else {
		site.HostNamesDisabled = nil
	}

	// HostingEnvironmentProfile
	if source.HostingEnvironmentProfile != nil {
		var hostingEnvironmentProfile HostingEnvironmentProfile
		err := hostingEnvironmentProfile.AssignProperties_From_HostingEnvironmentProfile(source.HostingEnvironmentProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_HostingEnvironmentProfile() to populate field HostingEnvironmentProfile")
		}
		site.HostingEnvironmentProfile = &hostingEnvironmentProfile
	} else {
		site.HostingEnvironmentProfile = nil
	}

	// HttpsOnly
	if source.HttpsOnly != nil {
		httpsOnly := *source.HttpsOnly
		site.HttpsOnly = &httpsOnly
	} else {
		site.HttpsOnly = nil
	}

	// HyperV
	if source.HyperV != nil {
		hyperV := *source.HyperV
		site.HyperV = &hyperV
	} else {
		site.HyperV = nil
	}

	// Identity
	if source.Identity != nil {
		var identity ManagedServiceIdentity
		err := identity.AssignProperties_From_ManagedServiceIdentity(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedServiceIdentity() to populate field Identity")
		}
		site.Identity = &identity
	} else {
		site.Identity = nil
	}

	// IsXenon
	if source.IsXenon != nil {
		isXenon := *source.IsXenon
		site.IsXenon = &isXenon
	} else {
		site.IsXenon = nil
	}

	// KeyVaultReferenceIdentity
	site.KeyVaultReferenceIdentity = genruntime.ClonePointerToString(source.KeyVaultReferenceIdentity)

	// Kind
	site.Kind = genruntime.ClonePointerToString(source.Kind)

	// Location
	site.Location = genruntime.ClonePointerToString(source.Location)

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		site.Owner = &owner
	} else {
		site.Owner = nil
	}

	// PublicNetworkAccess
	site.PublicNetworkAccess = genruntime.ClonePointerToString(source.PublicNetworkAccess)

	// RedundancyMode
	if source.RedundancyMode != nil {
		redundancyMode := Site_Properties_RedundancyMode_Spec(*source.RedundancyMode)
		site.RedundancyMode = &redundancyMode
	} else {
		site.RedundancyMode = nil
	}

	// Reserved
	if source.Reserved != nil {
		reserved := *source.Reserved
		site.Reserved = &reserved
	} else {
		site.Reserved = nil
	}

	// ScmSiteAlsoStopped
	if source.ScmSiteAlsoStopped != nil {
		scmSiteAlsoStopped := *source.ScmSiteAlsoStopped
		site.ScmSiteAlsoStopped = &scmSiteAlsoStopped
	} else {
		site.ScmSiteAlsoStopped = nil
	}

	// ServerFarmReference
	if source.ServerFarmReference != nil {
		serverFarmReference := source.ServerFarmReference.Copy()
		site.ServerFarmReference = &serverFarmReference
	} else {
		site.ServerFarmReference = nil
	}

	// SiteConfig
	if source.SiteConfig != nil {
		var siteConfig SiteConfig
		err := siteConfig.AssignProperties_From_SiteConfig(source.SiteConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SiteConfig() to populate field SiteConfig")
		}
		site.SiteConfig = &siteConfig
	} else {
		site.SiteConfig = nil
	}

	// StorageAccountRequired
	if source.StorageAccountRequired != nil {
		storageAccountRequired := *source.StorageAccountRequired
		site.StorageAccountRequired = &storageAccountRequired
	} else {
		site.StorageAccountRequired = nil
	}

	// Tags
	site.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// VirtualNetworkSubnetReference
	if source.VirtualNetworkSubnetReference != nil {
		virtualNetworkSubnetReference := source.VirtualNetworkSubnetReference.Copy()
		site.VirtualNetworkSubnetReference = &virtualNetworkSubnetReference
	} else {
		site.VirtualNetworkSubnetReference = nil
	}

	// VnetContentShareEnabled
	if source.VnetContentShareEnabled != nil {
		vnetContentShareEnabled := *source.VnetContentShareEnabled
		site.VnetContentShareEnabled = &vnetContentShareEnabled
	} else {
		site.VnetContentShareEnabled = nil
	}

	// VnetImagePullEnabled
	if source.VnetImagePullEnabled != nil {
		vnetImagePullEnabled := *source.VnetImagePullEnabled
		site.VnetImagePullEnabled = &vnetImagePullEnabled
	} else {
		site.VnetImagePullEnabled = nil
	}

	// VnetRouteAllEnabled
	if source.VnetRouteAllEnabled != nil {
		vnetRouteAllEnabled := *source.VnetRouteAllEnabled
		site.VnetRouteAllEnabled = &vnetRouteAllEnabled
	} else {
		site.VnetRouteAllEnabled = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Site_Spec populates the provided destination Site_Spec from our Site_Spec
func (site *Site_Spec) AssignProperties_To_Site_Spec(destination *v20220301s.Site_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureName
	destination.AzureName = site.AzureName

	// ClientAffinityEnabled
	if site.ClientAffinityEnabled != nil {
		clientAffinityEnabled := *site.ClientAffinityEnabled
		destination.ClientAffinityEnabled = &clientAffinityEnabled
	} else {
		destination.ClientAffinityEnabled = nil
	}

	// ClientCertEnabled
	if site.ClientCertEnabled != nil {
		clientCertEnabled := *site.ClientCertEnabled
		destination.ClientCertEnabled = &clientCertEnabled
	} else {
		destination.ClientCertEnabled = nil
	}

	// ClientCertExclusionPaths
	destination.ClientCertExclusionPaths = genruntime.ClonePointerToString(site.ClientCertExclusionPaths)

	// ClientCertMode
	if site.ClientCertMode != nil {
		clientCertMode := string(*site.ClientCertMode)
		destination.ClientCertMode = &clientCertMode
	} else {
		destination.ClientCertMode = nil
	}

	// CloningInfo
	if site.CloningInfo != nil {
		var cloningInfo v20220301s.CloningInfo
		err := site.CloningInfo.AssignProperties_To_CloningInfo(&cloningInfo)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_CloningInfo() to populate field CloningInfo")
		}
		destination.CloningInfo = &cloningInfo
	} else {
		destination.CloningInfo = nil
	}

	// ContainerSize
	destination.ContainerSize = genruntime.ClonePointerToInt(site.ContainerSize)

	// CustomDomainVerificationId
	destination.CustomDomainVerificationId = genruntime.ClonePointerToString(site.CustomDomainVerificationId)

	// DailyMemoryTimeQuota
	destination.DailyMemoryTimeQuota = genruntime.ClonePointerToInt(site.DailyMemoryTimeQuota)

	// Enabled
	if site.Enabled != nil {
		enabled := *site.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// ExtendedLocation
	if site.ExtendedLocation != nil {
		var extendedLocation v20220301s.ExtendedLocation
		err := site.ExtendedLocation.AssignProperties_To_ExtendedLocation(&extendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ExtendedLocation() to populate field ExtendedLocation")
		}
		destination.ExtendedLocation = &extendedLocation
	} else {
		destination.ExtendedLocation = nil
	}

	// HostNameSslStates
	if site.HostNameSslStates != nil {
		hostNameSslStateList := make([]v20220301s.HostNameSslState, len(site.HostNameSslStates))
		for hostNameSslStateIndex, hostNameSslStateItem := range site.HostNameSslStates {
			// Shadow the loop variable to avoid aliasing
			hostNameSslStateItem := hostNameSslStateItem
			var hostNameSslState v20220301s.HostNameSslState
			err := hostNameSslStateItem.AssignProperties_To_HostNameSslState(&hostNameSslState)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_HostNameSslState() to populate field HostNameSslStates")
			}
			hostNameSslStateList[hostNameSslStateIndex] = hostNameSslState
		}
		destination.HostNameSslStates = hostNameSslStateList
	} else {
		destination.HostNameSslStates = nil
	}

	// HostNamesDisabled
	if site.HostNamesDisabled != nil {
		hostNamesDisabled := *site.HostNamesDisabled
		destination.HostNamesDisabled = &hostNamesDisabled
	} else {
		destination.HostNamesDisabled = nil
	}

	// HostingEnvironmentProfile
	if site.HostingEnvironmentProfile != nil {
		var hostingEnvironmentProfile v20220301s.HostingEnvironmentProfile
		err := site.HostingEnvironmentProfile.AssignProperties_To_HostingEnvironmentProfile(&hostingEnvironmentProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_HostingEnvironmentProfile() to populate field HostingEnvironmentProfile")
		}
		destination.HostingEnvironmentProfile = &hostingEnvironmentProfile
	} else {
		destination.HostingEnvironmentProfile = nil
	}

	// HttpsOnly
	if site.HttpsOnly != nil {
		httpsOnly := *site.HttpsOnly
		destination.HttpsOnly = &httpsOnly
	} else {
		destination.HttpsOnly = nil
	}

	// HyperV
	if site.HyperV != nil {
		hyperV := *site.HyperV
		destination.HyperV = &hyperV
	} else {
		destination.HyperV = nil
	}

	// Identity
	if site.Identity != nil {
		var identity v20220301s.ManagedServiceIdentity
		err := site.Identity.AssignProperties_To_ManagedServiceIdentity(&identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedServiceIdentity() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// IsXenon
	if site.IsXenon != nil {
		isXenon := *site.IsXenon
		destination.IsXenon = &isXenon
	} else {
		destination.IsXenon = nil
	}

	// KeyVaultReferenceIdentity
	destination.KeyVaultReferenceIdentity = genruntime.ClonePointerToString(site.KeyVaultReferenceIdentity)

	// Kind
	destination.Kind = genruntime.ClonePointerToString(site.Kind)

	// Location
	destination.Location = genruntime.ClonePointerToString(site.Location)

	// OriginalVersion
	destination.OriginalVersion = site.OriginalVersion()

	// Owner
	if site.Owner != nil {
		owner := site.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// PublicNetworkAccess
	destination.PublicNetworkAccess = genruntime.ClonePointerToString(site.PublicNetworkAccess)

	// RedundancyMode
	if site.RedundancyMode != nil {
		redundancyMode := string(*site.RedundancyMode)
		destination.RedundancyMode = &redundancyMode
	} else {
		destination.RedundancyMode = nil
	}

	// Reserved
	if site.Reserved != nil {
		reserved := *site.Reserved
		destination.Reserved = &reserved
	} else {
		destination.Reserved = nil
	}

	// ScmSiteAlsoStopped
	if site.ScmSiteAlsoStopped != nil {
		scmSiteAlsoStopped := *site.ScmSiteAlsoStopped
		destination.ScmSiteAlsoStopped = &scmSiteAlsoStopped
	} else {
		destination.ScmSiteAlsoStopped = nil
	}

	// ServerFarmReference
	if site.ServerFarmReference != nil {
		serverFarmReference := site.ServerFarmReference.Copy()
		destination.ServerFarmReference = &serverFarmReference
	} else {
		destination.ServerFarmReference = nil
	}

	// SiteConfig
	if site.SiteConfig != nil {
		var siteConfig v20220301s.SiteConfig
		err := site.SiteConfig.AssignProperties_To_SiteConfig(&siteConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SiteConfig() to populate field SiteConfig")
		}
		destination.SiteConfig = &siteConfig
	} else {
		destination.SiteConfig = nil
	}

	// StorageAccountRequired
	if site.StorageAccountRequired != nil {
		storageAccountRequired := *site.StorageAccountRequired
		destination.StorageAccountRequired = &storageAccountRequired
	} else {
		destination.StorageAccountRequired = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(site.Tags)

	// VirtualNetworkSubnetReference
	if site.VirtualNetworkSubnetReference != nil {
		virtualNetworkSubnetReference := site.VirtualNetworkSubnetReference.Copy()
		destination.VirtualNetworkSubnetReference = &virtualNetworkSubnetReference
	} else {
		destination.VirtualNetworkSubnetReference = nil
	}

	// VnetContentShareEnabled
	if site.VnetContentShareEnabled != nil {
		vnetContentShareEnabled := *site.VnetContentShareEnabled
		destination.VnetContentShareEnabled = &vnetContentShareEnabled
	} else {
		destination.VnetContentShareEnabled = nil
	}

	// VnetImagePullEnabled
	if site.VnetImagePullEnabled != nil {
		vnetImagePullEnabled := *site.VnetImagePullEnabled
		destination.VnetImagePullEnabled = &vnetImagePullEnabled
	} else {
		destination.VnetImagePullEnabled = nil
	}

	// VnetRouteAllEnabled
	if site.VnetRouteAllEnabled != nil {
		vnetRouteAllEnabled := *site.VnetRouteAllEnabled
		destination.VnetRouteAllEnabled = &vnetRouteAllEnabled
	} else {
		destination.VnetRouteAllEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_Site_STATUS populates our Site_Spec from the provided source Site_STATUS
func (site *Site_Spec) Initialize_From_Site_STATUS(source *Site_STATUS) error {

	// ClientAffinityEnabled
	if source.ClientAffinityEnabled != nil {
		clientAffinityEnabled := *source.ClientAffinityEnabled
		site.ClientAffinityEnabled = &clientAffinityEnabled
	} else {
		site.ClientAffinityEnabled = nil
	}

	// ClientCertEnabled
	if source.ClientCertEnabled != nil {
		clientCertEnabled := *source.ClientCertEnabled
		site.ClientCertEnabled = &clientCertEnabled
	} else {
		site.ClientCertEnabled = nil
	}

	// ClientCertExclusionPaths
	site.ClientCertExclusionPaths = genruntime.ClonePointerToString(source.ClientCertExclusionPaths)

	// ClientCertMode
	if source.ClientCertMode != nil {
		clientCertMode := Site_Properties_ClientCertMode_Spec(*source.ClientCertMode)
		site.ClientCertMode = &clientCertMode
	} else {
		site.ClientCertMode = nil
	}

	// CloningInfo
	if source.CloningInfo != nil {
		var cloningInfo CloningInfo
		err := cloningInfo.Initialize_From_CloningInfo_STATUS(source.CloningInfo)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_CloningInfo_STATUS() to populate field CloningInfo")
		}
		site.CloningInfo = &cloningInfo
	} else {
		site.CloningInfo = nil
	}

	// ContainerSize
	site.ContainerSize = genruntime.ClonePointerToInt(source.ContainerSize)

	// CustomDomainVerificationId
	site.CustomDomainVerificationId = genruntime.ClonePointerToString(source.CustomDomainVerificationId)

	// DailyMemoryTimeQuota
	site.DailyMemoryTimeQuota = genruntime.ClonePointerToInt(source.DailyMemoryTimeQuota)

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		site.Enabled = &enabled
	} else {
		site.Enabled = nil
	}

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocation ExtendedLocation
		err := extendedLocation.Initialize_From_ExtendedLocation_STATUS(source.ExtendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_ExtendedLocation_STATUS() to populate field ExtendedLocation")
		}
		site.ExtendedLocation = &extendedLocation
	} else {
		site.ExtendedLocation = nil
	}

	// HostNameSslStates
	if source.HostNameSslStates != nil {
		hostNameSslStateList := make([]HostNameSslState, len(source.HostNameSslStates))
		for hostNameSslStateIndex, hostNameSslStateItem := range source.HostNameSslStates {
			// Shadow the loop variable to avoid aliasing
			hostNameSslStateItem := hostNameSslStateItem
			var hostNameSslState HostNameSslState
			err := hostNameSslState.Initialize_From_HostNameSslState_STATUS(&hostNameSslStateItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_HostNameSslState_STATUS() to populate field HostNameSslStates")
			}
			hostNameSslStateList[hostNameSslStateIndex] = hostNameSslState
		}
		site.HostNameSslStates = hostNameSslStateList
	} else {
		site.HostNameSslStates = nil
	}

	// HostNamesDisabled
	if source.HostNamesDisabled != nil {
		hostNamesDisabled := *source.HostNamesDisabled
		site.HostNamesDisabled = &hostNamesDisabled
	} else {
		site.HostNamesDisabled = nil
	}

	// HostingEnvironmentProfile
	if source.HostingEnvironmentProfile != nil {
		var hostingEnvironmentProfile HostingEnvironmentProfile
		err := hostingEnvironmentProfile.Initialize_From_HostingEnvironmentProfile_STATUS(source.HostingEnvironmentProfile)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_HostingEnvironmentProfile_STATUS() to populate field HostingEnvironmentProfile")
		}
		site.HostingEnvironmentProfile = &hostingEnvironmentProfile
	} else {
		site.HostingEnvironmentProfile = nil
	}

	// HttpsOnly
	if source.HttpsOnly != nil {
		httpsOnly := *source.HttpsOnly
		site.HttpsOnly = &httpsOnly
	} else {
		site.HttpsOnly = nil
	}

	// HyperV
	if source.HyperV != nil {
		hyperV := *source.HyperV
		site.HyperV = &hyperV
	} else {
		site.HyperV = nil
	}

	// Identity
	if source.Identity != nil {
		var identity ManagedServiceIdentity
		err := identity.Initialize_From_ManagedServiceIdentity_STATUS(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_ManagedServiceIdentity_STATUS() to populate field Identity")
		}
		site.Identity = &identity
	} else {
		site.Identity = nil
	}

	// IsXenon
	if source.IsXenon != nil {
		isXenon := *source.IsXenon
		site.IsXenon = &isXenon
	} else {
		site.IsXenon = nil
	}

	// KeyVaultReferenceIdentity
	site.KeyVaultReferenceIdentity = genruntime.ClonePointerToString(source.KeyVaultReferenceIdentity)

	// Kind
	site.Kind = genruntime.ClonePointerToString(source.Kind)

	// Location
	site.Location = genruntime.ClonePointerToString(source.Location)

	// PublicNetworkAccess
	site.PublicNetworkAccess = genruntime.ClonePointerToString(source.PublicNetworkAccess)

	// RedundancyMode
	if source.RedundancyMode != nil {
		redundancyMode := Site_Properties_RedundancyMode_Spec(*source.RedundancyMode)
		site.RedundancyMode = &redundancyMode
	} else {
		site.RedundancyMode = nil
	}

	// Reserved
	if source.Reserved != nil {
		reserved := *source.Reserved
		site.Reserved = &reserved
	} else {
		site.Reserved = nil
	}

	// ScmSiteAlsoStopped
	if source.ScmSiteAlsoStopped != nil {
		scmSiteAlsoStopped := *source.ScmSiteAlsoStopped
		site.ScmSiteAlsoStopped = &scmSiteAlsoStopped
	} else {
		site.ScmSiteAlsoStopped = nil
	}

	// ServerFarmReference
	if source.ServerFarmId != nil {
		serverFarmReference := genruntime.CreateResourceReferenceFromARMID(*source.ServerFarmId)
		site.ServerFarmReference = &serverFarmReference
	} else {
		site.ServerFarmReference = nil
	}

	// SiteConfig
	if source.SiteConfig != nil {
		var siteConfig SiteConfig
		err := siteConfig.Initialize_From_SiteConfig_STATUS(source.SiteConfig)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_SiteConfig_STATUS() to populate field SiteConfig")
		}
		site.SiteConfig = &siteConfig
	} else {
		site.SiteConfig = nil
	}

	// StorageAccountRequired
	if source.StorageAccountRequired != nil {
		storageAccountRequired := *source.StorageAccountRequired
		site.StorageAccountRequired = &storageAccountRequired
	} else {
		site.StorageAccountRequired = nil
	}

	// Tags
	site.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// VirtualNetworkSubnetReference
	if source.VirtualNetworkSubnetId != nil {
		virtualNetworkSubnetReference := genruntime.CreateResourceReferenceFromARMID(*source.VirtualNetworkSubnetId)
		site.VirtualNetworkSubnetReference = &virtualNetworkSubnetReference
	} else {
		site.VirtualNetworkSubnetReference = nil
	}

	// VnetContentShareEnabled
	if source.VnetContentShareEnabled != nil {
		vnetContentShareEnabled := *source.VnetContentShareEnabled
		site.VnetContentShareEnabled = &vnetContentShareEnabled
	} else {
		site.VnetContentShareEnabled = nil
	}

	// VnetImagePullEnabled
	if source.VnetImagePullEnabled != nil {
		vnetImagePullEnabled := *source.VnetImagePullEnabled
		site.VnetImagePullEnabled = &vnetImagePullEnabled
	} else {
		site.VnetImagePullEnabled = nil
	}

	// VnetRouteAllEnabled
	if source.VnetRouteAllEnabled != nil {
		vnetRouteAllEnabled := *source.VnetRouteAllEnabled
		site.VnetRouteAllEnabled = &vnetRouteAllEnabled
	} else {
		site.VnetRouteAllEnabled = nil
	}

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (site *Site_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (site *Site_Spec) SetAzureName(azureName string) { site.AzureName = azureName }

// A web app, a mobile app backend, or an API app.
type Site_STATUS struct {
	// AvailabilityState: Management information availability state for the app.
	AvailabilityState *Site_Properties_AvailabilityState_STATUS `json:"availabilityState,omitempty"`

	// ClientAffinityEnabled: <code>true</code> to enable client affinity; <code>false</code> to stop sending session affinity
	// cookies, which route client requests in the same session to the same instance. Default is <code>true</code>.
	ClientAffinityEnabled *bool `json:"clientAffinityEnabled,omitempty"`

	// ClientCertEnabled: <code>true</code> to enable client certificate authentication (TLS mutual authentication); otherwise,
	// <code>false</code>. Default is <code>false</code>.
	ClientCertEnabled *bool `json:"clientCertEnabled,omitempty"`

	// ClientCertExclusionPaths: client certificate authentication comma-separated exclusion paths
	ClientCertExclusionPaths *string `json:"clientCertExclusionPaths,omitempty"`

	// ClientCertMode: This composes with ClientCertEnabled setting.
	// - ClientCertEnabled: false means ClientCert is ignored.
	// - ClientCertEnabled: true and ClientCertMode: Required means ClientCert is required.
	// - ClientCertEnabled: true and ClientCertMode: Optional means ClientCert is optional or accepted.
	ClientCertMode *Site_Properties_ClientCertMode_STATUS `json:"clientCertMode,omitempty"`

	// CloningInfo: If specified during app creation, the app is cloned from a source app.
	CloningInfo *CloningInfo_STATUS `json:"cloningInfo,omitempty"`

	// Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	// ContainerSize: Size of the function container.
	ContainerSize *int `json:"containerSize,omitempty"`

	// CustomDomainVerificationId: Unique identifier that verifies the custom domains assigned to the app. Customer will add
	// this id to a txt record for verification.
	CustomDomainVerificationId *string `json:"customDomainVerificationId,omitempty"`

	// DailyMemoryTimeQuota: Maximum allowed daily memory-time quota (applicable on dynamic apps only).
	DailyMemoryTimeQuota *int `json:"dailyMemoryTimeQuota,omitempty"`

	// DefaultHostName: Default hostname of the app. Read-only.
	DefaultHostName *string `json:"defaultHostName,omitempty"`

	// Enabled: <code>true</code> if the app is enabled; otherwise, <code>false</code>. Setting this value to false disables
	// the app (takes the app offline).
	Enabled *bool `json:"enabled,omitempty"`

	// EnabledHostNames: Enabled hostnames for the app.Hostnames need to be assigned (see HostNames) AND enabled. Otherwise,
	// the app is not served on those hostnames.
	EnabledHostNames []string `json:"enabledHostNames,omitempty"`

	// ExtendedLocation: Extended Location.
	ExtendedLocation *ExtendedLocation_STATUS `json:"extendedLocation,omitempty"`

	// HostNameSslStates: Hostname SSL states are used to manage the SSL bindings for app's hostnames.
	HostNameSslStates []HostNameSslState_STATUS `json:"hostNameSslStates,omitempty"`

	// HostNames: Hostnames associated with the app.
	HostNames []string `json:"hostNames,omitempty"`

	// HostNamesDisabled: <code>true</code> to disable the public hostnames of the app; otherwise, <code>false</code>.
	// If <code>true</code>, the app is only accessible via API management process.
	HostNamesDisabled *bool `json:"hostNamesDisabled,omitempty"`

	// HostingEnvironmentProfile: App Service Environment to use for the app.
	HostingEnvironmentProfile *HostingEnvironmentProfile_STATUS `json:"hostingEnvironmentProfile,omitempty"`

	// HttpsOnly: HttpsOnly: configures a web site to accept only https requests. Issues redirect for
	// http requests
	HttpsOnly *bool `json:"httpsOnly,omitempty"`

	// HyperV: Hyper-V sandbox.
	HyperV *bool `json:"hyperV,omitempty"`

	// Id: Resource Id.
	Id *string `json:"id,omitempty"`

	// Identity: Managed service identity.
	Identity *ManagedServiceIdentity_STATUS `json:"identity,omitempty"`

	// InProgressOperationId: Specifies an operation id if this site has a pending operation.
	InProgressOperationId *string `json:"inProgressOperationId,omitempty"`

	// IsDefaultContainer: <code>true</code> if the app is a default container; otherwise, <code>false</code>.
	IsDefaultContainer *bool `json:"isDefaultContainer,omitempty"`

	// IsXenon: Obsolete: Hyper-V sandbox.
	IsXenon *bool `json:"isXenon,omitempty"`

	// KeyVaultReferenceIdentity: Identity to use for Key Vault Reference authentication.
	KeyVaultReferenceIdentity *string `json:"keyVaultReferenceIdentity,omitempty"`

	// Kind: Kind of resource.
	Kind *string `json:"kind,omitempty"`

	// LastModifiedTimeUtc: Last time the app was modified, in UTC. Read-only.
	LastModifiedTimeUtc *string `json:"lastModifiedTimeUtc,omitempty"`

	// Location: Resource Location.
	Location *string `json:"location,omitempty"`

	// MaxNumberOfWorkers: Maximum number of workers.
	// This only applies to Functions container.
	MaxNumberOfWorkers *int `json:"maxNumberOfWorkers,omitempty"`

	// Name: Resource Name.
	Name *string `json:"name,omitempty"`

	// OutboundIpAddresses: List of IP addresses that the app uses for outbound connections (e.g. database access). Includes
	// VIPs from tenants that site can be hosted with current settings. Read-only.
	OutboundIpAddresses *string `json:"outboundIpAddresses,omitempty"`

	// PossibleOutboundIpAddresses: List of IP addresses that the app uses for outbound connections (e.g. database access).
	// Includes VIPs from all tenants except dataComponent. Read-only.
	PossibleOutboundIpAddresses *string `json:"possibleOutboundIpAddresses,omitempty"`

	// PublicNetworkAccess: Property to allow or block all public traffic. Allowed Values: 'Enabled', 'Disabled' or an empty
	// string.
	PublicNetworkAccess *string `json:"publicNetworkAccess,omitempty"`

	// RedundancyMode: Site redundancy mode
	RedundancyMode *Site_Properties_RedundancyMode_STATUS `json:"redundancyMode,omitempty"`

	// RepositorySiteName: Name of the repository site.
	RepositorySiteName *string `json:"repositorySiteName,omitempty"`

	// Reserved: <code>true</code> if reserved; otherwise, <code>false</code>.
	Reserved *bool `json:"reserved,omitempty"`

	// ResourceGroup: Name of the resource group the app belongs to. Read-only.
	ResourceGroup *string `json:"resourceGroup,omitempty"`

	// ScmSiteAlsoStopped: <code>true</code> to stop SCM (KUDU) site when the app is stopped; otherwise, <code>false</code>.
	// The default is <code>false</code>.
	ScmSiteAlsoStopped *bool `json:"scmSiteAlsoStopped,omitempty"`

	// ServerFarmId: Resource ID of the associated App Service plan, formatted as:
	// "/subscriptions/{subscriptionID}/resourceGroups/{groupName}/providers/Microsoft.Web/serverfarms/{appServicePlanName}".
	ServerFarmId *string `json:"serverFarmId,omitempty"`

	// SiteConfig: Configuration of the app.
	SiteConfig *SiteConfig_STATUS `json:"siteConfig,omitempty"`

	// SlotSwapStatus: Status of the last deployment slot swap operation.
	SlotSwapStatus *SlotSwapStatus_STATUS `json:"slotSwapStatus,omitempty"`

	// State: Current state of the app.
	State *string `json:"state,omitempty"`

	// StorageAccountRequired: Checks if Customer provided storage account is required
	StorageAccountRequired *bool `json:"storageAccountRequired,omitempty"`

	// SuspendedTill: App suspended till in case memory-time quota is exceeded.
	SuspendedTill *string `json:"suspendedTill,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`

	// TargetSwapSlot: Specifies which deployment slot this app will swap into. Read-only.
	TargetSwapSlot *string `json:"targetSwapSlot,omitempty"`

	// TrafficManagerHostNames: Azure Traffic Manager hostnames associated with the app. Read-only.
	TrafficManagerHostNames []string `json:"trafficManagerHostNames,omitempty"`

	// Type: Resource type.
	Type *string `json:"type,omitempty"`

	// UsageState: State indicating whether the app has exceeded its quota usage. Read-only.
	UsageState *Site_Properties_UsageState_STATUS `json:"usageState,omitempty"`

	// VirtualNetworkSubnetId: Azure Resource Manager ID of the Virtual network and subnet to be joined by Regional VNET
	// Integration.
	// This must be of the form
	// /subscriptions/{subscriptionName}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{vnetName}/subnets/{subnetName}
	VirtualNetworkSubnetId *string `json:"virtualNetworkSubnetId,omitempty"`

	// VnetContentShareEnabled: To enable accessing content over virtual network
	VnetContentShareEnabled *bool `json:"vnetContentShareEnabled,omitempty"`

	// VnetImagePullEnabled: To enable pulling image over Virtual Network
	VnetImagePullEnabled *bool `json:"vnetImagePullEnabled,omitempty"`

	// VnetRouteAllEnabled: Virtual Network Route All enabled. This causes all outbound traffic to have Virtual Network
	// Security Groups and User Defined Routes applied.
	VnetRouteAllEnabled *bool `json:"vnetRouteAllEnabled,omitempty"`
}

var _ genruntime.ConvertibleStatus = &Site_STATUS{}

// ConvertStatusFrom populates our Site_STATUS from the provided source
func (site *Site_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*v20220301s.Site_STATUS)
	if ok {
		// Populate our instance from source
		return site.AssignProperties_From_Site_STATUS(src)
	}

	// Convert to an intermediate form
	src = &v20220301s.Site_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = site.AssignProperties_From_Site_STATUS(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our Site_STATUS
func (site *Site_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*v20220301s.Site_STATUS)
	if ok {
		// Populate destination from our instance
		return site.AssignProperties_To_Site_STATUS(dst)
	}

	// Convert to an intermediate form
	dst = &v20220301s.Site_STATUS{}
	err := site.AssignProperties_To_Site_STATUS(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &Site_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (site *Site_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Site_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (site *Site_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Site_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Site_STATUS_ARM, got %T", armInput)
	}

	// Set property "AvailabilityState":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AvailabilityState != nil {
			availabilityState := *typedInput.Properties.AvailabilityState
			site.AvailabilityState = &availabilityState
		}
	}

	// Set property "ClientAffinityEnabled":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ClientAffinityEnabled != nil {
			clientAffinityEnabled := *typedInput.Properties.ClientAffinityEnabled
			site.ClientAffinityEnabled = &clientAffinityEnabled
		}
	}

	// Set property "ClientCertEnabled":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ClientCertEnabled != nil {
			clientCertEnabled := *typedInput.Properties.ClientCertEnabled
			site.ClientCertEnabled = &clientCertEnabled
		}
	}

	// Set property "ClientCertExclusionPaths":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ClientCertExclusionPaths != nil {
			clientCertExclusionPaths := *typedInput.Properties.ClientCertExclusionPaths
			site.ClientCertExclusionPaths = &clientCertExclusionPaths
		}
	}

	// Set property "ClientCertMode":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ClientCertMode != nil {
			clientCertMode := *typedInput.Properties.ClientCertMode
			site.ClientCertMode = &clientCertMode
		}
	}

	// Set property "CloningInfo":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.CloningInfo != nil {
			var cloningInfo1 CloningInfo_STATUS
			err := cloningInfo1.PopulateFromARM(owner, *typedInput.Properties.CloningInfo)
			if err != nil {
				return err
			}
			cloningInfo := cloningInfo1
			site.CloningInfo = &cloningInfo
		}
	}

	// no assignment for property "Conditions"

	// Set property "ContainerSize":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ContainerSize != nil {
			containerSize := *typedInput.Properties.ContainerSize
			site.ContainerSize = &containerSize
		}
	}

	// Set property "CustomDomainVerificationId":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.CustomDomainVerificationId != nil {
			customDomainVerificationId := *typedInput.Properties.CustomDomainVerificationId
			site.CustomDomainVerificationId = &customDomainVerificationId
		}
	}

	// Set property "DailyMemoryTimeQuota":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DailyMemoryTimeQuota != nil {
			dailyMemoryTimeQuota := *typedInput.Properties.DailyMemoryTimeQuota
			site.DailyMemoryTimeQuota = &dailyMemoryTimeQuota
		}
	}

	// Set property "DefaultHostName":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DefaultHostName != nil {
			defaultHostName := *typedInput.Properties.DefaultHostName
			site.DefaultHostName = &defaultHostName
		}
	}

	// Set property "Enabled":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Enabled != nil {
			enabled := *typedInput.Properties.Enabled
			site.Enabled = &enabled
		}
	}

	// Set property "EnabledHostNames":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.EnabledHostNames {
			site.EnabledHostNames = append(site.EnabledHostNames, item)
		}
	}

	// Set property "ExtendedLocation":
	if typedInput.ExtendedLocation != nil {
		var extendedLocation1 ExtendedLocation_STATUS
		err := extendedLocation1.PopulateFromARM(owner, *typedInput.ExtendedLocation)
		if err != nil {
			return err
		}
		extendedLocation := extendedLocation1
		site.ExtendedLocation = &extendedLocation
	}

	// Set property "HostNameSslStates":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.HostNameSslStates {
			var item1 HostNameSslState_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			site.HostNameSslStates = append(site.HostNameSslStates, item1)
		}
	}

	// Set property "HostNames":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.HostNames {
			site.HostNames = append(site.HostNames, item)
		}
	}

	// Set property "HostNamesDisabled":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HostNamesDisabled != nil {
			hostNamesDisabled := *typedInput.Properties.HostNamesDisabled
			site.HostNamesDisabled = &hostNamesDisabled
		}
	}

	// Set property "HostingEnvironmentProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HostingEnvironmentProfile != nil {
			var hostingEnvironmentProfile1 HostingEnvironmentProfile_STATUS
			err := hostingEnvironmentProfile1.PopulateFromARM(owner, *typedInput.Properties.HostingEnvironmentProfile)
			if err != nil {
				return err
			}
			hostingEnvironmentProfile := hostingEnvironmentProfile1
			site.HostingEnvironmentProfile = &hostingEnvironmentProfile
		}
	}

	// Set property "HttpsOnly":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HttpsOnly != nil {
			httpsOnly := *typedInput.Properties.HttpsOnly
			site.HttpsOnly = &httpsOnly
		}
	}

	// Set property "HyperV":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HyperV != nil {
			hyperV := *typedInput.Properties.HyperV
			site.HyperV = &hyperV
		}
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		site.Id = &id
	}

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 ManagedServiceIdentity_STATUS
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		site.Identity = &identity
	}

	// Set property "InProgressOperationId":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.InProgressOperationId != nil {
			inProgressOperationId := *typedInput.Properties.InProgressOperationId
			site.InProgressOperationId = &inProgressOperationId
		}
	}

	// Set property "IsDefaultContainer":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IsDefaultContainer != nil {
			isDefaultContainer := *typedInput.Properties.IsDefaultContainer
			site.IsDefaultContainer = &isDefaultContainer
		}
	}

	// Set property "IsXenon":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IsXenon != nil {
			isXenon := *typedInput.Properties.IsXenon
			site.IsXenon = &isXenon
		}
	}

	// Set property "KeyVaultReferenceIdentity":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.KeyVaultReferenceIdentity != nil {
			keyVaultReferenceIdentity := *typedInput.Properties.KeyVaultReferenceIdentity
			site.KeyVaultReferenceIdentity = &keyVaultReferenceIdentity
		}
	}

	// Set property "Kind":
	if typedInput.Kind != nil {
		kind := *typedInput.Kind
		site.Kind = &kind
	}

	// Set property "LastModifiedTimeUtc":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.LastModifiedTimeUtc != nil {
			lastModifiedTimeUtc := *typedInput.Properties.LastModifiedTimeUtc
			site.LastModifiedTimeUtc = &lastModifiedTimeUtc
		}
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		site.Location = &location
	}

	// Set property "MaxNumberOfWorkers":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MaxNumberOfWorkers != nil {
			maxNumberOfWorkers := *typedInput.Properties.MaxNumberOfWorkers
			site.MaxNumberOfWorkers = &maxNumberOfWorkers
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		site.Name = &name
	}

	// Set property "OutboundIpAddresses":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.OutboundIpAddresses != nil {
			outboundIpAddresses := *typedInput.Properties.OutboundIpAddresses
			site.OutboundIpAddresses = &outboundIpAddresses
		}
	}

	// Set property "PossibleOutboundIpAddresses":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PossibleOutboundIpAddresses != nil {
			possibleOutboundIpAddresses := *typedInput.Properties.PossibleOutboundIpAddresses
			site.PossibleOutboundIpAddresses = &possibleOutboundIpAddresses
		}
	}

	// Set property "PublicNetworkAccess":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicNetworkAccess != nil {
			publicNetworkAccess := *typedInput.Properties.PublicNetworkAccess
			site.PublicNetworkAccess = &publicNetworkAccess
		}
	}

	// Set property "RedundancyMode":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.RedundancyMode != nil {
			redundancyMode := *typedInput.Properties.RedundancyMode
			site.RedundancyMode = &redundancyMode
		}
	}

	// Set property "RepositorySiteName":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.RepositorySiteName != nil {
			repositorySiteName := *typedInput.Properties.RepositorySiteName
			site.RepositorySiteName = &repositorySiteName
		}
	}

	// Set property "Reserved":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Reserved != nil {
			reserved := *typedInput.Properties.Reserved
			site.Reserved = &reserved
		}
	}

	// Set property "ResourceGroup":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ResourceGroup != nil {
			resourceGroup := *typedInput.Properties.ResourceGroup
			site.ResourceGroup = &resourceGroup
		}
	}

	// Set property "ScmSiteAlsoStopped":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ScmSiteAlsoStopped != nil {
			scmSiteAlsoStopped := *typedInput.Properties.ScmSiteAlsoStopped
			site.ScmSiteAlsoStopped = &scmSiteAlsoStopped
		}
	}

	// Set property "ServerFarmId":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ServerFarmId != nil {
			serverFarmId := *typedInput.Properties.ServerFarmId
			site.ServerFarmId = &serverFarmId
		}
	}

	// Set property "SiteConfig":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.SiteConfig != nil {
			var siteConfig1 SiteConfig_STATUS
			err := siteConfig1.PopulateFromARM(owner, *typedInput.Properties.SiteConfig)
			if err != nil {
				return err
			}
			siteConfig := siteConfig1
			site.SiteConfig = &siteConfig
		}
	}

	// Set property "SlotSwapStatus":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.SlotSwapStatus != nil {
			var slotSwapStatus1 SlotSwapStatus_STATUS
			err := slotSwapStatus1.PopulateFromARM(owner, *typedInput.Properties.SlotSwapStatus)
			if err != nil {
				return err
			}
			slotSwapStatus := slotSwapStatus1
			site.SlotSwapStatus = &slotSwapStatus
		}
	}

	// Set property "State":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.State != nil {
			state := *typedInput.Properties.State
			site.State = &state
		}
	}

	// Set property "StorageAccountRequired":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.StorageAccountRequired != nil {
			storageAccountRequired := *typedInput.Properties.StorageAccountRequired
			site.StorageAccountRequired = &storageAccountRequired
		}
	}

	// Set property "SuspendedTill":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.SuspendedTill != nil {
			suspendedTill := *typedInput.Properties.SuspendedTill
			site.SuspendedTill = &suspendedTill
		}
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		site.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			site.Tags[key] = value
		}
	}

	// Set property "TargetSwapSlot":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.TargetSwapSlot != nil {
			targetSwapSlot := *typedInput.Properties.TargetSwapSlot
			site.TargetSwapSlot = &targetSwapSlot
		}
	}

	// Set property "TrafficManagerHostNames":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.TrafficManagerHostNames {
			site.TrafficManagerHostNames = append(site.TrafficManagerHostNames, item)
		}
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		site.Type = &typeVar
	}

	// Set property "UsageState":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.UsageState != nil {
			usageState := *typedInput.Properties.UsageState
			site.UsageState = &usageState
		}
	}

	// Set property "VirtualNetworkSubnetId":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.VirtualNetworkSubnetId != nil {
			virtualNetworkSubnetId := *typedInput.Properties.VirtualNetworkSubnetId
			site.VirtualNetworkSubnetId = &virtualNetworkSubnetId
		}
	}

	// Set property "VnetContentShareEnabled":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.VnetContentShareEnabled != nil {
			vnetContentShareEnabled := *typedInput.Properties.VnetContentShareEnabled
			site.VnetContentShareEnabled = &vnetContentShareEnabled
		}
	}

	// Set property "VnetImagePullEnabled":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.VnetImagePullEnabled != nil {
			vnetImagePullEnabled := *typedInput.Properties.VnetImagePullEnabled
			site.VnetImagePullEnabled = &vnetImagePullEnabled
		}
	}

	// Set property "VnetRouteAllEnabled":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.VnetRouteAllEnabled != nil {
			vnetRouteAllEnabled := *typedInput.Properties.VnetRouteAllEnabled
			site.VnetRouteAllEnabled = &vnetRouteAllEnabled
		}
	}

	// No error
	return nil
}

// AssignProperties_From_Site_STATUS populates our Site_STATUS from the provided source Site_STATUS
func (site *Site_STATUS) AssignProperties_From_Site_STATUS(source *v20220301s.Site_STATUS) error {

	// AvailabilityState
	if source.AvailabilityState != nil {
		availabilityState := Site_Properties_AvailabilityState_STATUS(*source.AvailabilityState)
		site.AvailabilityState = &availabilityState
	} else {
		site.AvailabilityState = nil
	}

	// ClientAffinityEnabled
	if source.ClientAffinityEnabled != nil {
		clientAffinityEnabled := *source.ClientAffinityEnabled
		site.ClientAffinityEnabled = &clientAffinityEnabled
	} else {
		site.ClientAffinityEnabled = nil
	}

	// ClientCertEnabled
	if source.ClientCertEnabled != nil {
		clientCertEnabled := *source.ClientCertEnabled
		site.ClientCertEnabled = &clientCertEnabled
	} else {
		site.ClientCertEnabled = nil
	}

	// ClientCertExclusionPaths
	site.ClientCertExclusionPaths = genruntime.ClonePointerToString(source.ClientCertExclusionPaths)

	// ClientCertMode
	if source.ClientCertMode != nil {
		clientCertMode := Site_Properties_ClientCertMode_STATUS(*source.ClientCertMode)
		site.ClientCertMode = &clientCertMode
	} else {
		site.ClientCertMode = nil
	}

	// CloningInfo
	if source.CloningInfo != nil {
		var cloningInfo CloningInfo_STATUS
		err := cloningInfo.AssignProperties_From_CloningInfo_STATUS(source.CloningInfo)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_CloningInfo_STATUS() to populate field CloningInfo")
		}
		site.CloningInfo = &cloningInfo
	} else {
		site.CloningInfo = nil
	}

	// Conditions
	site.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// ContainerSize
	site.ContainerSize = genruntime.ClonePointerToInt(source.ContainerSize)

	// CustomDomainVerificationId
	site.CustomDomainVerificationId = genruntime.ClonePointerToString(source.CustomDomainVerificationId)

	// DailyMemoryTimeQuota
	site.DailyMemoryTimeQuota = genruntime.ClonePointerToInt(source.DailyMemoryTimeQuota)

	// DefaultHostName
	site.DefaultHostName = genruntime.ClonePointerToString(source.DefaultHostName)

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		site.Enabled = &enabled
	} else {
		site.Enabled = nil
	}

	// EnabledHostNames
	site.EnabledHostNames = genruntime.CloneSliceOfString(source.EnabledHostNames)

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocation ExtendedLocation_STATUS
		err := extendedLocation.AssignProperties_From_ExtendedLocation_STATUS(source.ExtendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ExtendedLocation_STATUS() to populate field ExtendedLocation")
		}
		site.ExtendedLocation = &extendedLocation
	} else {
		site.ExtendedLocation = nil
	}

	// HostNameSslStates
	if source.HostNameSslStates != nil {
		hostNameSslStateList := make([]HostNameSslState_STATUS, len(source.HostNameSslStates))
		for hostNameSslStateIndex, hostNameSslStateItem := range source.HostNameSslStates {
			// Shadow the loop variable to avoid aliasing
			hostNameSslStateItem := hostNameSslStateItem
			var hostNameSslState HostNameSslState_STATUS
			err := hostNameSslState.AssignProperties_From_HostNameSslState_STATUS(&hostNameSslStateItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_HostNameSslState_STATUS() to populate field HostNameSslStates")
			}
			hostNameSslStateList[hostNameSslStateIndex] = hostNameSslState
		}
		site.HostNameSslStates = hostNameSslStateList
	} else {
		site.HostNameSslStates = nil
	}

	// HostNames
	site.HostNames = genruntime.CloneSliceOfString(source.HostNames)

	// HostNamesDisabled
	if source.HostNamesDisabled != nil {
		hostNamesDisabled := *source.HostNamesDisabled
		site.HostNamesDisabled = &hostNamesDisabled
	} else {
		site.HostNamesDisabled = nil
	}

	// HostingEnvironmentProfile
	if source.HostingEnvironmentProfile != nil {
		var hostingEnvironmentProfile HostingEnvironmentProfile_STATUS
		err := hostingEnvironmentProfile.AssignProperties_From_HostingEnvironmentProfile_STATUS(source.HostingEnvironmentProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_HostingEnvironmentProfile_STATUS() to populate field HostingEnvironmentProfile")
		}
		site.HostingEnvironmentProfile = &hostingEnvironmentProfile
	} else {
		site.HostingEnvironmentProfile = nil
	}

	// HttpsOnly
	if source.HttpsOnly != nil {
		httpsOnly := *source.HttpsOnly
		site.HttpsOnly = &httpsOnly
	} else {
		site.HttpsOnly = nil
	}

	// HyperV
	if source.HyperV != nil {
		hyperV := *source.HyperV
		site.HyperV = &hyperV
	} else {
		site.HyperV = nil
	}

	// Id
	site.Id = genruntime.ClonePointerToString(source.Id)

	// Identity
	if source.Identity != nil {
		var identity ManagedServiceIdentity_STATUS
		err := identity.AssignProperties_From_ManagedServiceIdentity_STATUS(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedServiceIdentity_STATUS() to populate field Identity")
		}
		site.Identity = &identity
	} else {
		site.Identity = nil
	}

	// InProgressOperationId
	site.InProgressOperationId = genruntime.ClonePointerToString(source.InProgressOperationId)

	// IsDefaultContainer
	if source.IsDefaultContainer != nil {
		isDefaultContainer := *source.IsDefaultContainer
		site.IsDefaultContainer = &isDefaultContainer
	} else {
		site.IsDefaultContainer = nil
	}

	// IsXenon
	if source.IsXenon != nil {
		isXenon := *source.IsXenon
		site.IsXenon = &isXenon
	} else {
		site.IsXenon = nil
	}

	// KeyVaultReferenceIdentity
	site.KeyVaultReferenceIdentity = genruntime.ClonePointerToString(source.KeyVaultReferenceIdentity)

	// Kind
	site.Kind = genruntime.ClonePointerToString(source.Kind)

	// LastModifiedTimeUtc
	site.LastModifiedTimeUtc = genruntime.ClonePointerToString(source.LastModifiedTimeUtc)

	// Location
	site.Location = genruntime.ClonePointerToString(source.Location)

	// MaxNumberOfWorkers
	site.MaxNumberOfWorkers = genruntime.ClonePointerToInt(source.MaxNumberOfWorkers)

	// Name
	site.Name = genruntime.ClonePointerToString(source.Name)

	// OutboundIpAddresses
	site.OutboundIpAddresses = genruntime.ClonePointerToString(source.OutboundIpAddresses)

	// PossibleOutboundIpAddresses
	site.PossibleOutboundIpAddresses = genruntime.ClonePointerToString(source.PossibleOutboundIpAddresses)

	// PublicNetworkAccess
	site.PublicNetworkAccess = genruntime.ClonePointerToString(source.PublicNetworkAccess)

	// RedundancyMode
	if source.RedundancyMode != nil {
		redundancyMode := Site_Properties_RedundancyMode_STATUS(*source.RedundancyMode)
		site.RedundancyMode = &redundancyMode
	} else {
		site.RedundancyMode = nil
	}

	// RepositorySiteName
	site.RepositorySiteName = genruntime.ClonePointerToString(source.RepositorySiteName)

	// Reserved
	if source.Reserved != nil {
		reserved := *source.Reserved
		site.Reserved = &reserved
	} else {
		site.Reserved = nil
	}

	// ResourceGroup
	site.ResourceGroup = genruntime.ClonePointerToString(source.ResourceGroup)

	// ScmSiteAlsoStopped
	if source.ScmSiteAlsoStopped != nil {
		scmSiteAlsoStopped := *source.ScmSiteAlsoStopped
		site.ScmSiteAlsoStopped = &scmSiteAlsoStopped
	} else {
		site.ScmSiteAlsoStopped = nil
	}

	// ServerFarmId
	site.ServerFarmId = genruntime.ClonePointerToString(source.ServerFarmId)

	// SiteConfig
	if source.SiteConfig != nil {
		var siteConfig SiteConfig_STATUS
		err := siteConfig.AssignProperties_From_SiteConfig_STATUS(source.SiteConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SiteConfig_STATUS() to populate field SiteConfig")
		}
		site.SiteConfig = &siteConfig
	} else {
		site.SiteConfig = nil
	}

	// SlotSwapStatus
	if source.SlotSwapStatus != nil {
		var slotSwapStatus SlotSwapStatus_STATUS
		err := slotSwapStatus.AssignProperties_From_SlotSwapStatus_STATUS(source.SlotSwapStatus)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SlotSwapStatus_STATUS() to populate field SlotSwapStatus")
		}
		site.SlotSwapStatus = &slotSwapStatus
	} else {
		site.SlotSwapStatus = nil
	}

	// State
	site.State = genruntime.ClonePointerToString(source.State)

	// StorageAccountRequired
	if source.StorageAccountRequired != nil {
		storageAccountRequired := *source.StorageAccountRequired
		site.StorageAccountRequired = &storageAccountRequired
	} else {
		site.StorageAccountRequired = nil
	}

	// SuspendedTill
	site.SuspendedTill = genruntime.ClonePointerToString(source.SuspendedTill)

	// Tags
	site.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// TargetSwapSlot
	site.TargetSwapSlot = genruntime.ClonePointerToString(source.TargetSwapSlot)

	// TrafficManagerHostNames
	site.TrafficManagerHostNames = genruntime.CloneSliceOfString(source.TrafficManagerHostNames)

	// Type
	site.Type = genruntime.ClonePointerToString(source.Type)

	// UsageState
	if source.UsageState != nil {
		usageState := Site_Properties_UsageState_STATUS(*source.UsageState)
		site.UsageState = &usageState
	} else {
		site.UsageState = nil
	}

	// VirtualNetworkSubnetId
	site.VirtualNetworkSubnetId = genruntime.ClonePointerToString(source.VirtualNetworkSubnetId)

	// VnetContentShareEnabled
	if source.VnetContentShareEnabled != nil {
		vnetContentShareEnabled := *source.VnetContentShareEnabled
		site.VnetContentShareEnabled = &vnetContentShareEnabled
	} else {
		site.VnetContentShareEnabled = nil
	}

	// VnetImagePullEnabled
	if source.VnetImagePullEnabled != nil {
		vnetImagePullEnabled := *source.VnetImagePullEnabled
		site.VnetImagePullEnabled = &vnetImagePullEnabled
	} else {
		site.VnetImagePullEnabled = nil
	}

	// VnetRouteAllEnabled
	if source.VnetRouteAllEnabled != nil {
		vnetRouteAllEnabled := *source.VnetRouteAllEnabled
		site.VnetRouteAllEnabled = &vnetRouteAllEnabled
	} else {
		site.VnetRouteAllEnabled = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Site_STATUS populates the provided destination Site_STATUS from our Site_STATUS
func (site *Site_STATUS) AssignProperties_To_Site_STATUS(destination *v20220301s.Site_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AvailabilityState
	if site.AvailabilityState != nil {
		availabilityState := string(*site.AvailabilityState)
		destination.AvailabilityState = &availabilityState
	} else {
		destination.AvailabilityState = nil
	}

	// ClientAffinityEnabled
	if site.ClientAffinityEnabled != nil {
		clientAffinityEnabled := *site.ClientAffinityEnabled
		destination.ClientAffinityEnabled = &clientAffinityEnabled
	} else {
		destination.ClientAffinityEnabled = nil
	}

	// ClientCertEnabled
	if site.ClientCertEnabled != nil {
		clientCertEnabled := *site.ClientCertEnabled
		destination.ClientCertEnabled = &clientCertEnabled
	} else {
		destination.ClientCertEnabled = nil
	}

	// ClientCertExclusionPaths
	destination.ClientCertExclusionPaths = genruntime.ClonePointerToString(site.ClientCertExclusionPaths)

	// ClientCertMode
	if site.ClientCertMode != nil {
		clientCertMode := string(*site.ClientCertMode)
		destination.ClientCertMode = &clientCertMode
	} else {
		destination.ClientCertMode = nil
	}

	// CloningInfo
	if site.CloningInfo != nil {
		var cloningInfo v20220301s.CloningInfo_STATUS
		err := site.CloningInfo.AssignProperties_To_CloningInfo_STATUS(&cloningInfo)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_CloningInfo_STATUS() to populate field CloningInfo")
		}
		destination.CloningInfo = &cloningInfo
	} else {
		destination.CloningInfo = nil
	}

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(site.Conditions)

	// ContainerSize
	destination.ContainerSize = genruntime.ClonePointerToInt(site.ContainerSize)

	// CustomDomainVerificationId
	destination.CustomDomainVerificationId = genruntime.ClonePointerToString(site.CustomDomainVerificationId)

	// DailyMemoryTimeQuota
	destination.DailyMemoryTimeQuota = genruntime.ClonePointerToInt(site.DailyMemoryTimeQuota)

	// DefaultHostName
	destination.DefaultHostName = genruntime.ClonePointerToString(site.DefaultHostName)

	// Enabled
	if site.Enabled != nil {
		enabled := *site.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// EnabledHostNames
	destination.EnabledHostNames = genruntime.CloneSliceOfString(site.EnabledHostNames)

	// ExtendedLocation
	if site.ExtendedLocation != nil {
		var extendedLocation v20220301s.ExtendedLocation_STATUS
		err := site.ExtendedLocation.AssignProperties_To_ExtendedLocation_STATUS(&extendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ExtendedLocation_STATUS() to populate field ExtendedLocation")
		}
		destination.ExtendedLocation = &extendedLocation
	} else {
		destination.ExtendedLocation = nil
	}

	// HostNameSslStates
	if site.HostNameSslStates != nil {
		hostNameSslStateList := make([]v20220301s.HostNameSslState_STATUS, len(site.HostNameSslStates))
		for hostNameSslStateIndex, hostNameSslStateItem := range site.HostNameSslStates {
			// Shadow the loop variable to avoid aliasing
			hostNameSslStateItem := hostNameSslStateItem
			var hostNameSslState v20220301s.HostNameSslState_STATUS
			err := hostNameSslStateItem.AssignProperties_To_HostNameSslState_STATUS(&hostNameSslState)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_HostNameSslState_STATUS() to populate field HostNameSslStates")
			}
			hostNameSslStateList[hostNameSslStateIndex] = hostNameSslState
		}
		destination.HostNameSslStates = hostNameSslStateList
	} else {
		destination.HostNameSslStates = nil
	}

	// HostNames
	destination.HostNames = genruntime.CloneSliceOfString(site.HostNames)

	// HostNamesDisabled
	if site.HostNamesDisabled != nil {
		hostNamesDisabled := *site.HostNamesDisabled
		destination.HostNamesDisabled = &hostNamesDisabled
	} else {
		destination.HostNamesDisabled = nil
	}

	// HostingEnvironmentProfile
	if site.HostingEnvironmentProfile != nil {
		var hostingEnvironmentProfile v20220301s.HostingEnvironmentProfile_STATUS
		err := site.HostingEnvironmentProfile.AssignProperties_To_HostingEnvironmentProfile_STATUS(&hostingEnvironmentProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_HostingEnvironmentProfile_STATUS() to populate field HostingEnvironmentProfile")
		}
		destination.HostingEnvironmentProfile = &hostingEnvironmentProfile
	} else {
		destination.HostingEnvironmentProfile = nil
	}

	// HttpsOnly
	if site.HttpsOnly != nil {
		httpsOnly := *site.HttpsOnly
		destination.HttpsOnly = &httpsOnly
	} else {
		destination.HttpsOnly = nil
	}

	// HyperV
	if site.HyperV != nil {
		hyperV := *site.HyperV
		destination.HyperV = &hyperV
	} else {
		destination.HyperV = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(site.Id)

	// Identity
	if site.Identity != nil {
		var identity v20220301s.ManagedServiceIdentity_STATUS
		err := site.Identity.AssignProperties_To_ManagedServiceIdentity_STATUS(&identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedServiceIdentity_STATUS() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// InProgressOperationId
	destination.InProgressOperationId = genruntime.ClonePointerToString(site.InProgressOperationId)

	// IsDefaultContainer
	if site.IsDefaultContainer != nil {
		isDefaultContainer := *site.IsDefaultContainer
		destination.IsDefaultContainer = &isDefaultContainer
	} else {
		destination.IsDefaultContainer = nil
	}

	// IsXenon
	if site.IsXenon != nil {
		isXenon := *site.IsXenon
		destination.IsXenon = &isXenon
	} else {
		destination.IsXenon = nil
	}

	// KeyVaultReferenceIdentity
	destination.KeyVaultReferenceIdentity = genruntime.ClonePointerToString(site.KeyVaultReferenceIdentity)

	// Kind
	destination.Kind = genruntime.ClonePointerToString(site.Kind)

	// LastModifiedTimeUtc
	destination.LastModifiedTimeUtc = genruntime.ClonePointerToString(site.LastModifiedTimeUtc)

	// Location
	destination.Location = genruntime.ClonePointerToString(site.Location)

	// MaxNumberOfWorkers
	destination.MaxNumberOfWorkers = genruntime.ClonePointerToInt(site.MaxNumberOfWorkers)

	// Name
	destination.Name = genruntime.ClonePointerToString(site.Name)

	// OutboundIpAddresses
	destination.OutboundIpAddresses = genruntime.ClonePointerToString(site.OutboundIpAddresses)

	// PossibleOutboundIpAddresses
	destination.PossibleOutboundIpAddresses = genruntime.ClonePointerToString(site.PossibleOutboundIpAddresses)

	// PublicNetworkAccess
	destination.PublicNetworkAccess = genruntime.ClonePointerToString(site.PublicNetworkAccess)

	// RedundancyMode
	if site.RedundancyMode != nil {
		redundancyMode := string(*site.RedundancyMode)
		destination.RedundancyMode = &redundancyMode
	} else {
		destination.RedundancyMode = nil
	}

	// RepositorySiteName
	destination.RepositorySiteName = genruntime.ClonePointerToString(site.RepositorySiteName)

	// Reserved
	if site.Reserved != nil {
		reserved := *site.Reserved
		destination.Reserved = &reserved
	} else {
		destination.Reserved = nil
	}

	// ResourceGroup
	destination.ResourceGroup = genruntime.ClonePointerToString(site.ResourceGroup)

	// ScmSiteAlsoStopped
	if site.ScmSiteAlsoStopped != nil {
		scmSiteAlsoStopped := *site.ScmSiteAlsoStopped
		destination.ScmSiteAlsoStopped = &scmSiteAlsoStopped
	} else {
		destination.ScmSiteAlsoStopped = nil
	}

	// ServerFarmId
	destination.ServerFarmId = genruntime.ClonePointerToString(site.ServerFarmId)

	// SiteConfig
	if site.SiteConfig != nil {
		var siteConfig v20220301s.SiteConfig_STATUS
		err := site.SiteConfig.AssignProperties_To_SiteConfig_STATUS(&siteConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SiteConfig_STATUS() to populate field SiteConfig")
		}
		destination.SiteConfig = &siteConfig
	} else {
		destination.SiteConfig = nil
	}

	// SlotSwapStatus
	if site.SlotSwapStatus != nil {
		var slotSwapStatus v20220301s.SlotSwapStatus_STATUS
		err := site.SlotSwapStatus.AssignProperties_To_SlotSwapStatus_STATUS(&slotSwapStatus)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SlotSwapStatus_STATUS() to populate field SlotSwapStatus")
		}
		destination.SlotSwapStatus = &slotSwapStatus
	} else {
		destination.SlotSwapStatus = nil
	}

	// State
	destination.State = genruntime.ClonePointerToString(site.State)

	// StorageAccountRequired
	if site.StorageAccountRequired != nil {
		storageAccountRequired := *site.StorageAccountRequired
		destination.StorageAccountRequired = &storageAccountRequired
	} else {
		destination.StorageAccountRequired = nil
	}

	// SuspendedTill
	destination.SuspendedTill = genruntime.ClonePointerToString(site.SuspendedTill)

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(site.Tags)

	// TargetSwapSlot
	destination.TargetSwapSlot = genruntime.ClonePointerToString(site.TargetSwapSlot)

	// TrafficManagerHostNames
	destination.TrafficManagerHostNames = genruntime.CloneSliceOfString(site.TrafficManagerHostNames)

	// Type
	destination.Type = genruntime.ClonePointerToString(site.Type)

	// UsageState
	if site.UsageState != nil {
		usageState := string(*site.UsageState)
		destination.UsageState = &usageState
	} else {
		destination.UsageState = nil
	}

	// VirtualNetworkSubnetId
	destination.VirtualNetworkSubnetId = genruntime.ClonePointerToString(site.VirtualNetworkSubnetId)

	// VnetContentShareEnabled
	if site.VnetContentShareEnabled != nil {
		vnetContentShareEnabled := *site.VnetContentShareEnabled
		destination.VnetContentShareEnabled = &vnetContentShareEnabled
	} else {
		destination.VnetContentShareEnabled = nil
	}

	// VnetImagePullEnabled
	if site.VnetImagePullEnabled != nil {
		vnetImagePullEnabled := *site.VnetImagePullEnabled
		destination.VnetImagePullEnabled = &vnetImagePullEnabled
	} else {
		destination.VnetImagePullEnabled = nil
	}

	// VnetRouteAllEnabled
	if site.VnetRouteAllEnabled != nil {
		vnetRouteAllEnabled := *site.VnetRouteAllEnabled
		destination.VnetRouteAllEnabled = &vnetRouteAllEnabled
	} else {
		destination.VnetRouteAllEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Information needed for cloning operation.
type CloningInfo struct {
	// AppSettingsOverrides: Application setting overrides for cloned app. If specified, these settings override the settings
	// cloned
	// from source app. Otherwise, application settings from source app are retained.
	AppSettingsOverrides map[string]string `json:"appSettingsOverrides,omitempty"`

	// CloneCustomHostNames: <code>true</code> to clone custom hostnames from source app; otherwise, <code>false</code>.
	CloneCustomHostNames *bool `json:"cloneCustomHostNames,omitempty"`

	// CloneSourceControl: <code>true</code> to clone source control from source app; otherwise, <code>false</code>.
	CloneSourceControl *bool `json:"cloneSourceControl,omitempty"`

	// ConfigureLoadBalancing: <code>true</code> to configure load balancing for source and destination app.
	ConfigureLoadBalancing *bool `json:"configureLoadBalancing,omitempty"`

	// +kubebuilder:validation:Pattern="^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$"
	// CorrelationId: Correlation ID of cloning operation. This ID ties multiple cloning operations
	// together to use the same snapshot.
	CorrelationId *string `json:"correlationId,omitempty"`

	// HostingEnvironment: App Service Environment.
	HostingEnvironment *string `json:"hostingEnvironment,omitempty"`

	// Overwrite: <code>true</code> to overwrite destination app; otherwise, <code>false</code>.
	Overwrite *bool `json:"overwrite,omitempty"`

	// SourceWebAppLocation: Location of source app ex: West US or North Europe
	SourceWebAppLocation *string `json:"sourceWebAppLocation,omitempty"`

	// +kubebuilder:validation:Required
	// SourceWebAppReference: ARM resource ID of the source app. App resource ID is of the form
	// /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName} for production slots
	// and
	// /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slotName} for
	// other slots.
	SourceWebAppReference *genruntime.ResourceReference `armReference:"SourceWebAppId" json:"sourceWebAppReference,omitempty"`

	// TrafficManagerProfileName: Name of Traffic Manager profile to create. This is only needed if Traffic Manager profile
	// does not already exist.
	TrafficManagerProfileName *string `json:"trafficManagerProfileName,omitempty"`

	// TrafficManagerProfileReference: ARM resource ID of the Traffic Manager profile to use, if it exists. Traffic Manager
	// resource ID is of the form
	// /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficManagerProfiles/{profileName}.
	TrafficManagerProfileReference *genruntime.ResourceReference `armReference:"TrafficManagerProfileId" json:"trafficManagerProfileReference,omitempty"`
}

var _ genruntime.ARMTransformer = &CloningInfo{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (info *CloningInfo) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if info == nil {
		return nil, nil
	}
	result := &CloningInfo_ARM{}

	// Set property "AppSettingsOverrides":
	if info.AppSettingsOverrides != nil {
		result.AppSettingsOverrides = make(map[string]string, len(info.AppSettingsOverrides))
		for key, value := range info.AppSettingsOverrides {
			result.AppSettingsOverrides[key] = value
		}
	}

	// Set property "CloneCustomHostNames":
	if info.CloneCustomHostNames != nil {
		cloneCustomHostNames := *info.CloneCustomHostNames
		result.CloneCustomHostNames = &cloneCustomHostNames
	}

	// Set property "CloneSourceControl":
	if info.CloneSourceControl != nil {
		cloneSourceControl := *info.CloneSourceControl
		result.CloneSourceControl = &cloneSourceControl
	}

	// Set property "ConfigureLoadBalancing":
	if info.ConfigureLoadBalancing != nil {
		configureLoadBalancing := *info.ConfigureLoadBalancing
		result.ConfigureLoadBalancing = &configureLoadBalancing
	}

	// Set property "CorrelationId":
	if info.CorrelationId != nil {
		correlationId := *info.CorrelationId
		result.CorrelationId = &correlationId
	}

	// Set property "HostingEnvironment":
	if info.HostingEnvironment != nil {
		hostingEnvironment := *info.HostingEnvironment
		result.HostingEnvironment = &hostingEnvironment
	}

	// Set property "Overwrite":
	if info.Overwrite != nil {
		overwrite := *info.Overwrite
		result.Overwrite = &overwrite
	}

	// Set property "SourceWebAppId":
	if info.SourceWebAppReference != nil {
		sourceWebAppReferenceARMID, err := resolved.ResolvedReferences.Lookup(*info.SourceWebAppReference)
		if err != nil {
			return nil, err
		}
		sourceWebAppReference := sourceWebAppReferenceARMID
		result.SourceWebAppId = &sourceWebAppReference
	}

	// Set property "SourceWebAppLocation":
	if info.SourceWebAppLocation != nil {
		sourceWebAppLocation := *info.SourceWebAppLocation
		result.SourceWebAppLocation = &sourceWebAppLocation
	}

	// Set property "TrafficManagerProfileId":
	if info.TrafficManagerProfileReference != nil {
		trafficManagerProfileReferenceARMID, err := resolved.ResolvedReferences.Lookup(*info.TrafficManagerProfileReference)
		if err != nil {
			return nil, err
		}
		trafficManagerProfileReference := trafficManagerProfileReferenceARMID
		result.TrafficManagerProfileId = &trafficManagerProfileReference
	}

	// Set property "TrafficManagerProfileName":
	if info.TrafficManagerProfileName != nil {
		trafficManagerProfileName := *info.TrafficManagerProfileName
		result.TrafficManagerProfileName = &trafficManagerProfileName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (info *CloningInfo) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &CloningInfo_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (info *CloningInfo) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(CloningInfo_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected CloningInfo_ARM, got %T", armInput)
	}

	// Set property "AppSettingsOverrides":
	if typedInput.AppSettingsOverrides != nil {
		info.AppSettingsOverrides = make(map[string]string, len(typedInput.AppSettingsOverrides))
		for key, value := range typedInput.AppSettingsOverrides {
			info.AppSettingsOverrides[key] = value
		}
	}

	// Set property "CloneCustomHostNames":
	if typedInput.CloneCustomHostNames != nil {
		cloneCustomHostNames := *typedInput.CloneCustomHostNames
		info.CloneCustomHostNames = &cloneCustomHostNames
	}

	// Set property "CloneSourceControl":
	if typedInput.CloneSourceControl != nil {
		cloneSourceControl := *typedInput.CloneSourceControl
		info.CloneSourceControl = &cloneSourceControl
	}

	// Set property "ConfigureLoadBalancing":
	if typedInput.ConfigureLoadBalancing != nil {
		configureLoadBalancing := *typedInput.ConfigureLoadBalancing
		info.ConfigureLoadBalancing = &configureLoadBalancing
	}

	// Set property "CorrelationId":
	if typedInput.CorrelationId != nil {
		correlationId := *typedInput.CorrelationId
		info.CorrelationId = &correlationId
	}

	// Set property "HostingEnvironment":
	if typedInput.HostingEnvironment != nil {
		hostingEnvironment := *typedInput.HostingEnvironment
		info.HostingEnvironment = &hostingEnvironment
	}

	// Set property "Overwrite":
	if typedInput.Overwrite != nil {
		overwrite := *typedInput.Overwrite
		info.Overwrite = &overwrite
	}

	// Set property "SourceWebAppLocation":
	if typedInput.SourceWebAppLocation != nil {
		sourceWebAppLocation := *typedInput.SourceWebAppLocation
		info.SourceWebAppLocation = &sourceWebAppLocation
	}

	// no assignment for property "SourceWebAppReference"

	// Set property "TrafficManagerProfileName":
	if typedInput.TrafficManagerProfileName != nil {
		trafficManagerProfileName := *typedInput.TrafficManagerProfileName
		info.TrafficManagerProfileName = &trafficManagerProfileName
	}

	// no assignment for property "TrafficManagerProfileReference"

	// No error
	return nil
}

// AssignProperties_From_CloningInfo populates our CloningInfo from the provided source CloningInfo
func (info *CloningInfo) AssignProperties_From_CloningInfo(source *v20220301s.CloningInfo) error {

	// AppSettingsOverrides
	info.AppSettingsOverrides = genruntime.CloneMapOfStringToString(source.AppSettingsOverrides)

	// CloneCustomHostNames
	if source.CloneCustomHostNames != nil {
		cloneCustomHostName := *source.CloneCustomHostNames
		info.CloneCustomHostNames = &cloneCustomHostName
	} else {
		info.CloneCustomHostNames = nil
	}

	// CloneSourceControl
	if source.CloneSourceControl != nil {
		cloneSourceControl := *source.CloneSourceControl
		info.CloneSourceControl = &cloneSourceControl
	} else {
		info.CloneSourceControl = nil
	}

	// ConfigureLoadBalancing
	if source.ConfigureLoadBalancing != nil {
		configureLoadBalancing := *source.ConfigureLoadBalancing
		info.ConfigureLoadBalancing = &configureLoadBalancing
	} else {
		info.ConfigureLoadBalancing = nil
	}

	// CorrelationId
	if source.CorrelationId != nil {
		correlationId := *source.CorrelationId
		info.CorrelationId = &correlationId
	} else {
		info.CorrelationId = nil
	}

	// HostingEnvironment
	info.HostingEnvironment = genruntime.ClonePointerToString(source.HostingEnvironment)

	// Overwrite
	if source.Overwrite != nil {
		overwrite := *source.Overwrite
		info.Overwrite = &overwrite
	} else {
		info.Overwrite = nil
	}

	// SourceWebAppLocation
	info.SourceWebAppLocation = genruntime.ClonePointerToString(source.SourceWebAppLocation)

	// SourceWebAppReference
	if source.SourceWebAppReference != nil {
		sourceWebAppReference := source.SourceWebAppReference.Copy()
		info.SourceWebAppReference = &sourceWebAppReference
	} else {
		info.SourceWebAppReference = nil
	}

	// TrafficManagerProfileName
	info.TrafficManagerProfileName = genruntime.ClonePointerToString(source.TrafficManagerProfileName)

	// TrafficManagerProfileReference
	if source.TrafficManagerProfileReference != nil {
		trafficManagerProfileReference := source.TrafficManagerProfileReference.Copy()
		info.TrafficManagerProfileReference = &trafficManagerProfileReference
	} else {
		info.TrafficManagerProfileReference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_CloningInfo populates the provided destination CloningInfo from our CloningInfo
func (info *CloningInfo) AssignProperties_To_CloningInfo(destination *v20220301s.CloningInfo) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AppSettingsOverrides
	destination.AppSettingsOverrides = genruntime.CloneMapOfStringToString(info.AppSettingsOverrides)

	// CloneCustomHostNames
	if info.CloneCustomHostNames != nil {
		cloneCustomHostName := *info.CloneCustomHostNames
		destination.CloneCustomHostNames = &cloneCustomHostName
	} else {
		destination.CloneCustomHostNames = nil
	}

	// CloneSourceControl
	if info.CloneSourceControl != nil {
		cloneSourceControl := *info.CloneSourceControl
		destination.CloneSourceControl = &cloneSourceControl
	} else {
		destination.CloneSourceControl = nil
	}

	// ConfigureLoadBalancing
	if info.ConfigureLoadBalancing != nil {
		configureLoadBalancing := *info.ConfigureLoadBalancing
		destination.ConfigureLoadBalancing = &configureLoadBalancing
	} else {
		destination.ConfigureLoadBalancing = nil
	}

	// CorrelationId
	if info.CorrelationId != nil {
		correlationId := *info.CorrelationId
		destination.CorrelationId = &correlationId
	} else {
		destination.CorrelationId = nil
	}

	// HostingEnvironment
	destination.HostingEnvironment = genruntime.ClonePointerToString(info.HostingEnvironment)

	// Overwrite
	if info.Overwrite != nil {
		overwrite := *info.Overwrite
		destination.Overwrite = &overwrite
	} else {
		destination.Overwrite = nil
	}

	// SourceWebAppLocation
	destination.SourceWebAppLocation = genruntime.ClonePointerToString(info.SourceWebAppLocation)

	// SourceWebAppReference
	if info.SourceWebAppReference != nil {
		sourceWebAppReference := info.SourceWebAppReference.Copy()
		destination.SourceWebAppReference = &sourceWebAppReference
	} else {
		destination.SourceWebAppReference = nil
	}

	// TrafficManagerProfileName
	destination.TrafficManagerProfileName = genruntime.ClonePointerToString(info.TrafficManagerProfileName)

	// TrafficManagerProfileReference
	if info.TrafficManagerProfileReference != nil {
		trafficManagerProfileReference := info.TrafficManagerProfileReference.Copy()
		destination.TrafficManagerProfileReference = &trafficManagerProfileReference
	} else {
		destination.TrafficManagerProfileReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_CloningInfo_STATUS populates our CloningInfo from the provided source CloningInfo_STATUS
func (info *CloningInfo) Initialize_From_CloningInfo_STATUS(source *CloningInfo_STATUS) error {

	// AppSettingsOverrides
	info.AppSettingsOverrides = genruntime.CloneMapOfStringToString(source.AppSettingsOverrides)

	// CloneCustomHostNames
	if source.CloneCustomHostNames != nil {
		cloneCustomHostName := *source.CloneCustomHostNames
		info.CloneCustomHostNames = &cloneCustomHostName
	} else {
		info.CloneCustomHostNames = nil
	}

	// CloneSourceControl
	if source.CloneSourceControl != nil {
		cloneSourceControl := *source.CloneSourceControl
		info.CloneSourceControl = &cloneSourceControl
	} else {
		info.CloneSourceControl = nil
	}

	// ConfigureLoadBalancing
	if source.ConfigureLoadBalancing != nil {
		configureLoadBalancing := *source.ConfigureLoadBalancing
		info.ConfigureLoadBalancing = &configureLoadBalancing
	} else {
		info.ConfigureLoadBalancing = nil
	}

	// CorrelationId
	if source.CorrelationId != nil {
		correlationId := *source.CorrelationId
		info.CorrelationId = &correlationId
	} else {
		info.CorrelationId = nil
	}

	// HostingEnvironment
	info.HostingEnvironment = genruntime.ClonePointerToString(source.HostingEnvironment)

	// Overwrite
	if source.Overwrite != nil {
		overwrite := *source.Overwrite
		info.Overwrite = &overwrite
	} else {
		info.Overwrite = nil
	}

	// SourceWebAppLocation
	info.SourceWebAppLocation = genruntime.ClonePointerToString(source.SourceWebAppLocation)

	// SourceWebAppReference
	if source.SourceWebAppId != nil {
		sourceWebAppReference := genruntime.CreateResourceReferenceFromARMID(*source.SourceWebAppId)
		info.SourceWebAppReference = &sourceWebAppReference
	} else {
		info.SourceWebAppReference = nil
	}

	// TrafficManagerProfileName
	info.TrafficManagerProfileName = genruntime.ClonePointerToString(source.TrafficManagerProfileName)

	// TrafficManagerProfileReference
	if source.TrafficManagerProfileId != nil {
		trafficManagerProfileReference := genruntime.CreateResourceReferenceFromARMID(*source.TrafficManagerProfileId)
		info.TrafficManagerProfileReference = &trafficManagerProfileReference
	} else {
		info.TrafficManagerProfileReference = nil
	}

	// No error
	return nil
}

// Information needed for cloning operation.
type CloningInfo_STATUS struct {
	// AppSettingsOverrides: Application setting overrides for cloned app. If specified, these settings override the settings
	// cloned
	// from source app. Otherwise, application settings from source app are retained.
	AppSettingsOverrides map[string]string `json:"appSettingsOverrides,omitempty"`

	// CloneCustomHostNames: <code>true</code> to clone custom hostnames from source app; otherwise, <code>false</code>.
	CloneCustomHostNames *bool `json:"cloneCustomHostNames,omitempty"`

	// CloneSourceControl: <code>true</code> to clone source control from source app; otherwise, <code>false</code>.
	CloneSourceControl *bool `json:"cloneSourceControl,omitempty"`

	// ConfigureLoadBalancing: <code>true</code> to configure load balancing for source and destination app.
	ConfigureLoadBalancing *bool `json:"configureLoadBalancing,omitempty"`

	// CorrelationId: Correlation ID of cloning operation. This ID ties multiple cloning operations
	// together to use the same snapshot.
	CorrelationId *string `json:"correlationId,omitempty"`

	// HostingEnvironment: App Service Environment.
	HostingEnvironment *string `json:"hostingEnvironment,omitempty"`

	// Overwrite: <code>true</code> to overwrite destination app; otherwise, <code>false</code>.
	Overwrite *bool `json:"overwrite,omitempty"`

	// SourceWebAppId: ARM resource ID of the source app. App resource ID is of the form
	// /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName} for production slots
	// and
	// /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slotName} for
	// other slots.
	SourceWebAppId *string `json:"sourceWebAppId,omitempty"`

	// SourceWebAppLocation: Location of source app ex: West US or North Europe
	SourceWebAppLocation *string `json:"sourceWebAppLocation,omitempty"`

	// TrafficManagerProfileId: ARM resource ID of the Traffic Manager profile to use, if it exists. Traffic Manager resource
	// ID is of the form
	// /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficManagerProfiles/{profileName}.
	TrafficManagerProfileId *string `json:"trafficManagerProfileId,omitempty"`

	// TrafficManagerProfileName: Name of Traffic Manager profile to create. This is only needed if Traffic Manager profile
	// does not already exist.
	TrafficManagerProfileName *string `json:"trafficManagerProfileName,omitempty"`
}

var _ genruntime.FromARMConverter = &CloningInfo_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (info *CloningInfo_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &CloningInfo_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (info *CloningInfo_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(CloningInfo_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected CloningInfo_STATUS_ARM, got %T", armInput)
	}

	// Set property "AppSettingsOverrides":
	if typedInput.AppSettingsOverrides != nil {
		info.AppSettingsOverrides = make(map[string]string, len(typedInput.AppSettingsOverrides))
		for key, value := range typedInput.AppSettingsOverrides {
			info.AppSettingsOverrides[key] = value
		}
	}

	// Set property "CloneCustomHostNames":
	if typedInput.CloneCustomHostNames != nil {
		cloneCustomHostNames := *typedInput.CloneCustomHostNames
		info.CloneCustomHostNames = &cloneCustomHostNames
	}

	// Set property "CloneSourceControl":
	if typedInput.CloneSourceControl != nil {
		cloneSourceControl := *typedInput.CloneSourceControl
		info.CloneSourceControl = &cloneSourceControl
	}

	// Set property "ConfigureLoadBalancing":
	if typedInput.ConfigureLoadBalancing != nil {
		configureLoadBalancing := *typedInput.ConfigureLoadBalancing
		info.ConfigureLoadBalancing = &configureLoadBalancing
	}

	// Set property "CorrelationId":
	if typedInput.CorrelationId != nil {
		correlationId := *typedInput.CorrelationId
		info.CorrelationId = &correlationId
	}

	// Set property "HostingEnvironment":
	if typedInput.HostingEnvironment != nil {
		hostingEnvironment := *typedInput.HostingEnvironment
		info.HostingEnvironment = &hostingEnvironment
	}

	// Set property "Overwrite":
	if typedInput.Overwrite != nil {
		overwrite := *typedInput.Overwrite
		info.Overwrite = &overwrite
	}

	// Set property "SourceWebAppId":
	if typedInput.SourceWebAppId != nil {
		sourceWebAppId := *typedInput.SourceWebAppId
		info.SourceWebAppId = &sourceWebAppId
	}

	// Set property "SourceWebAppLocation":
	if typedInput.SourceWebAppLocation != nil {
		sourceWebAppLocation := *typedInput.SourceWebAppLocation
		info.SourceWebAppLocation = &sourceWebAppLocation
	}

	// Set property "TrafficManagerProfileId":
	if typedInput.TrafficManagerProfileId != nil {
		trafficManagerProfileId := *typedInput.TrafficManagerProfileId
		info.TrafficManagerProfileId = &trafficManagerProfileId
	}

	// Set property "TrafficManagerProfileName":
	if typedInput.TrafficManagerProfileName != nil {
		trafficManagerProfileName := *typedInput.TrafficManagerProfileName
		info.TrafficManagerProfileName = &trafficManagerProfileName
	}

	// No error
	return nil
}

// AssignProperties_From_CloningInfo_STATUS populates our CloningInfo_STATUS from the provided source CloningInfo_STATUS
func (info *CloningInfo_STATUS) AssignProperties_From_CloningInfo_STATUS(source *v20220301s.CloningInfo_STATUS) error {

	// AppSettingsOverrides
	info.AppSettingsOverrides = genruntime.CloneMapOfStringToString(source.AppSettingsOverrides)

	// CloneCustomHostNames
	if source.CloneCustomHostNames != nil {
		cloneCustomHostName := *source.CloneCustomHostNames
		info.CloneCustomHostNames = &cloneCustomHostName
	} else {
		info.CloneCustomHostNames = nil
	}

	// CloneSourceControl
	if source.CloneSourceControl != nil {
		cloneSourceControl := *source.CloneSourceControl
		info.CloneSourceControl = &cloneSourceControl
	} else {
		info.CloneSourceControl = nil
	}

	// ConfigureLoadBalancing
	if source.ConfigureLoadBalancing != nil {
		configureLoadBalancing := *source.ConfigureLoadBalancing
		info.ConfigureLoadBalancing = &configureLoadBalancing
	} else {
		info.ConfigureLoadBalancing = nil
	}

	// CorrelationId
	info.CorrelationId = genruntime.ClonePointerToString(source.CorrelationId)

	// HostingEnvironment
	info.HostingEnvironment = genruntime.ClonePointerToString(source.HostingEnvironment)

	// Overwrite
	if source.Overwrite != nil {
		overwrite := *source.Overwrite
		info.Overwrite = &overwrite
	} else {
		info.Overwrite = nil
	}

	// SourceWebAppId
	info.SourceWebAppId = genruntime.ClonePointerToString(source.SourceWebAppId)

	// SourceWebAppLocation
	info.SourceWebAppLocation = genruntime.ClonePointerToString(source.SourceWebAppLocation)

	// TrafficManagerProfileId
	info.TrafficManagerProfileId = genruntime.ClonePointerToString(source.TrafficManagerProfileId)

	// TrafficManagerProfileName
	info.TrafficManagerProfileName = genruntime.ClonePointerToString(source.TrafficManagerProfileName)

	// No error
	return nil
}

// AssignProperties_To_CloningInfo_STATUS populates the provided destination CloningInfo_STATUS from our CloningInfo_STATUS
func (info *CloningInfo_STATUS) AssignProperties_To_CloningInfo_STATUS(destination *v20220301s.CloningInfo_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AppSettingsOverrides
	destination.AppSettingsOverrides = genruntime.CloneMapOfStringToString(info.AppSettingsOverrides)

	// CloneCustomHostNames
	if info.CloneCustomHostNames != nil {
		cloneCustomHostName := *info.CloneCustomHostNames
		destination.CloneCustomHostNames = &cloneCustomHostName
	} else {
		destination.CloneCustomHostNames = nil
	}

	// CloneSourceControl
	if info.CloneSourceControl != nil {
		cloneSourceControl := *info.CloneSourceControl
		destination.CloneSourceControl = &cloneSourceControl
	} else {
		destination.CloneSourceControl = nil
	}

	// ConfigureLoadBalancing
	if info.ConfigureLoadBalancing != nil {
		configureLoadBalancing := *info.ConfigureLoadBalancing
		destination.ConfigureLoadBalancing = &configureLoadBalancing
	} else {
		destination.ConfigureLoadBalancing = nil
	}

	// CorrelationId
	destination.CorrelationId = genruntime.ClonePointerToString(info.CorrelationId)

	// HostingEnvironment
	destination.HostingEnvironment = genruntime.ClonePointerToString(info.HostingEnvironment)

	// Overwrite
	if info.Overwrite != nil {
		overwrite := *info.Overwrite
		destination.Overwrite = &overwrite
	} else {
		destination.Overwrite = nil
	}

	// SourceWebAppId
	destination.SourceWebAppId = genruntime.ClonePointerToString(info.SourceWebAppId)

	// SourceWebAppLocation
	destination.SourceWebAppLocation = genruntime.ClonePointerToString(info.SourceWebAppLocation)

	// TrafficManagerProfileId
	destination.TrafficManagerProfileId = genruntime.ClonePointerToString(info.TrafficManagerProfileId)

	// TrafficManagerProfileName
	destination.TrafficManagerProfileName = genruntime.ClonePointerToString(info.TrafficManagerProfileName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// SSL-enabled hostname.
type HostNameSslState struct {
	// HostType: Indicates whether the hostname is a standard or repository hostname.
	HostType *HostNameSslState_HostType `json:"hostType,omitempty"`

	// Name: Hostname.
	Name *string `json:"name,omitempty"`

	// SslState: SSL type.
	SslState *HostNameSslState_SslState `json:"sslState,omitempty"`

	// Thumbprint: SSL certificate thumbprint.
	Thumbprint *string `json:"thumbprint,omitempty"`

	// ToUpdate: Set to <code>true</code> to update existing hostname.
	ToUpdate *bool `json:"toUpdate,omitempty"`

	// VirtualIP: Virtual IP address assigned to the hostname if IP based SSL is enabled.
	VirtualIP *string `json:"virtualIP,omitempty"`
}

var _ genruntime.ARMTransformer = &HostNameSslState{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (state *HostNameSslState) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if state == nil {
		return nil, nil
	}
	result := &HostNameSslState_ARM{}

	// Set property "HostType":
	if state.HostType != nil {
		hostType := *state.HostType
		result.HostType = &hostType
	}

	// Set property "Name":
	if state.Name != nil {
		name := *state.Name
		result.Name = &name
	}

	// Set property "SslState":
	if state.SslState != nil {
		sslState := *state.SslState
		result.SslState = &sslState
	}

	// Set property "Thumbprint":
	if state.Thumbprint != nil {
		thumbprint := *state.Thumbprint
		result.Thumbprint = &thumbprint
	}

	// Set property "ToUpdate":
	if state.ToUpdate != nil {
		toUpdate := *state.ToUpdate
		result.ToUpdate = &toUpdate
	}

	// Set property "VirtualIP":
	if state.VirtualIP != nil {
		virtualIP := *state.VirtualIP
		result.VirtualIP = &virtualIP
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (state *HostNameSslState) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &HostNameSslState_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (state *HostNameSslState) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(HostNameSslState_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected HostNameSslState_ARM, got %T", armInput)
	}

	// Set property "HostType":
	if typedInput.HostType != nil {
		hostType := *typedInput.HostType
		state.HostType = &hostType
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		state.Name = &name
	}

	// Set property "SslState":
	if typedInput.SslState != nil {
		sslState := *typedInput.SslState
		state.SslState = &sslState
	}

	// Set property "Thumbprint":
	if typedInput.Thumbprint != nil {
		thumbprint := *typedInput.Thumbprint
		state.Thumbprint = &thumbprint
	}

	// Set property "ToUpdate":
	if typedInput.ToUpdate != nil {
		toUpdate := *typedInput.ToUpdate
		state.ToUpdate = &toUpdate
	}

	// Set property "VirtualIP":
	if typedInput.VirtualIP != nil {
		virtualIP := *typedInput.VirtualIP
		state.VirtualIP = &virtualIP
	}

	// No error
	return nil
}

// AssignProperties_From_HostNameSslState populates our HostNameSslState from the provided source HostNameSslState
func (state *HostNameSslState) AssignProperties_From_HostNameSslState(source *v20220301s.HostNameSslState) error {

	// HostType
	if source.HostType != nil {
		hostType := HostNameSslState_HostType(*source.HostType)
		state.HostType = &hostType
	} else {
		state.HostType = nil
	}

	// Name
	state.Name = genruntime.ClonePointerToString(source.Name)

	// SslState
	if source.SslState != nil {
		sslState := HostNameSslState_SslState(*source.SslState)
		state.SslState = &sslState
	} else {
		state.SslState = nil
	}

	// Thumbprint
	state.Thumbprint = genruntime.ClonePointerToString(source.Thumbprint)

	// ToUpdate
	if source.ToUpdate != nil {
		toUpdate := *source.ToUpdate
		state.ToUpdate = &toUpdate
	} else {
		state.ToUpdate = nil
	}

	// VirtualIP
	state.VirtualIP = genruntime.ClonePointerToString(source.VirtualIP)

	// No error
	return nil
}

// AssignProperties_To_HostNameSslState populates the provided destination HostNameSslState from our HostNameSslState
func (state *HostNameSslState) AssignProperties_To_HostNameSslState(destination *v20220301s.HostNameSslState) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// HostType
	if state.HostType != nil {
		hostType := string(*state.HostType)
		destination.HostType = &hostType
	} else {
		destination.HostType = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(state.Name)

	// SslState
	if state.SslState != nil {
		sslState := string(*state.SslState)
		destination.SslState = &sslState
	} else {
		destination.SslState = nil
	}

	// Thumbprint
	destination.Thumbprint = genruntime.ClonePointerToString(state.Thumbprint)

	// ToUpdate
	if state.ToUpdate != nil {
		toUpdate := *state.ToUpdate
		destination.ToUpdate = &toUpdate
	} else {
		destination.ToUpdate = nil
	}

	// VirtualIP
	destination.VirtualIP = genruntime.ClonePointerToString(state.VirtualIP)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_HostNameSslState_STATUS populates our HostNameSslState from the provided source HostNameSslState_STATUS
func (state *HostNameSslState) Initialize_From_HostNameSslState_STATUS(source *HostNameSslState_STATUS) error {

	// HostType
	if source.HostType != nil {
		hostType := HostNameSslState_HostType(*source.HostType)
		state.HostType = &hostType
	} else {
		state.HostType = nil
	}

	// Name
	state.Name = genruntime.ClonePointerToString(source.Name)

	// SslState
	if source.SslState != nil {
		sslState := HostNameSslState_SslState(*source.SslState)
		state.SslState = &sslState
	} else {
		state.SslState = nil
	}

	// Thumbprint
	state.Thumbprint = genruntime.ClonePointerToString(source.Thumbprint)

	// ToUpdate
	if source.ToUpdate != nil {
		toUpdate := *source.ToUpdate
		state.ToUpdate = &toUpdate
	} else {
		state.ToUpdate = nil
	}

	// VirtualIP
	state.VirtualIP = genruntime.ClonePointerToString(source.VirtualIP)

	// No error
	return nil
}

// SSL-enabled hostname.
type HostNameSslState_STATUS struct {
	// HostType: Indicates whether the hostname is a standard or repository hostname.
	HostType *HostNameSslState_HostType_STATUS `json:"hostType,omitempty"`

	// Name: Hostname.
	Name *string `json:"name,omitempty"`

	// SslState: SSL type.
	SslState *HostNameSslState_SslState_STATUS `json:"sslState,omitempty"`

	// Thumbprint: SSL certificate thumbprint.
	Thumbprint *string `json:"thumbprint,omitempty"`

	// ToUpdate: Set to <code>true</code> to update existing hostname.
	ToUpdate *bool `json:"toUpdate,omitempty"`

	// VirtualIP: Virtual IP address assigned to the hostname if IP based SSL is enabled.
	VirtualIP *string `json:"virtualIP,omitempty"`
}

var _ genruntime.FromARMConverter = &HostNameSslState_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (state *HostNameSslState_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &HostNameSslState_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (state *HostNameSslState_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(HostNameSslState_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected HostNameSslState_STATUS_ARM, got %T", armInput)
	}

	// Set property "HostType":
	if typedInput.HostType != nil {
		hostType := *typedInput.HostType
		state.HostType = &hostType
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		state.Name = &name
	}

	// Set property "SslState":
	if typedInput.SslState != nil {
		sslState := *typedInput.SslState
		state.SslState = &sslState
	}

	// Set property "Thumbprint":
	if typedInput.Thumbprint != nil {
		thumbprint := *typedInput.Thumbprint
		state.Thumbprint = &thumbprint
	}

	// Set property "ToUpdate":
	if typedInput.ToUpdate != nil {
		toUpdate := *typedInput.ToUpdate
		state.ToUpdate = &toUpdate
	}

	// Set property "VirtualIP":
	if typedInput.VirtualIP != nil {
		virtualIP := *typedInput.VirtualIP
		state.VirtualIP = &virtualIP
	}

	// No error
	return nil
}

// AssignProperties_From_HostNameSslState_STATUS populates our HostNameSslState_STATUS from the provided source HostNameSslState_STATUS
func (state *HostNameSslState_STATUS) AssignProperties_From_HostNameSslState_STATUS(source *v20220301s.HostNameSslState_STATUS) error {

	// HostType
	if source.HostType != nil {
		hostType := HostNameSslState_HostType_STATUS(*source.HostType)
		state.HostType = &hostType
	} else {
		state.HostType = nil
	}

	// Name
	state.Name = genruntime.ClonePointerToString(source.Name)

	// SslState
	if source.SslState != nil {
		sslState := HostNameSslState_SslState_STATUS(*source.SslState)
		state.SslState = &sslState
	} else {
		state.SslState = nil
	}

	// Thumbprint
	state.Thumbprint = genruntime.ClonePointerToString(source.Thumbprint)

	// ToUpdate
	if source.ToUpdate != nil {
		toUpdate := *source.ToUpdate
		state.ToUpdate = &toUpdate
	} else {
		state.ToUpdate = nil
	}

	// VirtualIP
	state.VirtualIP = genruntime.ClonePointerToString(source.VirtualIP)

	// No error
	return nil
}

// AssignProperties_To_HostNameSslState_STATUS populates the provided destination HostNameSslState_STATUS from our HostNameSslState_STATUS
func (state *HostNameSslState_STATUS) AssignProperties_To_HostNameSslState_STATUS(destination *v20220301s.HostNameSslState_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// HostType
	if state.HostType != nil {
		hostType := string(*state.HostType)
		destination.HostType = &hostType
	} else {
		destination.HostType = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(state.Name)

	// SslState
	if state.SslState != nil {
		sslState := string(*state.SslState)
		destination.SslState = &sslState
	} else {
		destination.SslState = nil
	}

	// Thumbprint
	destination.Thumbprint = genruntime.ClonePointerToString(state.Thumbprint)

	// ToUpdate
	if state.ToUpdate != nil {
		toUpdate := *state.ToUpdate
		destination.ToUpdate = &toUpdate
	} else {
		destination.ToUpdate = nil
	}

	// VirtualIP
	destination.VirtualIP = genruntime.ClonePointerToString(state.VirtualIP)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Managed service identity.
type ManagedServiceIdentity struct {
	// Type: Type of managed service identity.
	Type *ManagedServiceIdentity_Type `json:"type,omitempty"`

	// UserAssignedIdentities: The list of user assigned identities associated with the resource. The user identity dictionary
	// key references will be ARM resource ids in the form:
	// '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}
	UserAssignedIdentities []UserAssignedIdentityDetails `json:"userAssignedIdentities,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedServiceIdentity{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (identity *ManagedServiceIdentity) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if identity == nil {
		return nil, nil
	}
	result := &ManagedServiceIdentity_ARM{}

	// Set property "Type":
	if identity.Type != nil {
		typeVar := *identity.Type
		result.Type = &typeVar
	}

	// Set property "UserAssignedIdentities":
	result.UserAssignedIdentities = make(map[string]UserAssignedIdentityDetails_ARM, len(identity.UserAssignedIdentities))
	for _, ident := range identity.UserAssignedIdentities {
		identARMID, err := resolved.ResolvedReferences.Lookup(ident.Reference)
		if err != nil {
			return nil, err
		}
		key := identARMID
		result.UserAssignedIdentities[key] = UserAssignedIdentityDetails_ARM{}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *ManagedServiceIdentity) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedServiceIdentity_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *ManagedServiceIdentity) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedServiceIdentity_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedServiceIdentity_ARM, got %T", armInput)
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		identity.Type = &typeVar
	}

	// no assignment for property "UserAssignedIdentities"

	// No error
	return nil
}

// AssignProperties_From_ManagedServiceIdentity populates our ManagedServiceIdentity from the provided source ManagedServiceIdentity
func (identity *ManagedServiceIdentity) AssignProperties_From_ManagedServiceIdentity(source *v20220301s.ManagedServiceIdentity) error {

	// Type
	if source.Type != nil {
		typeVar := ManagedServiceIdentity_Type(*source.Type)
		identity.Type = &typeVar
	} else {
		identity.Type = nil
	}

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]UserAssignedIdentityDetails, len(source.UserAssignedIdentities))
		for userAssignedIdentityIndex, userAssignedIdentityItem := range source.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityItem := userAssignedIdentityItem
			var userAssignedIdentity UserAssignedIdentityDetails
			err := userAssignedIdentity.AssignProperties_From_UserAssignedIdentityDetails(&userAssignedIdentityItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_UserAssignedIdentityDetails() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityList[userAssignedIdentityIndex] = userAssignedIdentity
		}
		identity.UserAssignedIdentities = userAssignedIdentityList
	} else {
		identity.UserAssignedIdentities = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedServiceIdentity populates the provided destination ManagedServiceIdentity from our ManagedServiceIdentity
func (identity *ManagedServiceIdentity) AssignProperties_To_ManagedServiceIdentity(destination *v20220301s.ManagedServiceIdentity) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Type
	if identity.Type != nil {
		typeVar := string(*identity.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// UserAssignedIdentities
	if identity.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]v20220301s.UserAssignedIdentityDetails, len(identity.UserAssignedIdentities))
		for userAssignedIdentityIndex, userAssignedIdentityItem := range identity.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityItem := userAssignedIdentityItem
			var userAssignedIdentity v20220301s.UserAssignedIdentityDetails
			err := userAssignedIdentityItem.AssignProperties_To_UserAssignedIdentityDetails(&userAssignedIdentity)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_UserAssignedIdentityDetails() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityList[userAssignedIdentityIndex] = userAssignedIdentity
		}
		destination.UserAssignedIdentities = userAssignedIdentityList
	} else {
		destination.UserAssignedIdentities = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ManagedServiceIdentity_STATUS populates our ManagedServiceIdentity from the provided source ManagedServiceIdentity_STATUS
func (identity *ManagedServiceIdentity) Initialize_From_ManagedServiceIdentity_STATUS(source *ManagedServiceIdentity_STATUS) error {

	// Type
	if source.Type != nil {
		typeVar := ManagedServiceIdentity_Type(*source.Type)
		identity.Type = &typeVar
	} else {
		identity.Type = nil
	}

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]UserAssignedIdentityDetails, 0, len(source.UserAssignedIdentities))
		for userAssignedIdentitiesKey := range source.UserAssignedIdentities {
			userAssignedIdentitiesRef := genruntime.CreateResourceReferenceFromARMID(userAssignedIdentitiesKey)
			userAssignedIdentityList = append(userAssignedIdentityList, UserAssignedIdentityDetails{Reference: userAssignedIdentitiesRef})
		}
		identity.UserAssignedIdentities = userAssignedIdentityList
	} else {
		identity.UserAssignedIdentities = nil
	}

	// No error
	return nil
}

// Managed service identity.
type ManagedServiceIdentity_STATUS struct {
	// PrincipalId: Principal Id of managed service identity.
	PrincipalId *string `json:"principalId,omitempty"`

	// TenantId: Tenant of managed service identity.
	TenantId *string `json:"tenantId,omitempty"`

	// Type: Type of managed service identity.
	Type *ManagedServiceIdentity_Type_STATUS `json:"type,omitempty"`

	// UserAssignedIdentities: The list of user assigned identities associated with the resource. The user identity dictionary
	// key references will be ARM resource ids in the form:
	// '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}
	UserAssignedIdentities map[string]UserAssignedIdentity_STATUS `json:"userAssignedIdentities,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedServiceIdentity_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *ManagedServiceIdentity_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedServiceIdentity_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *ManagedServiceIdentity_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedServiceIdentity_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedServiceIdentity_STATUS_ARM, got %T", armInput)
	}

	// Set property "PrincipalId":
	if typedInput.PrincipalId != nil {
		principalId := *typedInput.PrincipalId
		identity.PrincipalId = &principalId
	}

	// Set property "TenantId":
	if typedInput.TenantId != nil {
		tenantId := *typedInput.TenantId
		identity.TenantId = &tenantId
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		identity.Type = &typeVar
	}

	// Set property "UserAssignedIdentities":
	if typedInput.UserAssignedIdentities != nil {
		identity.UserAssignedIdentities = make(map[string]UserAssignedIdentity_STATUS, len(typedInput.UserAssignedIdentities))
		for key, value := range typedInput.UserAssignedIdentities {
			var value1 UserAssignedIdentity_STATUS
			err := value1.PopulateFromARM(owner, value)
			if err != nil {
				return err
			}
			identity.UserAssignedIdentities[key] = value1
		}
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedServiceIdentity_STATUS populates our ManagedServiceIdentity_STATUS from the provided source ManagedServiceIdentity_STATUS
func (identity *ManagedServiceIdentity_STATUS) AssignProperties_From_ManagedServiceIdentity_STATUS(source *v20220301s.ManagedServiceIdentity_STATUS) error {

	// PrincipalId
	identity.PrincipalId = genruntime.ClonePointerToString(source.PrincipalId)

	// TenantId
	identity.TenantId = genruntime.ClonePointerToString(source.TenantId)

	// Type
	if source.Type != nil {
		typeVar := ManagedServiceIdentity_Type_STATUS(*source.Type)
		identity.Type = &typeVar
	} else {
		identity.Type = nil
	}

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityMap := make(map[string]UserAssignedIdentity_STATUS, len(source.UserAssignedIdentities))
		for userAssignedIdentityKey, userAssignedIdentityValue := range source.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityValue := userAssignedIdentityValue
			var userAssignedIdentity UserAssignedIdentity_STATUS
			err := userAssignedIdentity.AssignProperties_From_UserAssignedIdentity_STATUS(&userAssignedIdentityValue)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_UserAssignedIdentity_STATUS() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityMap[userAssignedIdentityKey] = userAssignedIdentity
		}
		identity.UserAssignedIdentities = userAssignedIdentityMap
	} else {
		identity.UserAssignedIdentities = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedServiceIdentity_STATUS populates the provided destination ManagedServiceIdentity_STATUS from our ManagedServiceIdentity_STATUS
func (identity *ManagedServiceIdentity_STATUS) AssignProperties_To_ManagedServiceIdentity_STATUS(destination *v20220301s.ManagedServiceIdentity_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PrincipalId
	destination.PrincipalId = genruntime.ClonePointerToString(identity.PrincipalId)

	// TenantId
	destination.TenantId = genruntime.ClonePointerToString(identity.TenantId)

	// Type
	if identity.Type != nil {
		typeVar := string(*identity.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// UserAssignedIdentities
	if identity.UserAssignedIdentities != nil {
		userAssignedIdentityMap := make(map[string]v20220301s.UserAssignedIdentity_STATUS, len(identity.UserAssignedIdentities))
		for userAssignedIdentityKey, userAssignedIdentityValue := range identity.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityValue := userAssignedIdentityValue
			var userAssignedIdentity v20220301s.UserAssignedIdentity_STATUS
			err := userAssignedIdentityValue.AssignProperties_To_UserAssignedIdentity_STATUS(&userAssignedIdentity)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_UserAssignedIdentity_STATUS() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityMap[userAssignedIdentityKey] = userAssignedIdentity
		}
		destination.UserAssignedIdentities = userAssignedIdentityMap
	} else {
		destination.UserAssignedIdentities = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type Site_Properties_AvailabilityState_STATUS string

const (
	Site_Properties_AvailabilityState_STATUS_DisasterRecoveryMode = Site_Properties_AvailabilityState_STATUS("DisasterRecoveryMode")
	Site_Properties_AvailabilityState_STATUS_Limited              = Site_Properties_AvailabilityState_STATUS("Limited")
	Site_Properties_AvailabilityState_STATUS_Normal               = Site_Properties_AvailabilityState_STATUS("Normal")
)

// +kubebuilder:validation:Enum={"Optional","OptionalInteractiveUser","Required"}
type Site_Properties_ClientCertMode_Spec string

const (
	Site_Properties_ClientCertMode_Spec_Optional                = Site_Properties_ClientCertMode_Spec("Optional")
	Site_Properties_ClientCertMode_Spec_OptionalInteractiveUser = Site_Properties_ClientCertMode_Spec("OptionalInteractiveUser")
	Site_Properties_ClientCertMode_Spec_Required                = Site_Properties_ClientCertMode_Spec("Required")
)

type Site_Properties_ClientCertMode_STATUS string

const (
	Site_Properties_ClientCertMode_STATUS_Optional                = Site_Properties_ClientCertMode_STATUS("Optional")
	Site_Properties_ClientCertMode_STATUS_OptionalInteractiveUser = Site_Properties_ClientCertMode_STATUS("OptionalInteractiveUser")
	Site_Properties_ClientCertMode_STATUS_Required                = Site_Properties_ClientCertMode_STATUS("Required")
)

// +kubebuilder:validation:Enum={"ActiveActive","Failover","GeoRedundant","Manual","None"}
type Site_Properties_RedundancyMode_Spec string

const (
	Site_Properties_RedundancyMode_Spec_ActiveActive = Site_Properties_RedundancyMode_Spec("ActiveActive")
	Site_Properties_RedundancyMode_Spec_Failover     = Site_Properties_RedundancyMode_Spec("Failover")
	Site_Properties_RedundancyMode_Spec_GeoRedundant = Site_Properties_RedundancyMode_Spec("GeoRedundant")
	Site_Properties_RedundancyMode_Spec_Manual       = Site_Properties_RedundancyMode_Spec("Manual")
	Site_Properties_RedundancyMode_Spec_None         = Site_Properties_RedundancyMode_Spec("None")
)

type Site_Properties_RedundancyMode_STATUS string

const (
	Site_Properties_RedundancyMode_STATUS_ActiveActive = Site_Properties_RedundancyMode_STATUS("ActiveActive")
	Site_Properties_RedundancyMode_STATUS_Failover     = Site_Properties_RedundancyMode_STATUS("Failover")
	Site_Properties_RedundancyMode_STATUS_GeoRedundant = Site_Properties_RedundancyMode_STATUS("GeoRedundant")
	Site_Properties_RedundancyMode_STATUS_Manual       = Site_Properties_RedundancyMode_STATUS("Manual")
	Site_Properties_RedundancyMode_STATUS_None         = Site_Properties_RedundancyMode_STATUS("None")
)

type Site_Properties_UsageState_STATUS string

const (
	Site_Properties_UsageState_STATUS_Exceeded = Site_Properties_UsageState_STATUS("Exceeded")
	Site_Properties_UsageState_STATUS_Normal   = Site_Properties_UsageState_STATUS("Normal")
)

// Configuration of an App Service app.
type SiteConfig struct {
	// AcrUseManagedIdentityCreds: Flag to use Managed Identity Creds for ACR pull
	AcrUseManagedIdentityCreds *bool `json:"acrUseManagedIdentityCreds,omitempty"`

	// AcrUserManagedIdentityID: If using user managed identity, the user managed identity ClientId
	AcrUserManagedIdentityID *string `json:"acrUserManagedIdentityID,omitempty"`

	// AlwaysOn: <code>true</code> if Always On is enabled; otherwise, <code>false</code>.
	AlwaysOn *bool `json:"alwaysOn,omitempty"`

	// ApiDefinition: Information about the formal API definition for the app.
	ApiDefinition *ApiDefinitionInfo `json:"apiDefinition,omitempty"`

	// ApiManagementConfig: Azure API management settings linked to the app.
	ApiManagementConfig *ApiManagementConfig `json:"apiManagementConfig,omitempty"`

	// AppCommandLine: App command line to launch.
	AppCommandLine *string `json:"appCommandLine,omitempty"`

	// AppSettings: Application settings.
	AppSettings []NameValuePair `json:"appSettings,omitempty"`

	// AutoHealEnabled: <code>true</code> if Auto Heal is enabled; otherwise, <code>false</code>.
	AutoHealEnabled *bool `json:"autoHealEnabled,omitempty"`

	// AutoHealRules: Auto Heal rules.
	AutoHealRules *AutoHealRules `json:"autoHealRules,omitempty"`

	// AutoSwapSlotName: Auto-swap slot name.
	AutoSwapSlotName *string `json:"autoSwapSlotName,omitempty"`

	// AzureStorageAccounts: List of Azure Storage Accounts.
	AzureStorageAccounts map[string]AzureStorageInfoValue `json:"azureStorageAccounts,omitempty"`

	// ConnectionStrings: Connection strings.
	ConnectionStrings []ConnStringInfo `json:"connectionStrings,omitempty"`

	// Cors: Cross-Origin Resource Sharing (CORS) settings.
	Cors *CorsSettings `json:"cors,omitempty"`

	// DefaultDocuments: Default documents.
	DefaultDocuments []string `json:"defaultDocuments,omitempty"`

	// DetailedErrorLoggingEnabled: <code>true</code> if detailed error logging is enabled; otherwise, <code>false</code>.
	DetailedErrorLoggingEnabled *bool `json:"detailedErrorLoggingEnabled,omitempty"`

	// DocumentRoot: Document root.
	DocumentRoot *string `json:"documentRoot,omitempty"`

	// Experiments: This is work around for polymorphic types.
	Experiments *Experiments `json:"experiments,omitempty"`

	// FtpsState: State of FTP / FTPS service
	FtpsState *SiteConfig_FtpsState `json:"ftpsState,omitempty"`

	// +kubebuilder:validation:Minimum=0
	// FunctionAppScaleLimit: Maximum number of workers that a site can scale out to.
	// This setting only applies to the Consumption and Elastic Premium Plans
	FunctionAppScaleLimit *int `json:"functionAppScaleLimit,omitempty"`

	// FunctionsRuntimeScaleMonitoringEnabled: Gets or sets a value indicating whether functions runtime scale monitoring is
	// enabled. When enabled,
	// the ScaleController will not monitor event sources directly, but will instead call to the
	// runtime to get scale status.
	FunctionsRuntimeScaleMonitoringEnabled *bool `json:"functionsRuntimeScaleMonitoringEnabled,omitempty"`

	// HandlerMappings: Handler mappings.
	HandlerMappings []HandlerMapping `json:"handlerMappings,omitempty"`

	// HealthCheckPath: Health check path
	HealthCheckPath *string `json:"healthCheckPath,omitempty"`

	// Http20Enabled: Http20Enabled: configures a web site to allow clients to connect over http2.0
	Http20Enabled *bool `json:"http20Enabled,omitempty"`

	// HttpLoggingEnabled: <code>true</code> if HTTP logging is enabled; otherwise, <code>false</code>.
	HttpLoggingEnabled *bool `json:"httpLoggingEnabled,omitempty"`

	// IpSecurityRestrictions: IP security restrictions for main.
	IpSecurityRestrictions []IpSecurityRestriction `json:"ipSecurityRestrictions,omitempty"`

	// JavaContainer: Java container.
	JavaContainer *string `json:"javaContainer,omitempty"`

	// JavaContainerVersion: Java container version.
	JavaContainerVersion *string `json:"javaContainerVersion,omitempty"`

	// JavaVersion: Java version.
	JavaVersion *string `json:"javaVersion,omitempty"`

	// KeyVaultReferenceIdentity: Identity to use for Key Vault Reference authentication.
	KeyVaultReferenceIdentity *string `json:"keyVaultReferenceIdentity,omitempty"`

	// Limits: Site limits.
	Limits *SiteLimits `json:"limits,omitempty"`

	// LinuxFxVersion: Linux App Framework and version
	LinuxFxVersion *string `json:"linuxFxVersion,omitempty"`

	// LoadBalancing: Site load balancing.
	LoadBalancing *SiteConfig_LoadBalancing `json:"loadBalancing,omitempty"`

	// LocalMySqlEnabled: <code>true</code> to enable local MySQL; otherwise, <code>false</code>.
	LocalMySqlEnabled *bool `json:"localMySqlEnabled,omitempty"`

	// LogsDirectorySizeLimit: HTTP logs directory size limit.
	LogsDirectorySizeLimit *int `json:"logsDirectorySizeLimit,omitempty"`

	// ManagedPipelineMode: Managed pipeline mode.
	ManagedPipelineMode *SiteConfig_ManagedPipelineMode `json:"managedPipelineMode,omitempty"`

	// ManagedServiceIdentityId: Managed Service Identity Id
	ManagedServiceIdentityId *int `json:"managedServiceIdentityId,omitempty"`

	// MinTlsVersion: MinTlsVersion: configures the minimum version of TLS required for SSL requests
	MinTlsVersion *SiteConfig_MinTlsVersion `json:"minTlsVersion,omitempty"`

	// +kubebuilder:validation:Maximum=20
	// +kubebuilder:validation:Minimum=0
	// MinimumElasticInstanceCount: Number of minimum instance count for a site
	// This setting only applies to the Elastic Plans
	MinimumElasticInstanceCount *int `json:"minimumElasticInstanceCount,omitempty"`

	// NetFrameworkVersion: .NET Framework version.
	NetFrameworkVersion *string `json:"netFrameworkVersion,omitempty"`

	// NodeVersion: Version of Node.js.
	NodeVersion *string `json:"nodeVersion,omitempty"`

	// NumberOfWorkers: Number of workers.
	NumberOfWorkers *int `json:"numberOfWorkers,omitempty"`

	// PhpVersion: Version of PHP.
	PhpVersion *string `json:"phpVersion,omitempty"`

	// PowerShellVersion: Version of PowerShell.
	PowerShellVersion *string `json:"powerShellVersion,omitempty"`

	// +kubebuilder:validation:Maximum=10
	// +kubebuilder:validation:Minimum=0
	// PreWarmedInstanceCount: Number of preWarmed instances.
	// This setting only applies to the Consumption and Elastic Plans
	PreWarmedInstanceCount *int `json:"preWarmedInstanceCount,omitempty"`

	// PublicNetworkAccess: Property to allow or block all public traffic.
	PublicNetworkAccess *string `json:"publicNetworkAccess,omitempty"`

	// PublishingUsername: Publishing user name.
	PublishingUsername *string `json:"publishingUsername,omitempty"`

	// Push: Push endpoint settings.
	Push *PushSettings `json:"push,omitempty"`

	// PythonVersion: Version of Python.
	PythonVersion *string `json:"pythonVersion,omitempty"`

	// RemoteDebuggingEnabled: <code>true</code> if remote debugging is enabled; otherwise, <code>false</code>.
	RemoteDebuggingEnabled *bool `json:"remoteDebuggingEnabled,omitempty"`

	// RemoteDebuggingVersion: Remote debugging version.
	RemoteDebuggingVersion *string `json:"remoteDebuggingVersion,omitempty"`

	// RequestTracingEnabled: <code>true</code> if request tracing is enabled; otherwise, <code>false</code>.
	RequestTracingEnabled *bool `json:"requestTracingEnabled,omitempty"`

	// RequestTracingExpirationTime: Request tracing expiration time.
	RequestTracingExpirationTime *string `json:"requestTracingExpirationTime,omitempty"`

	// ScmIpSecurityRestrictions: IP security restrictions for scm.
	ScmIpSecurityRestrictions []IpSecurityRestriction `json:"scmIpSecurityRestrictions,omitempty"`

	// ScmIpSecurityRestrictionsUseMain: IP security restrictions for scm to use main.
	ScmIpSecurityRestrictionsUseMain *bool `json:"scmIpSecurityRestrictionsUseMain,omitempty"`

	// ScmMinTlsVersion: ScmMinTlsVersion: configures the minimum version of TLS required for SSL requests for SCM site
	ScmMinTlsVersion *SiteConfig_ScmMinTlsVersion `json:"scmMinTlsVersion,omitempty"`

	// ScmType: SCM type.
	ScmType *SiteConfig_ScmType `json:"scmType,omitempty"`

	// TracingOptions: Tracing options.
	TracingOptions *string `json:"tracingOptions,omitempty"`

	// Use32BitWorkerProcess: <code>true</code> to use 32-bit worker process; otherwise, <code>false</code>.
	Use32BitWorkerProcess *bool `json:"use32BitWorkerProcess,omitempty"`

	// VirtualApplications: Virtual applications.
	VirtualApplications []VirtualApplication `json:"virtualApplications,omitempty"`

	// VnetName: Virtual Network name.
	VnetName *string `json:"vnetName,omitempty"`

	// VnetPrivatePortsCount: The number of private ports assigned to this app. These will be assigned dynamically on runtime.
	VnetPrivatePortsCount *int `json:"vnetPrivatePortsCount,omitempty"`

	// VnetRouteAllEnabled: Virtual Network Route All enabled. This causes all outbound traffic to have Virtual Network
	// Security Groups and User Defined Routes applied.
	VnetRouteAllEnabled *bool `json:"vnetRouteAllEnabled,omitempty"`

	// WebSocketsEnabled: <code>true</code> if WebSocket is enabled; otherwise, <code>false</code>.
	WebSocketsEnabled *bool `json:"webSocketsEnabled,omitempty"`

	// WebsiteTimeZone: Sets the time zone a site uses for generating timestamps. Compatible with Linux and Windows App
	// Service. Setting the WEBSITE_TIME_ZONE app setting takes precedence over this config. For Linux, expects tz database
	// values https://www.iana.org/time-zones (for a quick reference see
	// https://en.wikipedia.org/wiki/List_of_tz_database_time_zones). For Windows, expects one of the time zones listed under
	// HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Time Zones
	WebsiteTimeZone *string `json:"websiteTimeZone,omitempty"`

	// WindowsFxVersion: Xenon App Framework and version
	WindowsFxVersion *string `json:"windowsFxVersion,omitempty"`

	// XManagedServiceIdentityId: Explicit Managed Service Identity Id
	XManagedServiceIdentityId *int `json:"xManagedServiceIdentityId,omitempty"`
}

var _ genruntime.ARMTransformer = &SiteConfig{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (config *SiteConfig) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if config == nil {
		return nil, nil
	}
	result := &SiteConfig_ARM{}

	// Set property "AcrUseManagedIdentityCreds":
	if config.AcrUseManagedIdentityCreds != nil {
		acrUseManagedIdentityCreds := *config.AcrUseManagedIdentityCreds
		result.AcrUseManagedIdentityCreds = &acrUseManagedIdentityCreds
	}

	// Set property "AcrUserManagedIdentityID":
	if config.AcrUserManagedIdentityID != nil {
		acrUserManagedIdentityID := *config.AcrUserManagedIdentityID
		result.AcrUserManagedIdentityID = &acrUserManagedIdentityID
	}

	// Set property "AlwaysOn":
	if config.AlwaysOn != nil {
		alwaysOn := *config.AlwaysOn
		result.AlwaysOn = &alwaysOn
	}

	// Set property "ApiDefinition":
	if config.ApiDefinition != nil {
		apiDefinition_ARM, err := (*config.ApiDefinition).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		apiDefinition := *apiDefinition_ARM.(*ApiDefinitionInfo_ARM)
		result.ApiDefinition = &apiDefinition
	}

	// Set property "ApiManagementConfig":
	if config.ApiManagementConfig != nil {
		apiManagementConfig_ARM, err := (*config.ApiManagementConfig).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		apiManagementConfig := *apiManagementConfig_ARM.(*ApiManagementConfig_ARM)
		result.ApiManagementConfig = &apiManagementConfig
	}

	// Set property "AppCommandLine":
	if config.AppCommandLine != nil {
		appCommandLine := *config.AppCommandLine
		result.AppCommandLine = &appCommandLine
	}

	// Set property "AppSettings":
	for _, item := range config.AppSettings {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.AppSettings = append(result.AppSettings, *item_ARM.(*NameValuePair_ARM))
	}

	// Set property "AutoHealEnabled":
	if config.AutoHealEnabled != nil {
		autoHealEnabled := *config.AutoHealEnabled
		result.AutoHealEnabled = &autoHealEnabled
	}

	// Set property "AutoHealRules":
	if config.AutoHealRules != nil {
		autoHealRules_ARM, err := (*config.AutoHealRules).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		autoHealRules := *autoHealRules_ARM.(*AutoHealRules_ARM)
		result.AutoHealRules = &autoHealRules
	}

	// Set property "AutoSwapSlotName":
	if config.AutoSwapSlotName != nil {
		autoSwapSlotName := *config.AutoSwapSlotName
		result.AutoSwapSlotName = &autoSwapSlotName
	}

	// Set property "AzureStorageAccounts":
	if config.AzureStorageAccounts != nil {
		result.AzureStorageAccounts = make(map[string]AzureStorageInfoValue_ARM, len(config.AzureStorageAccounts))
		for key, value := range config.AzureStorageAccounts {
			value_ARM, err := value.ConvertToARM(resolved)
			if err != nil {
				return nil, err
			}
			result.AzureStorageAccounts[key] = *value_ARM.(*AzureStorageInfoValue_ARM)
		}
	}

	// Set property "ConnectionStrings":
	for _, item := range config.ConnectionStrings {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.ConnectionStrings = append(result.ConnectionStrings, *item_ARM.(*ConnStringInfo_ARM))
	}

	// Set property "Cors":
	if config.Cors != nil {
		cors_ARM, err := (*config.Cors).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		cors := *cors_ARM.(*CorsSettings_ARM)
		result.Cors = &cors
	}

	// Set property "DefaultDocuments":
	for _, item := range config.DefaultDocuments {
		result.DefaultDocuments = append(result.DefaultDocuments, item)
	}

	// Set property "DetailedErrorLoggingEnabled":
	if config.DetailedErrorLoggingEnabled != nil {
		detailedErrorLoggingEnabled := *config.DetailedErrorLoggingEnabled
		result.DetailedErrorLoggingEnabled = &detailedErrorLoggingEnabled
	}

	// Set property "DocumentRoot":
	if config.DocumentRoot != nil {
		documentRoot := *config.DocumentRoot
		result.DocumentRoot = &documentRoot
	}

	// Set property "Experiments":
	if config.Experiments != nil {
		experiments_ARM, err := (*config.Experiments).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		experiments := *experiments_ARM.(*Experiments_ARM)
		result.Experiments = &experiments
	}

	// Set property "FtpsState":
	if config.FtpsState != nil {
		ftpsState := *config.FtpsState
		result.FtpsState = &ftpsState
	}

	// Set property "FunctionAppScaleLimit":
	if config.FunctionAppScaleLimit != nil {
		functionAppScaleLimit := *config.FunctionAppScaleLimit
		result.FunctionAppScaleLimit = &functionAppScaleLimit
	}

	// Set property "FunctionsRuntimeScaleMonitoringEnabled":
	if config.FunctionsRuntimeScaleMonitoringEnabled != nil {
		functionsRuntimeScaleMonitoringEnabled := *config.FunctionsRuntimeScaleMonitoringEnabled
		result.FunctionsRuntimeScaleMonitoringEnabled = &functionsRuntimeScaleMonitoringEnabled
	}

	// Set property "HandlerMappings":
	for _, item := range config.HandlerMappings {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.HandlerMappings = append(result.HandlerMappings, *item_ARM.(*HandlerMapping_ARM))
	}

	// Set property "HealthCheckPath":
	if config.HealthCheckPath != nil {
		healthCheckPath := *config.HealthCheckPath
		result.HealthCheckPath = &healthCheckPath
	}

	// Set property "Http20Enabled":
	if config.Http20Enabled != nil {
		http20Enabled := *config.Http20Enabled
		result.Http20Enabled = &http20Enabled
	}

	// Set property "HttpLoggingEnabled":
	if config.HttpLoggingEnabled != nil {
		httpLoggingEnabled := *config.HttpLoggingEnabled
		result.HttpLoggingEnabled = &httpLoggingEnabled
	}

	// Set property "IpSecurityRestrictions":
	for _, item := range config.IpSecurityRestrictions {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.IpSecurityRestrictions = append(result.IpSecurityRestrictions, *item_ARM.(*IpSecurityRestriction_ARM))
	}

	// Set property "JavaContainer":
	if config.JavaContainer != nil {
		javaContainer := *config.JavaContainer
		result.JavaContainer = &javaContainer
	}

	// Set property "JavaContainerVersion":
	if config.JavaContainerVersion != nil {
		javaContainerVersion := *config.JavaContainerVersion
		result.JavaContainerVersion = &javaContainerVersion
	}

	// Set property "JavaVersion":
	if config.JavaVersion != nil {
		javaVersion := *config.JavaVersion
		result.JavaVersion = &javaVersion
	}

	// Set property "KeyVaultReferenceIdentity":
	if config.KeyVaultReferenceIdentity != nil {
		keyVaultReferenceIdentity := *config.KeyVaultReferenceIdentity
		result.KeyVaultReferenceIdentity = &keyVaultReferenceIdentity
	}

	// Set property "Limits":
	if config.Limits != nil {
		limits_ARM, err := (*config.Limits).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		limits := *limits_ARM.(*SiteLimits_ARM)
		result.Limits = &limits
	}

	// Set property "LinuxFxVersion":
	if config.LinuxFxVersion != nil {
		linuxFxVersion := *config.LinuxFxVersion
		result.LinuxFxVersion = &linuxFxVersion
	}

	// Set property "LoadBalancing":
	if config.LoadBalancing != nil {
		loadBalancing := *config.LoadBalancing
		result.LoadBalancing = &loadBalancing
	}

	// Set property "LocalMySqlEnabled":
	if config.LocalMySqlEnabled != nil {
		localMySqlEnabled := *config.LocalMySqlEnabled
		result.LocalMySqlEnabled = &localMySqlEnabled
	}

	// Set property "LogsDirectorySizeLimit":
	if config.LogsDirectorySizeLimit != nil {
		logsDirectorySizeLimit := *config.LogsDirectorySizeLimit
		result.LogsDirectorySizeLimit = &logsDirectorySizeLimit
	}

	// Set property "ManagedPipelineMode":
	if config.ManagedPipelineMode != nil {
		managedPipelineMode := *config.ManagedPipelineMode
		result.ManagedPipelineMode = &managedPipelineMode
	}

	// Set property "ManagedServiceIdentityId":
	if config.ManagedServiceIdentityId != nil {
		managedServiceIdentityId := *config.ManagedServiceIdentityId
		result.ManagedServiceIdentityId = &managedServiceIdentityId
	}

	// Set property "MinTlsVersion":
	if config.MinTlsVersion != nil {
		minTlsVersion := *config.MinTlsVersion
		result.MinTlsVersion = &minTlsVersion
	}

	// Set property "MinimumElasticInstanceCount":
	if config.MinimumElasticInstanceCount != nil {
		minimumElasticInstanceCount := *config.MinimumElasticInstanceCount
		result.MinimumElasticInstanceCount = &minimumElasticInstanceCount
	}

	// Set property "NetFrameworkVersion":
	if config.NetFrameworkVersion != nil {
		netFrameworkVersion := *config.NetFrameworkVersion
		result.NetFrameworkVersion = &netFrameworkVersion
	}

	// Set property "NodeVersion":
	if config.NodeVersion != nil {
		nodeVersion := *config.NodeVersion
		result.NodeVersion = &nodeVersion
	}

	// Set property "NumberOfWorkers":
	if config.NumberOfWorkers != nil {
		numberOfWorkers := *config.NumberOfWorkers
		result.NumberOfWorkers = &numberOfWorkers
	}

	// Set property "PhpVersion":
	if config.PhpVersion != nil {
		phpVersion := *config.PhpVersion
		result.PhpVersion = &phpVersion
	}

	// Set property "PowerShellVersion":
	if config.PowerShellVersion != nil {
		powerShellVersion := *config.PowerShellVersion
		result.PowerShellVersion = &powerShellVersion
	}

	// Set property "PreWarmedInstanceCount":
	if config.PreWarmedInstanceCount != nil {
		preWarmedInstanceCount := *config.PreWarmedInstanceCount
		result.PreWarmedInstanceCount = &preWarmedInstanceCount
	}

	// Set property "PublicNetworkAccess":
	if config.PublicNetworkAccess != nil {
		publicNetworkAccess := *config.PublicNetworkAccess
		result.PublicNetworkAccess = &publicNetworkAccess
	}

	// Set property "PublishingUsername":
	if config.PublishingUsername != nil {
		publishingUsername := *config.PublishingUsername
		result.PublishingUsername = &publishingUsername
	}

	// Set property "Push":
	if config.Push != nil {
		push_ARM, err := (*config.Push).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		push := *push_ARM.(*PushSettings_ARM)
		result.Push = &push
	}

	// Set property "PythonVersion":
	if config.PythonVersion != nil {
		pythonVersion := *config.PythonVersion
		result.PythonVersion = &pythonVersion
	}

	// Set property "RemoteDebuggingEnabled":
	if config.RemoteDebuggingEnabled != nil {
		remoteDebuggingEnabled := *config.RemoteDebuggingEnabled
		result.RemoteDebuggingEnabled = &remoteDebuggingEnabled
	}

	// Set property "RemoteDebuggingVersion":
	if config.RemoteDebuggingVersion != nil {
		remoteDebuggingVersion := *config.RemoteDebuggingVersion
		result.RemoteDebuggingVersion = &remoteDebuggingVersion
	}

	// Set property "RequestTracingEnabled":
	if config.RequestTracingEnabled != nil {
		requestTracingEnabled := *config.RequestTracingEnabled
		result.RequestTracingEnabled = &requestTracingEnabled
	}

	// Set property "RequestTracingExpirationTime":
	if config.RequestTracingExpirationTime != nil {
		requestTracingExpirationTime := *config.RequestTracingExpirationTime
		result.RequestTracingExpirationTime = &requestTracingExpirationTime
	}

	// Set property "ScmIpSecurityRestrictions":
	for _, item := range config.ScmIpSecurityRestrictions {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.ScmIpSecurityRestrictions = append(result.ScmIpSecurityRestrictions, *item_ARM.(*IpSecurityRestriction_ARM))
	}

	// Set property "ScmIpSecurityRestrictionsUseMain":
	if config.ScmIpSecurityRestrictionsUseMain != nil {
		scmIpSecurityRestrictionsUseMain := *config.ScmIpSecurityRestrictionsUseMain
		result.ScmIpSecurityRestrictionsUseMain = &scmIpSecurityRestrictionsUseMain
	}

	// Set property "ScmMinTlsVersion":
	if config.ScmMinTlsVersion != nil {
		scmMinTlsVersion := *config.ScmMinTlsVersion
		result.ScmMinTlsVersion = &scmMinTlsVersion
	}

	// Set property "ScmType":
	if config.ScmType != nil {
		scmType := *config.ScmType
		result.ScmType = &scmType
	}

	// Set property "TracingOptions":
	if config.TracingOptions != nil {
		tracingOptions := *config.TracingOptions
		result.TracingOptions = &tracingOptions
	}

	// Set property "Use32BitWorkerProcess":
	if config.Use32BitWorkerProcess != nil {
		use32BitWorkerProcess := *config.Use32BitWorkerProcess
		result.Use32BitWorkerProcess = &use32BitWorkerProcess
	}

	// Set property "VirtualApplications":
	for _, item := range config.VirtualApplications {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.VirtualApplications = append(result.VirtualApplications, *item_ARM.(*VirtualApplication_ARM))
	}

	// Set property "VnetName":
	if config.VnetName != nil {
		vnetName := *config.VnetName
		result.VnetName = &vnetName
	}

	// Set property "VnetPrivatePortsCount":
	if config.VnetPrivatePortsCount != nil {
		vnetPrivatePortsCount := *config.VnetPrivatePortsCount
		result.VnetPrivatePortsCount = &vnetPrivatePortsCount
	}

	// Set property "VnetRouteAllEnabled":
	if config.VnetRouteAllEnabled != nil {
		vnetRouteAllEnabled := *config.VnetRouteAllEnabled
		result.VnetRouteAllEnabled = &vnetRouteAllEnabled
	}

	// Set property "WebSocketsEnabled":
	if config.WebSocketsEnabled != nil {
		webSocketsEnabled := *config.WebSocketsEnabled
		result.WebSocketsEnabled = &webSocketsEnabled
	}

	// Set property "WebsiteTimeZone":
	if config.WebsiteTimeZone != nil {
		websiteTimeZone := *config.WebsiteTimeZone
		result.WebsiteTimeZone = &websiteTimeZone
	}

	// Set property "WindowsFxVersion":
	if config.WindowsFxVersion != nil {
		windowsFxVersion := *config.WindowsFxVersion
		result.WindowsFxVersion = &windowsFxVersion
	}

	// Set property "XManagedServiceIdentityId":
	if config.XManagedServiceIdentityId != nil {
		xManagedServiceIdentityId := *config.XManagedServiceIdentityId
		result.XManagedServiceIdentityId = &xManagedServiceIdentityId
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (config *SiteConfig) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &SiteConfig_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (config *SiteConfig) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(SiteConfig_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected SiteConfig_ARM, got %T", armInput)
	}

	// Set property "AcrUseManagedIdentityCreds":
	if typedInput.AcrUseManagedIdentityCreds != nil {
		acrUseManagedIdentityCreds := *typedInput.AcrUseManagedIdentityCreds
		config.AcrUseManagedIdentityCreds = &acrUseManagedIdentityCreds
	}

	// Set property "AcrUserManagedIdentityID":
	if typedInput.AcrUserManagedIdentityID != nil {
		acrUserManagedIdentityID := *typedInput.AcrUserManagedIdentityID
		config.AcrUserManagedIdentityID = &acrUserManagedIdentityID
	}

	// Set property "AlwaysOn":
	if typedInput.AlwaysOn != nil {
		alwaysOn := *typedInput.AlwaysOn
		config.AlwaysOn = &alwaysOn
	}

	// Set property "ApiDefinition":
	if typedInput.ApiDefinition != nil {
		var apiDefinition1 ApiDefinitionInfo
		err := apiDefinition1.PopulateFromARM(owner, *typedInput.ApiDefinition)
		if err != nil {
			return err
		}
		apiDefinition := apiDefinition1
		config.ApiDefinition = &apiDefinition
	}

	// Set property "ApiManagementConfig":
	if typedInput.ApiManagementConfig != nil {
		var apiManagementConfig1 ApiManagementConfig
		err := apiManagementConfig1.PopulateFromARM(owner, *typedInput.ApiManagementConfig)
		if err != nil {
			return err
		}
		apiManagementConfig := apiManagementConfig1
		config.ApiManagementConfig = &apiManagementConfig
	}

	// Set property "AppCommandLine":
	if typedInput.AppCommandLine != nil {
		appCommandLine := *typedInput.AppCommandLine
		config.AppCommandLine = &appCommandLine
	}

	// Set property "AppSettings":
	for _, item := range typedInput.AppSettings {
		var item1 NameValuePair
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		config.AppSettings = append(config.AppSettings, item1)
	}

	// Set property "AutoHealEnabled":
	if typedInput.AutoHealEnabled != nil {
		autoHealEnabled := *typedInput.AutoHealEnabled
		config.AutoHealEnabled = &autoHealEnabled
	}

	// Set property "AutoHealRules":
	if typedInput.AutoHealRules != nil {
		var autoHealRules1 AutoHealRules
		err := autoHealRules1.PopulateFromARM(owner, *typedInput.AutoHealRules)
		if err != nil {
			return err
		}
		autoHealRules := autoHealRules1
		config.AutoHealRules = &autoHealRules
	}

	// Set property "AutoSwapSlotName":
	if typedInput.AutoSwapSlotName != nil {
		autoSwapSlotName := *typedInput.AutoSwapSlotName
		config.AutoSwapSlotName = &autoSwapSlotName
	}

	// Set property "AzureStorageAccounts":
	if typedInput.AzureStorageAccounts != nil {
		config.AzureStorageAccounts = make(map[string]AzureStorageInfoValue, len(typedInput.AzureStorageAccounts))
		for key, value := range typedInput.AzureStorageAccounts {
			var value1 AzureStorageInfoValue
			err := value1.PopulateFromARM(owner, value)
			if err != nil {
				return err
			}
			config.AzureStorageAccounts[key] = value1
		}
	}

	// Set property "ConnectionStrings":
	for _, item := range typedInput.ConnectionStrings {
		var item1 ConnStringInfo
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		config.ConnectionStrings = append(config.ConnectionStrings, item1)
	}

	// Set property "Cors":
	if typedInput.Cors != nil {
		var cors1 CorsSettings
		err := cors1.PopulateFromARM(owner, *typedInput.Cors)
		if err != nil {
			return err
		}
		cors := cors1
		config.Cors = &cors
	}

	// Set property "DefaultDocuments":
	for _, item := range typedInput.DefaultDocuments {
		config.DefaultDocuments = append(config.DefaultDocuments, item)
	}

	// Set property "DetailedErrorLoggingEnabled":
	if typedInput.DetailedErrorLoggingEnabled != nil {
		detailedErrorLoggingEnabled := *typedInput.DetailedErrorLoggingEnabled
		config.DetailedErrorLoggingEnabled = &detailedErrorLoggingEnabled
	}

	// Set property "DocumentRoot":
	if typedInput.DocumentRoot != nil {
		documentRoot := *typedInput.DocumentRoot
		config.DocumentRoot = &documentRoot
	}

	// Set property "Experiments":
	if typedInput.Experiments != nil {
		var experiments1 Experiments
		err := experiments1.PopulateFromARM(owner, *typedInput.Experiments)
		if err != nil {
			return err
		}
		experiments := experiments1
		config.Experiments = &experiments
	}

	// Set property "FtpsState":
	if typedInput.FtpsState != nil {
		ftpsState := *typedInput.FtpsState
		config.FtpsState = &ftpsState
	}

	// Set property "FunctionAppScaleLimit":
	if typedInput.FunctionAppScaleLimit != nil {
		functionAppScaleLimit := *typedInput.FunctionAppScaleLimit
		config.FunctionAppScaleLimit = &functionAppScaleLimit
	}

	// Set property "FunctionsRuntimeScaleMonitoringEnabled":
	if typedInput.FunctionsRuntimeScaleMonitoringEnabled != nil {
		functionsRuntimeScaleMonitoringEnabled := *typedInput.FunctionsRuntimeScaleMonitoringEnabled
		config.FunctionsRuntimeScaleMonitoringEnabled = &functionsRuntimeScaleMonitoringEnabled
	}

	// Set property "HandlerMappings":
	for _, item := range typedInput.HandlerMappings {
		var item1 HandlerMapping
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		config.HandlerMappings = append(config.HandlerMappings, item1)
	}

	// Set property "HealthCheckPath":
	if typedInput.HealthCheckPath != nil {
		healthCheckPath := *typedInput.HealthCheckPath
		config.HealthCheckPath = &healthCheckPath
	}

	// Set property "Http20Enabled":
	if typedInput.Http20Enabled != nil {
		http20Enabled := *typedInput.Http20Enabled
		config.Http20Enabled = &http20Enabled
	}

	// Set property "HttpLoggingEnabled":
	if typedInput.HttpLoggingEnabled != nil {
		httpLoggingEnabled := *typedInput.HttpLoggingEnabled
		config.HttpLoggingEnabled = &httpLoggingEnabled
	}

	// Set property "IpSecurityRestrictions":
	for _, item := range typedInput.IpSecurityRestrictions {
		var item1 IpSecurityRestriction
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		config.IpSecurityRestrictions = append(config.IpSecurityRestrictions, item1)
	}

	// Set property "JavaContainer":
	if typedInput.JavaContainer != nil {
		javaContainer := *typedInput.JavaContainer
		config.JavaContainer = &javaContainer
	}

	// Set property "JavaContainerVersion":
	if typedInput.JavaContainerVersion != nil {
		javaContainerVersion := *typedInput.JavaContainerVersion
		config.JavaContainerVersion = &javaContainerVersion
	}

	// Set property "JavaVersion":
	if typedInput.JavaVersion != nil {
		javaVersion := *typedInput.JavaVersion
		config.JavaVersion = &javaVersion
	}

	// Set property "KeyVaultReferenceIdentity":
	if typedInput.KeyVaultReferenceIdentity != nil {
		keyVaultReferenceIdentity := *typedInput.KeyVaultReferenceIdentity
		config.KeyVaultReferenceIdentity = &keyVaultReferenceIdentity
	}

	// Set property "Limits":
	if typedInput.Limits != nil {
		var limits1 SiteLimits
		err := limits1.PopulateFromARM(owner, *typedInput.Limits)
		if err != nil {
			return err
		}
		limits := limits1
		config.Limits = &limits
	}

	// Set property "LinuxFxVersion":
	if typedInput.LinuxFxVersion != nil {
		linuxFxVersion := *typedInput.LinuxFxVersion
		config.LinuxFxVersion = &linuxFxVersion
	}

	// Set property "LoadBalancing":
	if typedInput.LoadBalancing != nil {
		loadBalancing := *typedInput.LoadBalancing
		config.LoadBalancing = &loadBalancing
	}

	// Set property "LocalMySqlEnabled":
	if typedInput.LocalMySqlEnabled != nil {
		localMySqlEnabled := *typedInput.LocalMySqlEnabled
		config.LocalMySqlEnabled = &localMySqlEnabled
	}

	// Set property "LogsDirectorySizeLimit":
	if typedInput.LogsDirectorySizeLimit != nil {
		logsDirectorySizeLimit := *typedInput.LogsDirectorySizeLimit
		config.LogsDirectorySizeLimit = &logsDirectorySizeLimit
	}

	// Set property "ManagedPipelineMode":
	if typedInput.ManagedPipelineMode != nil {
		managedPipelineMode := *typedInput.ManagedPipelineMode
		config.ManagedPipelineMode = &managedPipelineMode
	}

	// Set property "ManagedServiceIdentityId":
	if typedInput.ManagedServiceIdentityId != nil {
		managedServiceIdentityId := *typedInput.ManagedServiceIdentityId
		config.ManagedServiceIdentityId = &managedServiceIdentityId
	}

	// Set property "MinTlsVersion":
	if typedInput.MinTlsVersion != nil {
		minTlsVersion := *typedInput.MinTlsVersion
		config.MinTlsVersion = &minTlsVersion
	}

	// Set property "MinimumElasticInstanceCount":
	if typedInput.MinimumElasticInstanceCount != nil {
		minimumElasticInstanceCount := *typedInput.MinimumElasticInstanceCount
		config.MinimumElasticInstanceCount = &minimumElasticInstanceCount
	}

	// Set property "NetFrameworkVersion":
	if typedInput.NetFrameworkVersion != nil {
		netFrameworkVersion := *typedInput.NetFrameworkVersion
		config.NetFrameworkVersion = &netFrameworkVersion
	}

	// Set property "NodeVersion":
	if typedInput.NodeVersion != nil {
		nodeVersion := *typedInput.NodeVersion
		config.NodeVersion = &nodeVersion
	}

	// Set property "NumberOfWorkers":
	if typedInput.NumberOfWorkers != nil {
		numberOfWorkers := *typedInput.NumberOfWorkers
		config.NumberOfWorkers = &numberOfWorkers
	}

	// Set property "PhpVersion":
	if typedInput.PhpVersion != nil {
		phpVersion := *typedInput.PhpVersion
		config.PhpVersion = &phpVersion
	}

	// Set property "PowerShellVersion":
	if typedInput.PowerShellVersion != nil {
		powerShellVersion := *typedInput.PowerShellVersion
		config.PowerShellVersion = &powerShellVersion
	}

	// Set property "PreWarmedInstanceCount":
	if typedInput.PreWarmedInstanceCount != nil {
		preWarmedInstanceCount := *typedInput.PreWarmedInstanceCount
		config.PreWarmedInstanceCount = &preWarmedInstanceCount
	}

	// Set property "PublicNetworkAccess":
	if typedInput.PublicNetworkAccess != nil {
		publicNetworkAccess := *typedInput.PublicNetworkAccess
		config.PublicNetworkAccess = &publicNetworkAccess
	}

	// Set property "PublishingUsername":
	if typedInput.PublishingUsername != nil {
		publishingUsername := *typedInput.PublishingUsername
		config.PublishingUsername = &publishingUsername
	}

	// Set property "Push":
	if typedInput.Push != nil {
		var push1 PushSettings
		err := push1.PopulateFromARM(owner, *typedInput.Push)
		if err != nil {
			return err
		}
		push := push1
		config.Push = &push
	}

	// Set property "PythonVersion":
	if typedInput.PythonVersion != nil {
		pythonVersion := *typedInput.PythonVersion
		config.PythonVersion = &pythonVersion
	}

	// Set property "RemoteDebuggingEnabled":
	if typedInput.RemoteDebuggingEnabled != nil {
		remoteDebuggingEnabled := *typedInput.RemoteDebuggingEnabled
		config.RemoteDebuggingEnabled = &remoteDebuggingEnabled
	}

	// Set property "RemoteDebuggingVersion":
	if typedInput.RemoteDebuggingVersion != nil {
		remoteDebuggingVersion := *typedInput.RemoteDebuggingVersion
		config.RemoteDebuggingVersion = &remoteDebuggingVersion
	}

	// Set property "RequestTracingEnabled":
	if typedInput.RequestTracingEnabled != nil {
		requestTracingEnabled := *typedInput.RequestTracingEnabled
		config.RequestTracingEnabled = &requestTracingEnabled
	}

	// Set property "RequestTracingExpirationTime":
	if typedInput.RequestTracingExpirationTime != nil {
		requestTracingExpirationTime := *typedInput.RequestTracingExpirationTime
		config.RequestTracingExpirationTime = &requestTracingExpirationTime
	}

	// Set property "ScmIpSecurityRestrictions":
	for _, item := range typedInput.ScmIpSecurityRestrictions {
		var item1 IpSecurityRestriction
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		config.ScmIpSecurityRestrictions = append(config.ScmIpSecurityRestrictions, item1)
	}

	// Set property "ScmIpSecurityRestrictionsUseMain":
	if typedInput.ScmIpSecurityRestrictionsUseMain != nil {
		scmIpSecurityRestrictionsUseMain := *typedInput.ScmIpSecurityRestrictionsUseMain
		config.ScmIpSecurityRestrictionsUseMain = &scmIpSecurityRestrictionsUseMain
	}

	// Set property "ScmMinTlsVersion":
	if typedInput.ScmMinTlsVersion != nil {
		scmMinTlsVersion := *typedInput.ScmMinTlsVersion
		config.ScmMinTlsVersion = &scmMinTlsVersion
	}

	// Set property "ScmType":
	if typedInput.ScmType != nil {
		scmType := *typedInput.ScmType
		config.ScmType = &scmType
	}

	// Set property "TracingOptions":
	if typedInput.TracingOptions != nil {
		tracingOptions := *typedInput.TracingOptions
		config.TracingOptions = &tracingOptions
	}

	// Set property "Use32BitWorkerProcess":
	if typedInput.Use32BitWorkerProcess != nil {
		use32BitWorkerProcess := *typedInput.Use32BitWorkerProcess
		config.Use32BitWorkerProcess = &use32BitWorkerProcess
	}

	// Set property "VirtualApplications":
	for _, item := range typedInput.VirtualApplications {
		var item1 VirtualApplication
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		config.VirtualApplications = append(config.VirtualApplications, item1)
	}

	// Set property "VnetName":
	if typedInput.VnetName != nil {
		vnetName := *typedInput.VnetName
		config.VnetName = &vnetName
	}

	// Set property "VnetPrivatePortsCount":
	if typedInput.VnetPrivatePortsCount != nil {
		vnetPrivatePortsCount := *typedInput.VnetPrivatePortsCount
		config.VnetPrivatePortsCount = &vnetPrivatePortsCount
	}

	// Set property "VnetRouteAllEnabled":
	if typedInput.VnetRouteAllEnabled != nil {
		vnetRouteAllEnabled := *typedInput.VnetRouteAllEnabled
		config.VnetRouteAllEnabled = &vnetRouteAllEnabled
	}

	// Set property "WebSocketsEnabled":
	if typedInput.WebSocketsEnabled != nil {
		webSocketsEnabled := *typedInput.WebSocketsEnabled
		config.WebSocketsEnabled = &webSocketsEnabled
	}

	// Set property "WebsiteTimeZone":
	if typedInput.WebsiteTimeZone != nil {
		websiteTimeZone := *typedInput.WebsiteTimeZone
		config.WebsiteTimeZone = &websiteTimeZone
	}

	// Set property "WindowsFxVersion":
	if typedInput.WindowsFxVersion != nil {
		windowsFxVersion := *typedInput.WindowsFxVersion
		config.WindowsFxVersion = &windowsFxVersion
	}

	// Set property "XManagedServiceIdentityId":
	if typedInput.XManagedServiceIdentityId != nil {
		xManagedServiceIdentityId := *typedInput.XManagedServiceIdentityId
		config.XManagedServiceIdentityId = &xManagedServiceIdentityId
	}

	// No error
	return nil
}

// AssignProperties_From_SiteConfig populates our SiteConfig from the provided source SiteConfig
func (config *SiteConfig) AssignProperties_From_SiteConfig(source *v20220301s.SiteConfig) error {

	// AcrUseManagedIdentityCreds
	if source.AcrUseManagedIdentityCreds != nil {
		acrUseManagedIdentityCred := *source.AcrUseManagedIdentityCreds
		config.AcrUseManagedIdentityCreds = &acrUseManagedIdentityCred
	} else {
		config.AcrUseManagedIdentityCreds = nil
	}

	// AcrUserManagedIdentityID
	config.AcrUserManagedIdentityID = genruntime.ClonePointerToString(source.AcrUserManagedIdentityID)

	// AlwaysOn
	if source.AlwaysOn != nil {
		alwaysOn := *source.AlwaysOn
		config.AlwaysOn = &alwaysOn
	} else {
		config.AlwaysOn = nil
	}

	// ApiDefinition
	if source.ApiDefinition != nil {
		var apiDefinition ApiDefinitionInfo
		err := apiDefinition.AssignProperties_From_ApiDefinitionInfo(source.ApiDefinition)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ApiDefinitionInfo() to populate field ApiDefinition")
		}
		config.ApiDefinition = &apiDefinition
	} else {
		config.ApiDefinition = nil
	}

	// ApiManagementConfig
	if source.ApiManagementConfig != nil {
		var apiManagementConfig ApiManagementConfig
		err := apiManagementConfig.AssignProperties_From_ApiManagementConfig(source.ApiManagementConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ApiManagementConfig() to populate field ApiManagementConfig")
		}
		config.ApiManagementConfig = &apiManagementConfig
	} else {
		config.ApiManagementConfig = nil
	}

	// AppCommandLine
	config.AppCommandLine = genruntime.ClonePointerToString(source.AppCommandLine)

	// AppSettings
	if source.AppSettings != nil {
		appSettingList := make([]NameValuePair, len(source.AppSettings))
		for appSettingIndex, appSettingItem := range source.AppSettings {
			// Shadow the loop variable to avoid aliasing
			appSettingItem := appSettingItem
			var appSetting NameValuePair
			err := appSetting.AssignProperties_From_NameValuePair(&appSettingItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_NameValuePair() to populate field AppSettings")
			}
			appSettingList[appSettingIndex] = appSetting
		}
		config.AppSettings = appSettingList
	} else {
		config.AppSettings = nil
	}

	// AutoHealEnabled
	if source.AutoHealEnabled != nil {
		autoHealEnabled := *source.AutoHealEnabled
		config.AutoHealEnabled = &autoHealEnabled
	} else {
		config.AutoHealEnabled = nil
	}

	// AutoHealRules
	if source.AutoHealRules != nil {
		var autoHealRule AutoHealRules
		err := autoHealRule.AssignProperties_From_AutoHealRules(source.AutoHealRules)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AutoHealRules() to populate field AutoHealRules")
		}
		config.AutoHealRules = &autoHealRule
	} else {
		config.AutoHealRules = nil
	}

	// AutoSwapSlotName
	config.AutoSwapSlotName = genruntime.ClonePointerToString(source.AutoSwapSlotName)

	// AzureStorageAccounts
	if source.AzureStorageAccounts != nil {
		azureStorageAccountMap := make(map[string]AzureStorageInfoValue, len(source.AzureStorageAccounts))
		for azureStorageAccountKey, azureStorageAccountValue := range source.AzureStorageAccounts {
			// Shadow the loop variable to avoid aliasing
			azureStorageAccountValue := azureStorageAccountValue
			var azureStorageAccount AzureStorageInfoValue
			err := azureStorageAccount.AssignProperties_From_AzureStorageInfoValue(&azureStorageAccountValue)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_AzureStorageInfoValue() to populate field AzureStorageAccounts")
			}
			azureStorageAccountMap[azureStorageAccountKey] = azureStorageAccount
		}
		config.AzureStorageAccounts = azureStorageAccountMap
	} else {
		config.AzureStorageAccounts = nil
	}

	// ConnectionStrings
	if source.ConnectionStrings != nil {
		connectionStringList := make([]ConnStringInfo, len(source.ConnectionStrings))
		for connectionStringIndex, connectionStringItem := range source.ConnectionStrings {
			// Shadow the loop variable to avoid aliasing
			connectionStringItem := connectionStringItem
			var connectionString ConnStringInfo
			err := connectionString.AssignProperties_From_ConnStringInfo(&connectionStringItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ConnStringInfo() to populate field ConnectionStrings")
			}
			connectionStringList[connectionStringIndex] = connectionString
		}
		config.ConnectionStrings = connectionStringList
	} else {
		config.ConnectionStrings = nil
	}

	// Cors
	if source.Cors != nil {
		var cor CorsSettings
		err := cor.AssignProperties_From_CorsSettings(source.Cors)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_CorsSettings() to populate field Cors")
		}
		config.Cors = &cor
	} else {
		config.Cors = nil
	}

	// DefaultDocuments
	config.DefaultDocuments = genruntime.CloneSliceOfString(source.DefaultDocuments)

	// DetailedErrorLoggingEnabled
	if source.DetailedErrorLoggingEnabled != nil {
		detailedErrorLoggingEnabled := *source.DetailedErrorLoggingEnabled
		config.DetailedErrorLoggingEnabled = &detailedErrorLoggingEnabled
	} else {
		config.DetailedErrorLoggingEnabled = nil
	}

	// DocumentRoot
	config.DocumentRoot = genruntime.ClonePointerToString(source.DocumentRoot)

	// Experiments
	if source.Experiments != nil {
		var experiment Experiments
		err := experiment.AssignProperties_From_Experiments(source.Experiments)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Experiments() to populate field Experiments")
		}
		config.Experiments = &experiment
	} else {
		config.Experiments = nil
	}

	// FtpsState
	if source.FtpsState != nil {
		ftpsState := SiteConfig_FtpsState(*source.FtpsState)
		config.FtpsState = &ftpsState
	} else {
		config.FtpsState = nil
	}

	// FunctionAppScaleLimit
	if source.FunctionAppScaleLimit != nil {
		functionAppScaleLimit := *source.FunctionAppScaleLimit
		config.FunctionAppScaleLimit = &functionAppScaleLimit
	} else {
		config.FunctionAppScaleLimit = nil
	}

	// FunctionsRuntimeScaleMonitoringEnabled
	if source.FunctionsRuntimeScaleMonitoringEnabled != nil {
		functionsRuntimeScaleMonitoringEnabled := *source.FunctionsRuntimeScaleMonitoringEnabled
		config.FunctionsRuntimeScaleMonitoringEnabled = &functionsRuntimeScaleMonitoringEnabled
	} else {
		config.FunctionsRuntimeScaleMonitoringEnabled = nil
	}

	// HandlerMappings
	if source.HandlerMappings != nil {
		handlerMappingList := make([]HandlerMapping, len(source.HandlerMappings))
		for handlerMappingIndex, handlerMappingItem := range source.HandlerMappings {
			// Shadow the loop variable to avoid aliasing
			handlerMappingItem := handlerMappingItem
			var handlerMapping HandlerMapping
			err := handlerMapping.AssignProperties_From_HandlerMapping(&handlerMappingItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_HandlerMapping() to populate field HandlerMappings")
			}
			handlerMappingList[handlerMappingIndex] = handlerMapping
		}
		config.HandlerMappings = handlerMappingList
	} else {
		config.HandlerMappings = nil
	}

	// HealthCheckPath
	config.HealthCheckPath = genruntime.ClonePointerToString(source.HealthCheckPath)

	// Http20Enabled
	if source.Http20Enabled != nil {
		http20Enabled := *source.Http20Enabled
		config.Http20Enabled = &http20Enabled
	} else {
		config.Http20Enabled = nil
	}

	// HttpLoggingEnabled
	if source.HttpLoggingEnabled != nil {
		httpLoggingEnabled := *source.HttpLoggingEnabled
		config.HttpLoggingEnabled = &httpLoggingEnabled
	} else {
		config.HttpLoggingEnabled = nil
	}

	// IpSecurityRestrictions
	if source.IpSecurityRestrictions != nil {
		ipSecurityRestrictionList := make([]IpSecurityRestriction, len(source.IpSecurityRestrictions))
		for ipSecurityRestrictionIndex, ipSecurityRestrictionItem := range source.IpSecurityRestrictions {
			// Shadow the loop variable to avoid aliasing
			ipSecurityRestrictionItem := ipSecurityRestrictionItem
			var ipSecurityRestriction IpSecurityRestriction
			err := ipSecurityRestriction.AssignProperties_From_IpSecurityRestriction(&ipSecurityRestrictionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_IpSecurityRestriction() to populate field IpSecurityRestrictions")
			}
			ipSecurityRestrictionList[ipSecurityRestrictionIndex] = ipSecurityRestriction
		}
		config.IpSecurityRestrictions = ipSecurityRestrictionList
	} else {
		config.IpSecurityRestrictions = nil
	}

	// JavaContainer
	config.JavaContainer = genruntime.ClonePointerToString(source.JavaContainer)

	// JavaContainerVersion
	config.JavaContainerVersion = genruntime.ClonePointerToString(source.JavaContainerVersion)

	// JavaVersion
	config.JavaVersion = genruntime.ClonePointerToString(source.JavaVersion)

	// KeyVaultReferenceIdentity
	config.KeyVaultReferenceIdentity = genruntime.ClonePointerToString(source.KeyVaultReferenceIdentity)

	// Limits
	if source.Limits != nil {
		var limit SiteLimits
		err := limit.AssignProperties_From_SiteLimits(source.Limits)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SiteLimits() to populate field Limits")
		}
		config.Limits = &limit
	} else {
		config.Limits = nil
	}

	// LinuxFxVersion
	config.LinuxFxVersion = genruntime.ClonePointerToString(source.LinuxFxVersion)

	// LoadBalancing
	if source.LoadBalancing != nil {
		loadBalancing := SiteConfig_LoadBalancing(*source.LoadBalancing)
		config.LoadBalancing = &loadBalancing
	} else {
		config.LoadBalancing = nil
	}

	// LocalMySqlEnabled
	if source.LocalMySqlEnabled != nil {
		localMySqlEnabled := *source.LocalMySqlEnabled
		config.LocalMySqlEnabled = &localMySqlEnabled
	} else {
		config.LocalMySqlEnabled = nil
	}

	// LogsDirectorySizeLimit
	config.LogsDirectorySizeLimit = genruntime.ClonePointerToInt(source.LogsDirectorySizeLimit)

	// ManagedPipelineMode
	if source.ManagedPipelineMode != nil {
		managedPipelineMode := SiteConfig_ManagedPipelineMode(*source.ManagedPipelineMode)
		config.ManagedPipelineMode = &managedPipelineMode
	} else {
		config.ManagedPipelineMode = nil
	}

	// ManagedServiceIdentityId
	config.ManagedServiceIdentityId = genruntime.ClonePointerToInt(source.ManagedServiceIdentityId)

	// MinTlsVersion
	if source.MinTlsVersion != nil {
		minTlsVersion := SiteConfig_MinTlsVersion(*source.MinTlsVersion)
		config.MinTlsVersion = &minTlsVersion
	} else {
		config.MinTlsVersion = nil
	}

	// MinimumElasticInstanceCount
	if source.MinimumElasticInstanceCount != nil {
		minimumElasticInstanceCount := *source.MinimumElasticInstanceCount
		config.MinimumElasticInstanceCount = &minimumElasticInstanceCount
	} else {
		config.MinimumElasticInstanceCount = nil
	}

	// NetFrameworkVersion
	config.NetFrameworkVersion = genruntime.ClonePointerToString(source.NetFrameworkVersion)

	// NodeVersion
	config.NodeVersion = genruntime.ClonePointerToString(source.NodeVersion)

	// NumberOfWorkers
	config.NumberOfWorkers = genruntime.ClonePointerToInt(source.NumberOfWorkers)

	// PhpVersion
	config.PhpVersion = genruntime.ClonePointerToString(source.PhpVersion)

	// PowerShellVersion
	config.PowerShellVersion = genruntime.ClonePointerToString(source.PowerShellVersion)

	// PreWarmedInstanceCount
	if source.PreWarmedInstanceCount != nil {
		preWarmedInstanceCount := *source.PreWarmedInstanceCount
		config.PreWarmedInstanceCount = &preWarmedInstanceCount
	} else {
		config.PreWarmedInstanceCount = nil
	}

	// PublicNetworkAccess
	config.PublicNetworkAccess = genruntime.ClonePointerToString(source.PublicNetworkAccess)

	// PublishingUsername
	config.PublishingUsername = genruntime.ClonePointerToString(source.PublishingUsername)

	// Push
	if source.Push != nil {
		var push PushSettings
		err := push.AssignProperties_From_PushSettings(source.Push)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_PushSettings() to populate field Push")
		}
		config.Push = &push
	} else {
		config.Push = nil
	}

	// PythonVersion
	config.PythonVersion = genruntime.ClonePointerToString(source.PythonVersion)

	// RemoteDebuggingEnabled
	if source.RemoteDebuggingEnabled != nil {
		remoteDebuggingEnabled := *source.RemoteDebuggingEnabled
		config.RemoteDebuggingEnabled = &remoteDebuggingEnabled
	} else {
		config.RemoteDebuggingEnabled = nil
	}

	// RemoteDebuggingVersion
	config.RemoteDebuggingVersion = genruntime.ClonePointerToString(source.RemoteDebuggingVersion)

	// RequestTracingEnabled
	if source.RequestTracingEnabled != nil {
		requestTracingEnabled := *source.RequestTracingEnabled
		config.RequestTracingEnabled = &requestTracingEnabled
	} else {
		config.RequestTracingEnabled = nil
	}

	// RequestTracingExpirationTime
	config.RequestTracingExpirationTime = genruntime.ClonePointerToString(source.RequestTracingExpirationTime)

	// ScmIpSecurityRestrictions
	if source.ScmIpSecurityRestrictions != nil {
		scmIpSecurityRestrictionList := make([]IpSecurityRestriction, len(source.ScmIpSecurityRestrictions))
		for scmIpSecurityRestrictionIndex, scmIpSecurityRestrictionItem := range source.ScmIpSecurityRestrictions {
			// Shadow the loop variable to avoid aliasing
			scmIpSecurityRestrictionItem := scmIpSecurityRestrictionItem
			var scmIpSecurityRestriction IpSecurityRestriction
			err := scmIpSecurityRestriction.AssignProperties_From_IpSecurityRestriction(&scmIpSecurityRestrictionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_IpSecurityRestriction() to populate field ScmIpSecurityRestrictions")
			}
			scmIpSecurityRestrictionList[scmIpSecurityRestrictionIndex] = scmIpSecurityRestriction
		}
		config.ScmIpSecurityRestrictions = scmIpSecurityRestrictionList
	} else {
		config.ScmIpSecurityRestrictions = nil
	}

	// ScmIpSecurityRestrictionsUseMain
	if source.ScmIpSecurityRestrictionsUseMain != nil {
		scmIpSecurityRestrictionsUseMain := *source.ScmIpSecurityRestrictionsUseMain
		config.ScmIpSecurityRestrictionsUseMain = &scmIpSecurityRestrictionsUseMain
	} else {
		config.ScmIpSecurityRestrictionsUseMain = nil
	}

	// ScmMinTlsVersion
	if source.ScmMinTlsVersion != nil {
		scmMinTlsVersion := SiteConfig_ScmMinTlsVersion(*source.ScmMinTlsVersion)
		config.ScmMinTlsVersion = &scmMinTlsVersion
	} else {
		config.ScmMinTlsVersion = nil
	}

	// ScmType
	if source.ScmType != nil {
		scmType := SiteConfig_ScmType(*source.ScmType)
		config.ScmType = &scmType
	} else {
		config.ScmType = nil
	}

	// TracingOptions
	config.TracingOptions = genruntime.ClonePointerToString(source.TracingOptions)

	// Use32BitWorkerProcess
	if source.Use32BitWorkerProcess != nil {
		use32BitWorkerProcess := *source.Use32BitWorkerProcess
		config.Use32BitWorkerProcess = &use32BitWorkerProcess
	} else {
		config.Use32BitWorkerProcess = nil
	}

	// VirtualApplications
	if source.VirtualApplications != nil {
		virtualApplicationList := make([]VirtualApplication, len(source.VirtualApplications))
		for virtualApplicationIndex, virtualApplicationItem := range source.VirtualApplications {
			// Shadow the loop variable to avoid aliasing
			virtualApplicationItem := virtualApplicationItem
			var virtualApplication VirtualApplication
			err := virtualApplication.AssignProperties_From_VirtualApplication(&virtualApplicationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_VirtualApplication() to populate field VirtualApplications")
			}
			virtualApplicationList[virtualApplicationIndex] = virtualApplication
		}
		config.VirtualApplications = virtualApplicationList
	} else {
		config.VirtualApplications = nil
	}

	// VnetName
	config.VnetName = genruntime.ClonePointerToString(source.VnetName)

	// VnetPrivatePortsCount
	config.VnetPrivatePortsCount = genruntime.ClonePointerToInt(source.VnetPrivatePortsCount)

	// VnetRouteAllEnabled
	if source.VnetRouteAllEnabled != nil {
		vnetRouteAllEnabled := *source.VnetRouteAllEnabled
		config.VnetRouteAllEnabled = &vnetRouteAllEnabled
	} else {
		config.VnetRouteAllEnabled = nil
	}

	// WebSocketsEnabled
	if source.WebSocketsEnabled != nil {
		webSocketsEnabled := *source.WebSocketsEnabled
		config.WebSocketsEnabled = &webSocketsEnabled
	} else {
		config.WebSocketsEnabled = nil
	}

	// WebsiteTimeZone
	config.WebsiteTimeZone = genruntime.ClonePointerToString(source.WebsiteTimeZone)

	// WindowsFxVersion
	config.WindowsFxVersion = genruntime.ClonePointerToString(source.WindowsFxVersion)

	// XManagedServiceIdentityId
	config.XManagedServiceIdentityId = genruntime.ClonePointerToInt(source.XManagedServiceIdentityId)

	// No error
	return nil
}

// AssignProperties_To_SiteConfig populates the provided destination SiteConfig from our SiteConfig
func (config *SiteConfig) AssignProperties_To_SiteConfig(destination *v20220301s.SiteConfig) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AcrUseManagedIdentityCreds
	if config.AcrUseManagedIdentityCreds != nil {
		acrUseManagedIdentityCred := *config.AcrUseManagedIdentityCreds
		destination.AcrUseManagedIdentityCreds = &acrUseManagedIdentityCred
	} else {
		destination.AcrUseManagedIdentityCreds = nil
	}

	// AcrUserManagedIdentityID
	destination.AcrUserManagedIdentityID = genruntime.ClonePointerToString(config.AcrUserManagedIdentityID)

	// AlwaysOn
	if config.AlwaysOn != nil {
		alwaysOn := *config.AlwaysOn
		destination.AlwaysOn = &alwaysOn
	} else {
		destination.AlwaysOn = nil
	}

	// ApiDefinition
	if config.ApiDefinition != nil {
		var apiDefinition v20220301s.ApiDefinitionInfo
		err := config.ApiDefinition.AssignProperties_To_ApiDefinitionInfo(&apiDefinition)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ApiDefinitionInfo() to populate field ApiDefinition")
		}
		destination.ApiDefinition = &apiDefinition
	} else {
		destination.ApiDefinition = nil
	}

	// ApiManagementConfig
	if config.ApiManagementConfig != nil {
		var apiManagementConfig v20220301s.ApiManagementConfig
		err := config.ApiManagementConfig.AssignProperties_To_ApiManagementConfig(&apiManagementConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ApiManagementConfig() to populate field ApiManagementConfig")
		}
		destination.ApiManagementConfig = &apiManagementConfig
	} else {
		destination.ApiManagementConfig = nil
	}

	// AppCommandLine
	destination.AppCommandLine = genruntime.ClonePointerToString(config.AppCommandLine)

	// AppSettings
	if config.AppSettings != nil {
		appSettingList := make([]v20220301s.NameValuePair, len(config.AppSettings))
		for appSettingIndex, appSettingItem := range config.AppSettings {
			// Shadow the loop variable to avoid aliasing
			appSettingItem := appSettingItem
			var appSetting v20220301s.NameValuePair
			err := appSettingItem.AssignProperties_To_NameValuePair(&appSetting)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_NameValuePair() to populate field AppSettings")
			}
			appSettingList[appSettingIndex] = appSetting
		}
		destination.AppSettings = appSettingList
	} else {
		destination.AppSettings = nil
	}

	// AutoHealEnabled
	if config.AutoHealEnabled != nil {
		autoHealEnabled := *config.AutoHealEnabled
		destination.AutoHealEnabled = &autoHealEnabled
	} else {
		destination.AutoHealEnabled = nil
	}

	// AutoHealRules
	if config.AutoHealRules != nil {
		var autoHealRule v20220301s.AutoHealRules
		err := config.AutoHealRules.AssignProperties_To_AutoHealRules(&autoHealRule)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AutoHealRules() to populate field AutoHealRules")
		}
		destination.AutoHealRules = &autoHealRule
	} else {
		destination.AutoHealRules = nil
	}

	// AutoSwapSlotName
	destination.AutoSwapSlotName = genruntime.ClonePointerToString(config.AutoSwapSlotName)

	// AzureStorageAccounts
	if config.AzureStorageAccounts != nil {
		azureStorageAccountMap := make(map[string]v20220301s.AzureStorageInfoValue, len(config.AzureStorageAccounts))
		for azureStorageAccountKey, azureStorageAccountValue := range config.AzureStorageAccounts {
			// Shadow the loop variable to avoid aliasing
			azureStorageAccountValue := azureStorageAccountValue
			var azureStorageAccount v20220301s.AzureStorageInfoValue
			err := azureStorageAccountValue.AssignProperties_To_AzureStorageInfoValue(&azureStorageAccount)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_AzureStorageInfoValue() to populate field AzureStorageAccounts")
			}
			azureStorageAccountMap[azureStorageAccountKey] = azureStorageAccount
		}
		destination.AzureStorageAccounts = azureStorageAccountMap
	} else {
		destination.AzureStorageAccounts = nil
	}

	// ConnectionStrings
	if config.ConnectionStrings != nil {
		connectionStringList := make([]v20220301s.ConnStringInfo, len(config.ConnectionStrings))
		for connectionStringIndex, connectionStringItem := range config.ConnectionStrings {
			// Shadow the loop variable to avoid aliasing
			connectionStringItem := connectionStringItem
			var connectionString v20220301s.ConnStringInfo
			err := connectionStringItem.AssignProperties_To_ConnStringInfo(&connectionString)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ConnStringInfo() to populate field ConnectionStrings")
			}
			connectionStringList[connectionStringIndex] = connectionString
		}
		destination.ConnectionStrings = connectionStringList
	} else {
		destination.ConnectionStrings = nil
	}

	// Cors
	if config.Cors != nil {
		var cor v20220301s.CorsSettings
		err := config.Cors.AssignProperties_To_CorsSettings(&cor)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_CorsSettings() to populate field Cors")
		}
		destination.Cors = &cor
	} else {
		destination.Cors = nil
	}

	// DefaultDocuments
	destination.DefaultDocuments = genruntime.CloneSliceOfString(config.DefaultDocuments)

	// DetailedErrorLoggingEnabled
	if config.DetailedErrorLoggingEnabled != nil {
		detailedErrorLoggingEnabled := *config.DetailedErrorLoggingEnabled
		destination.DetailedErrorLoggingEnabled = &detailedErrorLoggingEnabled
	} else {
		destination.DetailedErrorLoggingEnabled = nil
	}

	// DocumentRoot
	destination.DocumentRoot = genruntime.ClonePointerToString(config.DocumentRoot)

	// Experiments
	if config.Experiments != nil {
		var experiment v20220301s.Experiments
		err := config.Experiments.AssignProperties_To_Experiments(&experiment)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Experiments() to populate field Experiments")
		}
		destination.Experiments = &experiment
	} else {
		destination.Experiments = nil
	}

	// FtpsState
	if config.FtpsState != nil {
		ftpsState := string(*config.FtpsState)
		destination.FtpsState = &ftpsState
	} else {
		destination.FtpsState = nil
	}

	// FunctionAppScaleLimit
	if config.FunctionAppScaleLimit != nil {
		functionAppScaleLimit := *config.FunctionAppScaleLimit
		destination.FunctionAppScaleLimit = &functionAppScaleLimit
	} else {
		destination.FunctionAppScaleLimit = nil
	}

	// FunctionsRuntimeScaleMonitoringEnabled
	if config.FunctionsRuntimeScaleMonitoringEnabled != nil {
		functionsRuntimeScaleMonitoringEnabled := *config.FunctionsRuntimeScaleMonitoringEnabled
		destination.FunctionsRuntimeScaleMonitoringEnabled = &functionsRuntimeScaleMonitoringEnabled
	} else {
		destination.FunctionsRuntimeScaleMonitoringEnabled = nil
	}

	// HandlerMappings
	if config.HandlerMappings != nil {
		handlerMappingList := make([]v20220301s.HandlerMapping, len(config.HandlerMappings))
		for handlerMappingIndex, handlerMappingItem := range config.HandlerMappings {
			// Shadow the loop variable to avoid aliasing
			handlerMappingItem := handlerMappingItem
			var handlerMapping v20220301s.HandlerMapping
			err := handlerMappingItem.AssignProperties_To_HandlerMapping(&handlerMapping)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_HandlerMapping() to populate field HandlerMappings")
			}
			handlerMappingList[handlerMappingIndex] = handlerMapping
		}
		destination.HandlerMappings = handlerMappingList
	} else {
		destination.HandlerMappings = nil
	}

	// HealthCheckPath
	destination.HealthCheckPath = genruntime.ClonePointerToString(config.HealthCheckPath)

	// Http20Enabled
	if config.Http20Enabled != nil {
		http20Enabled := *config.Http20Enabled
		destination.Http20Enabled = &http20Enabled
	} else {
		destination.Http20Enabled = nil
	}

	// HttpLoggingEnabled
	if config.HttpLoggingEnabled != nil {
		httpLoggingEnabled := *config.HttpLoggingEnabled
		destination.HttpLoggingEnabled = &httpLoggingEnabled
	} else {
		destination.HttpLoggingEnabled = nil
	}

	// IpSecurityRestrictions
	if config.IpSecurityRestrictions != nil {
		ipSecurityRestrictionList := make([]v20220301s.IpSecurityRestriction, len(config.IpSecurityRestrictions))
		for ipSecurityRestrictionIndex, ipSecurityRestrictionItem := range config.IpSecurityRestrictions {
			// Shadow the loop variable to avoid aliasing
			ipSecurityRestrictionItem := ipSecurityRestrictionItem
			var ipSecurityRestriction v20220301s.IpSecurityRestriction
			err := ipSecurityRestrictionItem.AssignProperties_To_IpSecurityRestriction(&ipSecurityRestriction)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_IpSecurityRestriction() to populate field IpSecurityRestrictions")
			}
			ipSecurityRestrictionList[ipSecurityRestrictionIndex] = ipSecurityRestriction
		}
		destination.IpSecurityRestrictions = ipSecurityRestrictionList
	} else {
		destination.IpSecurityRestrictions = nil
	}

	// JavaContainer
	destination.JavaContainer = genruntime.ClonePointerToString(config.JavaContainer)

	// JavaContainerVersion
	destination.JavaContainerVersion = genruntime.ClonePointerToString(config.JavaContainerVersion)

	// JavaVersion
	destination.JavaVersion = genruntime.ClonePointerToString(config.JavaVersion)

	// KeyVaultReferenceIdentity
	destination.KeyVaultReferenceIdentity = genruntime.ClonePointerToString(config.KeyVaultReferenceIdentity)

	// Limits
	if config.Limits != nil {
		var limit v20220301s.SiteLimits
		err := config.Limits.AssignProperties_To_SiteLimits(&limit)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SiteLimits() to populate field Limits")
		}
		destination.Limits = &limit
	} else {
		destination.Limits = nil
	}

	// LinuxFxVersion
	destination.LinuxFxVersion = genruntime.ClonePointerToString(config.LinuxFxVersion)

	// LoadBalancing
	if config.LoadBalancing != nil {
		loadBalancing := string(*config.LoadBalancing)
		destination.LoadBalancing = &loadBalancing
	} else {
		destination.LoadBalancing = nil
	}

	// LocalMySqlEnabled
	if config.LocalMySqlEnabled != nil {
		localMySqlEnabled := *config.LocalMySqlEnabled
		destination.LocalMySqlEnabled = &localMySqlEnabled
	} else {
		destination.LocalMySqlEnabled = nil
	}

	// LogsDirectorySizeLimit
	destination.LogsDirectorySizeLimit = genruntime.ClonePointerToInt(config.LogsDirectorySizeLimit)

	// ManagedPipelineMode
	if config.ManagedPipelineMode != nil {
		managedPipelineMode := string(*config.ManagedPipelineMode)
		destination.ManagedPipelineMode = &managedPipelineMode
	} else {
		destination.ManagedPipelineMode = nil
	}

	// ManagedServiceIdentityId
	destination.ManagedServiceIdentityId = genruntime.ClonePointerToInt(config.ManagedServiceIdentityId)

	// MinTlsVersion
	if config.MinTlsVersion != nil {
		minTlsVersion := string(*config.MinTlsVersion)
		destination.MinTlsVersion = &minTlsVersion
	} else {
		destination.MinTlsVersion = nil
	}

	// MinimumElasticInstanceCount
	if config.MinimumElasticInstanceCount != nil {
		minimumElasticInstanceCount := *config.MinimumElasticInstanceCount
		destination.MinimumElasticInstanceCount = &minimumElasticInstanceCount
	} else {
		destination.MinimumElasticInstanceCount = nil
	}

	// NetFrameworkVersion
	destination.NetFrameworkVersion = genruntime.ClonePointerToString(config.NetFrameworkVersion)

	// NodeVersion
	destination.NodeVersion = genruntime.ClonePointerToString(config.NodeVersion)

	// NumberOfWorkers
	destination.NumberOfWorkers = genruntime.ClonePointerToInt(config.NumberOfWorkers)

	// PhpVersion
	destination.PhpVersion = genruntime.ClonePointerToString(config.PhpVersion)

	// PowerShellVersion
	destination.PowerShellVersion = genruntime.ClonePointerToString(config.PowerShellVersion)

	// PreWarmedInstanceCount
	if config.PreWarmedInstanceCount != nil {
		preWarmedInstanceCount := *config.PreWarmedInstanceCount
		destination.PreWarmedInstanceCount = &preWarmedInstanceCount
	} else {
		destination.PreWarmedInstanceCount = nil
	}

	// PublicNetworkAccess
	destination.PublicNetworkAccess = genruntime.ClonePointerToString(config.PublicNetworkAccess)

	// PublishingUsername
	destination.PublishingUsername = genruntime.ClonePointerToString(config.PublishingUsername)

	// Push
	if config.Push != nil {
		var push v20220301s.PushSettings
		err := config.Push.AssignProperties_To_PushSettings(&push)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_PushSettings() to populate field Push")
		}
		destination.Push = &push
	} else {
		destination.Push = nil
	}

	// PythonVersion
	destination.PythonVersion = genruntime.ClonePointerToString(config.PythonVersion)

	// RemoteDebuggingEnabled
	if config.RemoteDebuggingEnabled != nil {
		remoteDebuggingEnabled := *config.RemoteDebuggingEnabled
		destination.RemoteDebuggingEnabled = &remoteDebuggingEnabled
	} else {
		destination.RemoteDebuggingEnabled = nil
	}

	// RemoteDebuggingVersion
	destination.RemoteDebuggingVersion = genruntime.ClonePointerToString(config.RemoteDebuggingVersion)

	// RequestTracingEnabled
	if config.RequestTracingEnabled != nil {
		requestTracingEnabled := *config.RequestTracingEnabled
		destination.RequestTracingEnabled = &requestTracingEnabled
	} else {
		destination.RequestTracingEnabled = nil
	}

	// RequestTracingExpirationTime
	destination.RequestTracingExpirationTime = genruntime.ClonePointerToString(config.RequestTracingExpirationTime)

	// ScmIpSecurityRestrictions
	if config.ScmIpSecurityRestrictions != nil {
		scmIpSecurityRestrictionList := make([]v20220301s.IpSecurityRestriction, len(config.ScmIpSecurityRestrictions))
		for scmIpSecurityRestrictionIndex, scmIpSecurityRestrictionItem := range config.ScmIpSecurityRestrictions {
			// Shadow the loop variable to avoid aliasing
			scmIpSecurityRestrictionItem := scmIpSecurityRestrictionItem
			var scmIpSecurityRestriction v20220301s.IpSecurityRestriction
			err := scmIpSecurityRestrictionItem.AssignProperties_To_IpSecurityRestriction(&scmIpSecurityRestriction)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_IpSecurityRestriction() to populate field ScmIpSecurityRestrictions")
			}
			scmIpSecurityRestrictionList[scmIpSecurityRestrictionIndex] = scmIpSecurityRestriction
		}
		destination.ScmIpSecurityRestrictions = scmIpSecurityRestrictionList
	} else {
		destination.ScmIpSecurityRestrictions = nil
	}

	// ScmIpSecurityRestrictionsUseMain
	if config.ScmIpSecurityRestrictionsUseMain != nil {
		scmIpSecurityRestrictionsUseMain := *config.ScmIpSecurityRestrictionsUseMain
		destination.ScmIpSecurityRestrictionsUseMain = &scmIpSecurityRestrictionsUseMain
	} else {
		destination.ScmIpSecurityRestrictionsUseMain = nil
	}

	// ScmMinTlsVersion
	if config.ScmMinTlsVersion != nil {
		scmMinTlsVersion := string(*config.ScmMinTlsVersion)
		destination.ScmMinTlsVersion = &scmMinTlsVersion
	} else {
		destination.ScmMinTlsVersion = nil
	}

	// ScmType
	if config.ScmType != nil {
		scmType := string(*config.ScmType)
		destination.ScmType = &scmType
	} else {
		destination.ScmType = nil
	}

	// TracingOptions
	destination.TracingOptions = genruntime.ClonePointerToString(config.TracingOptions)

	// Use32BitWorkerProcess
	if config.Use32BitWorkerProcess != nil {
		use32BitWorkerProcess := *config.Use32BitWorkerProcess
		destination.Use32BitWorkerProcess = &use32BitWorkerProcess
	} else {
		destination.Use32BitWorkerProcess = nil
	}

	// VirtualApplications
	if config.VirtualApplications != nil {
		virtualApplicationList := make([]v20220301s.VirtualApplication, len(config.VirtualApplications))
		for virtualApplicationIndex, virtualApplicationItem := range config.VirtualApplications {
			// Shadow the loop variable to avoid aliasing
			virtualApplicationItem := virtualApplicationItem
			var virtualApplication v20220301s.VirtualApplication
			err := virtualApplicationItem.AssignProperties_To_VirtualApplication(&virtualApplication)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_VirtualApplication() to populate field VirtualApplications")
			}
			virtualApplicationList[virtualApplicationIndex] = virtualApplication
		}
		destination.VirtualApplications = virtualApplicationList
	} else {
		destination.VirtualApplications = nil
	}

	// VnetName
	destination.VnetName = genruntime.ClonePointerToString(config.VnetName)

	// VnetPrivatePortsCount
	destination.VnetPrivatePortsCount = genruntime.ClonePointerToInt(config.VnetPrivatePortsCount)

	// VnetRouteAllEnabled
	if config.VnetRouteAllEnabled != nil {
		vnetRouteAllEnabled := *config.VnetRouteAllEnabled
		destination.VnetRouteAllEnabled = &vnetRouteAllEnabled
	} else {
		destination.VnetRouteAllEnabled = nil
	}

	// WebSocketsEnabled
	if config.WebSocketsEnabled != nil {
		webSocketsEnabled := *config.WebSocketsEnabled
		destination.WebSocketsEnabled = &webSocketsEnabled
	} else {
		destination.WebSocketsEnabled = nil
	}

	// WebsiteTimeZone
	destination.WebsiteTimeZone = genruntime.ClonePointerToString(config.WebsiteTimeZone)

	// WindowsFxVersion
	destination.WindowsFxVersion = genruntime.ClonePointerToString(config.WindowsFxVersion)

	// XManagedServiceIdentityId
	destination.XManagedServiceIdentityId = genruntime.ClonePointerToInt(config.XManagedServiceIdentityId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_SiteConfig_STATUS populates our SiteConfig from the provided source SiteConfig_STATUS
func (config *SiteConfig) Initialize_From_SiteConfig_STATUS(source *SiteConfig_STATUS) error {

	// AcrUseManagedIdentityCreds
	if source.AcrUseManagedIdentityCreds != nil {
		acrUseManagedIdentityCred := *source.AcrUseManagedIdentityCreds
		config.AcrUseManagedIdentityCreds = &acrUseManagedIdentityCred
	} else {
		config.AcrUseManagedIdentityCreds = nil
	}

	// AcrUserManagedIdentityID
	config.AcrUserManagedIdentityID = genruntime.ClonePointerToString(source.AcrUserManagedIdentityID)

	// AlwaysOn
	if source.AlwaysOn != nil {
		alwaysOn := *source.AlwaysOn
		config.AlwaysOn = &alwaysOn
	} else {
		config.AlwaysOn = nil
	}

	// ApiDefinition
	if source.ApiDefinition != nil {
		var apiDefinition ApiDefinitionInfo
		err := apiDefinition.Initialize_From_ApiDefinitionInfo_STATUS(source.ApiDefinition)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_ApiDefinitionInfo_STATUS() to populate field ApiDefinition")
		}
		config.ApiDefinition = &apiDefinition
	} else {
		config.ApiDefinition = nil
	}

	// ApiManagementConfig
	if source.ApiManagementConfig != nil {
		var apiManagementConfig ApiManagementConfig
		err := apiManagementConfig.Initialize_From_ApiManagementConfig_STATUS(source.ApiManagementConfig)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_ApiManagementConfig_STATUS() to populate field ApiManagementConfig")
		}
		config.ApiManagementConfig = &apiManagementConfig
	} else {
		config.ApiManagementConfig = nil
	}

	// AppCommandLine
	config.AppCommandLine = genruntime.ClonePointerToString(source.AppCommandLine)

	// AppSettings
	if source.AppSettings != nil {
		appSettingList := make([]NameValuePair, len(source.AppSettings))
		for appSettingIndex, appSettingItem := range source.AppSettings {
			// Shadow the loop variable to avoid aliasing
			appSettingItem := appSettingItem
			var appSetting NameValuePair
			err := appSetting.Initialize_From_NameValuePair_STATUS(&appSettingItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_NameValuePair_STATUS() to populate field AppSettings")
			}
			appSettingList[appSettingIndex] = appSetting
		}
		config.AppSettings = appSettingList
	} else {
		config.AppSettings = nil
	}

	// AutoHealEnabled
	if source.AutoHealEnabled != nil {
		autoHealEnabled := *source.AutoHealEnabled
		config.AutoHealEnabled = &autoHealEnabled
	} else {
		config.AutoHealEnabled = nil
	}

	// AutoHealRules
	if source.AutoHealRules != nil {
		var autoHealRule AutoHealRules
		err := autoHealRule.Initialize_From_AutoHealRules_STATUS(source.AutoHealRules)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_AutoHealRules_STATUS() to populate field AutoHealRules")
		}
		config.AutoHealRules = &autoHealRule
	} else {
		config.AutoHealRules = nil
	}

	// AutoSwapSlotName
	config.AutoSwapSlotName = genruntime.ClonePointerToString(source.AutoSwapSlotName)

	// AzureStorageAccounts
	if source.AzureStorageAccounts != nil {
		azureStorageAccountMap := make(map[string]AzureStorageInfoValue, len(source.AzureStorageAccounts))
		for azureStorageAccountKey, azureStorageAccountValue := range source.AzureStorageAccounts {
			// Shadow the loop variable to avoid aliasing
			azureStorageAccountValue := azureStorageAccountValue
			var azureStorageAccount AzureStorageInfoValue
			err := azureStorageAccount.Initialize_From_AzureStorageInfoValue_STATUS(&azureStorageAccountValue)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_AzureStorageInfoValue_STATUS() to populate field AzureStorageAccounts")
			}
			azureStorageAccountMap[azureStorageAccountKey] = azureStorageAccount
		}
		config.AzureStorageAccounts = azureStorageAccountMap
	} else {
		config.AzureStorageAccounts = nil
	}

	// ConnectionStrings
	if source.ConnectionStrings != nil {
		connectionStringList := make([]ConnStringInfo, len(source.ConnectionStrings))
		for connectionStringIndex, connectionStringItem := range source.ConnectionStrings {
			// Shadow the loop variable to avoid aliasing
			connectionStringItem := connectionStringItem
			var connectionString ConnStringInfo
			err := connectionString.Initialize_From_ConnStringInfo_STATUS(&connectionStringItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_ConnStringInfo_STATUS() to populate field ConnectionStrings")
			}
			connectionStringList[connectionStringIndex] = connectionString
		}
		config.ConnectionStrings = connectionStringList
	} else {
		config.ConnectionStrings = nil
	}

	// Cors
	if source.Cors != nil {
		var cor CorsSettings
		err := cor.Initialize_From_CorsSettings_STATUS(source.Cors)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_CorsSettings_STATUS() to populate field Cors")
		}
		config.Cors = &cor
	} else {
		config.Cors = nil
	}

	// DefaultDocuments
	config.DefaultDocuments = genruntime.CloneSliceOfString(source.DefaultDocuments)

	// DetailedErrorLoggingEnabled
	if source.DetailedErrorLoggingEnabled != nil {
		detailedErrorLoggingEnabled := *source.DetailedErrorLoggingEnabled
		config.DetailedErrorLoggingEnabled = &detailedErrorLoggingEnabled
	} else {
		config.DetailedErrorLoggingEnabled = nil
	}

	// DocumentRoot
	config.DocumentRoot = genruntime.ClonePointerToString(source.DocumentRoot)

	// Experiments
	if source.Experiments != nil {
		var experiment Experiments
		err := experiment.Initialize_From_Experiments_STATUS(source.Experiments)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_Experiments_STATUS() to populate field Experiments")
		}
		config.Experiments = &experiment
	} else {
		config.Experiments = nil
	}

	// FtpsState
	if source.FtpsState != nil {
		ftpsState := SiteConfig_FtpsState(*source.FtpsState)
		config.FtpsState = &ftpsState
	} else {
		config.FtpsState = nil
	}

	// FunctionAppScaleLimit
	if source.FunctionAppScaleLimit != nil {
		functionAppScaleLimit := *source.FunctionAppScaleLimit
		config.FunctionAppScaleLimit = &functionAppScaleLimit
	} else {
		config.FunctionAppScaleLimit = nil
	}

	// FunctionsRuntimeScaleMonitoringEnabled
	if source.FunctionsRuntimeScaleMonitoringEnabled != nil {
		functionsRuntimeScaleMonitoringEnabled := *source.FunctionsRuntimeScaleMonitoringEnabled
		config.FunctionsRuntimeScaleMonitoringEnabled = &functionsRuntimeScaleMonitoringEnabled
	} else {
		config.FunctionsRuntimeScaleMonitoringEnabled = nil
	}

	// HandlerMappings
	if source.HandlerMappings != nil {
		handlerMappingList := make([]HandlerMapping, len(source.HandlerMappings))
		for handlerMappingIndex, handlerMappingItem := range source.HandlerMappings {
			// Shadow the loop variable to avoid aliasing
			handlerMappingItem := handlerMappingItem
			var handlerMapping HandlerMapping
			err := handlerMapping.Initialize_From_HandlerMapping_STATUS(&handlerMappingItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_HandlerMapping_STATUS() to populate field HandlerMappings")
			}
			handlerMappingList[handlerMappingIndex] = handlerMapping
		}
		config.HandlerMappings = handlerMappingList
	} else {
		config.HandlerMappings = nil
	}

	// HealthCheckPath
	config.HealthCheckPath = genruntime.ClonePointerToString(source.HealthCheckPath)

	// Http20Enabled
	if source.Http20Enabled != nil {
		http20Enabled := *source.Http20Enabled
		config.Http20Enabled = &http20Enabled
	} else {
		config.Http20Enabled = nil
	}

	// HttpLoggingEnabled
	if source.HttpLoggingEnabled != nil {
		httpLoggingEnabled := *source.HttpLoggingEnabled
		config.HttpLoggingEnabled = &httpLoggingEnabled
	} else {
		config.HttpLoggingEnabled = nil
	}

	// IpSecurityRestrictions
	if source.IpSecurityRestrictions != nil {
		ipSecurityRestrictionList := make([]IpSecurityRestriction, len(source.IpSecurityRestrictions))
		for ipSecurityRestrictionIndex, ipSecurityRestrictionItem := range source.IpSecurityRestrictions {
			// Shadow the loop variable to avoid aliasing
			ipSecurityRestrictionItem := ipSecurityRestrictionItem
			var ipSecurityRestriction IpSecurityRestriction
			err := ipSecurityRestriction.Initialize_From_IpSecurityRestriction_STATUS(&ipSecurityRestrictionItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_IpSecurityRestriction_STATUS() to populate field IpSecurityRestrictions")
			}
			ipSecurityRestrictionList[ipSecurityRestrictionIndex] = ipSecurityRestriction
		}
		config.IpSecurityRestrictions = ipSecurityRestrictionList
	} else {
		config.IpSecurityRestrictions = nil
	}

	// JavaContainer
	config.JavaContainer = genruntime.ClonePointerToString(source.JavaContainer)

	// JavaContainerVersion
	config.JavaContainerVersion = genruntime.ClonePointerToString(source.JavaContainerVersion)

	// JavaVersion
	config.JavaVersion = genruntime.ClonePointerToString(source.JavaVersion)

	// KeyVaultReferenceIdentity
	config.KeyVaultReferenceIdentity = genruntime.ClonePointerToString(source.KeyVaultReferenceIdentity)

	// Limits
	if source.Limits != nil {
		var limit SiteLimits
		err := limit.Initialize_From_SiteLimits_STATUS(source.Limits)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_SiteLimits_STATUS() to populate field Limits")
		}
		config.Limits = &limit
	} else {
		config.Limits = nil
	}

	// LinuxFxVersion
	config.LinuxFxVersion = genruntime.ClonePointerToString(source.LinuxFxVersion)

	// LoadBalancing
	if source.LoadBalancing != nil {
		loadBalancing := SiteConfig_LoadBalancing(*source.LoadBalancing)
		config.LoadBalancing = &loadBalancing
	} else {
		config.LoadBalancing = nil
	}

	// LocalMySqlEnabled
	if source.LocalMySqlEnabled != nil {
		localMySqlEnabled := *source.LocalMySqlEnabled
		config.LocalMySqlEnabled = &localMySqlEnabled
	} else {
		config.LocalMySqlEnabled = nil
	}

	// LogsDirectorySizeLimit
	config.LogsDirectorySizeLimit = genruntime.ClonePointerToInt(source.LogsDirectorySizeLimit)

	// ManagedPipelineMode
	if source.ManagedPipelineMode != nil {
		managedPipelineMode := SiteConfig_ManagedPipelineMode(*source.ManagedPipelineMode)
		config.ManagedPipelineMode = &managedPipelineMode
	} else {
		config.ManagedPipelineMode = nil
	}

	// ManagedServiceIdentityId
	config.ManagedServiceIdentityId = genruntime.ClonePointerToInt(source.ManagedServiceIdentityId)

	// MinTlsVersion
	if source.MinTlsVersion != nil {
		minTlsVersion := SiteConfig_MinTlsVersion(*source.MinTlsVersion)
		config.MinTlsVersion = &minTlsVersion
	} else {
		config.MinTlsVersion = nil
	}

	// MinimumElasticInstanceCount
	if source.MinimumElasticInstanceCount != nil {
		minimumElasticInstanceCount := *source.MinimumElasticInstanceCount
		config.MinimumElasticInstanceCount = &minimumElasticInstanceCount
	} else {
		config.MinimumElasticInstanceCount = nil
	}

	// NetFrameworkVersion
	config.NetFrameworkVersion = genruntime.ClonePointerToString(source.NetFrameworkVersion)

	// NodeVersion
	config.NodeVersion = genruntime.ClonePointerToString(source.NodeVersion)

	// NumberOfWorkers
	config.NumberOfWorkers = genruntime.ClonePointerToInt(source.NumberOfWorkers)

	// PhpVersion
	config.PhpVersion = genruntime.ClonePointerToString(source.PhpVersion)

	// PowerShellVersion
	config.PowerShellVersion = genruntime.ClonePointerToString(source.PowerShellVersion)

	// PreWarmedInstanceCount
	if source.PreWarmedInstanceCount != nil {
		preWarmedInstanceCount := *source.PreWarmedInstanceCount
		config.PreWarmedInstanceCount = &preWarmedInstanceCount
	} else {
		config.PreWarmedInstanceCount = nil
	}

	// PublicNetworkAccess
	config.PublicNetworkAccess = genruntime.ClonePointerToString(source.PublicNetworkAccess)

	// PublishingUsername
	config.PublishingUsername = genruntime.ClonePointerToString(source.PublishingUsername)

	// Push
	if source.Push != nil {
		var push PushSettings
		err := push.Initialize_From_PushSettings_STATUS(source.Push)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_PushSettings_STATUS() to populate field Push")
		}
		config.Push = &push
	} else {
		config.Push = nil
	}

	// PythonVersion
	config.PythonVersion = genruntime.ClonePointerToString(source.PythonVersion)

	// RemoteDebuggingEnabled
	if source.RemoteDebuggingEnabled != nil {
		remoteDebuggingEnabled := *source.RemoteDebuggingEnabled
		config.RemoteDebuggingEnabled = &remoteDebuggingEnabled
	} else {
		config.RemoteDebuggingEnabled = nil
	}

	// RemoteDebuggingVersion
	config.RemoteDebuggingVersion = genruntime.ClonePointerToString(source.RemoteDebuggingVersion)

	// RequestTracingEnabled
	if source.RequestTracingEnabled != nil {
		requestTracingEnabled := *source.RequestTracingEnabled
		config.RequestTracingEnabled = &requestTracingEnabled
	} else {
		config.RequestTracingEnabled = nil
	}

	// RequestTracingExpirationTime
	config.RequestTracingExpirationTime = genruntime.ClonePointerToString(source.RequestTracingExpirationTime)

	// ScmIpSecurityRestrictions
	if source.ScmIpSecurityRestrictions != nil {
		scmIpSecurityRestrictionList := make([]IpSecurityRestriction, len(source.ScmIpSecurityRestrictions))
		for scmIpSecurityRestrictionIndex, scmIpSecurityRestrictionItem := range source.ScmIpSecurityRestrictions {
			// Shadow the loop variable to avoid aliasing
			scmIpSecurityRestrictionItem := scmIpSecurityRestrictionItem
			var scmIpSecurityRestriction IpSecurityRestriction
			err := scmIpSecurityRestriction.Initialize_From_IpSecurityRestriction_STATUS(&scmIpSecurityRestrictionItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_IpSecurityRestriction_STATUS() to populate field ScmIpSecurityRestrictions")
			}
			scmIpSecurityRestrictionList[scmIpSecurityRestrictionIndex] = scmIpSecurityRestriction
		}
		config.ScmIpSecurityRestrictions = scmIpSecurityRestrictionList
	} else {
		config.ScmIpSecurityRestrictions = nil
	}

	// ScmIpSecurityRestrictionsUseMain
	if source.ScmIpSecurityRestrictionsUseMain != nil {
		scmIpSecurityRestrictionsUseMain := *source.ScmIpSecurityRestrictionsUseMain
		config.ScmIpSecurityRestrictionsUseMain = &scmIpSecurityRestrictionsUseMain
	} else {
		config.ScmIpSecurityRestrictionsUseMain = nil
	}

	// ScmMinTlsVersion
	if source.ScmMinTlsVersion != nil {
		scmMinTlsVersion := SiteConfig_ScmMinTlsVersion(*source.ScmMinTlsVersion)
		config.ScmMinTlsVersion = &scmMinTlsVersion
	} else {
		config.ScmMinTlsVersion = nil
	}

	// ScmType
	if source.ScmType != nil {
		scmType := SiteConfig_ScmType(*source.ScmType)
		config.ScmType = &scmType
	} else {
		config.ScmType = nil
	}

	// TracingOptions
	config.TracingOptions = genruntime.ClonePointerToString(source.TracingOptions)

	// Use32BitWorkerProcess
	if source.Use32BitWorkerProcess != nil {
		use32BitWorkerProcess := *source.Use32BitWorkerProcess
		config.Use32BitWorkerProcess = &use32BitWorkerProcess
	} else {
		config.Use32BitWorkerProcess = nil
	}

	// VirtualApplications
	if source.VirtualApplications != nil {
		virtualApplicationList := make([]VirtualApplication, len(source.VirtualApplications))
		for virtualApplicationIndex, virtualApplicationItem := range source.VirtualApplications {
			// Shadow the loop variable to avoid aliasing
			virtualApplicationItem := virtualApplicationItem
			var virtualApplication VirtualApplication
			err := virtualApplication.Initialize_From_VirtualApplication_STATUS(&virtualApplicationItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_VirtualApplication_STATUS() to populate field VirtualApplications")
			}
			virtualApplicationList[virtualApplicationIndex] = virtualApplication
		}
		config.VirtualApplications = virtualApplicationList
	} else {
		config.VirtualApplications = nil
	}

	// VnetName
	config.VnetName = genruntime.ClonePointerToString(source.VnetName)

	// VnetPrivatePortsCount
	config.VnetPrivatePortsCount = genruntime.ClonePointerToInt(source.VnetPrivatePortsCount)

	// VnetRouteAllEnabled
	if source.VnetRouteAllEnabled != nil {
		vnetRouteAllEnabled := *source.VnetRouteAllEnabled
		config.VnetRouteAllEnabled = &vnetRouteAllEnabled
	} else {
		config.VnetRouteAllEnabled = nil
	}

	// WebSocketsEnabled
	if source.WebSocketsEnabled != nil {
		webSocketsEnabled := *source.WebSocketsEnabled
		config.WebSocketsEnabled = &webSocketsEnabled
	} else {
		config.WebSocketsEnabled = nil
	}

	// WebsiteTimeZone
	config.WebsiteTimeZone = genruntime.ClonePointerToString(source.WebsiteTimeZone)

	// WindowsFxVersion
	config.WindowsFxVersion = genruntime.ClonePointerToString(source.WindowsFxVersion)

	// XManagedServiceIdentityId
	config.XManagedServiceIdentityId = genruntime.ClonePointerToInt(source.XManagedServiceIdentityId)

	// No error
	return nil
}

// Configuration of an App Service app.
type SiteConfig_STATUS struct {
	// AcrUseManagedIdentityCreds: Flag to use Managed Identity Creds for ACR pull
	AcrUseManagedIdentityCreds *bool `json:"acrUseManagedIdentityCreds,omitempty"`

	// AcrUserManagedIdentityID: If using user managed identity, the user managed identity ClientId
	AcrUserManagedIdentityID *string `json:"acrUserManagedIdentityID,omitempty"`

	// AlwaysOn: <code>true</code> if Always On is enabled; otherwise, <code>false</code>.
	AlwaysOn *bool `json:"alwaysOn,omitempty"`

	// ApiDefinition: Information about the formal API definition for the app.
	ApiDefinition *ApiDefinitionInfo_STATUS `json:"apiDefinition,omitempty"`

	// ApiManagementConfig: Azure API management settings linked to the app.
	ApiManagementConfig *ApiManagementConfig_STATUS `json:"apiManagementConfig,omitempty"`

	// AppCommandLine: App command line to launch.
	AppCommandLine *string `json:"appCommandLine,omitempty"`

	// AppSettings: Application settings.
	AppSettings []NameValuePair_STATUS `json:"appSettings,omitempty"`

	// AutoHealEnabled: <code>true</code> if Auto Heal is enabled; otherwise, <code>false</code>.
	AutoHealEnabled *bool `json:"autoHealEnabled,omitempty"`

	// AutoHealRules: Auto Heal rules.
	AutoHealRules *AutoHealRules_STATUS `json:"autoHealRules,omitempty"`

	// AutoSwapSlotName: Auto-swap slot name.
	AutoSwapSlotName *string `json:"autoSwapSlotName,omitempty"`

	// AzureStorageAccounts: List of Azure Storage Accounts.
	AzureStorageAccounts map[string]AzureStorageInfoValue_STATUS `json:"azureStorageAccounts,omitempty"`

	// ConnectionStrings: Connection strings.
	ConnectionStrings []ConnStringInfo_STATUS `json:"connectionStrings,omitempty"`

	// Cors: Cross-Origin Resource Sharing (CORS) settings.
	Cors *CorsSettings_STATUS `json:"cors,omitempty"`

	// DefaultDocuments: Default documents.
	DefaultDocuments []string `json:"defaultDocuments,omitempty"`

	// DetailedErrorLoggingEnabled: <code>true</code> if detailed error logging is enabled; otherwise, <code>false</code>.
	DetailedErrorLoggingEnabled *bool `json:"detailedErrorLoggingEnabled,omitempty"`

	// DocumentRoot: Document root.
	DocumentRoot *string `json:"documentRoot,omitempty"`

	// Experiments: This is work around for polymorphic types.
	Experiments *Experiments_STATUS `json:"experiments,omitempty"`

	// FtpsState: State of FTP / FTPS service
	FtpsState *SiteConfig_FtpsState_STATUS `json:"ftpsState,omitempty"`

	// FunctionAppScaleLimit: Maximum number of workers that a site can scale out to.
	// This setting only applies to the Consumption and Elastic Premium Plans
	FunctionAppScaleLimit *int `json:"functionAppScaleLimit,omitempty"`

	// FunctionsRuntimeScaleMonitoringEnabled: Gets or sets a value indicating whether functions runtime scale monitoring is
	// enabled. When enabled,
	// the ScaleController will not monitor event sources directly, but will instead call to the
	// runtime to get scale status.
	FunctionsRuntimeScaleMonitoringEnabled *bool `json:"functionsRuntimeScaleMonitoringEnabled,omitempty"`

	// HandlerMappings: Handler mappings.
	HandlerMappings []HandlerMapping_STATUS `json:"handlerMappings,omitempty"`

	// HealthCheckPath: Health check path
	HealthCheckPath *string `json:"healthCheckPath,omitempty"`

	// Http20Enabled: Http20Enabled: configures a web site to allow clients to connect over http2.0
	Http20Enabled *bool `json:"http20Enabled,omitempty"`

	// HttpLoggingEnabled: <code>true</code> if HTTP logging is enabled; otherwise, <code>false</code>.
	HttpLoggingEnabled *bool `json:"httpLoggingEnabled,omitempty"`

	// IpSecurityRestrictions: IP security restrictions for main.
	IpSecurityRestrictions []IpSecurityRestriction_STATUS `json:"ipSecurityRestrictions,omitempty"`

	// JavaContainer: Java container.
	JavaContainer *string `json:"javaContainer,omitempty"`

	// JavaContainerVersion: Java container version.
	JavaContainerVersion *string `json:"javaContainerVersion,omitempty"`

	// JavaVersion: Java version.
	JavaVersion *string `json:"javaVersion,omitempty"`

	// KeyVaultReferenceIdentity: Identity to use for Key Vault Reference authentication.
	KeyVaultReferenceIdentity *string `json:"keyVaultReferenceIdentity,omitempty"`

	// Limits: Site limits.
	Limits *SiteLimits_STATUS `json:"limits,omitempty"`

	// LinuxFxVersion: Linux App Framework and version
	LinuxFxVersion *string `json:"linuxFxVersion,omitempty"`

	// LoadBalancing: Site load balancing.
	LoadBalancing *SiteConfig_LoadBalancing_STATUS `json:"loadBalancing,omitempty"`

	// LocalMySqlEnabled: <code>true</code> to enable local MySQL; otherwise, <code>false</code>.
	LocalMySqlEnabled *bool `json:"localMySqlEnabled,omitempty"`

	// LogsDirectorySizeLimit: HTTP logs directory size limit.
	LogsDirectorySizeLimit *int `json:"logsDirectorySizeLimit,omitempty"`

	// MachineKey: Site MachineKey.
	MachineKey *SiteMachineKey_STATUS `json:"machineKey,omitempty"`

	// ManagedPipelineMode: Managed pipeline mode.
	ManagedPipelineMode *SiteConfig_ManagedPipelineMode_STATUS `json:"managedPipelineMode,omitempty"`

	// ManagedServiceIdentityId: Managed Service Identity Id
	ManagedServiceIdentityId *int `json:"managedServiceIdentityId,omitempty"`

	// MinTlsVersion: MinTlsVersion: configures the minimum version of TLS required for SSL requests
	MinTlsVersion *SiteConfig_MinTlsVersion_STATUS `json:"minTlsVersion,omitempty"`

	// MinimumElasticInstanceCount: Number of minimum instance count for a site
	// This setting only applies to the Elastic Plans
	MinimumElasticInstanceCount *int `json:"minimumElasticInstanceCount,omitempty"`

	// NetFrameworkVersion: .NET Framework version.
	NetFrameworkVersion *string `json:"netFrameworkVersion,omitempty"`

	// NodeVersion: Version of Node.js.
	NodeVersion *string `json:"nodeVersion,omitempty"`

	// NumberOfWorkers: Number of workers.
	NumberOfWorkers *int `json:"numberOfWorkers,omitempty"`

	// PhpVersion: Version of PHP.
	PhpVersion *string `json:"phpVersion,omitempty"`

	// PowerShellVersion: Version of PowerShell.
	PowerShellVersion *string `json:"powerShellVersion,omitempty"`

	// PreWarmedInstanceCount: Number of preWarmed instances.
	// This setting only applies to the Consumption and Elastic Plans
	PreWarmedInstanceCount *int `json:"preWarmedInstanceCount,omitempty"`

	// PublicNetworkAccess: Property to allow or block all public traffic.
	PublicNetworkAccess *string `json:"publicNetworkAccess,omitempty"`

	// PublishingUsername: Publishing user name.
	PublishingUsername *string `json:"publishingUsername,omitempty"`

	// Push: Push endpoint settings.
	Push *PushSettings_STATUS `json:"push,omitempty"`

	// PythonVersion: Version of Python.
	PythonVersion *string `json:"pythonVersion,omitempty"`

	// RemoteDebuggingEnabled: <code>true</code> if remote debugging is enabled; otherwise, <code>false</code>.
	RemoteDebuggingEnabled *bool `json:"remoteDebuggingEnabled,omitempty"`

	// RemoteDebuggingVersion: Remote debugging version.
	RemoteDebuggingVersion *string `json:"remoteDebuggingVersion,omitempty"`

	// RequestTracingEnabled: <code>true</code> if request tracing is enabled; otherwise, <code>false</code>.
	RequestTracingEnabled *bool `json:"requestTracingEnabled,omitempty"`

	// RequestTracingExpirationTime: Request tracing expiration time.
	RequestTracingExpirationTime *string `json:"requestTracingExpirationTime,omitempty"`

	// ScmIpSecurityRestrictions: IP security restrictions for scm.
	ScmIpSecurityRestrictions []IpSecurityRestriction_STATUS `json:"scmIpSecurityRestrictions,omitempty"`

	// ScmIpSecurityRestrictionsUseMain: IP security restrictions for scm to use main.
	ScmIpSecurityRestrictionsUseMain *bool `json:"scmIpSecurityRestrictionsUseMain,omitempty"`

	// ScmMinTlsVersion: ScmMinTlsVersion: configures the minimum version of TLS required for SSL requests for SCM site
	ScmMinTlsVersion *SiteConfig_ScmMinTlsVersion_STATUS `json:"scmMinTlsVersion,omitempty"`

	// ScmType: SCM type.
	ScmType *SiteConfig_ScmType_STATUS `json:"scmType,omitempty"`

	// TracingOptions: Tracing options.
	TracingOptions *string `json:"tracingOptions,omitempty"`

	// Use32BitWorkerProcess: <code>true</code> to use 32-bit worker process; otherwise, <code>false</code>.
	Use32BitWorkerProcess *bool `json:"use32BitWorkerProcess,omitempty"`

	// VirtualApplications: Virtual applications.
	VirtualApplications []VirtualApplication_STATUS `json:"virtualApplications,omitempty"`

	// VnetName: Virtual Network name.
	VnetName *string `json:"vnetName,omitempty"`

	// VnetPrivatePortsCount: The number of private ports assigned to this app. These will be assigned dynamically on runtime.
	VnetPrivatePortsCount *int `json:"vnetPrivatePortsCount,omitempty"`

	// VnetRouteAllEnabled: Virtual Network Route All enabled. This causes all outbound traffic to have Virtual Network
	// Security Groups and User Defined Routes applied.
	VnetRouteAllEnabled *bool `json:"vnetRouteAllEnabled,omitempty"`

	// WebSocketsEnabled: <code>true</code> if WebSocket is enabled; otherwise, <code>false</code>.
	WebSocketsEnabled *bool `json:"webSocketsEnabled,omitempty"`

	// WebsiteTimeZone: Sets the time zone a site uses for generating timestamps. Compatible with Linux and Windows App
	// Service. Setting the WEBSITE_TIME_ZONE app setting takes precedence over this config. For Linux, expects tz database
	// values https://www.iana.org/time-zones (for a quick reference see
	// https://en.wikipedia.org/wiki/List_of_tz_database_time_zones). For Windows, expects one of the time zones listed under
	// HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Time Zones
	WebsiteTimeZone *string `json:"websiteTimeZone,omitempty"`

	// WindowsFxVersion: Xenon App Framework and version
	WindowsFxVersion *string `json:"windowsFxVersion,omitempty"`

	// XManagedServiceIdentityId: Explicit Managed Service Identity Id
	XManagedServiceIdentityId *int `json:"xManagedServiceIdentityId,omitempty"`
}

var _ genruntime.FromARMConverter = &SiteConfig_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (config *SiteConfig_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &SiteConfig_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (config *SiteConfig_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(SiteConfig_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected SiteConfig_STATUS_ARM, got %T", armInput)
	}

	// Set property "AcrUseManagedIdentityCreds":
	if typedInput.AcrUseManagedIdentityCreds != nil {
		acrUseManagedIdentityCreds := *typedInput.AcrUseManagedIdentityCreds
		config.AcrUseManagedIdentityCreds = &acrUseManagedIdentityCreds
	}

	// Set property "AcrUserManagedIdentityID":
	if typedInput.AcrUserManagedIdentityID != nil {
		acrUserManagedIdentityID := *typedInput.AcrUserManagedIdentityID
		config.AcrUserManagedIdentityID = &acrUserManagedIdentityID
	}

	// Set property "AlwaysOn":
	if typedInput.AlwaysOn != nil {
		alwaysOn := *typedInput.AlwaysOn
		config.AlwaysOn = &alwaysOn
	}

	// Set property "ApiDefinition":
	if typedInput.ApiDefinition != nil {
		var apiDefinition1 ApiDefinitionInfo_STATUS
		err := apiDefinition1.PopulateFromARM(owner, *typedInput.ApiDefinition)
		if err != nil {
			return err
		}
		apiDefinition := apiDefinition1
		config.ApiDefinition = &apiDefinition
	}

	// Set property "ApiManagementConfig":
	if typedInput.ApiManagementConfig != nil {
		var apiManagementConfig1 ApiManagementConfig_STATUS
		err := apiManagementConfig1.PopulateFromARM(owner, *typedInput.ApiManagementConfig)
		if err != nil {
			return err
		}
		apiManagementConfig := apiManagementConfig1
		config.ApiManagementConfig = &apiManagementConfig
	}

	// Set property "AppCommandLine":
	if typedInput.AppCommandLine != nil {
		appCommandLine := *typedInput.AppCommandLine
		config.AppCommandLine = &appCommandLine
	}

	// Set property "AppSettings":
	for _, item := range typedInput.AppSettings {
		var item1 NameValuePair_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		config.AppSettings = append(config.AppSettings, item1)
	}

	// Set property "AutoHealEnabled":
	if typedInput.AutoHealEnabled != nil {
		autoHealEnabled := *typedInput.AutoHealEnabled
		config.AutoHealEnabled = &autoHealEnabled
	}

	// Set property "AutoHealRules":
	if typedInput.AutoHealRules != nil {
		var autoHealRules1 AutoHealRules_STATUS
		err := autoHealRules1.PopulateFromARM(owner, *typedInput.AutoHealRules)
		if err != nil {
			return err
		}
		autoHealRules := autoHealRules1
		config.AutoHealRules = &autoHealRules
	}

	// Set property "AutoSwapSlotName":
	if typedInput.AutoSwapSlotName != nil {
		autoSwapSlotName := *typedInput.AutoSwapSlotName
		config.AutoSwapSlotName = &autoSwapSlotName
	}

	// Set property "AzureStorageAccounts":
	if typedInput.AzureStorageAccounts != nil {
		config.AzureStorageAccounts = make(map[string]AzureStorageInfoValue_STATUS, len(typedInput.AzureStorageAccounts))
		for key, value := range typedInput.AzureStorageAccounts {
			var value1 AzureStorageInfoValue_STATUS
			err := value1.PopulateFromARM(owner, value)
			if err != nil {
				return err
			}
			config.AzureStorageAccounts[key] = value1
		}
	}

	// Set property "ConnectionStrings":
	for _, item := range typedInput.ConnectionStrings {
		var item1 ConnStringInfo_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		config.ConnectionStrings = append(config.ConnectionStrings, item1)
	}

	// Set property "Cors":
	if typedInput.Cors != nil {
		var cors1 CorsSettings_STATUS
		err := cors1.PopulateFromARM(owner, *typedInput.Cors)
		if err != nil {
			return err
		}
		cors := cors1
		config.Cors = &cors
	}

	// Set property "DefaultDocuments":
	for _, item := range typedInput.DefaultDocuments {
		config.DefaultDocuments = append(config.DefaultDocuments, item)
	}

	// Set property "DetailedErrorLoggingEnabled":
	if typedInput.DetailedErrorLoggingEnabled != nil {
		detailedErrorLoggingEnabled := *typedInput.DetailedErrorLoggingEnabled
		config.DetailedErrorLoggingEnabled = &detailedErrorLoggingEnabled
	}

	// Set property "DocumentRoot":
	if typedInput.DocumentRoot != nil {
		documentRoot := *typedInput.DocumentRoot
		config.DocumentRoot = &documentRoot
	}

	// Set property "Experiments":
	if typedInput.Experiments != nil {
		var experiments1 Experiments_STATUS
		err := experiments1.PopulateFromARM(owner, *typedInput.Experiments)
		if err != nil {
			return err
		}
		experiments := experiments1
		config.Experiments = &experiments
	}

	// Set property "FtpsState":
	if typedInput.FtpsState != nil {
		ftpsState := *typedInput.FtpsState
		config.FtpsState = &ftpsState
	}

	// Set property "FunctionAppScaleLimit":
	if typedInput.FunctionAppScaleLimit != nil {
		functionAppScaleLimit := *typedInput.FunctionAppScaleLimit
		config.FunctionAppScaleLimit = &functionAppScaleLimit
	}

	// Set property "FunctionsRuntimeScaleMonitoringEnabled":
	if typedInput.FunctionsRuntimeScaleMonitoringEnabled != nil {
		functionsRuntimeScaleMonitoringEnabled := *typedInput.FunctionsRuntimeScaleMonitoringEnabled
		config.FunctionsRuntimeScaleMonitoringEnabled = &functionsRuntimeScaleMonitoringEnabled
	}

	// Set property "HandlerMappings":
	for _, item := range typedInput.HandlerMappings {
		var item1 HandlerMapping_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		config.HandlerMappings = append(config.HandlerMappings, item1)
	}

	// Set property "HealthCheckPath":
	if typedInput.HealthCheckPath != nil {
		healthCheckPath := *typedInput.HealthCheckPath
		config.HealthCheckPath = &healthCheckPath
	}

	// Set property "Http20Enabled":
	if typedInput.Http20Enabled != nil {
		http20Enabled := *typedInput.Http20Enabled
		config.Http20Enabled = &http20Enabled
	}

	// Set property "HttpLoggingEnabled":
	if typedInput.HttpLoggingEnabled != nil {
		httpLoggingEnabled := *typedInput.HttpLoggingEnabled
		config.HttpLoggingEnabled = &httpLoggingEnabled
	}

	// Set property "IpSecurityRestrictions":
	for _, item := range typedInput.IpSecurityRestrictions {
		var item1 IpSecurityRestriction_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		config.IpSecurityRestrictions = append(config.IpSecurityRestrictions, item1)
	}

	// Set property "JavaContainer":
	if typedInput.JavaContainer != nil {
		javaContainer := *typedInput.JavaContainer
		config.JavaContainer = &javaContainer
	}

	// Set property "JavaContainerVersion":
	if typedInput.JavaContainerVersion != nil {
		javaContainerVersion := *typedInput.JavaContainerVersion
		config.JavaContainerVersion = &javaContainerVersion
	}

	// Set property "JavaVersion":
	if typedInput.JavaVersion != nil {
		javaVersion := *typedInput.JavaVersion
		config.JavaVersion = &javaVersion
	}

	// Set property "KeyVaultReferenceIdentity":
	if typedInput.KeyVaultReferenceIdentity != nil {
		keyVaultReferenceIdentity := *typedInput.KeyVaultReferenceIdentity
		config.KeyVaultReferenceIdentity = &keyVaultReferenceIdentity
	}

	// Set property "Limits":
	if typedInput.Limits != nil {
		var limits1 SiteLimits_STATUS
		err := limits1.PopulateFromARM(owner, *typedInput.Limits)
		if err != nil {
			return err
		}
		limits := limits1
		config.Limits = &limits
	}

	// Set property "LinuxFxVersion":
	if typedInput.LinuxFxVersion != nil {
		linuxFxVersion := *typedInput.LinuxFxVersion
		config.LinuxFxVersion = &linuxFxVersion
	}

	// Set property "LoadBalancing":
	if typedInput.LoadBalancing != nil {
		loadBalancing := *typedInput.LoadBalancing
		config.LoadBalancing = &loadBalancing
	}

	// Set property "LocalMySqlEnabled":
	if typedInput.LocalMySqlEnabled != nil {
		localMySqlEnabled := *typedInput.LocalMySqlEnabled
		config.LocalMySqlEnabled = &localMySqlEnabled
	}

	// Set property "LogsDirectorySizeLimit":
	if typedInput.LogsDirectorySizeLimit != nil {
		logsDirectorySizeLimit := *typedInput.LogsDirectorySizeLimit
		config.LogsDirectorySizeLimit = &logsDirectorySizeLimit
	}

	// Set property "MachineKey":
	if typedInput.MachineKey != nil {
		var machineKey1 SiteMachineKey_STATUS
		err := machineKey1.PopulateFromARM(owner, *typedInput.MachineKey)
		if err != nil {
			return err
		}
		machineKey := machineKey1
		config.MachineKey = &machineKey
	}

	// Set property "ManagedPipelineMode":
	if typedInput.ManagedPipelineMode != nil {
		managedPipelineMode := *typedInput.ManagedPipelineMode
		config.ManagedPipelineMode = &managedPipelineMode
	}

	// Set property "ManagedServiceIdentityId":
	if typedInput.ManagedServiceIdentityId != nil {
		managedServiceIdentityId := *typedInput.ManagedServiceIdentityId
		config.ManagedServiceIdentityId = &managedServiceIdentityId
	}

	// Set property "MinTlsVersion":
	if typedInput.MinTlsVersion != nil {
		minTlsVersion := *typedInput.MinTlsVersion
		config.MinTlsVersion = &minTlsVersion
	}

	// Set property "MinimumElasticInstanceCount":
	if typedInput.MinimumElasticInstanceCount != nil {
		minimumElasticInstanceCount := *typedInput.MinimumElasticInstanceCount
		config.MinimumElasticInstanceCount = &minimumElasticInstanceCount
	}

	// Set property "NetFrameworkVersion":
	if typedInput.NetFrameworkVersion != nil {
		netFrameworkVersion := *typedInput.NetFrameworkVersion
		config.NetFrameworkVersion = &netFrameworkVersion
	}

	// Set property "NodeVersion":
	if typedInput.NodeVersion != nil {
		nodeVersion := *typedInput.NodeVersion
		config.NodeVersion = &nodeVersion
	}

	// Set property "NumberOfWorkers":
	if typedInput.NumberOfWorkers != nil {
		numberOfWorkers := *typedInput.NumberOfWorkers
		config.NumberOfWorkers = &numberOfWorkers
	}

	// Set property "PhpVersion":
	if typedInput.PhpVersion != nil {
		phpVersion := *typedInput.PhpVersion
		config.PhpVersion = &phpVersion
	}

	// Set property "PowerShellVersion":
	if typedInput.PowerShellVersion != nil {
		powerShellVersion := *typedInput.PowerShellVersion
		config.PowerShellVersion = &powerShellVersion
	}

	// Set property "PreWarmedInstanceCount":
	if typedInput.PreWarmedInstanceCount != nil {
		preWarmedInstanceCount := *typedInput.PreWarmedInstanceCount
		config.PreWarmedInstanceCount = &preWarmedInstanceCount
	}

	// Set property "PublicNetworkAccess":
	if typedInput.PublicNetworkAccess != nil {
		publicNetworkAccess := *typedInput.PublicNetworkAccess
		config.PublicNetworkAccess = &publicNetworkAccess
	}

	// Set property "PublishingUsername":
	if typedInput.PublishingUsername != nil {
		publishingUsername := *typedInput.PublishingUsername
		config.PublishingUsername = &publishingUsername
	}

	// Set property "Push":
	if typedInput.Push != nil {
		var push1 PushSettings_STATUS
		err := push1.PopulateFromARM(owner, *typedInput.Push)
		if err != nil {
			return err
		}
		push := push1
		config.Push = &push
	}

	// Set property "PythonVersion":
	if typedInput.PythonVersion != nil {
		pythonVersion := *typedInput.PythonVersion
		config.PythonVersion = &pythonVersion
	}

	// Set property "RemoteDebuggingEnabled":
	if typedInput.RemoteDebuggingEnabled != nil {
		remoteDebuggingEnabled := *typedInput.RemoteDebuggingEnabled
		config.RemoteDebuggingEnabled = &remoteDebuggingEnabled
	}

	// Set property "RemoteDebuggingVersion":
	if typedInput.RemoteDebuggingVersion != nil {
		remoteDebuggingVersion := *typedInput.RemoteDebuggingVersion
		config.RemoteDebuggingVersion = &remoteDebuggingVersion
	}

	// Set property "RequestTracingEnabled":
	if typedInput.RequestTracingEnabled != nil {
		requestTracingEnabled := *typedInput.RequestTracingEnabled
		config.RequestTracingEnabled = &requestTracingEnabled
	}

	// Set property "RequestTracingExpirationTime":
	if typedInput.RequestTracingExpirationTime != nil {
		requestTracingExpirationTime := *typedInput.RequestTracingExpirationTime
		config.RequestTracingExpirationTime = &requestTracingExpirationTime
	}

	// Set property "ScmIpSecurityRestrictions":
	for _, item := range typedInput.ScmIpSecurityRestrictions {
		var item1 IpSecurityRestriction_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		config.ScmIpSecurityRestrictions = append(config.ScmIpSecurityRestrictions, item1)
	}

	// Set property "ScmIpSecurityRestrictionsUseMain":
	if typedInput.ScmIpSecurityRestrictionsUseMain != nil {
		scmIpSecurityRestrictionsUseMain := *typedInput.ScmIpSecurityRestrictionsUseMain
		config.ScmIpSecurityRestrictionsUseMain = &scmIpSecurityRestrictionsUseMain
	}

	// Set property "ScmMinTlsVersion":
	if typedInput.ScmMinTlsVersion != nil {
		scmMinTlsVersion := *typedInput.ScmMinTlsVersion
		config.ScmMinTlsVersion = &scmMinTlsVersion
	}

	// Set property "ScmType":
	if typedInput.ScmType != nil {
		scmType := *typedInput.ScmType
		config.ScmType = &scmType
	}

	// Set property "TracingOptions":
	if typedInput.TracingOptions != nil {
		tracingOptions := *typedInput.TracingOptions
		config.TracingOptions = &tracingOptions
	}

	// Set property "Use32BitWorkerProcess":
	if typedInput.Use32BitWorkerProcess != nil {
		use32BitWorkerProcess := *typedInput.Use32BitWorkerProcess
		config.Use32BitWorkerProcess = &use32BitWorkerProcess
	}

	// Set property "VirtualApplications":
	for _, item := range typedInput.VirtualApplications {
		var item1 VirtualApplication_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		config.VirtualApplications = append(config.VirtualApplications, item1)
	}

	// Set property "VnetName":
	if typedInput.VnetName != nil {
		vnetName := *typedInput.VnetName
		config.VnetName = &vnetName
	}

	// Set property "VnetPrivatePortsCount":
	if typedInput.VnetPrivatePortsCount != nil {
		vnetPrivatePortsCount := *typedInput.VnetPrivatePortsCount
		config.VnetPrivatePortsCount = &vnetPrivatePortsCount
	}

	// Set property "VnetRouteAllEnabled":
	if typedInput.VnetRouteAllEnabled != nil {
		vnetRouteAllEnabled := *typedInput.VnetRouteAllEnabled
		config.VnetRouteAllEnabled = &vnetRouteAllEnabled
	}

	// Set property "WebSocketsEnabled":
	if typedInput.WebSocketsEnabled != nil {
		webSocketsEnabled := *typedInput.WebSocketsEnabled
		config.WebSocketsEnabled = &webSocketsEnabled
	}

	// Set property "WebsiteTimeZone":
	if typedInput.WebsiteTimeZone != nil {
		websiteTimeZone := *typedInput.WebsiteTimeZone
		config.WebsiteTimeZone = &websiteTimeZone
	}

	// Set property "WindowsFxVersion":
	if typedInput.WindowsFxVersion != nil {
		windowsFxVersion := *typedInput.WindowsFxVersion
		config.WindowsFxVersion = &windowsFxVersion
	}

	// Set property "XManagedServiceIdentityId":
	if typedInput.XManagedServiceIdentityId != nil {
		xManagedServiceIdentityId := *typedInput.XManagedServiceIdentityId
		config.XManagedServiceIdentityId = &xManagedServiceIdentityId
	}

	// No error
	return nil
}

// AssignProperties_From_SiteConfig_STATUS populates our SiteConfig_STATUS from the provided source SiteConfig_STATUS
func (config *SiteConfig_STATUS) AssignProperties_From_SiteConfig_STATUS(source *v20220301s.SiteConfig_STATUS) error {

	// AcrUseManagedIdentityCreds
	if source.AcrUseManagedIdentityCreds != nil {
		acrUseManagedIdentityCred := *source.AcrUseManagedIdentityCreds
		config.AcrUseManagedIdentityCreds = &acrUseManagedIdentityCred
	} else {
		config.AcrUseManagedIdentityCreds = nil
	}

	// AcrUserManagedIdentityID
	config.AcrUserManagedIdentityID = genruntime.ClonePointerToString(source.AcrUserManagedIdentityID)

	// AlwaysOn
	if source.AlwaysOn != nil {
		alwaysOn := *source.AlwaysOn
		config.AlwaysOn = &alwaysOn
	} else {
		config.AlwaysOn = nil
	}

	// ApiDefinition
	if source.ApiDefinition != nil {
		var apiDefinition ApiDefinitionInfo_STATUS
		err := apiDefinition.AssignProperties_From_ApiDefinitionInfo_STATUS(source.ApiDefinition)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ApiDefinitionInfo_STATUS() to populate field ApiDefinition")
		}
		config.ApiDefinition = &apiDefinition
	} else {
		config.ApiDefinition = nil
	}

	// ApiManagementConfig
	if source.ApiManagementConfig != nil {
		var apiManagementConfig ApiManagementConfig_STATUS
		err := apiManagementConfig.AssignProperties_From_ApiManagementConfig_STATUS(source.ApiManagementConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ApiManagementConfig_STATUS() to populate field ApiManagementConfig")
		}
		config.ApiManagementConfig = &apiManagementConfig
	} else {
		config.ApiManagementConfig = nil
	}

	// AppCommandLine
	config.AppCommandLine = genruntime.ClonePointerToString(source.AppCommandLine)

	// AppSettings
	if source.AppSettings != nil {
		appSettingList := make([]NameValuePair_STATUS, len(source.AppSettings))
		for appSettingIndex, appSettingItem := range source.AppSettings {
			// Shadow the loop variable to avoid aliasing
			appSettingItem := appSettingItem
			var appSetting NameValuePair_STATUS
			err := appSetting.AssignProperties_From_NameValuePair_STATUS(&appSettingItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_NameValuePair_STATUS() to populate field AppSettings")
			}
			appSettingList[appSettingIndex] = appSetting
		}
		config.AppSettings = appSettingList
	} else {
		config.AppSettings = nil
	}

	// AutoHealEnabled
	if source.AutoHealEnabled != nil {
		autoHealEnabled := *source.AutoHealEnabled
		config.AutoHealEnabled = &autoHealEnabled
	} else {
		config.AutoHealEnabled = nil
	}

	// AutoHealRules
	if source.AutoHealRules != nil {
		var autoHealRule AutoHealRules_STATUS
		err := autoHealRule.AssignProperties_From_AutoHealRules_STATUS(source.AutoHealRules)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AutoHealRules_STATUS() to populate field AutoHealRules")
		}
		config.AutoHealRules = &autoHealRule
	} else {
		config.AutoHealRules = nil
	}

	// AutoSwapSlotName
	config.AutoSwapSlotName = genruntime.ClonePointerToString(source.AutoSwapSlotName)

	// AzureStorageAccounts
	if source.AzureStorageAccounts != nil {
		azureStorageAccountMap := make(map[string]AzureStorageInfoValue_STATUS, len(source.AzureStorageAccounts))
		for azureStorageAccountKey, azureStorageAccountValue := range source.AzureStorageAccounts {
			// Shadow the loop variable to avoid aliasing
			azureStorageAccountValue := azureStorageAccountValue
			var azureStorageAccount AzureStorageInfoValue_STATUS
			err := azureStorageAccount.AssignProperties_From_AzureStorageInfoValue_STATUS(&azureStorageAccountValue)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_AzureStorageInfoValue_STATUS() to populate field AzureStorageAccounts")
			}
			azureStorageAccountMap[azureStorageAccountKey] = azureStorageAccount
		}
		config.AzureStorageAccounts = azureStorageAccountMap
	} else {
		config.AzureStorageAccounts = nil
	}

	// ConnectionStrings
	if source.ConnectionStrings != nil {
		connectionStringList := make([]ConnStringInfo_STATUS, len(source.ConnectionStrings))
		for connectionStringIndex, connectionStringItem := range source.ConnectionStrings {
			// Shadow the loop variable to avoid aliasing
			connectionStringItem := connectionStringItem
			var connectionString ConnStringInfo_STATUS
			err := connectionString.AssignProperties_From_ConnStringInfo_STATUS(&connectionStringItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ConnStringInfo_STATUS() to populate field ConnectionStrings")
			}
			connectionStringList[connectionStringIndex] = connectionString
		}
		config.ConnectionStrings = connectionStringList
	} else {
		config.ConnectionStrings = nil
	}

	// Cors
	if source.Cors != nil {
		var cor CorsSettings_STATUS
		err := cor.AssignProperties_From_CorsSettings_STATUS(source.Cors)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_CorsSettings_STATUS() to populate field Cors")
		}
		config.Cors = &cor
	} else {
		config.Cors = nil
	}

	// DefaultDocuments
	config.DefaultDocuments = genruntime.CloneSliceOfString(source.DefaultDocuments)

	// DetailedErrorLoggingEnabled
	if source.DetailedErrorLoggingEnabled != nil {
		detailedErrorLoggingEnabled := *source.DetailedErrorLoggingEnabled
		config.DetailedErrorLoggingEnabled = &detailedErrorLoggingEnabled
	} else {
		config.DetailedErrorLoggingEnabled = nil
	}

	// DocumentRoot
	config.DocumentRoot = genruntime.ClonePointerToString(source.DocumentRoot)

	// Experiments
	if source.Experiments != nil {
		var experiment Experiments_STATUS
		err := experiment.AssignProperties_From_Experiments_STATUS(source.Experiments)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Experiments_STATUS() to populate field Experiments")
		}
		config.Experiments = &experiment
	} else {
		config.Experiments = nil
	}

	// FtpsState
	if source.FtpsState != nil {
		ftpsState := SiteConfig_FtpsState_STATUS(*source.FtpsState)
		config.FtpsState = &ftpsState
	} else {
		config.FtpsState = nil
	}

	// FunctionAppScaleLimit
	config.FunctionAppScaleLimit = genruntime.ClonePointerToInt(source.FunctionAppScaleLimit)

	// FunctionsRuntimeScaleMonitoringEnabled
	if source.FunctionsRuntimeScaleMonitoringEnabled != nil {
		functionsRuntimeScaleMonitoringEnabled := *source.FunctionsRuntimeScaleMonitoringEnabled
		config.FunctionsRuntimeScaleMonitoringEnabled = &functionsRuntimeScaleMonitoringEnabled
	} else {
		config.FunctionsRuntimeScaleMonitoringEnabled = nil
	}

	// HandlerMappings
	if source.HandlerMappings != nil {
		handlerMappingList := make([]HandlerMapping_STATUS, len(source.HandlerMappings))
		for handlerMappingIndex, handlerMappingItem := range source.HandlerMappings {
			// Shadow the loop variable to avoid aliasing
			handlerMappingItem := handlerMappingItem
			var handlerMapping HandlerMapping_STATUS
			err := handlerMapping.AssignProperties_From_HandlerMapping_STATUS(&handlerMappingItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_HandlerMapping_STATUS() to populate field HandlerMappings")
			}
			handlerMappingList[handlerMappingIndex] = handlerMapping
		}
		config.HandlerMappings = handlerMappingList
	} else {
		config.HandlerMappings = nil
	}

	// HealthCheckPath
	config.HealthCheckPath = genruntime.ClonePointerToString(source.HealthCheckPath)

	// Http20Enabled
	if source.Http20Enabled != nil {
		http20Enabled := *source.Http20Enabled
		config.Http20Enabled = &http20Enabled
	} else {
		config.Http20Enabled = nil
	}

	// HttpLoggingEnabled
	if source.HttpLoggingEnabled != nil {
		httpLoggingEnabled := *source.HttpLoggingEnabled
		config.HttpLoggingEnabled = &httpLoggingEnabled
	} else {
		config.HttpLoggingEnabled = nil
	}

	// IpSecurityRestrictions
	if source.IpSecurityRestrictions != nil {
		ipSecurityRestrictionList := make([]IpSecurityRestriction_STATUS, len(source.IpSecurityRestrictions))
		for ipSecurityRestrictionIndex, ipSecurityRestrictionItem := range source.IpSecurityRestrictions {
			// Shadow the loop variable to avoid aliasing
			ipSecurityRestrictionItem := ipSecurityRestrictionItem
			var ipSecurityRestriction IpSecurityRestriction_STATUS
			err := ipSecurityRestriction.AssignProperties_From_IpSecurityRestriction_STATUS(&ipSecurityRestrictionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_IpSecurityRestriction_STATUS() to populate field IpSecurityRestrictions")
			}
			ipSecurityRestrictionList[ipSecurityRestrictionIndex] = ipSecurityRestriction
		}
		config.IpSecurityRestrictions = ipSecurityRestrictionList
	} else {
		config.IpSecurityRestrictions = nil
	}

	// JavaContainer
	config.JavaContainer = genruntime.ClonePointerToString(source.JavaContainer)

	// JavaContainerVersion
	config.JavaContainerVersion = genruntime.ClonePointerToString(source.JavaContainerVersion)

	// JavaVersion
	config.JavaVersion = genruntime.ClonePointerToString(source.JavaVersion)

	// KeyVaultReferenceIdentity
	config.KeyVaultReferenceIdentity = genruntime.ClonePointerToString(source.KeyVaultReferenceIdentity)

	// Limits
	if source.Limits != nil {
		var limit SiteLimits_STATUS
		err := limit.AssignProperties_From_SiteLimits_STATUS(source.Limits)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SiteLimits_STATUS() to populate field Limits")
		}
		config.Limits = &limit
	} else {
		config.Limits = nil
	}

	// LinuxFxVersion
	config.LinuxFxVersion = genruntime.ClonePointerToString(source.LinuxFxVersion)

	// LoadBalancing
	if source.LoadBalancing != nil {
		loadBalancing := SiteConfig_LoadBalancing_STATUS(*source.LoadBalancing)
		config.LoadBalancing = &loadBalancing
	} else {
		config.LoadBalancing = nil
	}

	// LocalMySqlEnabled
	if source.LocalMySqlEnabled != nil {
		localMySqlEnabled := *source.LocalMySqlEnabled
		config.LocalMySqlEnabled = &localMySqlEnabled
	} else {
		config.LocalMySqlEnabled = nil
	}

	// LogsDirectorySizeLimit
	config.LogsDirectorySizeLimit = genruntime.ClonePointerToInt(source.LogsDirectorySizeLimit)

	// MachineKey
	if source.MachineKey != nil {
		var machineKey SiteMachineKey_STATUS
		err := machineKey.AssignProperties_From_SiteMachineKey_STATUS(source.MachineKey)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SiteMachineKey_STATUS() to populate field MachineKey")
		}
		config.MachineKey = &machineKey
	} else {
		config.MachineKey = nil
	}

	// ManagedPipelineMode
	if source.ManagedPipelineMode != nil {
		managedPipelineMode := SiteConfig_ManagedPipelineMode_STATUS(*source.ManagedPipelineMode)
		config.ManagedPipelineMode = &managedPipelineMode
	} else {
		config.ManagedPipelineMode = nil
	}

	// ManagedServiceIdentityId
	config.ManagedServiceIdentityId = genruntime.ClonePointerToInt(source.ManagedServiceIdentityId)

	// MinTlsVersion
	if source.MinTlsVersion != nil {
		minTlsVersion := SiteConfig_MinTlsVersion_STATUS(*source.MinTlsVersion)
		config.MinTlsVersion = &minTlsVersion
	} else {
		config.MinTlsVersion = nil
	}

	// MinimumElasticInstanceCount
	config.MinimumElasticInstanceCount = genruntime.ClonePointerToInt(source.MinimumElasticInstanceCount)

	// NetFrameworkVersion
	config.NetFrameworkVersion = genruntime.ClonePointerToString(source.NetFrameworkVersion)

	// NodeVersion
	config.NodeVersion = genruntime.ClonePointerToString(source.NodeVersion)

	// NumberOfWorkers
	config.NumberOfWorkers = genruntime.ClonePointerToInt(source.NumberOfWorkers)

	// PhpVersion
	config.PhpVersion = genruntime.ClonePointerToString(source.PhpVersion)

	// PowerShellVersion
	config.PowerShellVersion = genruntime.ClonePointerToString(source.PowerShellVersion)

	// PreWarmedInstanceCount
	config.PreWarmedInstanceCount = genruntime.ClonePointerToInt(source.PreWarmedInstanceCount)

	// PublicNetworkAccess
	config.PublicNetworkAccess = genruntime.ClonePointerToString(source.PublicNetworkAccess)

	// PublishingUsername
	config.PublishingUsername = genruntime.ClonePointerToString(source.PublishingUsername)

	// Push
	if source.Push != nil {
		var push PushSettings_STATUS
		err := push.AssignProperties_From_PushSettings_STATUS(source.Push)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_PushSettings_STATUS() to populate field Push")
		}
		config.Push = &push
	} else {
		config.Push = nil
	}

	// PythonVersion
	config.PythonVersion = genruntime.ClonePointerToString(source.PythonVersion)

	// RemoteDebuggingEnabled
	if source.RemoteDebuggingEnabled != nil {
		remoteDebuggingEnabled := *source.RemoteDebuggingEnabled
		config.RemoteDebuggingEnabled = &remoteDebuggingEnabled
	} else {
		config.RemoteDebuggingEnabled = nil
	}

	// RemoteDebuggingVersion
	config.RemoteDebuggingVersion = genruntime.ClonePointerToString(source.RemoteDebuggingVersion)

	// RequestTracingEnabled
	if source.RequestTracingEnabled != nil {
		requestTracingEnabled := *source.RequestTracingEnabled
		config.RequestTracingEnabled = &requestTracingEnabled
	} else {
		config.RequestTracingEnabled = nil
	}

	// RequestTracingExpirationTime
	config.RequestTracingExpirationTime = genruntime.ClonePointerToString(source.RequestTracingExpirationTime)

	// ScmIpSecurityRestrictions
	if source.ScmIpSecurityRestrictions != nil {
		scmIpSecurityRestrictionList := make([]IpSecurityRestriction_STATUS, len(source.ScmIpSecurityRestrictions))
		for scmIpSecurityRestrictionIndex, scmIpSecurityRestrictionItem := range source.ScmIpSecurityRestrictions {
			// Shadow the loop variable to avoid aliasing
			scmIpSecurityRestrictionItem := scmIpSecurityRestrictionItem
			var scmIpSecurityRestriction IpSecurityRestriction_STATUS
			err := scmIpSecurityRestriction.AssignProperties_From_IpSecurityRestriction_STATUS(&scmIpSecurityRestrictionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_IpSecurityRestriction_STATUS() to populate field ScmIpSecurityRestrictions")
			}
			scmIpSecurityRestrictionList[scmIpSecurityRestrictionIndex] = scmIpSecurityRestriction
		}
		config.ScmIpSecurityRestrictions = scmIpSecurityRestrictionList
	} else {
		config.ScmIpSecurityRestrictions = nil
	}

	// ScmIpSecurityRestrictionsUseMain
	if source.ScmIpSecurityRestrictionsUseMain != nil {
		scmIpSecurityRestrictionsUseMain := *source.ScmIpSecurityRestrictionsUseMain
		config.ScmIpSecurityRestrictionsUseMain = &scmIpSecurityRestrictionsUseMain
	} else {
		config.ScmIpSecurityRestrictionsUseMain = nil
	}

	// ScmMinTlsVersion
	if source.ScmMinTlsVersion != nil {
		scmMinTlsVersion := SiteConfig_ScmMinTlsVersion_STATUS(*source.ScmMinTlsVersion)
		config.ScmMinTlsVersion = &scmMinTlsVersion
	} else {
		config.ScmMinTlsVersion = nil
	}

	// ScmType
	if source.ScmType != nil {
		scmType := SiteConfig_ScmType_STATUS(*source.ScmType)
		config.ScmType = &scmType
	} else {
		config.ScmType = nil
	}

	// TracingOptions
	config.TracingOptions = genruntime.ClonePointerToString(source.TracingOptions)

	// Use32BitWorkerProcess
	if source.Use32BitWorkerProcess != nil {
		use32BitWorkerProcess := *source.Use32BitWorkerProcess
		config.Use32BitWorkerProcess = &use32BitWorkerProcess
	} else {
		config.Use32BitWorkerProcess = nil
	}

	// VirtualApplications
	if source.VirtualApplications != nil {
		virtualApplicationList := make([]VirtualApplication_STATUS, len(source.VirtualApplications))
		for virtualApplicationIndex, virtualApplicationItem := range source.VirtualApplications {
			// Shadow the loop variable to avoid aliasing
			virtualApplicationItem := virtualApplicationItem
			var virtualApplication VirtualApplication_STATUS
			err := virtualApplication.AssignProperties_From_VirtualApplication_STATUS(&virtualApplicationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_VirtualApplication_STATUS() to populate field VirtualApplications")
			}
			virtualApplicationList[virtualApplicationIndex] = virtualApplication
		}
		config.VirtualApplications = virtualApplicationList
	} else {
		config.VirtualApplications = nil
	}

	// VnetName
	config.VnetName = genruntime.ClonePointerToString(source.VnetName)

	// VnetPrivatePortsCount
	config.VnetPrivatePortsCount = genruntime.ClonePointerToInt(source.VnetPrivatePortsCount)

	// VnetRouteAllEnabled
	if source.VnetRouteAllEnabled != nil {
		vnetRouteAllEnabled := *source.VnetRouteAllEnabled
		config.VnetRouteAllEnabled = &vnetRouteAllEnabled
	} else {
		config.VnetRouteAllEnabled = nil
	}

	// WebSocketsEnabled
	if source.WebSocketsEnabled != nil {
		webSocketsEnabled := *source.WebSocketsEnabled
		config.WebSocketsEnabled = &webSocketsEnabled
	} else {
		config.WebSocketsEnabled = nil
	}

	// WebsiteTimeZone
	config.WebsiteTimeZone = genruntime.ClonePointerToString(source.WebsiteTimeZone)

	// WindowsFxVersion
	config.WindowsFxVersion = genruntime.ClonePointerToString(source.WindowsFxVersion)

	// XManagedServiceIdentityId
	config.XManagedServiceIdentityId = genruntime.ClonePointerToInt(source.XManagedServiceIdentityId)

	// No error
	return nil
}

// AssignProperties_To_SiteConfig_STATUS populates the provided destination SiteConfig_STATUS from our SiteConfig_STATUS
func (config *SiteConfig_STATUS) AssignProperties_To_SiteConfig_STATUS(destination *v20220301s.SiteConfig_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AcrUseManagedIdentityCreds
	if config.AcrUseManagedIdentityCreds != nil {
		acrUseManagedIdentityCred := *config.AcrUseManagedIdentityCreds
		destination.AcrUseManagedIdentityCreds = &acrUseManagedIdentityCred
	} else {
		destination.AcrUseManagedIdentityCreds = nil
	}

	// AcrUserManagedIdentityID
	destination.AcrUserManagedIdentityID = genruntime.ClonePointerToString(config.AcrUserManagedIdentityID)

	// AlwaysOn
	if config.AlwaysOn != nil {
		alwaysOn := *config.AlwaysOn
		destination.AlwaysOn = &alwaysOn
	} else {
		destination.AlwaysOn = nil
	}

	// ApiDefinition
	if config.ApiDefinition != nil {
		var apiDefinition v20220301s.ApiDefinitionInfo_STATUS
		err := config.ApiDefinition.AssignProperties_To_ApiDefinitionInfo_STATUS(&apiDefinition)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ApiDefinitionInfo_STATUS() to populate field ApiDefinition")
		}
		destination.ApiDefinition = &apiDefinition
	} else {
		destination.ApiDefinition = nil
	}

	// ApiManagementConfig
	if config.ApiManagementConfig != nil {
		var apiManagementConfig v20220301s.ApiManagementConfig_STATUS
		err := config.ApiManagementConfig.AssignProperties_To_ApiManagementConfig_STATUS(&apiManagementConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ApiManagementConfig_STATUS() to populate field ApiManagementConfig")
		}
		destination.ApiManagementConfig = &apiManagementConfig
	} else {
		destination.ApiManagementConfig = nil
	}

	// AppCommandLine
	destination.AppCommandLine = genruntime.ClonePointerToString(config.AppCommandLine)

	// AppSettings
	if config.AppSettings != nil {
		appSettingList := make([]v20220301s.NameValuePair_STATUS, len(config.AppSettings))
		for appSettingIndex, appSettingItem := range config.AppSettings {
			// Shadow the loop variable to avoid aliasing
			appSettingItem := appSettingItem
			var appSetting v20220301s.NameValuePair_STATUS
			err := appSettingItem.AssignProperties_To_NameValuePair_STATUS(&appSetting)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_NameValuePair_STATUS() to populate field AppSettings")
			}
			appSettingList[appSettingIndex] = appSetting
		}
		destination.AppSettings = appSettingList
	} else {
		destination.AppSettings = nil
	}

	// AutoHealEnabled
	if config.AutoHealEnabled != nil {
		autoHealEnabled := *config.AutoHealEnabled
		destination.AutoHealEnabled = &autoHealEnabled
	} else {
		destination.AutoHealEnabled = nil
	}

	// AutoHealRules
	if config.AutoHealRules != nil {
		var autoHealRule v20220301s.AutoHealRules_STATUS
		err := config.AutoHealRules.AssignProperties_To_AutoHealRules_STATUS(&autoHealRule)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AutoHealRules_STATUS() to populate field AutoHealRules")
		}
		destination.AutoHealRules = &autoHealRule
	} else {
		destination.AutoHealRules = nil
	}

	// AutoSwapSlotName
	destination.AutoSwapSlotName = genruntime.ClonePointerToString(config.AutoSwapSlotName)

	// AzureStorageAccounts
	if config.AzureStorageAccounts != nil {
		azureStorageAccountMap := make(map[string]v20220301s.AzureStorageInfoValue_STATUS, len(config.AzureStorageAccounts))
		for azureStorageAccountKey, azureStorageAccountValue := range config.AzureStorageAccounts {
			// Shadow the loop variable to avoid aliasing
			azureStorageAccountValue := azureStorageAccountValue
			var azureStorageAccount v20220301s.AzureStorageInfoValue_STATUS
			err := azureStorageAccountValue.AssignProperties_To_AzureStorageInfoValue_STATUS(&azureStorageAccount)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_AzureStorageInfoValue_STATUS() to populate field AzureStorageAccounts")
			}
			azureStorageAccountMap[azureStorageAccountKey] = azureStorageAccount
		}
		destination.AzureStorageAccounts = azureStorageAccountMap
	} else {
		destination.AzureStorageAccounts = nil
	}

	// ConnectionStrings
	if config.ConnectionStrings != nil {
		connectionStringList := make([]v20220301s.ConnStringInfo_STATUS, len(config.ConnectionStrings))
		for connectionStringIndex, connectionStringItem := range config.ConnectionStrings {
			// Shadow the loop variable to avoid aliasing
			connectionStringItem := connectionStringItem
			var connectionString v20220301s.ConnStringInfo_STATUS
			err := connectionStringItem.AssignProperties_To_ConnStringInfo_STATUS(&connectionString)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ConnStringInfo_STATUS() to populate field ConnectionStrings")
			}
			connectionStringList[connectionStringIndex] = connectionString
		}
		destination.ConnectionStrings = connectionStringList
	} else {
		destination.ConnectionStrings = nil
	}

	// Cors
	if config.Cors != nil {
		var cor v20220301s.CorsSettings_STATUS
		err := config.Cors.AssignProperties_To_CorsSettings_STATUS(&cor)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_CorsSettings_STATUS() to populate field Cors")
		}
		destination.Cors = &cor
	} else {
		destination.Cors = nil
	}

	// DefaultDocuments
	destination.DefaultDocuments = genruntime.CloneSliceOfString(config.DefaultDocuments)

	// DetailedErrorLoggingEnabled
	if config.DetailedErrorLoggingEnabled != nil {
		detailedErrorLoggingEnabled := *config.DetailedErrorLoggingEnabled
		destination.DetailedErrorLoggingEnabled = &detailedErrorLoggingEnabled
	} else {
		destination.DetailedErrorLoggingEnabled = nil
	}

	// DocumentRoot
	destination.DocumentRoot = genruntime.ClonePointerToString(config.DocumentRoot)

	// Experiments
	if config.Experiments != nil {
		var experiment v20220301s.Experiments_STATUS
		err := config.Experiments.AssignProperties_To_Experiments_STATUS(&experiment)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Experiments_STATUS() to populate field Experiments")
		}
		destination.Experiments = &experiment
	} else {
		destination.Experiments = nil
	}

	// FtpsState
	if config.FtpsState != nil {
		ftpsState := string(*config.FtpsState)
		destination.FtpsState = &ftpsState
	} else {
		destination.FtpsState = nil
	}

	// FunctionAppScaleLimit
	destination.FunctionAppScaleLimit = genruntime.ClonePointerToInt(config.FunctionAppScaleLimit)

	// FunctionsRuntimeScaleMonitoringEnabled
	if config.FunctionsRuntimeScaleMonitoringEnabled != nil {
		functionsRuntimeScaleMonitoringEnabled := *config.FunctionsRuntimeScaleMonitoringEnabled
		destination.FunctionsRuntimeScaleMonitoringEnabled = &functionsRuntimeScaleMonitoringEnabled
	} else {
		destination.FunctionsRuntimeScaleMonitoringEnabled = nil
	}

	// HandlerMappings
	if config.HandlerMappings != nil {
		handlerMappingList := make([]v20220301s.HandlerMapping_STATUS, len(config.HandlerMappings))
		for handlerMappingIndex, handlerMappingItem := range config.HandlerMappings {
			// Shadow the loop variable to avoid aliasing
			handlerMappingItem := handlerMappingItem
			var handlerMapping v20220301s.HandlerMapping_STATUS
			err := handlerMappingItem.AssignProperties_To_HandlerMapping_STATUS(&handlerMapping)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_HandlerMapping_STATUS() to populate field HandlerMappings")
			}
			handlerMappingList[handlerMappingIndex] = handlerMapping
		}
		destination.HandlerMappings = handlerMappingList
	} else {
		destination.HandlerMappings = nil
	}

	// HealthCheckPath
	destination.HealthCheckPath = genruntime.ClonePointerToString(config.HealthCheckPath)

	// Http20Enabled
	if config.Http20Enabled != nil {
		http20Enabled := *config.Http20Enabled
		destination.Http20Enabled = &http20Enabled
	} else {
		destination.Http20Enabled = nil
	}

	// HttpLoggingEnabled
	if config.HttpLoggingEnabled != nil {
		httpLoggingEnabled := *config.HttpLoggingEnabled
		destination.HttpLoggingEnabled = &httpLoggingEnabled
	} else {
		destination.HttpLoggingEnabled = nil
	}

	// IpSecurityRestrictions
	if config.IpSecurityRestrictions != nil {
		ipSecurityRestrictionList := make([]v20220301s.IpSecurityRestriction_STATUS, len(config.IpSecurityRestrictions))
		for ipSecurityRestrictionIndex, ipSecurityRestrictionItem := range config.IpSecurityRestrictions {
			// Shadow the loop variable to avoid aliasing
			ipSecurityRestrictionItem := ipSecurityRestrictionItem
			var ipSecurityRestriction v20220301s.IpSecurityRestriction_STATUS
			err := ipSecurityRestrictionItem.AssignProperties_To_IpSecurityRestriction_STATUS(&ipSecurityRestriction)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_IpSecurityRestriction_STATUS() to populate field IpSecurityRestrictions")
			}
			ipSecurityRestrictionList[ipSecurityRestrictionIndex] = ipSecurityRestriction
		}
		destination.IpSecurityRestrictions = ipSecurityRestrictionList
	} else {
		destination.IpSecurityRestrictions = nil
	}

	// JavaContainer
	destination.JavaContainer = genruntime.ClonePointerToString(config.JavaContainer)

	// JavaContainerVersion
	destination.JavaContainerVersion = genruntime.ClonePointerToString(config.JavaContainerVersion)

	// JavaVersion
	destination.JavaVersion = genruntime.ClonePointerToString(config.JavaVersion)

	// KeyVaultReferenceIdentity
	destination.KeyVaultReferenceIdentity = genruntime.ClonePointerToString(config.KeyVaultReferenceIdentity)

	// Limits
	if config.Limits != nil {
		var limit v20220301s.SiteLimits_STATUS
		err := config.Limits.AssignProperties_To_SiteLimits_STATUS(&limit)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SiteLimits_STATUS() to populate field Limits")
		}
		destination.Limits = &limit
	} else {
		destination.Limits = nil
	}

	// LinuxFxVersion
	destination.LinuxFxVersion = genruntime.ClonePointerToString(config.LinuxFxVersion)

	// LoadBalancing
	if config.LoadBalancing != nil {
		loadBalancing := string(*config.LoadBalancing)
		destination.LoadBalancing = &loadBalancing
	} else {
		destination.LoadBalancing = nil
	}

	// LocalMySqlEnabled
	if config.LocalMySqlEnabled != nil {
		localMySqlEnabled := *config.LocalMySqlEnabled
		destination.LocalMySqlEnabled = &localMySqlEnabled
	} else {
		destination.LocalMySqlEnabled = nil
	}

	// LogsDirectorySizeLimit
	destination.LogsDirectorySizeLimit = genruntime.ClonePointerToInt(config.LogsDirectorySizeLimit)

	// MachineKey
	if config.MachineKey != nil {
		var machineKey v20220301s.SiteMachineKey_STATUS
		err := config.MachineKey.AssignProperties_To_SiteMachineKey_STATUS(&machineKey)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SiteMachineKey_STATUS() to populate field MachineKey")
		}
		destination.MachineKey = &machineKey
	} else {
		destination.MachineKey = nil
	}

	// ManagedPipelineMode
	if config.ManagedPipelineMode != nil {
		managedPipelineMode := string(*config.ManagedPipelineMode)
		destination.ManagedPipelineMode = &managedPipelineMode
	} else {
		destination.ManagedPipelineMode = nil
	}

	// ManagedServiceIdentityId
	destination.ManagedServiceIdentityId = genruntime.ClonePointerToInt(config.ManagedServiceIdentityId)

	// MinTlsVersion
	if config.MinTlsVersion != nil {
		minTlsVersion := string(*config.MinTlsVersion)
		destination.MinTlsVersion = &minTlsVersion
	} else {
		destination.MinTlsVersion = nil
	}

	// MinimumElasticInstanceCount
	destination.MinimumElasticInstanceCount = genruntime.ClonePointerToInt(config.MinimumElasticInstanceCount)

	// NetFrameworkVersion
	destination.NetFrameworkVersion = genruntime.ClonePointerToString(config.NetFrameworkVersion)

	// NodeVersion
	destination.NodeVersion = genruntime.ClonePointerToString(config.NodeVersion)

	// NumberOfWorkers
	destination.NumberOfWorkers = genruntime.ClonePointerToInt(config.NumberOfWorkers)

	// PhpVersion
	destination.PhpVersion = genruntime.ClonePointerToString(config.PhpVersion)

	// PowerShellVersion
	destination.PowerShellVersion = genruntime.ClonePointerToString(config.PowerShellVersion)

	// PreWarmedInstanceCount
	destination.PreWarmedInstanceCount = genruntime.ClonePointerToInt(config.PreWarmedInstanceCount)

	// PublicNetworkAccess
	destination.PublicNetworkAccess = genruntime.ClonePointerToString(config.PublicNetworkAccess)

	// PublishingUsername
	destination.PublishingUsername = genruntime.ClonePointerToString(config.PublishingUsername)

	// Push
	if config.Push != nil {
		var push v20220301s.PushSettings_STATUS
		err := config.Push.AssignProperties_To_PushSettings_STATUS(&push)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_PushSettings_STATUS() to populate field Push")
		}
		destination.Push = &push
	} else {
		destination.Push = nil
	}

	// PythonVersion
	destination.PythonVersion = genruntime.ClonePointerToString(config.PythonVersion)

	// RemoteDebuggingEnabled
	if config.RemoteDebuggingEnabled != nil {
		remoteDebuggingEnabled := *config.RemoteDebuggingEnabled
		destination.RemoteDebuggingEnabled = &remoteDebuggingEnabled
	} else {
		destination.RemoteDebuggingEnabled = nil
	}

	// RemoteDebuggingVersion
	destination.RemoteDebuggingVersion = genruntime.ClonePointerToString(config.RemoteDebuggingVersion)

	// RequestTracingEnabled
	if config.RequestTracingEnabled != nil {
		requestTracingEnabled := *config.RequestTracingEnabled
		destination.RequestTracingEnabled = &requestTracingEnabled
	} else {
		destination.RequestTracingEnabled = nil
	}

	// RequestTracingExpirationTime
	destination.RequestTracingExpirationTime = genruntime.ClonePointerToString(config.RequestTracingExpirationTime)

	// ScmIpSecurityRestrictions
	if config.ScmIpSecurityRestrictions != nil {
		scmIpSecurityRestrictionList := make([]v20220301s.IpSecurityRestriction_STATUS, len(config.ScmIpSecurityRestrictions))
		for scmIpSecurityRestrictionIndex, scmIpSecurityRestrictionItem := range config.ScmIpSecurityRestrictions {
			// Shadow the loop variable to avoid aliasing
			scmIpSecurityRestrictionItem := scmIpSecurityRestrictionItem
			var scmIpSecurityRestriction v20220301s.IpSecurityRestriction_STATUS
			err := scmIpSecurityRestrictionItem.AssignProperties_To_IpSecurityRestriction_STATUS(&scmIpSecurityRestriction)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_IpSecurityRestriction_STATUS() to populate field ScmIpSecurityRestrictions")
			}
			scmIpSecurityRestrictionList[scmIpSecurityRestrictionIndex] = scmIpSecurityRestriction
		}
		destination.ScmIpSecurityRestrictions = scmIpSecurityRestrictionList
	} else {
		destination.ScmIpSecurityRestrictions = nil
	}

	// ScmIpSecurityRestrictionsUseMain
	if config.ScmIpSecurityRestrictionsUseMain != nil {
		scmIpSecurityRestrictionsUseMain := *config.ScmIpSecurityRestrictionsUseMain
		destination.ScmIpSecurityRestrictionsUseMain = &scmIpSecurityRestrictionsUseMain
	} else {
		destination.ScmIpSecurityRestrictionsUseMain = nil
	}

	// ScmMinTlsVersion
	if config.ScmMinTlsVersion != nil {
		scmMinTlsVersion := string(*config.ScmMinTlsVersion)
		destination.ScmMinTlsVersion = &scmMinTlsVersion
	} else {
		destination.ScmMinTlsVersion = nil
	}

	// ScmType
	if config.ScmType != nil {
		scmType := string(*config.ScmType)
		destination.ScmType = &scmType
	} else {
		destination.ScmType = nil
	}

	// TracingOptions
	destination.TracingOptions = genruntime.ClonePointerToString(config.TracingOptions)

	// Use32BitWorkerProcess
	if config.Use32BitWorkerProcess != nil {
		use32BitWorkerProcess := *config.Use32BitWorkerProcess
		destination.Use32BitWorkerProcess = &use32BitWorkerProcess
	} else {
		destination.Use32BitWorkerProcess = nil
	}

	// VirtualApplications
	if config.VirtualApplications != nil {
		virtualApplicationList := make([]v20220301s.VirtualApplication_STATUS, len(config.VirtualApplications))
		for virtualApplicationIndex, virtualApplicationItem := range config.VirtualApplications {
			// Shadow the loop variable to avoid aliasing
			virtualApplicationItem := virtualApplicationItem
			var virtualApplication v20220301s.VirtualApplication_STATUS
			err := virtualApplicationItem.AssignProperties_To_VirtualApplication_STATUS(&virtualApplication)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_VirtualApplication_STATUS() to populate field VirtualApplications")
			}
			virtualApplicationList[virtualApplicationIndex] = virtualApplication
		}
		destination.VirtualApplications = virtualApplicationList
	} else {
		destination.VirtualApplications = nil
	}

	// VnetName
	destination.VnetName = genruntime.ClonePointerToString(config.VnetName)

	// VnetPrivatePortsCount
	destination.VnetPrivatePortsCount = genruntime.ClonePointerToInt(config.VnetPrivatePortsCount)

	// VnetRouteAllEnabled
	if config.VnetRouteAllEnabled != nil {
		vnetRouteAllEnabled := *config.VnetRouteAllEnabled
		destination.VnetRouteAllEnabled = &vnetRouteAllEnabled
	} else {
		destination.VnetRouteAllEnabled = nil
	}

	// WebSocketsEnabled
	if config.WebSocketsEnabled != nil {
		webSocketsEnabled := *config.WebSocketsEnabled
		destination.WebSocketsEnabled = &webSocketsEnabled
	} else {
		destination.WebSocketsEnabled = nil
	}

	// WebsiteTimeZone
	destination.WebsiteTimeZone = genruntime.ClonePointerToString(config.WebsiteTimeZone)

	// WindowsFxVersion
	destination.WindowsFxVersion = genruntime.ClonePointerToString(config.WindowsFxVersion)

	// XManagedServiceIdentityId
	destination.XManagedServiceIdentityId = genruntime.ClonePointerToInt(config.XManagedServiceIdentityId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The status of the last successful slot swap operation.
type SlotSwapStatus_STATUS struct {
	// DestinationSlotName: The destination slot of the last swap operation.
	DestinationSlotName *string `json:"destinationSlotName,omitempty"`

	// SourceSlotName: The source slot of the last swap operation.
	SourceSlotName *string `json:"sourceSlotName,omitempty"`

	// TimestampUtc: The time the last successful slot swap completed.
	TimestampUtc *string `json:"timestampUtc,omitempty"`
}

var _ genruntime.FromARMConverter = &SlotSwapStatus_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (status *SlotSwapStatus_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &SlotSwapStatus_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (status *SlotSwapStatus_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(SlotSwapStatus_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected SlotSwapStatus_STATUS_ARM, got %T", armInput)
	}

	// Set property "DestinationSlotName":
	if typedInput.DestinationSlotName != nil {
		destinationSlotName := *typedInput.DestinationSlotName
		status.DestinationSlotName = &destinationSlotName
	}

	// Set property "SourceSlotName":
	if typedInput.SourceSlotName != nil {
		sourceSlotName := *typedInput.SourceSlotName
		status.SourceSlotName = &sourceSlotName
	}

	// Set property "TimestampUtc":
	if typedInput.TimestampUtc != nil {
		timestampUtc := *typedInput.TimestampUtc
		status.TimestampUtc = &timestampUtc
	}

	// No error
	return nil
}

// AssignProperties_From_SlotSwapStatus_STATUS populates our SlotSwapStatus_STATUS from the provided source SlotSwapStatus_STATUS
func (status *SlotSwapStatus_STATUS) AssignProperties_From_SlotSwapStatus_STATUS(source *v20220301s.SlotSwapStatus_STATUS) error {

	// DestinationSlotName
	status.DestinationSlotName = genruntime.ClonePointerToString(source.DestinationSlotName)

	// SourceSlotName
	status.SourceSlotName = genruntime.ClonePointerToString(source.SourceSlotName)

	// TimestampUtc
	status.TimestampUtc = genruntime.ClonePointerToString(source.TimestampUtc)

	// No error
	return nil
}

// AssignProperties_To_SlotSwapStatus_STATUS populates the provided destination SlotSwapStatus_STATUS from our SlotSwapStatus_STATUS
func (status *SlotSwapStatus_STATUS) AssignProperties_To_SlotSwapStatus_STATUS(destination *v20220301s.SlotSwapStatus_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DestinationSlotName
	destination.DestinationSlotName = genruntime.ClonePointerToString(status.DestinationSlotName)

	// SourceSlotName
	destination.SourceSlotName = genruntime.ClonePointerToString(status.SourceSlotName)

	// TimestampUtc
	destination.TimestampUtc = genruntime.ClonePointerToString(status.TimestampUtc)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Information about the formal API definition for the app.
type ApiDefinitionInfo struct {
	// Url: The URL of the API definition.
	Url *string `json:"url,omitempty"`
}

var _ genruntime.ARMTransformer = &ApiDefinitionInfo{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (info *ApiDefinitionInfo) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if info == nil {
		return nil, nil
	}
	result := &ApiDefinitionInfo_ARM{}

	// Set property "Url":
	if info.Url != nil {
		url := *info.Url
		result.Url = &url
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (info *ApiDefinitionInfo) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ApiDefinitionInfo_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (info *ApiDefinitionInfo) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ApiDefinitionInfo_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ApiDefinitionInfo_ARM, got %T", armInput)
	}

	// Set property "Url":
	if typedInput.Url != nil {
		url := *typedInput.Url
		info.Url = &url
	}

	// No error
	return nil
}

// AssignProperties_From_ApiDefinitionInfo populates our ApiDefinitionInfo from the provided source ApiDefinitionInfo
func (info *ApiDefinitionInfo) AssignProperties_From_ApiDefinitionInfo(source *v20220301s.ApiDefinitionInfo) error {

	// Url
	info.Url = genruntime.ClonePointerToString(source.Url)

	// No error
	return nil
}

// AssignProperties_To_ApiDefinitionInfo populates the provided destination ApiDefinitionInfo from our ApiDefinitionInfo
func (info *ApiDefinitionInfo) AssignProperties_To_ApiDefinitionInfo(destination *v20220301s.ApiDefinitionInfo) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Url
	destination.Url = genruntime.ClonePointerToString(info.Url)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ApiDefinitionInfo_STATUS populates our ApiDefinitionInfo from the provided source ApiDefinitionInfo_STATUS
func (info *ApiDefinitionInfo) Initialize_From_ApiDefinitionInfo_STATUS(source *ApiDefinitionInfo_STATUS) error {

	// Url
	info.Url = genruntime.ClonePointerToString(source.Url)

	// No error
	return nil
}

// Information about the formal API definition for the app.
type ApiDefinitionInfo_STATUS struct {
	// Url: The URL of the API definition.
	Url *string `json:"url,omitempty"`
}

var _ genruntime.FromARMConverter = &ApiDefinitionInfo_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (info *ApiDefinitionInfo_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ApiDefinitionInfo_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (info *ApiDefinitionInfo_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ApiDefinitionInfo_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ApiDefinitionInfo_STATUS_ARM, got %T", armInput)
	}

	// Set property "Url":
	if typedInput.Url != nil {
		url := *typedInput.Url
		info.Url = &url
	}

	// No error
	return nil
}

// AssignProperties_From_ApiDefinitionInfo_STATUS populates our ApiDefinitionInfo_STATUS from the provided source ApiDefinitionInfo_STATUS
func (info *ApiDefinitionInfo_STATUS) AssignProperties_From_ApiDefinitionInfo_STATUS(source *v20220301s.ApiDefinitionInfo_STATUS) error {

	// Url
	info.Url = genruntime.ClonePointerToString(source.Url)

	// No error
	return nil
}

// AssignProperties_To_ApiDefinitionInfo_STATUS populates the provided destination ApiDefinitionInfo_STATUS from our ApiDefinitionInfo_STATUS
func (info *ApiDefinitionInfo_STATUS) AssignProperties_To_ApiDefinitionInfo_STATUS(destination *v20220301s.ApiDefinitionInfo_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Url
	destination.Url = genruntime.ClonePointerToString(info.Url)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Azure API management (APIM) configuration linked to the app.
type ApiManagementConfig struct {
	// Reference: APIM-Api Identifier.
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

var _ genruntime.ARMTransformer = &ApiManagementConfig{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (config *ApiManagementConfig) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if config == nil {
		return nil, nil
	}
	result := &ApiManagementConfig_ARM{}

	// Set property "Id":
	if config.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.Lookup(*config.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (config *ApiManagementConfig) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ApiManagementConfig_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (config *ApiManagementConfig) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	_, ok := armInput.(ApiManagementConfig_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ApiManagementConfig_ARM, got %T", armInput)
	}

	// no assignment for property "Reference"

	// No error
	return nil
}

// AssignProperties_From_ApiManagementConfig populates our ApiManagementConfig from the provided source ApiManagementConfig
func (config *ApiManagementConfig) AssignProperties_From_ApiManagementConfig(source *v20220301s.ApiManagementConfig) error {

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		config.Reference = &reference
	} else {
		config.Reference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ApiManagementConfig populates the provided destination ApiManagementConfig from our ApiManagementConfig
func (config *ApiManagementConfig) AssignProperties_To_ApiManagementConfig(destination *v20220301s.ApiManagementConfig) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Reference
	if config.Reference != nil {
		reference := config.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ApiManagementConfig_STATUS populates our ApiManagementConfig from the provided source ApiManagementConfig_STATUS
func (config *ApiManagementConfig) Initialize_From_ApiManagementConfig_STATUS(source *ApiManagementConfig_STATUS) error {

	// Reference
	if source.Id != nil {
		reference := genruntime.CreateResourceReferenceFromARMID(*source.Id)
		config.Reference = &reference
	} else {
		config.Reference = nil
	}

	// No error
	return nil
}

// Azure API management (APIM) configuration linked to the app.
type ApiManagementConfig_STATUS struct {
	// Id: APIM-Api Identifier.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &ApiManagementConfig_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (config *ApiManagementConfig_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ApiManagementConfig_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (config *ApiManagementConfig_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ApiManagementConfig_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ApiManagementConfig_STATUS_ARM, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		config.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_ApiManagementConfig_STATUS populates our ApiManagementConfig_STATUS from the provided source ApiManagementConfig_STATUS
func (config *ApiManagementConfig_STATUS) AssignProperties_From_ApiManagementConfig_STATUS(source *v20220301s.ApiManagementConfig_STATUS) error {

	// Id
	config.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_ApiManagementConfig_STATUS populates the provided destination ApiManagementConfig_STATUS from our ApiManagementConfig_STATUS
func (config *ApiManagementConfig_STATUS) AssignProperties_To_ApiManagementConfig_STATUS(destination *v20220301s.ApiManagementConfig_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(config.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Rules that can be defined for auto-heal.
type AutoHealRules struct {
	// Actions: Actions to be executed when a rule is triggered.
	Actions *AutoHealActions `json:"actions,omitempty"`

	// Triggers: Conditions that describe when to execute the auto-heal actions.
	Triggers *AutoHealTriggers `json:"triggers,omitempty"`
}

var _ genruntime.ARMTransformer = &AutoHealRules{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (rules *AutoHealRules) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if rules == nil {
		return nil, nil
	}
	result := &AutoHealRules_ARM{}

	// Set property "Actions":
	if rules.Actions != nil {
		actions_ARM, err := (*rules.Actions).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		actions := *actions_ARM.(*AutoHealActions_ARM)
		result.Actions = &actions
	}

	// Set property "Triggers":
	if rules.Triggers != nil {
		triggers_ARM, err := (*rules.Triggers).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		triggers := *triggers_ARM.(*AutoHealTriggers_ARM)
		result.Triggers = &triggers
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rules *AutoHealRules) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &AutoHealRules_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rules *AutoHealRules) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(AutoHealRules_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected AutoHealRules_ARM, got %T", armInput)
	}

	// Set property "Actions":
	if typedInput.Actions != nil {
		var actions1 AutoHealActions
		err := actions1.PopulateFromARM(owner, *typedInput.Actions)
		if err != nil {
			return err
		}
		actions := actions1
		rules.Actions = &actions
	}

	// Set property "Triggers":
	if typedInput.Triggers != nil {
		var triggers1 AutoHealTriggers
		err := triggers1.PopulateFromARM(owner, *typedInput.Triggers)
		if err != nil {
			return err
		}
		triggers := triggers1
		rules.Triggers = &triggers
	}

	// No error
	return nil
}

// AssignProperties_From_AutoHealRules populates our AutoHealRules from the provided source AutoHealRules
func (rules *AutoHealRules) AssignProperties_From_AutoHealRules(source *v20220301s.AutoHealRules) error {

	// Actions
	if source.Actions != nil {
		var action AutoHealActions
		err := action.AssignProperties_From_AutoHealActions(source.Actions)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AutoHealActions() to populate field Actions")
		}
		rules.Actions = &action
	} else {
		rules.Actions = nil
	}

	// Triggers
	if source.Triggers != nil {
		var trigger AutoHealTriggers
		err := trigger.AssignProperties_From_AutoHealTriggers(source.Triggers)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AutoHealTriggers() to populate field Triggers")
		}
		rules.Triggers = &trigger
	} else {
		rules.Triggers = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AutoHealRules populates the provided destination AutoHealRules from our AutoHealRules
func (rules *AutoHealRules) AssignProperties_To_AutoHealRules(destination *v20220301s.AutoHealRules) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Actions
	if rules.Actions != nil {
		var action v20220301s.AutoHealActions
		err := rules.Actions.AssignProperties_To_AutoHealActions(&action)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AutoHealActions() to populate field Actions")
		}
		destination.Actions = &action
	} else {
		destination.Actions = nil
	}

	// Triggers
	if rules.Triggers != nil {
		var trigger v20220301s.AutoHealTriggers
		err := rules.Triggers.AssignProperties_To_AutoHealTriggers(&trigger)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AutoHealTriggers() to populate field Triggers")
		}
		destination.Triggers = &trigger
	} else {
		destination.Triggers = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_AutoHealRules_STATUS populates our AutoHealRules from the provided source AutoHealRules_STATUS
func (rules *AutoHealRules) Initialize_From_AutoHealRules_STATUS(source *AutoHealRules_STATUS) error {

	// Actions
	if source.Actions != nil {
		var action AutoHealActions
		err := action.Initialize_From_AutoHealActions_STATUS(source.Actions)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_AutoHealActions_STATUS() to populate field Actions")
		}
		rules.Actions = &action
	} else {
		rules.Actions = nil
	}

	// Triggers
	if source.Triggers != nil {
		var trigger AutoHealTriggers
		err := trigger.Initialize_From_AutoHealTriggers_STATUS(source.Triggers)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_AutoHealTriggers_STATUS() to populate field Triggers")
		}
		rules.Triggers = &trigger
	} else {
		rules.Triggers = nil
	}

	// No error
	return nil
}

// Rules that can be defined for auto-heal.
type AutoHealRules_STATUS struct {
	// Actions: Actions to be executed when a rule is triggered.
	Actions *AutoHealActions_STATUS `json:"actions,omitempty"`

	// Triggers: Conditions that describe when to execute the auto-heal actions.
	Triggers *AutoHealTriggers_STATUS `json:"triggers,omitempty"`
}

var _ genruntime.FromARMConverter = &AutoHealRules_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rules *AutoHealRules_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &AutoHealRules_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rules *AutoHealRules_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(AutoHealRules_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected AutoHealRules_STATUS_ARM, got %T", armInput)
	}

	// Set property "Actions":
	if typedInput.Actions != nil {
		var actions1 AutoHealActions_STATUS
		err := actions1.PopulateFromARM(owner, *typedInput.Actions)
		if err != nil {
			return err
		}
		actions := actions1
		rules.Actions = &actions
	}

	// Set property "Triggers":
	if typedInput.Triggers != nil {
		var triggers1 AutoHealTriggers_STATUS
		err := triggers1.PopulateFromARM(owner, *typedInput.Triggers)
		if err != nil {
			return err
		}
		triggers := triggers1
		rules.Triggers = &triggers
	}

	// No error
	return nil
}

// AssignProperties_From_AutoHealRules_STATUS populates our AutoHealRules_STATUS from the provided source AutoHealRules_STATUS
func (rules *AutoHealRules_STATUS) AssignProperties_From_AutoHealRules_STATUS(source *v20220301s.AutoHealRules_STATUS) error {

	// Actions
	if source.Actions != nil {
		var action AutoHealActions_STATUS
		err := action.AssignProperties_From_AutoHealActions_STATUS(source.Actions)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AutoHealActions_STATUS() to populate field Actions")
		}
		rules.Actions = &action
	} else {
		rules.Actions = nil
	}

	// Triggers
	if source.Triggers != nil {
		var trigger AutoHealTriggers_STATUS
		err := trigger.AssignProperties_From_AutoHealTriggers_STATUS(source.Triggers)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AutoHealTriggers_STATUS() to populate field Triggers")
		}
		rules.Triggers = &trigger
	} else {
		rules.Triggers = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AutoHealRules_STATUS populates the provided destination AutoHealRules_STATUS from our AutoHealRules_STATUS
func (rules *AutoHealRules_STATUS) AssignProperties_To_AutoHealRules_STATUS(destination *v20220301s.AutoHealRules_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Actions
	if rules.Actions != nil {
		var action v20220301s.AutoHealActions_STATUS
		err := rules.Actions.AssignProperties_To_AutoHealActions_STATUS(&action)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AutoHealActions_STATUS() to populate field Actions")
		}
		destination.Actions = &action
	} else {
		destination.Actions = nil
	}

	// Triggers
	if rules.Triggers != nil {
		var trigger v20220301s.AutoHealTriggers_STATUS
		err := rules.Triggers.AssignProperties_To_AutoHealTriggers_STATUS(&trigger)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AutoHealTriggers_STATUS() to populate field Triggers")
		}
		destination.Triggers = &trigger
	} else {
		destination.Triggers = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Azure Files or Blob Storage access information value for dictionary storage.
type AzureStorageInfoValue struct {
	// AccessKey: Access key for the storage account.
	AccessKey *genruntime.SecretReference `json:"accessKey,omitempty"`

	// AccountName: Name of the storage account.
	AccountName *string `json:"accountName,omitempty"`

	// MountPath: Path to mount the storage within the site's runtime environment.
	MountPath *string `json:"mountPath,omitempty"`

	// ShareName: Name of the file share (container name, for Blob storage).
	ShareName *string `json:"shareName,omitempty"`

	// Type: Type of storage.
	Type *AzureStorageInfoValue_Type `json:"type,omitempty"`
}

var _ genruntime.ARMTransformer = &AzureStorageInfoValue{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (value *AzureStorageInfoValue) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if value == nil {
		return nil, nil
	}
	result := &AzureStorageInfoValue_ARM{}

	// Set property "AccessKey":
	if value.AccessKey != nil {
		accessKeySecret, err := resolved.ResolvedSecrets.Lookup(*value.AccessKey)
		if err != nil {
			return nil, errors.Wrap(err, "looking up secret for property AccessKey")
		}
		accessKey := accessKeySecret
		result.AccessKey = &accessKey
	}

	// Set property "AccountName":
	if value.AccountName != nil {
		accountName := *value.AccountName
		result.AccountName = &accountName
	}

	// Set property "MountPath":
	if value.MountPath != nil {
		mountPath := *value.MountPath
		result.MountPath = &mountPath
	}

	// Set property "ShareName":
	if value.ShareName != nil {
		shareName := *value.ShareName
		result.ShareName = &shareName
	}

	// Set property "Type":
	if value.Type != nil {
		typeVar := *value.Type
		result.Type = &typeVar
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (value *AzureStorageInfoValue) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &AzureStorageInfoValue_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (value *AzureStorageInfoValue) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(AzureStorageInfoValue_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected AzureStorageInfoValue_ARM, got %T", armInput)
	}

	// no assignment for property "AccessKey"

	// Set property "AccountName":
	if typedInput.AccountName != nil {
		accountName := *typedInput.AccountName
		value.AccountName = &accountName
	}

	// Set property "MountPath":
	if typedInput.MountPath != nil {
		mountPath := *typedInput.MountPath
		value.MountPath = &mountPath
	}

	// Set property "ShareName":
	if typedInput.ShareName != nil {
		shareName := *typedInput.ShareName
		value.ShareName = &shareName
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		value.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_AzureStorageInfoValue populates our AzureStorageInfoValue from the provided source AzureStorageInfoValue
func (value *AzureStorageInfoValue) AssignProperties_From_AzureStorageInfoValue(source *v20220301s.AzureStorageInfoValue) error {

	// AccessKey
	if source.AccessKey != nil {
		accessKey := source.AccessKey.Copy()
		value.AccessKey = &accessKey
	} else {
		value.AccessKey = nil
	}

	// AccountName
	value.AccountName = genruntime.ClonePointerToString(source.AccountName)

	// MountPath
	value.MountPath = genruntime.ClonePointerToString(source.MountPath)

	// ShareName
	value.ShareName = genruntime.ClonePointerToString(source.ShareName)

	// Type
	if source.Type != nil {
		typeVar := AzureStorageInfoValue_Type(*source.Type)
		value.Type = &typeVar
	} else {
		value.Type = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AzureStorageInfoValue populates the provided destination AzureStorageInfoValue from our AzureStorageInfoValue
func (value *AzureStorageInfoValue) AssignProperties_To_AzureStorageInfoValue(destination *v20220301s.AzureStorageInfoValue) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AccessKey
	if value.AccessKey != nil {
		accessKey := value.AccessKey.Copy()
		destination.AccessKey = &accessKey
	} else {
		destination.AccessKey = nil
	}

	// AccountName
	destination.AccountName = genruntime.ClonePointerToString(value.AccountName)

	// MountPath
	destination.MountPath = genruntime.ClonePointerToString(value.MountPath)

	// ShareName
	destination.ShareName = genruntime.ClonePointerToString(value.ShareName)

	// Type
	if value.Type != nil {
		typeVar := string(*value.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_AzureStorageInfoValue_STATUS populates our AzureStorageInfoValue from the provided source AzureStorageInfoValue_STATUS
func (value *AzureStorageInfoValue) Initialize_From_AzureStorageInfoValue_STATUS(source *AzureStorageInfoValue_STATUS) error {

	// AccountName
	value.AccountName = genruntime.ClonePointerToString(source.AccountName)

	// MountPath
	value.MountPath = genruntime.ClonePointerToString(source.MountPath)

	// ShareName
	value.ShareName = genruntime.ClonePointerToString(source.ShareName)

	// Type
	if source.Type != nil {
		typeVar := AzureStorageInfoValue_Type(*source.Type)
		value.Type = &typeVar
	} else {
		value.Type = nil
	}

	// No error
	return nil
}

// Azure Files or Blob Storage access information value for dictionary storage.
type AzureStorageInfoValue_STATUS struct {
	// AccountName: Name of the storage account.
	AccountName *string `json:"accountName,omitempty"`

	// MountPath: Path to mount the storage within the site's runtime environment.
	MountPath *string `json:"mountPath,omitempty"`

	// ShareName: Name of the file share (container name, for Blob storage).
	ShareName *string `json:"shareName,omitempty"`

	// State: State of the storage account.
	State *AzureStorageInfoValue_State_STATUS `json:"state,omitempty"`

	// Type: Type of storage.
	Type *AzureStorageInfoValue_Type_STATUS `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &AzureStorageInfoValue_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (value *AzureStorageInfoValue_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &AzureStorageInfoValue_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (value *AzureStorageInfoValue_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(AzureStorageInfoValue_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected AzureStorageInfoValue_STATUS_ARM, got %T", armInput)
	}

	// Set property "AccountName":
	if typedInput.AccountName != nil {
		accountName := *typedInput.AccountName
		value.AccountName = &accountName
	}

	// Set property "MountPath":
	if typedInput.MountPath != nil {
		mountPath := *typedInput.MountPath
		value.MountPath = &mountPath
	}

	// Set property "ShareName":
	if typedInput.ShareName != nil {
		shareName := *typedInput.ShareName
		value.ShareName = &shareName
	}

	// Set property "State":
	if typedInput.State != nil {
		state := *typedInput.State
		value.State = &state
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		value.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_AzureStorageInfoValue_STATUS populates our AzureStorageInfoValue_STATUS from the provided source AzureStorageInfoValue_STATUS
func (value *AzureStorageInfoValue_STATUS) AssignProperties_From_AzureStorageInfoValue_STATUS(source *v20220301s.AzureStorageInfoValue_STATUS) error {

	// AccountName
	value.AccountName = genruntime.ClonePointerToString(source.AccountName)

	// MountPath
	value.MountPath = genruntime.ClonePointerToString(source.MountPath)

	// ShareName
	value.ShareName = genruntime.ClonePointerToString(source.ShareName)

	// State
	if source.State != nil {
		state := AzureStorageInfoValue_State_STATUS(*source.State)
		value.State = &state
	} else {
		value.State = nil
	}

	// Type
	if source.Type != nil {
		typeVar := AzureStorageInfoValue_Type_STATUS(*source.Type)
		value.Type = &typeVar
	} else {
		value.Type = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AzureStorageInfoValue_STATUS populates the provided destination AzureStorageInfoValue_STATUS from our AzureStorageInfoValue_STATUS
func (value *AzureStorageInfoValue_STATUS) AssignProperties_To_AzureStorageInfoValue_STATUS(destination *v20220301s.AzureStorageInfoValue_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AccountName
	destination.AccountName = genruntime.ClonePointerToString(value.AccountName)

	// MountPath
	destination.MountPath = genruntime.ClonePointerToString(value.MountPath)

	// ShareName
	destination.ShareName = genruntime.ClonePointerToString(value.ShareName)

	// State
	if value.State != nil {
		state := string(*value.State)
		destination.State = &state
	} else {
		destination.State = nil
	}

	// Type
	if value.Type != nil {
		typeVar := string(*value.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Database connection string information.
type ConnStringInfo struct {
	// ConnectionString: Connection string value.
	ConnectionString *string `json:"connectionString,omitempty"`

	// Name: Name of connection string.
	Name *string `json:"name,omitempty"`

	// Type: Type of database.
	Type *ConnStringInfo_Type `json:"type,omitempty"`
}

var _ genruntime.ARMTransformer = &ConnStringInfo{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (info *ConnStringInfo) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if info == nil {
		return nil, nil
	}
	result := &ConnStringInfo_ARM{}

	// Set property "ConnectionString":
	if info.ConnectionString != nil {
		connectionString := *info.ConnectionString
		result.ConnectionString = &connectionString
	}

	// Set property "Name":
	if info.Name != nil {
		name := *info.Name
		result.Name = &name
	}

	// Set property "Type":
	if info.Type != nil {
		typeVar := *info.Type
		result.Type = &typeVar
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (info *ConnStringInfo) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ConnStringInfo_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (info *ConnStringInfo) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ConnStringInfo_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ConnStringInfo_ARM, got %T", armInput)
	}

	// Set property "ConnectionString":
	if typedInput.ConnectionString != nil {
		connectionString := *typedInput.ConnectionString
		info.ConnectionString = &connectionString
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		info.Name = &name
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		info.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_ConnStringInfo populates our ConnStringInfo from the provided source ConnStringInfo
func (info *ConnStringInfo) AssignProperties_From_ConnStringInfo(source *v20220301s.ConnStringInfo) error {

	// ConnectionString
	info.ConnectionString = genruntime.ClonePointerToString(source.ConnectionString)

	// Name
	info.Name = genruntime.ClonePointerToString(source.Name)

	// Type
	if source.Type != nil {
		typeVar := ConnStringInfo_Type(*source.Type)
		info.Type = &typeVar
	} else {
		info.Type = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ConnStringInfo populates the provided destination ConnStringInfo from our ConnStringInfo
func (info *ConnStringInfo) AssignProperties_To_ConnStringInfo(destination *v20220301s.ConnStringInfo) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ConnectionString
	destination.ConnectionString = genruntime.ClonePointerToString(info.ConnectionString)

	// Name
	destination.Name = genruntime.ClonePointerToString(info.Name)

	// Type
	if info.Type != nil {
		typeVar := string(*info.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ConnStringInfo_STATUS populates our ConnStringInfo from the provided source ConnStringInfo_STATUS
func (info *ConnStringInfo) Initialize_From_ConnStringInfo_STATUS(source *ConnStringInfo_STATUS) error {

	// ConnectionString
	info.ConnectionString = genruntime.ClonePointerToString(source.ConnectionString)

	// Name
	info.Name = genruntime.ClonePointerToString(source.Name)

	// Type
	if source.Type != nil {
		typeVar := ConnStringInfo_Type(*source.Type)
		info.Type = &typeVar
	} else {
		info.Type = nil
	}

	// No error
	return nil
}

// Database connection string information.
type ConnStringInfo_STATUS struct {
	// ConnectionString: Connection string value.
	ConnectionString *string `json:"connectionString,omitempty"`

	// Name: Name of connection string.
	Name *string `json:"name,omitempty"`

	// Type: Type of database.
	Type *ConnStringInfo_Type_STATUS `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &ConnStringInfo_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (info *ConnStringInfo_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ConnStringInfo_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (info *ConnStringInfo_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ConnStringInfo_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ConnStringInfo_STATUS_ARM, got %T", armInput)
	}

	// Set property "ConnectionString":
	if typedInput.ConnectionString != nil {
		connectionString := *typedInput.ConnectionString
		info.ConnectionString = &connectionString
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		info.Name = &name
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		info.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_ConnStringInfo_STATUS populates our ConnStringInfo_STATUS from the provided source ConnStringInfo_STATUS
func (info *ConnStringInfo_STATUS) AssignProperties_From_ConnStringInfo_STATUS(source *v20220301s.ConnStringInfo_STATUS) error {

	// ConnectionString
	info.ConnectionString = genruntime.ClonePointerToString(source.ConnectionString)

	// Name
	info.Name = genruntime.ClonePointerToString(source.Name)

	// Type
	if source.Type != nil {
		typeVar := ConnStringInfo_Type_STATUS(*source.Type)
		info.Type = &typeVar
	} else {
		info.Type = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ConnStringInfo_STATUS populates the provided destination ConnStringInfo_STATUS from our ConnStringInfo_STATUS
func (info *ConnStringInfo_STATUS) AssignProperties_To_ConnStringInfo_STATUS(destination *v20220301s.ConnStringInfo_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ConnectionString
	destination.ConnectionString = genruntime.ClonePointerToString(info.ConnectionString)

	// Name
	destination.Name = genruntime.ClonePointerToString(info.Name)

	// Type
	if info.Type != nil {
		typeVar := string(*info.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Cross-Origin Resource Sharing (CORS) settings for the app.
type CorsSettings struct {
	// AllowedOrigins: Gets or sets the list of origins that should be allowed to make cross-origin
	// calls (for example: http://example.com:12345). Use "*" to allow all.
	AllowedOrigins []string `json:"allowedOrigins,omitempty"`

	// SupportCredentials: Gets or sets whether CORS requests with credentials are allowed. See
	// https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#Requests_with_credentials
	// for more details.
	SupportCredentials *bool `json:"supportCredentials,omitempty"`
}

var _ genruntime.ARMTransformer = &CorsSettings{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (settings *CorsSettings) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if settings == nil {
		return nil, nil
	}
	result := &CorsSettings_ARM{}

	// Set property "AllowedOrigins":
	for _, item := range settings.AllowedOrigins {
		result.AllowedOrigins = append(result.AllowedOrigins, item)
	}

	// Set property "SupportCredentials":
	if settings.SupportCredentials != nil {
		supportCredentials := *settings.SupportCredentials
		result.SupportCredentials = &supportCredentials
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *CorsSettings) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &CorsSettings_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *CorsSettings) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(CorsSettings_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected CorsSettings_ARM, got %T", armInput)
	}

	// Set property "AllowedOrigins":
	for _, item := range typedInput.AllowedOrigins {
		settings.AllowedOrigins = append(settings.AllowedOrigins, item)
	}

	// Set property "SupportCredentials":
	if typedInput.SupportCredentials != nil {
		supportCredentials := *typedInput.SupportCredentials
		settings.SupportCredentials = &supportCredentials
	}

	// No error
	return nil
}

// AssignProperties_From_CorsSettings populates our CorsSettings from the provided source CorsSettings
func (settings *CorsSettings) AssignProperties_From_CorsSettings(source *v20220301s.CorsSettings) error {

	// AllowedOrigins
	settings.AllowedOrigins = genruntime.CloneSliceOfString(source.AllowedOrigins)

	// SupportCredentials
	if source.SupportCredentials != nil {
		supportCredential := *source.SupportCredentials
		settings.SupportCredentials = &supportCredential
	} else {
		settings.SupportCredentials = nil
	}

	// No error
	return nil
}

// AssignProperties_To_CorsSettings populates the provided destination CorsSettings from our CorsSettings
func (settings *CorsSettings) AssignProperties_To_CorsSettings(destination *v20220301s.CorsSettings) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AllowedOrigins
	destination.AllowedOrigins = genruntime.CloneSliceOfString(settings.AllowedOrigins)

	// SupportCredentials
	if settings.SupportCredentials != nil {
		supportCredential := *settings.SupportCredentials
		destination.SupportCredentials = &supportCredential
	} else {
		destination.SupportCredentials = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_CorsSettings_STATUS populates our CorsSettings from the provided source CorsSettings_STATUS
func (settings *CorsSettings) Initialize_From_CorsSettings_STATUS(source *CorsSettings_STATUS) error {

	// AllowedOrigins
	settings.AllowedOrigins = genruntime.CloneSliceOfString(source.AllowedOrigins)

	// SupportCredentials
	if source.SupportCredentials != nil {
		supportCredential := *source.SupportCredentials
		settings.SupportCredentials = &supportCredential
	} else {
		settings.SupportCredentials = nil
	}

	// No error
	return nil
}

// Cross-Origin Resource Sharing (CORS) settings for the app.
type CorsSettings_STATUS struct {
	// AllowedOrigins: Gets or sets the list of origins that should be allowed to make cross-origin
	// calls (for example: http://example.com:12345). Use "*" to allow all.
	AllowedOrigins []string `json:"allowedOrigins,omitempty"`

	// SupportCredentials: Gets or sets whether CORS requests with credentials are allowed. See
	// https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#Requests_with_credentials
	// for more details.
	SupportCredentials *bool `json:"supportCredentials,omitempty"`
}

var _ genruntime.FromARMConverter = &CorsSettings_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *CorsSettings_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &CorsSettings_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *CorsSettings_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(CorsSettings_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected CorsSettings_STATUS_ARM, got %T", armInput)
	}

	// Set property "AllowedOrigins":
	for _, item := range typedInput.AllowedOrigins {
		settings.AllowedOrigins = append(settings.AllowedOrigins, item)
	}

	// Set property "SupportCredentials":
	if typedInput.SupportCredentials != nil {
		supportCredentials := *typedInput.SupportCredentials
		settings.SupportCredentials = &supportCredentials
	}

	// No error
	return nil
}

// AssignProperties_From_CorsSettings_STATUS populates our CorsSettings_STATUS from the provided source CorsSettings_STATUS
func (settings *CorsSettings_STATUS) AssignProperties_From_CorsSettings_STATUS(source *v20220301s.CorsSettings_STATUS) error {

	// AllowedOrigins
	settings.AllowedOrigins = genruntime.CloneSliceOfString(source.AllowedOrigins)

	// SupportCredentials
	if source.SupportCredentials != nil {
		supportCredential := *source.SupportCredentials
		settings.SupportCredentials = &supportCredential
	} else {
		settings.SupportCredentials = nil
	}

	// No error
	return nil
}

// AssignProperties_To_CorsSettings_STATUS populates the provided destination CorsSettings_STATUS from our CorsSettings_STATUS
func (settings *CorsSettings_STATUS) AssignProperties_To_CorsSettings_STATUS(destination *v20220301s.CorsSettings_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AllowedOrigins
	destination.AllowedOrigins = genruntime.CloneSliceOfString(settings.AllowedOrigins)

	// SupportCredentials
	if settings.SupportCredentials != nil {
		supportCredential := *settings.SupportCredentials
		destination.SupportCredentials = &supportCredential
	} else {
		destination.SupportCredentials = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Routing rules in production experiments.
type Experiments struct {
	// RampUpRules: List of ramp-up rules.
	RampUpRules []RampUpRule `json:"rampUpRules,omitempty"`
}

var _ genruntime.ARMTransformer = &Experiments{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (experiments *Experiments) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if experiments == nil {
		return nil, nil
	}
	result := &Experiments_ARM{}

	// Set property "RampUpRules":
	for _, item := range experiments.RampUpRules {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.RampUpRules = append(result.RampUpRules, *item_ARM.(*RampUpRule_ARM))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (experiments *Experiments) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Experiments_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (experiments *Experiments) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Experiments_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Experiments_ARM, got %T", armInput)
	}

	// Set property "RampUpRules":
	for _, item := range typedInput.RampUpRules {
		var item1 RampUpRule
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		experiments.RampUpRules = append(experiments.RampUpRules, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_Experiments populates our Experiments from the provided source Experiments
func (experiments *Experiments) AssignProperties_From_Experiments(source *v20220301s.Experiments) error {

	// RampUpRules
	if source.RampUpRules != nil {
		rampUpRuleList := make([]RampUpRule, len(source.RampUpRules))
		for rampUpRuleIndex, rampUpRuleItem := range source.RampUpRules {
			// Shadow the loop variable to avoid aliasing
			rampUpRuleItem := rampUpRuleItem
			var rampUpRule RampUpRule
			err := rampUpRule.AssignProperties_From_RampUpRule(&rampUpRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_RampUpRule() to populate field RampUpRules")
			}
			rampUpRuleList[rampUpRuleIndex] = rampUpRule
		}
		experiments.RampUpRules = rampUpRuleList
	} else {
		experiments.RampUpRules = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Experiments populates the provided destination Experiments from our Experiments
func (experiments *Experiments) AssignProperties_To_Experiments(destination *v20220301s.Experiments) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// RampUpRules
	if experiments.RampUpRules != nil {
		rampUpRuleList := make([]v20220301s.RampUpRule, len(experiments.RampUpRules))
		for rampUpRuleIndex, rampUpRuleItem := range experiments.RampUpRules {
			// Shadow the loop variable to avoid aliasing
			rampUpRuleItem := rampUpRuleItem
			var rampUpRule v20220301s.RampUpRule
			err := rampUpRuleItem.AssignProperties_To_RampUpRule(&rampUpRule)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_RampUpRule() to populate field RampUpRules")
			}
			rampUpRuleList[rampUpRuleIndex] = rampUpRule
		}
		destination.RampUpRules = rampUpRuleList
	} else {
		destination.RampUpRules = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_Experiments_STATUS populates our Experiments from the provided source Experiments_STATUS
func (experiments *Experiments) Initialize_From_Experiments_STATUS(source *Experiments_STATUS) error {

	// RampUpRules
	if source.RampUpRules != nil {
		rampUpRuleList := make([]RampUpRule, len(source.RampUpRules))
		for rampUpRuleIndex, rampUpRuleItem := range source.RampUpRules {
			// Shadow the loop variable to avoid aliasing
			rampUpRuleItem := rampUpRuleItem
			var rampUpRule RampUpRule
			err := rampUpRule.Initialize_From_RampUpRule_STATUS(&rampUpRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_RampUpRule_STATUS() to populate field RampUpRules")
			}
			rampUpRuleList[rampUpRuleIndex] = rampUpRule
		}
		experiments.RampUpRules = rampUpRuleList
	} else {
		experiments.RampUpRules = nil
	}

	// No error
	return nil
}

// Routing rules in production experiments.
type Experiments_STATUS struct {
	// RampUpRules: List of ramp-up rules.
	RampUpRules []RampUpRule_STATUS `json:"rampUpRules,omitempty"`
}

var _ genruntime.FromARMConverter = &Experiments_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (experiments *Experiments_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Experiments_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (experiments *Experiments_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Experiments_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Experiments_STATUS_ARM, got %T", armInput)
	}

	// Set property "RampUpRules":
	for _, item := range typedInput.RampUpRules {
		var item1 RampUpRule_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		experiments.RampUpRules = append(experiments.RampUpRules, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_Experiments_STATUS populates our Experiments_STATUS from the provided source Experiments_STATUS
func (experiments *Experiments_STATUS) AssignProperties_From_Experiments_STATUS(source *v20220301s.Experiments_STATUS) error {

	// RampUpRules
	if source.RampUpRules != nil {
		rampUpRuleList := make([]RampUpRule_STATUS, len(source.RampUpRules))
		for rampUpRuleIndex, rampUpRuleItem := range source.RampUpRules {
			// Shadow the loop variable to avoid aliasing
			rampUpRuleItem := rampUpRuleItem
			var rampUpRule RampUpRule_STATUS
			err := rampUpRule.AssignProperties_From_RampUpRule_STATUS(&rampUpRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_RampUpRule_STATUS() to populate field RampUpRules")
			}
			rampUpRuleList[rampUpRuleIndex] = rampUpRule
		}
		experiments.RampUpRules = rampUpRuleList
	} else {
		experiments.RampUpRules = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Experiments_STATUS populates the provided destination Experiments_STATUS from our Experiments_STATUS
func (experiments *Experiments_STATUS) AssignProperties_To_Experiments_STATUS(destination *v20220301s.Experiments_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// RampUpRules
	if experiments.RampUpRules != nil {
		rampUpRuleList := make([]v20220301s.RampUpRule_STATUS, len(experiments.RampUpRules))
		for rampUpRuleIndex, rampUpRuleItem := range experiments.RampUpRules {
			// Shadow the loop variable to avoid aliasing
			rampUpRuleItem := rampUpRuleItem
			var rampUpRule v20220301s.RampUpRule_STATUS
			err := rampUpRuleItem.AssignProperties_To_RampUpRule_STATUS(&rampUpRule)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_RampUpRule_STATUS() to populate field RampUpRules")
			}
			rampUpRuleList[rampUpRuleIndex] = rampUpRule
		}
		destination.RampUpRules = rampUpRuleList
	} else {
		destination.RampUpRules = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The IIS handler mappings used to define which handler processes HTTP requests with certain extension.
// For example, it
// is used to configure php-cgi.exe process to handle all HTTP requests with *.php extension.
type HandlerMapping struct {
	// Arguments: Command-line arguments to be passed to the script processor.
	Arguments *string `json:"arguments,omitempty"`

	// Extension: Requests with this extension will be handled using the specified FastCGI application.
	Extension *string `json:"extension,omitempty"`

	// ScriptProcessor: The absolute path to the FastCGI application.
	ScriptProcessor *string `json:"scriptProcessor,omitempty"`
}

var _ genruntime.ARMTransformer = &HandlerMapping{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (mapping *HandlerMapping) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if mapping == nil {
		return nil, nil
	}
	result := &HandlerMapping_ARM{}

	// Set property "Arguments":
	if mapping.Arguments != nil {
		arguments := *mapping.Arguments
		result.Arguments = &arguments
	}

	// Set property "Extension":
	if mapping.Extension != nil {
		extension := *mapping.Extension
		result.Extension = &extension
	}

	// Set property "ScriptProcessor":
	if mapping.ScriptProcessor != nil {
		scriptProcessor := *mapping.ScriptProcessor
		result.ScriptProcessor = &scriptProcessor
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (mapping *HandlerMapping) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &HandlerMapping_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (mapping *HandlerMapping) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(HandlerMapping_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected HandlerMapping_ARM, got %T", armInput)
	}

	// Set property "Arguments":
	if typedInput.Arguments != nil {
		arguments := *typedInput.Arguments
		mapping.Arguments = &arguments
	}

	// Set property "Extension":
	if typedInput.Extension != nil {
		extension := *typedInput.Extension
		mapping.Extension = &extension
	}

	// Set property "ScriptProcessor":
	if typedInput.ScriptProcessor != nil {
		scriptProcessor := *typedInput.ScriptProcessor
		mapping.ScriptProcessor = &scriptProcessor
	}

	// No error
	return nil
}

// AssignProperties_From_HandlerMapping populates our HandlerMapping from the provided source HandlerMapping
func (mapping *HandlerMapping) AssignProperties_From_HandlerMapping(source *v20220301s.HandlerMapping) error {

	// Arguments
	mapping.Arguments = genruntime.ClonePointerToString(source.Arguments)

	// Extension
	mapping.Extension = genruntime.ClonePointerToString(source.Extension)

	// ScriptProcessor
	mapping.ScriptProcessor = genruntime.ClonePointerToString(source.ScriptProcessor)

	// No error
	return nil
}

// AssignProperties_To_HandlerMapping populates the provided destination HandlerMapping from our HandlerMapping
func (mapping *HandlerMapping) AssignProperties_To_HandlerMapping(destination *v20220301s.HandlerMapping) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Arguments
	destination.Arguments = genruntime.ClonePointerToString(mapping.Arguments)

	// Extension
	destination.Extension = genruntime.ClonePointerToString(mapping.Extension)

	// ScriptProcessor
	destination.ScriptProcessor = genruntime.ClonePointerToString(mapping.ScriptProcessor)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_HandlerMapping_STATUS populates our HandlerMapping from the provided source HandlerMapping_STATUS
func (mapping *HandlerMapping) Initialize_From_HandlerMapping_STATUS(source *HandlerMapping_STATUS) error {

	// Arguments
	mapping.Arguments = genruntime.ClonePointerToString(source.Arguments)

	// Extension
	mapping.Extension = genruntime.ClonePointerToString(source.Extension)

	// ScriptProcessor
	mapping.ScriptProcessor = genruntime.ClonePointerToString(source.ScriptProcessor)

	// No error
	return nil
}

// The IIS handler mappings used to define which handler processes HTTP requests with certain extension.
// For example, it
// is used to configure php-cgi.exe process to handle all HTTP requests with *.php extension.
type HandlerMapping_STATUS struct {
	// Arguments: Command-line arguments to be passed to the script processor.
	Arguments *string `json:"arguments,omitempty"`

	// Extension: Requests with this extension will be handled using the specified FastCGI application.
	Extension *string `json:"extension,omitempty"`

	// ScriptProcessor: The absolute path to the FastCGI application.
	ScriptProcessor *string `json:"scriptProcessor,omitempty"`
}

var _ genruntime.FromARMConverter = &HandlerMapping_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (mapping *HandlerMapping_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &HandlerMapping_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (mapping *HandlerMapping_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(HandlerMapping_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected HandlerMapping_STATUS_ARM, got %T", armInput)
	}

	// Set property "Arguments":
	if typedInput.Arguments != nil {
		arguments := *typedInput.Arguments
		mapping.Arguments = &arguments
	}

	// Set property "Extension":
	if typedInput.Extension != nil {
		extension := *typedInput.Extension
		mapping.Extension = &extension
	}

	// Set property "ScriptProcessor":
	if typedInput.ScriptProcessor != nil {
		scriptProcessor := *typedInput.ScriptProcessor
		mapping.ScriptProcessor = &scriptProcessor
	}

	// No error
	return nil
}

// AssignProperties_From_HandlerMapping_STATUS populates our HandlerMapping_STATUS from the provided source HandlerMapping_STATUS
func (mapping *HandlerMapping_STATUS) AssignProperties_From_HandlerMapping_STATUS(source *v20220301s.HandlerMapping_STATUS) error {

	// Arguments
	mapping.Arguments = genruntime.ClonePointerToString(source.Arguments)

	// Extension
	mapping.Extension = genruntime.ClonePointerToString(source.Extension)

	// ScriptProcessor
	mapping.ScriptProcessor = genruntime.ClonePointerToString(source.ScriptProcessor)

	// No error
	return nil
}

// AssignProperties_To_HandlerMapping_STATUS populates the provided destination HandlerMapping_STATUS from our HandlerMapping_STATUS
func (mapping *HandlerMapping_STATUS) AssignProperties_To_HandlerMapping_STATUS(destination *v20220301s.HandlerMapping_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Arguments
	destination.Arguments = genruntime.ClonePointerToString(mapping.Arguments)

	// Extension
	destination.Extension = genruntime.ClonePointerToString(mapping.Extension)

	// ScriptProcessor
	destination.ScriptProcessor = genruntime.ClonePointerToString(mapping.ScriptProcessor)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Repository","Standard"}
type HostNameSslState_HostType string

const (
	HostNameSslState_HostType_Repository = HostNameSslState_HostType("Repository")
	HostNameSslState_HostType_Standard   = HostNameSslState_HostType("Standard")
)

type HostNameSslState_HostType_STATUS string

const (
	HostNameSslState_HostType_STATUS_Repository = HostNameSslState_HostType_STATUS("Repository")
	HostNameSslState_HostType_STATUS_Standard   = HostNameSslState_HostType_STATUS("Standard")
)

// +kubebuilder:validation:Enum={"Disabled","IpBasedEnabled","SniEnabled"}
type HostNameSslState_SslState string

const (
	HostNameSslState_SslState_Disabled       = HostNameSslState_SslState("Disabled")
	HostNameSslState_SslState_IpBasedEnabled = HostNameSslState_SslState("IpBasedEnabled")
	HostNameSslState_SslState_SniEnabled     = HostNameSslState_SslState("SniEnabled")
)

type HostNameSslState_SslState_STATUS string

const (
	HostNameSslState_SslState_STATUS_Disabled       = HostNameSslState_SslState_STATUS("Disabled")
	HostNameSslState_SslState_STATUS_IpBasedEnabled = HostNameSslState_SslState_STATUS("IpBasedEnabled")
	HostNameSslState_SslState_STATUS_SniEnabled     = HostNameSslState_SslState_STATUS("SniEnabled")
)

// IP security restriction on an app.
type IpSecurityRestriction struct {
	// Action: Allow or Deny access for this IP range.
	Action *string `json:"action,omitempty"`

	// Description: IP restriction rule description.
	Description *string `json:"description,omitempty"`

	// Headers: IP restriction rule headers.
	// X-Forwarded-Host (https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-Host#Examples).
	// The matching logic is ..
	// - If the property is null or empty (default), all hosts(or lack of) are allowed.
	// - A value is compared using ordinal-ignore-case (excluding port number).
	// - Subdomain wildcards are permitted but don't match the root domain. For example, *.contoso.com matches the subdomain
	// foo.contoso.com
	// but not the root domain contoso.com or multi-level foo.bar.contoso.com
	// - Unicode host names are allowed but are converted to Punycode for matching.
	// X-Forwarded-For (https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-For#Examples).
	// The matching logic is ..
	// - If the property is null or empty (default), any forwarded-for chains (or lack of) are allowed.
	// - If any address (excluding port number) in the chain (comma separated) matches the CIDR defined by the property.
	// X-Azure-FDID and X-FD-HealthProbe.
	// The matching logic is exact match.
	Headers map[string][]string `json:"headers,omitempty"`

	// IpAddress: IP address the security restriction is valid for.
	// It can be in form of pure ipv4 address (required SubnetMask property) or
	// CIDR notation such as ipv4/mask (leading bit match). For CIDR,
	// SubnetMask property must not be specified.
	IpAddress *string `json:"ipAddress,omitempty"`

	// Name: IP restriction rule name.
	Name *string `json:"name,omitempty"`

	// Priority: Priority of IP restriction rule.
	Priority *int `json:"priority,omitempty"`

	// SubnetMask: Subnet mask for the range of IP addresses the restriction is valid for.
	SubnetMask *string `json:"subnetMask,omitempty"`

	// SubnetTrafficTag: (internal) Subnet traffic tag
	SubnetTrafficTag *int `json:"subnetTrafficTag,omitempty"`

	// Tag: Defines what this IP filter will be used for. This is to support IP filtering on proxies.
	Tag *IpSecurityRestriction_Tag `json:"tag,omitempty"`

	// VnetSubnetResourceReference: Virtual network resource id
	VnetSubnetResourceReference *genruntime.ResourceReference `armReference:"VnetSubnetResourceId" json:"vnetSubnetResourceReference,omitempty"`

	// VnetTrafficTag: (internal) Vnet traffic tag
	VnetTrafficTag *int `json:"vnetTrafficTag,omitempty"`
}

var _ genruntime.ARMTransformer = &IpSecurityRestriction{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (restriction *IpSecurityRestriction) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if restriction == nil {
		return nil, nil
	}
	result := &IpSecurityRestriction_ARM{}

	// Set property "Action":
	if restriction.Action != nil {
		action := *restriction.Action
		result.Action = &action
	}

	// Set property "Description":
	if restriction.Description != nil {
		description := *restriction.Description
		result.Description = &description
	}

	// Set property "Headers":
	if restriction.Headers != nil {
		result.Headers = make(map[string][]string, len(restriction.Headers))
		for key, value := range restriction.Headers {
			var valueTemp []string
			for _, item := range value {
				valueTemp = append(valueTemp, item)
			}
			result.Headers[key] = valueTemp
		}
	}

	// Set property "IpAddress":
	if restriction.IpAddress != nil {
		ipAddress := *restriction.IpAddress
		result.IpAddress = &ipAddress
	}

	// Set property "Name":
	if restriction.Name != nil {
		name := *restriction.Name
		result.Name = &name
	}

	// Set property "Priority":
	if restriction.Priority != nil {
		priority := *restriction.Priority
		result.Priority = &priority
	}

	// Set property "SubnetMask":
	if restriction.SubnetMask != nil {
		subnetMask := *restriction.SubnetMask
		result.SubnetMask = &subnetMask
	}

	// Set property "SubnetTrafficTag":
	if restriction.SubnetTrafficTag != nil {
		subnetTrafficTag := *restriction.SubnetTrafficTag
		result.SubnetTrafficTag = &subnetTrafficTag
	}

	// Set property "Tag":
	if restriction.Tag != nil {
		tag := *restriction.Tag
		result.Tag = &tag
	}

	// Set property "VnetSubnetResourceId":
	if restriction.VnetSubnetResourceReference != nil {
		vnetSubnetResourceReferenceARMID, err := resolved.ResolvedReferences.Lookup(*restriction.VnetSubnetResourceReference)
		if err != nil {
			return nil, err
		}
		vnetSubnetResourceReference := vnetSubnetResourceReferenceARMID
		result.VnetSubnetResourceId = &vnetSubnetResourceReference
	}

	// Set property "VnetTrafficTag":
	if restriction.VnetTrafficTag != nil {
		vnetTrafficTag := *restriction.VnetTrafficTag
		result.VnetTrafficTag = &vnetTrafficTag
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (restriction *IpSecurityRestriction) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &IpSecurityRestriction_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (restriction *IpSecurityRestriction) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(IpSecurityRestriction_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected IpSecurityRestriction_ARM, got %T", armInput)
	}

	// Set property "Action":
	if typedInput.Action != nil {
		action := *typedInput.Action
		restriction.Action = &action
	}

	// Set property "Description":
	if typedInput.Description != nil {
		description := *typedInput.Description
		restriction.Description = &description
	}

	// Set property "Headers":
	if typedInput.Headers != nil {
		restriction.Headers = make(map[string][]string, len(typedInput.Headers))
		for key, value := range typedInput.Headers {
			var valueTemp []string
			for _, item := range value {
				valueTemp = append(valueTemp, item)
			}
			restriction.Headers[key] = valueTemp
		}
	}

	// Set property "IpAddress":
	if typedInput.IpAddress != nil {
		ipAddress := *typedInput.IpAddress
		restriction.IpAddress = &ipAddress
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		restriction.Name = &name
	}

	// Set property "Priority":
	if typedInput.Priority != nil {
		priority := *typedInput.Priority
		restriction.Priority = &priority
	}

	// Set property "SubnetMask":
	if typedInput.SubnetMask != nil {
		subnetMask := *typedInput.SubnetMask
		restriction.SubnetMask = &subnetMask
	}

	// Set property "SubnetTrafficTag":
	if typedInput.SubnetTrafficTag != nil {
		subnetTrafficTag := *typedInput.SubnetTrafficTag
		restriction.SubnetTrafficTag = &subnetTrafficTag
	}

	// Set property "Tag":
	if typedInput.Tag != nil {
		tag := *typedInput.Tag
		restriction.Tag = &tag
	}

	// no assignment for property "VnetSubnetResourceReference"

	// Set property "VnetTrafficTag":
	if typedInput.VnetTrafficTag != nil {
		vnetTrafficTag := *typedInput.VnetTrafficTag
		restriction.VnetTrafficTag = &vnetTrafficTag
	}

	// No error
	return nil
}

// AssignProperties_From_IpSecurityRestriction populates our IpSecurityRestriction from the provided source IpSecurityRestriction
func (restriction *IpSecurityRestriction) AssignProperties_From_IpSecurityRestriction(source *v20220301s.IpSecurityRestriction) error {

	// Action
	restriction.Action = genruntime.ClonePointerToString(source.Action)

	// Description
	restriction.Description = genruntime.ClonePointerToString(source.Description)

	// Headers
	if source.Headers != nil {
		headerMap := make(map[string][]string, len(source.Headers))
		for headerKey, headerValue := range source.Headers {
			// Shadow the loop variable to avoid aliasing
			headerValue := headerValue
			headerMap[headerKey] = genruntime.CloneSliceOfString(headerValue)
		}
		restriction.Headers = headerMap
	} else {
		restriction.Headers = nil
	}

	// IpAddress
	restriction.IpAddress = genruntime.ClonePointerToString(source.IpAddress)

	// Name
	restriction.Name = genruntime.ClonePointerToString(source.Name)

	// Priority
	restriction.Priority = genruntime.ClonePointerToInt(source.Priority)

	// SubnetMask
	restriction.SubnetMask = genruntime.ClonePointerToString(source.SubnetMask)

	// SubnetTrafficTag
	restriction.SubnetTrafficTag = genruntime.ClonePointerToInt(source.SubnetTrafficTag)

	// Tag
	if source.Tag != nil {
		tag := IpSecurityRestriction_Tag(*source.Tag)
		restriction.Tag = &tag
	} else {
		restriction.Tag = nil
	}

	// VnetSubnetResourceReference
	if source.VnetSubnetResourceReference != nil {
		vnetSubnetResourceReference := source.VnetSubnetResourceReference.Copy()
		restriction.VnetSubnetResourceReference = &vnetSubnetResourceReference
	} else {
		restriction.VnetSubnetResourceReference = nil
	}

	// VnetTrafficTag
	restriction.VnetTrafficTag = genruntime.ClonePointerToInt(source.VnetTrafficTag)

	// No error
	return nil
}

// AssignProperties_To_IpSecurityRestriction populates the provided destination IpSecurityRestriction from our IpSecurityRestriction
func (restriction *IpSecurityRestriction) AssignProperties_To_IpSecurityRestriction(destination *v20220301s.IpSecurityRestriction) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Action
	destination.Action = genruntime.ClonePointerToString(restriction.Action)

	// Description
	destination.Description = genruntime.ClonePointerToString(restriction.Description)

	// Headers
	if restriction.Headers != nil {
		headerMap := make(map[string][]string, len(restriction.Headers))
		for headerKey, headerValue := range restriction.Headers {
			// Shadow the loop variable to avoid aliasing
			headerValue := headerValue
			headerMap[headerKey] = genruntime.CloneSliceOfString(headerValue)
		}
		destination.Headers = headerMap
	} else {
		destination.Headers = nil
	}

	// IpAddress
	destination.IpAddress = genruntime.ClonePointerToString(restriction.IpAddress)

	// Name
	destination.Name = genruntime.ClonePointerToString(restriction.Name)

	// Priority
	destination.Priority = genruntime.ClonePointerToInt(restriction.Priority)

	// SubnetMask
	destination.SubnetMask = genruntime.ClonePointerToString(restriction.SubnetMask)

	// SubnetTrafficTag
	destination.SubnetTrafficTag = genruntime.ClonePointerToInt(restriction.SubnetTrafficTag)

	// Tag
	if restriction.Tag != nil {
		tag := string(*restriction.Tag)
		destination.Tag = &tag
	} else {
		destination.Tag = nil
	}

	// VnetSubnetResourceReference
	if restriction.VnetSubnetResourceReference != nil {
		vnetSubnetResourceReference := restriction.VnetSubnetResourceReference.Copy()
		destination.VnetSubnetResourceReference = &vnetSubnetResourceReference
	} else {
		destination.VnetSubnetResourceReference = nil
	}

	// VnetTrafficTag
	destination.VnetTrafficTag = genruntime.ClonePointerToInt(restriction.VnetTrafficTag)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_IpSecurityRestriction_STATUS populates our IpSecurityRestriction from the provided source IpSecurityRestriction_STATUS
func (restriction *IpSecurityRestriction) Initialize_From_IpSecurityRestriction_STATUS(source *IpSecurityRestriction_STATUS) error {

	// Action
	restriction.Action = genruntime.ClonePointerToString(source.Action)

	// Description
	restriction.Description = genruntime.ClonePointerToString(source.Description)

	// Headers
	if source.Headers != nil {
		headerMap := make(map[string][]string, len(source.Headers))
		for headerKey, headerValue := range source.Headers {
			// Shadow the loop variable to avoid aliasing
			headerValue := headerValue
			headerMap[headerKey] = genruntime.CloneSliceOfString(headerValue)
		}
		restriction.Headers = headerMap
	} else {
		restriction.Headers = nil
	}

	// IpAddress
	restriction.IpAddress = genruntime.ClonePointerToString(source.IpAddress)

	// Name
	restriction.Name = genruntime.ClonePointerToString(source.Name)

	// Priority
	restriction.Priority = genruntime.ClonePointerToInt(source.Priority)

	// SubnetMask
	restriction.SubnetMask = genruntime.ClonePointerToString(source.SubnetMask)

	// SubnetTrafficTag
	restriction.SubnetTrafficTag = genruntime.ClonePointerToInt(source.SubnetTrafficTag)

	// Tag
	if source.Tag != nil {
		tag := IpSecurityRestriction_Tag(*source.Tag)
		restriction.Tag = &tag
	} else {
		restriction.Tag = nil
	}

	// VnetSubnetResourceReference
	if source.VnetSubnetResourceId != nil {
		vnetSubnetResourceReference := genruntime.CreateResourceReferenceFromARMID(*source.VnetSubnetResourceId)
		restriction.VnetSubnetResourceReference = &vnetSubnetResourceReference
	} else {
		restriction.VnetSubnetResourceReference = nil
	}

	// VnetTrafficTag
	restriction.VnetTrafficTag = genruntime.ClonePointerToInt(source.VnetTrafficTag)

	// No error
	return nil
}

// IP security restriction on an app.
type IpSecurityRestriction_STATUS struct {
	// Action: Allow or Deny access for this IP range.
	Action *string `json:"action,omitempty"`

	// Description: IP restriction rule description.
	Description *string `json:"description,omitempty"`

	// Headers: IP restriction rule headers.
	// X-Forwarded-Host (https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-Host#Examples).
	// The matching logic is ..
	// - If the property is null or empty (default), all hosts(or lack of) are allowed.
	// - A value is compared using ordinal-ignore-case (excluding port number).
	// - Subdomain wildcards are permitted but don't match the root domain. For example, *.contoso.com matches the subdomain
	// foo.contoso.com
	// but not the root domain contoso.com or multi-level foo.bar.contoso.com
	// - Unicode host names are allowed but are converted to Punycode for matching.
	// X-Forwarded-For (https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-For#Examples).
	// The matching logic is ..
	// - If the property is null or empty (default), any forwarded-for chains (or lack of) are allowed.
	// - If any address (excluding port number) in the chain (comma separated) matches the CIDR defined by the property.
	// X-Azure-FDID and X-FD-HealthProbe.
	// The matching logic is exact match.
	Headers map[string][]string `json:"headers,omitempty"`

	// IpAddress: IP address the security restriction is valid for.
	// It can be in form of pure ipv4 address (required SubnetMask property) or
	// CIDR notation such as ipv4/mask (leading bit match). For CIDR,
	// SubnetMask property must not be specified.
	IpAddress *string `json:"ipAddress,omitempty"`

	// Name: IP restriction rule name.
	Name *string `json:"name,omitempty"`

	// Priority: Priority of IP restriction rule.
	Priority *int `json:"priority,omitempty"`

	// SubnetMask: Subnet mask for the range of IP addresses the restriction is valid for.
	SubnetMask *string `json:"subnetMask,omitempty"`

	// SubnetTrafficTag: (internal) Subnet traffic tag
	SubnetTrafficTag *int `json:"subnetTrafficTag,omitempty"`

	// Tag: Defines what this IP filter will be used for. This is to support IP filtering on proxies.
	Tag *IpSecurityRestriction_Tag_STATUS `json:"tag,omitempty"`

	// VnetSubnetResourceId: Virtual network resource id
	VnetSubnetResourceId *string `json:"vnetSubnetResourceId,omitempty"`

	// VnetTrafficTag: (internal) Vnet traffic tag
	VnetTrafficTag *int `json:"vnetTrafficTag,omitempty"`
}

var _ genruntime.FromARMConverter = &IpSecurityRestriction_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (restriction *IpSecurityRestriction_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &IpSecurityRestriction_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (restriction *IpSecurityRestriction_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(IpSecurityRestriction_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected IpSecurityRestriction_STATUS_ARM, got %T", armInput)
	}

	// Set property "Action":
	if typedInput.Action != nil {
		action := *typedInput.Action
		restriction.Action = &action
	}

	// Set property "Description":
	if typedInput.Description != nil {
		description := *typedInput.Description
		restriction.Description = &description
	}

	// Set property "Headers":
	if typedInput.Headers != nil {
		restriction.Headers = make(map[string][]string, len(typedInput.Headers))
		for key, value := range typedInput.Headers {
			var valueTemp []string
			for _, item := range value {
				valueTemp = append(valueTemp, item)
			}
			restriction.Headers[key] = valueTemp
		}
	}

	// Set property "IpAddress":
	if typedInput.IpAddress != nil {
		ipAddress := *typedInput.IpAddress
		restriction.IpAddress = &ipAddress
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		restriction.Name = &name
	}

	// Set property "Priority":
	if typedInput.Priority != nil {
		priority := *typedInput.Priority
		restriction.Priority = &priority
	}

	// Set property "SubnetMask":
	if typedInput.SubnetMask != nil {
		subnetMask := *typedInput.SubnetMask
		restriction.SubnetMask = &subnetMask
	}

	// Set property "SubnetTrafficTag":
	if typedInput.SubnetTrafficTag != nil {
		subnetTrafficTag := *typedInput.SubnetTrafficTag
		restriction.SubnetTrafficTag = &subnetTrafficTag
	}

	// Set property "Tag":
	if typedInput.Tag != nil {
		tag := *typedInput.Tag
		restriction.Tag = &tag
	}

	// Set property "VnetSubnetResourceId":
	if typedInput.VnetSubnetResourceId != nil {
		vnetSubnetResourceId := *typedInput.VnetSubnetResourceId
		restriction.VnetSubnetResourceId = &vnetSubnetResourceId
	}

	// Set property "VnetTrafficTag":
	if typedInput.VnetTrafficTag != nil {
		vnetTrafficTag := *typedInput.VnetTrafficTag
		restriction.VnetTrafficTag = &vnetTrafficTag
	}

	// No error
	return nil
}

// AssignProperties_From_IpSecurityRestriction_STATUS populates our IpSecurityRestriction_STATUS from the provided source IpSecurityRestriction_STATUS
func (restriction *IpSecurityRestriction_STATUS) AssignProperties_From_IpSecurityRestriction_STATUS(source *v20220301s.IpSecurityRestriction_STATUS) error {

	// Action
	restriction.Action = genruntime.ClonePointerToString(source.Action)

	// Description
	restriction.Description = genruntime.ClonePointerToString(source.Description)

	// Headers
	if source.Headers != nil {
		headerMap := make(map[string][]string, len(source.Headers))
		for headerKey, headerValue := range source.Headers {
			// Shadow the loop variable to avoid aliasing
			headerValue := headerValue
			headerMap[headerKey] = genruntime.CloneSliceOfString(headerValue)
		}
		restriction.Headers = headerMap
	} else {
		restriction.Headers = nil
	}

	// IpAddress
	restriction.IpAddress = genruntime.ClonePointerToString(source.IpAddress)

	// Name
	restriction.Name = genruntime.ClonePointerToString(source.Name)

	// Priority
	restriction.Priority = genruntime.ClonePointerToInt(source.Priority)

	// SubnetMask
	restriction.SubnetMask = genruntime.ClonePointerToString(source.SubnetMask)

	// SubnetTrafficTag
	restriction.SubnetTrafficTag = genruntime.ClonePointerToInt(source.SubnetTrafficTag)

	// Tag
	if source.Tag != nil {
		tag := IpSecurityRestriction_Tag_STATUS(*source.Tag)
		restriction.Tag = &tag
	} else {
		restriction.Tag = nil
	}

	// VnetSubnetResourceId
	restriction.VnetSubnetResourceId = genruntime.ClonePointerToString(source.VnetSubnetResourceId)

	// VnetTrafficTag
	restriction.VnetTrafficTag = genruntime.ClonePointerToInt(source.VnetTrafficTag)

	// No error
	return nil
}

// AssignProperties_To_IpSecurityRestriction_STATUS populates the provided destination IpSecurityRestriction_STATUS from our IpSecurityRestriction_STATUS
func (restriction *IpSecurityRestriction_STATUS) AssignProperties_To_IpSecurityRestriction_STATUS(destination *v20220301s.IpSecurityRestriction_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Action
	destination.Action = genruntime.ClonePointerToString(restriction.Action)

	// Description
	destination.Description = genruntime.ClonePointerToString(restriction.Description)

	// Headers
	if restriction.Headers != nil {
		headerMap := make(map[string][]string, len(restriction.Headers))
		for headerKey, headerValue := range restriction.Headers {
			// Shadow the loop variable to avoid aliasing
			headerValue := headerValue
			headerMap[headerKey] = genruntime.CloneSliceOfString(headerValue)
		}
		destination.Headers = headerMap
	} else {
		destination.Headers = nil
	}

	// IpAddress
	destination.IpAddress = genruntime.ClonePointerToString(restriction.IpAddress)

	// Name
	destination.Name = genruntime.ClonePointerToString(restriction.Name)

	// Priority
	destination.Priority = genruntime.ClonePointerToInt(restriction.Priority)

	// SubnetMask
	destination.SubnetMask = genruntime.ClonePointerToString(restriction.SubnetMask)

	// SubnetTrafficTag
	destination.SubnetTrafficTag = genruntime.ClonePointerToInt(restriction.SubnetTrafficTag)

	// Tag
	if restriction.Tag != nil {
		tag := string(*restriction.Tag)
		destination.Tag = &tag
	} else {
		destination.Tag = nil
	}

	// VnetSubnetResourceId
	destination.VnetSubnetResourceId = genruntime.ClonePointerToString(restriction.VnetSubnetResourceId)

	// VnetTrafficTag
	destination.VnetTrafficTag = genruntime.ClonePointerToInt(restriction.VnetTrafficTag)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Name value pair.
type NameValuePair struct {
	// Name: Pair name.
	Name *string `json:"name,omitempty"`

	// Value: Pair value.
	Value *string `json:"value,omitempty"`
}

var _ genruntime.ARMTransformer = &NameValuePair{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (pair *NameValuePair) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if pair == nil {
		return nil, nil
	}
	result := &NameValuePair_ARM{}

	// Set property "Name":
	if pair.Name != nil {
		name := *pair.Name
		result.Name = &name
	}

	// Set property "Value":
	if pair.Value != nil {
		value := *pair.Value
		result.Value = &value
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (pair *NameValuePair) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &NameValuePair_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (pair *NameValuePair) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(NameValuePair_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected NameValuePair_ARM, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		pair.Name = &name
	}

	// Set property "Value":
	if typedInput.Value != nil {
		value := *typedInput.Value
		pair.Value = &value
	}

	// No error
	return nil
}

// AssignProperties_From_NameValuePair populates our NameValuePair from the provided source NameValuePair
func (pair *NameValuePair) AssignProperties_From_NameValuePair(source *v20220301s.NameValuePair) error {

	// Name
	pair.Name = genruntime.ClonePointerToString(source.Name)

	// Value
	pair.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// AssignProperties_To_NameValuePair populates the provided destination NameValuePair from our NameValuePair
func (pair *NameValuePair) AssignProperties_To_NameValuePair(destination *v20220301s.NameValuePair) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(pair.Name)

	// Value
	destination.Value = genruntime.ClonePointerToString(pair.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_NameValuePair_STATUS populates our NameValuePair from the provided source NameValuePair_STATUS
func (pair *NameValuePair) Initialize_From_NameValuePair_STATUS(source *NameValuePair_STATUS) error {

	// Name
	pair.Name = genruntime.ClonePointerToString(source.Name)

	// Value
	pair.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// Name value pair.
type NameValuePair_STATUS struct {
	// Name: Pair name.
	Name *string `json:"name,omitempty"`

	// Value: Pair value.
	Value *string `json:"value,omitempty"`
}

var _ genruntime.FromARMConverter = &NameValuePair_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (pair *NameValuePair_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &NameValuePair_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (pair *NameValuePair_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(NameValuePair_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected NameValuePair_STATUS_ARM, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		pair.Name = &name
	}

	// Set property "Value":
	if typedInput.Value != nil {
		value := *typedInput.Value
		pair.Value = &value
	}

	// No error
	return nil
}

// AssignProperties_From_NameValuePair_STATUS populates our NameValuePair_STATUS from the provided source NameValuePair_STATUS
func (pair *NameValuePair_STATUS) AssignProperties_From_NameValuePair_STATUS(source *v20220301s.NameValuePair_STATUS) error {

	// Name
	pair.Name = genruntime.ClonePointerToString(source.Name)

	// Value
	pair.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// AssignProperties_To_NameValuePair_STATUS populates the provided destination NameValuePair_STATUS from our NameValuePair_STATUS
func (pair *NameValuePair_STATUS) AssignProperties_To_NameValuePair_STATUS(destination *v20220301s.NameValuePair_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(pair.Name)

	// Value
	destination.Value = genruntime.ClonePointerToString(pair.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Push settings for the App.
type PushSettings struct {
	// DynamicTagsJson: Gets or sets a JSON string containing a list of dynamic tags that will be evaluated from user claims in
	// the push registration endpoint.
	DynamicTagsJson *string `json:"dynamicTagsJson,omitempty"`

	// +kubebuilder:validation:Required
	// IsPushEnabled: Gets or sets a flag indicating whether the Push endpoint is enabled.
	IsPushEnabled *bool `json:"isPushEnabled,omitempty"`

	// Kind: Kind of resource.
	Kind *string `json:"kind,omitempty"`

	// TagWhitelistJson: Gets or sets a JSON string containing a list of tags that are in the allowed list for use by the push
	// registration endpoint.
	TagWhitelistJson *string `json:"tagWhitelistJson,omitempty"`

	// TagsRequiringAuth: Gets or sets a JSON string containing a list of tags that require user authentication to be used in
	// the push registration endpoint.
	// Tags can consist of alphanumeric characters and the following:
	// '_', '@', '#', '.', ':', '-'.
	// Validation should be performed at the PushRequestHandler.
	TagsRequiringAuth *string `json:"tagsRequiringAuth,omitempty"`
}

var _ genruntime.ARMTransformer = &PushSettings{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (settings *PushSettings) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if settings == nil {
		return nil, nil
	}
	result := &PushSettings_ARM{}

	// Set property "Kind":
	if settings.Kind != nil {
		kind := *settings.Kind
		result.Kind = &kind
	}

	// Set property "Properties":
	if settings.DynamicTagsJson != nil ||
		settings.IsPushEnabled != nil ||
		settings.TagWhitelistJson != nil ||
		settings.TagsRequiringAuth != nil {
		result.Properties = &PushSettings_Properties_ARM{}
	}
	if settings.DynamicTagsJson != nil {
		dynamicTagsJson := *settings.DynamicTagsJson
		result.Properties.DynamicTagsJson = &dynamicTagsJson
	}
	if settings.IsPushEnabled != nil {
		isPushEnabled := *settings.IsPushEnabled
		result.Properties.IsPushEnabled = &isPushEnabled
	}
	if settings.TagWhitelistJson != nil {
		tagWhitelistJson := *settings.TagWhitelistJson
		result.Properties.TagWhitelistJson = &tagWhitelistJson
	}
	if settings.TagsRequiringAuth != nil {
		tagsRequiringAuth := *settings.TagsRequiringAuth
		result.Properties.TagsRequiringAuth = &tagsRequiringAuth
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *PushSettings) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &PushSettings_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *PushSettings) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(PushSettings_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected PushSettings_ARM, got %T", armInput)
	}

	// Set property "DynamicTagsJson":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DynamicTagsJson != nil {
			dynamicTagsJson := *typedInput.Properties.DynamicTagsJson
			settings.DynamicTagsJson = &dynamicTagsJson
		}
	}

	// Set property "IsPushEnabled":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IsPushEnabled != nil {
			isPushEnabled := *typedInput.Properties.IsPushEnabled
			settings.IsPushEnabled = &isPushEnabled
		}
	}

	// Set property "Kind":
	if typedInput.Kind != nil {
		kind := *typedInput.Kind
		settings.Kind = &kind
	}

	// Set property "TagWhitelistJson":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.TagWhitelistJson != nil {
			tagWhitelistJson := *typedInput.Properties.TagWhitelistJson
			settings.TagWhitelistJson = &tagWhitelistJson
		}
	}

	// Set property "TagsRequiringAuth":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.TagsRequiringAuth != nil {
			tagsRequiringAuth := *typedInput.Properties.TagsRequiringAuth
			settings.TagsRequiringAuth = &tagsRequiringAuth
		}
	}

	// No error
	return nil
}

// AssignProperties_From_PushSettings populates our PushSettings from the provided source PushSettings
func (settings *PushSettings) AssignProperties_From_PushSettings(source *v20220301s.PushSettings) error {

	// DynamicTagsJson
	settings.DynamicTagsJson = genruntime.ClonePointerToString(source.DynamicTagsJson)

	// IsPushEnabled
	if source.IsPushEnabled != nil {
		isPushEnabled := *source.IsPushEnabled
		settings.IsPushEnabled = &isPushEnabled
	} else {
		settings.IsPushEnabled = nil
	}

	// Kind
	settings.Kind = genruntime.ClonePointerToString(source.Kind)

	// TagWhitelistJson
	settings.TagWhitelistJson = genruntime.ClonePointerToString(source.TagWhitelistJson)

	// TagsRequiringAuth
	settings.TagsRequiringAuth = genruntime.ClonePointerToString(source.TagsRequiringAuth)

	// No error
	return nil
}

// AssignProperties_To_PushSettings populates the provided destination PushSettings from our PushSettings
func (settings *PushSettings) AssignProperties_To_PushSettings(destination *v20220301s.PushSettings) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DynamicTagsJson
	destination.DynamicTagsJson = genruntime.ClonePointerToString(settings.DynamicTagsJson)

	// IsPushEnabled
	if settings.IsPushEnabled != nil {
		isPushEnabled := *settings.IsPushEnabled
		destination.IsPushEnabled = &isPushEnabled
	} else {
		destination.IsPushEnabled = nil
	}

	// Kind
	destination.Kind = genruntime.ClonePointerToString(settings.Kind)

	// TagWhitelistJson
	destination.TagWhitelistJson = genruntime.ClonePointerToString(settings.TagWhitelistJson)

	// TagsRequiringAuth
	destination.TagsRequiringAuth = genruntime.ClonePointerToString(settings.TagsRequiringAuth)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_PushSettings_STATUS populates our PushSettings from the provided source PushSettings_STATUS
func (settings *PushSettings) Initialize_From_PushSettings_STATUS(source *PushSettings_STATUS) error {

	// DynamicTagsJson
	settings.DynamicTagsJson = genruntime.ClonePointerToString(source.DynamicTagsJson)

	// IsPushEnabled
	if source.IsPushEnabled != nil {
		isPushEnabled := *source.IsPushEnabled
		settings.IsPushEnabled = &isPushEnabled
	} else {
		settings.IsPushEnabled = nil
	}

	// Kind
	settings.Kind = genruntime.ClonePointerToString(source.Kind)

	// TagWhitelistJson
	settings.TagWhitelistJson = genruntime.ClonePointerToString(source.TagWhitelistJson)

	// TagsRequiringAuth
	settings.TagsRequiringAuth = genruntime.ClonePointerToString(source.TagsRequiringAuth)

	// No error
	return nil
}

// Push settings for the App.
type PushSettings_STATUS struct {
	// DynamicTagsJson: Gets or sets a JSON string containing a list of dynamic tags that will be evaluated from user claims in
	// the push registration endpoint.
	DynamicTagsJson *string `json:"dynamicTagsJson,omitempty"`

	// Id: Resource Id.
	Id *string `json:"id,omitempty"`

	// IsPushEnabled: Gets or sets a flag indicating whether the Push endpoint is enabled.
	IsPushEnabled *bool `json:"isPushEnabled,omitempty"`

	// Kind: Kind of resource.
	Kind *string `json:"kind,omitempty"`

	// Name: Resource Name.
	Name *string `json:"name,omitempty"`

	// TagWhitelistJson: Gets or sets a JSON string containing a list of tags that are in the allowed list for use by the push
	// registration endpoint.
	TagWhitelistJson *string `json:"tagWhitelistJson,omitempty"`

	// TagsRequiringAuth: Gets or sets a JSON string containing a list of tags that require user authentication to be used in
	// the push registration endpoint.
	// Tags can consist of alphanumeric characters and the following:
	// '_', '@', '#', '.', ':', '-'.
	// Validation should be performed at the PushRequestHandler.
	TagsRequiringAuth *string `json:"tagsRequiringAuth,omitempty"`

	// Type: Resource type.
	Type *string `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &PushSettings_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *PushSettings_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &PushSettings_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *PushSettings_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(PushSettings_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected PushSettings_STATUS_ARM, got %T", armInput)
	}

	// Set property "DynamicTagsJson":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DynamicTagsJson != nil {
			dynamicTagsJson := *typedInput.Properties.DynamicTagsJson
			settings.DynamicTagsJson = &dynamicTagsJson
		}
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		settings.Id = &id
	}

	// Set property "IsPushEnabled":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IsPushEnabled != nil {
			isPushEnabled := *typedInput.Properties.IsPushEnabled
			settings.IsPushEnabled = &isPushEnabled
		}
	}

	// Set property "Kind":
	if typedInput.Kind != nil {
		kind := *typedInput.Kind
		settings.Kind = &kind
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		settings.Name = &name
	}

	// Set property "TagWhitelistJson":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.TagWhitelistJson != nil {
			tagWhitelistJson := *typedInput.Properties.TagWhitelistJson
			settings.TagWhitelistJson = &tagWhitelistJson
		}
	}

	// Set property "TagsRequiringAuth":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.TagsRequiringAuth != nil {
			tagsRequiringAuth := *typedInput.Properties.TagsRequiringAuth
			settings.TagsRequiringAuth = &tagsRequiringAuth
		}
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		settings.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_PushSettings_STATUS populates our PushSettings_STATUS from the provided source PushSettings_STATUS
func (settings *PushSettings_STATUS) AssignProperties_From_PushSettings_STATUS(source *v20220301s.PushSettings_STATUS) error {

	// DynamicTagsJson
	settings.DynamicTagsJson = genruntime.ClonePointerToString(source.DynamicTagsJson)

	// Id
	settings.Id = genruntime.ClonePointerToString(source.Id)

	// IsPushEnabled
	if source.IsPushEnabled != nil {
		isPushEnabled := *source.IsPushEnabled
		settings.IsPushEnabled = &isPushEnabled
	} else {
		settings.IsPushEnabled = nil
	}

	// Kind
	settings.Kind = genruntime.ClonePointerToString(source.Kind)

	// Name
	settings.Name = genruntime.ClonePointerToString(source.Name)

	// TagWhitelistJson
	settings.TagWhitelistJson = genruntime.ClonePointerToString(source.TagWhitelistJson)

	// TagsRequiringAuth
	settings.TagsRequiringAuth = genruntime.ClonePointerToString(source.TagsRequiringAuth)

	// Type
	settings.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignProperties_To_PushSettings_STATUS populates the provided destination PushSettings_STATUS from our PushSettings_STATUS
func (settings *PushSettings_STATUS) AssignProperties_To_PushSettings_STATUS(destination *v20220301s.PushSettings_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DynamicTagsJson
	destination.DynamicTagsJson = genruntime.ClonePointerToString(settings.DynamicTagsJson)

	// Id
	destination.Id = genruntime.ClonePointerToString(settings.Id)

	// IsPushEnabled
	if settings.IsPushEnabled != nil {
		isPushEnabled := *settings.IsPushEnabled
		destination.IsPushEnabled = &isPushEnabled
	} else {
		destination.IsPushEnabled = nil
	}

	// Kind
	destination.Kind = genruntime.ClonePointerToString(settings.Kind)

	// Name
	destination.Name = genruntime.ClonePointerToString(settings.Name)

	// TagWhitelistJson
	destination.TagWhitelistJson = genruntime.ClonePointerToString(settings.TagWhitelistJson)

	// TagsRequiringAuth
	destination.TagsRequiringAuth = genruntime.ClonePointerToString(settings.TagsRequiringAuth)

	// Type
	destination.Type = genruntime.ClonePointerToString(settings.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"AllAllowed","Disabled","FtpsOnly"}
type SiteConfig_FtpsState string

const (
	SiteConfig_FtpsState_AllAllowed = SiteConfig_FtpsState("AllAllowed")
	SiteConfig_FtpsState_Disabled   = SiteConfig_FtpsState("Disabled")
	SiteConfig_FtpsState_FtpsOnly   = SiteConfig_FtpsState("FtpsOnly")
)

type SiteConfig_FtpsState_STATUS string

const (
	SiteConfig_FtpsState_STATUS_AllAllowed = SiteConfig_FtpsState_STATUS("AllAllowed")
	SiteConfig_FtpsState_STATUS_Disabled   = SiteConfig_FtpsState_STATUS("Disabled")
	SiteConfig_FtpsState_STATUS_FtpsOnly   = SiteConfig_FtpsState_STATUS("FtpsOnly")
)

// +kubebuilder:validation:Enum={"LeastRequests","LeastResponseTime","PerSiteRoundRobin","RequestHash","WeightedRoundRobin","WeightedTotalTraffic"}
type SiteConfig_LoadBalancing string

const (
	SiteConfig_LoadBalancing_LeastRequests        = SiteConfig_LoadBalancing("LeastRequests")
	SiteConfig_LoadBalancing_LeastResponseTime    = SiteConfig_LoadBalancing("LeastResponseTime")
	SiteConfig_LoadBalancing_PerSiteRoundRobin    = SiteConfig_LoadBalancing("PerSiteRoundRobin")
	SiteConfig_LoadBalancing_RequestHash          = SiteConfig_LoadBalancing("RequestHash")
	SiteConfig_LoadBalancing_WeightedRoundRobin   = SiteConfig_LoadBalancing("WeightedRoundRobin")
	SiteConfig_LoadBalancing_WeightedTotalTraffic = SiteConfig_LoadBalancing("WeightedTotalTraffic")
)

type SiteConfig_LoadBalancing_STATUS string

const (
	SiteConfig_LoadBalancing_STATUS_LeastRequests        = SiteConfig_LoadBalancing_STATUS("LeastRequests")
	SiteConfig_LoadBalancing_STATUS_LeastResponseTime    = SiteConfig_LoadBalancing_STATUS("LeastResponseTime")
	SiteConfig_LoadBalancing_STATUS_PerSiteRoundRobin    = SiteConfig_LoadBalancing_STATUS("PerSiteRoundRobin")
	SiteConfig_LoadBalancing_STATUS_RequestHash          = SiteConfig_LoadBalancing_STATUS("RequestHash")
	SiteConfig_LoadBalancing_STATUS_WeightedRoundRobin   = SiteConfig_LoadBalancing_STATUS("WeightedRoundRobin")
	SiteConfig_LoadBalancing_STATUS_WeightedTotalTraffic = SiteConfig_LoadBalancing_STATUS("WeightedTotalTraffic")
)

// +kubebuilder:validation:Enum={"Classic","Integrated"}
type SiteConfig_ManagedPipelineMode string

const (
	SiteConfig_ManagedPipelineMode_Classic    = SiteConfig_ManagedPipelineMode("Classic")
	SiteConfig_ManagedPipelineMode_Integrated = SiteConfig_ManagedPipelineMode("Integrated")
)

type SiteConfig_ManagedPipelineMode_STATUS string

const (
	SiteConfig_ManagedPipelineMode_STATUS_Classic    = SiteConfig_ManagedPipelineMode_STATUS("Classic")
	SiteConfig_ManagedPipelineMode_STATUS_Integrated = SiteConfig_ManagedPipelineMode_STATUS("Integrated")
)

// +kubebuilder:validation:Enum={"1.0","1.1","1.2"}
type SiteConfig_MinTlsVersion string

const (
	SiteConfig_MinTlsVersion_10 = SiteConfig_MinTlsVersion("1.0")
	SiteConfig_MinTlsVersion_11 = SiteConfig_MinTlsVersion("1.1")
	SiteConfig_MinTlsVersion_12 = SiteConfig_MinTlsVersion("1.2")
)

type SiteConfig_MinTlsVersion_STATUS string

const (
	SiteConfig_MinTlsVersion_STATUS_10 = SiteConfig_MinTlsVersion_STATUS("1.0")
	SiteConfig_MinTlsVersion_STATUS_11 = SiteConfig_MinTlsVersion_STATUS("1.1")
	SiteConfig_MinTlsVersion_STATUS_12 = SiteConfig_MinTlsVersion_STATUS("1.2")
)

// +kubebuilder:validation:Enum={"1.0","1.1","1.2"}
type SiteConfig_ScmMinTlsVersion string

const (
	SiteConfig_ScmMinTlsVersion_10 = SiteConfig_ScmMinTlsVersion("1.0")
	SiteConfig_ScmMinTlsVersion_11 = SiteConfig_ScmMinTlsVersion("1.1")
	SiteConfig_ScmMinTlsVersion_12 = SiteConfig_ScmMinTlsVersion("1.2")
)

type SiteConfig_ScmMinTlsVersion_STATUS string

const (
	SiteConfig_ScmMinTlsVersion_STATUS_10 = SiteConfig_ScmMinTlsVersion_STATUS("1.0")
	SiteConfig_ScmMinTlsVersion_STATUS_11 = SiteConfig_ScmMinTlsVersion_STATUS("1.1")
	SiteConfig_ScmMinTlsVersion_STATUS_12 = SiteConfig_ScmMinTlsVersion_STATUS("1.2")
)

// +kubebuilder:validation:Enum={"BitbucketGit","BitbucketHg","CodePlexGit","CodePlexHg","Dropbox","ExternalGit","ExternalHg","GitHub","LocalGit","None","OneDrive","Tfs","VSO","VSTSRM"}
type SiteConfig_ScmType string

const (
	SiteConfig_ScmType_BitbucketGit = SiteConfig_ScmType("BitbucketGit")
	SiteConfig_ScmType_BitbucketHg  = SiteConfig_ScmType("BitbucketHg")
	SiteConfig_ScmType_CodePlexGit  = SiteConfig_ScmType("CodePlexGit")
	SiteConfig_ScmType_CodePlexHg   = SiteConfig_ScmType("CodePlexHg")
	SiteConfig_ScmType_Dropbox      = SiteConfig_ScmType("Dropbox")
	SiteConfig_ScmType_ExternalGit  = SiteConfig_ScmType("ExternalGit")
	SiteConfig_ScmType_ExternalHg   = SiteConfig_ScmType("ExternalHg")
	SiteConfig_ScmType_GitHub       = SiteConfig_ScmType("GitHub")
	SiteConfig_ScmType_LocalGit     = SiteConfig_ScmType("LocalGit")
	SiteConfig_ScmType_None         = SiteConfig_ScmType("None")
	SiteConfig_ScmType_OneDrive     = SiteConfig_ScmType("OneDrive")
	SiteConfig_ScmType_Tfs          = SiteConfig_ScmType("Tfs")
	SiteConfig_ScmType_VSO          = SiteConfig_ScmType("VSO")
	SiteConfig_ScmType_VSTSRM       = SiteConfig_ScmType("VSTSRM")
)

type SiteConfig_ScmType_STATUS string

const (
	SiteConfig_ScmType_STATUS_BitbucketGit = SiteConfig_ScmType_STATUS("BitbucketGit")
	SiteConfig_ScmType_STATUS_BitbucketHg  = SiteConfig_ScmType_STATUS("BitbucketHg")
	SiteConfig_ScmType_STATUS_CodePlexGit  = SiteConfig_ScmType_STATUS("CodePlexGit")
	SiteConfig_ScmType_STATUS_CodePlexHg   = SiteConfig_ScmType_STATUS("CodePlexHg")
	SiteConfig_ScmType_STATUS_Dropbox      = SiteConfig_ScmType_STATUS("Dropbox")
	SiteConfig_ScmType_STATUS_ExternalGit  = SiteConfig_ScmType_STATUS("ExternalGit")
	SiteConfig_ScmType_STATUS_ExternalHg   = SiteConfig_ScmType_STATUS("ExternalHg")
	SiteConfig_ScmType_STATUS_GitHub       = SiteConfig_ScmType_STATUS("GitHub")
	SiteConfig_ScmType_STATUS_LocalGit     = SiteConfig_ScmType_STATUS("LocalGit")
	SiteConfig_ScmType_STATUS_None         = SiteConfig_ScmType_STATUS("None")
	SiteConfig_ScmType_STATUS_OneDrive     = SiteConfig_ScmType_STATUS("OneDrive")
	SiteConfig_ScmType_STATUS_Tfs          = SiteConfig_ScmType_STATUS("Tfs")
	SiteConfig_ScmType_STATUS_VSO          = SiteConfig_ScmType_STATUS("VSO")
	SiteConfig_ScmType_STATUS_VSTSRM       = SiteConfig_ScmType_STATUS("VSTSRM")
)

// Metric limits set on an app.
type SiteLimits struct {
	// MaxDiskSizeInMb: Maximum allowed disk size usage in MB.
	MaxDiskSizeInMb *int `json:"maxDiskSizeInMb,omitempty"`

	// MaxMemoryInMb: Maximum allowed memory usage in MB.
	MaxMemoryInMb *int `json:"maxMemoryInMb,omitempty"`

	// MaxPercentageCpu: Maximum allowed CPU usage percentage.
	MaxPercentageCpu *float64 `json:"maxPercentageCpu,omitempty"`
}

var _ genruntime.ARMTransformer = &SiteLimits{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (limits *SiteLimits) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if limits == nil {
		return nil, nil
	}
	result := &SiteLimits_ARM{}

	// Set property "MaxDiskSizeInMb":
	if limits.MaxDiskSizeInMb != nil {
		maxDiskSizeInMb := *limits.MaxDiskSizeInMb
		result.MaxDiskSizeInMb = &maxDiskSizeInMb
	}

	// Set property "MaxMemoryInMb":
	if limits.MaxMemoryInMb != nil {
		maxMemoryInMb := *limits.MaxMemoryInMb
		result.MaxMemoryInMb = &maxMemoryInMb
	}

	// Set property "MaxPercentageCpu":
	if limits.MaxPercentageCpu != nil {
		maxPercentageCpu := *limits.MaxPercentageCpu
		result.MaxPercentageCpu = &maxPercentageCpu
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (limits *SiteLimits) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &SiteLimits_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (limits *SiteLimits) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(SiteLimits_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected SiteLimits_ARM, got %T", armInput)
	}

	// Set property "MaxDiskSizeInMb":
	if typedInput.MaxDiskSizeInMb != nil {
		maxDiskSizeInMb := *typedInput.MaxDiskSizeInMb
		limits.MaxDiskSizeInMb = &maxDiskSizeInMb
	}

	// Set property "MaxMemoryInMb":
	if typedInput.MaxMemoryInMb != nil {
		maxMemoryInMb := *typedInput.MaxMemoryInMb
		limits.MaxMemoryInMb = &maxMemoryInMb
	}

	// Set property "MaxPercentageCpu":
	if typedInput.MaxPercentageCpu != nil {
		maxPercentageCpu := *typedInput.MaxPercentageCpu
		limits.MaxPercentageCpu = &maxPercentageCpu
	}

	// No error
	return nil
}

// AssignProperties_From_SiteLimits populates our SiteLimits from the provided source SiteLimits
func (limits *SiteLimits) AssignProperties_From_SiteLimits(source *v20220301s.SiteLimits) error {

	// MaxDiskSizeInMb
	limits.MaxDiskSizeInMb = genruntime.ClonePointerToInt(source.MaxDiskSizeInMb)

	// MaxMemoryInMb
	limits.MaxMemoryInMb = genruntime.ClonePointerToInt(source.MaxMemoryInMb)

	// MaxPercentageCpu
	if source.MaxPercentageCpu != nil {
		maxPercentageCpu := *source.MaxPercentageCpu
		limits.MaxPercentageCpu = &maxPercentageCpu
	} else {
		limits.MaxPercentageCpu = nil
	}

	// No error
	return nil
}

// AssignProperties_To_SiteLimits populates the provided destination SiteLimits from our SiteLimits
func (limits *SiteLimits) AssignProperties_To_SiteLimits(destination *v20220301s.SiteLimits) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MaxDiskSizeInMb
	destination.MaxDiskSizeInMb = genruntime.ClonePointerToInt(limits.MaxDiskSizeInMb)

	// MaxMemoryInMb
	destination.MaxMemoryInMb = genruntime.ClonePointerToInt(limits.MaxMemoryInMb)

	// MaxPercentageCpu
	if limits.MaxPercentageCpu != nil {
		maxPercentageCpu := *limits.MaxPercentageCpu
		destination.MaxPercentageCpu = &maxPercentageCpu
	} else {
		destination.MaxPercentageCpu = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_SiteLimits_STATUS populates our SiteLimits from the provided source SiteLimits_STATUS
func (limits *SiteLimits) Initialize_From_SiteLimits_STATUS(source *SiteLimits_STATUS) error {

	// MaxDiskSizeInMb
	limits.MaxDiskSizeInMb = genruntime.ClonePointerToInt(source.MaxDiskSizeInMb)

	// MaxMemoryInMb
	limits.MaxMemoryInMb = genruntime.ClonePointerToInt(source.MaxMemoryInMb)

	// MaxPercentageCpu
	if source.MaxPercentageCpu != nil {
		maxPercentageCpu := *source.MaxPercentageCpu
		limits.MaxPercentageCpu = &maxPercentageCpu
	} else {
		limits.MaxPercentageCpu = nil
	}

	// No error
	return nil
}

// Metric limits set on an app.
type SiteLimits_STATUS struct {
	// MaxDiskSizeInMb: Maximum allowed disk size usage in MB.
	MaxDiskSizeInMb *int `json:"maxDiskSizeInMb,omitempty"`

	// MaxMemoryInMb: Maximum allowed memory usage in MB.
	MaxMemoryInMb *int `json:"maxMemoryInMb,omitempty"`

	// MaxPercentageCpu: Maximum allowed CPU usage percentage.
	MaxPercentageCpu *float64 `json:"maxPercentageCpu,omitempty"`
}

var _ genruntime.FromARMConverter = &SiteLimits_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (limits *SiteLimits_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &SiteLimits_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (limits *SiteLimits_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(SiteLimits_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected SiteLimits_STATUS_ARM, got %T", armInput)
	}

	// Set property "MaxDiskSizeInMb":
	if typedInput.MaxDiskSizeInMb != nil {
		maxDiskSizeInMb := *typedInput.MaxDiskSizeInMb
		limits.MaxDiskSizeInMb = &maxDiskSizeInMb
	}

	// Set property "MaxMemoryInMb":
	if typedInput.MaxMemoryInMb != nil {
		maxMemoryInMb := *typedInput.MaxMemoryInMb
		limits.MaxMemoryInMb = &maxMemoryInMb
	}

	// Set property "MaxPercentageCpu":
	if typedInput.MaxPercentageCpu != nil {
		maxPercentageCpu := *typedInput.MaxPercentageCpu
		limits.MaxPercentageCpu = &maxPercentageCpu
	}

	// No error
	return nil
}

// AssignProperties_From_SiteLimits_STATUS populates our SiteLimits_STATUS from the provided source SiteLimits_STATUS
func (limits *SiteLimits_STATUS) AssignProperties_From_SiteLimits_STATUS(source *v20220301s.SiteLimits_STATUS) error {

	// MaxDiskSizeInMb
	limits.MaxDiskSizeInMb = genruntime.ClonePointerToInt(source.MaxDiskSizeInMb)

	// MaxMemoryInMb
	limits.MaxMemoryInMb = genruntime.ClonePointerToInt(source.MaxMemoryInMb)

	// MaxPercentageCpu
	if source.MaxPercentageCpu != nil {
		maxPercentageCpu := *source.MaxPercentageCpu
		limits.MaxPercentageCpu = &maxPercentageCpu
	} else {
		limits.MaxPercentageCpu = nil
	}

	// No error
	return nil
}

// AssignProperties_To_SiteLimits_STATUS populates the provided destination SiteLimits_STATUS from our SiteLimits_STATUS
func (limits *SiteLimits_STATUS) AssignProperties_To_SiteLimits_STATUS(destination *v20220301s.SiteLimits_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MaxDiskSizeInMb
	destination.MaxDiskSizeInMb = genruntime.ClonePointerToInt(limits.MaxDiskSizeInMb)

	// MaxMemoryInMb
	destination.MaxMemoryInMb = genruntime.ClonePointerToInt(limits.MaxMemoryInMb)

	// MaxPercentageCpu
	if limits.MaxPercentageCpu != nil {
		maxPercentageCpu := *limits.MaxPercentageCpu
		destination.MaxPercentageCpu = &maxPercentageCpu
	} else {
		destination.MaxPercentageCpu = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// MachineKey of an app.
type SiteMachineKey_STATUS struct {
	// Decryption: Algorithm used for decryption.
	Decryption *string `json:"decryption,omitempty"`

	// DecryptionKey: Decryption key.
	DecryptionKey *string `json:"decryptionKey,omitempty"`

	// Validation: MachineKey validation.
	Validation *string `json:"validation,omitempty"`

	// ValidationKey: Validation key.
	ValidationKey *string `json:"validationKey,omitempty"`
}

var _ genruntime.FromARMConverter = &SiteMachineKey_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (machineKey *SiteMachineKey_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &SiteMachineKey_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (machineKey *SiteMachineKey_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(SiteMachineKey_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected SiteMachineKey_STATUS_ARM, got %T", armInput)
	}

	// Set property "Decryption":
	if typedInput.Decryption != nil {
		decryption := *typedInput.Decryption
		machineKey.Decryption = &decryption
	}

	// Set property "DecryptionKey":
	if typedInput.DecryptionKey != nil {
		decryptionKey := *typedInput.DecryptionKey
		machineKey.DecryptionKey = &decryptionKey
	}

	// Set property "Validation":
	if typedInput.Validation != nil {
		validation := *typedInput.Validation
		machineKey.Validation = &validation
	}

	// Set property "ValidationKey":
	if typedInput.ValidationKey != nil {
		validationKey := *typedInput.ValidationKey
		machineKey.ValidationKey = &validationKey
	}

	// No error
	return nil
}

// AssignProperties_From_SiteMachineKey_STATUS populates our SiteMachineKey_STATUS from the provided source SiteMachineKey_STATUS
func (machineKey *SiteMachineKey_STATUS) AssignProperties_From_SiteMachineKey_STATUS(source *v20220301s.SiteMachineKey_STATUS) error {

	// Decryption
	machineKey.Decryption = genruntime.ClonePointerToString(source.Decryption)

	// DecryptionKey
	machineKey.DecryptionKey = genruntime.ClonePointerToString(source.DecryptionKey)

	// Validation
	machineKey.Validation = genruntime.ClonePointerToString(source.Validation)

	// ValidationKey
	machineKey.ValidationKey = genruntime.ClonePointerToString(source.ValidationKey)

	// No error
	return nil
}

// AssignProperties_To_SiteMachineKey_STATUS populates the provided destination SiteMachineKey_STATUS from our SiteMachineKey_STATUS
func (machineKey *SiteMachineKey_STATUS) AssignProperties_To_SiteMachineKey_STATUS(destination *v20220301s.SiteMachineKey_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Decryption
	destination.Decryption = genruntime.ClonePointerToString(machineKey.Decryption)

	// DecryptionKey
	destination.DecryptionKey = genruntime.ClonePointerToString(machineKey.DecryptionKey)

	// Validation
	destination.Validation = genruntime.ClonePointerToString(machineKey.Validation)

	// ValidationKey
	destination.ValidationKey = genruntime.ClonePointerToString(machineKey.ValidationKey)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// User Assigned identity.
type UserAssignedIdentity_STATUS struct {
	// ClientId: Client Id of user assigned identity
	ClientId *string `json:"clientId,omitempty"`

	// PrincipalId: Principal Id of user assigned identity
	PrincipalId *string `json:"principalId,omitempty"`
}

var _ genruntime.FromARMConverter = &UserAssignedIdentity_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *UserAssignedIdentity_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &UserAssignedIdentity_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *UserAssignedIdentity_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(UserAssignedIdentity_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected UserAssignedIdentity_STATUS_ARM, got %T", armInput)
	}

	// Set property "ClientId":
	if typedInput.ClientId != nil {
		clientId := *typedInput.ClientId
		identity.ClientId = &clientId
	}

	// Set property "PrincipalId":
	if typedInput.PrincipalId != nil {
		principalId := *typedInput.PrincipalId
		identity.PrincipalId = &principalId
	}

	// No error
	return nil
}

// AssignProperties_From_UserAssignedIdentity_STATUS populates our UserAssignedIdentity_STATUS from the provided source UserAssignedIdentity_STATUS
func (identity *UserAssignedIdentity_STATUS) AssignProperties_From_UserAssignedIdentity_STATUS(source *v20220301s.UserAssignedIdentity_STATUS) error {

	// ClientId
	identity.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// PrincipalId
	identity.PrincipalId = genruntime.ClonePointerToString(source.PrincipalId)

	// No error
	return nil
}

// AssignProperties_To_UserAssignedIdentity_STATUS populates the provided destination UserAssignedIdentity_STATUS from our UserAssignedIdentity_STATUS
func (identity *UserAssignedIdentity_STATUS) AssignProperties_To_UserAssignedIdentity_STATUS(destination *v20220301s.UserAssignedIdentity_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(identity.ClientId)

	// PrincipalId
	destination.PrincipalId = genruntime.ClonePointerToString(identity.PrincipalId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Information about the user assigned identity for the resource
type UserAssignedIdentityDetails struct {
	Reference genruntime.ResourceReference `armReference:"Reference" json:"reference,omitempty"`
}

// AssignProperties_From_UserAssignedIdentityDetails populates our UserAssignedIdentityDetails from the provided source UserAssignedIdentityDetails
func (details *UserAssignedIdentityDetails) AssignProperties_From_UserAssignedIdentityDetails(source *v20220301s.UserAssignedIdentityDetails) error {

	// Reference
	details.Reference = source.Reference.Copy()

	// No error
	return nil
}

// AssignProperties_To_UserAssignedIdentityDetails populates the provided destination UserAssignedIdentityDetails from our UserAssignedIdentityDetails
func (details *UserAssignedIdentityDetails) AssignProperties_To_UserAssignedIdentityDetails(destination *v20220301s.UserAssignedIdentityDetails) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Reference
	destination.Reference = details.Reference.Copy()

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Virtual application in an app.
type VirtualApplication struct {
	// PhysicalPath: Physical path.
	PhysicalPath *string `json:"physicalPath,omitempty"`

	// PreloadEnabled: <code>true</code> if preloading is enabled; otherwise, <code>false</code>.
	PreloadEnabled *bool `json:"preloadEnabled,omitempty"`

	// VirtualDirectories: Virtual directories for virtual application.
	VirtualDirectories []VirtualDirectory `json:"virtualDirectories,omitempty"`

	// VirtualPath: Virtual path.
	VirtualPath *string `json:"virtualPath,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualApplication{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (application *VirtualApplication) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if application == nil {
		return nil, nil
	}
	result := &VirtualApplication_ARM{}

	// Set property "PhysicalPath":
	if application.PhysicalPath != nil {
		physicalPath := *application.PhysicalPath
		result.PhysicalPath = &physicalPath
	}

	// Set property "PreloadEnabled":
	if application.PreloadEnabled != nil {
		preloadEnabled := *application.PreloadEnabled
		result.PreloadEnabled = &preloadEnabled
	}

	// Set property "VirtualDirectories":
	for _, item := range application.VirtualDirectories {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.VirtualDirectories = append(result.VirtualDirectories, *item_ARM.(*VirtualDirectory_ARM))
	}

	// Set property "VirtualPath":
	if application.VirtualPath != nil {
		virtualPath := *application.VirtualPath
		result.VirtualPath = &virtualPath
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (application *VirtualApplication) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualApplication_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (application *VirtualApplication) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualApplication_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualApplication_ARM, got %T", armInput)
	}

	// Set property "PhysicalPath":
	if typedInput.PhysicalPath != nil {
		physicalPath := *typedInput.PhysicalPath
		application.PhysicalPath = &physicalPath
	}

	// Set property "PreloadEnabled":
	if typedInput.PreloadEnabled != nil {
		preloadEnabled := *typedInput.PreloadEnabled
		application.PreloadEnabled = &preloadEnabled
	}

	// Set property "VirtualDirectories":
	for _, item := range typedInput.VirtualDirectories {
		var item1 VirtualDirectory
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		application.VirtualDirectories = append(application.VirtualDirectories, item1)
	}

	// Set property "VirtualPath":
	if typedInput.VirtualPath != nil {
		virtualPath := *typedInput.VirtualPath
		application.VirtualPath = &virtualPath
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualApplication populates our VirtualApplication from the provided source VirtualApplication
func (application *VirtualApplication) AssignProperties_From_VirtualApplication(source *v20220301s.VirtualApplication) error {

	// PhysicalPath
	application.PhysicalPath = genruntime.ClonePointerToString(source.PhysicalPath)

	// PreloadEnabled
	if source.PreloadEnabled != nil {
		preloadEnabled := *source.PreloadEnabled
		application.PreloadEnabled = &preloadEnabled
	} else {
		application.PreloadEnabled = nil
	}

	// VirtualDirectories
	if source.VirtualDirectories != nil {
		virtualDirectoryList := make([]VirtualDirectory, len(source.VirtualDirectories))
		for virtualDirectoryIndex, virtualDirectoryItem := range source.VirtualDirectories {
			// Shadow the loop variable to avoid aliasing
			virtualDirectoryItem := virtualDirectoryItem
			var virtualDirectory VirtualDirectory
			err := virtualDirectory.AssignProperties_From_VirtualDirectory(&virtualDirectoryItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_VirtualDirectory() to populate field VirtualDirectories")
			}
			virtualDirectoryList[virtualDirectoryIndex] = virtualDirectory
		}
		application.VirtualDirectories = virtualDirectoryList
	} else {
		application.VirtualDirectories = nil
	}

	// VirtualPath
	application.VirtualPath = genruntime.ClonePointerToString(source.VirtualPath)

	// No error
	return nil
}

// AssignProperties_To_VirtualApplication populates the provided destination VirtualApplication from our VirtualApplication
func (application *VirtualApplication) AssignProperties_To_VirtualApplication(destination *v20220301s.VirtualApplication) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PhysicalPath
	destination.PhysicalPath = genruntime.ClonePointerToString(application.PhysicalPath)

	// PreloadEnabled
	if application.PreloadEnabled != nil {
		preloadEnabled := *application.PreloadEnabled
		destination.PreloadEnabled = &preloadEnabled
	} else {
		destination.PreloadEnabled = nil
	}

	// VirtualDirectories
	if application.VirtualDirectories != nil {
		virtualDirectoryList := make([]v20220301s.VirtualDirectory, len(application.VirtualDirectories))
		for virtualDirectoryIndex, virtualDirectoryItem := range application.VirtualDirectories {
			// Shadow the loop variable to avoid aliasing
			virtualDirectoryItem := virtualDirectoryItem
			var virtualDirectory v20220301s.VirtualDirectory
			err := virtualDirectoryItem.AssignProperties_To_VirtualDirectory(&virtualDirectory)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_VirtualDirectory() to populate field VirtualDirectories")
			}
			virtualDirectoryList[virtualDirectoryIndex] = virtualDirectory
		}
		destination.VirtualDirectories = virtualDirectoryList
	} else {
		destination.VirtualDirectories = nil
	}

	// VirtualPath
	destination.VirtualPath = genruntime.ClonePointerToString(application.VirtualPath)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_VirtualApplication_STATUS populates our VirtualApplication from the provided source VirtualApplication_STATUS
func (application *VirtualApplication) Initialize_From_VirtualApplication_STATUS(source *VirtualApplication_STATUS) error {

	// PhysicalPath
	application.PhysicalPath = genruntime.ClonePointerToString(source.PhysicalPath)

	// PreloadEnabled
	if source.PreloadEnabled != nil {
		preloadEnabled := *source.PreloadEnabled
		application.PreloadEnabled = &preloadEnabled
	} else {
		application.PreloadEnabled = nil
	}

	// VirtualDirectories
	if source.VirtualDirectories != nil {
		virtualDirectoryList := make([]VirtualDirectory, len(source.VirtualDirectories))
		for virtualDirectoryIndex, virtualDirectoryItem := range source.VirtualDirectories {
			// Shadow the loop variable to avoid aliasing
			virtualDirectoryItem := virtualDirectoryItem
			var virtualDirectory VirtualDirectory
			err := virtualDirectory.Initialize_From_VirtualDirectory_STATUS(&virtualDirectoryItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_VirtualDirectory_STATUS() to populate field VirtualDirectories")
			}
			virtualDirectoryList[virtualDirectoryIndex] = virtualDirectory
		}
		application.VirtualDirectories = virtualDirectoryList
	} else {
		application.VirtualDirectories = nil
	}

	// VirtualPath
	application.VirtualPath = genruntime.ClonePointerToString(source.VirtualPath)

	// No error
	return nil
}

// Virtual application in an app.
type VirtualApplication_STATUS struct {
	// PhysicalPath: Physical path.
	PhysicalPath *string `json:"physicalPath,omitempty"`

	// PreloadEnabled: <code>true</code> if preloading is enabled; otherwise, <code>false</code>.
	PreloadEnabled *bool `json:"preloadEnabled,omitempty"`

	// VirtualDirectories: Virtual directories for virtual application.
	VirtualDirectories []VirtualDirectory_STATUS `json:"virtualDirectories,omitempty"`

	// VirtualPath: Virtual path.
	VirtualPath *string `json:"virtualPath,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualApplication_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (application *VirtualApplication_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualApplication_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (application *VirtualApplication_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualApplication_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualApplication_STATUS_ARM, got %T", armInput)
	}

	// Set property "PhysicalPath":
	if typedInput.PhysicalPath != nil {
		physicalPath := *typedInput.PhysicalPath
		application.PhysicalPath = &physicalPath
	}

	// Set property "PreloadEnabled":
	if typedInput.PreloadEnabled != nil {
		preloadEnabled := *typedInput.PreloadEnabled
		application.PreloadEnabled = &preloadEnabled
	}

	// Set property "VirtualDirectories":
	for _, item := range typedInput.VirtualDirectories {
		var item1 VirtualDirectory_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		application.VirtualDirectories = append(application.VirtualDirectories, item1)
	}

	// Set property "VirtualPath":
	if typedInput.VirtualPath != nil {
		virtualPath := *typedInput.VirtualPath
		application.VirtualPath = &virtualPath
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualApplication_STATUS populates our VirtualApplication_STATUS from the provided source VirtualApplication_STATUS
func (application *VirtualApplication_STATUS) AssignProperties_From_VirtualApplication_STATUS(source *v20220301s.VirtualApplication_STATUS) error {

	// PhysicalPath
	application.PhysicalPath = genruntime.ClonePointerToString(source.PhysicalPath)

	// PreloadEnabled
	if source.PreloadEnabled != nil {
		preloadEnabled := *source.PreloadEnabled
		application.PreloadEnabled = &preloadEnabled
	} else {
		application.PreloadEnabled = nil
	}

	// VirtualDirectories
	if source.VirtualDirectories != nil {
		virtualDirectoryList := make([]VirtualDirectory_STATUS, len(source.VirtualDirectories))
		for virtualDirectoryIndex, virtualDirectoryItem := range source.VirtualDirectories {
			// Shadow the loop variable to avoid aliasing
			virtualDirectoryItem := virtualDirectoryItem
			var virtualDirectory VirtualDirectory_STATUS
			err := virtualDirectory.AssignProperties_From_VirtualDirectory_STATUS(&virtualDirectoryItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_VirtualDirectory_STATUS() to populate field VirtualDirectories")
			}
			virtualDirectoryList[virtualDirectoryIndex] = virtualDirectory
		}
		application.VirtualDirectories = virtualDirectoryList
	} else {
		application.VirtualDirectories = nil
	}

	// VirtualPath
	application.VirtualPath = genruntime.ClonePointerToString(source.VirtualPath)

	// No error
	return nil
}

// AssignProperties_To_VirtualApplication_STATUS populates the provided destination VirtualApplication_STATUS from our VirtualApplication_STATUS
func (application *VirtualApplication_STATUS) AssignProperties_To_VirtualApplication_STATUS(destination *v20220301s.VirtualApplication_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PhysicalPath
	destination.PhysicalPath = genruntime.ClonePointerToString(application.PhysicalPath)

	// PreloadEnabled
	if application.PreloadEnabled != nil {
		preloadEnabled := *application.PreloadEnabled
		destination.PreloadEnabled = &preloadEnabled
	} else {
		destination.PreloadEnabled = nil
	}

	// VirtualDirectories
	if application.VirtualDirectories != nil {
		virtualDirectoryList := make([]v20220301s.VirtualDirectory_STATUS, len(application.VirtualDirectories))
		for virtualDirectoryIndex, virtualDirectoryItem := range application.VirtualDirectories {
			// Shadow the loop variable to avoid aliasing
			virtualDirectoryItem := virtualDirectoryItem
			var virtualDirectory v20220301s.VirtualDirectory_STATUS
			err := virtualDirectoryItem.AssignProperties_To_VirtualDirectory_STATUS(&virtualDirectory)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_VirtualDirectory_STATUS() to populate field VirtualDirectories")
			}
			virtualDirectoryList[virtualDirectoryIndex] = virtualDirectory
		}
		destination.VirtualDirectories = virtualDirectoryList
	} else {
		destination.VirtualDirectories = nil
	}

	// VirtualPath
	destination.VirtualPath = genruntime.ClonePointerToString(application.VirtualPath)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Actions which to take by the auto-heal module when a rule is triggered.
type AutoHealActions struct {
	// ActionType: Predefined action to be taken.
	ActionType *AutoHealActions_ActionType `json:"actionType,omitempty"`

	// CustomAction: Custom action to be taken.
	CustomAction *AutoHealCustomAction `json:"customAction,omitempty"`

	// MinProcessExecutionTime: Minimum time the process must execute
	// before taking the action
	MinProcessExecutionTime *string `json:"minProcessExecutionTime,omitempty"`
}

var _ genruntime.ARMTransformer = &AutoHealActions{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (actions *AutoHealActions) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if actions == nil {
		return nil, nil
	}
	result := &AutoHealActions_ARM{}

	// Set property "ActionType":
	if actions.ActionType != nil {
		actionType := *actions.ActionType
		result.ActionType = &actionType
	}

	// Set property "CustomAction":
	if actions.CustomAction != nil {
		customAction_ARM, err := (*actions.CustomAction).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		customAction := *customAction_ARM.(*AutoHealCustomAction_ARM)
		result.CustomAction = &customAction
	}

	// Set property "MinProcessExecutionTime":
	if actions.MinProcessExecutionTime != nil {
		minProcessExecutionTime := *actions.MinProcessExecutionTime
		result.MinProcessExecutionTime = &minProcessExecutionTime
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (actions *AutoHealActions) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &AutoHealActions_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (actions *AutoHealActions) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(AutoHealActions_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected AutoHealActions_ARM, got %T", armInput)
	}

	// Set property "ActionType":
	if typedInput.ActionType != nil {
		actionType := *typedInput.ActionType
		actions.ActionType = &actionType
	}

	// Set property "CustomAction":
	if typedInput.CustomAction != nil {
		var customAction1 AutoHealCustomAction
		err := customAction1.PopulateFromARM(owner, *typedInput.CustomAction)
		if err != nil {
			return err
		}
		customAction := customAction1
		actions.CustomAction = &customAction
	}

	// Set property "MinProcessExecutionTime":
	if typedInput.MinProcessExecutionTime != nil {
		minProcessExecutionTime := *typedInput.MinProcessExecutionTime
		actions.MinProcessExecutionTime = &minProcessExecutionTime
	}

	// No error
	return nil
}

// AssignProperties_From_AutoHealActions populates our AutoHealActions from the provided source AutoHealActions
func (actions *AutoHealActions) AssignProperties_From_AutoHealActions(source *v20220301s.AutoHealActions) error {

	// ActionType
	if source.ActionType != nil {
		actionType := AutoHealActions_ActionType(*source.ActionType)
		actions.ActionType = &actionType
	} else {
		actions.ActionType = nil
	}

	// CustomAction
	if source.CustomAction != nil {
		var customAction AutoHealCustomAction
		err := customAction.AssignProperties_From_AutoHealCustomAction(source.CustomAction)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AutoHealCustomAction() to populate field CustomAction")
		}
		actions.CustomAction = &customAction
	} else {
		actions.CustomAction = nil
	}

	// MinProcessExecutionTime
	actions.MinProcessExecutionTime = genruntime.ClonePointerToString(source.MinProcessExecutionTime)

	// No error
	return nil
}

// AssignProperties_To_AutoHealActions populates the provided destination AutoHealActions from our AutoHealActions
func (actions *AutoHealActions) AssignProperties_To_AutoHealActions(destination *v20220301s.AutoHealActions) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ActionType
	if actions.ActionType != nil {
		actionType := string(*actions.ActionType)
		destination.ActionType = &actionType
	} else {
		destination.ActionType = nil
	}

	// CustomAction
	if actions.CustomAction != nil {
		var customAction v20220301s.AutoHealCustomAction
		err := actions.CustomAction.AssignProperties_To_AutoHealCustomAction(&customAction)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AutoHealCustomAction() to populate field CustomAction")
		}
		destination.CustomAction = &customAction
	} else {
		destination.CustomAction = nil
	}

	// MinProcessExecutionTime
	destination.MinProcessExecutionTime = genruntime.ClonePointerToString(actions.MinProcessExecutionTime)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_AutoHealActions_STATUS populates our AutoHealActions from the provided source AutoHealActions_STATUS
func (actions *AutoHealActions) Initialize_From_AutoHealActions_STATUS(source *AutoHealActions_STATUS) error {

	// ActionType
	if source.ActionType != nil {
		actionType := AutoHealActions_ActionType(*source.ActionType)
		actions.ActionType = &actionType
	} else {
		actions.ActionType = nil
	}

	// CustomAction
	if source.CustomAction != nil {
		var customAction AutoHealCustomAction
		err := customAction.Initialize_From_AutoHealCustomAction_STATUS(source.CustomAction)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_AutoHealCustomAction_STATUS() to populate field CustomAction")
		}
		actions.CustomAction = &customAction
	} else {
		actions.CustomAction = nil
	}

	// MinProcessExecutionTime
	actions.MinProcessExecutionTime = genruntime.ClonePointerToString(source.MinProcessExecutionTime)

	// No error
	return nil
}

// Actions which to take by the auto-heal module when a rule is triggered.
type AutoHealActions_STATUS struct {
	// ActionType: Predefined action to be taken.
	ActionType *AutoHealActions_ActionType_STATUS `json:"actionType,omitempty"`

	// CustomAction: Custom action to be taken.
	CustomAction *AutoHealCustomAction_STATUS `json:"customAction,omitempty"`

	// MinProcessExecutionTime: Minimum time the process must execute
	// before taking the action
	MinProcessExecutionTime *string `json:"minProcessExecutionTime,omitempty"`
}

var _ genruntime.FromARMConverter = &AutoHealActions_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (actions *AutoHealActions_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &AutoHealActions_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (actions *AutoHealActions_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(AutoHealActions_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected AutoHealActions_STATUS_ARM, got %T", armInput)
	}

	// Set property "ActionType":
	if typedInput.ActionType != nil {
		actionType := *typedInput.ActionType
		actions.ActionType = &actionType
	}

	// Set property "CustomAction":
	if typedInput.CustomAction != nil {
		var customAction1 AutoHealCustomAction_STATUS
		err := customAction1.PopulateFromARM(owner, *typedInput.CustomAction)
		if err != nil {
			return err
		}
		customAction := customAction1
		actions.CustomAction = &customAction
	}

	// Set property "MinProcessExecutionTime":
	if typedInput.MinProcessExecutionTime != nil {
		minProcessExecutionTime := *typedInput.MinProcessExecutionTime
		actions.MinProcessExecutionTime = &minProcessExecutionTime
	}

	// No error
	return nil
}

// AssignProperties_From_AutoHealActions_STATUS populates our AutoHealActions_STATUS from the provided source AutoHealActions_STATUS
func (actions *AutoHealActions_STATUS) AssignProperties_From_AutoHealActions_STATUS(source *v20220301s.AutoHealActions_STATUS) error {

	// ActionType
	if source.ActionType != nil {
		actionType := AutoHealActions_ActionType_STATUS(*source.ActionType)
		actions.ActionType = &actionType
	} else {
		actions.ActionType = nil
	}

	// CustomAction
	if source.CustomAction != nil {
		var customAction AutoHealCustomAction_STATUS
		err := customAction.AssignProperties_From_AutoHealCustomAction_STATUS(source.CustomAction)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AutoHealCustomAction_STATUS() to populate field CustomAction")
		}
		actions.CustomAction = &customAction
	} else {
		actions.CustomAction = nil
	}

	// MinProcessExecutionTime
	actions.MinProcessExecutionTime = genruntime.ClonePointerToString(source.MinProcessExecutionTime)

	// No error
	return nil
}

// AssignProperties_To_AutoHealActions_STATUS populates the provided destination AutoHealActions_STATUS from our AutoHealActions_STATUS
func (actions *AutoHealActions_STATUS) AssignProperties_To_AutoHealActions_STATUS(destination *v20220301s.AutoHealActions_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ActionType
	if actions.ActionType != nil {
		actionType := string(*actions.ActionType)
		destination.ActionType = &actionType
	} else {
		destination.ActionType = nil
	}

	// CustomAction
	if actions.CustomAction != nil {
		var customAction v20220301s.AutoHealCustomAction_STATUS
		err := actions.CustomAction.AssignProperties_To_AutoHealCustomAction_STATUS(&customAction)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AutoHealCustomAction_STATUS() to populate field CustomAction")
		}
		destination.CustomAction = &customAction
	} else {
		destination.CustomAction = nil
	}

	// MinProcessExecutionTime
	destination.MinProcessExecutionTime = genruntime.ClonePointerToString(actions.MinProcessExecutionTime)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Triggers for auto-heal.
type AutoHealTriggers struct {
	// PrivateBytesInKB: A rule based on private bytes.
	PrivateBytesInKB *int `json:"privateBytesInKB,omitempty"`

	// Requests: A rule based on total requests.
	Requests *RequestsBasedTrigger `json:"requests,omitempty"`

	// SlowRequests: A rule based on request execution time.
	SlowRequests *SlowRequestsBasedTrigger `json:"slowRequests,omitempty"`

	// SlowRequestsWithPath: A rule based on multiple Slow Requests Rule with path
	SlowRequestsWithPath []SlowRequestsBasedTrigger `json:"slowRequestsWithPath,omitempty"`

	// StatusCodes: A rule based on status codes.
	StatusCodes []StatusCodesBasedTrigger `json:"statusCodes,omitempty"`

	// StatusCodesRange: A rule based on status codes ranges.
	StatusCodesRange []StatusCodesRangeBasedTrigger `json:"statusCodesRange,omitempty"`
}

var _ genruntime.ARMTransformer = &AutoHealTriggers{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (triggers *AutoHealTriggers) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if triggers == nil {
		return nil, nil
	}
	result := &AutoHealTriggers_ARM{}

	// Set property "PrivateBytesInKB":
	if triggers.PrivateBytesInKB != nil {
		privateBytesInKB := *triggers.PrivateBytesInKB
		result.PrivateBytesInKB = &privateBytesInKB
	}

	// Set property "Requests":
	if triggers.Requests != nil {
		requests_ARM, err := (*triggers.Requests).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		requests := *requests_ARM.(*RequestsBasedTrigger_ARM)
		result.Requests = &requests
	}

	// Set property "SlowRequests":
	if triggers.SlowRequests != nil {
		slowRequests_ARM, err := (*triggers.SlowRequests).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		slowRequests := *slowRequests_ARM.(*SlowRequestsBasedTrigger_ARM)
		result.SlowRequests = &slowRequests
	}

	// Set property "SlowRequestsWithPath":
	for _, item := range triggers.SlowRequestsWithPath {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.SlowRequestsWithPath = append(result.SlowRequestsWithPath, *item_ARM.(*SlowRequestsBasedTrigger_ARM))
	}

	// Set property "StatusCodes":
	for _, item := range triggers.StatusCodes {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.StatusCodes = append(result.StatusCodes, *item_ARM.(*StatusCodesBasedTrigger_ARM))
	}

	// Set property "StatusCodesRange":
	for _, item := range triggers.StatusCodesRange {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.StatusCodesRange = append(result.StatusCodesRange, *item_ARM.(*StatusCodesRangeBasedTrigger_ARM))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (triggers *AutoHealTriggers) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &AutoHealTriggers_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (triggers *AutoHealTriggers) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(AutoHealTriggers_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected AutoHealTriggers_ARM, got %T", armInput)
	}

	// Set property "PrivateBytesInKB":
	if typedInput.PrivateBytesInKB != nil {
		privateBytesInKB := *typedInput.PrivateBytesInKB
		triggers.PrivateBytesInKB = &privateBytesInKB
	}

	// Set property "Requests":
	if typedInput.Requests != nil {
		var requests1 RequestsBasedTrigger
		err := requests1.PopulateFromARM(owner, *typedInput.Requests)
		if err != nil {
			return err
		}
		requests := requests1
		triggers.Requests = &requests
	}

	// Set property "SlowRequests":
	if typedInput.SlowRequests != nil {
		var slowRequests1 SlowRequestsBasedTrigger
		err := slowRequests1.PopulateFromARM(owner, *typedInput.SlowRequests)
		if err != nil {
			return err
		}
		slowRequests := slowRequests1
		triggers.SlowRequests = &slowRequests
	}

	// Set property "SlowRequestsWithPath":
	for _, item := range typedInput.SlowRequestsWithPath {
		var item1 SlowRequestsBasedTrigger
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		triggers.SlowRequestsWithPath = append(triggers.SlowRequestsWithPath, item1)
	}

	// Set property "StatusCodes":
	for _, item := range typedInput.StatusCodes {
		var item1 StatusCodesBasedTrigger
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		triggers.StatusCodes = append(triggers.StatusCodes, item1)
	}

	// Set property "StatusCodesRange":
	for _, item := range typedInput.StatusCodesRange {
		var item1 StatusCodesRangeBasedTrigger
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		triggers.StatusCodesRange = append(triggers.StatusCodesRange, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_AutoHealTriggers populates our AutoHealTriggers from the provided source AutoHealTriggers
func (triggers *AutoHealTriggers) AssignProperties_From_AutoHealTriggers(source *v20220301s.AutoHealTriggers) error {

	// PrivateBytesInKB
	triggers.PrivateBytesInKB = genruntime.ClonePointerToInt(source.PrivateBytesInKB)

	// Requests
	if source.Requests != nil {
		var request RequestsBasedTrigger
		err := request.AssignProperties_From_RequestsBasedTrigger(source.Requests)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_RequestsBasedTrigger() to populate field Requests")
		}
		triggers.Requests = &request
	} else {
		triggers.Requests = nil
	}

	// SlowRequests
	if source.SlowRequests != nil {
		var slowRequest SlowRequestsBasedTrigger
		err := slowRequest.AssignProperties_From_SlowRequestsBasedTrigger(source.SlowRequests)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SlowRequestsBasedTrigger() to populate field SlowRequests")
		}
		triggers.SlowRequests = &slowRequest
	} else {
		triggers.SlowRequests = nil
	}

	// SlowRequestsWithPath
	if source.SlowRequestsWithPath != nil {
		slowRequestsWithPathList := make([]SlowRequestsBasedTrigger, len(source.SlowRequestsWithPath))
		for slowRequestsWithPathIndex, slowRequestsWithPathItem := range source.SlowRequestsWithPath {
			// Shadow the loop variable to avoid aliasing
			slowRequestsWithPathItem := slowRequestsWithPathItem
			var slowRequestsWithPath SlowRequestsBasedTrigger
			err := slowRequestsWithPath.AssignProperties_From_SlowRequestsBasedTrigger(&slowRequestsWithPathItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SlowRequestsBasedTrigger() to populate field SlowRequestsWithPath")
			}
			slowRequestsWithPathList[slowRequestsWithPathIndex] = slowRequestsWithPath
		}
		triggers.SlowRequestsWithPath = slowRequestsWithPathList
	} else {
		triggers.SlowRequestsWithPath = nil
	}

	// StatusCodes
	if source.StatusCodes != nil {
		statusCodeList := make([]StatusCodesBasedTrigger, len(source.StatusCodes))
		for statusCodeIndex, statusCodeItem := range source.StatusCodes {
			// Shadow the loop variable to avoid aliasing
			statusCodeItem := statusCodeItem
			var statusCode StatusCodesBasedTrigger
			err := statusCode.AssignProperties_From_StatusCodesBasedTrigger(&statusCodeItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_StatusCodesBasedTrigger() to populate field StatusCodes")
			}
			statusCodeList[statusCodeIndex] = statusCode
		}
		triggers.StatusCodes = statusCodeList
	} else {
		triggers.StatusCodes = nil
	}

	// StatusCodesRange
	if source.StatusCodesRange != nil {
		statusCodesRangeList := make([]StatusCodesRangeBasedTrigger, len(source.StatusCodesRange))
		for statusCodesRangeIndex, statusCodesRangeItem := range source.StatusCodesRange {
			// Shadow the loop variable to avoid aliasing
			statusCodesRangeItem := statusCodesRangeItem
			var statusCodesRange StatusCodesRangeBasedTrigger
			err := statusCodesRange.AssignProperties_From_StatusCodesRangeBasedTrigger(&statusCodesRangeItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_StatusCodesRangeBasedTrigger() to populate field StatusCodesRange")
			}
			statusCodesRangeList[statusCodesRangeIndex] = statusCodesRange
		}
		triggers.StatusCodesRange = statusCodesRangeList
	} else {
		triggers.StatusCodesRange = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AutoHealTriggers populates the provided destination AutoHealTriggers from our AutoHealTriggers
func (triggers *AutoHealTriggers) AssignProperties_To_AutoHealTriggers(destination *v20220301s.AutoHealTriggers) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PrivateBytesInKB
	destination.PrivateBytesInKB = genruntime.ClonePointerToInt(triggers.PrivateBytesInKB)

	// Requests
	if triggers.Requests != nil {
		var request v20220301s.RequestsBasedTrigger
		err := triggers.Requests.AssignProperties_To_RequestsBasedTrigger(&request)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_RequestsBasedTrigger() to populate field Requests")
		}
		destination.Requests = &request
	} else {
		destination.Requests = nil
	}

	// SlowRequests
	if triggers.SlowRequests != nil {
		var slowRequest v20220301s.SlowRequestsBasedTrigger
		err := triggers.SlowRequests.AssignProperties_To_SlowRequestsBasedTrigger(&slowRequest)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SlowRequestsBasedTrigger() to populate field SlowRequests")
		}
		destination.SlowRequests = &slowRequest
	} else {
		destination.SlowRequests = nil
	}

	// SlowRequestsWithPath
	if triggers.SlowRequestsWithPath != nil {
		slowRequestsWithPathList := make([]v20220301s.SlowRequestsBasedTrigger, len(triggers.SlowRequestsWithPath))
		for slowRequestsWithPathIndex, slowRequestsWithPathItem := range triggers.SlowRequestsWithPath {
			// Shadow the loop variable to avoid aliasing
			slowRequestsWithPathItem := slowRequestsWithPathItem
			var slowRequestsWithPath v20220301s.SlowRequestsBasedTrigger
			err := slowRequestsWithPathItem.AssignProperties_To_SlowRequestsBasedTrigger(&slowRequestsWithPath)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SlowRequestsBasedTrigger() to populate field SlowRequestsWithPath")
			}
			slowRequestsWithPathList[slowRequestsWithPathIndex] = slowRequestsWithPath
		}
		destination.SlowRequestsWithPath = slowRequestsWithPathList
	} else {
		destination.SlowRequestsWithPath = nil
	}

	// StatusCodes
	if triggers.StatusCodes != nil {
		statusCodeList := make([]v20220301s.StatusCodesBasedTrigger, len(triggers.StatusCodes))
		for statusCodeIndex, statusCodeItem := range triggers.StatusCodes {
			// Shadow the loop variable to avoid aliasing
			statusCodeItem := statusCodeItem
			var statusCode v20220301s.StatusCodesBasedTrigger
			err := statusCodeItem.AssignProperties_To_StatusCodesBasedTrigger(&statusCode)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_StatusCodesBasedTrigger() to populate field StatusCodes")
			}
			statusCodeList[statusCodeIndex] = statusCode
		}
		destination.StatusCodes = statusCodeList
	} else {
		destination.StatusCodes = nil
	}

	// StatusCodesRange
	if triggers.StatusCodesRange != nil {
		statusCodesRangeList := make([]v20220301s.StatusCodesRangeBasedTrigger, len(triggers.StatusCodesRange))
		for statusCodesRangeIndex, statusCodesRangeItem := range triggers.StatusCodesRange {
			// Shadow the loop variable to avoid aliasing
			statusCodesRangeItem := statusCodesRangeItem
			var statusCodesRange v20220301s.StatusCodesRangeBasedTrigger
			err := statusCodesRangeItem.AssignProperties_To_StatusCodesRangeBasedTrigger(&statusCodesRange)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_StatusCodesRangeBasedTrigger() to populate field StatusCodesRange")
			}
			statusCodesRangeList[statusCodesRangeIndex] = statusCodesRange
		}
		destination.StatusCodesRange = statusCodesRangeList
	} else {
		destination.StatusCodesRange = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_AutoHealTriggers_STATUS populates our AutoHealTriggers from the provided source AutoHealTriggers_STATUS
func (triggers *AutoHealTriggers) Initialize_From_AutoHealTriggers_STATUS(source *AutoHealTriggers_STATUS) error {

	// PrivateBytesInKB
	triggers.PrivateBytesInKB = genruntime.ClonePointerToInt(source.PrivateBytesInKB)

	// Requests
	if source.Requests != nil {
		var request RequestsBasedTrigger
		err := request.Initialize_From_RequestsBasedTrigger_STATUS(source.Requests)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_RequestsBasedTrigger_STATUS() to populate field Requests")
		}
		triggers.Requests = &request
	} else {
		triggers.Requests = nil
	}

	// SlowRequests
	if source.SlowRequests != nil {
		var slowRequest SlowRequestsBasedTrigger
		err := slowRequest.Initialize_From_SlowRequestsBasedTrigger_STATUS(source.SlowRequests)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_SlowRequestsBasedTrigger_STATUS() to populate field SlowRequests")
		}
		triggers.SlowRequests = &slowRequest
	} else {
		triggers.SlowRequests = nil
	}

	// SlowRequestsWithPath
	if source.SlowRequestsWithPath != nil {
		slowRequestsWithPathList := make([]SlowRequestsBasedTrigger, len(source.SlowRequestsWithPath))
		for slowRequestsWithPathIndex, slowRequestsWithPathItem := range source.SlowRequestsWithPath {
			// Shadow the loop variable to avoid aliasing
			slowRequestsWithPathItem := slowRequestsWithPathItem
			var slowRequestsWithPath SlowRequestsBasedTrigger
			err := slowRequestsWithPath.Initialize_From_SlowRequestsBasedTrigger_STATUS(&slowRequestsWithPathItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_SlowRequestsBasedTrigger_STATUS() to populate field SlowRequestsWithPath")
			}
			slowRequestsWithPathList[slowRequestsWithPathIndex] = slowRequestsWithPath
		}
		triggers.SlowRequestsWithPath = slowRequestsWithPathList
	} else {
		triggers.SlowRequestsWithPath = nil
	}

	// StatusCodes
	if source.StatusCodes != nil {
		statusCodeList := make([]StatusCodesBasedTrigger, len(source.StatusCodes))
		for statusCodeIndex, statusCodeItem := range source.StatusCodes {
			// Shadow the loop variable to avoid aliasing
			statusCodeItem := statusCodeItem
			var statusCode StatusCodesBasedTrigger
			err := statusCode.Initialize_From_StatusCodesBasedTrigger_STATUS(&statusCodeItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_StatusCodesBasedTrigger_STATUS() to populate field StatusCodes")
			}
			statusCodeList[statusCodeIndex] = statusCode
		}
		triggers.StatusCodes = statusCodeList
	} else {
		triggers.StatusCodes = nil
	}

	// StatusCodesRange
	if source.StatusCodesRange != nil {
		statusCodesRangeList := make([]StatusCodesRangeBasedTrigger, len(source.StatusCodesRange))
		for statusCodesRangeIndex, statusCodesRangeItem := range source.StatusCodesRange {
			// Shadow the loop variable to avoid aliasing
			statusCodesRangeItem := statusCodesRangeItem
			var statusCodesRange StatusCodesRangeBasedTrigger
			err := statusCodesRange.Initialize_From_StatusCodesRangeBasedTrigger_STATUS(&statusCodesRangeItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_StatusCodesRangeBasedTrigger_STATUS() to populate field StatusCodesRange")
			}
			statusCodesRangeList[statusCodesRangeIndex] = statusCodesRange
		}
		triggers.StatusCodesRange = statusCodesRangeList
	} else {
		triggers.StatusCodesRange = nil
	}

	// No error
	return nil
}

// Triggers for auto-heal.
type AutoHealTriggers_STATUS struct {
	// PrivateBytesInKB: A rule based on private bytes.
	PrivateBytesInKB *int `json:"privateBytesInKB,omitempty"`

	// Requests: A rule based on total requests.
	Requests *RequestsBasedTrigger_STATUS `json:"requests,omitempty"`

	// SlowRequests: A rule based on request execution time.
	SlowRequests *SlowRequestsBasedTrigger_STATUS `json:"slowRequests,omitempty"`

	// SlowRequestsWithPath: A rule based on multiple Slow Requests Rule with path
	SlowRequestsWithPath []SlowRequestsBasedTrigger_STATUS `json:"slowRequestsWithPath,omitempty"`

	// StatusCodes: A rule based on status codes.
	StatusCodes []StatusCodesBasedTrigger_STATUS `json:"statusCodes,omitempty"`

	// StatusCodesRange: A rule based on status codes ranges.
	StatusCodesRange []StatusCodesRangeBasedTrigger_STATUS `json:"statusCodesRange,omitempty"`
}

var _ genruntime.FromARMConverter = &AutoHealTriggers_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (triggers *AutoHealTriggers_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &AutoHealTriggers_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (triggers *AutoHealTriggers_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(AutoHealTriggers_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected AutoHealTriggers_STATUS_ARM, got %T", armInput)
	}

	// Set property "PrivateBytesInKB":
	if typedInput.PrivateBytesInKB != nil {
		privateBytesInKB := *typedInput.PrivateBytesInKB
		triggers.PrivateBytesInKB = &privateBytesInKB
	}

	// Set property "Requests":
	if typedInput.Requests != nil {
		var requests1 RequestsBasedTrigger_STATUS
		err := requests1.PopulateFromARM(owner, *typedInput.Requests)
		if err != nil {
			return err
		}
		requests := requests1
		triggers.Requests = &requests
	}

	// Set property "SlowRequests":
	if typedInput.SlowRequests != nil {
		var slowRequests1 SlowRequestsBasedTrigger_STATUS
		err := slowRequests1.PopulateFromARM(owner, *typedInput.SlowRequests)
		if err != nil {
			return err
		}
		slowRequests := slowRequests1
		triggers.SlowRequests = &slowRequests
	}

	// Set property "SlowRequestsWithPath":
	for _, item := range typedInput.SlowRequestsWithPath {
		var item1 SlowRequestsBasedTrigger_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		triggers.SlowRequestsWithPath = append(triggers.SlowRequestsWithPath, item1)
	}

	// Set property "StatusCodes":
	for _, item := range typedInput.StatusCodes {
		var item1 StatusCodesBasedTrigger_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		triggers.StatusCodes = append(triggers.StatusCodes, item1)
	}

	// Set property "StatusCodesRange":
	for _, item := range typedInput.StatusCodesRange {
		var item1 StatusCodesRangeBasedTrigger_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		triggers.StatusCodesRange = append(triggers.StatusCodesRange, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_AutoHealTriggers_STATUS populates our AutoHealTriggers_STATUS from the provided source AutoHealTriggers_STATUS
func (triggers *AutoHealTriggers_STATUS) AssignProperties_From_AutoHealTriggers_STATUS(source *v20220301s.AutoHealTriggers_STATUS) error {

	// PrivateBytesInKB
	triggers.PrivateBytesInKB = genruntime.ClonePointerToInt(source.PrivateBytesInKB)

	// Requests
	if source.Requests != nil {
		var request RequestsBasedTrigger_STATUS
		err := request.AssignProperties_From_RequestsBasedTrigger_STATUS(source.Requests)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_RequestsBasedTrigger_STATUS() to populate field Requests")
		}
		triggers.Requests = &request
	} else {
		triggers.Requests = nil
	}

	// SlowRequests
	if source.SlowRequests != nil {
		var slowRequest SlowRequestsBasedTrigger_STATUS
		err := slowRequest.AssignProperties_From_SlowRequestsBasedTrigger_STATUS(source.SlowRequests)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SlowRequestsBasedTrigger_STATUS() to populate field SlowRequests")
		}
		triggers.SlowRequests = &slowRequest
	} else {
		triggers.SlowRequests = nil
	}

	// SlowRequestsWithPath
	if source.SlowRequestsWithPath != nil {
		slowRequestsWithPathList := make([]SlowRequestsBasedTrigger_STATUS, len(source.SlowRequestsWithPath))
		for slowRequestsWithPathIndex, slowRequestsWithPathItem := range source.SlowRequestsWithPath {
			// Shadow the loop variable to avoid aliasing
			slowRequestsWithPathItem := slowRequestsWithPathItem
			var slowRequestsWithPath SlowRequestsBasedTrigger_STATUS
			err := slowRequestsWithPath.AssignProperties_From_SlowRequestsBasedTrigger_STATUS(&slowRequestsWithPathItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SlowRequestsBasedTrigger_STATUS() to populate field SlowRequestsWithPath")
			}
			slowRequestsWithPathList[slowRequestsWithPathIndex] = slowRequestsWithPath
		}
		triggers.SlowRequestsWithPath = slowRequestsWithPathList
	} else {
		triggers.SlowRequestsWithPath = nil
	}

	// StatusCodes
	if source.StatusCodes != nil {
		statusCodeList := make([]StatusCodesBasedTrigger_STATUS, len(source.StatusCodes))
		for statusCodeIndex, statusCodeItem := range source.StatusCodes {
			// Shadow the loop variable to avoid aliasing
			statusCodeItem := statusCodeItem
			var statusCode StatusCodesBasedTrigger_STATUS
			err := statusCode.AssignProperties_From_StatusCodesBasedTrigger_STATUS(&statusCodeItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_StatusCodesBasedTrigger_STATUS() to populate field StatusCodes")
			}
			statusCodeList[statusCodeIndex] = statusCode
		}
		triggers.StatusCodes = statusCodeList
	} else {
		triggers.StatusCodes = nil
	}

	// StatusCodesRange
	if source.StatusCodesRange != nil {
		statusCodesRangeList := make([]StatusCodesRangeBasedTrigger_STATUS, len(source.StatusCodesRange))
		for statusCodesRangeIndex, statusCodesRangeItem := range source.StatusCodesRange {
			// Shadow the loop variable to avoid aliasing
			statusCodesRangeItem := statusCodesRangeItem
			var statusCodesRange StatusCodesRangeBasedTrigger_STATUS
			err := statusCodesRange.AssignProperties_From_StatusCodesRangeBasedTrigger_STATUS(&statusCodesRangeItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_StatusCodesRangeBasedTrigger_STATUS() to populate field StatusCodesRange")
			}
			statusCodesRangeList[statusCodesRangeIndex] = statusCodesRange
		}
		triggers.StatusCodesRange = statusCodesRangeList
	} else {
		triggers.StatusCodesRange = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AutoHealTriggers_STATUS populates the provided destination AutoHealTriggers_STATUS from our AutoHealTriggers_STATUS
func (triggers *AutoHealTriggers_STATUS) AssignProperties_To_AutoHealTriggers_STATUS(destination *v20220301s.AutoHealTriggers_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PrivateBytesInKB
	destination.PrivateBytesInKB = genruntime.ClonePointerToInt(triggers.PrivateBytesInKB)

	// Requests
	if triggers.Requests != nil {
		var request v20220301s.RequestsBasedTrigger_STATUS
		err := triggers.Requests.AssignProperties_To_RequestsBasedTrigger_STATUS(&request)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_RequestsBasedTrigger_STATUS() to populate field Requests")
		}
		destination.Requests = &request
	} else {
		destination.Requests = nil
	}

	// SlowRequests
	if triggers.SlowRequests != nil {
		var slowRequest v20220301s.SlowRequestsBasedTrigger_STATUS
		err := triggers.SlowRequests.AssignProperties_To_SlowRequestsBasedTrigger_STATUS(&slowRequest)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SlowRequestsBasedTrigger_STATUS() to populate field SlowRequests")
		}
		destination.SlowRequests = &slowRequest
	} else {
		destination.SlowRequests = nil
	}

	// SlowRequestsWithPath
	if triggers.SlowRequestsWithPath != nil {
		slowRequestsWithPathList := make([]v20220301s.SlowRequestsBasedTrigger_STATUS, len(triggers.SlowRequestsWithPath))
		for slowRequestsWithPathIndex, slowRequestsWithPathItem := range triggers.SlowRequestsWithPath {
			// Shadow the loop variable to avoid aliasing
			slowRequestsWithPathItem := slowRequestsWithPathItem
			var slowRequestsWithPath v20220301s.SlowRequestsBasedTrigger_STATUS
			err := slowRequestsWithPathItem.AssignProperties_To_SlowRequestsBasedTrigger_STATUS(&slowRequestsWithPath)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SlowRequestsBasedTrigger_STATUS() to populate field SlowRequestsWithPath")
			}
			slowRequestsWithPathList[slowRequestsWithPathIndex] = slowRequestsWithPath
		}
		destination.SlowRequestsWithPath = slowRequestsWithPathList
	} else {
		destination.SlowRequestsWithPath = nil
	}

	// StatusCodes
	if triggers.StatusCodes != nil {
		statusCodeList := make([]v20220301s.StatusCodesBasedTrigger_STATUS, len(triggers.StatusCodes))
		for statusCodeIndex, statusCodeItem := range triggers.StatusCodes {
			// Shadow the loop variable to avoid aliasing
			statusCodeItem := statusCodeItem
			var statusCode v20220301s.StatusCodesBasedTrigger_STATUS
			err := statusCodeItem.AssignProperties_To_StatusCodesBasedTrigger_STATUS(&statusCode)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_StatusCodesBasedTrigger_STATUS() to populate field StatusCodes")
			}
			statusCodeList[statusCodeIndex] = statusCode
		}
		destination.StatusCodes = statusCodeList
	} else {
		destination.StatusCodes = nil
	}

	// StatusCodesRange
	if triggers.StatusCodesRange != nil {
		statusCodesRangeList := make([]v20220301s.StatusCodesRangeBasedTrigger_STATUS, len(triggers.StatusCodesRange))
		for statusCodesRangeIndex, statusCodesRangeItem := range triggers.StatusCodesRange {
			// Shadow the loop variable to avoid aliasing
			statusCodesRangeItem := statusCodesRangeItem
			var statusCodesRange v20220301s.StatusCodesRangeBasedTrigger_STATUS
			err := statusCodesRangeItem.AssignProperties_To_StatusCodesRangeBasedTrigger_STATUS(&statusCodesRange)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_StatusCodesRangeBasedTrigger_STATUS() to populate field StatusCodesRange")
			}
			statusCodesRangeList[statusCodesRangeIndex] = statusCodesRange
		}
		destination.StatusCodesRange = statusCodesRangeList
	} else {
		destination.StatusCodesRange = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type AzureStorageInfoValue_State_STATUS string

const (
	AzureStorageInfoValue_State_STATUS_InvalidCredentials = AzureStorageInfoValue_State_STATUS("InvalidCredentials")
	AzureStorageInfoValue_State_STATUS_InvalidShare       = AzureStorageInfoValue_State_STATUS("InvalidShare")
	AzureStorageInfoValue_State_STATUS_NotValidated       = AzureStorageInfoValue_State_STATUS("NotValidated")
	AzureStorageInfoValue_State_STATUS_Ok                 = AzureStorageInfoValue_State_STATUS("Ok")
)

// +kubebuilder:validation:Enum={"AzureBlob","AzureFiles"}
type AzureStorageInfoValue_Type string

const (
	AzureStorageInfoValue_Type_AzureBlob  = AzureStorageInfoValue_Type("AzureBlob")
	AzureStorageInfoValue_Type_AzureFiles = AzureStorageInfoValue_Type("AzureFiles")
)

type AzureStorageInfoValue_Type_STATUS string

const (
	AzureStorageInfoValue_Type_STATUS_AzureBlob  = AzureStorageInfoValue_Type_STATUS("AzureBlob")
	AzureStorageInfoValue_Type_STATUS_AzureFiles = AzureStorageInfoValue_Type_STATUS("AzureFiles")
)

// +kubebuilder:validation:Enum={"ApiHub","Custom","DocDb","EventHub","MySql","NotificationHub","PostgreSQL","RedisCache","SQLAzure","SQLServer","ServiceBus"}
type ConnStringInfo_Type string

const (
	ConnStringInfo_Type_ApiHub          = ConnStringInfo_Type("ApiHub")
	ConnStringInfo_Type_Custom          = ConnStringInfo_Type("Custom")
	ConnStringInfo_Type_DocDb           = ConnStringInfo_Type("DocDb")
	ConnStringInfo_Type_EventHub        = ConnStringInfo_Type("EventHub")
	ConnStringInfo_Type_MySql           = ConnStringInfo_Type("MySql")
	ConnStringInfo_Type_NotificationHub = ConnStringInfo_Type("NotificationHub")
	ConnStringInfo_Type_PostgreSQL      = ConnStringInfo_Type("PostgreSQL")
	ConnStringInfo_Type_RedisCache      = ConnStringInfo_Type("RedisCache")
	ConnStringInfo_Type_SQLAzure        = ConnStringInfo_Type("SQLAzure")
	ConnStringInfo_Type_SQLServer       = ConnStringInfo_Type("SQLServer")
	ConnStringInfo_Type_ServiceBus      = ConnStringInfo_Type("ServiceBus")
)

type ConnStringInfo_Type_STATUS string

const (
	ConnStringInfo_Type_STATUS_ApiHub          = ConnStringInfo_Type_STATUS("ApiHub")
	ConnStringInfo_Type_STATUS_Custom          = ConnStringInfo_Type_STATUS("Custom")
	ConnStringInfo_Type_STATUS_DocDb           = ConnStringInfo_Type_STATUS("DocDb")
	ConnStringInfo_Type_STATUS_EventHub        = ConnStringInfo_Type_STATUS("EventHub")
	ConnStringInfo_Type_STATUS_MySql           = ConnStringInfo_Type_STATUS("MySql")
	ConnStringInfo_Type_STATUS_NotificationHub = ConnStringInfo_Type_STATUS("NotificationHub")
	ConnStringInfo_Type_STATUS_PostgreSQL      = ConnStringInfo_Type_STATUS("PostgreSQL")
	ConnStringInfo_Type_STATUS_RedisCache      = ConnStringInfo_Type_STATUS("RedisCache")
	ConnStringInfo_Type_STATUS_SQLAzure        = ConnStringInfo_Type_STATUS("SQLAzure")
	ConnStringInfo_Type_STATUS_SQLServer       = ConnStringInfo_Type_STATUS("SQLServer")
	ConnStringInfo_Type_STATUS_ServiceBus      = ConnStringInfo_Type_STATUS("ServiceBus")
)

// +kubebuilder:validation:Enum={"Default","ServiceTag","XffProxy"}
type IpSecurityRestriction_Tag string

const (
	IpSecurityRestriction_Tag_Default    = IpSecurityRestriction_Tag("Default")
	IpSecurityRestriction_Tag_ServiceTag = IpSecurityRestriction_Tag("ServiceTag")
	IpSecurityRestriction_Tag_XffProxy   = IpSecurityRestriction_Tag("XffProxy")
)

type IpSecurityRestriction_Tag_STATUS string

const (
	IpSecurityRestriction_Tag_STATUS_Default    = IpSecurityRestriction_Tag_STATUS("Default")
	IpSecurityRestriction_Tag_STATUS_ServiceTag = IpSecurityRestriction_Tag_STATUS("ServiceTag")
	IpSecurityRestriction_Tag_STATUS_XffProxy   = IpSecurityRestriction_Tag_STATUS("XffProxy")
)

// Routing rules for ramp up testing. This rule allows to redirect static traffic % to a slot or to gradually change
// routing % based on performance.
type RampUpRule struct {
	// ActionHostName: Hostname of a slot to which the traffic will be redirected if decided to. E.g.
	// myapp-stage.azurewebsites.net.
	ActionHostName *string `json:"actionHostName,omitempty"`

	// ChangeDecisionCallbackUrl: Custom decision algorithm can be provided in TiPCallback site extension which URL can be
	// specified. See TiPCallback site extension for the scaffold and contracts.
	// https://www.siteextensions.net/packages/TiPCallback/
	ChangeDecisionCallbackUrl *string `json:"changeDecisionCallbackUrl,omitempty"`

	// ChangeIntervalInMinutes: Specifies interval in minutes to reevaluate ReroutePercentage.
	ChangeIntervalInMinutes *int `json:"changeIntervalInMinutes,omitempty"`

	// ChangeStep: In auto ramp up scenario this is the step to add/remove from <code>ReroutePercentage</code> until it reaches
	// \n<code>MinReroutePercentage</code> or
	// <code>MaxReroutePercentage</code>. Site metrics are checked every N minutes specified in
	// <code>ChangeIntervalInMinutes</code>.\nCustom decision algorithm
	// can be provided in TiPCallback site extension which URL can be specified in <code>ChangeDecisionCallbackUrl</code>.
	ChangeStep *float64 `json:"changeStep,omitempty"`

	// MaxReroutePercentage: Specifies upper boundary below which ReroutePercentage will stay.
	MaxReroutePercentage *float64 `json:"maxReroutePercentage,omitempty"`

	// MinReroutePercentage: Specifies lower boundary above which ReroutePercentage will stay.
	MinReroutePercentage *float64 `json:"minReroutePercentage,omitempty"`

	// Name: Name of the routing rule. The recommended name would be to point to the slot which will receive the traffic in the
	// experiment.
	Name *string `json:"name,omitempty"`

	// ReroutePercentage: Percentage of the traffic which will be redirected to <code>ActionHostName</code>.
	ReroutePercentage *float64 `json:"reroutePercentage,omitempty"`
}

var _ genruntime.ARMTransformer = &RampUpRule{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (rule *RampUpRule) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if rule == nil {
		return nil, nil
	}
	result := &RampUpRule_ARM{}

	// Set property "ActionHostName":
	if rule.ActionHostName != nil {
		actionHostName := *rule.ActionHostName
		result.ActionHostName = &actionHostName
	}

	// Set property "ChangeDecisionCallbackUrl":
	if rule.ChangeDecisionCallbackUrl != nil {
		changeDecisionCallbackUrl := *rule.ChangeDecisionCallbackUrl
		result.ChangeDecisionCallbackUrl = &changeDecisionCallbackUrl
	}

	// Set property "ChangeIntervalInMinutes":
	if rule.ChangeIntervalInMinutes != nil {
		changeIntervalInMinutes := *rule.ChangeIntervalInMinutes
		result.ChangeIntervalInMinutes = &changeIntervalInMinutes
	}

	// Set property "ChangeStep":
	if rule.ChangeStep != nil {
		changeStep := *rule.ChangeStep
		result.ChangeStep = &changeStep
	}

	// Set property "MaxReroutePercentage":
	if rule.MaxReroutePercentage != nil {
		maxReroutePercentage := *rule.MaxReroutePercentage
		result.MaxReroutePercentage = &maxReroutePercentage
	}

	// Set property "MinReroutePercentage":
	if rule.MinReroutePercentage != nil {
		minReroutePercentage := *rule.MinReroutePercentage
		result.MinReroutePercentage = &minReroutePercentage
	}

	// Set property "Name":
	if rule.Name != nil {
		name := *rule.Name
		result.Name = &name
	}

	// Set property "ReroutePercentage":
	if rule.ReroutePercentage != nil {
		reroutePercentage := *rule.ReroutePercentage
		result.ReroutePercentage = &reroutePercentage
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *RampUpRule) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &RampUpRule_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *RampUpRule) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(RampUpRule_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected RampUpRule_ARM, got %T", armInput)
	}

	// Set property "ActionHostName":
	if typedInput.ActionHostName != nil {
		actionHostName := *typedInput.ActionHostName
		rule.ActionHostName = &actionHostName
	}

	// Set property "ChangeDecisionCallbackUrl":
	if typedInput.ChangeDecisionCallbackUrl != nil {
		changeDecisionCallbackUrl := *typedInput.ChangeDecisionCallbackUrl
		rule.ChangeDecisionCallbackUrl = &changeDecisionCallbackUrl
	}

	// Set property "ChangeIntervalInMinutes":
	if typedInput.ChangeIntervalInMinutes != nil {
		changeIntervalInMinutes := *typedInput.ChangeIntervalInMinutes
		rule.ChangeIntervalInMinutes = &changeIntervalInMinutes
	}

	// Set property "ChangeStep":
	if typedInput.ChangeStep != nil {
		changeStep := *typedInput.ChangeStep
		rule.ChangeStep = &changeStep
	}

	// Set property "MaxReroutePercentage":
	if typedInput.MaxReroutePercentage != nil {
		maxReroutePercentage := *typedInput.MaxReroutePercentage
		rule.MaxReroutePercentage = &maxReroutePercentage
	}

	// Set property "MinReroutePercentage":
	if typedInput.MinReroutePercentage != nil {
		minReroutePercentage := *typedInput.MinReroutePercentage
		rule.MinReroutePercentage = &minReroutePercentage
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		rule.Name = &name
	}

	// Set property "ReroutePercentage":
	if typedInput.ReroutePercentage != nil {
		reroutePercentage := *typedInput.ReroutePercentage
		rule.ReroutePercentage = &reroutePercentage
	}

	// No error
	return nil
}

// AssignProperties_From_RampUpRule populates our RampUpRule from the provided source RampUpRule
func (rule *RampUpRule) AssignProperties_From_RampUpRule(source *v20220301s.RampUpRule) error {

	// ActionHostName
	rule.ActionHostName = genruntime.ClonePointerToString(source.ActionHostName)

	// ChangeDecisionCallbackUrl
	rule.ChangeDecisionCallbackUrl = genruntime.ClonePointerToString(source.ChangeDecisionCallbackUrl)

	// ChangeIntervalInMinutes
	rule.ChangeIntervalInMinutes = genruntime.ClonePointerToInt(source.ChangeIntervalInMinutes)

	// ChangeStep
	if source.ChangeStep != nil {
		changeStep := *source.ChangeStep
		rule.ChangeStep = &changeStep
	} else {
		rule.ChangeStep = nil
	}

	// MaxReroutePercentage
	if source.MaxReroutePercentage != nil {
		maxReroutePercentage := *source.MaxReroutePercentage
		rule.MaxReroutePercentage = &maxReroutePercentage
	} else {
		rule.MaxReroutePercentage = nil
	}

	// MinReroutePercentage
	if source.MinReroutePercentage != nil {
		minReroutePercentage := *source.MinReroutePercentage
		rule.MinReroutePercentage = &minReroutePercentage
	} else {
		rule.MinReroutePercentage = nil
	}

	// Name
	rule.Name = genruntime.ClonePointerToString(source.Name)

	// ReroutePercentage
	if source.ReroutePercentage != nil {
		reroutePercentage := *source.ReroutePercentage
		rule.ReroutePercentage = &reroutePercentage
	} else {
		rule.ReroutePercentage = nil
	}

	// No error
	return nil
}

// AssignProperties_To_RampUpRule populates the provided destination RampUpRule from our RampUpRule
func (rule *RampUpRule) AssignProperties_To_RampUpRule(destination *v20220301s.RampUpRule) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ActionHostName
	destination.ActionHostName = genruntime.ClonePointerToString(rule.ActionHostName)

	// ChangeDecisionCallbackUrl
	destination.ChangeDecisionCallbackUrl = genruntime.ClonePointerToString(rule.ChangeDecisionCallbackUrl)

	// ChangeIntervalInMinutes
	destination.ChangeIntervalInMinutes = genruntime.ClonePointerToInt(rule.ChangeIntervalInMinutes)

	// ChangeStep
	if rule.ChangeStep != nil {
		changeStep := *rule.ChangeStep
		destination.ChangeStep = &changeStep
	} else {
		destination.ChangeStep = nil
	}

	// MaxReroutePercentage
	if rule.MaxReroutePercentage != nil {
		maxReroutePercentage := *rule.MaxReroutePercentage
		destination.MaxReroutePercentage = &maxReroutePercentage
	} else {
		destination.MaxReroutePercentage = nil
	}

	// MinReroutePercentage
	if rule.MinReroutePercentage != nil {
		minReroutePercentage := *rule.MinReroutePercentage
		destination.MinReroutePercentage = &minReroutePercentage
	} else {
		destination.MinReroutePercentage = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(rule.Name)

	// ReroutePercentage
	if rule.ReroutePercentage != nil {
		reroutePercentage := *rule.ReroutePercentage
		destination.ReroutePercentage = &reroutePercentage
	} else {
		destination.ReroutePercentage = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_RampUpRule_STATUS populates our RampUpRule from the provided source RampUpRule_STATUS
func (rule *RampUpRule) Initialize_From_RampUpRule_STATUS(source *RampUpRule_STATUS) error {

	// ActionHostName
	rule.ActionHostName = genruntime.ClonePointerToString(source.ActionHostName)

	// ChangeDecisionCallbackUrl
	rule.ChangeDecisionCallbackUrl = genruntime.ClonePointerToString(source.ChangeDecisionCallbackUrl)

	// ChangeIntervalInMinutes
	rule.ChangeIntervalInMinutes = genruntime.ClonePointerToInt(source.ChangeIntervalInMinutes)

	// ChangeStep
	if source.ChangeStep != nil {
		changeStep := *source.ChangeStep
		rule.ChangeStep = &changeStep
	} else {
		rule.ChangeStep = nil
	}

	// MaxReroutePercentage
	if source.MaxReroutePercentage != nil {
		maxReroutePercentage := *source.MaxReroutePercentage
		rule.MaxReroutePercentage = &maxReroutePercentage
	} else {
		rule.MaxReroutePercentage = nil
	}

	// MinReroutePercentage
	if source.MinReroutePercentage != nil {
		minReroutePercentage := *source.MinReroutePercentage
		rule.MinReroutePercentage = &minReroutePercentage
	} else {
		rule.MinReroutePercentage = nil
	}

	// Name
	rule.Name = genruntime.ClonePointerToString(source.Name)

	// ReroutePercentage
	if source.ReroutePercentage != nil {
		reroutePercentage := *source.ReroutePercentage
		rule.ReroutePercentage = &reroutePercentage
	} else {
		rule.ReroutePercentage = nil
	}

	// No error
	return nil
}

// Routing rules for ramp up testing. This rule allows to redirect static traffic % to a slot or to gradually change
// routing % based on performance.
type RampUpRule_STATUS struct {
	// ActionHostName: Hostname of a slot to which the traffic will be redirected if decided to. E.g.
	// myapp-stage.azurewebsites.net.
	ActionHostName *string `json:"actionHostName,omitempty"`

	// ChangeDecisionCallbackUrl: Custom decision algorithm can be provided in TiPCallback site extension which URL can be
	// specified. See TiPCallback site extension for the scaffold and contracts.
	// https://www.siteextensions.net/packages/TiPCallback/
	ChangeDecisionCallbackUrl *string `json:"changeDecisionCallbackUrl,omitempty"`

	// ChangeIntervalInMinutes: Specifies interval in minutes to reevaluate ReroutePercentage.
	ChangeIntervalInMinutes *int `json:"changeIntervalInMinutes,omitempty"`

	// ChangeStep: In auto ramp up scenario this is the step to add/remove from <code>ReroutePercentage</code> until it reaches
	// \n<code>MinReroutePercentage</code> or
	// <code>MaxReroutePercentage</code>. Site metrics are checked every N minutes specified in
	// <code>ChangeIntervalInMinutes</code>.\nCustom decision algorithm
	// can be provided in TiPCallback site extension which URL can be specified in <code>ChangeDecisionCallbackUrl</code>.
	ChangeStep *float64 `json:"changeStep,omitempty"`

	// MaxReroutePercentage: Specifies upper boundary below which ReroutePercentage will stay.
	MaxReroutePercentage *float64 `json:"maxReroutePercentage,omitempty"`

	// MinReroutePercentage: Specifies lower boundary above which ReroutePercentage will stay.
	MinReroutePercentage *float64 `json:"minReroutePercentage,omitempty"`

	// Name: Name of the routing rule. The recommended name would be to point to the slot which will receive the traffic in the
	// experiment.
	Name *string `json:"name,omitempty"`

	// ReroutePercentage: Percentage of the traffic which will be redirected to <code>ActionHostName</code>.
	ReroutePercentage *float64 `json:"reroutePercentage,omitempty"`
}

var _ genruntime.FromARMConverter = &RampUpRule_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *RampUpRule_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &RampUpRule_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *RampUpRule_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(RampUpRule_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected RampUpRule_STATUS_ARM, got %T", armInput)
	}

	// Set property "ActionHostName":
	if typedInput.ActionHostName != nil {
		actionHostName := *typedInput.ActionHostName
		rule.ActionHostName = &actionHostName
	}

	// Set property "ChangeDecisionCallbackUrl":
	if typedInput.ChangeDecisionCallbackUrl != nil {
		changeDecisionCallbackUrl := *typedInput.ChangeDecisionCallbackUrl
		rule.ChangeDecisionCallbackUrl = &changeDecisionCallbackUrl
	}

	// Set property "ChangeIntervalInMinutes":
	if typedInput.ChangeIntervalInMinutes != nil {
		changeIntervalInMinutes := *typedInput.ChangeIntervalInMinutes
		rule.ChangeIntervalInMinutes = &changeIntervalInMinutes
	}

	// Set property "ChangeStep":
	if typedInput.ChangeStep != nil {
		changeStep := *typedInput.ChangeStep
		rule.ChangeStep = &changeStep
	}

	// Set property "MaxReroutePercentage":
	if typedInput.MaxReroutePercentage != nil {
		maxReroutePercentage := *typedInput.MaxReroutePercentage
		rule.MaxReroutePercentage = &maxReroutePercentage
	}

	// Set property "MinReroutePercentage":
	if typedInput.MinReroutePercentage != nil {
		minReroutePercentage := *typedInput.MinReroutePercentage
		rule.MinReroutePercentage = &minReroutePercentage
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		rule.Name = &name
	}

	// Set property "ReroutePercentage":
	if typedInput.ReroutePercentage != nil {
		reroutePercentage := *typedInput.ReroutePercentage
		rule.ReroutePercentage = &reroutePercentage
	}

	// No error
	return nil
}

// AssignProperties_From_RampUpRule_STATUS populates our RampUpRule_STATUS from the provided source RampUpRule_STATUS
func (rule *RampUpRule_STATUS) AssignProperties_From_RampUpRule_STATUS(source *v20220301s.RampUpRule_STATUS) error {

	// ActionHostName
	rule.ActionHostName = genruntime.ClonePointerToString(source.ActionHostName)

	// ChangeDecisionCallbackUrl
	rule.ChangeDecisionCallbackUrl = genruntime.ClonePointerToString(source.ChangeDecisionCallbackUrl)

	// ChangeIntervalInMinutes
	rule.ChangeIntervalInMinutes = genruntime.ClonePointerToInt(source.ChangeIntervalInMinutes)

	// ChangeStep
	if source.ChangeStep != nil {
		changeStep := *source.ChangeStep
		rule.ChangeStep = &changeStep
	} else {
		rule.ChangeStep = nil
	}

	// MaxReroutePercentage
	if source.MaxReroutePercentage != nil {
		maxReroutePercentage := *source.MaxReroutePercentage
		rule.MaxReroutePercentage = &maxReroutePercentage
	} else {
		rule.MaxReroutePercentage = nil
	}

	// MinReroutePercentage
	if source.MinReroutePercentage != nil {
		minReroutePercentage := *source.MinReroutePercentage
		rule.MinReroutePercentage = &minReroutePercentage
	} else {
		rule.MinReroutePercentage = nil
	}

	// Name
	rule.Name = genruntime.ClonePointerToString(source.Name)

	// ReroutePercentage
	if source.ReroutePercentage != nil {
		reroutePercentage := *source.ReroutePercentage
		rule.ReroutePercentage = &reroutePercentage
	} else {
		rule.ReroutePercentage = nil
	}

	// No error
	return nil
}

// AssignProperties_To_RampUpRule_STATUS populates the provided destination RampUpRule_STATUS from our RampUpRule_STATUS
func (rule *RampUpRule_STATUS) AssignProperties_To_RampUpRule_STATUS(destination *v20220301s.RampUpRule_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ActionHostName
	destination.ActionHostName = genruntime.ClonePointerToString(rule.ActionHostName)

	// ChangeDecisionCallbackUrl
	destination.ChangeDecisionCallbackUrl = genruntime.ClonePointerToString(rule.ChangeDecisionCallbackUrl)

	// ChangeIntervalInMinutes
	destination.ChangeIntervalInMinutes = genruntime.ClonePointerToInt(rule.ChangeIntervalInMinutes)

	// ChangeStep
	if rule.ChangeStep != nil {
		changeStep := *rule.ChangeStep
		destination.ChangeStep = &changeStep
	} else {
		destination.ChangeStep = nil
	}

	// MaxReroutePercentage
	if rule.MaxReroutePercentage != nil {
		maxReroutePercentage := *rule.MaxReroutePercentage
		destination.MaxReroutePercentage = &maxReroutePercentage
	} else {
		destination.MaxReroutePercentage = nil
	}

	// MinReroutePercentage
	if rule.MinReroutePercentage != nil {
		minReroutePercentage := *rule.MinReroutePercentage
		destination.MinReroutePercentage = &minReroutePercentage
	} else {
		destination.MinReroutePercentage = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(rule.Name)

	// ReroutePercentage
	if rule.ReroutePercentage != nil {
		reroutePercentage := *rule.ReroutePercentage
		destination.ReroutePercentage = &reroutePercentage
	} else {
		destination.ReroutePercentage = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Directory for virtual application.
type VirtualDirectory struct {
	// PhysicalPath: Physical path.
	PhysicalPath *string `json:"physicalPath,omitempty"`

	// VirtualPath: Path to virtual application.
	VirtualPath *string `json:"virtualPath,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualDirectory{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (directory *VirtualDirectory) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if directory == nil {
		return nil, nil
	}
	result := &VirtualDirectory_ARM{}

	// Set property "PhysicalPath":
	if directory.PhysicalPath != nil {
		physicalPath := *directory.PhysicalPath
		result.PhysicalPath = &physicalPath
	}

	// Set property "VirtualPath":
	if directory.VirtualPath != nil {
		virtualPath := *directory.VirtualPath
		result.VirtualPath = &virtualPath
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (directory *VirtualDirectory) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualDirectory_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (directory *VirtualDirectory) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualDirectory_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualDirectory_ARM, got %T", armInput)
	}

	// Set property "PhysicalPath":
	if typedInput.PhysicalPath != nil {
		physicalPath := *typedInput.PhysicalPath
		directory.PhysicalPath = &physicalPath
	}

	// Set property "VirtualPath":
	if typedInput.VirtualPath != nil {
		virtualPath := *typedInput.VirtualPath
		directory.VirtualPath = &virtualPath
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualDirectory populates our VirtualDirectory from the provided source VirtualDirectory
func (directory *VirtualDirectory) AssignProperties_From_VirtualDirectory(source *v20220301s.VirtualDirectory) error {

	// PhysicalPath
	directory.PhysicalPath = genruntime.ClonePointerToString(source.PhysicalPath)

	// VirtualPath
	directory.VirtualPath = genruntime.ClonePointerToString(source.VirtualPath)

	// No error
	return nil
}

// AssignProperties_To_VirtualDirectory populates the provided destination VirtualDirectory from our VirtualDirectory
func (directory *VirtualDirectory) AssignProperties_To_VirtualDirectory(destination *v20220301s.VirtualDirectory) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PhysicalPath
	destination.PhysicalPath = genruntime.ClonePointerToString(directory.PhysicalPath)

	// VirtualPath
	destination.VirtualPath = genruntime.ClonePointerToString(directory.VirtualPath)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_VirtualDirectory_STATUS populates our VirtualDirectory from the provided source VirtualDirectory_STATUS
func (directory *VirtualDirectory) Initialize_From_VirtualDirectory_STATUS(source *VirtualDirectory_STATUS) error {

	// PhysicalPath
	directory.PhysicalPath = genruntime.ClonePointerToString(source.PhysicalPath)

	// VirtualPath
	directory.VirtualPath = genruntime.ClonePointerToString(source.VirtualPath)

	// No error
	return nil
}

// Directory for virtual application.
type VirtualDirectory_STATUS struct {
	// PhysicalPath: Physical path.
	PhysicalPath *string `json:"physicalPath,omitempty"`

	// VirtualPath: Path to virtual application.
	VirtualPath *string `json:"virtualPath,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualDirectory_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (directory *VirtualDirectory_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualDirectory_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (directory *VirtualDirectory_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualDirectory_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualDirectory_STATUS_ARM, got %T", armInput)
	}

	// Set property "PhysicalPath":
	if typedInput.PhysicalPath != nil {
		physicalPath := *typedInput.PhysicalPath
		directory.PhysicalPath = &physicalPath
	}

	// Set property "VirtualPath":
	if typedInput.VirtualPath != nil {
		virtualPath := *typedInput.VirtualPath
		directory.VirtualPath = &virtualPath
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualDirectory_STATUS populates our VirtualDirectory_STATUS from the provided source VirtualDirectory_STATUS
func (directory *VirtualDirectory_STATUS) AssignProperties_From_VirtualDirectory_STATUS(source *v20220301s.VirtualDirectory_STATUS) error {

	// PhysicalPath
	directory.PhysicalPath = genruntime.ClonePointerToString(source.PhysicalPath)

	// VirtualPath
	directory.VirtualPath = genruntime.ClonePointerToString(source.VirtualPath)

	// No error
	return nil
}

// AssignProperties_To_VirtualDirectory_STATUS populates the provided destination VirtualDirectory_STATUS from our VirtualDirectory_STATUS
func (directory *VirtualDirectory_STATUS) AssignProperties_To_VirtualDirectory_STATUS(destination *v20220301s.VirtualDirectory_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PhysicalPath
	destination.PhysicalPath = genruntime.ClonePointerToString(directory.PhysicalPath)

	// VirtualPath
	destination.VirtualPath = genruntime.ClonePointerToString(directory.VirtualPath)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"CustomAction","LogEvent","Recycle"}
type AutoHealActions_ActionType string

const (
	AutoHealActions_ActionType_CustomAction = AutoHealActions_ActionType("CustomAction")
	AutoHealActions_ActionType_LogEvent     = AutoHealActions_ActionType("LogEvent")
	AutoHealActions_ActionType_Recycle      = AutoHealActions_ActionType("Recycle")
)

type AutoHealActions_ActionType_STATUS string

const (
	AutoHealActions_ActionType_STATUS_CustomAction = AutoHealActions_ActionType_STATUS("CustomAction")
	AutoHealActions_ActionType_STATUS_LogEvent     = AutoHealActions_ActionType_STATUS("LogEvent")
	AutoHealActions_ActionType_STATUS_Recycle      = AutoHealActions_ActionType_STATUS("Recycle")
)

// Custom action to be executed
// when an auto heal rule is triggered.
type AutoHealCustomAction struct {
	// Exe: Executable to be run.
	Exe *string `json:"exe,omitempty"`

	// Parameters: Parameters for the executable.
	Parameters *string `json:"parameters,omitempty"`
}

var _ genruntime.ARMTransformer = &AutoHealCustomAction{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (action *AutoHealCustomAction) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if action == nil {
		return nil, nil
	}
	result := &AutoHealCustomAction_ARM{}

	// Set property "Exe":
	if action.Exe != nil {
		exe := *action.Exe
		result.Exe = &exe
	}

	// Set property "Parameters":
	if action.Parameters != nil {
		parameters := *action.Parameters
		result.Parameters = &parameters
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (action *AutoHealCustomAction) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &AutoHealCustomAction_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (action *AutoHealCustomAction) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(AutoHealCustomAction_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected AutoHealCustomAction_ARM, got %T", armInput)
	}

	// Set property "Exe":
	if typedInput.Exe != nil {
		exe := *typedInput.Exe
		action.Exe = &exe
	}

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		parameters := *typedInput.Parameters
		action.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_AutoHealCustomAction populates our AutoHealCustomAction from the provided source AutoHealCustomAction
func (action *AutoHealCustomAction) AssignProperties_From_AutoHealCustomAction(source *v20220301s.AutoHealCustomAction) error {

	// Exe
	action.Exe = genruntime.ClonePointerToString(source.Exe)

	// Parameters
	action.Parameters = genruntime.ClonePointerToString(source.Parameters)

	// No error
	return nil
}

// AssignProperties_To_AutoHealCustomAction populates the provided destination AutoHealCustomAction from our AutoHealCustomAction
func (action *AutoHealCustomAction) AssignProperties_To_AutoHealCustomAction(destination *v20220301s.AutoHealCustomAction) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Exe
	destination.Exe = genruntime.ClonePointerToString(action.Exe)

	// Parameters
	destination.Parameters = genruntime.ClonePointerToString(action.Parameters)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_AutoHealCustomAction_STATUS populates our AutoHealCustomAction from the provided source AutoHealCustomAction_STATUS
func (action *AutoHealCustomAction) Initialize_From_AutoHealCustomAction_STATUS(source *AutoHealCustomAction_STATUS) error {

	// Exe
	action.Exe = genruntime.ClonePointerToString(source.Exe)

	// Parameters
	action.Parameters = genruntime.ClonePointerToString(source.Parameters)

	// No error
	return nil
}

// Custom action to be executed
// when an auto heal rule is triggered.
type AutoHealCustomAction_STATUS struct {
	// Exe: Executable to be run.
	Exe *string `json:"exe,omitempty"`

	// Parameters: Parameters for the executable.
	Parameters *string `json:"parameters,omitempty"`
}

var _ genruntime.FromARMConverter = &AutoHealCustomAction_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (action *AutoHealCustomAction_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &AutoHealCustomAction_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (action *AutoHealCustomAction_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(AutoHealCustomAction_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected AutoHealCustomAction_STATUS_ARM, got %T", armInput)
	}

	// Set property "Exe":
	if typedInput.Exe != nil {
		exe := *typedInput.Exe
		action.Exe = &exe
	}

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		parameters := *typedInput.Parameters
		action.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_AutoHealCustomAction_STATUS populates our AutoHealCustomAction_STATUS from the provided source AutoHealCustomAction_STATUS
func (action *AutoHealCustomAction_STATUS) AssignProperties_From_AutoHealCustomAction_STATUS(source *v20220301s.AutoHealCustomAction_STATUS) error {

	// Exe
	action.Exe = genruntime.ClonePointerToString(source.Exe)

	// Parameters
	action.Parameters = genruntime.ClonePointerToString(source.Parameters)

	// No error
	return nil
}

// AssignProperties_To_AutoHealCustomAction_STATUS populates the provided destination AutoHealCustomAction_STATUS from our AutoHealCustomAction_STATUS
func (action *AutoHealCustomAction_STATUS) AssignProperties_To_AutoHealCustomAction_STATUS(destination *v20220301s.AutoHealCustomAction_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Exe
	destination.Exe = genruntime.ClonePointerToString(action.Exe)

	// Parameters
	destination.Parameters = genruntime.ClonePointerToString(action.Parameters)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Trigger based on total requests.
type RequestsBasedTrigger struct {
	// Count: Request Count.
	Count *int `json:"count,omitempty"`

	// TimeInterval: Time interval.
	TimeInterval *string `json:"timeInterval,omitempty"`
}

var _ genruntime.ARMTransformer = &RequestsBasedTrigger{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (trigger *RequestsBasedTrigger) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if trigger == nil {
		return nil, nil
	}
	result := &RequestsBasedTrigger_ARM{}

	// Set property "Count":
	if trigger.Count != nil {
		count := *trigger.Count
		result.Count = &count
	}

	// Set property "TimeInterval":
	if trigger.TimeInterval != nil {
		timeInterval := *trigger.TimeInterval
		result.TimeInterval = &timeInterval
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (trigger *RequestsBasedTrigger) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &RequestsBasedTrigger_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (trigger *RequestsBasedTrigger) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(RequestsBasedTrigger_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected RequestsBasedTrigger_ARM, got %T", armInput)
	}

	// Set property "Count":
	if typedInput.Count != nil {
		count := *typedInput.Count
		trigger.Count = &count
	}

	// Set property "TimeInterval":
	if typedInput.TimeInterval != nil {
		timeInterval := *typedInput.TimeInterval
		trigger.TimeInterval = &timeInterval
	}

	// No error
	return nil
}

// AssignProperties_From_RequestsBasedTrigger populates our RequestsBasedTrigger from the provided source RequestsBasedTrigger
func (trigger *RequestsBasedTrigger) AssignProperties_From_RequestsBasedTrigger(source *v20220301s.RequestsBasedTrigger) error {

	// Count
	trigger.Count = genruntime.ClonePointerToInt(source.Count)

	// TimeInterval
	trigger.TimeInterval = genruntime.ClonePointerToString(source.TimeInterval)

	// No error
	return nil
}

// AssignProperties_To_RequestsBasedTrigger populates the provided destination RequestsBasedTrigger from our RequestsBasedTrigger
func (trigger *RequestsBasedTrigger) AssignProperties_To_RequestsBasedTrigger(destination *v20220301s.RequestsBasedTrigger) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Count
	destination.Count = genruntime.ClonePointerToInt(trigger.Count)

	// TimeInterval
	destination.TimeInterval = genruntime.ClonePointerToString(trigger.TimeInterval)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_RequestsBasedTrigger_STATUS populates our RequestsBasedTrigger from the provided source RequestsBasedTrigger_STATUS
func (trigger *RequestsBasedTrigger) Initialize_From_RequestsBasedTrigger_STATUS(source *RequestsBasedTrigger_STATUS) error {

	// Count
	trigger.Count = genruntime.ClonePointerToInt(source.Count)

	// TimeInterval
	trigger.TimeInterval = genruntime.ClonePointerToString(source.TimeInterval)

	// No error
	return nil
}

// Trigger based on total requests.
type RequestsBasedTrigger_STATUS struct {
	// Count: Request Count.
	Count *int `json:"count,omitempty"`

	// TimeInterval: Time interval.
	TimeInterval *string `json:"timeInterval,omitempty"`
}

var _ genruntime.FromARMConverter = &RequestsBasedTrigger_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (trigger *RequestsBasedTrigger_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &RequestsBasedTrigger_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (trigger *RequestsBasedTrigger_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(RequestsBasedTrigger_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected RequestsBasedTrigger_STATUS_ARM, got %T", armInput)
	}

	// Set property "Count":
	if typedInput.Count != nil {
		count := *typedInput.Count
		trigger.Count = &count
	}

	// Set property "TimeInterval":
	if typedInput.TimeInterval != nil {
		timeInterval := *typedInput.TimeInterval
		trigger.TimeInterval = &timeInterval
	}

	// No error
	return nil
}

// AssignProperties_From_RequestsBasedTrigger_STATUS populates our RequestsBasedTrigger_STATUS from the provided source RequestsBasedTrigger_STATUS
func (trigger *RequestsBasedTrigger_STATUS) AssignProperties_From_RequestsBasedTrigger_STATUS(source *v20220301s.RequestsBasedTrigger_STATUS) error {

	// Count
	trigger.Count = genruntime.ClonePointerToInt(source.Count)

	// TimeInterval
	trigger.TimeInterval = genruntime.ClonePointerToString(source.TimeInterval)

	// No error
	return nil
}

// AssignProperties_To_RequestsBasedTrigger_STATUS populates the provided destination RequestsBasedTrigger_STATUS from our RequestsBasedTrigger_STATUS
func (trigger *RequestsBasedTrigger_STATUS) AssignProperties_To_RequestsBasedTrigger_STATUS(destination *v20220301s.RequestsBasedTrigger_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Count
	destination.Count = genruntime.ClonePointerToInt(trigger.Count)

	// TimeInterval
	destination.TimeInterval = genruntime.ClonePointerToString(trigger.TimeInterval)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Trigger based on request execution time.
type SlowRequestsBasedTrigger struct {
	// Count: Request Count.
	Count *int `json:"count,omitempty"`

	// Path: Request Path.
	Path *string `json:"path,omitempty"`

	// TimeInterval: Time interval.
	TimeInterval *string `json:"timeInterval,omitempty"`

	// TimeTaken: Time taken.
	TimeTaken *string `json:"timeTaken,omitempty"`
}

var _ genruntime.ARMTransformer = &SlowRequestsBasedTrigger{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (trigger *SlowRequestsBasedTrigger) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if trigger == nil {
		return nil, nil
	}
	result := &SlowRequestsBasedTrigger_ARM{}

	// Set property "Count":
	if trigger.Count != nil {
		count := *trigger.Count
		result.Count = &count
	}

	// Set property "Path":
	if trigger.Path != nil {
		path := *trigger.Path
		result.Path = &path
	}

	// Set property "TimeInterval":
	if trigger.TimeInterval != nil {
		timeInterval := *trigger.TimeInterval
		result.TimeInterval = &timeInterval
	}

	// Set property "TimeTaken":
	if trigger.TimeTaken != nil {
		timeTaken := *trigger.TimeTaken
		result.TimeTaken = &timeTaken
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (trigger *SlowRequestsBasedTrigger) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &SlowRequestsBasedTrigger_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (trigger *SlowRequestsBasedTrigger) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(SlowRequestsBasedTrigger_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected SlowRequestsBasedTrigger_ARM, got %T", armInput)
	}

	// Set property "Count":
	if typedInput.Count != nil {
		count := *typedInput.Count
		trigger.Count = &count
	}

	// Set property "Path":
	if typedInput.Path != nil {
		path := *typedInput.Path
		trigger.Path = &path
	}

	// Set property "TimeInterval":
	if typedInput.TimeInterval != nil {
		timeInterval := *typedInput.TimeInterval
		trigger.TimeInterval = &timeInterval
	}

	// Set property "TimeTaken":
	if typedInput.TimeTaken != nil {
		timeTaken := *typedInput.TimeTaken
		trigger.TimeTaken = &timeTaken
	}

	// No error
	return nil
}

// AssignProperties_From_SlowRequestsBasedTrigger populates our SlowRequestsBasedTrigger from the provided source SlowRequestsBasedTrigger
func (trigger *SlowRequestsBasedTrigger) AssignProperties_From_SlowRequestsBasedTrigger(source *v20220301s.SlowRequestsBasedTrigger) error {

	// Count
	trigger.Count = genruntime.ClonePointerToInt(source.Count)

	// Path
	trigger.Path = genruntime.ClonePointerToString(source.Path)

	// TimeInterval
	trigger.TimeInterval = genruntime.ClonePointerToString(source.TimeInterval)

	// TimeTaken
	trigger.TimeTaken = genruntime.ClonePointerToString(source.TimeTaken)

	// No error
	return nil
}

// AssignProperties_To_SlowRequestsBasedTrigger populates the provided destination SlowRequestsBasedTrigger from our SlowRequestsBasedTrigger
func (trigger *SlowRequestsBasedTrigger) AssignProperties_To_SlowRequestsBasedTrigger(destination *v20220301s.SlowRequestsBasedTrigger) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Count
	destination.Count = genruntime.ClonePointerToInt(trigger.Count)

	// Path
	destination.Path = genruntime.ClonePointerToString(trigger.Path)

	// TimeInterval
	destination.TimeInterval = genruntime.ClonePointerToString(trigger.TimeInterval)

	// TimeTaken
	destination.TimeTaken = genruntime.ClonePointerToString(trigger.TimeTaken)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_SlowRequestsBasedTrigger_STATUS populates our SlowRequestsBasedTrigger from the provided source SlowRequestsBasedTrigger_STATUS
func (trigger *SlowRequestsBasedTrigger) Initialize_From_SlowRequestsBasedTrigger_STATUS(source *SlowRequestsBasedTrigger_STATUS) error {

	// Count
	trigger.Count = genruntime.ClonePointerToInt(source.Count)

	// Path
	trigger.Path = genruntime.ClonePointerToString(source.Path)

	// TimeInterval
	trigger.TimeInterval = genruntime.ClonePointerToString(source.TimeInterval)

	// TimeTaken
	trigger.TimeTaken = genruntime.ClonePointerToString(source.TimeTaken)

	// No error
	return nil
}

// Trigger based on request execution time.
type SlowRequestsBasedTrigger_STATUS struct {
	// Count: Request Count.
	Count *int `json:"count,omitempty"`

	// Path: Request Path.
	Path *string `json:"path,omitempty"`

	// TimeInterval: Time interval.
	TimeInterval *string `json:"timeInterval,omitempty"`

	// TimeTaken: Time taken.
	TimeTaken *string `json:"timeTaken,omitempty"`
}

var _ genruntime.FromARMConverter = &SlowRequestsBasedTrigger_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (trigger *SlowRequestsBasedTrigger_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &SlowRequestsBasedTrigger_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (trigger *SlowRequestsBasedTrigger_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(SlowRequestsBasedTrigger_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected SlowRequestsBasedTrigger_STATUS_ARM, got %T", armInput)
	}

	// Set property "Count":
	if typedInput.Count != nil {
		count := *typedInput.Count
		trigger.Count = &count
	}

	// Set property "Path":
	if typedInput.Path != nil {
		path := *typedInput.Path
		trigger.Path = &path
	}

	// Set property "TimeInterval":
	if typedInput.TimeInterval != nil {
		timeInterval := *typedInput.TimeInterval
		trigger.TimeInterval = &timeInterval
	}

	// Set property "TimeTaken":
	if typedInput.TimeTaken != nil {
		timeTaken := *typedInput.TimeTaken
		trigger.TimeTaken = &timeTaken
	}

	// No error
	return nil
}

// AssignProperties_From_SlowRequestsBasedTrigger_STATUS populates our SlowRequestsBasedTrigger_STATUS from the provided source SlowRequestsBasedTrigger_STATUS
func (trigger *SlowRequestsBasedTrigger_STATUS) AssignProperties_From_SlowRequestsBasedTrigger_STATUS(source *v20220301s.SlowRequestsBasedTrigger_STATUS) error {

	// Count
	trigger.Count = genruntime.ClonePointerToInt(source.Count)

	// Path
	trigger.Path = genruntime.ClonePointerToString(source.Path)

	// TimeInterval
	trigger.TimeInterval = genruntime.ClonePointerToString(source.TimeInterval)

	// TimeTaken
	trigger.TimeTaken = genruntime.ClonePointerToString(source.TimeTaken)

	// No error
	return nil
}

// AssignProperties_To_SlowRequestsBasedTrigger_STATUS populates the provided destination SlowRequestsBasedTrigger_STATUS from our SlowRequestsBasedTrigger_STATUS
func (trigger *SlowRequestsBasedTrigger_STATUS) AssignProperties_To_SlowRequestsBasedTrigger_STATUS(destination *v20220301s.SlowRequestsBasedTrigger_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Count
	destination.Count = genruntime.ClonePointerToInt(trigger.Count)

	// Path
	destination.Path = genruntime.ClonePointerToString(trigger.Path)

	// TimeInterval
	destination.TimeInterval = genruntime.ClonePointerToString(trigger.TimeInterval)

	// TimeTaken
	destination.TimeTaken = genruntime.ClonePointerToString(trigger.TimeTaken)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Trigger based on status code.
type StatusCodesBasedTrigger struct {
	// Count: Request Count.
	Count *int `json:"count,omitempty"`

	// Path: Request Path
	Path *string `json:"path,omitempty"`

	// Status: HTTP status code.
	Status *int `json:"status,omitempty"`

	// SubStatus: Request Sub Status.
	SubStatus *int `json:"subStatus,omitempty"`

	// TimeInterval: Time interval.
	TimeInterval *string `json:"timeInterval,omitempty"`

	// Win32Status: Win32 error code.
	Win32Status *int `json:"win32Status,omitempty"`
}

var _ genruntime.ARMTransformer = &StatusCodesBasedTrigger{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (trigger *StatusCodesBasedTrigger) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if trigger == nil {
		return nil, nil
	}
	result := &StatusCodesBasedTrigger_ARM{}

	// Set property "Count":
	if trigger.Count != nil {
		count := *trigger.Count
		result.Count = &count
	}

	// Set property "Path":
	if trigger.Path != nil {
		path := *trigger.Path
		result.Path = &path
	}

	// Set property "Status":
	if trigger.Status != nil {
		status := *trigger.Status
		result.Status = &status
	}

	// Set property "SubStatus":
	if trigger.SubStatus != nil {
		subStatus := *trigger.SubStatus
		result.SubStatus = &subStatus
	}

	// Set property "TimeInterval":
	if trigger.TimeInterval != nil {
		timeInterval := *trigger.TimeInterval
		result.TimeInterval = &timeInterval
	}

	// Set property "Win32Status":
	if trigger.Win32Status != nil {
		win32Status := *trigger.Win32Status
		result.Win32Status = &win32Status
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (trigger *StatusCodesBasedTrigger) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &StatusCodesBasedTrigger_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (trigger *StatusCodesBasedTrigger) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(StatusCodesBasedTrigger_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected StatusCodesBasedTrigger_ARM, got %T", armInput)
	}

	// Set property "Count":
	if typedInput.Count != nil {
		count := *typedInput.Count
		trigger.Count = &count
	}

	// Set property "Path":
	if typedInput.Path != nil {
		path := *typedInput.Path
		trigger.Path = &path
	}

	// Set property "Status":
	if typedInput.Status != nil {
		status := *typedInput.Status
		trigger.Status = &status
	}

	// Set property "SubStatus":
	if typedInput.SubStatus != nil {
		subStatus := *typedInput.SubStatus
		trigger.SubStatus = &subStatus
	}

	// Set property "TimeInterval":
	if typedInput.TimeInterval != nil {
		timeInterval := *typedInput.TimeInterval
		trigger.TimeInterval = &timeInterval
	}

	// Set property "Win32Status":
	if typedInput.Win32Status != nil {
		win32Status := *typedInput.Win32Status
		trigger.Win32Status = &win32Status
	}

	// No error
	return nil
}

// AssignProperties_From_StatusCodesBasedTrigger populates our StatusCodesBasedTrigger from the provided source StatusCodesBasedTrigger
func (trigger *StatusCodesBasedTrigger) AssignProperties_From_StatusCodesBasedTrigger(source *v20220301s.StatusCodesBasedTrigger) error {

	// Count
	trigger.Count = genruntime.ClonePointerToInt(source.Count)

	// Path
	trigger.Path = genruntime.ClonePointerToString(source.Path)

	// Status
	trigger.Status = genruntime.ClonePointerToInt(source.Status)

	// SubStatus
	trigger.SubStatus = genruntime.ClonePointerToInt(source.SubStatus)

	// TimeInterval
	trigger.TimeInterval = genruntime.ClonePointerToString(source.TimeInterval)

	// Win32Status
	trigger.Win32Status = genruntime.ClonePointerToInt(source.Win32Status)

	// No error
	return nil
}

// AssignProperties_To_StatusCodesBasedTrigger populates the provided destination StatusCodesBasedTrigger from our StatusCodesBasedTrigger
func (trigger *StatusCodesBasedTrigger) AssignProperties_To_StatusCodesBasedTrigger(destination *v20220301s.StatusCodesBasedTrigger) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Count
	destination.Count = genruntime.ClonePointerToInt(trigger.Count)

	// Path
	destination.Path = genruntime.ClonePointerToString(trigger.Path)

	// Status
	destination.Status = genruntime.ClonePointerToInt(trigger.Status)

	// SubStatus
	destination.SubStatus = genruntime.ClonePointerToInt(trigger.SubStatus)

	// TimeInterval
	destination.TimeInterval = genruntime.ClonePointerToString(trigger.TimeInterval)

	// Win32Status
	destination.Win32Status = genruntime.ClonePointerToInt(trigger.Win32Status)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_StatusCodesBasedTrigger_STATUS populates our StatusCodesBasedTrigger from the provided source StatusCodesBasedTrigger_STATUS
func (trigger *StatusCodesBasedTrigger) Initialize_From_StatusCodesBasedTrigger_STATUS(source *StatusCodesBasedTrigger_STATUS) error {

	// Count
	trigger.Count = genruntime.ClonePointerToInt(source.Count)

	// Path
	trigger.Path = genruntime.ClonePointerToString(source.Path)

	// Status
	trigger.Status = genruntime.ClonePointerToInt(source.Status)

	// SubStatus
	trigger.SubStatus = genruntime.ClonePointerToInt(source.SubStatus)

	// TimeInterval
	trigger.TimeInterval = genruntime.ClonePointerToString(source.TimeInterval)

	// Win32Status
	trigger.Win32Status = genruntime.ClonePointerToInt(source.Win32Status)

	// No error
	return nil
}

// Trigger based on status code.
type StatusCodesBasedTrigger_STATUS struct {
	// Count: Request Count.
	Count *int `json:"count,omitempty"`

	// Path: Request Path
	Path *string `json:"path,omitempty"`

	// Status: HTTP status code.
	Status *int `json:"status,omitempty"`

	// SubStatus: Request Sub Status.
	SubStatus *int `json:"subStatus,omitempty"`

	// TimeInterval: Time interval.
	TimeInterval *string `json:"timeInterval,omitempty"`

	// Win32Status: Win32 error code.
	Win32Status *int `json:"win32Status,omitempty"`
}

var _ genruntime.FromARMConverter = &StatusCodesBasedTrigger_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (trigger *StatusCodesBasedTrigger_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &StatusCodesBasedTrigger_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (trigger *StatusCodesBasedTrigger_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(StatusCodesBasedTrigger_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected StatusCodesBasedTrigger_STATUS_ARM, got %T", armInput)
	}

	// Set property "Count":
	if typedInput.Count != nil {
		count := *typedInput.Count
		trigger.Count = &count
	}

	// Set property "Path":
	if typedInput.Path != nil {
		path := *typedInput.Path
		trigger.Path = &path
	}

	// Set property "Status":
	if typedInput.Status != nil {
		status := *typedInput.Status
		trigger.Status = &status
	}

	// Set property "SubStatus":
	if typedInput.SubStatus != nil {
		subStatus := *typedInput.SubStatus
		trigger.SubStatus = &subStatus
	}

	// Set property "TimeInterval":
	if typedInput.TimeInterval != nil {
		timeInterval := *typedInput.TimeInterval
		trigger.TimeInterval = &timeInterval
	}

	// Set property "Win32Status":
	if typedInput.Win32Status != nil {
		win32Status := *typedInput.Win32Status
		trigger.Win32Status = &win32Status
	}

	// No error
	return nil
}

// AssignProperties_From_StatusCodesBasedTrigger_STATUS populates our StatusCodesBasedTrigger_STATUS from the provided source StatusCodesBasedTrigger_STATUS
func (trigger *StatusCodesBasedTrigger_STATUS) AssignProperties_From_StatusCodesBasedTrigger_STATUS(source *v20220301s.StatusCodesBasedTrigger_STATUS) error {

	// Count
	trigger.Count = genruntime.ClonePointerToInt(source.Count)

	// Path
	trigger.Path = genruntime.ClonePointerToString(source.Path)

	// Status
	trigger.Status = genruntime.ClonePointerToInt(source.Status)

	// SubStatus
	trigger.SubStatus = genruntime.ClonePointerToInt(source.SubStatus)

	// TimeInterval
	trigger.TimeInterval = genruntime.ClonePointerToString(source.TimeInterval)

	// Win32Status
	trigger.Win32Status = genruntime.ClonePointerToInt(source.Win32Status)

	// No error
	return nil
}

// AssignProperties_To_StatusCodesBasedTrigger_STATUS populates the provided destination StatusCodesBasedTrigger_STATUS from our StatusCodesBasedTrigger_STATUS
func (trigger *StatusCodesBasedTrigger_STATUS) AssignProperties_To_StatusCodesBasedTrigger_STATUS(destination *v20220301s.StatusCodesBasedTrigger_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Count
	destination.Count = genruntime.ClonePointerToInt(trigger.Count)

	// Path
	destination.Path = genruntime.ClonePointerToString(trigger.Path)

	// Status
	destination.Status = genruntime.ClonePointerToInt(trigger.Status)

	// SubStatus
	destination.SubStatus = genruntime.ClonePointerToInt(trigger.SubStatus)

	// TimeInterval
	destination.TimeInterval = genruntime.ClonePointerToString(trigger.TimeInterval)

	// Win32Status
	destination.Win32Status = genruntime.ClonePointerToInt(trigger.Win32Status)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Trigger based on range of status codes.
type StatusCodesRangeBasedTrigger struct {
	// Count: Request Count.
	Count *int    `json:"count,omitempty"`
	Path  *string `json:"path,omitempty"`

	// StatusCodes: HTTP status code.
	StatusCodes *string `json:"statusCodes,omitempty"`

	// TimeInterval: Time interval.
	TimeInterval *string `json:"timeInterval,omitempty"`
}

var _ genruntime.ARMTransformer = &StatusCodesRangeBasedTrigger{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (trigger *StatusCodesRangeBasedTrigger) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if trigger == nil {
		return nil, nil
	}
	result := &StatusCodesRangeBasedTrigger_ARM{}

	// Set property "Count":
	if trigger.Count != nil {
		count := *trigger.Count
		result.Count = &count
	}

	// Set property "Path":
	if trigger.Path != nil {
		path := *trigger.Path
		result.Path = &path
	}

	// Set property "StatusCodes":
	if trigger.StatusCodes != nil {
		statusCodes := *trigger.StatusCodes
		result.StatusCodes = &statusCodes
	}

	// Set property "TimeInterval":
	if trigger.TimeInterval != nil {
		timeInterval := *trigger.TimeInterval
		result.TimeInterval = &timeInterval
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (trigger *StatusCodesRangeBasedTrigger) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &StatusCodesRangeBasedTrigger_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (trigger *StatusCodesRangeBasedTrigger) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(StatusCodesRangeBasedTrigger_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected StatusCodesRangeBasedTrigger_ARM, got %T", armInput)
	}

	// Set property "Count":
	if typedInput.Count != nil {
		count := *typedInput.Count
		trigger.Count = &count
	}

	// Set property "Path":
	if typedInput.Path != nil {
		path := *typedInput.Path
		trigger.Path = &path
	}

	// Set property "StatusCodes":
	if typedInput.StatusCodes != nil {
		statusCodes := *typedInput.StatusCodes
		trigger.StatusCodes = &statusCodes
	}

	// Set property "TimeInterval":
	if typedInput.TimeInterval != nil {
		timeInterval := *typedInput.TimeInterval
		trigger.TimeInterval = &timeInterval
	}

	// No error
	return nil
}

// AssignProperties_From_StatusCodesRangeBasedTrigger populates our StatusCodesRangeBasedTrigger from the provided source StatusCodesRangeBasedTrigger
func (trigger *StatusCodesRangeBasedTrigger) AssignProperties_From_StatusCodesRangeBasedTrigger(source *v20220301s.StatusCodesRangeBasedTrigger) error {

	// Count
	trigger.Count = genruntime.ClonePointerToInt(source.Count)

	// Path
	trigger.Path = genruntime.ClonePointerToString(source.Path)

	// StatusCodes
	trigger.StatusCodes = genruntime.ClonePointerToString(source.StatusCodes)

	// TimeInterval
	trigger.TimeInterval = genruntime.ClonePointerToString(source.TimeInterval)

	// No error
	return nil
}

// AssignProperties_To_StatusCodesRangeBasedTrigger populates the provided destination StatusCodesRangeBasedTrigger from our StatusCodesRangeBasedTrigger
func (trigger *StatusCodesRangeBasedTrigger) AssignProperties_To_StatusCodesRangeBasedTrigger(destination *v20220301s.StatusCodesRangeBasedTrigger) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Count
	destination.Count = genruntime.ClonePointerToInt(trigger.Count)

	// Path
	destination.Path = genruntime.ClonePointerToString(trigger.Path)

	// StatusCodes
	destination.StatusCodes = genruntime.ClonePointerToString(trigger.StatusCodes)

	// TimeInterval
	destination.TimeInterval = genruntime.ClonePointerToString(trigger.TimeInterval)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_StatusCodesRangeBasedTrigger_STATUS populates our StatusCodesRangeBasedTrigger from the provided source StatusCodesRangeBasedTrigger_STATUS
func (trigger *StatusCodesRangeBasedTrigger) Initialize_From_StatusCodesRangeBasedTrigger_STATUS(source *StatusCodesRangeBasedTrigger_STATUS) error {

	// Count
	trigger.Count = genruntime.ClonePointerToInt(source.Count)

	// Path
	trigger.Path = genruntime.ClonePointerToString(source.Path)

	// StatusCodes
	trigger.StatusCodes = genruntime.ClonePointerToString(source.StatusCodes)

	// TimeInterval
	trigger.TimeInterval = genruntime.ClonePointerToString(source.TimeInterval)

	// No error
	return nil
}

// Trigger based on range of status codes.
type StatusCodesRangeBasedTrigger_STATUS struct {
	// Count: Request Count.
	Count *int    `json:"count,omitempty"`
	Path  *string `json:"path,omitempty"`

	// StatusCodes: HTTP status code.
	StatusCodes *string `json:"statusCodes,omitempty"`

	// TimeInterval: Time interval.
	TimeInterval *string `json:"timeInterval,omitempty"`
}

var _ genruntime.FromARMConverter = &StatusCodesRangeBasedTrigger_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (trigger *StatusCodesRangeBasedTrigger_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &StatusCodesRangeBasedTrigger_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (trigger *StatusCodesRangeBasedTrigger_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(StatusCodesRangeBasedTrigger_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected StatusCodesRangeBasedTrigger_STATUS_ARM, got %T", armInput)
	}

	// Set property "Count":
	if typedInput.Count != nil {
		count := *typedInput.Count
		trigger.Count = &count
	}

	// Set property "Path":
	if typedInput.Path != nil {
		path := *typedInput.Path
		trigger.Path = &path
	}

	// Set property "StatusCodes":
	if typedInput.StatusCodes != nil {
		statusCodes := *typedInput.StatusCodes
		trigger.StatusCodes = &statusCodes
	}

	// Set property "TimeInterval":
	if typedInput.TimeInterval != nil {
		timeInterval := *typedInput.TimeInterval
		trigger.TimeInterval = &timeInterval
	}

	// No error
	return nil
}

// AssignProperties_From_StatusCodesRangeBasedTrigger_STATUS populates our StatusCodesRangeBasedTrigger_STATUS from the provided source StatusCodesRangeBasedTrigger_STATUS
func (trigger *StatusCodesRangeBasedTrigger_STATUS) AssignProperties_From_StatusCodesRangeBasedTrigger_STATUS(source *v20220301s.StatusCodesRangeBasedTrigger_STATUS) error {

	// Count
	trigger.Count = genruntime.ClonePointerToInt(source.Count)

	// Path
	trigger.Path = genruntime.ClonePointerToString(source.Path)

	// StatusCodes
	trigger.StatusCodes = genruntime.ClonePointerToString(source.StatusCodes)

	// TimeInterval
	trigger.TimeInterval = genruntime.ClonePointerToString(source.TimeInterval)

	// No error
	return nil
}

// AssignProperties_To_StatusCodesRangeBasedTrigger_STATUS populates the provided destination StatusCodesRangeBasedTrigger_STATUS from our StatusCodesRangeBasedTrigger_STATUS
func (trigger *StatusCodesRangeBasedTrigger_STATUS) AssignProperties_To_StatusCodesRangeBasedTrigger_STATUS(destination *v20220301s.StatusCodesRangeBasedTrigger_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Count
	destination.Count = genruntime.ClonePointerToInt(trigger.Count)

	// Path
	destination.Path = genruntime.ClonePointerToString(trigger.Path)

	// StatusCodes
	destination.StatusCodes = genruntime.ClonePointerToString(trigger.StatusCodes)

	// TimeInterval
	destination.TimeInterval = genruntime.ClonePointerToString(trigger.TimeInterval)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

func init() {
	SchemeBuilder.Register(&Site{}, &SiteList{})
}
