//go:build !ignore_autogenerated

/*
Copyright (c) Microsoft Corporation.
Licensed under the MIT license.
*/

// Code generated by controller-gen. DO NOT EDIT.

package storage

import (
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/core"
	runtime "k8s.io/apimachinery/pkg/runtime"
)

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ApiErrorBase_STATUS) DeepCopyInto(out *ApiErrorBase_STATUS) {
	*out = *in
	if in.Code != nil {
		in, out := &in.Code, &out.Code
		*out = new(string)
		**out = **in
	}
	if in.Message != nil {
		in, out := &in.Message, &out.Message
		*out = new(string)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Target != nil {
		in, out := &in.Target, &out.Target
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ApiErrorBase_STATUS.
func (in *ApiErrorBase_STATUS) DeepCopy() *ApiErrorBase_STATUS {
	if in == nil {
		return nil
	}
	out := new(ApiErrorBase_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ApiError_STATUS) DeepCopyInto(out *ApiError_STATUS) {
	*out = *in
	if in.Code != nil {
		in, out := &in.Code, &out.Code
		*out = new(string)
		**out = **in
	}
	if in.Details != nil {
		in, out := &in.Details, &out.Details
		*out = make([]ApiErrorBase_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Innererror != nil {
		in, out := &in.Innererror, &out.Innererror
		*out = new(InnerError_STATUS)
		(*in).DeepCopyInto(*out)
	}
	if in.Message != nil {
		in, out := &in.Message, &out.Message
		*out = new(string)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Target != nil {
		in, out := &in.Target, &out.Target
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ApiError_STATUS.
func (in *ApiError_STATUS) DeepCopy() *ApiError_STATUS {
	if in == nil {
		return nil
	}
	out := new(ApiError_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CopyCompletionError) DeepCopyInto(out *CopyCompletionError) {
	*out = *in
	if in.ErrorCode != nil {
		in, out := &in.ErrorCode, &out.ErrorCode
		*out = new(string)
		**out = **in
	}
	if in.ErrorMessage != nil {
		in, out := &in.ErrorMessage, &out.ErrorMessage
		*out = new(string)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CopyCompletionError.
func (in *CopyCompletionError) DeepCopy() *CopyCompletionError {
	if in == nil {
		return nil
	}
	out := new(CopyCompletionError)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CopyCompletionError_STATUS) DeepCopyInto(out *CopyCompletionError_STATUS) {
	*out = *in
	if in.ErrorCode != nil {
		in, out := &in.ErrorCode, &out.ErrorCode
		*out = new(string)
		**out = **in
	}
	if in.ErrorMessage != nil {
		in, out := &in.ErrorMessage, &out.ErrorMessage
		*out = new(string)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CopyCompletionError_STATUS.
func (in *CopyCompletionError_STATUS) DeepCopy() *CopyCompletionError_STATUS {
	if in == nil {
		return nil
	}
	out := new(CopyCompletionError_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CreationData) DeepCopyInto(out *CreationData) {
	*out = *in
	if in.CreateOption != nil {
		in, out := &in.CreateOption, &out.CreateOption
		*out = new(string)
		**out = **in
	}
	if in.ElasticSanResourceReference != nil {
		in, out := &in.ElasticSanResourceReference, &out.ElasticSanResourceReference
		*out = new(genruntime.ResourceReference)
		**out = **in
	}
	if in.GalleryImageReference != nil {
		in, out := &in.GalleryImageReference, &out.GalleryImageReference
		*out = new(ImageDiskReference)
		(*in).DeepCopyInto(*out)
	}
	if in.ImageReference != nil {
		in, out := &in.ImageReference, &out.ImageReference
		*out = new(ImageDiskReference)
		(*in).DeepCopyInto(*out)
	}
	if in.LogicalSectorSize != nil {
		in, out := &in.LogicalSectorSize, &out.LogicalSectorSize
		*out = new(int)
		**out = **in
	}
	if in.PerformancePlus != nil {
		in, out := &in.PerformancePlus, &out.PerformancePlus
		*out = new(bool)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.ProvisionedBandwidthCopySpeed != nil {
		in, out := &in.ProvisionedBandwidthCopySpeed, &out.ProvisionedBandwidthCopySpeed
		*out = new(string)
		**out = **in
	}
	if in.SecurityDataUri != nil {
		in, out := &in.SecurityDataUri, &out.SecurityDataUri
		*out = new(string)
		**out = **in
	}
	if in.SourceResourceReference != nil {
		in, out := &in.SourceResourceReference, &out.SourceResourceReference
		*out = new(genruntime.ResourceReference)
		**out = **in
	}
	if in.SourceUri != nil {
		in, out := &in.SourceUri, &out.SourceUri
		*out = new(string)
		**out = **in
	}
	if in.StorageAccountId != nil {
		in, out := &in.StorageAccountId, &out.StorageAccountId
		*out = new(string)
		**out = **in
	}
	if in.UploadSizeBytes != nil {
		in, out := &in.UploadSizeBytes, &out.UploadSizeBytes
		*out = new(int)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CreationData.
func (in *CreationData) DeepCopy() *CreationData {
	if in == nil {
		return nil
	}
	out := new(CreationData)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CreationData_STATUS) DeepCopyInto(out *CreationData_STATUS) {
	*out = *in
	if in.CreateOption != nil {
		in, out := &in.CreateOption, &out.CreateOption
		*out = new(string)
		**out = **in
	}
	if in.ElasticSanResourceId != nil {
		in, out := &in.ElasticSanResourceId, &out.ElasticSanResourceId
		*out = new(string)
		**out = **in
	}
	if in.GalleryImageReference != nil {
		in, out := &in.GalleryImageReference, &out.GalleryImageReference
		*out = new(ImageDiskReference_STATUS)
		(*in).DeepCopyInto(*out)
	}
	if in.ImageReference != nil {
		in, out := &in.ImageReference, &out.ImageReference
		*out = new(ImageDiskReference_STATUS)
		(*in).DeepCopyInto(*out)
	}
	if in.LogicalSectorSize != nil {
		in, out := &in.LogicalSectorSize, &out.LogicalSectorSize
		*out = new(int)
		**out = **in
	}
	if in.PerformancePlus != nil {
		in, out := &in.PerformancePlus, &out.PerformancePlus
		*out = new(bool)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.ProvisionedBandwidthCopySpeed != nil {
		in, out := &in.ProvisionedBandwidthCopySpeed, &out.ProvisionedBandwidthCopySpeed
		*out = new(string)
		**out = **in
	}
	if in.SecurityDataUri != nil {
		in, out := &in.SecurityDataUri, &out.SecurityDataUri
		*out = new(string)
		**out = **in
	}
	if in.SourceResourceId != nil {
		in, out := &in.SourceResourceId, &out.SourceResourceId
		*out = new(string)
		**out = **in
	}
	if in.SourceUniqueId != nil {
		in, out := &in.SourceUniqueId, &out.SourceUniqueId
		*out = new(string)
		**out = **in
	}
	if in.SourceUri != nil {
		in, out := &in.SourceUri, &out.SourceUri
		*out = new(string)
		**out = **in
	}
	if in.StorageAccountId != nil {
		in, out := &in.StorageAccountId, &out.StorageAccountId
		*out = new(string)
		**out = **in
	}
	if in.UploadSizeBytes != nil {
		in, out := &in.UploadSizeBytes, &out.UploadSizeBytes
		*out = new(int)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CreationData_STATUS.
func (in *CreationData_STATUS) DeepCopy() *CreationData_STATUS {
	if in == nil {
		return nil
	}
	out := new(CreationData_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Disk) DeepCopyInto(out *Disk) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Disk.
func (in *Disk) DeepCopy() *Disk {
	if in == nil {
		return nil
	}
	out := new(Disk)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *Disk) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DiskAccess) DeepCopyInto(out *DiskAccess) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DiskAccess.
func (in *DiskAccess) DeepCopy() *DiskAccess {
	if in == nil {
		return nil
	}
	out := new(DiskAccess)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *DiskAccess) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DiskAccessList) DeepCopyInto(out *DiskAccessList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]DiskAccess, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DiskAccessList.
func (in *DiskAccessList) DeepCopy() *DiskAccessList {
	if in == nil {
		return nil
	}
	out := new(DiskAccessList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *DiskAccessList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DiskAccessOperatorSpec) DeepCopyInto(out *DiskAccessOperatorSpec) {
	*out = *in
	if in.ConfigMapExpressions != nil {
		in, out := &in.ConfigMapExpressions, &out.ConfigMapExpressions
		*out = make([]*core.DestinationExpression, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(core.DestinationExpression)
				**out = **in
			}
		}
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.SecretExpressions != nil {
		in, out := &in.SecretExpressions, &out.SecretExpressions
		*out = make([]*core.DestinationExpression, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(core.DestinationExpression)
				**out = **in
			}
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DiskAccessOperatorSpec.
func (in *DiskAccessOperatorSpec) DeepCopy() *DiskAccessOperatorSpec {
	if in == nil {
		return nil
	}
	out := new(DiskAccessOperatorSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DiskAccess_STATUS) DeepCopyInto(out *DiskAccess_STATUS) {
	*out = *in
	if in.Conditions != nil {
		in, out := &in.Conditions, &out.Conditions
		*out = make([]conditions.Condition, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.ExtendedLocation != nil {
		in, out := &in.ExtendedLocation, &out.ExtendedLocation
		*out = new(ExtendedLocation_STATUS)
		(*in).DeepCopyInto(*out)
	}
	if in.Id != nil {
		in, out := &in.Id, &out.Id
		*out = new(string)
		**out = **in
	}
	if in.Location != nil {
		in, out := &in.Location, &out.Location
		*out = new(string)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PrivateEndpointConnections != nil {
		in, out := &in.PrivateEndpointConnections, &out.PrivateEndpointConnections
		*out = make([]PrivateEndpointConnection_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.ProvisioningState != nil {
		in, out := &in.ProvisioningState, &out.ProvisioningState
		*out = new(string)
		**out = **in
	}
	if in.Tags != nil {
		in, out := &in.Tags, &out.Tags
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.TimeCreated != nil {
		in, out := &in.TimeCreated, &out.TimeCreated
		*out = new(string)
		**out = **in
	}
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DiskAccess_STATUS.
func (in *DiskAccess_STATUS) DeepCopy() *DiskAccess_STATUS {
	if in == nil {
		return nil
	}
	out := new(DiskAccess_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DiskAccess_Spec) DeepCopyInto(out *DiskAccess_Spec) {
	*out = *in
	if in.ExtendedLocation != nil {
		in, out := &in.ExtendedLocation, &out.ExtendedLocation
		*out = new(ExtendedLocation)
		(*in).DeepCopyInto(*out)
	}
	if in.Location != nil {
		in, out := &in.Location, &out.Location
		*out = new(string)
		**out = **in
	}
	if in.OperatorSpec != nil {
		in, out := &in.OperatorSpec, &out.OperatorSpec
		*out = new(DiskAccessOperatorSpec)
		(*in).DeepCopyInto(*out)
	}
	if in.Owner != nil {
		in, out := &in.Owner, &out.Owner
		*out = new(genruntime.KnownResourceReference)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Tags != nil {
		in, out := &in.Tags, &out.Tags
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DiskAccess_Spec.
func (in *DiskAccess_Spec) DeepCopy() *DiskAccess_Spec {
	if in == nil {
		return nil
	}
	out := new(DiskAccess_Spec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DiskEncryptionSet) DeepCopyInto(out *DiskEncryptionSet) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DiskEncryptionSet.
func (in *DiskEncryptionSet) DeepCopy() *DiskEncryptionSet {
	if in == nil {
		return nil
	}
	out := new(DiskEncryptionSet)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *DiskEncryptionSet) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DiskEncryptionSetList) DeepCopyInto(out *DiskEncryptionSetList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]DiskEncryptionSet, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DiskEncryptionSetList.
func (in *DiskEncryptionSetList) DeepCopy() *DiskEncryptionSetList {
	if in == nil {
		return nil
	}
	out := new(DiskEncryptionSetList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *DiskEncryptionSetList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DiskEncryptionSetOperatorSpec) DeepCopyInto(out *DiskEncryptionSetOperatorSpec) {
	*out = *in
	if in.ConfigMapExpressions != nil {
		in, out := &in.ConfigMapExpressions, &out.ConfigMapExpressions
		*out = make([]*core.DestinationExpression, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(core.DestinationExpression)
				**out = **in
			}
		}
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.SecretExpressions != nil {
		in, out := &in.SecretExpressions, &out.SecretExpressions
		*out = make([]*core.DestinationExpression, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(core.DestinationExpression)
				**out = **in
			}
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DiskEncryptionSetOperatorSpec.
func (in *DiskEncryptionSetOperatorSpec) DeepCopy() *DiskEncryptionSetOperatorSpec {
	if in == nil {
		return nil
	}
	out := new(DiskEncryptionSetOperatorSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DiskEncryptionSet_STATUS) DeepCopyInto(out *DiskEncryptionSet_STATUS) {
	*out = *in
	if in.ActiveKey != nil {
		in, out := &in.ActiveKey, &out.ActiveKey
		*out = new(KeyForDiskEncryptionSet_STATUS)
		(*in).DeepCopyInto(*out)
	}
	if in.AutoKeyRotationError != nil {
		in, out := &in.AutoKeyRotationError, &out.AutoKeyRotationError
		*out = new(ApiError_STATUS)
		(*in).DeepCopyInto(*out)
	}
	if in.Conditions != nil {
		in, out := &in.Conditions, &out.Conditions
		*out = make([]conditions.Condition, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.EncryptionType != nil {
		in, out := &in.EncryptionType, &out.EncryptionType
		*out = new(string)
		**out = **in
	}
	if in.FederatedClientId != nil {
		in, out := &in.FederatedClientId, &out.FederatedClientId
		*out = new(string)
		**out = **in
	}
	if in.Id != nil {
		in, out := &in.Id, &out.Id
		*out = new(string)
		**out = **in
	}
	if in.Identity != nil {
		in, out := &in.Identity, &out.Identity
		*out = new(EncryptionSetIdentity_STATUS)
		(*in).DeepCopyInto(*out)
	}
	if in.LastKeyRotationTimestamp != nil {
		in, out := &in.LastKeyRotationTimestamp, &out.LastKeyRotationTimestamp
		*out = new(string)
		**out = **in
	}
	if in.Location != nil {
		in, out := &in.Location, &out.Location
		*out = new(string)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PreviousKeys != nil {
		in, out := &in.PreviousKeys, &out.PreviousKeys
		*out = make([]KeyForDiskEncryptionSet_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.ProvisioningState != nil {
		in, out := &in.ProvisioningState, &out.ProvisioningState
		*out = new(string)
		**out = **in
	}
	if in.RotationToLatestKeyVersionEnabled != nil {
		in, out := &in.RotationToLatestKeyVersionEnabled, &out.RotationToLatestKeyVersionEnabled
		*out = new(bool)
		**out = **in
	}
	if in.Tags != nil {
		in, out := &in.Tags, &out.Tags
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DiskEncryptionSet_STATUS.
func (in *DiskEncryptionSet_STATUS) DeepCopy() *DiskEncryptionSet_STATUS {
	if in == nil {
		return nil
	}
	out := new(DiskEncryptionSet_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DiskEncryptionSet_Spec) DeepCopyInto(out *DiskEncryptionSet_Spec) {
	*out = *in
	if in.ActiveKey != nil {
		in, out := &in.ActiveKey, &out.ActiveKey
		*out = new(KeyForDiskEncryptionSet)
		(*in).DeepCopyInto(*out)
	}
	if in.EncryptionType != nil {
		in, out := &in.EncryptionType, &out.EncryptionType
		*out = new(string)
		**out = **in
	}
	if in.FederatedClientId != nil {
		in, out := &in.FederatedClientId, &out.FederatedClientId
		*out = new(string)
		**out = **in
	}
	if in.FederatedClientIdFromConfig != nil {
		in, out := &in.FederatedClientIdFromConfig, &out.FederatedClientIdFromConfig
		*out = new(genruntime.ConfigMapReference)
		**out = **in
	}
	if in.Identity != nil {
		in, out := &in.Identity, &out.Identity
		*out = new(EncryptionSetIdentity)
		(*in).DeepCopyInto(*out)
	}
	if in.Location != nil {
		in, out := &in.Location, &out.Location
		*out = new(string)
		**out = **in
	}
	if in.OperatorSpec != nil {
		in, out := &in.OperatorSpec, &out.OperatorSpec
		*out = new(DiskEncryptionSetOperatorSpec)
		(*in).DeepCopyInto(*out)
	}
	if in.Owner != nil {
		in, out := &in.Owner, &out.Owner
		*out = new(genruntime.KnownResourceReference)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.RotationToLatestKeyVersionEnabled != nil {
		in, out := &in.RotationToLatestKeyVersionEnabled, &out.RotationToLatestKeyVersionEnabled
		*out = new(bool)
		**out = **in
	}
	if in.Tags != nil {
		in, out := &in.Tags, &out.Tags
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DiskEncryptionSet_Spec.
func (in *DiskEncryptionSet_Spec) DeepCopy() *DiskEncryptionSet_Spec {
	if in == nil {
		return nil
	}
	out := new(DiskEncryptionSet_Spec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DiskList) DeepCopyInto(out *DiskList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]Disk, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DiskList.
func (in *DiskList) DeepCopy() *DiskList {
	if in == nil {
		return nil
	}
	out := new(DiskList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *DiskList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DiskOperatorSpec) DeepCopyInto(out *DiskOperatorSpec) {
	*out = *in
	if in.ConfigMapExpressions != nil {
		in, out := &in.ConfigMapExpressions, &out.ConfigMapExpressions
		*out = make([]*core.DestinationExpression, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(core.DestinationExpression)
				**out = **in
			}
		}
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.SecretExpressions != nil {
		in, out := &in.SecretExpressions, &out.SecretExpressions
		*out = make([]*core.DestinationExpression, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(core.DestinationExpression)
				**out = **in
			}
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DiskOperatorSpec.
func (in *DiskOperatorSpec) DeepCopy() *DiskOperatorSpec {
	if in == nil {
		return nil
	}
	out := new(DiskOperatorSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DiskSecurityProfile) DeepCopyInto(out *DiskSecurityProfile) {
	*out = *in
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.SecureVMDiskEncryptionSetReference != nil {
		in, out := &in.SecureVMDiskEncryptionSetReference, &out.SecureVMDiskEncryptionSetReference
		*out = new(genruntime.ResourceReference)
		**out = **in
	}
	if in.SecurityType != nil {
		in, out := &in.SecurityType, &out.SecurityType
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DiskSecurityProfile.
func (in *DiskSecurityProfile) DeepCopy() *DiskSecurityProfile {
	if in == nil {
		return nil
	}
	out := new(DiskSecurityProfile)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DiskSecurityProfile_STATUS) DeepCopyInto(out *DiskSecurityProfile_STATUS) {
	*out = *in
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.SecureVMDiskEncryptionSetId != nil {
		in, out := &in.SecureVMDiskEncryptionSetId, &out.SecureVMDiskEncryptionSetId
		*out = new(string)
		**out = **in
	}
	if in.SecurityType != nil {
		in, out := &in.SecurityType, &out.SecurityType
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DiskSecurityProfile_STATUS.
func (in *DiskSecurityProfile_STATUS) DeepCopy() *DiskSecurityProfile_STATUS {
	if in == nil {
		return nil
	}
	out := new(DiskSecurityProfile_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DiskSku) DeepCopyInto(out *DiskSku) {
	*out = *in
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DiskSku.
func (in *DiskSku) DeepCopy() *DiskSku {
	if in == nil {
		return nil
	}
	out := new(DiskSku)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DiskSku_STATUS) DeepCopyInto(out *DiskSku_STATUS) {
	*out = *in
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Tier != nil {
		in, out := &in.Tier, &out.Tier
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DiskSku_STATUS.
func (in *DiskSku_STATUS) DeepCopy() *DiskSku_STATUS {
	if in == nil {
		return nil
	}
	out := new(DiskSku_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Disk_STATUS) DeepCopyInto(out *Disk_STATUS) {
	*out = *in
	if in.BurstingEnabled != nil {
		in, out := &in.BurstingEnabled, &out.BurstingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BurstingEnabledTime != nil {
		in, out := &in.BurstingEnabledTime, &out.BurstingEnabledTime
		*out = new(string)
		**out = **in
	}
	if in.CompletionPercent != nil {
		in, out := &in.CompletionPercent, &out.CompletionPercent
		*out = new(float64)
		**out = **in
	}
	if in.Conditions != nil {
		in, out := &in.Conditions, &out.Conditions
		*out = make([]conditions.Condition, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.CreationData != nil {
		in, out := &in.CreationData, &out.CreationData
		*out = new(CreationData_STATUS)
		(*in).DeepCopyInto(*out)
	}
	if in.DataAccessAuthMode != nil {
		in, out := &in.DataAccessAuthMode, &out.DataAccessAuthMode
		*out = new(string)
		**out = **in
	}
	if in.DiskAccessId != nil {
		in, out := &in.DiskAccessId, &out.DiskAccessId
		*out = new(string)
		**out = **in
	}
	if in.DiskIOPSReadOnly != nil {
		in, out := &in.DiskIOPSReadOnly, &out.DiskIOPSReadOnly
		*out = new(int)
		**out = **in
	}
	if in.DiskIOPSReadWrite != nil {
		in, out := &in.DiskIOPSReadWrite, &out.DiskIOPSReadWrite
		*out = new(int)
		**out = **in
	}
	if in.DiskMBpsReadOnly != nil {
		in, out := &in.DiskMBpsReadOnly, &out.DiskMBpsReadOnly
		*out = new(int)
		**out = **in
	}
	if in.DiskMBpsReadWrite != nil {
		in, out := &in.DiskMBpsReadWrite, &out.DiskMBpsReadWrite
		*out = new(int)
		**out = **in
	}
	if in.DiskSizeBytes != nil {
		in, out := &in.DiskSizeBytes, &out.DiskSizeBytes
		*out = new(int)
		**out = **in
	}
	if in.DiskSizeGB != nil {
		in, out := &in.DiskSizeGB, &out.DiskSizeGB
		*out = new(int)
		**out = **in
	}
	if in.DiskState != nil {
		in, out := &in.DiskState, &out.DiskState
		*out = new(string)
		**out = **in
	}
	if in.Encryption != nil {
		in, out := &in.Encryption, &out.Encryption
		*out = new(Encryption_STATUS)
		(*in).DeepCopyInto(*out)
	}
	if in.EncryptionSettingsCollection != nil {
		in, out := &in.EncryptionSettingsCollection, &out.EncryptionSettingsCollection
		*out = new(EncryptionSettingsCollection_STATUS)
		(*in).DeepCopyInto(*out)
	}
	if in.ExtendedLocation != nil {
		in, out := &in.ExtendedLocation, &out.ExtendedLocation
		*out = new(ExtendedLocation_STATUS)
		(*in).DeepCopyInto(*out)
	}
	if in.HyperVGeneration != nil {
		in, out := &in.HyperVGeneration, &out.HyperVGeneration
		*out = new(string)
		**out = **in
	}
	if in.Id != nil {
		in, out := &in.Id, &out.Id
		*out = new(string)
		**out = **in
	}
	if in.LastOwnershipUpdateTime != nil {
		in, out := &in.LastOwnershipUpdateTime, &out.LastOwnershipUpdateTime
		*out = new(string)
		**out = **in
	}
	if in.Location != nil {
		in, out := &in.Location, &out.Location
		*out = new(string)
		**out = **in
	}
	if in.ManagedBy != nil {
		in, out := &in.ManagedBy, &out.ManagedBy
		*out = new(string)
		**out = **in
	}
	if in.ManagedByExtended != nil {
		in, out := &in.ManagedByExtended, &out.ManagedByExtended
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.MaxShares != nil {
		in, out := &in.MaxShares, &out.MaxShares
		*out = new(int)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.NetworkAccessPolicy != nil {
		in, out := &in.NetworkAccessPolicy, &out.NetworkAccessPolicy
		*out = new(string)
		**out = **in
	}
	if in.OptimizedForFrequentAttach != nil {
		in, out := &in.OptimizedForFrequentAttach, &out.OptimizedForFrequentAttach
		*out = new(bool)
		**out = **in
	}
	if in.OsType != nil {
		in, out := &in.OsType, &out.OsType
		*out = new(string)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.PropertyUpdatesInProgress != nil {
		in, out := &in.PropertyUpdatesInProgress, &out.PropertyUpdatesInProgress
		*out = new(PropertyUpdatesInProgress_STATUS)
		(*in).DeepCopyInto(*out)
	}
	if in.ProvisioningState != nil {
		in, out := &in.ProvisioningState, &out.ProvisioningState
		*out = new(string)
		**out = **in
	}
	if in.PublicNetworkAccess != nil {
		in, out := &in.PublicNetworkAccess, &out.PublicNetworkAccess
		*out = new(string)
		**out = **in
	}
	if in.PurchasePlan != nil {
		in, out := &in.PurchasePlan, &out.PurchasePlan
		*out = new(PurchasePlan_STATUS)
		(*in).DeepCopyInto(*out)
	}
	if in.SecurityProfile != nil {
		in, out := &in.SecurityProfile, &out.SecurityProfile
		*out = new(DiskSecurityProfile_STATUS)
		(*in).DeepCopyInto(*out)
	}
	if in.ShareInfo != nil {
		in, out := &in.ShareInfo, &out.ShareInfo
		*out = make([]ShareInfoElement_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Sku != nil {
		in, out := &in.Sku, &out.Sku
		*out = new(DiskSku_STATUS)
		(*in).DeepCopyInto(*out)
	}
	if in.SupportedCapabilities != nil {
		in, out := &in.SupportedCapabilities, &out.SupportedCapabilities
		*out = new(SupportedCapabilities_STATUS)
		(*in).DeepCopyInto(*out)
	}
	if in.SupportsHibernation != nil {
		in, out := &in.SupportsHibernation, &out.SupportsHibernation
		*out = new(bool)
		**out = **in
	}
	if in.Tags != nil {
		in, out := &in.Tags, &out.Tags
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Tier != nil {
		in, out := &in.Tier, &out.Tier
		*out = new(string)
		**out = **in
	}
	if in.TimeCreated != nil {
		in, out := &in.TimeCreated, &out.TimeCreated
		*out = new(string)
		**out = **in
	}
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(string)
		**out = **in
	}
	if in.UniqueId != nil {
		in, out := &in.UniqueId, &out.UniqueId
		*out = new(string)
		**out = **in
	}
	if in.Zones != nil {
		in, out := &in.Zones, &out.Zones
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Disk_STATUS.
func (in *Disk_STATUS) DeepCopy() *Disk_STATUS {
	if in == nil {
		return nil
	}
	out := new(Disk_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Disk_Spec) DeepCopyInto(out *Disk_Spec) {
	*out = *in
	if in.BurstingEnabled != nil {
		in, out := &in.BurstingEnabled, &out.BurstingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.CompletionPercent != nil {
		in, out := &in.CompletionPercent, &out.CompletionPercent
		*out = new(float64)
		**out = **in
	}
	if in.CreationData != nil {
		in, out := &in.CreationData, &out.CreationData
		*out = new(CreationData)
		(*in).DeepCopyInto(*out)
	}
	if in.DataAccessAuthMode != nil {
		in, out := &in.DataAccessAuthMode, &out.DataAccessAuthMode
		*out = new(string)
		**out = **in
	}
	if in.DiskAccessReference != nil {
		in, out := &in.DiskAccessReference, &out.DiskAccessReference
		*out = new(genruntime.ResourceReference)
		**out = **in
	}
	if in.DiskIOPSReadOnly != nil {
		in, out := &in.DiskIOPSReadOnly, &out.DiskIOPSReadOnly
		*out = new(int)
		**out = **in
	}
	if in.DiskIOPSReadWrite != nil {
		in, out := &in.DiskIOPSReadWrite, &out.DiskIOPSReadWrite
		*out = new(int)
		**out = **in
	}
	if in.DiskMBpsReadOnly != nil {
		in, out := &in.DiskMBpsReadOnly, &out.DiskMBpsReadOnly
		*out = new(int)
		**out = **in
	}
	if in.DiskMBpsReadWrite != nil {
		in, out := &in.DiskMBpsReadWrite, &out.DiskMBpsReadWrite
		*out = new(int)
		**out = **in
	}
	if in.DiskSizeGB != nil {
		in, out := &in.DiskSizeGB, &out.DiskSizeGB
		*out = new(int)
		**out = **in
	}
	if in.Encryption != nil {
		in, out := &in.Encryption, &out.Encryption
		*out = new(Encryption)
		(*in).DeepCopyInto(*out)
	}
	if in.EncryptionSettingsCollection != nil {
		in, out := &in.EncryptionSettingsCollection, &out.EncryptionSettingsCollection
		*out = new(EncryptionSettingsCollection)
		(*in).DeepCopyInto(*out)
	}
	if in.ExtendedLocation != nil {
		in, out := &in.ExtendedLocation, &out.ExtendedLocation
		*out = new(ExtendedLocation)
		(*in).DeepCopyInto(*out)
	}
	if in.HyperVGeneration != nil {
		in, out := &in.HyperVGeneration, &out.HyperVGeneration
		*out = new(string)
		**out = **in
	}
	if in.Location != nil {
		in, out := &in.Location, &out.Location
		*out = new(string)
		**out = **in
	}
	if in.MaxShares != nil {
		in, out := &in.MaxShares, &out.MaxShares
		*out = new(int)
		**out = **in
	}
	if in.NetworkAccessPolicy != nil {
		in, out := &in.NetworkAccessPolicy, &out.NetworkAccessPolicy
		*out = new(string)
		**out = **in
	}
	if in.OperatorSpec != nil {
		in, out := &in.OperatorSpec, &out.OperatorSpec
		*out = new(DiskOperatorSpec)
		(*in).DeepCopyInto(*out)
	}
	if in.OptimizedForFrequentAttach != nil {
		in, out := &in.OptimizedForFrequentAttach, &out.OptimizedForFrequentAttach
		*out = new(bool)
		**out = **in
	}
	if in.OsType != nil {
		in, out := &in.OsType, &out.OsType
		*out = new(string)
		**out = **in
	}
	if in.Owner != nil {
		in, out := &in.Owner, &out.Owner
		*out = new(genruntime.KnownResourceReference)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.PublicNetworkAccess != nil {
		in, out := &in.PublicNetworkAccess, &out.PublicNetworkAccess
		*out = new(string)
		**out = **in
	}
	if in.PurchasePlan != nil {
		in, out := &in.PurchasePlan, &out.PurchasePlan
		*out = new(PurchasePlan)
		(*in).DeepCopyInto(*out)
	}
	if in.SecurityProfile != nil {
		in, out := &in.SecurityProfile, &out.SecurityProfile
		*out = new(DiskSecurityProfile)
		(*in).DeepCopyInto(*out)
	}
	if in.Sku != nil {
		in, out := &in.Sku, &out.Sku
		*out = new(DiskSku)
		(*in).DeepCopyInto(*out)
	}
	if in.SupportedCapabilities != nil {
		in, out := &in.SupportedCapabilities, &out.SupportedCapabilities
		*out = new(SupportedCapabilities)
		(*in).DeepCopyInto(*out)
	}
	if in.SupportsHibernation != nil {
		in, out := &in.SupportsHibernation, &out.SupportsHibernation
		*out = new(bool)
		**out = **in
	}
	if in.Tags != nil {
		in, out := &in.Tags, &out.Tags
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Tier != nil {
		in, out := &in.Tier, &out.Tier
		*out = new(string)
		**out = **in
	}
	if in.Zones != nil {
		in, out := &in.Zones, &out.Zones
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Disk_Spec.
func (in *Disk_Spec) DeepCopy() *Disk_Spec {
	if in == nil {
		return nil
	}
	out := new(Disk_Spec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Encryption) DeepCopyInto(out *Encryption) {
	*out = *in
	if in.DiskEncryptionSetReference != nil {
		in, out := &in.DiskEncryptionSetReference, &out.DiskEncryptionSetReference
		*out = new(genruntime.ResourceReference)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Encryption.
func (in *Encryption) DeepCopy() *Encryption {
	if in == nil {
		return nil
	}
	out := new(Encryption)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *EncryptionSetIdentity) DeepCopyInto(out *EncryptionSetIdentity) {
	*out = *in
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(string)
		**out = **in
	}
	if in.UserAssignedIdentities != nil {
		in, out := &in.UserAssignedIdentities, &out.UserAssignedIdentities
		*out = make([]UserAssignedIdentityDetails, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new EncryptionSetIdentity.
func (in *EncryptionSetIdentity) DeepCopy() *EncryptionSetIdentity {
	if in == nil {
		return nil
	}
	out := new(EncryptionSetIdentity)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *EncryptionSetIdentity_STATUS) DeepCopyInto(out *EncryptionSetIdentity_STATUS) {
	*out = *in
	if in.PrincipalId != nil {
		in, out := &in.PrincipalId, &out.PrincipalId
		*out = new(string)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.TenantId != nil {
		in, out := &in.TenantId, &out.TenantId
		*out = new(string)
		**out = **in
	}
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(string)
		**out = **in
	}
	if in.UserAssignedIdentities != nil {
		in, out := &in.UserAssignedIdentities, &out.UserAssignedIdentities
		*out = make(map[string]EncryptionSetIdentity_UserAssignedIdentities_STATUS, len(*in))
		for key, val := range *in {
			(*out)[key] = *val.DeepCopy()
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new EncryptionSetIdentity_STATUS.
func (in *EncryptionSetIdentity_STATUS) DeepCopy() *EncryptionSetIdentity_STATUS {
	if in == nil {
		return nil
	}
	out := new(EncryptionSetIdentity_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *EncryptionSetIdentity_UserAssignedIdentities_STATUS) DeepCopyInto(out *EncryptionSetIdentity_UserAssignedIdentities_STATUS) {
	*out = *in
	if in.ClientId != nil {
		in, out := &in.ClientId, &out.ClientId
		*out = new(string)
		**out = **in
	}
	if in.PrincipalId != nil {
		in, out := &in.PrincipalId, &out.PrincipalId
		*out = new(string)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new EncryptionSetIdentity_UserAssignedIdentities_STATUS.
func (in *EncryptionSetIdentity_UserAssignedIdentities_STATUS) DeepCopy() *EncryptionSetIdentity_UserAssignedIdentities_STATUS {
	if in == nil {
		return nil
	}
	out := new(EncryptionSetIdentity_UserAssignedIdentities_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *EncryptionSettingsCollection) DeepCopyInto(out *EncryptionSettingsCollection) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.EncryptionSettings != nil {
		in, out := &in.EncryptionSettings, &out.EncryptionSettings
		*out = make([]EncryptionSettingsElement, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.EncryptionSettingsVersion != nil {
		in, out := &in.EncryptionSettingsVersion, &out.EncryptionSettingsVersion
		*out = new(string)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new EncryptionSettingsCollection.
func (in *EncryptionSettingsCollection) DeepCopy() *EncryptionSettingsCollection {
	if in == nil {
		return nil
	}
	out := new(EncryptionSettingsCollection)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *EncryptionSettingsCollection_STATUS) DeepCopyInto(out *EncryptionSettingsCollection_STATUS) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.EncryptionSettings != nil {
		in, out := &in.EncryptionSettings, &out.EncryptionSettings
		*out = make([]EncryptionSettingsElement_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.EncryptionSettingsVersion != nil {
		in, out := &in.EncryptionSettingsVersion, &out.EncryptionSettingsVersion
		*out = new(string)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new EncryptionSettingsCollection_STATUS.
func (in *EncryptionSettingsCollection_STATUS) DeepCopy() *EncryptionSettingsCollection_STATUS {
	if in == nil {
		return nil
	}
	out := new(EncryptionSettingsCollection_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *EncryptionSettingsElement) DeepCopyInto(out *EncryptionSettingsElement) {
	*out = *in
	if in.DiskEncryptionKey != nil {
		in, out := &in.DiskEncryptionKey, &out.DiskEncryptionKey
		*out = new(KeyVaultAndSecretReference)
		(*in).DeepCopyInto(*out)
	}
	if in.KeyEncryptionKey != nil {
		in, out := &in.KeyEncryptionKey, &out.KeyEncryptionKey
		*out = new(KeyVaultAndKeyReference)
		(*in).DeepCopyInto(*out)
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new EncryptionSettingsElement.
func (in *EncryptionSettingsElement) DeepCopy() *EncryptionSettingsElement {
	if in == nil {
		return nil
	}
	out := new(EncryptionSettingsElement)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *EncryptionSettingsElement_STATUS) DeepCopyInto(out *EncryptionSettingsElement_STATUS) {
	*out = *in
	if in.DiskEncryptionKey != nil {
		in, out := &in.DiskEncryptionKey, &out.DiskEncryptionKey
		*out = new(KeyVaultAndSecretReference_STATUS)
		(*in).DeepCopyInto(*out)
	}
	if in.KeyEncryptionKey != nil {
		in, out := &in.KeyEncryptionKey, &out.KeyEncryptionKey
		*out = new(KeyVaultAndKeyReference_STATUS)
		(*in).DeepCopyInto(*out)
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new EncryptionSettingsElement_STATUS.
func (in *EncryptionSettingsElement_STATUS) DeepCopy() *EncryptionSettingsElement_STATUS {
	if in == nil {
		return nil
	}
	out := new(EncryptionSettingsElement_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Encryption_STATUS) DeepCopyInto(out *Encryption_STATUS) {
	*out = *in
	if in.DiskEncryptionSetId != nil {
		in, out := &in.DiskEncryptionSetId, &out.DiskEncryptionSetId
		*out = new(string)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Encryption_STATUS.
func (in *Encryption_STATUS) DeepCopy() *Encryption_STATUS {
	if in == nil {
		return nil
	}
	out := new(Encryption_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ExtendedLocation) DeepCopyInto(out *ExtendedLocation) {
	*out = *in
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ExtendedLocation.
func (in *ExtendedLocation) DeepCopy() *ExtendedLocation {
	if in == nil {
		return nil
	}
	out := new(ExtendedLocation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ExtendedLocation_STATUS) DeepCopyInto(out *ExtendedLocation_STATUS) {
	*out = *in
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ExtendedLocation_STATUS.
func (in *ExtendedLocation_STATUS) DeepCopy() *ExtendedLocation_STATUS {
	if in == nil {
		return nil
	}
	out := new(ExtendedLocation_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ImageDiskReference) DeepCopyInto(out *ImageDiskReference) {
	*out = *in
	if in.CommunityGalleryImageId != nil {
		in, out := &in.CommunityGalleryImageId, &out.CommunityGalleryImageId
		*out = new(string)
		**out = **in
	}
	if in.Lun != nil {
		in, out := &in.Lun, &out.Lun
		*out = new(int)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Reference != nil {
		in, out := &in.Reference, &out.Reference
		*out = new(genruntime.ResourceReference)
		**out = **in
	}
	if in.SharedGalleryImageId != nil {
		in, out := &in.SharedGalleryImageId, &out.SharedGalleryImageId
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ImageDiskReference.
func (in *ImageDiskReference) DeepCopy() *ImageDiskReference {
	if in == nil {
		return nil
	}
	out := new(ImageDiskReference)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ImageDiskReference_STATUS) DeepCopyInto(out *ImageDiskReference_STATUS) {
	*out = *in
	if in.CommunityGalleryImageId != nil {
		in, out := &in.CommunityGalleryImageId, &out.CommunityGalleryImageId
		*out = new(string)
		**out = **in
	}
	if in.Id != nil {
		in, out := &in.Id, &out.Id
		*out = new(string)
		**out = **in
	}
	if in.Lun != nil {
		in, out := &in.Lun, &out.Lun
		*out = new(int)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.SharedGalleryImageId != nil {
		in, out := &in.SharedGalleryImageId, &out.SharedGalleryImageId
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ImageDiskReference_STATUS.
func (in *ImageDiskReference_STATUS) DeepCopy() *ImageDiskReference_STATUS {
	if in == nil {
		return nil
	}
	out := new(ImageDiskReference_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *InnerError_STATUS) DeepCopyInto(out *InnerError_STATUS) {
	*out = *in
	if in.Errordetail != nil {
		in, out := &in.Errordetail, &out.Errordetail
		*out = new(string)
		**out = **in
	}
	if in.Exceptiontype != nil {
		in, out := &in.Exceptiontype, &out.Exceptiontype
		*out = new(string)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new InnerError_STATUS.
func (in *InnerError_STATUS) DeepCopy() *InnerError_STATUS {
	if in == nil {
		return nil
	}
	out := new(InnerError_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KeyForDiskEncryptionSet) DeepCopyInto(out *KeyForDiskEncryptionSet) {
	*out = *in
	if in.KeyUrl != nil {
		in, out := &in.KeyUrl, &out.KeyUrl
		*out = new(string)
		**out = **in
	}
	if in.KeyUrlFromConfig != nil {
		in, out := &in.KeyUrlFromConfig, &out.KeyUrlFromConfig
		*out = new(genruntime.ConfigMapReference)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.SourceVault != nil {
		in, out := &in.SourceVault, &out.SourceVault
		*out = new(SourceVault)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KeyForDiskEncryptionSet.
func (in *KeyForDiskEncryptionSet) DeepCopy() *KeyForDiskEncryptionSet {
	if in == nil {
		return nil
	}
	out := new(KeyForDiskEncryptionSet)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KeyForDiskEncryptionSet_STATUS) DeepCopyInto(out *KeyForDiskEncryptionSet_STATUS) {
	*out = *in
	if in.KeyUrl != nil {
		in, out := &in.KeyUrl, &out.KeyUrl
		*out = new(string)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.SourceVault != nil {
		in, out := &in.SourceVault, &out.SourceVault
		*out = new(SourceVault_STATUS)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KeyForDiskEncryptionSet_STATUS.
func (in *KeyForDiskEncryptionSet_STATUS) DeepCopy() *KeyForDiskEncryptionSet_STATUS {
	if in == nil {
		return nil
	}
	out := new(KeyForDiskEncryptionSet_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KeyVaultAndKeyReference) DeepCopyInto(out *KeyVaultAndKeyReference) {
	*out = *in
	if in.KeyUrl != nil {
		in, out := &in.KeyUrl, &out.KeyUrl
		*out = new(string)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.SourceVault != nil {
		in, out := &in.SourceVault, &out.SourceVault
		*out = new(SourceVault)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KeyVaultAndKeyReference.
func (in *KeyVaultAndKeyReference) DeepCopy() *KeyVaultAndKeyReference {
	if in == nil {
		return nil
	}
	out := new(KeyVaultAndKeyReference)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KeyVaultAndKeyReference_STATUS) DeepCopyInto(out *KeyVaultAndKeyReference_STATUS) {
	*out = *in
	if in.KeyUrl != nil {
		in, out := &in.KeyUrl, &out.KeyUrl
		*out = new(string)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.SourceVault != nil {
		in, out := &in.SourceVault, &out.SourceVault
		*out = new(SourceVault_STATUS)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KeyVaultAndKeyReference_STATUS.
func (in *KeyVaultAndKeyReference_STATUS) DeepCopy() *KeyVaultAndKeyReference_STATUS {
	if in == nil {
		return nil
	}
	out := new(KeyVaultAndKeyReference_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KeyVaultAndSecretReference) DeepCopyInto(out *KeyVaultAndSecretReference) {
	*out = *in
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.SecretUrl != nil {
		in, out := &in.SecretUrl, &out.SecretUrl
		*out = new(string)
		**out = **in
	}
	if in.SourceVault != nil {
		in, out := &in.SourceVault, &out.SourceVault
		*out = new(SourceVault)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KeyVaultAndSecretReference.
func (in *KeyVaultAndSecretReference) DeepCopy() *KeyVaultAndSecretReference {
	if in == nil {
		return nil
	}
	out := new(KeyVaultAndSecretReference)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KeyVaultAndSecretReference_STATUS) DeepCopyInto(out *KeyVaultAndSecretReference_STATUS) {
	*out = *in
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.SecretUrl != nil {
		in, out := &in.SecretUrl, &out.SecretUrl
		*out = new(string)
		**out = **in
	}
	if in.SourceVault != nil {
		in, out := &in.SourceVault, &out.SourceVault
		*out = new(SourceVault_STATUS)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KeyVaultAndSecretReference_STATUS.
func (in *KeyVaultAndSecretReference_STATUS) DeepCopy() *KeyVaultAndSecretReference_STATUS {
	if in == nil {
		return nil
	}
	out := new(KeyVaultAndSecretReference_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PrivateEndpointConnection_STATUS) DeepCopyInto(out *PrivateEndpointConnection_STATUS) {
	*out = *in
	if in.Id != nil {
		in, out := &in.Id, &out.Id
		*out = new(string)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PrivateEndpointConnection_STATUS.
func (in *PrivateEndpointConnection_STATUS) DeepCopy() *PrivateEndpointConnection_STATUS {
	if in == nil {
		return nil
	}
	out := new(PrivateEndpointConnection_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PropertyUpdatesInProgress_STATUS) DeepCopyInto(out *PropertyUpdatesInProgress_STATUS) {
	*out = *in
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.TargetTier != nil {
		in, out := &in.TargetTier, &out.TargetTier
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PropertyUpdatesInProgress_STATUS.
func (in *PropertyUpdatesInProgress_STATUS) DeepCopy() *PropertyUpdatesInProgress_STATUS {
	if in == nil {
		return nil
	}
	out := new(PropertyUpdatesInProgress_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PurchasePlan) DeepCopyInto(out *PurchasePlan) {
	*out = *in
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.Product != nil {
		in, out := &in.Product, &out.Product
		*out = new(string)
		**out = **in
	}
	if in.PromotionCode != nil {
		in, out := &in.PromotionCode, &out.PromotionCode
		*out = new(string)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Publisher != nil {
		in, out := &in.Publisher, &out.Publisher
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PurchasePlan.
func (in *PurchasePlan) DeepCopy() *PurchasePlan {
	if in == nil {
		return nil
	}
	out := new(PurchasePlan)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PurchasePlan_STATUS) DeepCopyInto(out *PurchasePlan_STATUS) {
	*out = *in
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.Product != nil {
		in, out := &in.Product, &out.Product
		*out = new(string)
		**out = **in
	}
	if in.PromotionCode != nil {
		in, out := &in.PromotionCode, &out.PromotionCode
		*out = new(string)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Publisher != nil {
		in, out := &in.Publisher, &out.Publisher
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PurchasePlan_STATUS.
func (in *PurchasePlan_STATUS) DeepCopy() *PurchasePlan_STATUS {
	if in == nil {
		return nil
	}
	out := new(PurchasePlan_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ShareInfoElement_STATUS) DeepCopyInto(out *ShareInfoElement_STATUS) {
	*out = *in
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.VmUri != nil {
		in, out := &in.VmUri, &out.VmUri
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ShareInfoElement_STATUS.
func (in *ShareInfoElement_STATUS) DeepCopy() *ShareInfoElement_STATUS {
	if in == nil {
		return nil
	}
	out := new(ShareInfoElement_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Snapshot) DeepCopyInto(out *Snapshot) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Snapshot.
func (in *Snapshot) DeepCopy() *Snapshot {
	if in == nil {
		return nil
	}
	out := new(Snapshot)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *Snapshot) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SnapshotList) DeepCopyInto(out *SnapshotList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]Snapshot, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SnapshotList.
func (in *SnapshotList) DeepCopy() *SnapshotList {
	if in == nil {
		return nil
	}
	out := new(SnapshotList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *SnapshotList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SnapshotOperatorSpec) DeepCopyInto(out *SnapshotOperatorSpec) {
	*out = *in
	if in.ConfigMapExpressions != nil {
		in, out := &in.ConfigMapExpressions, &out.ConfigMapExpressions
		*out = make([]*core.DestinationExpression, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(core.DestinationExpression)
				**out = **in
			}
		}
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.SecretExpressions != nil {
		in, out := &in.SecretExpressions, &out.SecretExpressions
		*out = make([]*core.DestinationExpression, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(core.DestinationExpression)
				**out = **in
			}
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SnapshotOperatorSpec.
func (in *SnapshotOperatorSpec) DeepCopy() *SnapshotOperatorSpec {
	if in == nil {
		return nil
	}
	out := new(SnapshotOperatorSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SnapshotSku) DeepCopyInto(out *SnapshotSku) {
	*out = *in
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SnapshotSku.
func (in *SnapshotSku) DeepCopy() *SnapshotSku {
	if in == nil {
		return nil
	}
	out := new(SnapshotSku)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SnapshotSku_STATUS) DeepCopyInto(out *SnapshotSku_STATUS) {
	*out = *in
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Tier != nil {
		in, out := &in.Tier, &out.Tier
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SnapshotSku_STATUS.
func (in *SnapshotSku_STATUS) DeepCopy() *SnapshotSku_STATUS {
	if in == nil {
		return nil
	}
	out := new(SnapshotSku_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Snapshot_STATUS) DeepCopyInto(out *Snapshot_STATUS) {
	*out = *in
	if in.CompletionPercent != nil {
		in, out := &in.CompletionPercent, &out.CompletionPercent
		*out = new(float64)
		**out = **in
	}
	if in.Conditions != nil {
		in, out := &in.Conditions, &out.Conditions
		*out = make([]conditions.Condition, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.CopyCompletionError != nil {
		in, out := &in.CopyCompletionError, &out.CopyCompletionError
		*out = new(CopyCompletionError_STATUS)
		(*in).DeepCopyInto(*out)
	}
	if in.CreationData != nil {
		in, out := &in.CreationData, &out.CreationData
		*out = new(CreationData_STATUS)
		(*in).DeepCopyInto(*out)
	}
	if in.DataAccessAuthMode != nil {
		in, out := &in.DataAccessAuthMode, &out.DataAccessAuthMode
		*out = new(string)
		**out = **in
	}
	if in.DiskAccessId != nil {
		in, out := &in.DiskAccessId, &out.DiskAccessId
		*out = new(string)
		**out = **in
	}
	if in.DiskSizeBytes != nil {
		in, out := &in.DiskSizeBytes, &out.DiskSizeBytes
		*out = new(int)
		**out = **in
	}
	if in.DiskSizeGB != nil {
		in, out := &in.DiskSizeGB, &out.DiskSizeGB
		*out = new(int)
		**out = **in
	}
	if in.DiskState != nil {
		in, out := &in.DiskState, &out.DiskState
		*out = new(string)
		**out = **in
	}
	if in.Encryption != nil {
		in, out := &in.Encryption, &out.Encryption
		*out = new(Encryption_STATUS)
		(*in).DeepCopyInto(*out)
	}
	if in.EncryptionSettingsCollection != nil {
		in, out := &in.EncryptionSettingsCollection, &out.EncryptionSettingsCollection
		*out = new(EncryptionSettingsCollection_STATUS)
		(*in).DeepCopyInto(*out)
	}
	if in.ExtendedLocation != nil {
		in, out := &in.ExtendedLocation, &out.ExtendedLocation
		*out = new(ExtendedLocation_STATUS)
		(*in).DeepCopyInto(*out)
	}
	if in.HyperVGeneration != nil {
		in, out := &in.HyperVGeneration, &out.HyperVGeneration
		*out = new(string)
		**out = **in
	}
	if in.Id != nil {
		in, out := &in.Id, &out.Id
		*out = new(string)
		**out = **in
	}
	if in.Incremental != nil {
		in, out := &in.Incremental, &out.Incremental
		*out = new(bool)
		**out = **in
	}
	if in.IncrementalSnapshotFamilyId != nil {
		in, out := &in.IncrementalSnapshotFamilyId, &out.IncrementalSnapshotFamilyId
		*out = new(string)
		**out = **in
	}
	if in.Location != nil {
		in, out := &in.Location, &out.Location
		*out = new(string)
		**out = **in
	}
	if in.ManagedBy != nil {
		in, out := &in.ManagedBy, &out.ManagedBy
		*out = new(string)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.NetworkAccessPolicy != nil {
		in, out := &in.NetworkAccessPolicy, &out.NetworkAccessPolicy
		*out = new(string)
		**out = **in
	}
	if in.OsType != nil {
		in, out := &in.OsType, &out.OsType
		*out = new(string)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.ProvisioningState != nil {
		in, out := &in.ProvisioningState, &out.ProvisioningState
		*out = new(string)
		**out = **in
	}
	if in.PublicNetworkAccess != nil {
		in, out := &in.PublicNetworkAccess, &out.PublicNetworkAccess
		*out = new(string)
		**out = **in
	}
	if in.PurchasePlan != nil {
		in, out := &in.PurchasePlan, &out.PurchasePlan
		*out = new(PurchasePlan_STATUS)
		(*in).DeepCopyInto(*out)
	}
	if in.SecurityProfile != nil {
		in, out := &in.SecurityProfile, &out.SecurityProfile
		*out = new(DiskSecurityProfile_STATUS)
		(*in).DeepCopyInto(*out)
	}
	if in.Sku != nil {
		in, out := &in.Sku, &out.Sku
		*out = new(SnapshotSku_STATUS)
		(*in).DeepCopyInto(*out)
	}
	if in.SupportedCapabilities != nil {
		in, out := &in.SupportedCapabilities, &out.SupportedCapabilities
		*out = new(SupportedCapabilities_STATUS)
		(*in).DeepCopyInto(*out)
	}
	if in.SupportsHibernation != nil {
		in, out := &in.SupportsHibernation, &out.SupportsHibernation
		*out = new(bool)
		**out = **in
	}
	if in.Tags != nil {
		in, out := &in.Tags, &out.Tags
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.TimeCreated != nil {
		in, out := &in.TimeCreated, &out.TimeCreated
		*out = new(string)
		**out = **in
	}
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(string)
		**out = **in
	}
	if in.UniqueId != nil {
		in, out := &in.UniqueId, &out.UniqueId
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Snapshot_STATUS.
func (in *Snapshot_STATUS) DeepCopy() *Snapshot_STATUS {
	if in == nil {
		return nil
	}
	out := new(Snapshot_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Snapshot_Spec) DeepCopyInto(out *Snapshot_Spec) {
	*out = *in
	if in.CompletionPercent != nil {
		in, out := &in.CompletionPercent, &out.CompletionPercent
		*out = new(float64)
		**out = **in
	}
	if in.CopyCompletionError != nil {
		in, out := &in.CopyCompletionError, &out.CopyCompletionError
		*out = new(CopyCompletionError)
		(*in).DeepCopyInto(*out)
	}
	if in.CreationData != nil {
		in, out := &in.CreationData, &out.CreationData
		*out = new(CreationData)
		(*in).DeepCopyInto(*out)
	}
	if in.DataAccessAuthMode != nil {
		in, out := &in.DataAccessAuthMode, &out.DataAccessAuthMode
		*out = new(string)
		**out = **in
	}
	if in.DiskAccessReference != nil {
		in, out := &in.DiskAccessReference, &out.DiskAccessReference
		*out = new(genruntime.ResourceReference)
		**out = **in
	}
	if in.DiskSizeGB != nil {
		in, out := &in.DiskSizeGB, &out.DiskSizeGB
		*out = new(int)
		**out = **in
	}
	if in.DiskState != nil {
		in, out := &in.DiskState, &out.DiskState
		*out = new(string)
		**out = **in
	}
	if in.Encryption != nil {
		in, out := &in.Encryption, &out.Encryption
		*out = new(Encryption)
		(*in).DeepCopyInto(*out)
	}
	if in.EncryptionSettingsCollection != nil {
		in, out := &in.EncryptionSettingsCollection, &out.EncryptionSettingsCollection
		*out = new(EncryptionSettingsCollection)
		(*in).DeepCopyInto(*out)
	}
	if in.ExtendedLocation != nil {
		in, out := &in.ExtendedLocation, &out.ExtendedLocation
		*out = new(ExtendedLocation)
		(*in).DeepCopyInto(*out)
	}
	if in.HyperVGeneration != nil {
		in, out := &in.HyperVGeneration, &out.HyperVGeneration
		*out = new(string)
		**out = **in
	}
	if in.Incremental != nil {
		in, out := &in.Incremental, &out.Incremental
		*out = new(bool)
		**out = **in
	}
	if in.Location != nil {
		in, out := &in.Location, &out.Location
		*out = new(string)
		**out = **in
	}
	if in.NetworkAccessPolicy != nil {
		in, out := &in.NetworkAccessPolicy, &out.NetworkAccessPolicy
		*out = new(string)
		**out = **in
	}
	if in.OperatorSpec != nil {
		in, out := &in.OperatorSpec, &out.OperatorSpec
		*out = new(SnapshotOperatorSpec)
		(*in).DeepCopyInto(*out)
	}
	if in.OsType != nil {
		in, out := &in.OsType, &out.OsType
		*out = new(string)
		**out = **in
	}
	if in.Owner != nil {
		in, out := &in.Owner, &out.Owner
		*out = new(genruntime.KnownResourceReference)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.PublicNetworkAccess != nil {
		in, out := &in.PublicNetworkAccess, &out.PublicNetworkAccess
		*out = new(string)
		**out = **in
	}
	if in.PurchasePlan != nil {
		in, out := &in.PurchasePlan, &out.PurchasePlan
		*out = new(PurchasePlan)
		(*in).DeepCopyInto(*out)
	}
	if in.SecurityProfile != nil {
		in, out := &in.SecurityProfile, &out.SecurityProfile
		*out = new(DiskSecurityProfile)
		(*in).DeepCopyInto(*out)
	}
	if in.Sku != nil {
		in, out := &in.Sku, &out.Sku
		*out = new(SnapshotSku)
		(*in).DeepCopyInto(*out)
	}
	if in.SupportedCapabilities != nil {
		in, out := &in.SupportedCapabilities, &out.SupportedCapabilities
		*out = new(SupportedCapabilities)
		(*in).DeepCopyInto(*out)
	}
	if in.SupportsHibernation != nil {
		in, out := &in.SupportsHibernation, &out.SupportsHibernation
		*out = new(bool)
		**out = **in
	}
	if in.Tags != nil {
		in, out := &in.Tags, &out.Tags
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Snapshot_Spec.
func (in *Snapshot_Spec) DeepCopy() *Snapshot_Spec {
	if in == nil {
		return nil
	}
	out := new(Snapshot_Spec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SourceVault) DeepCopyInto(out *SourceVault) {
	*out = *in
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Reference != nil {
		in, out := &in.Reference, &out.Reference
		*out = new(genruntime.ResourceReference)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SourceVault.
func (in *SourceVault) DeepCopy() *SourceVault {
	if in == nil {
		return nil
	}
	out := new(SourceVault)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SourceVault_STATUS) DeepCopyInto(out *SourceVault_STATUS) {
	*out = *in
	if in.Id != nil {
		in, out := &in.Id, &out.Id
		*out = new(string)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SourceVault_STATUS.
func (in *SourceVault_STATUS) DeepCopy() *SourceVault_STATUS {
	if in == nil {
		return nil
	}
	out := new(SourceVault_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SupportedCapabilities) DeepCopyInto(out *SupportedCapabilities) {
	*out = *in
	if in.AcceleratedNetwork != nil {
		in, out := &in.AcceleratedNetwork, &out.AcceleratedNetwork
		*out = new(bool)
		**out = **in
	}
	if in.Architecture != nil {
		in, out := &in.Architecture, &out.Architecture
		*out = new(string)
		**out = **in
	}
	if in.DiskControllerTypes != nil {
		in, out := &in.DiskControllerTypes, &out.DiskControllerTypes
		*out = new(string)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SupportedCapabilities.
func (in *SupportedCapabilities) DeepCopy() *SupportedCapabilities {
	if in == nil {
		return nil
	}
	out := new(SupportedCapabilities)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SupportedCapabilities_STATUS) DeepCopyInto(out *SupportedCapabilities_STATUS) {
	*out = *in
	if in.AcceleratedNetwork != nil {
		in, out := &in.AcceleratedNetwork, &out.AcceleratedNetwork
		*out = new(bool)
		**out = **in
	}
	if in.Architecture != nil {
		in, out := &in.Architecture, &out.Architecture
		*out = new(string)
		**out = **in
	}
	if in.DiskControllerTypes != nil {
		in, out := &in.DiskControllerTypes, &out.DiskControllerTypes
		*out = new(string)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SupportedCapabilities_STATUS.
func (in *SupportedCapabilities_STATUS) DeepCopy() *SupportedCapabilities_STATUS {
	if in == nil {
		return nil
	}
	out := new(SupportedCapabilities_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *UserAssignedIdentityDetails) DeepCopyInto(out *UserAssignedIdentityDetails) {
	*out = *in
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	out.Reference = in.Reference
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new UserAssignedIdentityDetails.
func (in *UserAssignedIdentityDetails) DeepCopy() *UserAssignedIdentityDetails {
	if in == nil {
		return nil
	}
	out := new(UserAssignedIdentityDetails)
	in.DeepCopyInto(out)
	return out
}
