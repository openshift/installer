// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20201101

import (
	"fmt"
	v20201101s "github.com/Azure/azure-service-operator/v2/api/network/v1api20201101/storage"
	"github.com/Azure/azure-service-operator/v2/internal/reflecthelpers"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/pkg/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
	"sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Generator information:
// - Generated from: /network/resource-manager/Microsoft.Network/stable/2020-11-01/networkInterface.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkInterfaces/{networkInterfaceName}
type NetworkInterface struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              NetworkInterface_Spec                                        `json:"spec,omitempty"`
	Status            NetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded `json:"status,omitempty"`
}

var _ conditions.Conditioner = &NetworkInterface{}

// GetConditions returns the conditions of the resource
func (networkInterface *NetworkInterface) GetConditions() conditions.Conditions {
	return networkInterface.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (networkInterface *NetworkInterface) SetConditions(conditions conditions.Conditions) {
	networkInterface.Status.Conditions = conditions
}

var _ conversion.Convertible = &NetworkInterface{}

// ConvertFrom populates our NetworkInterface from the provided hub NetworkInterface
func (networkInterface *NetworkInterface) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*v20201101s.NetworkInterface)
	if !ok {
		return fmt.Errorf("expected network/v1api20201101/storage/NetworkInterface but received %T instead", hub)
	}

	return networkInterface.AssignProperties_From_NetworkInterface(source)
}

// ConvertTo populates the provided hub NetworkInterface from our NetworkInterface
func (networkInterface *NetworkInterface) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*v20201101s.NetworkInterface)
	if !ok {
		return fmt.Errorf("expected network/v1api20201101/storage/NetworkInterface but received %T instead", hub)
	}

	return networkInterface.AssignProperties_To_NetworkInterface(destination)
}

// +kubebuilder:webhook:path=/mutate-network-azure-com-v1api20201101-networkinterface,mutating=true,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=network.azure.com,resources=networkinterfaces,verbs=create;update,versions=v1api20201101,name=default.v1api20201101.networkinterfaces.network.azure.com,admissionReviewVersions=v1

var _ admission.Defaulter = &NetworkInterface{}

// Default applies defaults to the NetworkInterface resource
func (networkInterface *NetworkInterface) Default() {
	networkInterface.defaultImpl()
	var temp any = networkInterface
	if runtimeDefaulter, ok := temp.(genruntime.Defaulter); ok {
		runtimeDefaulter.CustomDefault()
	}
}

// defaultAzureName defaults the Azure name of the resource to the Kubernetes name
func (networkInterface *NetworkInterface) defaultAzureName() {
	if networkInterface.Spec.AzureName == "" {
		networkInterface.Spec.AzureName = networkInterface.Name
	}
}

// defaultImpl applies the code generated defaults to the NetworkInterface resource
func (networkInterface *NetworkInterface) defaultImpl() { networkInterface.defaultAzureName() }

var _ genruntime.ImportableResource = &NetworkInterface{}

// InitializeSpec initializes the spec for this resource from the given status
func (networkInterface *NetworkInterface) InitializeSpec(status genruntime.ConvertibleStatus) error {
	if s, ok := status.(*NetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded); ok {
		return networkInterface.Spec.Initialize_From_NetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded(s)
	}

	return fmt.Errorf("expected Status of type NetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded but received %T instead", status)
}

var _ genruntime.KubernetesResource = &NetworkInterface{}

// AzureName returns the Azure name of the resource
func (networkInterface *NetworkInterface) AzureName() string {
	return networkInterface.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2020-11-01"
func (networkInterface NetworkInterface) GetAPIVersion() string {
	return string(APIVersion_Value)
}

// GetResourceScope returns the scope of the resource
func (networkInterface *NetworkInterface) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (networkInterface *NetworkInterface) GetSpec() genruntime.ConvertibleSpec {
	return &networkInterface.Spec
}

// GetStatus returns the status of this resource
func (networkInterface *NetworkInterface) GetStatus() genruntime.ConvertibleStatus {
	return &networkInterface.Status
}

// GetSupportedOperations returns the operations supported by the resource
func (networkInterface *NetworkInterface) GetSupportedOperations() []genruntime.ResourceOperation {
	return []genruntime.ResourceOperation{
		genruntime.ResourceOperationDelete,
		genruntime.ResourceOperationGet,
		genruntime.ResourceOperationPut,
	}
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.Network/networkInterfaces"
func (networkInterface *NetworkInterface) GetType() string {
	return "Microsoft.Network/networkInterfaces"
}

// NewEmptyStatus returns a new empty (blank) status
func (networkInterface *NetworkInterface) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &NetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded{}
}

// Owner returns the ResourceReference of the owner
func (networkInterface *NetworkInterface) Owner() *genruntime.ResourceReference {
	group, kind := genruntime.LookupOwnerGroupKind(networkInterface.Spec)
	return networkInterface.Spec.Owner.AsResourceReference(group, kind)
}

// SetStatus sets the status of this resource
func (networkInterface *NetworkInterface) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*NetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded); ok {
		networkInterface.Status = *st
		return nil
	}

	// Convert status to required version
	var st NetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return errors.Wrap(err, "failed to convert status")
	}

	networkInterface.Status = st
	return nil
}

// +kubebuilder:webhook:path=/validate-network-azure-com-v1api20201101-networkinterface,mutating=false,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=network.azure.com,resources=networkinterfaces,verbs=create;update,versions=v1api20201101,name=validate.v1api20201101.networkinterfaces.network.azure.com,admissionReviewVersions=v1

var _ admission.Validator = &NetworkInterface{}

// ValidateCreate validates the creation of the resource
func (networkInterface *NetworkInterface) ValidateCreate() (admission.Warnings, error) {
	validations := networkInterface.createValidations()
	var temp any = networkInterface
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.CreateValidations()...)
	}
	return genruntime.ValidateCreate(validations)
}

// ValidateDelete validates the deletion of the resource
func (networkInterface *NetworkInterface) ValidateDelete() (admission.Warnings, error) {
	validations := networkInterface.deleteValidations()
	var temp any = networkInterface
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.DeleteValidations()...)
	}
	return genruntime.ValidateDelete(validations)
}

// ValidateUpdate validates an update of the resource
func (networkInterface *NetworkInterface) ValidateUpdate(old runtime.Object) (admission.Warnings, error) {
	validations := networkInterface.updateValidations()
	var temp any = networkInterface
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.UpdateValidations()...)
	}
	return genruntime.ValidateUpdate(old, validations)
}

// createValidations validates the creation of the resource
func (networkInterface *NetworkInterface) createValidations() []func() (admission.Warnings, error) {
	return []func() (admission.Warnings, error){networkInterface.validateResourceReferences, networkInterface.validateOwnerReference}
}

// deleteValidations validates the deletion of the resource
func (networkInterface *NetworkInterface) deleteValidations() []func() (admission.Warnings, error) {
	return nil
}

// updateValidations validates the update of the resource
func (networkInterface *NetworkInterface) updateValidations() []func(old runtime.Object) (admission.Warnings, error) {
	return []func(old runtime.Object) (admission.Warnings, error){
		func(old runtime.Object) (admission.Warnings, error) {
			return networkInterface.validateResourceReferences()
		},
		networkInterface.validateWriteOnceProperties,
		func(old runtime.Object) (admission.Warnings, error) {
			return networkInterface.validateOwnerReference()
		},
	}
}

// validateOwnerReference validates the owner field
func (networkInterface *NetworkInterface) validateOwnerReference() (admission.Warnings, error) {
	return genruntime.ValidateOwner(networkInterface)
}

// validateResourceReferences validates all resource references
func (networkInterface *NetworkInterface) validateResourceReferences() (admission.Warnings, error) {
	refs, err := reflecthelpers.FindResourceReferences(&networkInterface.Spec)
	if err != nil {
		return nil, err
	}
	return genruntime.ValidateResourceReferences(refs)
}

// validateWriteOnceProperties validates all WriteOnce properties
func (networkInterface *NetworkInterface) validateWriteOnceProperties(old runtime.Object) (admission.Warnings, error) {
	oldObj, ok := old.(*NetworkInterface)
	if !ok {
		return nil, nil
	}

	return genruntime.ValidateWriteOnceProperties(oldObj, networkInterface)
}

// AssignProperties_From_NetworkInterface populates our NetworkInterface from the provided source NetworkInterface
func (networkInterface *NetworkInterface) AssignProperties_From_NetworkInterface(source *v20201101s.NetworkInterface) error {

	// ObjectMeta
	networkInterface.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec NetworkInterface_Spec
	err := spec.AssignProperties_From_NetworkInterface_Spec(&source.Spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_NetworkInterface_Spec() to populate field Spec")
	}
	networkInterface.Spec = spec

	// Status
	var status NetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded
	err = status.AssignProperties_From_NetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded(&source.Status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_NetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded() to populate field Status")
	}
	networkInterface.Status = status

	// No error
	return nil
}

// AssignProperties_To_NetworkInterface populates the provided destination NetworkInterface from our NetworkInterface
func (networkInterface *NetworkInterface) AssignProperties_To_NetworkInterface(destination *v20201101s.NetworkInterface) error {

	// ObjectMeta
	destination.ObjectMeta = *networkInterface.ObjectMeta.DeepCopy()

	// Spec
	var spec v20201101s.NetworkInterface_Spec
	err := networkInterface.Spec.AssignProperties_To_NetworkInterface_Spec(&spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_NetworkInterface_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status v20201101s.NetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded
	err = networkInterface.Status.AssignProperties_To_NetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded(&status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_NetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (networkInterface *NetworkInterface) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: networkInterface.Spec.OriginalVersion(),
		Kind:    "NetworkInterface",
	}
}

// +kubebuilder:object:root=true
// Generator information:
// - Generated from: /network/resource-manager/Microsoft.Network/stable/2020-11-01/networkInterface.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkInterfaces/{networkInterfaceName}
type NetworkInterfaceList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []NetworkInterface `json:"items"`
}

type NetworkInterface_Spec struct {
	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName string `json:"azureName,omitempty"`

	// DnsSettings: The DNS settings in network interface.
	DnsSettings *NetworkInterfaceDnsSettings `json:"dnsSettings,omitempty"`

	// EnableAcceleratedNetworking: If the network interface is accelerated networking enabled.
	EnableAcceleratedNetworking *bool `json:"enableAcceleratedNetworking,omitempty"`

	// EnableIPForwarding: Indicates whether IP forwarding is enabled on this network interface.
	EnableIPForwarding *bool `json:"enableIPForwarding,omitempty"`

	// ExtendedLocation: The extended location of the network interface.
	ExtendedLocation *ExtendedLocation `json:"extendedLocation,omitempty"`

	// IpConfigurations: A list of IPConfigurations of the network interface.
	IpConfigurations []NetworkInterfaceIPConfiguration_NetworkInterface_SubResourceEmbedded `json:"ipConfigurations,omitempty"`

	// Location: Resource location.
	Location *string `json:"location,omitempty"`

	// NetworkSecurityGroup: The reference to the NetworkSecurityGroup resource.
	NetworkSecurityGroup *NetworkSecurityGroupSpec_NetworkInterface_SubResourceEmbedded `json:"networkSecurityGroup,omitempty"`

	// NicType: Type of Network Interface resource.
	NicType *NetworkInterfacePropertiesFormat_NicType `json:"nicType,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a resources.azure.com/ResourceGroup resource
	Owner *genruntime.KnownResourceReference `group:"resources.azure.com" json:"owner,omitempty" kind:"ResourceGroup"`

	// PrivateLinkService: Privatelinkservice of the network interface resource.
	PrivateLinkService *PrivateLinkServiceSpec `json:"privateLinkService,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`
}

var _ genruntime.ARMTransformer = &NetworkInterface_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (networkInterface *NetworkInterface_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if networkInterface == nil {
		return nil, nil
	}
	result := &NetworkInterface_Spec_ARM{}

	// Set property "ExtendedLocation":
	if networkInterface.ExtendedLocation != nil {
		extendedLocation_ARM, err := (*networkInterface.ExtendedLocation).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		extendedLocation := *extendedLocation_ARM.(*ExtendedLocation_ARM)
		result.ExtendedLocation = &extendedLocation
	}

	// Set property "Location":
	if networkInterface.Location != nil {
		location := *networkInterface.Location
		result.Location = &location
	}

	// Set property "Name":
	result.Name = resolved.Name

	// Set property "Properties":
	if networkInterface.DnsSettings != nil ||
		networkInterface.EnableAcceleratedNetworking != nil ||
		networkInterface.EnableIPForwarding != nil ||
		networkInterface.IpConfigurations != nil ||
		networkInterface.NetworkSecurityGroup != nil ||
		networkInterface.NicType != nil ||
		networkInterface.PrivateLinkService != nil {
		result.Properties = &NetworkInterfacePropertiesFormat_ARM{}
	}
	if networkInterface.DnsSettings != nil {
		dnsSettings_ARM, err := (*networkInterface.DnsSettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		dnsSettings := *dnsSettings_ARM.(*NetworkInterfaceDnsSettings_ARM)
		result.Properties.DnsSettings = &dnsSettings
	}
	if networkInterface.EnableAcceleratedNetworking != nil {
		enableAcceleratedNetworking := *networkInterface.EnableAcceleratedNetworking
		result.Properties.EnableAcceleratedNetworking = &enableAcceleratedNetworking
	}
	if networkInterface.EnableIPForwarding != nil {
		enableIPForwarding := *networkInterface.EnableIPForwarding
		result.Properties.EnableIPForwarding = &enableIPForwarding
	}
	for _, item := range networkInterface.IpConfigurations {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.IpConfigurations = append(result.Properties.IpConfigurations, *item_ARM.(*NetworkInterfaceIPConfiguration_NetworkInterface_SubResourceEmbedded_ARM))
	}
	if networkInterface.NetworkSecurityGroup != nil {
		networkSecurityGroup_ARM, err := (*networkInterface.NetworkSecurityGroup).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		networkSecurityGroup := *networkSecurityGroup_ARM.(*NetworkSecurityGroupSpec_NetworkInterface_SubResourceEmbedded_ARM)
		result.Properties.NetworkSecurityGroup = &networkSecurityGroup
	}
	if networkInterface.NicType != nil {
		nicType := *networkInterface.NicType
		result.Properties.NicType = &nicType
	}
	if networkInterface.PrivateLinkService != nil {
		privateLinkService_ARM, err := (*networkInterface.PrivateLinkService).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		privateLinkService := *privateLinkService_ARM.(*PrivateLinkServiceSpec_ARM)
		result.Properties.PrivateLinkService = &privateLinkService
	}

	// Set property "Tags":
	if networkInterface.Tags != nil {
		result.Tags = make(map[string]string, len(networkInterface.Tags))
		for key, value := range networkInterface.Tags {
			result.Tags[key] = value
		}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (networkInterface *NetworkInterface_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &NetworkInterface_Spec_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (networkInterface *NetworkInterface_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(NetworkInterface_Spec_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected NetworkInterface_Spec_ARM, got %T", armInput)
	}

	// Set property "AzureName":
	networkInterface.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property "DnsSettings":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DnsSettings != nil {
			var dnsSettings1 NetworkInterfaceDnsSettings
			err := dnsSettings1.PopulateFromARM(owner, *typedInput.Properties.DnsSettings)
			if err != nil {
				return err
			}
			dnsSettings := dnsSettings1
			networkInterface.DnsSettings = &dnsSettings
		}
	}

	// Set property "EnableAcceleratedNetworking":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableAcceleratedNetworking != nil {
			enableAcceleratedNetworking := *typedInput.Properties.EnableAcceleratedNetworking
			networkInterface.EnableAcceleratedNetworking = &enableAcceleratedNetworking
		}
	}

	// Set property "EnableIPForwarding":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableIPForwarding != nil {
			enableIPForwarding := *typedInput.Properties.EnableIPForwarding
			networkInterface.EnableIPForwarding = &enableIPForwarding
		}
	}

	// Set property "ExtendedLocation":
	if typedInput.ExtendedLocation != nil {
		var extendedLocation1 ExtendedLocation
		err := extendedLocation1.PopulateFromARM(owner, *typedInput.ExtendedLocation)
		if err != nil {
			return err
		}
		extendedLocation := extendedLocation1
		networkInterface.ExtendedLocation = &extendedLocation
	}

	// Set property "IpConfigurations":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.IpConfigurations {
			var item1 NetworkInterfaceIPConfiguration_NetworkInterface_SubResourceEmbedded
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			networkInterface.IpConfigurations = append(networkInterface.IpConfigurations, item1)
		}
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		networkInterface.Location = &location
	}

	// Set property "NetworkSecurityGroup":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.NetworkSecurityGroup != nil {
			var networkSecurityGroup1 NetworkSecurityGroupSpec_NetworkInterface_SubResourceEmbedded
			err := networkSecurityGroup1.PopulateFromARM(owner, *typedInput.Properties.NetworkSecurityGroup)
			if err != nil {
				return err
			}
			networkSecurityGroup := networkSecurityGroup1
			networkInterface.NetworkSecurityGroup = &networkSecurityGroup
		}
	}

	// Set property "NicType":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.NicType != nil {
			nicType := *typedInput.Properties.NicType
			networkInterface.NicType = &nicType
		}
	}

	// Set property "Owner":
	networkInterface.Owner = &genruntime.KnownResourceReference{
		Name:  owner.Name,
		ARMID: owner.ARMID,
	}

	// Set property "PrivateLinkService":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateLinkService != nil {
			var privateLinkService1 PrivateLinkServiceSpec
			err := privateLinkService1.PopulateFromARM(owner, *typedInput.Properties.PrivateLinkService)
			if err != nil {
				return err
			}
			privateLinkService := privateLinkService1
			networkInterface.PrivateLinkService = &privateLinkService
		}
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		networkInterface.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			networkInterface.Tags[key] = value
		}
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &NetworkInterface_Spec{}

// ConvertSpecFrom populates our NetworkInterface_Spec from the provided source
func (networkInterface *NetworkInterface_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*v20201101s.NetworkInterface_Spec)
	if ok {
		// Populate our instance from source
		return networkInterface.AssignProperties_From_NetworkInterface_Spec(src)
	}

	// Convert to an intermediate form
	src = &v20201101s.NetworkInterface_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = networkInterface.AssignProperties_From_NetworkInterface_Spec(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our NetworkInterface_Spec
func (networkInterface *NetworkInterface_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*v20201101s.NetworkInterface_Spec)
	if ok {
		// Populate destination from our instance
		return networkInterface.AssignProperties_To_NetworkInterface_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &v20201101s.NetworkInterface_Spec{}
	err := networkInterface.AssignProperties_To_NetworkInterface_Spec(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignProperties_From_NetworkInterface_Spec populates our NetworkInterface_Spec from the provided source NetworkInterface_Spec
func (networkInterface *NetworkInterface_Spec) AssignProperties_From_NetworkInterface_Spec(source *v20201101s.NetworkInterface_Spec) error {

	// AzureName
	networkInterface.AzureName = source.AzureName

	// DnsSettings
	if source.DnsSettings != nil {
		var dnsSetting NetworkInterfaceDnsSettings
		err := dnsSetting.AssignProperties_From_NetworkInterfaceDnsSettings(source.DnsSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_NetworkInterfaceDnsSettings() to populate field DnsSettings")
		}
		networkInterface.DnsSettings = &dnsSetting
	} else {
		networkInterface.DnsSettings = nil
	}

	// EnableAcceleratedNetworking
	if source.EnableAcceleratedNetworking != nil {
		enableAcceleratedNetworking := *source.EnableAcceleratedNetworking
		networkInterface.EnableAcceleratedNetworking = &enableAcceleratedNetworking
	} else {
		networkInterface.EnableAcceleratedNetworking = nil
	}

	// EnableIPForwarding
	if source.EnableIPForwarding != nil {
		enableIPForwarding := *source.EnableIPForwarding
		networkInterface.EnableIPForwarding = &enableIPForwarding
	} else {
		networkInterface.EnableIPForwarding = nil
	}

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocation ExtendedLocation
		err := extendedLocation.AssignProperties_From_ExtendedLocation(source.ExtendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ExtendedLocation() to populate field ExtendedLocation")
		}
		networkInterface.ExtendedLocation = &extendedLocation
	} else {
		networkInterface.ExtendedLocation = nil
	}

	// IpConfigurations
	if source.IpConfigurations != nil {
		ipConfigurationList := make([]NetworkInterfaceIPConfiguration_NetworkInterface_SubResourceEmbedded, len(source.IpConfigurations))
		for ipConfigurationIndex, ipConfigurationItem := range source.IpConfigurations {
			// Shadow the loop variable to avoid aliasing
			ipConfigurationItem := ipConfigurationItem
			var ipConfiguration NetworkInterfaceIPConfiguration_NetworkInterface_SubResourceEmbedded
			err := ipConfiguration.AssignProperties_From_NetworkInterfaceIPConfiguration_NetworkInterface_SubResourceEmbedded(&ipConfigurationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_NetworkInterfaceIPConfiguration_NetworkInterface_SubResourceEmbedded() to populate field IpConfigurations")
			}
			ipConfigurationList[ipConfigurationIndex] = ipConfiguration
		}
		networkInterface.IpConfigurations = ipConfigurationList
	} else {
		networkInterface.IpConfigurations = nil
	}

	// Location
	networkInterface.Location = genruntime.ClonePointerToString(source.Location)

	// NetworkSecurityGroup
	if source.NetworkSecurityGroup != nil {
		var networkSecurityGroup NetworkSecurityGroupSpec_NetworkInterface_SubResourceEmbedded
		err := networkSecurityGroup.AssignProperties_From_NetworkSecurityGroupSpec_NetworkInterface_SubResourceEmbedded(source.NetworkSecurityGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_NetworkSecurityGroupSpec_NetworkInterface_SubResourceEmbedded() to populate field NetworkSecurityGroup")
		}
		networkInterface.NetworkSecurityGroup = &networkSecurityGroup
	} else {
		networkInterface.NetworkSecurityGroup = nil
	}

	// NicType
	if source.NicType != nil {
		nicType := NetworkInterfacePropertiesFormat_NicType(*source.NicType)
		networkInterface.NicType = &nicType
	} else {
		networkInterface.NicType = nil
	}

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		networkInterface.Owner = &owner
	} else {
		networkInterface.Owner = nil
	}

	// PrivateLinkService
	if source.PrivateLinkService != nil {
		var privateLinkService PrivateLinkServiceSpec
		err := privateLinkService.AssignProperties_From_PrivateLinkServiceSpec(source.PrivateLinkService)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_PrivateLinkServiceSpec() to populate field PrivateLinkService")
		}
		networkInterface.PrivateLinkService = &privateLinkService
	} else {
		networkInterface.PrivateLinkService = nil
	}

	// Tags
	networkInterface.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// No error
	return nil
}

// AssignProperties_To_NetworkInterface_Spec populates the provided destination NetworkInterface_Spec from our NetworkInterface_Spec
func (networkInterface *NetworkInterface_Spec) AssignProperties_To_NetworkInterface_Spec(destination *v20201101s.NetworkInterface_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureName
	destination.AzureName = networkInterface.AzureName

	// DnsSettings
	if networkInterface.DnsSettings != nil {
		var dnsSetting v20201101s.NetworkInterfaceDnsSettings
		err := networkInterface.DnsSettings.AssignProperties_To_NetworkInterfaceDnsSettings(&dnsSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_NetworkInterfaceDnsSettings() to populate field DnsSettings")
		}
		destination.DnsSettings = &dnsSetting
	} else {
		destination.DnsSettings = nil
	}

	// EnableAcceleratedNetworking
	if networkInterface.EnableAcceleratedNetworking != nil {
		enableAcceleratedNetworking := *networkInterface.EnableAcceleratedNetworking
		destination.EnableAcceleratedNetworking = &enableAcceleratedNetworking
	} else {
		destination.EnableAcceleratedNetworking = nil
	}

	// EnableIPForwarding
	if networkInterface.EnableIPForwarding != nil {
		enableIPForwarding := *networkInterface.EnableIPForwarding
		destination.EnableIPForwarding = &enableIPForwarding
	} else {
		destination.EnableIPForwarding = nil
	}

	// ExtendedLocation
	if networkInterface.ExtendedLocation != nil {
		var extendedLocation v20201101s.ExtendedLocation
		err := networkInterface.ExtendedLocation.AssignProperties_To_ExtendedLocation(&extendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ExtendedLocation() to populate field ExtendedLocation")
		}
		destination.ExtendedLocation = &extendedLocation
	} else {
		destination.ExtendedLocation = nil
	}

	// IpConfigurations
	if networkInterface.IpConfigurations != nil {
		ipConfigurationList := make([]v20201101s.NetworkInterfaceIPConfiguration_NetworkInterface_SubResourceEmbedded, len(networkInterface.IpConfigurations))
		for ipConfigurationIndex, ipConfigurationItem := range networkInterface.IpConfigurations {
			// Shadow the loop variable to avoid aliasing
			ipConfigurationItem := ipConfigurationItem
			var ipConfiguration v20201101s.NetworkInterfaceIPConfiguration_NetworkInterface_SubResourceEmbedded
			err := ipConfigurationItem.AssignProperties_To_NetworkInterfaceIPConfiguration_NetworkInterface_SubResourceEmbedded(&ipConfiguration)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_NetworkInterfaceIPConfiguration_NetworkInterface_SubResourceEmbedded() to populate field IpConfigurations")
			}
			ipConfigurationList[ipConfigurationIndex] = ipConfiguration
		}
		destination.IpConfigurations = ipConfigurationList
	} else {
		destination.IpConfigurations = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(networkInterface.Location)

	// NetworkSecurityGroup
	if networkInterface.NetworkSecurityGroup != nil {
		var networkSecurityGroup v20201101s.NetworkSecurityGroupSpec_NetworkInterface_SubResourceEmbedded
		err := networkInterface.NetworkSecurityGroup.AssignProperties_To_NetworkSecurityGroupSpec_NetworkInterface_SubResourceEmbedded(&networkSecurityGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_NetworkSecurityGroupSpec_NetworkInterface_SubResourceEmbedded() to populate field NetworkSecurityGroup")
		}
		destination.NetworkSecurityGroup = &networkSecurityGroup
	} else {
		destination.NetworkSecurityGroup = nil
	}

	// NicType
	if networkInterface.NicType != nil {
		nicType := string(*networkInterface.NicType)
		destination.NicType = &nicType
	} else {
		destination.NicType = nil
	}

	// OriginalVersion
	destination.OriginalVersion = networkInterface.OriginalVersion()

	// Owner
	if networkInterface.Owner != nil {
		owner := networkInterface.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// PrivateLinkService
	if networkInterface.PrivateLinkService != nil {
		var privateLinkService v20201101s.PrivateLinkServiceSpec
		err := networkInterface.PrivateLinkService.AssignProperties_To_PrivateLinkServiceSpec(&privateLinkService)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_PrivateLinkServiceSpec() to populate field PrivateLinkService")
		}
		destination.PrivateLinkService = &privateLinkService
	} else {
		destination.PrivateLinkService = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(networkInterface.Tags)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_NetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded populates our NetworkInterface_Spec from the provided source NetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded
func (networkInterface *NetworkInterface_Spec) Initialize_From_NetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded(source *NetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded) error {

	// DnsSettings
	if source.DnsSettings != nil {
		var dnsSetting NetworkInterfaceDnsSettings
		err := dnsSetting.Initialize_From_NetworkInterfaceDnsSettings_STATUS(source.DnsSettings)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_NetworkInterfaceDnsSettings_STATUS() to populate field DnsSettings")
		}
		networkInterface.DnsSettings = &dnsSetting
	} else {
		networkInterface.DnsSettings = nil
	}

	// EnableAcceleratedNetworking
	if source.EnableAcceleratedNetworking != nil {
		enableAcceleratedNetworking := *source.EnableAcceleratedNetworking
		networkInterface.EnableAcceleratedNetworking = &enableAcceleratedNetworking
	} else {
		networkInterface.EnableAcceleratedNetworking = nil
	}

	// EnableIPForwarding
	if source.EnableIPForwarding != nil {
		enableIPForwarding := *source.EnableIPForwarding
		networkInterface.EnableIPForwarding = &enableIPForwarding
	} else {
		networkInterface.EnableIPForwarding = nil
	}

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocation ExtendedLocation
		err := extendedLocation.Initialize_From_ExtendedLocation_STATUS(source.ExtendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_ExtendedLocation_STATUS() to populate field ExtendedLocation")
		}
		networkInterface.ExtendedLocation = &extendedLocation
	} else {
		networkInterface.ExtendedLocation = nil
	}

	// IpConfigurations
	if source.IpConfigurations != nil {
		ipConfigurationList := make([]NetworkInterfaceIPConfiguration_NetworkInterface_SubResourceEmbedded, len(source.IpConfigurations))
		for ipConfigurationIndex, ipConfigurationItem := range source.IpConfigurations {
			// Shadow the loop variable to avoid aliasing
			ipConfigurationItem := ipConfigurationItem
			var ipConfiguration NetworkInterfaceIPConfiguration_NetworkInterface_SubResourceEmbedded
			err := ipConfiguration.Initialize_From_NetworkInterfaceIPConfiguration_STATUS_NetworkInterface_SubResourceEmbedded(&ipConfigurationItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_NetworkInterfaceIPConfiguration_STATUS_NetworkInterface_SubResourceEmbedded() to populate field IpConfigurations")
			}
			ipConfigurationList[ipConfigurationIndex] = ipConfiguration
		}
		networkInterface.IpConfigurations = ipConfigurationList
	} else {
		networkInterface.IpConfigurations = nil
	}

	// Location
	networkInterface.Location = genruntime.ClonePointerToString(source.Location)

	// NetworkSecurityGroup
	if source.NetworkSecurityGroup != nil {
		var networkSecurityGroup NetworkSecurityGroupSpec_NetworkInterface_SubResourceEmbedded
		err := networkSecurityGroup.Initialize_From_NetworkSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded(source.NetworkSecurityGroup)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_NetworkSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded() to populate field NetworkSecurityGroup")
		}
		networkInterface.NetworkSecurityGroup = &networkSecurityGroup
	} else {
		networkInterface.NetworkSecurityGroup = nil
	}

	// NicType
	if source.NicType != nil {
		nicType := NetworkInterfacePropertiesFormat_NicType(*source.NicType)
		networkInterface.NicType = &nicType
	} else {
		networkInterface.NicType = nil
	}

	// PrivateLinkService
	if source.PrivateLinkService != nil {
		var privateLinkService PrivateLinkServiceSpec
		err := privateLinkService.Initialize_From_PrivateLinkService_STATUS_NetworkInterface_SubResourceEmbedded(source.PrivateLinkService)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_PrivateLinkService_STATUS_NetworkInterface_SubResourceEmbedded() to populate field PrivateLinkService")
		}
		networkInterface.PrivateLinkService = &privateLinkService
	} else {
		networkInterface.PrivateLinkService = nil
	}

	// Tags
	networkInterface.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (networkInterface *NetworkInterface_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (networkInterface *NetworkInterface_Spec) SetAzureName(azureName string) {
	networkInterface.AzureName = azureName
}

// A network interface in a resource group.
type NetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded struct {
	// Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	// DnsSettings: The DNS settings in network interface.
	DnsSettings *NetworkInterfaceDnsSettings_STATUS `json:"dnsSettings,omitempty"`

	// DscpConfiguration: A reference to the dscp configuration to which the network interface is linked.
	DscpConfiguration *SubResource_STATUS `json:"dscpConfiguration,omitempty"`

	// EnableAcceleratedNetworking: If the network interface is accelerated networking enabled.
	EnableAcceleratedNetworking *bool `json:"enableAcceleratedNetworking,omitempty"`

	// EnableIPForwarding: Indicates whether IP forwarding is enabled on this network interface.
	EnableIPForwarding *bool `json:"enableIPForwarding,omitempty"`

	// Etag: A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`

	// ExtendedLocation: The extended location of the network interface.
	ExtendedLocation *ExtendedLocation_STATUS `json:"extendedLocation,omitempty"`

	// HostedWorkloads: A list of references to linked BareMetal resources.
	HostedWorkloads []string `json:"hostedWorkloads,omitempty"`

	// Id: Resource ID.
	Id *string `json:"id,omitempty"`

	// IpConfigurations: A list of IPConfigurations of the network interface.
	IpConfigurations []NetworkInterfaceIPConfiguration_STATUS_NetworkInterface_SubResourceEmbedded `json:"ipConfigurations,omitempty"`

	// Location: Resource location.
	Location *string `json:"location,omitempty"`

	// MacAddress: The MAC address of the network interface.
	MacAddress *string `json:"macAddress,omitempty"`

	// MigrationPhase: Migration phase of Network Interface resource.
	MigrationPhase *NetworkInterfacePropertiesFormat_MigrationPhase_STATUS `json:"migrationPhase,omitempty"`

	// Name: Resource name.
	Name *string `json:"name,omitempty"`

	// NetworkSecurityGroup: The reference to the NetworkSecurityGroup resource.
	NetworkSecurityGroup *NetworkSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded `json:"networkSecurityGroup,omitempty"`

	// NicType: Type of Network Interface resource.
	NicType *NetworkInterfacePropertiesFormat_NicType_STATUS `json:"nicType,omitempty"`

	// Primary: Whether this is a primary network interface on a virtual machine.
	Primary *bool `json:"primary,omitempty"`

	// PrivateEndpoint: A reference to the private endpoint to which the network interface is linked.
	PrivateEndpoint *PrivateEndpoint_STATUS_NetworkInterface_SubResourceEmbedded `json:"privateEndpoint,omitempty"`

	// PrivateLinkService: Privatelinkservice of the network interface resource.
	PrivateLinkService *PrivateLinkService_STATUS_NetworkInterface_SubResourceEmbedded `json:"privateLinkService,omitempty"`

	// ProvisioningState: The provisioning state of the network interface resource.
	ProvisioningState *ProvisioningState_STATUS `json:"provisioningState,omitempty"`

	// ResourceGuid: The resource GUID property of the network interface resource.
	ResourceGuid *string `json:"resourceGuid,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`

	// TapConfigurations: A list of TapConfigurations of the network interface.
	TapConfigurations []NetworkInterfaceTapConfiguration_STATUS_NetworkInterface_SubResourceEmbedded `json:"tapConfigurations,omitempty"`

	// Type: Resource type.
	Type *string `json:"type,omitempty"`

	// VirtualMachine: The reference to a virtual machine.
	VirtualMachine *SubResource_STATUS `json:"virtualMachine,omitempty"`
}

var _ genruntime.ConvertibleStatus = &NetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded{}

// ConvertStatusFrom populates our NetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded from the provided source
func (embedded *NetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*v20201101s.NetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded)
	if ok {
		// Populate our instance from source
		return embedded.AssignProperties_From_NetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded(src)
	}

	// Convert to an intermediate form
	src = &v20201101s.NetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = embedded.AssignProperties_From_NetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our NetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded
func (embedded *NetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*v20201101s.NetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded)
	if ok {
		// Populate destination from our instance
		return embedded.AssignProperties_To_NetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded(dst)
	}

	// Convert to an intermediate form
	dst = &v20201101s.NetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded{}
	err := embedded.AssignProperties_To_NetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &NetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (embedded *NetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &NetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (embedded *NetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(NetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected NetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded_ARM, got %T", armInput)
	}

	// no assignment for property "Conditions"

	// Set property "DnsSettings":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DnsSettings != nil {
			var dnsSettings1 NetworkInterfaceDnsSettings_STATUS
			err := dnsSettings1.PopulateFromARM(owner, *typedInput.Properties.DnsSettings)
			if err != nil {
				return err
			}
			dnsSettings := dnsSettings1
			embedded.DnsSettings = &dnsSettings
		}
	}

	// Set property "DscpConfiguration":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DscpConfiguration != nil {
			var dscpConfiguration1 SubResource_STATUS
			err := dscpConfiguration1.PopulateFromARM(owner, *typedInput.Properties.DscpConfiguration)
			if err != nil {
				return err
			}
			dscpConfiguration := dscpConfiguration1
			embedded.DscpConfiguration = &dscpConfiguration
		}
	}

	// Set property "EnableAcceleratedNetworking":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableAcceleratedNetworking != nil {
			enableAcceleratedNetworking := *typedInput.Properties.EnableAcceleratedNetworking
			embedded.EnableAcceleratedNetworking = &enableAcceleratedNetworking
		}
	}

	// Set property "EnableIPForwarding":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableIPForwarding != nil {
			enableIPForwarding := *typedInput.Properties.EnableIPForwarding
			embedded.EnableIPForwarding = &enableIPForwarding
		}
	}

	// Set property "Etag":
	if typedInput.Etag != nil {
		etag := *typedInput.Etag
		embedded.Etag = &etag
	}

	// Set property "ExtendedLocation":
	if typedInput.ExtendedLocation != nil {
		var extendedLocation1 ExtendedLocation_STATUS
		err := extendedLocation1.PopulateFromARM(owner, *typedInput.ExtendedLocation)
		if err != nil {
			return err
		}
		extendedLocation := extendedLocation1
		embedded.ExtendedLocation = &extendedLocation
	}

	// Set property "HostedWorkloads":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.HostedWorkloads {
			embedded.HostedWorkloads = append(embedded.HostedWorkloads, item)
		}
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		embedded.Id = &id
	}

	// Set property "IpConfigurations":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.IpConfigurations {
			var item1 NetworkInterfaceIPConfiguration_STATUS_NetworkInterface_SubResourceEmbedded
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			embedded.IpConfigurations = append(embedded.IpConfigurations, item1)
		}
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		embedded.Location = &location
	}

	// Set property "MacAddress":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MacAddress != nil {
			macAddress := *typedInput.Properties.MacAddress
			embedded.MacAddress = &macAddress
		}
	}

	// Set property "MigrationPhase":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MigrationPhase != nil {
			migrationPhase := *typedInput.Properties.MigrationPhase
			embedded.MigrationPhase = &migrationPhase
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		embedded.Name = &name
	}

	// Set property "NetworkSecurityGroup":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.NetworkSecurityGroup != nil {
			var networkSecurityGroup1 NetworkSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded
			err := networkSecurityGroup1.PopulateFromARM(owner, *typedInput.Properties.NetworkSecurityGroup)
			if err != nil {
				return err
			}
			networkSecurityGroup := networkSecurityGroup1
			embedded.NetworkSecurityGroup = &networkSecurityGroup
		}
	}

	// Set property "NicType":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.NicType != nil {
			nicType := *typedInput.Properties.NicType
			embedded.NicType = &nicType
		}
	}

	// Set property "Primary":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Primary != nil {
			primary := *typedInput.Properties.Primary
			embedded.Primary = &primary
		}
	}

	// Set property "PrivateEndpoint":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateEndpoint != nil {
			var privateEndpoint1 PrivateEndpoint_STATUS_NetworkInterface_SubResourceEmbedded
			err := privateEndpoint1.PopulateFromARM(owner, *typedInput.Properties.PrivateEndpoint)
			if err != nil {
				return err
			}
			privateEndpoint := privateEndpoint1
			embedded.PrivateEndpoint = &privateEndpoint
		}
	}

	// Set property "PrivateLinkService":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateLinkService != nil {
			var privateLinkService1 PrivateLinkService_STATUS_NetworkInterface_SubResourceEmbedded
			err := privateLinkService1.PopulateFromARM(owner, *typedInput.Properties.PrivateLinkService)
			if err != nil {
				return err
			}
			privateLinkService := privateLinkService1
			embedded.PrivateLinkService = &privateLinkService
		}
	}

	// Set property "ProvisioningState":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			provisioningState := *typedInput.Properties.ProvisioningState
			embedded.ProvisioningState = &provisioningState
		}
	}

	// Set property "ResourceGuid":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ResourceGuid != nil {
			resourceGuid := *typedInput.Properties.ResourceGuid
			embedded.ResourceGuid = &resourceGuid
		}
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		embedded.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			embedded.Tags[key] = value
		}
	}

	// Set property "TapConfigurations":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.TapConfigurations {
			var item1 NetworkInterfaceTapConfiguration_STATUS_NetworkInterface_SubResourceEmbedded
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			embedded.TapConfigurations = append(embedded.TapConfigurations, item1)
		}
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		embedded.Type = &typeVar
	}

	// Set property "VirtualMachine":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.VirtualMachine != nil {
			var virtualMachine1 SubResource_STATUS
			err := virtualMachine1.PopulateFromARM(owner, *typedInput.Properties.VirtualMachine)
			if err != nil {
				return err
			}
			virtualMachine := virtualMachine1
			embedded.VirtualMachine = &virtualMachine
		}
	}

	// No error
	return nil
}

// AssignProperties_From_NetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded populates our NetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded from the provided source NetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded
func (embedded *NetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded) AssignProperties_From_NetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded(source *v20201101s.NetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded) error {

	// Conditions
	embedded.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// DnsSettings
	if source.DnsSettings != nil {
		var dnsSetting NetworkInterfaceDnsSettings_STATUS
		err := dnsSetting.AssignProperties_From_NetworkInterfaceDnsSettings_STATUS(source.DnsSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_NetworkInterfaceDnsSettings_STATUS() to populate field DnsSettings")
		}
		embedded.DnsSettings = &dnsSetting
	} else {
		embedded.DnsSettings = nil
	}

	// DscpConfiguration
	if source.DscpConfiguration != nil {
		var dscpConfiguration SubResource_STATUS
		err := dscpConfiguration.AssignProperties_From_SubResource_STATUS(source.DscpConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field DscpConfiguration")
		}
		embedded.DscpConfiguration = &dscpConfiguration
	} else {
		embedded.DscpConfiguration = nil
	}

	// EnableAcceleratedNetworking
	if source.EnableAcceleratedNetworking != nil {
		enableAcceleratedNetworking := *source.EnableAcceleratedNetworking
		embedded.EnableAcceleratedNetworking = &enableAcceleratedNetworking
	} else {
		embedded.EnableAcceleratedNetworking = nil
	}

	// EnableIPForwarding
	if source.EnableIPForwarding != nil {
		enableIPForwarding := *source.EnableIPForwarding
		embedded.EnableIPForwarding = &enableIPForwarding
	} else {
		embedded.EnableIPForwarding = nil
	}

	// Etag
	embedded.Etag = genruntime.ClonePointerToString(source.Etag)

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocation ExtendedLocation_STATUS
		err := extendedLocation.AssignProperties_From_ExtendedLocation_STATUS(source.ExtendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ExtendedLocation_STATUS() to populate field ExtendedLocation")
		}
		embedded.ExtendedLocation = &extendedLocation
	} else {
		embedded.ExtendedLocation = nil
	}

	// HostedWorkloads
	embedded.HostedWorkloads = genruntime.CloneSliceOfString(source.HostedWorkloads)

	// Id
	embedded.Id = genruntime.ClonePointerToString(source.Id)

	// IpConfigurations
	if source.IpConfigurations != nil {
		ipConfigurationList := make([]NetworkInterfaceIPConfiguration_STATUS_NetworkInterface_SubResourceEmbedded, len(source.IpConfigurations))
		for ipConfigurationIndex, ipConfigurationItem := range source.IpConfigurations {
			// Shadow the loop variable to avoid aliasing
			ipConfigurationItem := ipConfigurationItem
			var ipConfiguration NetworkInterfaceIPConfiguration_STATUS_NetworkInterface_SubResourceEmbedded
			err := ipConfiguration.AssignProperties_From_NetworkInterfaceIPConfiguration_STATUS_NetworkInterface_SubResourceEmbedded(&ipConfigurationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_NetworkInterfaceIPConfiguration_STATUS_NetworkInterface_SubResourceEmbedded() to populate field IpConfigurations")
			}
			ipConfigurationList[ipConfigurationIndex] = ipConfiguration
		}
		embedded.IpConfigurations = ipConfigurationList
	} else {
		embedded.IpConfigurations = nil
	}

	// Location
	embedded.Location = genruntime.ClonePointerToString(source.Location)

	// MacAddress
	embedded.MacAddress = genruntime.ClonePointerToString(source.MacAddress)

	// MigrationPhase
	if source.MigrationPhase != nil {
		migrationPhase := NetworkInterfacePropertiesFormat_MigrationPhase_STATUS(*source.MigrationPhase)
		embedded.MigrationPhase = &migrationPhase
	} else {
		embedded.MigrationPhase = nil
	}

	// Name
	embedded.Name = genruntime.ClonePointerToString(source.Name)

	// NetworkSecurityGroup
	if source.NetworkSecurityGroup != nil {
		var networkSecurityGroup NetworkSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded
		err := networkSecurityGroup.AssignProperties_From_NetworkSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded(source.NetworkSecurityGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_NetworkSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded() to populate field NetworkSecurityGroup")
		}
		embedded.NetworkSecurityGroup = &networkSecurityGroup
	} else {
		embedded.NetworkSecurityGroup = nil
	}

	// NicType
	if source.NicType != nil {
		nicType := NetworkInterfacePropertiesFormat_NicType_STATUS(*source.NicType)
		embedded.NicType = &nicType
	} else {
		embedded.NicType = nil
	}

	// Primary
	if source.Primary != nil {
		primary := *source.Primary
		embedded.Primary = &primary
	} else {
		embedded.Primary = nil
	}

	// PrivateEndpoint
	if source.PrivateEndpoint != nil {
		var privateEndpoint PrivateEndpoint_STATUS_NetworkInterface_SubResourceEmbedded
		err := privateEndpoint.AssignProperties_From_PrivateEndpoint_STATUS_NetworkInterface_SubResourceEmbedded(source.PrivateEndpoint)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_PrivateEndpoint_STATUS_NetworkInterface_SubResourceEmbedded() to populate field PrivateEndpoint")
		}
		embedded.PrivateEndpoint = &privateEndpoint
	} else {
		embedded.PrivateEndpoint = nil
	}

	// PrivateLinkService
	if source.PrivateLinkService != nil {
		var privateLinkService PrivateLinkService_STATUS_NetworkInterface_SubResourceEmbedded
		err := privateLinkService.AssignProperties_From_PrivateLinkService_STATUS_NetworkInterface_SubResourceEmbedded(source.PrivateLinkService)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_PrivateLinkService_STATUS_NetworkInterface_SubResourceEmbedded() to populate field PrivateLinkService")
		}
		embedded.PrivateLinkService = &privateLinkService
	} else {
		embedded.PrivateLinkService = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := ProvisioningState_STATUS(*source.ProvisioningState)
		embedded.ProvisioningState = &provisioningState
	} else {
		embedded.ProvisioningState = nil
	}

	// ResourceGuid
	embedded.ResourceGuid = genruntime.ClonePointerToString(source.ResourceGuid)

	// Tags
	embedded.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// TapConfigurations
	if source.TapConfigurations != nil {
		tapConfigurationList := make([]NetworkInterfaceTapConfiguration_STATUS_NetworkInterface_SubResourceEmbedded, len(source.TapConfigurations))
		for tapConfigurationIndex, tapConfigurationItem := range source.TapConfigurations {
			// Shadow the loop variable to avoid aliasing
			tapConfigurationItem := tapConfigurationItem
			var tapConfiguration NetworkInterfaceTapConfiguration_STATUS_NetworkInterface_SubResourceEmbedded
			err := tapConfiguration.AssignProperties_From_NetworkInterfaceTapConfiguration_STATUS_NetworkInterface_SubResourceEmbedded(&tapConfigurationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_NetworkInterfaceTapConfiguration_STATUS_NetworkInterface_SubResourceEmbedded() to populate field TapConfigurations")
			}
			tapConfigurationList[tapConfigurationIndex] = tapConfiguration
		}
		embedded.TapConfigurations = tapConfigurationList
	} else {
		embedded.TapConfigurations = nil
	}

	// Type
	embedded.Type = genruntime.ClonePointerToString(source.Type)

	// VirtualMachine
	if source.VirtualMachine != nil {
		var virtualMachine SubResource_STATUS
		err := virtualMachine.AssignProperties_From_SubResource_STATUS(source.VirtualMachine)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field VirtualMachine")
		}
		embedded.VirtualMachine = &virtualMachine
	} else {
		embedded.VirtualMachine = nil
	}

	// No error
	return nil
}

// AssignProperties_To_NetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded populates the provided destination NetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded from our NetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded
func (embedded *NetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded) AssignProperties_To_NetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded(destination *v20201101s.NetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(embedded.Conditions)

	// DnsSettings
	if embedded.DnsSettings != nil {
		var dnsSetting v20201101s.NetworkInterfaceDnsSettings_STATUS
		err := embedded.DnsSettings.AssignProperties_To_NetworkInterfaceDnsSettings_STATUS(&dnsSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_NetworkInterfaceDnsSettings_STATUS() to populate field DnsSettings")
		}
		destination.DnsSettings = &dnsSetting
	} else {
		destination.DnsSettings = nil
	}

	// DscpConfiguration
	if embedded.DscpConfiguration != nil {
		var dscpConfiguration v20201101s.SubResource_STATUS
		err := embedded.DscpConfiguration.AssignProperties_To_SubResource_STATUS(&dscpConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field DscpConfiguration")
		}
		destination.DscpConfiguration = &dscpConfiguration
	} else {
		destination.DscpConfiguration = nil
	}

	// EnableAcceleratedNetworking
	if embedded.EnableAcceleratedNetworking != nil {
		enableAcceleratedNetworking := *embedded.EnableAcceleratedNetworking
		destination.EnableAcceleratedNetworking = &enableAcceleratedNetworking
	} else {
		destination.EnableAcceleratedNetworking = nil
	}

	// EnableIPForwarding
	if embedded.EnableIPForwarding != nil {
		enableIPForwarding := *embedded.EnableIPForwarding
		destination.EnableIPForwarding = &enableIPForwarding
	} else {
		destination.EnableIPForwarding = nil
	}

	// Etag
	destination.Etag = genruntime.ClonePointerToString(embedded.Etag)

	// ExtendedLocation
	if embedded.ExtendedLocation != nil {
		var extendedLocation v20201101s.ExtendedLocation_STATUS
		err := embedded.ExtendedLocation.AssignProperties_To_ExtendedLocation_STATUS(&extendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ExtendedLocation_STATUS() to populate field ExtendedLocation")
		}
		destination.ExtendedLocation = &extendedLocation
	} else {
		destination.ExtendedLocation = nil
	}

	// HostedWorkloads
	destination.HostedWorkloads = genruntime.CloneSliceOfString(embedded.HostedWorkloads)

	// Id
	destination.Id = genruntime.ClonePointerToString(embedded.Id)

	// IpConfigurations
	if embedded.IpConfigurations != nil {
		ipConfigurationList := make([]v20201101s.NetworkInterfaceIPConfiguration_STATUS_NetworkInterface_SubResourceEmbedded, len(embedded.IpConfigurations))
		for ipConfigurationIndex, ipConfigurationItem := range embedded.IpConfigurations {
			// Shadow the loop variable to avoid aliasing
			ipConfigurationItem := ipConfigurationItem
			var ipConfiguration v20201101s.NetworkInterfaceIPConfiguration_STATUS_NetworkInterface_SubResourceEmbedded
			err := ipConfigurationItem.AssignProperties_To_NetworkInterfaceIPConfiguration_STATUS_NetworkInterface_SubResourceEmbedded(&ipConfiguration)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_NetworkInterfaceIPConfiguration_STATUS_NetworkInterface_SubResourceEmbedded() to populate field IpConfigurations")
			}
			ipConfigurationList[ipConfigurationIndex] = ipConfiguration
		}
		destination.IpConfigurations = ipConfigurationList
	} else {
		destination.IpConfigurations = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(embedded.Location)

	// MacAddress
	destination.MacAddress = genruntime.ClonePointerToString(embedded.MacAddress)

	// MigrationPhase
	if embedded.MigrationPhase != nil {
		migrationPhase := string(*embedded.MigrationPhase)
		destination.MigrationPhase = &migrationPhase
	} else {
		destination.MigrationPhase = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(embedded.Name)

	// NetworkSecurityGroup
	if embedded.NetworkSecurityGroup != nil {
		var networkSecurityGroup v20201101s.NetworkSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded
		err := embedded.NetworkSecurityGroup.AssignProperties_To_NetworkSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded(&networkSecurityGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_NetworkSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded() to populate field NetworkSecurityGroup")
		}
		destination.NetworkSecurityGroup = &networkSecurityGroup
	} else {
		destination.NetworkSecurityGroup = nil
	}

	// NicType
	if embedded.NicType != nil {
		nicType := string(*embedded.NicType)
		destination.NicType = &nicType
	} else {
		destination.NicType = nil
	}

	// Primary
	if embedded.Primary != nil {
		primary := *embedded.Primary
		destination.Primary = &primary
	} else {
		destination.Primary = nil
	}

	// PrivateEndpoint
	if embedded.PrivateEndpoint != nil {
		var privateEndpoint v20201101s.PrivateEndpoint_STATUS_NetworkInterface_SubResourceEmbedded
		err := embedded.PrivateEndpoint.AssignProperties_To_PrivateEndpoint_STATUS_NetworkInterface_SubResourceEmbedded(&privateEndpoint)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_PrivateEndpoint_STATUS_NetworkInterface_SubResourceEmbedded() to populate field PrivateEndpoint")
		}
		destination.PrivateEndpoint = &privateEndpoint
	} else {
		destination.PrivateEndpoint = nil
	}

	// PrivateLinkService
	if embedded.PrivateLinkService != nil {
		var privateLinkService v20201101s.PrivateLinkService_STATUS_NetworkInterface_SubResourceEmbedded
		err := embedded.PrivateLinkService.AssignProperties_To_PrivateLinkService_STATUS_NetworkInterface_SubResourceEmbedded(&privateLinkService)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_PrivateLinkService_STATUS_NetworkInterface_SubResourceEmbedded() to populate field PrivateLinkService")
		}
		destination.PrivateLinkService = &privateLinkService
	} else {
		destination.PrivateLinkService = nil
	}

	// ProvisioningState
	if embedded.ProvisioningState != nil {
		provisioningState := string(*embedded.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// ResourceGuid
	destination.ResourceGuid = genruntime.ClonePointerToString(embedded.ResourceGuid)

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(embedded.Tags)

	// TapConfigurations
	if embedded.TapConfigurations != nil {
		tapConfigurationList := make([]v20201101s.NetworkInterfaceTapConfiguration_STATUS_NetworkInterface_SubResourceEmbedded, len(embedded.TapConfigurations))
		for tapConfigurationIndex, tapConfigurationItem := range embedded.TapConfigurations {
			// Shadow the loop variable to avoid aliasing
			tapConfigurationItem := tapConfigurationItem
			var tapConfiguration v20201101s.NetworkInterfaceTapConfiguration_STATUS_NetworkInterface_SubResourceEmbedded
			err := tapConfigurationItem.AssignProperties_To_NetworkInterfaceTapConfiguration_STATUS_NetworkInterface_SubResourceEmbedded(&tapConfiguration)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_NetworkInterfaceTapConfiguration_STATUS_NetworkInterface_SubResourceEmbedded() to populate field TapConfigurations")
			}
			tapConfigurationList[tapConfigurationIndex] = tapConfiguration
		}
		destination.TapConfigurations = tapConfigurationList
	} else {
		destination.TapConfigurations = nil
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(embedded.Type)

	// VirtualMachine
	if embedded.VirtualMachine != nil {
		var virtualMachine v20201101s.SubResource_STATUS
		err := embedded.VirtualMachine.AssignProperties_To_SubResource_STATUS(&virtualMachine)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field VirtualMachine")
		}
		destination.VirtualMachine = &virtualMachine
	} else {
		destination.VirtualMachine = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// DNS settings of a network interface.
type NetworkInterfaceDnsSettings struct {
	// DnsServers: List of DNS servers IP addresses. Use 'AzureProvidedDNS' to switch to azure provided DNS resolution.
	// 'AzureProvidedDNS' value cannot be combined with other IPs, it must be the only value in dnsServers collection.
	DnsServers []string `json:"dnsServers,omitempty"`

	// InternalDnsNameLabel: Relative DNS name for this NIC used for internal communications between VMs in the same virtual
	// network.
	InternalDnsNameLabel *string `json:"internalDnsNameLabel,omitempty"`
}

var _ genruntime.ARMTransformer = &NetworkInterfaceDnsSettings{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (settings *NetworkInterfaceDnsSettings) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if settings == nil {
		return nil, nil
	}
	result := &NetworkInterfaceDnsSettings_ARM{}

	// Set property "DnsServers":
	for _, item := range settings.DnsServers {
		result.DnsServers = append(result.DnsServers, item)
	}

	// Set property "InternalDnsNameLabel":
	if settings.InternalDnsNameLabel != nil {
		internalDnsNameLabel := *settings.InternalDnsNameLabel
		result.InternalDnsNameLabel = &internalDnsNameLabel
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *NetworkInterfaceDnsSettings) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &NetworkInterfaceDnsSettings_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *NetworkInterfaceDnsSettings) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(NetworkInterfaceDnsSettings_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected NetworkInterfaceDnsSettings_ARM, got %T", armInput)
	}

	// Set property "DnsServers":
	for _, item := range typedInput.DnsServers {
		settings.DnsServers = append(settings.DnsServers, item)
	}

	// Set property "InternalDnsNameLabel":
	if typedInput.InternalDnsNameLabel != nil {
		internalDnsNameLabel := *typedInput.InternalDnsNameLabel
		settings.InternalDnsNameLabel = &internalDnsNameLabel
	}

	// No error
	return nil
}

// AssignProperties_From_NetworkInterfaceDnsSettings populates our NetworkInterfaceDnsSettings from the provided source NetworkInterfaceDnsSettings
func (settings *NetworkInterfaceDnsSettings) AssignProperties_From_NetworkInterfaceDnsSettings(source *v20201101s.NetworkInterfaceDnsSettings) error {

	// DnsServers
	settings.DnsServers = genruntime.CloneSliceOfString(source.DnsServers)

	// InternalDnsNameLabel
	settings.InternalDnsNameLabel = genruntime.ClonePointerToString(source.InternalDnsNameLabel)

	// No error
	return nil
}

// AssignProperties_To_NetworkInterfaceDnsSettings populates the provided destination NetworkInterfaceDnsSettings from our NetworkInterfaceDnsSettings
func (settings *NetworkInterfaceDnsSettings) AssignProperties_To_NetworkInterfaceDnsSettings(destination *v20201101s.NetworkInterfaceDnsSettings) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DnsServers
	destination.DnsServers = genruntime.CloneSliceOfString(settings.DnsServers)

	// InternalDnsNameLabel
	destination.InternalDnsNameLabel = genruntime.ClonePointerToString(settings.InternalDnsNameLabel)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_NetworkInterfaceDnsSettings_STATUS populates our NetworkInterfaceDnsSettings from the provided source NetworkInterfaceDnsSettings_STATUS
func (settings *NetworkInterfaceDnsSettings) Initialize_From_NetworkInterfaceDnsSettings_STATUS(source *NetworkInterfaceDnsSettings_STATUS) error {

	// DnsServers
	settings.DnsServers = genruntime.CloneSliceOfString(source.DnsServers)

	// InternalDnsNameLabel
	settings.InternalDnsNameLabel = genruntime.ClonePointerToString(source.InternalDnsNameLabel)

	// No error
	return nil
}

// DNS settings of a network interface.
type NetworkInterfaceDnsSettings_STATUS struct {
	// AppliedDnsServers: If the VM that uses this NIC is part of an Availability Set, then this list will have the union of
	// all DNS servers from all NICs that are part of the Availability Set. This property is what is configured on each of
	// those VMs.
	AppliedDnsServers []string `json:"appliedDnsServers,omitempty"`

	// DnsServers: List of DNS servers IP addresses. Use 'AzureProvidedDNS' to switch to azure provided DNS resolution.
	// 'AzureProvidedDNS' value cannot be combined with other IPs, it must be the only value in dnsServers collection.
	DnsServers []string `json:"dnsServers,omitempty"`

	// InternalDnsNameLabel: Relative DNS name for this NIC used for internal communications between VMs in the same virtual
	// network.
	InternalDnsNameLabel *string `json:"internalDnsNameLabel,omitempty"`

	// InternalDomainNameSuffix: Even if internalDnsNameLabel is not specified, a DNS entry is created for the primary NIC of
	// the VM. This DNS name can be constructed by concatenating the VM name with the value of internalDomainNameSuffix.
	InternalDomainNameSuffix *string `json:"internalDomainNameSuffix,omitempty"`

	// InternalFqdn: Fully qualified DNS name supporting internal communications between VMs in the same virtual network.
	InternalFqdn *string `json:"internalFqdn,omitempty"`
}

var _ genruntime.FromARMConverter = &NetworkInterfaceDnsSettings_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *NetworkInterfaceDnsSettings_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &NetworkInterfaceDnsSettings_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *NetworkInterfaceDnsSettings_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(NetworkInterfaceDnsSettings_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected NetworkInterfaceDnsSettings_STATUS_ARM, got %T", armInput)
	}

	// Set property "AppliedDnsServers":
	for _, item := range typedInput.AppliedDnsServers {
		settings.AppliedDnsServers = append(settings.AppliedDnsServers, item)
	}

	// Set property "DnsServers":
	for _, item := range typedInput.DnsServers {
		settings.DnsServers = append(settings.DnsServers, item)
	}

	// Set property "InternalDnsNameLabel":
	if typedInput.InternalDnsNameLabel != nil {
		internalDnsNameLabel := *typedInput.InternalDnsNameLabel
		settings.InternalDnsNameLabel = &internalDnsNameLabel
	}

	// Set property "InternalDomainNameSuffix":
	if typedInput.InternalDomainNameSuffix != nil {
		internalDomainNameSuffix := *typedInput.InternalDomainNameSuffix
		settings.InternalDomainNameSuffix = &internalDomainNameSuffix
	}

	// Set property "InternalFqdn":
	if typedInput.InternalFqdn != nil {
		internalFqdn := *typedInput.InternalFqdn
		settings.InternalFqdn = &internalFqdn
	}

	// No error
	return nil
}

// AssignProperties_From_NetworkInterfaceDnsSettings_STATUS populates our NetworkInterfaceDnsSettings_STATUS from the provided source NetworkInterfaceDnsSettings_STATUS
func (settings *NetworkInterfaceDnsSettings_STATUS) AssignProperties_From_NetworkInterfaceDnsSettings_STATUS(source *v20201101s.NetworkInterfaceDnsSettings_STATUS) error {

	// AppliedDnsServers
	settings.AppliedDnsServers = genruntime.CloneSliceOfString(source.AppliedDnsServers)

	// DnsServers
	settings.DnsServers = genruntime.CloneSliceOfString(source.DnsServers)

	// InternalDnsNameLabel
	settings.InternalDnsNameLabel = genruntime.ClonePointerToString(source.InternalDnsNameLabel)

	// InternalDomainNameSuffix
	settings.InternalDomainNameSuffix = genruntime.ClonePointerToString(source.InternalDomainNameSuffix)

	// InternalFqdn
	settings.InternalFqdn = genruntime.ClonePointerToString(source.InternalFqdn)

	// No error
	return nil
}

// AssignProperties_To_NetworkInterfaceDnsSettings_STATUS populates the provided destination NetworkInterfaceDnsSettings_STATUS from our NetworkInterfaceDnsSettings_STATUS
func (settings *NetworkInterfaceDnsSettings_STATUS) AssignProperties_To_NetworkInterfaceDnsSettings_STATUS(destination *v20201101s.NetworkInterfaceDnsSettings_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AppliedDnsServers
	destination.AppliedDnsServers = genruntime.CloneSliceOfString(settings.AppliedDnsServers)

	// DnsServers
	destination.DnsServers = genruntime.CloneSliceOfString(settings.DnsServers)

	// InternalDnsNameLabel
	destination.InternalDnsNameLabel = genruntime.ClonePointerToString(settings.InternalDnsNameLabel)

	// InternalDomainNameSuffix
	destination.InternalDomainNameSuffix = genruntime.ClonePointerToString(settings.InternalDomainNameSuffix)

	// InternalFqdn
	destination.InternalFqdn = genruntime.ClonePointerToString(settings.InternalFqdn)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// IPConfiguration in a network interface.
type NetworkInterfaceIPConfiguration_NetworkInterface_SubResourceEmbedded struct {
	// ApplicationGatewayBackendAddressPools: The reference to ApplicationGatewayBackendAddressPool resource.
	ApplicationGatewayBackendAddressPools []ApplicationGatewayBackendAddressPool_NetworkInterface_SubResourceEmbedded `json:"applicationGatewayBackendAddressPools,omitempty"`

	// ApplicationSecurityGroups: Application security groups in which the IP configuration is included.
	ApplicationSecurityGroups []ApplicationSecurityGroupSpec_NetworkInterface_SubResourceEmbedded `json:"applicationSecurityGroups,omitempty"`

	// LoadBalancerBackendAddressPools: The reference to LoadBalancerBackendAddressPool resource.
	LoadBalancerBackendAddressPools []BackendAddressPool_NetworkInterface_SubResourceEmbedded `json:"loadBalancerBackendAddressPools,omitempty"`

	// LoadBalancerInboundNatRules: A list of references of LoadBalancerInboundNatRules.
	LoadBalancerInboundNatRules []InboundNatRule_NetworkInterface_SubResourceEmbedded `json:"loadBalancerInboundNatRules,omitempty"`

	// Name: The name of the resource that is unique within a resource group. This name can be used to access the resource.
	Name *string `json:"name,omitempty"`

	// Primary: Whether this is a primary customer address on the network interface.
	Primary *bool `json:"primary,omitempty"`

	// PrivateIPAddress: Private IP address of the IP configuration.
	PrivateIPAddress *string `json:"privateIPAddress,omitempty"`

	// PrivateIPAddressVersion: Whether the specific IP configuration is IPv4 or IPv6. Default is IPv4.
	PrivateIPAddressVersion *IPVersion `json:"privateIPAddressVersion,omitempty"`

	// PrivateIPAllocationMethod: The private IP address allocation method.
	PrivateIPAllocationMethod *IPAllocationMethod `json:"privateIPAllocationMethod,omitempty"`

	// PublicIPAddress: Public IP address bound to the IP configuration.
	PublicIPAddress *PublicIPAddressSpec_NetworkInterface_SubResourceEmbedded `json:"publicIPAddress,omitempty"`

	// Subnet: Subnet bound to the IP configuration.
	Subnet *Subnet_NetworkInterface_SubResourceEmbedded `json:"subnet,omitempty"`

	// VirtualNetworkTaps: The reference to Virtual Network Taps.
	VirtualNetworkTaps []VirtualNetworkTapSpec_NetworkInterface_SubResourceEmbedded `json:"virtualNetworkTaps,omitempty"`
}

var _ genruntime.ARMTransformer = &NetworkInterfaceIPConfiguration_NetworkInterface_SubResourceEmbedded{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (embedded *NetworkInterfaceIPConfiguration_NetworkInterface_SubResourceEmbedded) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if embedded == nil {
		return nil, nil
	}
	result := &NetworkInterfaceIPConfiguration_NetworkInterface_SubResourceEmbedded_ARM{}

	// Set property "Name":
	if embedded.Name != nil {
		name := *embedded.Name
		result.Name = &name
	}

	// Set property "Properties":
	if embedded.ApplicationGatewayBackendAddressPools != nil ||
		embedded.ApplicationSecurityGroups != nil ||
		embedded.LoadBalancerBackendAddressPools != nil ||
		embedded.LoadBalancerInboundNatRules != nil ||
		embedded.Primary != nil ||
		embedded.PrivateIPAddress != nil ||
		embedded.PrivateIPAddressVersion != nil ||
		embedded.PrivateIPAllocationMethod != nil ||
		embedded.PublicIPAddress != nil ||
		embedded.Subnet != nil ||
		embedded.VirtualNetworkTaps != nil {
		result.Properties = &NetworkInterfaceIPConfigurationPropertiesFormat_ARM{}
	}
	for _, item := range embedded.ApplicationGatewayBackendAddressPools {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.ApplicationGatewayBackendAddressPools = append(result.Properties.ApplicationGatewayBackendAddressPools, *item_ARM.(*ApplicationGatewayBackendAddressPool_NetworkInterface_SubResourceEmbedded_ARM))
	}
	for _, item := range embedded.ApplicationSecurityGroups {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.ApplicationSecurityGroups = append(result.Properties.ApplicationSecurityGroups, *item_ARM.(*ApplicationSecurityGroupSpec_NetworkInterface_SubResourceEmbedded_ARM))
	}
	for _, item := range embedded.LoadBalancerBackendAddressPools {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.LoadBalancerBackendAddressPools = append(result.Properties.LoadBalancerBackendAddressPools, *item_ARM.(*BackendAddressPool_NetworkInterface_SubResourceEmbedded_ARM))
	}
	for _, item := range embedded.LoadBalancerInboundNatRules {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.LoadBalancerInboundNatRules = append(result.Properties.LoadBalancerInboundNatRules, *item_ARM.(*InboundNatRule_NetworkInterface_SubResourceEmbedded_ARM))
	}
	if embedded.Primary != nil {
		primary := *embedded.Primary
		result.Properties.Primary = &primary
	}
	if embedded.PrivateIPAddress != nil {
		privateIPAddress := *embedded.PrivateIPAddress
		result.Properties.PrivateIPAddress = &privateIPAddress
	}
	if embedded.PrivateIPAddressVersion != nil {
		privateIPAddressVersion := *embedded.PrivateIPAddressVersion
		result.Properties.PrivateIPAddressVersion = &privateIPAddressVersion
	}
	if embedded.PrivateIPAllocationMethod != nil {
		privateIPAllocationMethod := *embedded.PrivateIPAllocationMethod
		result.Properties.PrivateIPAllocationMethod = &privateIPAllocationMethod
	}
	if embedded.PublicIPAddress != nil {
		publicIPAddress_ARM, err := (*embedded.PublicIPAddress).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		publicIPAddress := *publicIPAddress_ARM.(*PublicIPAddressSpec_NetworkInterface_SubResourceEmbedded_ARM)
		result.Properties.PublicIPAddress = &publicIPAddress
	}
	if embedded.Subnet != nil {
		subnet_ARM, err := (*embedded.Subnet).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		subnet := *subnet_ARM.(*Subnet_NetworkInterface_SubResourceEmbedded_ARM)
		result.Properties.Subnet = &subnet
	}
	for _, item := range embedded.VirtualNetworkTaps {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.VirtualNetworkTaps = append(result.Properties.VirtualNetworkTaps, *item_ARM.(*VirtualNetworkTapSpec_NetworkInterface_SubResourceEmbedded_ARM))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (embedded *NetworkInterfaceIPConfiguration_NetworkInterface_SubResourceEmbedded) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &NetworkInterfaceIPConfiguration_NetworkInterface_SubResourceEmbedded_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (embedded *NetworkInterfaceIPConfiguration_NetworkInterface_SubResourceEmbedded) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(NetworkInterfaceIPConfiguration_NetworkInterface_SubResourceEmbedded_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected NetworkInterfaceIPConfiguration_NetworkInterface_SubResourceEmbedded_ARM, got %T", armInput)
	}

	// Set property "ApplicationGatewayBackendAddressPools":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.ApplicationGatewayBackendAddressPools {
			var item1 ApplicationGatewayBackendAddressPool_NetworkInterface_SubResourceEmbedded
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			embedded.ApplicationGatewayBackendAddressPools = append(embedded.ApplicationGatewayBackendAddressPools, item1)
		}
	}

	// Set property "ApplicationSecurityGroups":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.ApplicationSecurityGroups {
			var item1 ApplicationSecurityGroupSpec_NetworkInterface_SubResourceEmbedded
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			embedded.ApplicationSecurityGroups = append(embedded.ApplicationSecurityGroups, item1)
		}
	}

	// Set property "LoadBalancerBackendAddressPools":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.LoadBalancerBackendAddressPools {
			var item1 BackendAddressPool_NetworkInterface_SubResourceEmbedded
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			embedded.LoadBalancerBackendAddressPools = append(embedded.LoadBalancerBackendAddressPools, item1)
		}
	}

	// Set property "LoadBalancerInboundNatRules":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.LoadBalancerInboundNatRules {
			var item1 InboundNatRule_NetworkInterface_SubResourceEmbedded
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			embedded.LoadBalancerInboundNatRules = append(embedded.LoadBalancerInboundNatRules, item1)
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		embedded.Name = &name
	}

	// Set property "Primary":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Primary != nil {
			primary := *typedInput.Properties.Primary
			embedded.Primary = &primary
		}
	}

	// Set property "PrivateIPAddress":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateIPAddress != nil {
			privateIPAddress := *typedInput.Properties.PrivateIPAddress
			embedded.PrivateIPAddress = &privateIPAddress
		}
	}

	// Set property "PrivateIPAddressVersion":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateIPAddressVersion != nil {
			privateIPAddressVersion := *typedInput.Properties.PrivateIPAddressVersion
			embedded.PrivateIPAddressVersion = &privateIPAddressVersion
		}
	}

	// Set property "PrivateIPAllocationMethod":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateIPAllocationMethod != nil {
			privateIPAllocationMethod := *typedInput.Properties.PrivateIPAllocationMethod
			embedded.PrivateIPAllocationMethod = &privateIPAllocationMethod
		}
	}

	// Set property "PublicIPAddress":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicIPAddress != nil {
			var publicIPAddress1 PublicIPAddressSpec_NetworkInterface_SubResourceEmbedded
			err := publicIPAddress1.PopulateFromARM(owner, *typedInput.Properties.PublicIPAddress)
			if err != nil {
				return err
			}
			publicIPAddress := publicIPAddress1
			embedded.PublicIPAddress = &publicIPAddress
		}
	}

	// Set property "Subnet":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Subnet != nil {
			var subnet1 Subnet_NetworkInterface_SubResourceEmbedded
			err := subnet1.PopulateFromARM(owner, *typedInput.Properties.Subnet)
			if err != nil {
				return err
			}
			subnet := subnet1
			embedded.Subnet = &subnet
		}
	}

	// Set property "VirtualNetworkTaps":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.VirtualNetworkTaps {
			var item1 VirtualNetworkTapSpec_NetworkInterface_SubResourceEmbedded
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			embedded.VirtualNetworkTaps = append(embedded.VirtualNetworkTaps, item1)
		}
	}

	// No error
	return nil
}

// AssignProperties_From_NetworkInterfaceIPConfiguration_NetworkInterface_SubResourceEmbedded populates our NetworkInterfaceIPConfiguration_NetworkInterface_SubResourceEmbedded from the provided source NetworkInterfaceIPConfiguration_NetworkInterface_SubResourceEmbedded
func (embedded *NetworkInterfaceIPConfiguration_NetworkInterface_SubResourceEmbedded) AssignProperties_From_NetworkInterfaceIPConfiguration_NetworkInterface_SubResourceEmbedded(source *v20201101s.NetworkInterfaceIPConfiguration_NetworkInterface_SubResourceEmbedded) error {

	// ApplicationGatewayBackendAddressPools
	if source.ApplicationGatewayBackendAddressPools != nil {
		applicationGatewayBackendAddressPoolList := make([]ApplicationGatewayBackendAddressPool_NetworkInterface_SubResourceEmbedded, len(source.ApplicationGatewayBackendAddressPools))
		for applicationGatewayBackendAddressPoolIndex, applicationGatewayBackendAddressPoolItem := range source.ApplicationGatewayBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			applicationGatewayBackendAddressPoolItem := applicationGatewayBackendAddressPoolItem
			var applicationGatewayBackendAddressPool ApplicationGatewayBackendAddressPool_NetworkInterface_SubResourceEmbedded
			err := applicationGatewayBackendAddressPool.AssignProperties_From_ApplicationGatewayBackendAddressPool_NetworkInterface_SubResourceEmbedded(&applicationGatewayBackendAddressPoolItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ApplicationGatewayBackendAddressPool_NetworkInterface_SubResourceEmbedded() to populate field ApplicationGatewayBackendAddressPools")
			}
			applicationGatewayBackendAddressPoolList[applicationGatewayBackendAddressPoolIndex] = applicationGatewayBackendAddressPool
		}
		embedded.ApplicationGatewayBackendAddressPools = applicationGatewayBackendAddressPoolList
	} else {
		embedded.ApplicationGatewayBackendAddressPools = nil
	}

	// ApplicationSecurityGroups
	if source.ApplicationSecurityGroups != nil {
		applicationSecurityGroupList := make([]ApplicationSecurityGroupSpec_NetworkInterface_SubResourceEmbedded, len(source.ApplicationSecurityGroups))
		for applicationSecurityGroupIndex, applicationSecurityGroupItem := range source.ApplicationSecurityGroups {
			// Shadow the loop variable to avoid aliasing
			applicationSecurityGroupItem := applicationSecurityGroupItem
			var applicationSecurityGroup ApplicationSecurityGroupSpec_NetworkInterface_SubResourceEmbedded
			err := applicationSecurityGroup.AssignProperties_From_ApplicationSecurityGroupSpec_NetworkInterface_SubResourceEmbedded(&applicationSecurityGroupItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ApplicationSecurityGroupSpec_NetworkInterface_SubResourceEmbedded() to populate field ApplicationSecurityGroups")
			}
			applicationSecurityGroupList[applicationSecurityGroupIndex] = applicationSecurityGroup
		}
		embedded.ApplicationSecurityGroups = applicationSecurityGroupList
	} else {
		embedded.ApplicationSecurityGroups = nil
	}

	// LoadBalancerBackendAddressPools
	if source.LoadBalancerBackendAddressPools != nil {
		loadBalancerBackendAddressPoolList := make([]BackendAddressPool_NetworkInterface_SubResourceEmbedded, len(source.LoadBalancerBackendAddressPools))
		for loadBalancerBackendAddressPoolIndex, loadBalancerBackendAddressPoolItem := range source.LoadBalancerBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			loadBalancerBackendAddressPoolItem := loadBalancerBackendAddressPoolItem
			var loadBalancerBackendAddressPool BackendAddressPool_NetworkInterface_SubResourceEmbedded
			err := loadBalancerBackendAddressPool.AssignProperties_From_BackendAddressPool_NetworkInterface_SubResourceEmbedded(&loadBalancerBackendAddressPoolItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_BackendAddressPool_NetworkInterface_SubResourceEmbedded() to populate field LoadBalancerBackendAddressPools")
			}
			loadBalancerBackendAddressPoolList[loadBalancerBackendAddressPoolIndex] = loadBalancerBackendAddressPool
		}
		embedded.LoadBalancerBackendAddressPools = loadBalancerBackendAddressPoolList
	} else {
		embedded.LoadBalancerBackendAddressPools = nil
	}

	// LoadBalancerInboundNatRules
	if source.LoadBalancerInboundNatRules != nil {
		loadBalancerInboundNatRuleList := make([]InboundNatRule_NetworkInterface_SubResourceEmbedded, len(source.LoadBalancerInboundNatRules))
		for loadBalancerInboundNatRuleIndex, loadBalancerInboundNatRuleItem := range source.LoadBalancerInboundNatRules {
			// Shadow the loop variable to avoid aliasing
			loadBalancerInboundNatRuleItem := loadBalancerInboundNatRuleItem
			var loadBalancerInboundNatRule InboundNatRule_NetworkInterface_SubResourceEmbedded
			err := loadBalancerInboundNatRule.AssignProperties_From_InboundNatRule_NetworkInterface_SubResourceEmbedded(&loadBalancerInboundNatRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_InboundNatRule_NetworkInterface_SubResourceEmbedded() to populate field LoadBalancerInboundNatRules")
			}
			loadBalancerInboundNatRuleList[loadBalancerInboundNatRuleIndex] = loadBalancerInboundNatRule
		}
		embedded.LoadBalancerInboundNatRules = loadBalancerInboundNatRuleList
	} else {
		embedded.LoadBalancerInboundNatRules = nil
	}

	// Name
	embedded.Name = genruntime.ClonePointerToString(source.Name)

	// Primary
	if source.Primary != nil {
		primary := *source.Primary
		embedded.Primary = &primary
	} else {
		embedded.Primary = nil
	}

	// PrivateIPAddress
	embedded.PrivateIPAddress = genruntime.ClonePointerToString(source.PrivateIPAddress)

	// PrivateIPAddressVersion
	if source.PrivateIPAddressVersion != nil {
		privateIPAddressVersion := IPVersion(*source.PrivateIPAddressVersion)
		embedded.PrivateIPAddressVersion = &privateIPAddressVersion
	} else {
		embedded.PrivateIPAddressVersion = nil
	}

	// PrivateIPAllocationMethod
	if source.PrivateIPAllocationMethod != nil {
		privateIPAllocationMethod := IPAllocationMethod(*source.PrivateIPAllocationMethod)
		embedded.PrivateIPAllocationMethod = &privateIPAllocationMethod
	} else {
		embedded.PrivateIPAllocationMethod = nil
	}

	// PublicIPAddress
	if source.PublicIPAddress != nil {
		var publicIPAddress PublicIPAddressSpec_NetworkInterface_SubResourceEmbedded
		err := publicIPAddress.AssignProperties_From_PublicIPAddressSpec_NetworkInterface_SubResourceEmbedded(source.PublicIPAddress)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_PublicIPAddressSpec_NetworkInterface_SubResourceEmbedded() to populate field PublicIPAddress")
		}
		embedded.PublicIPAddress = &publicIPAddress
	} else {
		embedded.PublicIPAddress = nil
	}

	// Subnet
	if source.Subnet != nil {
		var subnet Subnet_NetworkInterface_SubResourceEmbedded
		err := subnet.AssignProperties_From_Subnet_NetworkInterface_SubResourceEmbedded(source.Subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Subnet_NetworkInterface_SubResourceEmbedded() to populate field Subnet")
		}
		embedded.Subnet = &subnet
	} else {
		embedded.Subnet = nil
	}

	// VirtualNetworkTaps
	if source.VirtualNetworkTaps != nil {
		virtualNetworkTapList := make([]VirtualNetworkTapSpec_NetworkInterface_SubResourceEmbedded, len(source.VirtualNetworkTaps))
		for virtualNetworkTapIndex, virtualNetworkTapItem := range source.VirtualNetworkTaps {
			// Shadow the loop variable to avoid aliasing
			virtualNetworkTapItem := virtualNetworkTapItem
			var virtualNetworkTap VirtualNetworkTapSpec_NetworkInterface_SubResourceEmbedded
			err := virtualNetworkTap.AssignProperties_From_VirtualNetworkTapSpec_NetworkInterface_SubResourceEmbedded(&virtualNetworkTapItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_VirtualNetworkTapSpec_NetworkInterface_SubResourceEmbedded() to populate field VirtualNetworkTaps")
			}
			virtualNetworkTapList[virtualNetworkTapIndex] = virtualNetworkTap
		}
		embedded.VirtualNetworkTaps = virtualNetworkTapList
	} else {
		embedded.VirtualNetworkTaps = nil
	}

	// No error
	return nil
}

// AssignProperties_To_NetworkInterfaceIPConfiguration_NetworkInterface_SubResourceEmbedded populates the provided destination NetworkInterfaceIPConfiguration_NetworkInterface_SubResourceEmbedded from our NetworkInterfaceIPConfiguration_NetworkInterface_SubResourceEmbedded
func (embedded *NetworkInterfaceIPConfiguration_NetworkInterface_SubResourceEmbedded) AssignProperties_To_NetworkInterfaceIPConfiguration_NetworkInterface_SubResourceEmbedded(destination *v20201101s.NetworkInterfaceIPConfiguration_NetworkInterface_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ApplicationGatewayBackendAddressPools
	if embedded.ApplicationGatewayBackendAddressPools != nil {
		applicationGatewayBackendAddressPoolList := make([]v20201101s.ApplicationGatewayBackendAddressPool_NetworkInterface_SubResourceEmbedded, len(embedded.ApplicationGatewayBackendAddressPools))
		for applicationGatewayBackendAddressPoolIndex, applicationGatewayBackendAddressPoolItem := range embedded.ApplicationGatewayBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			applicationGatewayBackendAddressPoolItem := applicationGatewayBackendAddressPoolItem
			var applicationGatewayBackendAddressPool v20201101s.ApplicationGatewayBackendAddressPool_NetworkInterface_SubResourceEmbedded
			err := applicationGatewayBackendAddressPoolItem.AssignProperties_To_ApplicationGatewayBackendAddressPool_NetworkInterface_SubResourceEmbedded(&applicationGatewayBackendAddressPool)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ApplicationGatewayBackendAddressPool_NetworkInterface_SubResourceEmbedded() to populate field ApplicationGatewayBackendAddressPools")
			}
			applicationGatewayBackendAddressPoolList[applicationGatewayBackendAddressPoolIndex] = applicationGatewayBackendAddressPool
		}
		destination.ApplicationGatewayBackendAddressPools = applicationGatewayBackendAddressPoolList
	} else {
		destination.ApplicationGatewayBackendAddressPools = nil
	}

	// ApplicationSecurityGroups
	if embedded.ApplicationSecurityGroups != nil {
		applicationSecurityGroupList := make([]v20201101s.ApplicationSecurityGroupSpec_NetworkInterface_SubResourceEmbedded, len(embedded.ApplicationSecurityGroups))
		for applicationSecurityGroupIndex, applicationSecurityGroupItem := range embedded.ApplicationSecurityGroups {
			// Shadow the loop variable to avoid aliasing
			applicationSecurityGroupItem := applicationSecurityGroupItem
			var applicationSecurityGroup v20201101s.ApplicationSecurityGroupSpec_NetworkInterface_SubResourceEmbedded
			err := applicationSecurityGroupItem.AssignProperties_To_ApplicationSecurityGroupSpec_NetworkInterface_SubResourceEmbedded(&applicationSecurityGroup)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ApplicationSecurityGroupSpec_NetworkInterface_SubResourceEmbedded() to populate field ApplicationSecurityGroups")
			}
			applicationSecurityGroupList[applicationSecurityGroupIndex] = applicationSecurityGroup
		}
		destination.ApplicationSecurityGroups = applicationSecurityGroupList
	} else {
		destination.ApplicationSecurityGroups = nil
	}

	// LoadBalancerBackendAddressPools
	if embedded.LoadBalancerBackendAddressPools != nil {
		loadBalancerBackendAddressPoolList := make([]v20201101s.BackendAddressPool_NetworkInterface_SubResourceEmbedded, len(embedded.LoadBalancerBackendAddressPools))
		for loadBalancerBackendAddressPoolIndex, loadBalancerBackendAddressPoolItem := range embedded.LoadBalancerBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			loadBalancerBackendAddressPoolItem := loadBalancerBackendAddressPoolItem
			var loadBalancerBackendAddressPool v20201101s.BackendAddressPool_NetworkInterface_SubResourceEmbedded
			err := loadBalancerBackendAddressPoolItem.AssignProperties_To_BackendAddressPool_NetworkInterface_SubResourceEmbedded(&loadBalancerBackendAddressPool)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_BackendAddressPool_NetworkInterface_SubResourceEmbedded() to populate field LoadBalancerBackendAddressPools")
			}
			loadBalancerBackendAddressPoolList[loadBalancerBackendAddressPoolIndex] = loadBalancerBackendAddressPool
		}
		destination.LoadBalancerBackendAddressPools = loadBalancerBackendAddressPoolList
	} else {
		destination.LoadBalancerBackendAddressPools = nil
	}

	// LoadBalancerInboundNatRules
	if embedded.LoadBalancerInboundNatRules != nil {
		loadBalancerInboundNatRuleList := make([]v20201101s.InboundNatRule_NetworkInterface_SubResourceEmbedded, len(embedded.LoadBalancerInboundNatRules))
		for loadBalancerInboundNatRuleIndex, loadBalancerInboundNatRuleItem := range embedded.LoadBalancerInboundNatRules {
			// Shadow the loop variable to avoid aliasing
			loadBalancerInboundNatRuleItem := loadBalancerInboundNatRuleItem
			var loadBalancerInboundNatRule v20201101s.InboundNatRule_NetworkInterface_SubResourceEmbedded
			err := loadBalancerInboundNatRuleItem.AssignProperties_To_InboundNatRule_NetworkInterface_SubResourceEmbedded(&loadBalancerInboundNatRule)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_InboundNatRule_NetworkInterface_SubResourceEmbedded() to populate field LoadBalancerInboundNatRules")
			}
			loadBalancerInboundNatRuleList[loadBalancerInboundNatRuleIndex] = loadBalancerInboundNatRule
		}
		destination.LoadBalancerInboundNatRules = loadBalancerInboundNatRuleList
	} else {
		destination.LoadBalancerInboundNatRules = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(embedded.Name)

	// Primary
	if embedded.Primary != nil {
		primary := *embedded.Primary
		destination.Primary = &primary
	} else {
		destination.Primary = nil
	}

	// PrivateIPAddress
	destination.PrivateIPAddress = genruntime.ClonePointerToString(embedded.PrivateIPAddress)

	// PrivateIPAddressVersion
	if embedded.PrivateIPAddressVersion != nil {
		privateIPAddressVersion := string(*embedded.PrivateIPAddressVersion)
		destination.PrivateIPAddressVersion = &privateIPAddressVersion
	} else {
		destination.PrivateIPAddressVersion = nil
	}

	// PrivateIPAllocationMethod
	if embedded.PrivateIPAllocationMethod != nil {
		privateIPAllocationMethod := string(*embedded.PrivateIPAllocationMethod)
		destination.PrivateIPAllocationMethod = &privateIPAllocationMethod
	} else {
		destination.PrivateIPAllocationMethod = nil
	}

	// PublicIPAddress
	if embedded.PublicIPAddress != nil {
		var publicIPAddress v20201101s.PublicIPAddressSpec_NetworkInterface_SubResourceEmbedded
		err := embedded.PublicIPAddress.AssignProperties_To_PublicIPAddressSpec_NetworkInterface_SubResourceEmbedded(&publicIPAddress)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_PublicIPAddressSpec_NetworkInterface_SubResourceEmbedded() to populate field PublicIPAddress")
		}
		destination.PublicIPAddress = &publicIPAddress
	} else {
		destination.PublicIPAddress = nil
	}

	// Subnet
	if embedded.Subnet != nil {
		var subnet v20201101s.Subnet_NetworkInterface_SubResourceEmbedded
		err := embedded.Subnet.AssignProperties_To_Subnet_NetworkInterface_SubResourceEmbedded(&subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Subnet_NetworkInterface_SubResourceEmbedded() to populate field Subnet")
		}
		destination.Subnet = &subnet
	} else {
		destination.Subnet = nil
	}

	// VirtualNetworkTaps
	if embedded.VirtualNetworkTaps != nil {
		virtualNetworkTapList := make([]v20201101s.VirtualNetworkTapSpec_NetworkInterface_SubResourceEmbedded, len(embedded.VirtualNetworkTaps))
		for virtualNetworkTapIndex, virtualNetworkTapItem := range embedded.VirtualNetworkTaps {
			// Shadow the loop variable to avoid aliasing
			virtualNetworkTapItem := virtualNetworkTapItem
			var virtualNetworkTap v20201101s.VirtualNetworkTapSpec_NetworkInterface_SubResourceEmbedded
			err := virtualNetworkTapItem.AssignProperties_To_VirtualNetworkTapSpec_NetworkInterface_SubResourceEmbedded(&virtualNetworkTap)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_VirtualNetworkTapSpec_NetworkInterface_SubResourceEmbedded() to populate field VirtualNetworkTaps")
			}
			virtualNetworkTapList[virtualNetworkTapIndex] = virtualNetworkTap
		}
		destination.VirtualNetworkTaps = virtualNetworkTapList
	} else {
		destination.VirtualNetworkTaps = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_NetworkInterfaceIPConfiguration_STATUS_NetworkInterface_SubResourceEmbedded populates our NetworkInterfaceIPConfiguration_NetworkInterface_SubResourceEmbedded from the provided source NetworkInterfaceIPConfiguration_STATUS_NetworkInterface_SubResourceEmbedded
func (embedded *NetworkInterfaceIPConfiguration_NetworkInterface_SubResourceEmbedded) Initialize_From_NetworkInterfaceIPConfiguration_STATUS_NetworkInterface_SubResourceEmbedded(source *NetworkInterfaceIPConfiguration_STATUS_NetworkInterface_SubResourceEmbedded) error {

	// ApplicationGatewayBackendAddressPools
	if source.ApplicationGatewayBackendAddressPools != nil {
		applicationGatewayBackendAddressPoolList := make([]ApplicationGatewayBackendAddressPool_NetworkInterface_SubResourceEmbedded, len(source.ApplicationGatewayBackendAddressPools))
		for applicationGatewayBackendAddressPoolIndex, applicationGatewayBackendAddressPoolItem := range source.ApplicationGatewayBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			applicationGatewayBackendAddressPoolItem := applicationGatewayBackendAddressPoolItem
			var applicationGatewayBackendAddressPool ApplicationGatewayBackendAddressPool_NetworkInterface_SubResourceEmbedded
			err := applicationGatewayBackendAddressPool.Initialize_From_ApplicationGatewayBackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded(&applicationGatewayBackendAddressPoolItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_ApplicationGatewayBackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded() to populate field ApplicationGatewayBackendAddressPools")
			}
			applicationGatewayBackendAddressPoolList[applicationGatewayBackendAddressPoolIndex] = applicationGatewayBackendAddressPool
		}
		embedded.ApplicationGatewayBackendAddressPools = applicationGatewayBackendAddressPoolList
	} else {
		embedded.ApplicationGatewayBackendAddressPools = nil
	}

	// ApplicationSecurityGroups
	if source.ApplicationSecurityGroups != nil {
		applicationSecurityGroupList := make([]ApplicationSecurityGroupSpec_NetworkInterface_SubResourceEmbedded, len(source.ApplicationSecurityGroups))
		for applicationSecurityGroupIndex, applicationSecurityGroupItem := range source.ApplicationSecurityGroups {
			// Shadow the loop variable to avoid aliasing
			applicationSecurityGroupItem := applicationSecurityGroupItem
			var applicationSecurityGroup ApplicationSecurityGroupSpec_NetworkInterface_SubResourceEmbedded
			err := applicationSecurityGroup.Initialize_From_ApplicationSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded(&applicationSecurityGroupItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_ApplicationSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded() to populate field ApplicationSecurityGroups")
			}
			applicationSecurityGroupList[applicationSecurityGroupIndex] = applicationSecurityGroup
		}
		embedded.ApplicationSecurityGroups = applicationSecurityGroupList
	} else {
		embedded.ApplicationSecurityGroups = nil
	}

	// LoadBalancerBackendAddressPools
	if source.LoadBalancerBackendAddressPools != nil {
		loadBalancerBackendAddressPoolList := make([]BackendAddressPool_NetworkInterface_SubResourceEmbedded, len(source.LoadBalancerBackendAddressPools))
		for loadBalancerBackendAddressPoolIndex, loadBalancerBackendAddressPoolItem := range source.LoadBalancerBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			loadBalancerBackendAddressPoolItem := loadBalancerBackendAddressPoolItem
			var loadBalancerBackendAddressPool BackendAddressPool_NetworkInterface_SubResourceEmbedded
			err := loadBalancerBackendAddressPool.Initialize_From_BackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded(&loadBalancerBackendAddressPoolItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_BackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded() to populate field LoadBalancerBackendAddressPools")
			}
			loadBalancerBackendAddressPoolList[loadBalancerBackendAddressPoolIndex] = loadBalancerBackendAddressPool
		}
		embedded.LoadBalancerBackendAddressPools = loadBalancerBackendAddressPoolList
	} else {
		embedded.LoadBalancerBackendAddressPools = nil
	}

	// LoadBalancerInboundNatRules
	if source.LoadBalancerInboundNatRules != nil {
		loadBalancerInboundNatRuleList := make([]InboundNatRule_NetworkInterface_SubResourceEmbedded, len(source.LoadBalancerInboundNatRules))
		for loadBalancerInboundNatRuleIndex, loadBalancerInboundNatRuleItem := range source.LoadBalancerInboundNatRules {
			// Shadow the loop variable to avoid aliasing
			loadBalancerInboundNatRuleItem := loadBalancerInboundNatRuleItem
			var loadBalancerInboundNatRule InboundNatRule_NetworkInterface_SubResourceEmbedded
			err := loadBalancerInboundNatRule.Initialize_From_InboundNatRule_STATUS_NetworkInterface_SubResourceEmbedded(&loadBalancerInboundNatRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_InboundNatRule_STATUS_NetworkInterface_SubResourceEmbedded() to populate field LoadBalancerInboundNatRules")
			}
			loadBalancerInboundNatRuleList[loadBalancerInboundNatRuleIndex] = loadBalancerInboundNatRule
		}
		embedded.LoadBalancerInboundNatRules = loadBalancerInboundNatRuleList
	} else {
		embedded.LoadBalancerInboundNatRules = nil
	}

	// Name
	embedded.Name = genruntime.ClonePointerToString(source.Name)

	// Primary
	if source.Primary != nil {
		primary := *source.Primary
		embedded.Primary = &primary
	} else {
		embedded.Primary = nil
	}

	// PrivateIPAddress
	embedded.PrivateIPAddress = genruntime.ClonePointerToString(source.PrivateIPAddress)

	// PrivateIPAddressVersion
	if source.PrivateIPAddressVersion != nil {
		privateIPAddressVersion := IPVersion(*source.PrivateIPAddressVersion)
		embedded.PrivateIPAddressVersion = &privateIPAddressVersion
	} else {
		embedded.PrivateIPAddressVersion = nil
	}

	// PrivateIPAllocationMethod
	if source.PrivateIPAllocationMethod != nil {
		privateIPAllocationMethod := IPAllocationMethod(*source.PrivateIPAllocationMethod)
		embedded.PrivateIPAllocationMethod = &privateIPAllocationMethod
	} else {
		embedded.PrivateIPAllocationMethod = nil
	}

	// PublicIPAddress
	if source.PublicIPAddress != nil {
		var publicIPAddress PublicIPAddressSpec_NetworkInterface_SubResourceEmbedded
		err := publicIPAddress.Initialize_From_PublicIPAddress_STATUS_NetworkInterface_SubResourceEmbedded(source.PublicIPAddress)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_PublicIPAddress_STATUS_NetworkInterface_SubResourceEmbedded() to populate field PublicIPAddress")
		}
		embedded.PublicIPAddress = &publicIPAddress
	} else {
		embedded.PublicIPAddress = nil
	}

	// Subnet
	if source.Subnet != nil {
		var subnet Subnet_NetworkInterface_SubResourceEmbedded
		err := subnet.Initialize_From_Subnet_STATUS_NetworkInterface_SubResourceEmbedded(source.Subnet)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_Subnet_STATUS_NetworkInterface_SubResourceEmbedded() to populate field Subnet")
		}
		embedded.Subnet = &subnet
	} else {
		embedded.Subnet = nil
	}

	// VirtualNetworkTaps
	if source.VirtualNetworkTaps != nil {
		virtualNetworkTapList := make([]VirtualNetworkTapSpec_NetworkInterface_SubResourceEmbedded, len(source.VirtualNetworkTaps))
		for virtualNetworkTapIndex, virtualNetworkTapItem := range source.VirtualNetworkTaps {
			// Shadow the loop variable to avoid aliasing
			virtualNetworkTapItem := virtualNetworkTapItem
			var virtualNetworkTap VirtualNetworkTapSpec_NetworkInterface_SubResourceEmbedded
			err := virtualNetworkTap.Initialize_From_VirtualNetworkTap_STATUS_NetworkInterface_SubResourceEmbedded(&virtualNetworkTapItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_VirtualNetworkTap_STATUS_NetworkInterface_SubResourceEmbedded() to populate field VirtualNetworkTaps")
			}
			virtualNetworkTapList[virtualNetworkTapIndex] = virtualNetworkTap
		}
		embedded.VirtualNetworkTaps = virtualNetworkTapList
	} else {
		embedded.VirtualNetworkTaps = nil
	}

	// No error
	return nil
}

// IPConfiguration in a network interface.
type NetworkInterfaceIPConfiguration_STATUS_NetworkInterface_SubResourceEmbedded struct {
	// ApplicationGatewayBackendAddressPools: The reference to ApplicationGatewayBackendAddressPool resource.
	ApplicationGatewayBackendAddressPools []ApplicationGatewayBackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded `json:"applicationGatewayBackendAddressPools,omitempty"`

	// ApplicationSecurityGroups: Application security groups in which the IP configuration is included.
	ApplicationSecurityGroups []ApplicationSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded `json:"applicationSecurityGroups,omitempty"`

	// Etag: A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`

	// Id: Resource ID.
	Id *string `json:"id,omitempty"`

	// LoadBalancerBackendAddressPools: The reference to LoadBalancerBackendAddressPool resource.
	LoadBalancerBackendAddressPools []BackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded `json:"loadBalancerBackendAddressPools,omitempty"`

	// LoadBalancerInboundNatRules: A list of references of LoadBalancerInboundNatRules.
	LoadBalancerInboundNatRules []InboundNatRule_STATUS_NetworkInterface_SubResourceEmbedded `json:"loadBalancerInboundNatRules,omitempty"`

	// Name: The name of the resource that is unique within a resource group. This name can be used to access the resource.
	Name *string `json:"name,omitempty"`

	// Primary: Whether this is a primary customer address on the network interface.
	Primary *bool `json:"primary,omitempty"`

	// PrivateIPAddress: Private IP address of the IP configuration.
	PrivateIPAddress *string `json:"privateIPAddress,omitempty"`

	// PrivateIPAddressVersion: Whether the specific IP configuration is IPv4 or IPv6. Default is IPv4.
	PrivateIPAddressVersion *IPVersion_STATUS `json:"privateIPAddressVersion,omitempty"`

	// PrivateIPAllocationMethod: The private IP address allocation method.
	PrivateIPAllocationMethod *IPAllocationMethod_STATUS `json:"privateIPAllocationMethod,omitempty"`

	// PrivateLinkConnectionProperties: PrivateLinkConnection properties for the network interface.
	PrivateLinkConnectionProperties *NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_STATUS `json:"privateLinkConnectionProperties,omitempty"`

	// ProvisioningState: The provisioning state of the network interface IP configuration.
	ProvisioningState *ProvisioningState_STATUS `json:"provisioningState,omitempty"`

	// PublicIPAddress: Public IP address bound to the IP configuration.
	PublicIPAddress *PublicIPAddress_STATUS_NetworkInterface_SubResourceEmbedded `json:"publicIPAddress,omitempty"`

	// Subnet: Subnet bound to the IP configuration.
	Subnet *Subnet_STATUS_NetworkInterface_SubResourceEmbedded `json:"subnet,omitempty"`

	// Type: Resource type.
	Type *string `json:"type,omitempty"`

	// VirtualNetworkTaps: The reference to Virtual Network Taps.
	VirtualNetworkTaps []VirtualNetworkTap_STATUS_NetworkInterface_SubResourceEmbedded `json:"virtualNetworkTaps,omitempty"`
}

var _ genruntime.FromARMConverter = &NetworkInterfaceIPConfiguration_STATUS_NetworkInterface_SubResourceEmbedded{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (embedded *NetworkInterfaceIPConfiguration_STATUS_NetworkInterface_SubResourceEmbedded) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &NetworkInterfaceIPConfiguration_STATUS_NetworkInterface_SubResourceEmbedded_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (embedded *NetworkInterfaceIPConfiguration_STATUS_NetworkInterface_SubResourceEmbedded) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(NetworkInterfaceIPConfiguration_STATUS_NetworkInterface_SubResourceEmbedded_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected NetworkInterfaceIPConfiguration_STATUS_NetworkInterface_SubResourceEmbedded_ARM, got %T", armInput)
	}

	// Set property "ApplicationGatewayBackendAddressPools":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.ApplicationGatewayBackendAddressPools {
			var item1 ApplicationGatewayBackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			embedded.ApplicationGatewayBackendAddressPools = append(embedded.ApplicationGatewayBackendAddressPools, item1)
		}
	}

	// Set property "ApplicationSecurityGroups":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.ApplicationSecurityGroups {
			var item1 ApplicationSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			embedded.ApplicationSecurityGroups = append(embedded.ApplicationSecurityGroups, item1)
		}
	}

	// Set property "Etag":
	if typedInput.Etag != nil {
		etag := *typedInput.Etag
		embedded.Etag = &etag
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		embedded.Id = &id
	}

	// Set property "LoadBalancerBackendAddressPools":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.LoadBalancerBackendAddressPools {
			var item1 BackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			embedded.LoadBalancerBackendAddressPools = append(embedded.LoadBalancerBackendAddressPools, item1)
		}
	}

	// Set property "LoadBalancerInboundNatRules":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.LoadBalancerInboundNatRules {
			var item1 InboundNatRule_STATUS_NetworkInterface_SubResourceEmbedded
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			embedded.LoadBalancerInboundNatRules = append(embedded.LoadBalancerInboundNatRules, item1)
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		embedded.Name = &name
	}

	// Set property "Primary":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Primary != nil {
			primary := *typedInput.Properties.Primary
			embedded.Primary = &primary
		}
	}

	// Set property "PrivateIPAddress":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateIPAddress != nil {
			privateIPAddress := *typedInput.Properties.PrivateIPAddress
			embedded.PrivateIPAddress = &privateIPAddress
		}
	}

	// Set property "PrivateIPAddressVersion":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateIPAddressVersion != nil {
			privateIPAddressVersion := *typedInput.Properties.PrivateIPAddressVersion
			embedded.PrivateIPAddressVersion = &privateIPAddressVersion
		}
	}

	// Set property "PrivateIPAllocationMethod":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateIPAllocationMethod != nil {
			privateIPAllocationMethod := *typedInput.Properties.PrivateIPAllocationMethod
			embedded.PrivateIPAllocationMethod = &privateIPAllocationMethod
		}
	}

	// Set property "PrivateLinkConnectionProperties":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateLinkConnectionProperties != nil {
			var privateLinkConnectionProperties1 NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_STATUS
			err := privateLinkConnectionProperties1.PopulateFromARM(owner, *typedInput.Properties.PrivateLinkConnectionProperties)
			if err != nil {
				return err
			}
			privateLinkConnectionProperties := privateLinkConnectionProperties1
			embedded.PrivateLinkConnectionProperties = &privateLinkConnectionProperties
		}
	}

	// Set property "ProvisioningState":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			provisioningState := *typedInput.Properties.ProvisioningState
			embedded.ProvisioningState = &provisioningState
		}
	}

	// Set property "PublicIPAddress":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicIPAddress != nil {
			var publicIPAddress1 PublicIPAddress_STATUS_NetworkInterface_SubResourceEmbedded
			err := publicIPAddress1.PopulateFromARM(owner, *typedInput.Properties.PublicIPAddress)
			if err != nil {
				return err
			}
			publicIPAddress := publicIPAddress1
			embedded.PublicIPAddress = &publicIPAddress
		}
	}

	// Set property "Subnet":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Subnet != nil {
			var subnet1 Subnet_STATUS_NetworkInterface_SubResourceEmbedded
			err := subnet1.PopulateFromARM(owner, *typedInput.Properties.Subnet)
			if err != nil {
				return err
			}
			subnet := subnet1
			embedded.Subnet = &subnet
		}
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		embedded.Type = &typeVar
	}

	// Set property "VirtualNetworkTaps":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.VirtualNetworkTaps {
			var item1 VirtualNetworkTap_STATUS_NetworkInterface_SubResourceEmbedded
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			embedded.VirtualNetworkTaps = append(embedded.VirtualNetworkTaps, item1)
		}
	}

	// No error
	return nil
}

// AssignProperties_From_NetworkInterfaceIPConfiguration_STATUS_NetworkInterface_SubResourceEmbedded populates our NetworkInterfaceIPConfiguration_STATUS_NetworkInterface_SubResourceEmbedded from the provided source NetworkInterfaceIPConfiguration_STATUS_NetworkInterface_SubResourceEmbedded
func (embedded *NetworkInterfaceIPConfiguration_STATUS_NetworkInterface_SubResourceEmbedded) AssignProperties_From_NetworkInterfaceIPConfiguration_STATUS_NetworkInterface_SubResourceEmbedded(source *v20201101s.NetworkInterfaceIPConfiguration_STATUS_NetworkInterface_SubResourceEmbedded) error {

	// ApplicationGatewayBackendAddressPools
	if source.ApplicationGatewayBackendAddressPools != nil {
		applicationGatewayBackendAddressPoolList := make([]ApplicationGatewayBackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded, len(source.ApplicationGatewayBackendAddressPools))
		for applicationGatewayBackendAddressPoolIndex, applicationGatewayBackendAddressPoolItem := range source.ApplicationGatewayBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			applicationGatewayBackendAddressPoolItem := applicationGatewayBackendAddressPoolItem
			var applicationGatewayBackendAddressPool ApplicationGatewayBackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded
			err := applicationGatewayBackendAddressPool.AssignProperties_From_ApplicationGatewayBackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded(&applicationGatewayBackendAddressPoolItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ApplicationGatewayBackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded() to populate field ApplicationGatewayBackendAddressPools")
			}
			applicationGatewayBackendAddressPoolList[applicationGatewayBackendAddressPoolIndex] = applicationGatewayBackendAddressPool
		}
		embedded.ApplicationGatewayBackendAddressPools = applicationGatewayBackendAddressPoolList
	} else {
		embedded.ApplicationGatewayBackendAddressPools = nil
	}

	// ApplicationSecurityGroups
	if source.ApplicationSecurityGroups != nil {
		applicationSecurityGroupList := make([]ApplicationSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded, len(source.ApplicationSecurityGroups))
		for applicationSecurityGroupIndex, applicationSecurityGroupItem := range source.ApplicationSecurityGroups {
			// Shadow the loop variable to avoid aliasing
			applicationSecurityGroupItem := applicationSecurityGroupItem
			var applicationSecurityGroup ApplicationSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded
			err := applicationSecurityGroup.AssignProperties_From_ApplicationSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded(&applicationSecurityGroupItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ApplicationSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded() to populate field ApplicationSecurityGroups")
			}
			applicationSecurityGroupList[applicationSecurityGroupIndex] = applicationSecurityGroup
		}
		embedded.ApplicationSecurityGroups = applicationSecurityGroupList
	} else {
		embedded.ApplicationSecurityGroups = nil
	}

	// Etag
	embedded.Etag = genruntime.ClonePointerToString(source.Etag)

	// Id
	embedded.Id = genruntime.ClonePointerToString(source.Id)

	// LoadBalancerBackendAddressPools
	if source.LoadBalancerBackendAddressPools != nil {
		loadBalancerBackendAddressPoolList := make([]BackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded, len(source.LoadBalancerBackendAddressPools))
		for loadBalancerBackendAddressPoolIndex, loadBalancerBackendAddressPoolItem := range source.LoadBalancerBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			loadBalancerBackendAddressPoolItem := loadBalancerBackendAddressPoolItem
			var loadBalancerBackendAddressPool BackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded
			err := loadBalancerBackendAddressPool.AssignProperties_From_BackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded(&loadBalancerBackendAddressPoolItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_BackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded() to populate field LoadBalancerBackendAddressPools")
			}
			loadBalancerBackendAddressPoolList[loadBalancerBackendAddressPoolIndex] = loadBalancerBackendAddressPool
		}
		embedded.LoadBalancerBackendAddressPools = loadBalancerBackendAddressPoolList
	} else {
		embedded.LoadBalancerBackendAddressPools = nil
	}

	// LoadBalancerInboundNatRules
	if source.LoadBalancerInboundNatRules != nil {
		loadBalancerInboundNatRuleList := make([]InboundNatRule_STATUS_NetworkInterface_SubResourceEmbedded, len(source.LoadBalancerInboundNatRules))
		for loadBalancerInboundNatRuleIndex, loadBalancerInboundNatRuleItem := range source.LoadBalancerInboundNatRules {
			// Shadow the loop variable to avoid aliasing
			loadBalancerInboundNatRuleItem := loadBalancerInboundNatRuleItem
			var loadBalancerInboundNatRule InboundNatRule_STATUS_NetworkInterface_SubResourceEmbedded
			err := loadBalancerInboundNatRule.AssignProperties_From_InboundNatRule_STATUS_NetworkInterface_SubResourceEmbedded(&loadBalancerInboundNatRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_InboundNatRule_STATUS_NetworkInterface_SubResourceEmbedded() to populate field LoadBalancerInboundNatRules")
			}
			loadBalancerInboundNatRuleList[loadBalancerInboundNatRuleIndex] = loadBalancerInboundNatRule
		}
		embedded.LoadBalancerInboundNatRules = loadBalancerInboundNatRuleList
	} else {
		embedded.LoadBalancerInboundNatRules = nil
	}

	// Name
	embedded.Name = genruntime.ClonePointerToString(source.Name)

	// Primary
	if source.Primary != nil {
		primary := *source.Primary
		embedded.Primary = &primary
	} else {
		embedded.Primary = nil
	}

	// PrivateIPAddress
	embedded.PrivateIPAddress = genruntime.ClonePointerToString(source.PrivateIPAddress)

	// PrivateIPAddressVersion
	if source.PrivateIPAddressVersion != nil {
		privateIPAddressVersion := IPVersion_STATUS(*source.PrivateIPAddressVersion)
		embedded.PrivateIPAddressVersion = &privateIPAddressVersion
	} else {
		embedded.PrivateIPAddressVersion = nil
	}

	// PrivateIPAllocationMethod
	if source.PrivateIPAllocationMethod != nil {
		privateIPAllocationMethod := IPAllocationMethod_STATUS(*source.PrivateIPAllocationMethod)
		embedded.PrivateIPAllocationMethod = &privateIPAllocationMethod
	} else {
		embedded.PrivateIPAllocationMethod = nil
	}

	// PrivateLinkConnectionProperties
	if source.PrivateLinkConnectionProperties != nil {
		var privateLinkConnectionProperty NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_STATUS
		err := privateLinkConnectionProperty.AssignProperties_From_NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_STATUS(source.PrivateLinkConnectionProperties)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_STATUS() to populate field PrivateLinkConnectionProperties")
		}
		embedded.PrivateLinkConnectionProperties = &privateLinkConnectionProperty
	} else {
		embedded.PrivateLinkConnectionProperties = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := ProvisioningState_STATUS(*source.ProvisioningState)
		embedded.ProvisioningState = &provisioningState
	} else {
		embedded.ProvisioningState = nil
	}

	// PublicIPAddress
	if source.PublicIPAddress != nil {
		var publicIPAddress PublicIPAddress_STATUS_NetworkInterface_SubResourceEmbedded
		err := publicIPAddress.AssignProperties_From_PublicIPAddress_STATUS_NetworkInterface_SubResourceEmbedded(source.PublicIPAddress)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_PublicIPAddress_STATUS_NetworkInterface_SubResourceEmbedded() to populate field PublicIPAddress")
		}
		embedded.PublicIPAddress = &publicIPAddress
	} else {
		embedded.PublicIPAddress = nil
	}

	// Subnet
	if source.Subnet != nil {
		var subnet Subnet_STATUS_NetworkInterface_SubResourceEmbedded
		err := subnet.AssignProperties_From_Subnet_STATUS_NetworkInterface_SubResourceEmbedded(source.Subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Subnet_STATUS_NetworkInterface_SubResourceEmbedded() to populate field Subnet")
		}
		embedded.Subnet = &subnet
	} else {
		embedded.Subnet = nil
	}

	// Type
	embedded.Type = genruntime.ClonePointerToString(source.Type)

	// VirtualNetworkTaps
	if source.VirtualNetworkTaps != nil {
		virtualNetworkTapList := make([]VirtualNetworkTap_STATUS_NetworkInterface_SubResourceEmbedded, len(source.VirtualNetworkTaps))
		for virtualNetworkTapIndex, virtualNetworkTapItem := range source.VirtualNetworkTaps {
			// Shadow the loop variable to avoid aliasing
			virtualNetworkTapItem := virtualNetworkTapItem
			var virtualNetworkTap VirtualNetworkTap_STATUS_NetworkInterface_SubResourceEmbedded
			err := virtualNetworkTap.AssignProperties_From_VirtualNetworkTap_STATUS_NetworkInterface_SubResourceEmbedded(&virtualNetworkTapItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_VirtualNetworkTap_STATUS_NetworkInterface_SubResourceEmbedded() to populate field VirtualNetworkTaps")
			}
			virtualNetworkTapList[virtualNetworkTapIndex] = virtualNetworkTap
		}
		embedded.VirtualNetworkTaps = virtualNetworkTapList
	} else {
		embedded.VirtualNetworkTaps = nil
	}

	// No error
	return nil
}

// AssignProperties_To_NetworkInterfaceIPConfiguration_STATUS_NetworkInterface_SubResourceEmbedded populates the provided destination NetworkInterfaceIPConfiguration_STATUS_NetworkInterface_SubResourceEmbedded from our NetworkInterfaceIPConfiguration_STATUS_NetworkInterface_SubResourceEmbedded
func (embedded *NetworkInterfaceIPConfiguration_STATUS_NetworkInterface_SubResourceEmbedded) AssignProperties_To_NetworkInterfaceIPConfiguration_STATUS_NetworkInterface_SubResourceEmbedded(destination *v20201101s.NetworkInterfaceIPConfiguration_STATUS_NetworkInterface_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ApplicationGatewayBackendAddressPools
	if embedded.ApplicationGatewayBackendAddressPools != nil {
		applicationGatewayBackendAddressPoolList := make([]v20201101s.ApplicationGatewayBackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded, len(embedded.ApplicationGatewayBackendAddressPools))
		for applicationGatewayBackendAddressPoolIndex, applicationGatewayBackendAddressPoolItem := range embedded.ApplicationGatewayBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			applicationGatewayBackendAddressPoolItem := applicationGatewayBackendAddressPoolItem
			var applicationGatewayBackendAddressPool v20201101s.ApplicationGatewayBackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded
			err := applicationGatewayBackendAddressPoolItem.AssignProperties_To_ApplicationGatewayBackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded(&applicationGatewayBackendAddressPool)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ApplicationGatewayBackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded() to populate field ApplicationGatewayBackendAddressPools")
			}
			applicationGatewayBackendAddressPoolList[applicationGatewayBackendAddressPoolIndex] = applicationGatewayBackendAddressPool
		}
		destination.ApplicationGatewayBackendAddressPools = applicationGatewayBackendAddressPoolList
	} else {
		destination.ApplicationGatewayBackendAddressPools = nil
	}

	// ApplicationSecurityGroups
	if embedded.ApplicationSecurityGroups != nil {
		applicationSecurityGroupList := make([]v20201101s.ApplicationSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded, len(embedded.ApplicationSecurityGroups))
		for applicationSecurityGroupIndex, applicationSecurityGroupItem := range embedded.ApplicationSecurityGroups {
			// Shadow the loop variable to avoid aliasing
			applicationSecurityGroupItem := applicationSecurityGroupItem
			var applicationSecurityGroup v20201101s.ApplicationSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded
			err := applicationSecurityGroupItem.AssignProperties_To_ApplicationSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded(&applicationSecurityGroup)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ApplicationSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded() to populate field ApplicationSecurityGroups")
			}
			applicationSecurityGroupList[applicationSecurityGroupIndex] = applicationSecurityGroup
		}
		destination.ApplicationSecurityGroups = applicationSecurityGroupList
	} else {
		destination.ApplicationSecurityGroups = nil
	}

	// Etag
	destination.Etag = genruntime.ClonePointerToString(embedded.Etag)

	// Id
	destination.Id = genruntime.ClonePointerToString(embedded.Id)

	// LoadBalancerBackendAddressPools
	if embedded.LoadBalancerBackendAddressPools != nil {
		loadBalancerBackendAddressPoolList := make([]v20201101s.BackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded, len(embedded.LoadBalancerBackendAddressPools))
		for loadBalancerBackendAddressPoolIndex, loadBalancerBackendAddressPoolItem := range embedded.LoadBalancerBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			loadBalancerBackendAddressPoolItem := loadBalancerBackendAddressPoolItem
			var loadBalancerBackendAddressPool v20201101s.BackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded
			err := loadBalancerBackendAddressPoolItem.AssignProperties_To_BackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded(&loadBalancerBackendAddressPool)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_BackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded() to populate field LoadBalancerBackendAddressPools")
			}
			loadBalancerBackendAddressPoolList[loadBalancerBackendAddressPoolIndex] = loadBalancerBackendAddressPool
		}
		destination.LoadBalancerBackendAddressPools = loadBalancerBackendAddressPoolList
	} else {
		destination.LoadBalancerBackendAddressPools = nil
	}

	// LoadBalancerInboundNatRules
	if embedded.LoadBalancerInboundNatRules != nil {
		loadBalancerInboundNatRuleList := make([]v20201101s.InboundNatRule_STATUS_NetworkInterface_SubResourceEmbedded, len(embedded.LoadBalancerInboundNatRules))
		for loadBalancerInboundNatRuleIndex, loadBalancerInboundNatRuleItem := range embedded.LoadBalancerInboundNatRules {
			// Shadow the loop variable to avoid aliasing
			loadBalancerInboundNatRuleItem := loadBalancerInboundNatRuleItem
			var loadBalancerInboundNatRule v20201101s.InboundNatRule_STATUS_NetworkInterface_SubResourceEmbedded
			err := loadBalancerInboundNatRuleItem.AssignProperties_To_InboundNatRule_STATUS_NetworkInterface_SubResourceEmbedded(&loadBalancerInboundNatRule)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_InboundNatRule_STATUS_NetworkInterface_SubResourceEmbedded() to populate field LoadBalancerInboundNatRules")
			}
			loadBalancerInboundNatRuleList[loadBalancerInboundNatRuleIndex] = loadBalancerInboundNatRule
		}
		destination.LoadBalancerInboundNatRules = loadBalancerInboundNatRuleList
	} else {
		destination.LoadBalancerInboundNatRules = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(embedded.Name)

	// Primary
	if embedded.Primary != nil {
		primary := *embedded.Primary
		destination.Primary = &primary
	} else {
		destination.Primary = nil
	}

	// PrivateIPAddress
	destination.PrivateIPAddress = genruntime.ClonePointerToString(embedded.PrivateIPAddress)

	// PrivateIPAddressVersion
	if embedded.PrivateIPAddressVersion != nil {
		privateIPAddressVersion := string(*embedded.PrivateIPAddressVersion)
		destination.PrivateIPAddressVersion = &privateIPAddressVersion
	} else {
		destination.PrivateIPAddressVersion = nil
	}

	// PrivateIPAllocationMethod
	if embedded.PrivateIPAllocationMethod != nil {
		privateIPAllocationMethod := string(*embedded.PrivateIPAllocationMethod)
		destination.PrivateIPAllocationMethod = &privateIPAllocationMethod
	} else {
		destination.PrivateIPAllocationMethod = nil
	}

	// PrivateLinkConnectionProperties
	if embedded.PrivateLinkConnectionProperties != nil {
		var privateLinkConnectionProperty v20201101s.NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_STATUS
		err := embedded.PrivateLinkConnectionProperties.AssignProperties_To_NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_STATUS(&privateLinkConnectionProperty)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_STATUS() to populate field PrivateLinkConnectionProperties")
		}
		destination.PrivateLinkConnectionProperties = &privateLinkConnectionProperty
	} else {
		destination.PrivateLinkConnectionProperties = nil
	}

	// ProvisioningState
	if embedded.ProvisioningState != nil {
		provisioningState := string(*embedded.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// PublicIPAddress
	if embedded.PublicIPAddress != nil {
		var publicIPAddress v20201101s.PublicIPAddress_STATUS_NetworkInterface_SubResourceEmbedded
		err := embedded.PublicIPAddress.AssignProperties_To_PublicIPAddress_STATUS_NetworkInterface_SubResourceEmbedded(&publicIPAddress)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_PublicIPAddress_STATUS_NetworkInterface_SubResourceEmbedded() to populate field PublicIPAddress")
		}
		destination.PublicIPAddress = &publicIPAddress
	} else {
		destination.PublicIPAddress = nil
	}

	// Subnet
	if embedded.Subnet != nil {
		var subnet v20201101s.Subnet_STATUS_NetworkInterface_SubResourceEmbedded
		err := embedded.Subnet.AssignProperties_To_Subnet_STATUS_NetworkInterface_SubResourceEmbedded(&subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Subnet_STATUS_NetworkInterface_SubResourceEmbedded() to populate field Subnet")
		}
		destination.Subnet = &subnet
	} else {
		destination.Subnet = nil
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(embedded.Type)

	// VirtualNetworkTaps
	if embedded.VirtualNetworkTaps != nil {
		virtualNetworkTapList := make([]v20201101s.VirtualNetworkTap_STATUS_NetworkInterface_SubResourceEmbedded, len(embedded.VirtualNetworkTaps))
		for virtualNetworkTapIndex, virtualNetworkTapItem := range embedded.VirtualNetworkTaps {
			// Shadow the loop variable to avoid aliasing
			virtualNetworkTapItem := virtualNetworkTapItem
			var virtualNetworkTap v20201101s.VirtualNetworkTap_STATUS_NetworkInterface_SubResourceEmbedded
			err := virtualNetworkTapItem.AssignProperties_To_VirtualNetworkTap_STATUS_NetworkInterface_SubResourceEmbedded(&virtualNetworkTap)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_VirtualNetworkTap_STATUS_NetworkInterface_SubResourceEmbedded() to populate field VirtualNetworkTaps")
			}
			virtualNetworkTapList[virtualNetworkTapIndex] = virtualNetworkTap
		}
		destination.VirtualNetworkTaps = virtualNetworkTapList
	} else {
		destination.VirtualNetworkTaps = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type NetworkInterfacePropertiesFormat_MigrationPhase_STATUS string

const (
	NetworkInterfacePropertiesFormat_MigrationPhase_STATUS_Abort     = NetworkInterfacePropertiesFormat_MigrationPhase_STATUS("Abort")
	NetworkInterfacePropertiesFormat_MigrationPhase_STATUS_Commit    = NetworkInterfacePropertiesFormat_MigrationPhase_STATUS("Commit")
	NetworkInterfacePropertiesFormat_MigrationPhase_STATUS_Committed = NetworkInterfacePropertiesFormat_MigrationPhase_STATUS("Committed")
	NetworkInterfacePropertiesFormat_MigrationPhase_STATUS_None      = NetworkInterfacePropertiesFormat_MigrationPhase_STATUS("None")
	NetworkInterfacePropertiesFormat_MigrationPhase_STATUS_Prepare   = NetworkInterfacePropertiesFormat_MigrationPhase_STATUS("Prepare")
)

// +kubebuilder:validation:Enum={"Elastic","Standard"}
type NetworkInterfacePropertiesFormat_NicType string

const (
	NetworkInterfacePropertiesFormat_NicType_Elastic  = NetworkInterfacePropertiesFormat_NicType("Elastic")
	NetworkInterfacePropertiesFormat_NicType_Standard = NetworkInterfacePropertiesFormat_NicType("Standard")
)

type NetworkInterfacePropertiesFormat_NicType_STATUS string

const (
	NetworkInterfacePropertiesFormat_NicType_STATUS_Elastic  = NetworkInterfacePropertiesFormat_NicType_STATUS("Elastic")
	NetworkInterfacePropertiesFormat_NicType_STATUS_Standard = NetworkInterfacePropertiesFormat_NicType_STATUS("Standard")
)

// Tap configuration in a Network Interface.
type NetworkInterfaceTapConfiguration_STATUS_NetworkInterface_SubResourceEmbedded struct {
	// Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &NetworkInterfaceTapConfiguration_STATUS_NetworkInterface_SubResourceEmbedded{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (embedded *NetworkInterfaceTapConfiguration_STATUS_NetworkInterface_SubResourceEmbedded) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &NetworkInterfaceTapConfiguration_STATUS_NetworkInterface_SubResourceEmbedded_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (embedded *NetworkInterfaceTapConfiguration_STATUS_NetworkInterface_SubResourceEmbedded) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(NetworkInterfaceTapConfiguration_STATUS_NetworkInterface_SubResourceEmbedded_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected NetworkInterfaceTapConfiguration_STATUS_NetworkInterface_SubResourceEmbedded_ARM, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		embedded.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_NetworkInterfaceTapConfiguration_STATUS_NetworkInterface_SubResourceEmbedded populates our NetworkInterfaceTapConfiguration_STATUS_NetworkInterface_SubResourceEmbedded from the provided source NetworkInterfaceTapConfiguration_STATUS_NetworkInterface_SubResourceEmbedded
func (embedded *NetworkInterfaceTapConfiguration_STATUS_NetworkInterface_SubResourceEmbedded) AssignProperties_From_NetworkInterfaceTapConfiguration_STATUS_NetworkInterface_SubResourceEmbedded(source *v20201101s.NetworkInterfaceTapConfiguration_STATUS_NetworkInterface_SubResourceEmbedded) error {

	// Id
	embedded.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_NetworkInterfaceTapConfiguration_STATUS_NetworkInterface_SubResourceEmbedded populates the provided destination NetworkInterfaceTapConfiguration_STATUS_NetworkInterface_SubResourceEmbedded from our NetworkInterfaceTapConfiguration_STATUS_NetworkInterface_SubResourceEmbedded
func (embedded *NetworkInterfaceTapConfiguration_STATUS_NetworkInterface_SubResourceEmbedded) AssignProperties_To_NetworkInterfaceTapConfiguration_STATUS_NetworkInterface_SubResourceEmbedded(destination *v20201101s.NetworkInterfaceTapConfiguration_STATUS_NetworkInterface_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(embedded.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// NetworkSecurityGroup resource.
type NetworkSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded struct {
	// Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &NetworkSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (embedded *NetworkSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &NetworkSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (embedded *NetworkSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(NetworkSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected NetworkSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded_ARM, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		embedded.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_NetworkSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded populates our NetworkSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded from the provided source NetworkSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded
func (embedded *NetworkSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded) AssignProperties_From_NetworkSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded(source *v20201101s.NetworkSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded) error {

	// Id
	embedded.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_NetworkSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded populates the provided destination NetworkSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded from our NetworkSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded
func (embedded *NetworkSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded) AssignProperties_To_NetworkSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded(destination *v20201101s.NetworkSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(embedded.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// NetworkSecurityGroup resource.
type NetworkSecurityGroupSpec_NetworkInterface_SubResourceEmbedded struct {
	// Reference: Resource ID.
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

var _ genruntime.ARMTransformer = &NetworkSecurityGroupSpec_NetworkInterface_SubResourceEmbedded{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (embedded *NetworkSecurityGroupSpec_NetworkInterface_SubResourceEmbedded) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if embedded == nil {
		return nil, nil
	}
	result := &NetworkSecurityGroupSpec_NetworkInterface_SubResourceEmbedded_ARM{}

	// Set property "Id":
	if embedded.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.Lookup(*embedded.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (embedded *NetworkSecurityGroupSpec_NetworkInterface_SubResourceEmbedded) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &NetworkSecurityGroupSpec_NetworkInterface_SubResourceEmbedded_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (embedded *NetworkSecurityGroupSpec_NetworkInterface_SubResourceEmbedded) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	_, ok := armInput.(NetworkSecurityGroupSpec_NetworkInterface_SubResourceEmbedded_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected NetworkSecurityGroupSpec_NetworkInterface_SubResourceEmbedded_ARM, got %T", armInput)
	}

	// no assignment for property "Reference"

	// No error
	return nil
}

// AssignProperties_From_NetworkSecurityGroupSpec_NetworkInterface_SubResourceEmbedded populates our NetworkSecurityGroupSpec_NetworkInterface_SubResourceEmbedded from the provided source NetworkSecurityGroupSpec_NetworkInterface_SubResourceEmbedded
func (embedded *NetworkSecurityGroupSpec_NetworkInterface_SubResourceEmbedded) AssignProperties_From_NetworkSecurityGroupSpec_NetworkInterface_SubResourceEmbedded(source *v20201101s.NetworkSecurityGroupSpec_NetworkInterface_SubResourceEmbedded) error {

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		embedded.Reference = &reference
	} else {
		embedded.Reference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_NetworkSecurityGroupSpec_NetworkInterface_SubResourceEmbedded populates the provided destination NetworkSecurityGroupSpec_NetworkInterface_SubResourceEmbedded from our NetworkSecurityGroupSpec_NetworkInterface_SubResourceEmbedded
func (embedded *NetworkSecurityGroupSpec_NetworkInterface_SubResourceEmbedded) AssignProperties_To_NetworkSecurityGroupSpec_NetworkInterface_SubResourceEmbedded(destination *v20201101s.NetworkSecurityGroupSpec_NetworkInterface_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Reference
	if embedded.Reference != nil {
		reference := embedded.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_NetworkSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded populates our NetworkSecurityGroupSpec_NetworkInterface_SubResourceEmbedded from the provided source NetworkSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded
func (embedded *NetworkSecurityGroupSpec_NetworkInterface_SubResourceEmbedded) Initialize_From_NetworkSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded(source *NetworkSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded) error {

	// Reference
	if source.Id != nil {
		reference := genruntime.CreateResourceReferenceFromARMID(*source.Id)
		embedded.Reference = &reference
	} else {
		embedded.Reference = nil
	}

	// No error
	return nil
}

// Private endpoint resource.
type PrivateEndpoint_STATUS_NetworkInterface_SubResourceEmbedded struct {
	// Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &PrivateEndpoint_STATUS_NetworkInterface_SubResourceEmbedded{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (embedded *PrivateEndpoint_STATUS_NetworkInterface_SubResourceEmbedded) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &PrivateEndpoint_STATUS_NetworkInterface_SubResourceEmbedded_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (embedded *PrivateEndpoint_STATUS_NetworkInterface_SubResourceEmbedded) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(PrivateEndpoint_STATUS_NetworkInterface_SubResourceEmbedded_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected PrivateEndpoint_STATUS_NetworkInterface_SubResourceEmbedded_ARM, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		embedded.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_PrivateEndpoint_STATUS_NetworkInterface_SubResourceEmbedded populates our PrivateEndpoint_STATUS_NetworkInterface_SubResourceEmbedded from the provided source PrivateEndpoint_STATUS_NetworkInterface_SubResourceEmbedded
func (embedded *PrivateEndpoint_STATUS_NetworkInterface_SubResourceEmbedded) AssignProperties_From_PrivateEndpoint_STATUS_NetworkInterface_SubResourceEmbedded(source *v20201101s.PrivateEndpoint_STATUS_NetworkInterface_SubResourceEmbedded) error {

	// Id
	embedded.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_PrivateEndpoint_STATUS_NetworkInterface_SubResourceEmbedded populates the provided destination PrivateEndpoint_STATUS_NetworkInterface_SubResourceEmbedded from our PrivateEndpoint_STATUS_NetworkInterface_SubResourceEmbedded
func (embedded *PrivateEndpoint_STATUS_NetworkInterface_SubResourceEmbedded) AssignProperties_To_PrivateEndpoint_STATUS_NetworkInterface_SubResourceEmbedded(destination *v20201101s.PrivateEndpoint_STATUS_NetworkInterface_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(embedded.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Private link service resource.
type PrivateLinkService_STATUS_NetworkInterface_SubResourceEmbedded struct {
	// Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &PrivateLinkService_STATUS_NetworkInterface_SubResourceEmbedded{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (embedded *PrivateLinkService_STATUS_NetworkInterface_SubResourceEmbedded) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &PrivateLinkService_STATUS_NetworkInterface_SubResourceEmbedded_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (embedded *PrivateLinkService_STATUS_NetworkInterface_SubResourceEmbedded) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(PrivateLinkService_STATUS_NetworkInterface_SubResourceEmbedded_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected PrivateLinkService_STATUS_NetworkInterface_SubResourceEmbedded_ARM, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		embedded.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_PrivateLinkService_STATUS_NetworkInterface_SubResourceEmbedded populates our PrivateLinkService_STATUS_NetworkInterface_SubResourceEmbedded from the provided source PrivateLinkService_STATUS_NetworkInterface_SubResourceEmbedded
func (embedded *PrivateLinkService_STATUS_NetworkInterface_SubResourceEmbedded) AssignProperties_From_PrivateLinkService_STATUS_NetworkInterface_SubResourceEmbedded(source *v20201101s.PrivateLinkService_STATUS_NetworkInterface_SubResourceEmbedded) error {

	// Id
	embedded.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_PrivateLinkService_STATUS_NetworkInterface_SubResourceEmbedded populates the provided destination PrivateLinkService_STATUS_NetworkInterface_SubResourceEmbedded from our PrivateLinkService_STATUS_NetworkInterface_SubResourceEmbedded
func (embedded *PrivateLinkService_STATUS_NetworkInterface_SubResourceEmbedded) AssignProperties_To_PrivateLinkService_STATUS_NetworkInterface_SubResourceEmbedded(destination *v20201101s.PrivateLinkService_STATUS_NetworkInterface_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(embedded.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Private link service resource.
type PrivateLinkServiceSpec struct {
	// Reference: Resource ID.
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

var _ genruntime.ARMTransformer = &PrivateLinkServiceSpec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (service *PrivateLinkServiceSpec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if service == nil {
		return nil, nil
	}
	result := &PrivateLinkServiceSpec_ARM{}

	// Set property "Id":
	if service.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.Lookup(*service.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (service *PrivateLinkServiceSpec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &PrivateLinkServiceSpec_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (service *PrivateLinkServiceSpec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	_, ok := armInput.(PrivateLinkServiceSpec_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected PrivateLinkServiceSpec_ARM, got %T", armInput)
	}

	// no assignment for property "Reference"

	// No error
	return nil
}

// AssignProperties_From_PrivateLinkServiceSpec populates our PrivateLinkServiceSpec from the provided source PrivateLinkServiceSpec
func (service *PrivateLinkServiceSpec) AssignProperties_From_PrivateLinkServiceSpec(source *v20201101s.PrivateLinkServiceSpec) error {

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		service.Reference = &reference
	} else {
		service.Reference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_PrivateLinkServiceSpec populates the provided destination PrivateLinkServiceSpec from our PrivateLinkServiceSpec
func (service *PrivateLinkServiceSpec) AssignProperties_To_PrivateLinkServiceSpec(destination *v20201101s.PrivateLinkServiceSpec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Reference
	if service.Reference != nil {
		reference := service.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_PrivateLinkService_STATUS_NetworkInterface_SubResourceEmbedded populates our PrivateLinkServiceSpec from the provided source PrivateLinkService_STATUS_NetworkInterface_SubResourceEmbedded
func (service *PrivateLinkServiceSpec) Initialize_From_PrivateLinkService_STATUS_NetworkInterface_SubResourceEmbedded(source *PrivateLinkService_STATUS_NetworkInterface_SubResourceEmbedded) error {

	// Reference
	if source.Id != nil {
		reference := genruntime.CreateResourceReferenceFromARMID(*source.Id)
		service.Reference = &reference
	} else {
		service.Reference = nil
	}

	// No error
	return nil
}

// Backend Address Pool of an application gateway.
type ApplicationGatewayBackendAddressPool_NetworkInterface_SubResourceEmbedded struct {
	// Reference: Resource ID.
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

var _ genruntime.ARMTransformer = &ApplicationGatewayBackendAddressPool_NetworkInterface_SubResourceEmbedded{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (embedded *ApplicationGatewayBackendAddressPool_NetworkInterface_SubResourceEmbedded) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if embedded == nil {
		return nil, nil
	}
	result := &ApplicationGatewayBackendAddressPool_NetworkInterface_SubResourceEmbedded_ARM{}

	// Set property "Id":
	if embedded.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.Lookup(*embedded.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (embedded *ApplicationGatewayBackendAddressPool_NetworkInterface_SubResourceEmbedded) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ApplicationGatewayBackendAddressPool_NetworkInterface_SubResourceEmbedded_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (embedded *ApplicationGatewayBackendAddressPool_NetworkInterface_SubResourceEmbedded) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	_, ok := armInput.(ApplicationGatewayBackendAddressPool_NetworkInterface_SubResourceEmbedded_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ApplicationGatewayBackendAddressPool_NetworkInterface_SubResourceEmbedded_ARM, got %T", armInput)
	}

	// no assignment for property "Reference"

	// No error
	return nil
}

// AssignProperties_From_ApplicationGatewayBackendAddressPool_NetworkInterface_SubResourceEmbedded populates our ApplicationGatewayBackendAddressPool_NetworkInterface_SubResourceEmbedded from the provided source ApplicationGatewayBackendAddressPool_NetworkInterface_SubResourceEmbedded
func (embedded *ApplicationGatewayBackendAddressPool_NetworkInterface_SubResourceEmbedded) AssignProperties_From_ApplicationGatewayBackendAddressPool_NetworkInterface_SubResourceEmbedded(source *v20201101s.ApplicationGatewayBackendAddressPool_NetworkInterface_SubResourceEmbedded) error {

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		embedded.Reference = &reference
	} else {
		embedded.Reference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ApplicationGatewayBackendAddressPool_NetworkInterface_SubResourceEmbedded populates the provided destination ApplicationGatewayBackendAddressPool_NetworkInterface_SubResourceEmbedded from our ApplicationGatewayBackendAddressPool_NetworkInterface_SubResourceEmbedded
func (embedded *ApplicationGatewayBackendAddressPool_NetworkInterface_SubResourceEmbedded) AssignProperties_To_ApplicationGatewayBackendAddressPool_NetworkInterface_SubResourceEmbedded(destination *v20201101s.ApplicationGatewayBackendAddressPool_NetworkInterface_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Reference
	if embedded.Reference != nil {
		reference := embedded.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ApplicationGatewayBackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded populates our ApplicationGatewayBackendAddressPool_NetworkInterface_SubResourceEmbedded from the provided source ApplicationGatewayBackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded
func (embedded *ApplicationGatewayBackendAddressPool_NetworkInterface_SubResourceEmbedded) Initialize_From_ApplicationGatewayBackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded(source *ApplicationGatewayBackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded) error {

	// Reference
	if source.Id != nil {
		reference := genruntime.CreateResourceReferenceFromARMID(*source.Id)
		embedded.Reference = &reference
	} else {
		embedded.Reference = nil
	}

	// No error
	return nil
}

// Backend Address Pool of an application gateway.
type ApplicationGatewayBackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded struct {
	// Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &ApplicationGatewayBackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (embedded *ApplicationGatewayBackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ApplicationGatewayBackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (embedded *ApplicationGatewayBackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ApplicationGatewayBackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ApplicationGatewayBackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded_ARM, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		embedded.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_ApplicationGatewayBackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded populates our ApplicationGatewayBackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded from the provided source ApplicationGatewayBackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded
func (embedded *ApplicationGatewayBackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded) AssignProperties_From_ApplicationGatewayBackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded(source *v20201101s.ApplicationGatewayBackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded) error {

	// Id
	embedded.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_ApplicationGatewayBackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded populates the provided destination ApplicationGatewayBackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded from our ApplicationGatewayBackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded
func (embedded *ApplicationGatewayBackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded) AssignProperties_To_ApplicationGatewayBackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded(destination *v20201101s.ApplicationGatewayBackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(embedded.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// An application security group in a resource group.
type ApplicationSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded struct {
	// Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &ApplicationSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (embedded *ApplicationSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ApplicationSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (embedded *ApplicationSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ApplicationSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ApplicationSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded_ARM, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		embedded.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_ApplicationSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded populates our ApplicationSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded from the provided source ApplicationSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded
func (embedded *ApplicationSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded) AssignProperties_From_ApplicationSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded(source *v20201101s.ApplicationSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded) error {

	// Id
	embedded.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_ApplicationSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded populates the provided destination ApplicationSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded from our ApplicationSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded
func (embedded *ApplicationSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded) AssignProperties_To_ApplicationSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded(destination *v20201101s.ApplicationSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(embedded.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// An application security group in a resource group.
type ApplicationSecurityGroupSpec_NetworkInterface_SubResourceEmbedded struct {
	// Reference: Resource ID.
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

var _ genruntime.ARMTransformer = &ApplicationSecurityGroupSpec_NetworkInterface_SubResourceEmbedded{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (embedded *ApplicationSecurityGroupSpec_NetworkInterface_SubResourceEmbedded) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if embedded == nil {
		return nil, nil
	}
	result := &ApplicationSecurityGroupSpec_NetworkInterface_SubResourceEmbedded_ARM{}

	// Set property "Id":
	if embedded.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.Lookup(*embedded.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (embedded *ApplicationSecurityGroupSpec_NetworkInterface_SubResourceEmbedded) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ApplicationSecurityGroupSpec_NetworkInterface_SubResourceEmbedded_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (embedded *ApplicationSecurityGroupSpec_NetworkInterface_SubResourceEmbedded) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	_, ok := armInput.(ApplicationSecurityGroupSpec_NetworkInterface_SubResourceEmbedded_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ApplicationSecurityGroupSpec_NetworkInterface_SubResourceEmbedded_ARM, got %T", armInput)
	}

	// no assignment for property "Reference"

	// No error
	return nil
}

// AssignProperties_From_ApplicationSecurityGroupSpec_NetworkInterface_SubResourceEmbedded populates our ApplicationSecurityGroupSpec_NetworkInterface_SubResourceEmbedded from the provided source ApplicationSecurityGroupSpec_NetworkInterface_SubResourceEmbedded
func (embedded *ApplicationSecurityGroupSpec_NetworkInterface_SubResourceEmbedded) AssignProperties_From_ApplicationSecurityGroupSpec_NetworkInterface_SubResourceEmbedded(source *v20201101s.ApplicationSecurityGroupSpec_NetworkInterface_SubResourceEmbedded) error {

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		embedded.Reference = &reference
	} else {
		embedded.Reference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ApplicationSecurityGroupSpec_NetworkInterface_SubResourceEmbedded populates the provided destination ApplicationSecurityGroupSpec_NetworkInterface_SubResourceEmbedded from our ApplicationSecurityGroupSpec_NetworkInterface_SubResourceEmbedded
func (embedded *ApplicationSecurityGroupSpec_NetworkInterface_SubResourceEmbedded) AssignProperties_To_ApplicationSecurityGroupSpec_NetworkInterface_SubResourceEmbedded(destination *v20201101s.ApplicationSecurityGroupSpec_NetworkInterface_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Reference
	if embedded.Reference != nil {
		reference := embedded.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ApplicationSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded populates our ApplicationSecurityGroupSpec_NetworkInterface_SubResourceEmbedded from the provided source ApplicationSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded
func (embedded *ApplicationSecurityGroupSpec_NetworkInterface_SubResourceEmbedded) Initialize_From_ApplicationSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded(source *ApplicationSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded) error {

	// Reference
	if source.Id != nil {
		reference := genruntime.CreateResourceReferenceFromARMID(*source.Id)
		embedded.Reference = &reference
	} else {
		embedded.Reference = nil
	}

	// No error
	return nil
}

// Pool of backend IP addresses.
type BackendAddressPool_NetworkInterface_SubResourceEmbedded struct {
	// Reference: Resource ID.
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

var _ genruntime.ARMTransformer = &BackendAddressPool_NetworkInterface_SubResourceEmbedded{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (embedded *BackendAddressPool_NetworkInterface_SubResourceEmbedded) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if embedded == nil {
		return nil, nil
	}
	result := &BackendAddressPool_NetworkInterface_SubResourceEmbedded_ARM{}

	// Set property "Id":
	if embedded.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.Lookup(*embedded.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (embedded *BackendAddressPool_NetworkInterface_SubResourceEmbedded) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &BackendAddressPool_NetworkInterface_SubResourceEmbedded_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (embedded *BackendAddressPool_NetworkInterface_SubResourceEmbedded) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	_, ok := armInput.(BackendAddressPool_NetworkInterface_SubResourceEmbedded_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected BackendAddressPool_NetworkInterface_SubResourceEmbedded_ARM, got %T", armInput)
	}

	// no assignment for property "Reference"

	// No error
	return nil
}

// AssignProperties_From_BackendAddressPool_NetworkInterface_SubResourceEmbedded populates our BackendAddressPool_NetworkInterface_SubResourceEmbedded from the provided source BackendAddressPool_NetworkInterface_SubResourceEmbedded
func (embedded *BackendAddressPool_NetworkInterface_SubResourceEmbedded) AssignProperties_From_BackendAddressPool_NetworkInterface_SubResourceEmbedded(source *v20201101s.BackendAddressPool_NetworkInterface_SubResourceEmbedded) error {

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		embedded.Reference = &reference
	} else {
		embedded.Reference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_BackendAddressPool_NetworkInterface_SubResourceEmbedded populates the provided destination BackendAddressPool_NetworkInterface_SubResourceEmbedded from our BackendAddressPool_NetworkInterface_SubResourceEmbedded
func (embedded *BackendAddressPool_NetworkInterface_SubResourceEmbedded) AssignProperties_To_BackendAddressPool_NetworkInterface_SubResourceEmbedded(destination *v20201101s.BackendAddressPool_NetworkInterface_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Reference
	if embedded.Reference != nil {
		reference := embedded.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_BackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded populates our BackendAddressPool_NetworkInterface_SubResourceEmbedded from the provided source BackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded
func (embedded *BackendAddressPool_NetworkInterface_SubResourceEmbedded) Initialize_From_BackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded(source *BackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded) error {

	// Reference
	if source.Id != nil {
		reference := genruntime.CreateResourceReferenceFromARMID(*source.Id)
		embedded.Reference = &reference
	} else {
		embedded.Reference = nil
	}

	// No error
	return nil
}

// Pool of backend IP addresses.
type BackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded struct {
	// Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &BackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (embedded *BackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &BackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (embedded *BackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(BackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected BackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded_ARM, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		embedded.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_BackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded populates our BackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded from the provided source BackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded
func (embedded *BackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded) AssignProperties_From_BackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded(source *v20201101s.BackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded) error {

	// Id
	embedded.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_BackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded populates the provided destination BackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded from our BackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded
func (embedded *BackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded) AssignProperties_To_BackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded(destination *v20201101s.BackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(embedded.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Inbound NAT rule of the load balancer.
type InboundNatRule_NetworkInterface_SubResourceEmbedded struct {
	// Reference: Resource ID.
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

var _ genruntime.ARMTransformer = &InboundNatRule_NetworkInterface_SubResourceEmbedded{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (embedded *InboundNatRule_NetworkInterface_SubResourceEmbedded) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if embedded == nil {
		return nil, nil
	}
	result := &InboundNatRule_NetworkInterface_SubResourceEmbedded_ARM{}

	// Set property "Id":
	if embedded.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.Lookup(*embedded.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (embedded *InboundNatRule_NetworkInterface_SubResourceEmbedded) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &InboundNatRule_NetworkInterface_SubResourceEmbedded_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (embedded *InboundNatRule_NetworkInterface_SubResourceEmbedded) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	_, ok := armInput.(InboundNatRule_NetworkInterface_SubResourceEmbedded_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected InboundNatRule_NetworkInterface_SubResourceEmbedded_ARM, got %T", armInput)
	}

	// no assignment for property "Reference"

	// No error
	return nil
}

// AssignProperties_From_InboundNatRule_NetworkInterface_SubResourceEmbedded populates our InboundNatRule_NetworkInterface_SubResourceEmbedded from the provided source InboundNatRule_NetworkInterface_SubResourceEmbedded
func (embedded *InboundNatRule_NetworkInterface_SubResourceEmbedded) AssignProperties_From_InboundNatRule_NetworkInterface_SubResourceEmbedded(source *v20201101s.InboundNatRule_NetworkInterface_SubResourceEmbedded) error {

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		embedded.Reference = &reference
	} else {
		embedded.Reference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_InboundNatRule_NetworkInterface_SubResourceEmbedded populates the provided destination InboundNatRule_NetworkInterface_SubResourceEmbedded from our InboundNatRule_NetworkInterface_SubResourceEmbedded
func (embedded *InboundNatRule_NetworkInterface_SubResourceEmbedded) AssignProperties_To_InboundNatRule_NetworkInterface_SubResourceEmbedded(destination *v20201101s.InboundNatRule_NetworkInterface_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Reference
	if embedded.Reference != nil {
		reference := embedded.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_InboundNatRule_STATUS_NetworkInterface_SubResourceEmbedded populates our InboundNatRule_NetworkInterface_SubResourceEmbedded from the provided source InboundNatRule_STATUS_NetworkInterface_SubResourceEmbedded
func (embedded *InboundNatRule_NetworkInterface_SubResourceEmbedded) Initialize_From_InboundNatRule_STATUS_NetworkInterface_SubResourceEmbedded(source *InboundNatRule_STATUS_NetworkInterface_SubResourceEmbedded) error {

	// Reference
	if source.Id != nil {
		reference := genruntime.CreateResourceReferenceFromARMID(*source.Id)
		embedded.Reference = &reference
	} else {
		embedded.Reference = nil
	}

	// No error
	return nil
}

// Inbound NAT rule of the load balancer.
type InboundNatRule_STATUS_NetworkInterface_SubResourceEmbedded struct {
	// Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &InboundNatRule_STATUS_NetworkInterface_SubResourceEmbedded{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (embedded *InboundNatRule_STATUS_NetworkInterface_SubResourceEmbedded) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &InboundNatRule_STATUS_NetworkInterface_SubResourceEmbedded_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (embedded *InboundNatRule_STATUS_NetworkInterface_SubResourceEmbedded) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(InboundNatRule_STATUS_NetworkInterface_SubResourceEmbedded_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected InboundNatRule_STATUS_NetworkInterface_SubResourceEmbedded_ARM, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		embedded.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_InboundNatRule_STATUS_NetworkInterface_SubResourceEmbedded populates our InboundNatRule_STATUS_NetworkInterface_SubResourceEmbedded from the provided source InboundNatRule_STATUS_NetworkInterface_SubResourceEmbedded
func (embedded *InboundNatRule_STATUS_NetworkInterface_SubResourceEmbedded) AssignProperties_From_InboundNatRule_STATUS_NetworkInterface_SubResourceEmbedded(source *v20201101s.InboundNatRule_STATUS_NetworkInterface_SubResourceEmbedded) error {

	// Id
	embedded.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_InboundNatRule_STATUS_NetworkInterface_SubResourceEmbedded populates the provided destination InboundNatRule_STATUS_NetworkInterface_SubResourceEmbedded from our InboundNatRule_STATUS_NetworkInterface_SubResourceEmbedded
func (embedded *InboundNatRule_STATUS_NetworkInterface_SubResourceEmbedded) AssignProperties_To_InboundNatRule_STATUS_NetworkInterface_SubResourceEmbedded(destination *v20201101s.InboundNatRule_STATUS_NetworkInterface_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(embedded.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// PrivateLinkConnection properties for the network interface.
type NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_STATUS struct {
	// Fqdns: List of FQDNs for current private link connection.
	Fqdns []string `json:"fqdns,omitempty"`

	// GroupId: The group ID for current private link connection.
	GroupId *string `json:"groupId,omitempty"`

	// RequiredMemberName: The required member name for current private link connection.
	RequiredMemberName *string `json:"requiredMemberName,omitempty"`
}

var _ genruntime.FromARMConverter = &NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_STATUS_ARM, got %T", armInput)
	}

	// Set property "Fqdns":
	for _, item := range typedInput.Fqdns {
		properties.Fqdns = append(properties.Fqdns, item)
	}

	// Set property "GroupId":
	if typedInput.GroupId != nil {
		groupId := *typedInput.GroupId
		properties.GroupId = &groupId
	}

	// Set property "RequiredMemberName":
	if typedInput.RequiredMemberName != nil {
		requiredMemberName := *typedInput.RequiredMemberName
		properties.RequiredMemberName = &requiredMemberName
	}

	// No error
	return nil
}

// AssignProperties_From_NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_STATUS populates our NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_STATUS from the provided source NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_STATUS
func (properties *NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_STATUS) AssignProperties_From_NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_STATUS(source *v20201101s.NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_STATUS) error {

	// Fqdns
	properties.Fqdns = genruntime.CloneSliceOfString(source.Fqdns)

	// GroupId
	properties.GroupId = genruntime.ClonePointerToString(source.GroupId)

	// RequiredMemberName
	properties.RequiredMemberName = genruntime.ClonePointerToString(source.RequiredMemberName)

	// No error
	return nil
}

// AssignProperties_To_NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_STATUS populates the provided destination NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_STATUS from our NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_STATUS
func (properties *NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_STATUS) AssignProperties_To_NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_STATUS(destination *v20201101s.NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Fqdns
	destination.Fqdns = genruntime.CloneSliceOfString(properties.Fqdns)

	// GroupId
	destination.GroupId = genruntime.ClonePointerToString(properties.GroupId)

	// RequiredMemberName
	destination.RequiredMemberName = genruntime.ClonePointerToString(properties.RequiredMemberName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Public IP address resource.
type PublicIPAddress_STATUS_NetworkInterface_SubResourceEmbedded struct {
	// Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &PublicIPAddress_STATUS_NetworkInterface_SubResourceEmbedded{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (embedded *PublicIPAddress_STATUS_NetworkInterface_SubResourceEmbedded) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &PublicIPAddress_STATUS_NetworkInterface_SubResourceEmbedded_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (embedded *PublicIPAddress_STATUS_NetworkInterface_SubResourceEmbedded) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(PublicIPAddress_STATUS_NetworkInterface_SubResourceEmbedded_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected PublicIPAddress_STATUS_NetworkInterface_SubResourceEmbedded_ARM, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		embedded.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_PublicIPAddress_STATUS_NetworkInterface_SubResourceEmbedded populates our PublicIPAddress_STATUS_NetworkInterface_SubResourceEmbedded from the provided source PublicIPAddress_STATUS_NetworkInterface_SubResourceEmbedded
func (embedded *PublicIPAddress_STATUS_NetworkInterface_SubResourceEmbedded) AssignProperties_From_PublicIPAddress_STATUS_NetworkInterface_SubResourceEmbedded(source *v20201101s.PublicIPAddress_STATUS_NetworkInterface_SubResourceEmbedded) error {

	// Id
	embedded.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_PublicIPAddress_STATUS_NetworkInterface_SubResourceEmbedded populates the provided destination PublicIPAddress_STATUS_NetworkInterface_SubResourceEmbedded from our PublicIPAddress_STATUS_NetworkInterface_SubResourceEmbedded
func (embedded *PublicIPAddress_STATUS_NetworkInterface_SubResourceEmbedded) AssignProperties_To_PublicIPAddress_STATUS_NetworkInterface_SubResourceEmbedded(destination *v20201101s.PublicIPAddress_STATUS_NetworkInterface_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(embedded.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Public IP address resource.
type PublicIPAddressSpec_NetworkInterface_SubResourceEmbedded struct {
	// Reference: Resource ID.
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

var _ genruntime.ARMTransformer = &PublicIPAddressSpec_NetworkInterface_SubResourceEmbedded{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (embedded *PublicIPAddressSpec_NetworkInterface_SubResourceEmbedded) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if embedded == nil {
		return nil, nil
	}
	result := &PublicIPAddressSpec_NetworkInterface_SubResourceEmbedded_ARM{}

	// Set property "Id":
	if embedded.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.Lookup(*embedded.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (embedded *PublicIPAddressSpec_NetworkInterface_SubResourceEmbedded) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &PublicIPAddressSpec_NetworkInterface_SubResourceEmbedded_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (embedded *PublicIPAddressSpec_NetworkInterface_SubResourceEmbedded) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	_, ok := armInput.(PublicIPAddressSpec_NetworkInterface_SubResourceEmbedded_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected PublicIPAddressSpec_NetworkInterface_SubResourceEmbedded_ARM, got %T", armInput)
	}

	// no assignment for property "Reference"

	// No error
	return nil
}

// AssignProperties_From_PublicIPAddressSpec_NetworkInterface_SubResourceEmbedded populates our PublicIPAddressSpec_NetworkInterface_SubResourceEmbedded from the provided source PublicIPAddressSpec_NetworkInterface_SubResourceEmbedded
func (embedded *PublicIPAddressSpec_NetworkInterface_SubResourceEmbedded) AssignProperties_From_PublicIPAddressSpec_NetworkInterface_SubResourceEmbedded(source *v20201101s.PublicIPAddressSpec_NetworkInterface_SubResourceEmbedded) error {

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		embedded.Reference = &reference
	} else {
		embedded.Reference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_PublicIPAddressSpec_NetworkInterface_SubResourceEmbedded populates the provided destination PublicIPAddressSpec_NetworkInterface_SubResourceEmbedded from our PublicIPAddressSpec_NetworkInterface_SubResourceEmbedded
func (embedded *PublicIPAddressSpec_NetworkInterface_SubResourceEmbedded) AssignProperties_To_PublicIPAddressSpec_NetworkInterface_SubResourceEmbedded(destination *v20201101s.PublicIPAddressSpec_NetworkInterface_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Reference
	if embedded.Reference != nil {
		reference := embedded.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_PublicIPAddress_STATUS_NetworkInterface_SubResourceEmbedded populates our PublicIPAddressSpec_NetworkInterface_SubResourceEmbedded from the provided source PublicIPAddress_STATUS_NetworkInterface_SubResourceEmbedded
func (embedded *PublicIPAddressSpec_NetworkInterface_SubResourceEmbedded) Initialize_From_PublicIPAddress_STATUS_NetworkInterface_SubResourceEmbedded(source *PublicIPAddress_STATUS_NetworkInterface_SubResourceEmbedded) error {

	// Reference
	if source.Id != nil {
		reference := genruntime.CreateResourceReferenceFromARMID(*source.Id)
		embedded.Reference = &reference
	} else {
		embedded.Reference = nil
	}

	// No error
	return nil
}

// Subnet in a virtual network resource.
type Subnet_NetworkInterface_SubResourceEmbedded struct {
	// Reference: Resource ID.
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

var _ genruntime.ARMTransformer = &Subnet_NetworkInterface_SubResourceEmbedded{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (embedded *Subnet_NetworkInterface_SubResourceEmbedded) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if embedded == nil {
		return nil, nil
	}
	result := &Subnet_NetworkInterface_SubResourceEmbedded_ARM{}

	// Set property "Id":
	if embedded.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.Lookup(*embedded.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (embedded *Subnet_NetworkInterface_SubResourceEmbedded) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Subnet_NetworkInterface_SubResourceEmbedded_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (embedded *Subnet_NetworkInterface_SubResourceEmbedded) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	_, ok := armInput.(Subnet_NetworkInterface_SubResourceEmbedded_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Subnet_NetworkInterface_SubResourceEmbedded_ARM, got %T", armInput)
	}

	// no assignment for property "Reference"

	// No error
	return nil
}

// AssignProperties_From_Subnet_NetworkInterface_SubResourceEmbedded populates our Subnet_NetworkInterface_SubResourceEmbedded from the provided source Subnet_NetworkInterface_SubResourceEmbedded
func (embedded *Subnet_NetworkInterface_SubResourceEmbedded) AssignProperties_From_Subnet_NetworkInterface_SubResourceEmbedded(source *v20201101s.Subnet_NetworkInterface_SubResourceEmbedded) error {

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		embedded.Reference = &reference
	} else {
		embedded.Reference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Subnet_NetworkInterface_SubResourceEmbedded populates the provided destination Subnet_NetworkInterface_SubResourceEmbedded from our Subnet_NetworkInterface_SubResourceEmbedded
func (embedded *Subnet_NetworkInterface_SubResourceEmbedded) AssignProperties_To_Subnet_NetworkInterface_SubResourceEmbedded(destination *v20201101s.Subnet_NetworkInterface_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Reference
	if embedded.Reference != nil {
		reference := embedded.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_Subnet_STATUS_NetworkInterface_SubResourceEmbedded populates our Subnet_NetworkInterface_SubResourceEmbedded from the provided source Subnet_STATUS_NetworkInterface_SubResourceEmbedded
func (embedded *Subnet_NetworkInterface_SubResourceEmbedded) Initialize_From_Subnet_STATUS_NetworkInterface_SubResourceEmbedded(source *Subnet_STATUS_NetworkInterface_SubResourceEmbedded) error {

	// Reference
	if source.Id != nil {
		reference := genruntime.CreateResourceReferenceFromARMID(*source.Id)
		embedded.Reference = &reference
	} else {
		embedded.Reference = nil
	}

	// No error
	return nil
}

// Subnet in a virtual network resource.
type Subnet_STATUS_NetworkInterface_SubResourceEmbedded struct {
	// Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &Subnet_STATUS_NetworkInterface_SubResourceEmbedded{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (embedded *Subnet_STATUS_NetworkInterface_SubResourceEmbedded) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Subnet_STATUS_NetworkInterface_SubResourceEmbedded_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (embedded *Subnet_STATUS_NetworkInterface_SubResourceEmbedded) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Subnet_STATUS_NetworkInterface_SubResourceEmbedded_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Subnet_STATUS_NetworkInterface_SubResourceEmbedded_ARM, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		embedded.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_Subnet_STATUS_NetworkInterface_SubResourceEmbedded populates our Subnet_STATUS_NetworkInterface_SubResourceEmbedded from the provided source Subnet_STATUS_NetworkInterface_SubResourceEmbedded
func (embedded *Subnet_STATUS_NetworkInterface_SubResourceEmbedded) AssignProperties_From_Subnet_STATUS_NetworkInterface_SubResourceEmbedded(source *v20201101s.Subnet_STATUS_NetworkInterface_SubResourceEmbedded) error {

	// Id
	embedded.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_Subnet_STATUS_NetworkInterface_SubResourceEmbedded populates the provided destination Subnet_STATUS_NetworkInterface_SubResourceEmbedded from our Subnet_STATUS_NetworkInterface_SubResourceEmbedded
func (embedded *Subnet_STATUS_NetworkInterface_SubResourceEmbedded) AssignProperties_To_Subnet_STATUS_NetworkInterface_SubResourceEmbedded(destination *v20201101s.Subnet_STATUS_NetworkInterface_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(embedded.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Virtual Network Tap resource.
type VirtualNetworkTap_STATUS_NetworkInterface_SubResourceEmbedded struct {
	// Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualNetworkTap_STATUS_NetworkInterface_SubResourceEmbedded{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (embedded *VirtualNetworkTap_STATUS_NetworkInterface_SubResourceEmbedded) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualNetworkTap_STATUS_NetworkInterface_SubResourceEmbedded_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (embedded *VirtualNetworkTap_STATUS_NetworkInterface_SubResourceEmbedded) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualNetworkTap_STATUS_NetworkInterface_SubResourceEmbedded_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualNetworkTap_STATUS_NetworkInterface_SubResourceEmbedded_ARM, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		embedded.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualNetworkTap_STATUS_NetworkInterface_SubResourceEmbedded populates our VirtualNetworkTap_STATUS_NetworkInterface_SubResourceEmbedded from the provided source VirtualNetworkTap_STATUS_NetworkInterface_SubResourceEmbedded
func (embedded *VirtualNetworkTap_STATUS_NetworkInterface_SubResourceEmbedded) AssignProperties_From_VirtualNetworkTap_STATUS_NetworkInterface_SubResourceEmbedded(source *v20201101s.VirtualNetworkTap_STATUS_NetworkInterface_SubResourceEmbedded) error {

	// Id
	embedded.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_VirtualNetworkTap_STATUS_NetworkInterface_SubResourceEmbedded populates the provided destination VirtualNetworkTap_STATUS_NetworkInterface_SubResourceEmbedded from our VirtualNetworkTap_STATUS_NetworkInterface_SubResourceEmbedded
func (embedded *VirtualNetworkTap_STATUS_NetworkInterface_SubResourceEmbedded) AssignProperties_To_VirtualNetworkTap_STATUS_NetworkInterface_SubResourceEmbedded(destination *v20201101s.VirtualNetworkTap_STATUS_NetworkInterface_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(embedded.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Virtual Network Tap resource.
type VirtualNetworkTapSpec_NetworkInterface_SubResourceEmbedded struct {
	// Reference: Resource ID.
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualNetworkTapSpec_NetworkInterface_SubResourceEmbedded{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (embedded *VirtualNetworkTapSpec_NetworkInterface_SubResourceEmbedded) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if embedded == nil {
		return nil, nil
	}
	result := &VirtualNetworkTapSpec_NetworkInterface_SubResourceEmbedded_ARM{}

	// Set property "Id":
	if embedded.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.Lookup(*embedded.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (embedded *VirtualNetworkTapSpec_NetworkInterface_SubResourceEmbedded) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualNetworkTapSpec_NetworkInterface_SubResourceEmbedded_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (embedded *VirtualNetworkTapSpec_NetworkInterface_SubResourceEmbedded) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	_, ok := armInput.(VirtualNetworkTapSpec_NetworkInterface_SubResourceEmbedded_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualNetworkTapSpec_NetworkInterface_SubResourceEmbedded_ARM, got %T", armInput)
	}

	// no assignment for property "Reference"

	// No error
	return nil
}

// AssignProperties_From_VirtualNetworkTapSpec_NetworkInterface_SubResourceEmbedded populates our VirtualNetworkTapSpec_NetworkInterface_SubResourceEmbedded from the provided source VirtualNetworkTapSpec_NetworkInterface_SubResourceEmbedded
func (embedded *VirtualNetworkTapSpec_NetworkInterface_SubResourceEmbedded) AssignProperties_From_VirtualNetworkTapSpec_NetworkInterface_SubResourceEmbedded(source *v20201101s.VirtualNetworkTapSpec_NetworkInterface_SubResourceEmbedded) error {

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		embedded.Reference = &reference
	} else {
		embedded.Reference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualNetworkTapSpec_NetworkInterface_SubResourceEmbedded populates the provided destination VirtualNetworkTapSpec_NetworkInterface_SubResourceEmbedded from our VirtualNetworkTapSpec_NetworkInterface_SubResourceEmbedded
func (embedded *VirtualNetworkTapSpec_NetworkInterface_SubResourceEmbedded) AssignProperties_To_VirtualNetworkTapSpec_NetworkInterface_SubResourceEmbedded(destination *v20201101s.VirtualNetworkTapSpec_NetworkInterface_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Reference
	if embedded.Reference != nil {
		reference := embedded.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_VirtualNetworkTap_STATUS_NetworkInterface_SubResourceEmbedded populates our VirtualNetworkTapSpec_NetworkInterface_SubResourceEmbedded from the provided source VirtualNetworkTap_STATUS_NetworkInterface_SubResourceEmbedded
func (embedded *VirtualNetworkTapSpec_NetworkInterface_SubResourceEmbedded) Initialize_From_VirtualNetworkTap_STATUS_NetworkInterface_SubResourceEmbedded(source *VirtualNetworkTap_STATUS_NetworkInterface_SubResourceEmbedded) error {

	// Reference
	if source.Id != nil {
		reference := genruntime.CreateResourceReferenceFromARMID(*source.Id)
		embedded.Reference = &reference
	} else {
		embedded.Reference = nil
	}

	// No error
	return nil
}

func init() {
	SchemeBuilder.Register(&NetworkInterface{}, &NetworkInterfaceList{})
}
