// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20230501

import (
	"fmt"
	v20230501s "github.com/Azure/azure-service-operator/v2/api/kubernetesconfiguration/v1api20230501/storage"
	"github.com/Azure/azure-service-operator/v2/internal/reflecthelpers"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/pkg/errors"
	"k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
	"sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Generator information:
// - Generated from: /kubernetesconfiguration/resource-manager/Microsoft.KubernetesConfiguration/stable/2023-05-01/extensions.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{clusterRp}/{clusterResourceName}/{clusterName}/providers/Microsoft.KubernetesConfiguration/extensions/{extensionName}
type Extension struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              Extension_Spec   `json:"spec,omitempty"`
	Status            Extension_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &Extension{}

// GetConditions returns the conditions of the resource
func (extension *Extension) GetConditions() conditions.Conditions {
	return extension.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (extension *Extension) SetConditions(conditions conditions.Conditions) {
	extension.Status.Conditions = conditions
}

var _ conversion.Convertible = &Extension{}

// ConvertFrom populates our Extension from the provided hub Extension
func (extension *Extension) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*v20230501s.Extension)
	if !ok {
		return fmt.Errorf("expected kubernetesconfiguration/v1api20230501/storage/Extension but received %T instead", hub)
	}

	return extension.AssignProperties_From_Extension(source)
}

// ConvertTo populates the provided hub Extension from our Extension
func (extension *Extension) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*v20230501s.Extension)
	if !ok {
		return fmt.Errorf("expected kubernetesconfiguration/v1api20230501/storage/Extension but received %T instead", hub)
	}

	return extension.AssignProperties_To_Extension(destination)
}

// +kubebuilder:webhook:path=/mutate-kubernetesconfiguration-azure-com-v1api20230501-extension,mutating=true,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=kubernetesconfiguration.azure.com,resources=extensions,verbs=create;update,versions=v1api20230501,name=default.v1api20230501.extensions.kubernetesconfiguration.azure.com,admissionReviewVersions=v1

var _ admission.Defaulter = &Extension{}

// Default applies defaults to the Extension resource
func (extension *Extension) Default() {
	extension.defaultImpl()
	var temp any = extension
	if runtimeDefaulter, ok := temp.(genruntime.Defaulter); ok {
		runtimeDefaulter.CustomDefault()
	}
}

// defaultAzureName defaults the Azure name of the resource to the Kubernetes name
func (extension *Extension) defaultAzureName() {
	if extension.Spec.AzureName == "" {
		extension.Spec.AzureName = extension.Name
	}
}

// defaultImpl applies the code generated defaults to the Extension resource
func (extension *Extension) defaultImpl() { extension.defaultAzureName() }

var _ genruntime.ImportableResource = &Extension{}

// InitializeSpec initializes the spec for this resource from the given status
func (extension *Extension) InitializeSpec(status genruntime.ConvertibleStatus) error {
	if s, ok := status.(*Extension_STATUS); ok {
		return extension.Spec.Initialize_From_Extension_STATUS(s)
	}

	return fmt.Errorf("expected Status of type Extension_STATUS but received %T instead", status)
}

var _ genruntime.KubernetesResource = &Extension{}

// AzureName returns the Azure name of the resource
func (extension *Extension) AzureName() string {
	return extension.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2023-05-01"
func (extension Extension) GetAPIVersion() string {
	return string(APIVersion_Value)
}

// GetResourceScope returns the scope of the resource
func (extension *Extension) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeExtension
}

// GetSpec returns the specification of this resource
func (extension *Extension) GetSpec() genruntime.ConvertibleSpec {
	return &extension.Spec
}

// GetStatus returns the status of this resource
func (extension *Extension) GetStatus() genruntime.ConvertibleStatus {
	return &extension.Status
}

// GetSupportedOperations returns the operations supported by the resource
func (extension *Extension) GetSupportedOperations() []genruntime.ResourceOperation {
	return []genruntime.ResourceOperation{
		genruntime.ResourceOperationDelete,
		genruntime.ResourceOperationGet,
		genruntime.ResourceOperationPut,
	}
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.KubernetesConfiguration/extensions"
func (extension *Extension) GetType() string {
	return "Microsoft.KubernetesConfiguration/extensions"
}

// NewEmptyStatus returns a new empty (blank) status
func (extension *Extension) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &Extension_STATUS{}
}

// Owner returns the ResourceReference of the owner
func (extension *Extension) Owner() *genruntime.ResourceReference {
	return extension.Spec.Owner.AsResourceReference()
}

// SetStatus sets the status of this resource
func (extension *Extension) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*Extension_STATUS); ok {
		extension.Status = *st
		return nil
	}

	// Convert status to required version
	var st Extension_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return errors.Wrap(err, "failed to convert status")
	}

	extension.Status = st
	return nil
}

// +kubebuilder:webhook:path=/validate-kubernetesconfiguration-azure-com-v1api20230501-extension,mutating=false,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=kubernetesconfiguration.azure.com,resources=extensions,verbs=create;update,versions=v1api20230501,name=validate.v1api20230501.extensions.kubernetesconfiguration.azure.com,admissionReviewVersions=v1

var _ admission.Validator = &Extension{}

// ValidateCreate validates the creation of the resource
func (extension *Extension) ValidateCreate() (admission.Warnings, error) {
	validations := extension.createValidations()
	var temp any = extension
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.CreateValidations()...)
	}
	return genruntime.ValidateCreate(validations)
}

// ValidateDelete validates the deletion of the resource
func (extension *Extension) ValidateDelete() (admission.Warnings, error) {
	validations := extension.deleteValidations()
	var temp any = extension
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.DeleteValidations()...)
	}
	return genruntime.ValidateDelete(validations)
}

// ValidateUpdate validates an update of the resource
func (extension *Extension) ValidateUpdate(old runtime.Object) (admission.Warnings, error) {
	validations := extension.updateValidations()
	var temp any = extension
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.UpdateValidations()...)
	}
	return genruntime.ValidateUpdate(old, validations)
}

// createValidations validates the creation of the resource
func (extension *Extension) createValidations() []func() (admission.Warnings, error) {
	return []func() (admission.Warnings, error){extension.validateResourceReferences}
}

// deleteValidations validates the deletion of the resource
func (extension *Extension) deleteValidations() []func() (admission.Warnings, error) {
	return nil
}

// updateValidations validates the update of the resource
func (extension *Extension) updateValidations() []func(old runtime.Object) (admission.Warnings, error) {
	return []func(old runtime.Object) (admission.Warnings, error){
		func(old runtime.Object) (admission.Warnings, error) {
			return extension.validateResourceReferences()
		},
		extension.validateWriteOnceProperties}
}

// validateResourceReferences validates all resource references
func (extension *Extension) validateResourceReferences() (admission.Warnings, error) {
	refs, err := reflecthelpers.FindResourceReferences(&extension.Spec)
	if err != nil {
		return nil, err
	}
	return genruntime.ValidateResourceReferences(refs)
}

// validateWriteOnceProperties validates all WriteOnce properties
func (extension *Extension) validateWriteOnceProperties(old runtime.Object) (admission.Warnings, error) {
	oldObj, ok := old.(*Extension)
	if !ok {
		return nil, nil
	}

	return genruntime.ValidateWriteOnceProperties(oldObj, extension)
}

// AssignProperties_From_Extension populates our Extension from the provided source Extension
func (extension *Extension) AssignProperties_From_Extension(source *v20230501s.Extension) error {

	// ObjectMeta
	extension.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec Extension_Spec
	err := spec.AssignProperties_From_Extension_Spec(&source.Spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_Extension_Spec() to populate field Spec")
	}
	extension.Spec = spec

	// Status
	var status Extension_STATUS
	err = status.AssignProperties_From_Extension_STATUS(&source.Status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_Extension_STATUS() to populate field Status")
	}
	extension.Status = status

	// No error
	return nil
}

// AssignProperties_To_Extension populates the provided destination Extension from our Extension
func (extension *Extension) AssignProperties_To_Extension(destination *v20230501s.Extension) error {

	// ObjectMeta
	destination.ObjectMeta = *extension.ObjectMeta.DeepCopy()

	// Spec
	var spec v20230501s.Extension_Spec
	err := extension.Spec.AssignProperties_To_Extension_Spec(&spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_Extension_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status v20230501s.Extension_STATUS
	err = extension.Status.AssignProperties_To_Extension_STATUS(&status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_Extension_STATUS() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (extension *Extension) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: extension.Spec.OriginalVersion(),
		Kind:    "Extension",
	}
}

// +kubebuilder:object:root=true
// Generator information:
// - Generated from: /kubernetesconfiguration/resource-manager/Microsoft.KubernetesConfiguration/stable/2023-05-01/extensions.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{clusterRp}/{clusterResourceName}/{clusterName}/providers/Microsoft.KubernetesConfiguration/extensions/{extensionName}
type ExtensionList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Extension `json:"items"`
}

// +kubebuilder:validation:Enum={"2023-05-01"}
type APIVersion string

const APIVersion_Value = APIVersion("2023-05-01")

type Extension_Spec struct {
	// AksAssignedIdentity: Identity of the Extension resource in an AKS cluster
	AksAssignedIdentity *Extension_Properties_AksAssignedIdentity_Spec `json:"aksAssignedIdentity,omitempty"`

	// AutoUpgradeMinorVersion: Flag to note if this extension participates in auto upgrade of minor version, or not.
	AutoUpgradeMinorVersion *bool `json:"autoUpgradeMinorVersion,omitempty"`

	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName string `json:"azureName,omitempty"`

	// ConfigurationSettings: Configuration settings, as name-value pairs for configuring this extension.
	ConfigurationSettings map[string]string `json:"configurationSettings,omitempty"`

	// ExtensionType: Type of the Extension, of which this resource is an instance of.  It must be one of the Extension Types
	// registered with Microsoft.KubernetesConfiguration by the Extension publisher.
	ExtensionType *string `json:"extensionType,omitempty"`

	// Identity: Identity of the Extension resource
	Identity *Identity `json:"identity,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. This resource is an
	// extension resource, which means that any other Azure resource can be its owner.
	Owner *genruntime.ArbitraryOwnerReference `json:"owner,omitempty"`

	// Plan: The plan information.
	Plan *Plan `json:"plan,omitempty"`

	// ReleaseTrain: ReleaseTrain this extension participates in for auto-upgrade (e.g. Stable, Preview, etc.) - only if
	// autoUpgradeMinorVersion is 'true'.
	ReleaseTrain *string `json:"releaseTrain,omitempty"`

	// Scope: Scope at which the extension is installed.
	Scope *Scope `json:"scope,omitempty"`

	// SystemData: Top level metadata
	// https://github.com/Azure/azure-resource-manager-rpc/blob/master/v1.0/common-api-contracts.md#system-metadata-for-all-azure-resources
	SystemData *SystemData `json:"systemData,omitempty"`

	// Version: User-specified version of the extension for this extension to 'pin'. To use 'version', autoUpgradeMinorVersion
	// must be 'false'.
	Version *string `json:"version,omitempty"`
}

var _ genruntime.ARMTransformer = &Extension_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (extension *Extension_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if extension == nil {
		return nil, nil
	}
	result := &Extension_Spec_ARM{}

	// Set property "Identity":
	if extension.Identity != nil {
		identity_ARM, err := (*extension.Identity).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		identity := *identity_ARM.(*Identity_ARM)
		result.Identity = &identity
	}

	// Set property "Name":
	result.Name = resolved.Name

	// Set property "Plan":
	if extension.Plan != nil {
		plan_ARM, err := (*extension.Plan).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		plan := *plan_ARM.(*Plan_ARM)
		result.Plan = &plan
	}

	// Set property "Properties":
	if extension.AksAssignedIdentity != nil ||
		extension.AutoUpgradeMinorVersion != nil ||
		extension.ConfigurationSettings != nil ||
		extension.ExtensionType != nil ||
		extension.ReleaseTrain != nil ||
		extension.Scope != nil ||
		extension.Version != nil {
		result.Properties = &Extension_Properties_Spec_ARM{}
	}
	if extension.AksAssignedIdentity != nil {
		aksAssignedIdentity_ARM, err := (*extension.AksAssignedIdentity).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		aksAssignedIdentity := *aksAssignedIdentity_ARM.(*Extension_Properties_AksAssignedIdentity_Spec_ARM)
		result.Properties.AksAssignedIdentity = &aksAssignedIdentity
	}
	if extension.AutoUpgradeMinorVersion != nil {
		autoUpgradeMinorVersion := *extension.AutoUpgradeMinorVersion
		result.Properties.AutoUpgradeMinorVersion = &autoUpgradeMinorVersion
	}
	if extension.ConfigurationSettings != nil {
		result.Properties.ConfigurationSettings = make(map[string]string, len(extension.ConfigurationSettings))
		for key, value := range extension.ConfigurationSettings {
			result.Properties.ConfigurationSettings[key] = value
		}
	}
	if extension.ExtensionType != nil {
		extensionType := *extension.ExtensionType
		result.Properties.ExtensionType = &extensionType
	}
	if extension.ReleaseTrain != nil {
		releaseTrain := *extension.ReleaseTrain
		result.Properties.ReleaseTrain = &releaseTrain
	}
	if extension.Scope != nil {
		scope_ARM, err := (*extension.Scope).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		scope := *scope_ARM.(*Scope_ARM)
		result.Properties.Scope = &scope
	}
	if extension.Version != nil {
		version := *extension.Version
		result.Properties.Version = &version
	}

	// Set property "SystemData":
	if extension.SystemData != nil {
		systemData_ARM, err := (*extension.SystemData).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		systemData := *systemData_ARM.(*SystemData_ARM)
		result.SystemData = &systemData
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (extension *Extension_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Extension_Spec_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (extension *Extension_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Extension_Spec_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Extension_Spec_ARM, got %T", armInput)
	}

	// Set property "AksAssignedIdentity":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AksAssignedIdentity != nil {
			var aksAssignedIdentity1 Extension_Properties_AksAssignedIdentity_Spec
			err := aksAssignedIdentity1.PopulateFromARM(owner, *typedInput.Properties.AksAssignedIdentity)
			if err != nil {
				return err
			}
			aksAssignedIdentity := aksAssignedIdentity1
			extension.AksAssignedIdentity = &aksAssignedIdentity
		}
	}

	// Set property "AutoUpgradeMinorVersion":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AutoUpgradeMinorVersion != nil {
			autoUpgradeMinorVersion := *typedInput.Properties.AutoUpgradeMinorVersion
			extension.AutoUpgradeMinorVersion = &autoUpgradeMinorVersion
		}
	}

	// Set property "AzureName":
	extension.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property "ConfigurationSettings":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ConfigurationSettings != nil {
			extension.ConfigurationSettings = make(map[string]string, len(typedInput.Properties.ConfigurationSettings))
			for key, value := range typedInput.Properties.ConfigurationSettings {
				extension.ConfigurationSettings[key] = value
			}
		}
	}

	// Set property "ExtensionType":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ExtensionType != nil {
			extensionType := *typedInput.Properties.ExtensionType
			extension.ExtensionType = &extensionType
		}
	}

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 Identity
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		extension.Identity = &identity
	}

	// Set property "Owner":
	extension.Owner = &owner

	// Set property "Plan":
	if typedInput.Plan != nil {
		var plan1 Plan
		err := plan1.PopulateFromARM(owner, *typedInput.Plan)
		if err != nil {
			return err
		}
		plan := plan1
		extension.Plan = &plan
	}

	// Set property "ReleaseTrain":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ReleaseTrain != nil {
			releaseTrain := *typedInput.Properties.ReleaseTrain
			extension.ReleaseTrain = &releaseTrain
		}
	}

	// Set property "Scope":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Scope != nil {
			var scope1 Scope
			err := scope1.PopulateFromARM(owner, *typedInput.Properties.Scope)
			if err != nil {
				return err
			}
			scope := scope1
			extension.Scope = &scope
		}
	}

	// Set property "SystemData":
	if typedInput.SystemData != nil {
		var systemData1 SystemData
		err := systemData1.PopulateFromARM(owner, *typedInput.SystemData)
		if err != nil {
			return err
		}
		systemData := systemData1
		extension.SystemData = &systemData
	}

	// Set property "Version":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Version != nil {
			version := *typedInput.Properties.Version
			extension.Version = &version
		}
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &Extension_Spec{}

// ConvertSpecFrom populates our Extension_Spec from the provided source
func (extension *Extension_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*v20230501s.Extension_Spec)
	if ok {
		// Populate our instance from source
		return extension.AssignProperties_From_Extension_Spec(src)
	}

	// Convert to an intermediate form
	src = &v20230501s.Extension_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = extension.AssignProperties_From_Extension_Spec(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our Extension_Spec
func (extension *Extension_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*v20230501s.Extension_Spec)
	if ok {
		// Populate destination from our instance
		return extension.AssignProperties_To_Extension_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &v20230501s.Extension_Spec{}
	err := extension.AssignProperties_To_Extension_Spec(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignProperties_From_Extension_Spec populates our Extension_Spec from the provided source Extension_Spec
func (extension *Extension_Spec) AssignProperties_From_Extension_Spec(source *v20230501s.Extension_Spec) error {

	// AksAssignedIdentity
	if source.AksAssignedIdentity != nil {
		var aksAssignedIdentity Extension_Properties_AksAssignedIdentity_Spec
		err := aksAssignedIdentity.AssignProperties_From_Extension_Properties_AksAssignedIdentity_Spec(source.AksAssignedIdentity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Extension_Properties_AksAssignedIdentity_Spec() to populate field AksAssignedIdentity")
		}
		extension.AksAssignedIdentity = &aksAssignedIdentity
	} else {
		extension.AksAssignedIdentity = nil
	}

	// AutoUpgradeMinorVersion
	if source.AutoUpgradeMinorVersion != nil {
		autoUpgradeMinorVersion := *source.AutoUpgradeMinorVersion
		extension.AutoUpgradeMinorVersion = &autoUpgradeMinorVersion
	} else {
		extension.AutoUpgradeMinorVersion = nil
	}

	// AzureName
	extension.AzureName = source.AzureName

	// ConfigurationSettings
	extension.ConfigurationSettings = genruntime.CloneMapOfStringToString(source.ConfigurationSettings)

	// ExtensionType
	extension.ExtensionType = genruntime.ClonePointerToString(source.ExtensionType)

	// Identity
	if source.Identity != nil {
		var identity Identity
		err := identity.AssignProperties_From_Identity(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Identity() to populate field Identity")
		}
		extension.Identity = &identity
	} else {
		extension.Identity = nil
	}

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		extension.Owner = &owner
	} else {
		extension.Owner = nil
	}

	// Plan
	if source.Plan != nil {
		var plan Plan
		err := plan.AssignProperties_From_Plan(source.Plan)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Plan() to populate field Plan")
		}
		extension.Plan = &plan
	} else {
		extension.Plan = nil
	}

	// ReleaseTrain
	extension.ReleaseTrain = genruntime.ClonePointerToString(source.ReleaseTrain)

	// Scope
	if source.Scope != nil {
		var scope Scope
		err := scope.AssignProperties_From_Scope(source.Scope)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Scope() to populate field Scope")
		}
		extension.Scope = &scope
	} else {
		extension.Scope = nil
	}

	// SystemData
	if source.SystemData != nil {
		var systemDatum SystemData
		err := systemDatum.AssignProperties_From_SystemData(source.SystemData)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SystemData() to populate field SystemData")
		}
		extension.SystemData = &systemDatum
	} else {
		extension.SystemData = nil
	}

	// Version
	extension.Version = genruntime.ClonePointerToString(source.Version)

	// No error
	return nil
}

// AssignProperties_To_Extension_Spec populates the provided destination Extension_Spec from our Extension_Spec
func (extension *Extension_Spec) AssignProperties_To_Extension_Spec(destination *v20230501s.Extension_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AksAssignedIdentity
	if extension.AksAssignedIdentity != nil {
		var aksAssignedIdentity v20230501s.Extension_Properties_AksAssignedIdentity_Spec
		err := extension.AksAssignedIdentity.AssignProperties_To_Extension_Properties_AksAssignedIdentity_Spec(&aksAssignedIdentity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Extension_Properties_AksAssignedIdentity_Spec() to populate field AksAssignedIdentity")
		}
		destination.AksAssignedIdentity = &aksAssignedIdentity
	} else {
		destination.AksAssignedIdentity = nil
	}

	// AutoUpgradeMinorVersion
	if extension.AutoUpgradeMinorVersion != nil {
		autoUpgradeMinorVersion := *extension.AutoUpgradeMinorVersion
		destination.AutoUpgradeMinorVersion = &autoUpgradeMinorVersion
	} else {
		destination.AutoUpgradeMinorVersion = nil
	}

	// AzureName
	destination.AzureName = extension.AzureName

	// ConfigurationSettings
	destination.ConfigurationSettings = genruntime.CloneMapOfStringToString(extension.ConfigurationSettings)

	// ExtensionType
	destination.ExtensionType = genruntime.ClonePointerToString(extension.ExtensionType)

	// Identity
	if extension.Identity != nil {
		var identity v20230501s.Identity
		err := extension.Identity.AssignProperties_To_Identity(&identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Identity() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// OriginalVersion
	destination.OriginalVersion = extension.OriginalVersion()

	// Owner
	if extension.Owner != nil {
		owner := extension.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// Plan
	if extension.Plan != nil {
		var plan v20230501s.Plan
		err := extension.Plan.AssignProperties_To_Plan(&plan)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Plan() to populate field Plan")
		}
		destination.Plan = &plan
	} else {
		destination.Plan = nil
	}

	// ReleaseTrain
	destination.ReleaseTrain = genruntime.ClonePointerToString(extension.ReleaseTrain)

	// Scope
	if extension.Scope != nil {
		var scope v20230501s.Scope
		err := extension.Scope.AssignProperties_To_Scope(&scope)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Scope() to populate field Scope")
		}
		destination.Scope = &scope
	} else {
		destination.Scope = nil
	}

	// SystemData
	if extension.SystemData != nil {
		var systemDatum v20230501s.SystemData
		err := extension.SystemData.AssignProperties_To_SystemData(&systemDatum)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SystemData() to populate field SystemData")
		}
		destination.SystemData = &systemDatum
	} else {
		destination.SystemData = nil
	}

	// Version
	destination.Version = genruntime.ClonePointerToString(extension.Version)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_Extension_STATUS populates our Extension_Spec from the provided source Extension_STATUS
func (extension *Extension_Spec) Initialize_From_Extension_STATUS(source *Extension_STATUS) error {

	// AksAssignedIdentity
	if source.AksAssignedIdentity != nil {
		var aksAssignedIdentity Extension_Properties_AksAssignedIdentity_Spec
		err := aksAssignedIdentity.Initialize_From_Extension_Properties_AksAssignedIdentity_STATUS(source.AksAssignedIdentity)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_Extension_Properties_AksAssignedIdentity_STATUS() to populate field AksAssignedIdentity")
		}
		extension.AksAssignedIdentity = &aksAssignedIdentity
	} else {
		extension.AksAssignedIdentity = nil
	}

	// AutoUpgradeMinorVersion
	if source.AutoUpgradeMinorVersion != nil {
		autoUpgradeMinorVersion := *source.AutoUpgradeMinorVersion
		extension.AutoUpgradeMinorVersion = &autoUpgradeMinorVersion
	} else {
		extension.AutoUpgradeMinorVersion = nil
	}

	// ConfigurationSettings
	extension.ConfigurationSettings = genruntime.CloneMapOfStringToString(source.ConfigurationSettings)

	// ExtensionType
	extension.ExtensionType = genruntime.ClonePointerToString(source.ExtensionType)

	// Identity
	if source.Identity != nil {
		var identity Identity
		err := identity.Initialize_From_Identity_STATUS(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_Identity_STATUS() to populate field Identity")
		}
		extension.Identity = &identity
	} else {
		extension.Identity = nil
	}

	// Plan
	if source.Plan != nil {
		var plan Plan
		err := plan.Initialize_From_Plan_STATUS(source.Plan)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_Plan_STATUS() to populate field Plan")
		}
		extension.Plan = &plan
	} else {
		extension.Plan = nil
	}

	// ReleaseTrain
	extension.ReleaseTrain = genruntime.ClonePointerToString(source.ReleaseTrain)

	// Scope
	if source.Scope != nil {
		var scope Scope
		err := scope.Initialize_From_Scope_STATUS(source.Scope)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_Scope_STATUS() to populate field Scope")
		}
		extension.Scope = &scope
	} else {
		extension.Scope = nil
	}

	// SystemData
	if source.SystemData != nil {
		var systemDatum SystemData
		err := systemDatum.Initialize_From_SystemData_STATUS(source.SystemData)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_SystemData_STATUS() to populate field SystemData")
		}
		extension.SystemData = &systemDatum
	} else {
		extension.SystemData = nil
	}

	// Version
	extension.Version = genruntime.ClonePointerToString(source.Version)

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (extension *Extension_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (extension *Extension_Spec) SetAzureName(azureName string) { extension.AzureName = azureName }

// The Extension object.
type Extension_STATUS struct {
	// AksAssignedIdentity: Identity of the Extension resource in an AKS cluster
	AksAssignedIdentity *Extension_Properties_AksAssignedIdentity_STATUS `json:"aksAssignedIdentity,omitempty"`

	// AutoUpgradeMinorVersion: Flag to note if this extension participates in auto upgrade of minor version, or not.
	AutoUpgradeMinorVersion *bool `json:"autoUpgradeMinorVersion,omitempty"`

	// Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	// ConfigurationSettings: Configuration settings, as name-value pairs for configuring this extension.
	ConfigurationSettings map[string]string `json:"configurationSettings,omitempty"`

	// CurrentVersion: Currently installed version of the extension.
	CurrentVersion *string `json:"currentVersion,omitempty"`

	// CustomLocationSettings: Custom Location settings properties.
	CustomLocationSettings map[string]string `json:"customLocationSettings,omitempty"`

	// ErrorInfo: Error information from the Agent - e.g. errors during installation.
	ErrorInfo *ErrorDetail_STATUS `json:"errorInfo,omitempty"`

	// ExtensionType: Type of the Extension, of which this resource is an instance of.  It must be one of the Extension Types
	// registered with Microsoft.KubernetesConfiguration by the Extension publisher.
	ExtensionType *string `json:"extensionType,omitempty"`

	// Id: Fully qualified resource ID for the resource. Ex -
	// /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	Id *string `json:"id,omitempty"`

	// Identity: Identity of the Extension resource
	Identity *Identity_STATUS `json:"identity,omitempty"`

	// IsSystemExtension: Flag to note if this extension is a system extension
	IsSystemExtension *bool `json:"isSystemExtension,omitempty"`

	// Name: The name of the resource
	Name *string `json:"name,omitempty"`

	// PackageUri: Uri of the Helm package
	PackageUri *string `json:"packageUri,omitempty"`

	// Plan: The plan information.
	Plan *Plan_STATUS `json:"plan,omitempty"`

	// ProvisioningState: Status of installation of this extension.
	ProvisioningState *ProvisioningStateDefinition_STATUS `json:"provisioningState,omitempty"`

	// ReleaseTrain: ReleaseTrain this extension participates in for auto-upgrade (e.g. Stable, Preview, etc.) - only if
	// autoUpgradeMinorVersion is 'true'.
	ReleaseTrain *string `json:"releaseTrain,omitempty"`

	// Scope: Scope at which the extension is installed.
	Scope *Scope_STATUS `json:"scope,omitempty"`

	// Statuses: Status from this extension.
	Statuses []ExtensionStatus_STATUS `json:"statuses,omitempty"`

	// SystemData: Top level metadata
	// https://github.com/Azure/azure-resource-manager-rpc/blob/master/v1.0/common-api-contracts.md#system-metadata-for-all-azure-resources
	SystemData *SystemData_STATUS `json:"systemData,omitempty"`

	// Type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`

	// Version: User-specified version of the extension for this extension to 'pin'. To use 'version', autoUpgradeMinorVersion
	// must be 'false'.
	Version *string `json:"version,omitempty"`
}

var _ genruntime.ConvertibleStatus = &Extension_STATUS{}

// ConvertStatusFrom populates our Extension_STATUS from the provided source
func (extension *Extension_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*v20230501s.Extension_STATUS)
	if ok {
		// Populate our instance from source
		return extension.AssignProperties_From_Extension_STATUS(src)
	}

	// Convert to an intermediate form
	src = &v20230501s.Extension_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = extension.AssignProperties_From_Extension_STATUS(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our Extension_STATUS
func (extension *Extension_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*v20230501s.Extension_STATUS)
	if ok {
		// Populate destination from our instance
		return extension.AssignProperties_To_Extension_STATUS(dst)
	}

	// Convert to an intermediate form
	dst = &v20230501s.Extension_STATUS{}
	err := extension.AssignProperties_To_Extension_STATUS(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &Extension_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (extension *Extension_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Extension_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (extension *Extension_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Extension_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Extension_STATUS_ARM, got %T", armInput)
	}

	// Set property "AksAssignedIdentity":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AksAssignedIdentity != nil {
			var aksAssignedIdentity1 Extension_Properties_AksAssignedIdentity_STATUS
			err := aksAssignedIdentity1.PopulateFromARM(owner, *typedInput.Properties.AksAssignedIdentity)
			if err != nil {
				return err
			}
			aksAssignedIdentity := aksAssignedIdentity1
			extension.AksAssignedIdentity = &aksAssignedIdentity
		}
	}

	// Set property "AutoUpgradeMinorVersion":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AutoUpgradeMinorVersion != nil {
			autoUpgradeMinorVersion := *typedInput.Properties.AutoUpgradeMinorVersion
			extension.AutoUpgradeMinorVersion = &autoUpgradeMinorVersion
		}
	}

	// no assignment for property "Conditions"

	// Set property "ConfigurationSettings":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ConfigurationSettings != nil {
			extension.ConfigurationSettings = make(map[string]string, len(typedInput.Properties.ConfigurationSettings))
			for key, value := range typedInput.Properties.ConfigurationSettings {
				extension.ConfigurationSettings[key] = value
			}
		}
	}

	// Set property "CurrentVersion":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.CurrentVersion != nil {
			currentVersion := *typedInput.Properties.CurrentVersion
			extension.CurrentVersion = &currentVersion
		}
	}

	// Set property "CustomLocationSettings":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.CustomLocationSettings != nil {
			extension.CustomLocationSettings = make(map[string]string, len(typedInput.Properties.CustomLocationSettings))
			for key, value := range typedInput.Properties.CustomLocationSettings {
				extension.CustomLocationSettings[key] = value
			}
		}
	}

	// Set property "ErrorInfo":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ErrorInfo != nil {
			var errorInfo1 ErrorDetail_STATUS
			err := errorInfo1.PopulateFromARM(owner, *typedInput.Properties.ErrorInfo)
			if err != nil {
				return err
			}
			errorInfo := errorInfo1
			extension.ErrorInfo = &errorInfo
		}
	}

	// Set property "ExtensionType":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ExtensionType != nil {
			extensionType := *typedInput.Properties.ExtensionType
			extension.ExtensionType = &extensionType
		}
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		extension.Id = &id
	}

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 Identity_STATUS
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		extension.Identity = &identity
	}

	// Set property "IsSystemExtension":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IsSystemExtension != nil {
			isSystemExtension := *typedInput.Properties.IsSystemExtension
			extension.IsSystemExtension = &isSystemExtension
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		extension.Name = &name
	}

	// Set property "PackageUri":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PackageUri != nil {
			packageUri := *typedInput.Properties.PackageUri
			extension.PackageUri = &packageUri
		}
	}

	// Set property "Plan":
	if typedInput.Plan != nil {
		var plan1 Plan_STATUS
		err := plan1.PopulateFromARM(owner, *typedInput.Plan)
		if err != nil {
			return err
		}
		plan := plan1
		extension.Plan = &plan
	}

	// Set property "ProvisioningState":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			provisioningState := *typedInput.Properties.ProvisioningState
			extension.ProvisioningState = &provisioningState
		}
	}

	// Set property "ReleaseTrain":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ReleaseTrain != nil {
			releaseTrain := *typedInput.Properties.ReleaseTrain
			extension.ReleaseTrain = &releaseTrain
		}
	}

	// Set property "Scope":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Scope != nil {
			var scope1 Scope_STATUS
			err := scope1.PopulateFromARM(owner, *typedInput.Properties.Scope)
			if err != nil {
				return err
			}
			scope := scope1
			extension.Scope = &scope
		}
	}

	// Set property "Statuses":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Statuses {
			var item1 ExtensionStatus_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			extension.Statuses = append(extension.Statuses, item1)
		}
	}

	// Set property "SystemData":
	if typedInput.SystemData != nil {
		var systemData1 SystemData_STATUS
		err := systemData1.PopulateFromARM(owner, *typedInput.SystemData)
		if err != nil {
			return err
		}
		systemData := systemData1
		extension.SystemData = &systemData
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		extension.Type = &typeVar
	}

	// Set property "Version":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Version != nil {
			version := *typedInput.Properties.Version
			extension.Version = &version
		}
	}

	// No error
	return nil
}

// AssignProperties_From_Extension_STATUS populates our Extension_STATUS from the provided source Extension_STATUS
func (extension *Extension_STATUS) AssignProperties_From_Extension_STATUS(source *v20230501s.Extension_STATUS) error {

	// AksAssignedIdentity
	if source.AksAssignedIdentity != nil {
		var aksAssignedIdentity Extension_Properties_AksAssignedIdentity_STATUS
		err := aksAssignedIdentity.AssignProperties_From_Extension_Properties_AksAssignedIdentity_STATUS(source.AksAssignedIdentity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Extension_Properties_AksAssignedIdentity_STATUS() to populate field AksAssignedIdentity")
		}
		extension.AksAssignedIdentity = &aksAssignedIdentity
	} else {
		extension.AksAssignedIdentity = nil
	}

	// AutoUpgradeMinorVersion
	if source.AutoUpgradeMinorVersion != nil {
		autoUpgradeMinorVersion := *source.AutoUpgradeMinorVersion
		extension.AutoUpgradeMinorVersion = &autoUpgradeMinorVersion
	} else {
		extension.AutoUpgradeMinorVersion = nil
	}

	// Conditions
	extension.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// ConfigurationSettings
	extension.ConfigurationSettings = genruntime.CloneMapOfStringToString(source.ConfigurationSettings)

	// CurrentVersion
	extension.CurrentVersion = genruntime.ClonePointerToString(source.CurrentVersion)

	// CustomLocationSettings
	extension.CustomLocationSettings = genruntime.CloneMapOfStringToString(source.CustomLocationSettings)

	// ErrorInfo
	if source.ErrorInfo != nil {
		var errorInfo ErrorDetail_STATUS
		err := errorInfo.AssignProperties_From_ErrorDetail_STATUS(source.ErrorInfo)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ErrorDetail_STATUS() to populate field ErrorInfo")
		}
		extension.ErrorInfo = &errorInfo
	} else {
		extension.ErrorInfo = nil
	}

	// ExtensionType
	extension.ExtensionType = genruntime.ClonePointerToString(source.ExtensionType)

	// Id
	extension.Id = genruntime.ClonePointerToString(source.Id)

	// Identity
	if source.Identity != nil {
		var identity Identity_STATUS
		err := identity.AssignProperties_From_Identity_STATUS(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Identity_STATUS() to populate field Identity")
		}
		extension.Identity = &identity
	} else {
		extension.Identity = nil
	}

	// IsSystemExtension
	if source.IsSystemExtension != nil {
		isSystemExtension := *source.IsSystemExtension
		extension.IsSystemExtension = &isSystemExtension
	} else {
		extension.IsSystemExtension = nil
	}

	// Name
	extension.Name = genruntime.ClonePointerToString(source.Name)

	// PackageUri
	extension.PackageUri = genruntime.ClonePointerToString(source.PackageUri)

	// Plan
	if source.Plan != nil {
		var plan Plan_STATUS
		err := plan.AssignProperties_From_Plan_STATUS(source.Plan)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Plan_STATUS() to populate field Plan")
		}
		extension.Plan = &plan
	} else {
		extension.Plan = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := ProvisioningStateDefinition_STATUS(*source.ProvisioningState)
		extension.ProvisioningState = &provisioningState
	} else {
		extension.ProvisioningState = nil
	}

	// ReleaseTrain
	extension.ReleaseTrain = genruntime.ClonePointerToString(source.ReleaseTrain)

	// Scope
	if source.Scope != nil {
		var scope Scope_STATUS
		err := scope.AssignProperties_From_Scope_STATUS(source.Scope)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Scope_STATUS() to populate field Scope")
		}
		extension.Scope = &scope
	} else {
		extension.Scope = nil
	}

	// Statuses
	if source.Statuses != nil {
		statusList := make([]ExtensionStatus_STATUS, len(source.Statuses))
		for statusIndex, statusItem := range source.Statuses {
			// Shadow the loop variable to avoid aliasing
			statusItem := statusItem
			var status ExtensionStatus_STATUS
			err := status.AssignProperties_From_ExtensionStatus_STATUS(&statusItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ExtensionStatus_STATUS() to populate field Statuses")
			}
			statusList[statusIndex] = status
		}
		extension.Statuses = statusList
	} else {
		extension.Statuses = nil
	}

	// SystemData
	if source.SystemData != nil {
		var systemDatum SystemData_STATUS
		err := systemDatum.AssignProperties_From_SystemData_STATUS(source.SystemData)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SystemData_STATUS() to populate field SystemData")
		}
		extension.SystemData = &systemDatum
	} else {
		extension.SystemData = nil
	}

	// Type
	extension.Type = genruntime.ClonePointerToString(source.Type)

	// Version
	extension.Version = genruntime.ClonePointerToString(source.Version)

	// No error
	return nil
}

// AssignProperties_To_Extension_STATUS populates the provided destination Extension_STATUS from our Extension_STATUS
func (extension *Extension_STATUS) AssignProperties_To_Extension_STATUS(destination *v20230501s.Extension_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AksAssignedIdentity
	if extension.AksAssignedIdentity != nil {
		var aksAssignedIdentity v20230501s.Extension_Properties_AksAssignedIdentity_STATUS
		err := extension.AksAssignedIdentity.AssignProperties_To_Extension_Properties_AksAssignedIdentity_STATUS(&aksAssignedIdentity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Extension_Properties_AksAssignedIdentity_STATUS() to populate field AksAssignedIdentity")
		}
		destination.AksAssignedIdentity = &aksAssignedIdentity
	} else {
		destination.AksAssignedIdentity = nil
	}

	// AutoUpgradeMinorVersion
	if extension.AutoUpgradeMinorVersion != nil {
		autoUpgradeMinorVersion := *extension.AutoUpgradeMinorVersion
		destination.AutoUpgradeMinorVersion = &autoUpgradeMinorVersion
	} else {
		destination.AutoUpgradeMinorVersion = nil
	}

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(extension.Conditions)

	// ConfigurationSettings
	destination.ConfigurationSettings = genruntime.CloneMapOfStringToString(extension.ConfigurationSettings)

	// CurrentVersion
	destination.CurrentVersion = genruntime.ClonePointerToString(extension.CurrentVersion)

	// CustomLocationSettings
	destination.CustomLocationSettings = genruntime.CloneMapOfStringToString(extension.CustomLocationSettings)

	// ErrorInfo
	if extension.ErrorInfo != nil {
		var errorInfo v20230501s.ErrorDetail_STATUS
		err := extension.ErrorInfo.AssignProperties_To_ErrorDetail_STATUS(&errorInfo)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ErrorDetail_STATUS() to populate field ErrorInfo")
		}
		destination.ErrorInfo = &errorInfo
	} else {
		destination.ErrorInfo = nil
	}

	// ExtensionType
	destination.ExtensionType = genruntime.ClonePointerToString(extension.ExtensionType)

	// Id
	destination.Id = genruntime.ClonePointerToString(extension.Id)

	// Identity
	if extension.Identity != nil {
		var identity v20230501s.Identity_STATUS
		err := extension.Identity.AssignProperties_To_Identity_STATUS(&identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Identity_STATUS() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// IsSystemExtension
	if extension.IsSystemExtension != nil {
		isSystemExtension := *extension.IsSystemExtension
		destination.IsSystemExtension = &isSystemExtension
	} else {
		destination.IsSystemExtension = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(extension.Name)

	// PackageUri
	destination.PackageUri = genruntime.ClonePointerToString(extension.PackageUri)

	// Plan
	if extension.Plan != nil {
		var plan v20230501s.Plan_STATUS
		err := extension.Plan.AssignProperties_To_Plan_STATUS(&plan)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Plan_STATUS() to populate field Plan")
		}
		destination.Plan = &plan
	} else {
		destination.Plan = nil
	}

	// ProvisioningState
	if extension.ProvisioningState != nil {
		provisioningState := string(*extension.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// ReleaseTrain
	destination.ReleaseTrain = genruntime.ClonePointerToString(extension.ReleaseTrain)

	// Scope
	if extension.Scope != nil {
		var scope v20230501s.Scope_STATUS
		err := extension.Scope.AssignProperties_To_Scope_STATUS(&scope)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Scope_STATUS() to populate field Scope")
		}
		destination.Scope = &scope
	} else {
		destination.Scope = nil
	}

	// Statuses
	if extension.Statuses != nil {
		statusList := make([]v20230501s.ExtensionStatus_STATUS, len(extension.Statuses))
		for statusIndex, statusItem := range extension.Statuses {
			// Shadow the loop variable to avoid aliasing
			statusItem := statusItem
			var status v20230501s.ExtensionStatus_STATUS
			err := statusItem.AssignProperties_To_ExtensionStatus_STATUS(&status)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ExtensionStatus_STATUS() to populate field Statuses")
			}
			statusList[statusIndex] = status
		}
		destination.Statuses = statusList
	} else {
		destination.Statuses = nil
	}

	// SystemData
	if extension.SystemData != nil {
		var systemDatum v20230501s.SystemData_STATUS
		err := extension.SystemData.AssignProperties_To_SystemData_STATUS(&systemDatum)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SystemData_STATUS() to populate field SystemData")
		}
		destination.SystemData = &systemDatum
	} else {
		destination.SystemData = nil
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(extension.Type)

	// Version
	destination.Version = genruntime.ClonePointerToString(extension.Version)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The error detail.
type ErrorDetail_STATUS struct {
	// AdditionalInfo: The error additional info.
	AdditionalInfo []ErrorAdditionalInfo_STATUS `json:"additionalInfo,omitempty"`

	// Code: The error code.
	Code *string `json:"code,omitempty"`

	// Details: The error details.
	Details []ErrorDetail_STATUS_Unrolled `json:"details,omitempty"`

	// Message: The error message.
	Message *string `json:"message,omitempty"`

	// Target: The error target.
	Target *string `json:"target,omitempty"`
}

var _ genruntime.FromARMConverter = &ErrorDetail_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (detail *ErrorDetail_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ErrorDetail_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (detail *ErrorDetail_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ErrorDetail_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ErrorDetail_STATUS_ARM, got %T", armInput)
	}

	// Set property "AdditionalInfo":
	for _, item := range typedInput.AdditionalInfo {
		var item1 ErrorAdditionalInfo_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		detail.AdditionalInfo = append(detail.AdditionalInfo, item1)
	}

	// Set property "Code":
	if typedInput.Code != nil {
		code := *typedInput.Code
		detail.Code = &code
	}

	// Set property "Details":
	for _, item := range typedInput.Details {
		var item1 ErrorDetail_STATUS_Unrolled
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		detail.Details = append(detail.Details, item1)
	}

	// Set property "Message":
	if typedInput.Message != nil {
		message := *typedInput.Message
		detail.Message = &message
	}

	// Set property "Target":
	if typedInput.Target != nil {
		target := *typedInput.Target
		detail.Target = &target
	}

	// No error
	return nil
}

// AssignProperties_From_ErrorDetail_STATUS populates our ErrorDetail_STATUS from the provided source ErrorDetail_STATUS
func (detail *ErrorDetail_STATUS) AssignProperties_From_ErrorDetail_STATUS(source *v20230501s.ErrorDetail_STATUS) error {

	// AdditionalInfo
	if source.AdditionalInfo != nil {
		additionalInfoList := make([]ErrorAdditionalInfo_STATUS, len(source.AdditionalInfo))
		for additionalInfoIndex, additionalInfoItem := range source.AdditionalInfo {
			// Shadow the loop variable to avoid aliasing
			additionalInfoItem := additionalInfoItem
			var additionalInfo ErrorAdditionalInfo_STATUS
			err := additionalInfo.AssignProperties_From_ErrorAdditionalInfo_STATUS(&additionalInfoItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ErrorAdditionalInfo_STATUS() to populate field AdditionalInfo")
			}
			additionalInfoList[additionalInfoIndex] = additionalInfo
		}
		detail.AdditionalInfo = additionalInfoList
	} else {
		detail.AdditionalInfo = nil
	}

	// Code
	detail.Code = genruntime.ClonePointerToString(source.Code)

	// Details
	if source.Details != nil {
		detailList := make([]ErrorDetail_STATUS_Unrolled, len(source.Details))
		for detailIndex, detailItem := range source.Details {
			// Shadow the loop variable to avoid aliasing
			detailItem := detailItem
			var detailLocal ErrorDetail_STATUS_Unrolled
			err := detailLocal.AssignProperties_From_ErrorDetail_STATUS_Unrolled(&detailItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ErrorDetail_STATUS_Unrolled() to populate field Details")
			}
			detailList[detailIndex] = detailLocal
		}
		detail.Details = detailList
	} else {
		detail.Details = nil
	}

	// Message
	detail.Message = genruntime.ClonePointerToString(source.Message)

	// Target
	detail.Target = genruntime.ClonePointerToString(source.Target)

	// No error
	return nil
}

// AssignProperties_To_ErrorDetail_STATUS populates the provided destination ErrorDetail_STATUS from our ErrorDetail_STATUS
func (detail *ErrorDetail_STATUS) AssignProperties_To_ErrorDetail_STATUS(destination *v20230501s.ErrorDetail_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdditionalInfo
	if detail.AdditionalInfo != nil {
		additionalInfoList := make([]v20230501s.ErrorAdditionalInfo_STATUS, len(detail.AdditionalInfo))
		for additionalInfoIndex, additionalInfoItem := range detail.AdditionalInfo {
			// Shadow the loop variable to avoid aliasing
			additionalInfoItem := additionalInfoItem
			var additionalInfo v20230501s.ErrorAdditionalInfo_STATUS
			err := additionalInfoItem.AssignProperties_To_ErrorAdditionalInfo_STATUS(&additionalInfo)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ErrorAdditionalInfo_STATUS() to populate field AdditionalInfo")
			}
			additionalInfoList[additionalInfoIndex] = additionalInfo
		}
		destination.AdditionalInfo = additionalInfoList
	} else {
		destination.AdditionalInfo = nil
	}

	// Code
	destination.Code = genruntime.ClonePointerToString(detail.Code)

	// Details
	if detail.Details != nil {
		detailList := make([]v20230501s.ErrorDetail_STATUS_Unrolled, len(detail.Details))
		for detailIndex, detailItem := range detail.Details {
			// Shadow the loop variable to avoid aliasing
			detailItem := detailItem
			var detailLocal v20230501s.ErrorDetail_STATUS_Unrolled
			err := detailItem.AssignProperties_To_ErrorDetail_STATUS_Unrolled(&detailLocal)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ErrorDetail_STATUS_Unrolled() to populate field Details")
			}
			detailList[detailIndex] = detailLocal
		}
		destination.Details = detailList
	} else {
		destination.Details = nil
	}

	// Message
	destination.Message = genruntime.ClonePointerToString(detail.Message)

	// Target
	destination.Target = genruntime.ClonePointerToString(detail.Target)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type Extension_Properties_AksAssignedIdentity_Spec struct {
	// Type: The identity type.
	Type *Extension_Properties_AksAssignedIdentity_Type_Spec `json:"type,omitempty"`
}

var _ genruntime.ARMTransformer = &Extension_Properties_AksAssignedIdentity_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (identity *Extension_Properties_AksAssignedIdentity_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if identity == nil {
		return nil, nil
	}
	result := &Extension_Properties_AksAssignedIdentity_Spec_ARM{}

	// Set property "Type":
	if identity.Type != nil {
		typeVar := *identity.Type
		result.Type = &typeVar
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *Extension_Properties_AksAssignedIdentity_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Extension_Properties_AksAssignedIdentity_Spec_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *Extension_Properties_AksAssignedIdentity_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Extension_Properties_AksAssignedIdentity_Spec_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Extension_Properties_AksAssignedIdentity_Spec_ARM, got %T", armInput)
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		identity.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_Extension_Properties_AksAssignedIdentity_Spec populates our Extension_Properties_AksAssignedIdentity_Spec from the provided source Extension_Properties_AksAssignedIdentity_Spec
func (identity *Extension_Properties_AksAssignedIdentity_Spec) AssignProperties_From_Extension_Properties_AksAssignedIdentity_Spec(source *v20230501s.Extension_Properties_AksAssignedIdentity_Spec) error {

	// Type
	if source.Type != nil {
		typeVar := Extension_Properties_AksAssignedIdentity_Type_Spec(*source.Type)
		identity.Type = &typeVar
	} else {
		identity.Type = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Extension_Properties_AksAssignedIdentity_Spec populates the provided destination Extension_Properties_AksAssignedIdentity_Spec from our Extension_Properties_AksAssignedIdentity_Spec
func (identity *Extension_Properties_AksAssignedIdentity_Spec) AssignProperties_To_Extension_Properties_AksAssignedIdentity_Spec(destination *v20230501s.Extension_Properties_AksAssignedIdentity_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Type
	if identity.Type != nil {
		typeVar := string(*identity.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_Extension_Properties_AksAssignedIdentity_STATUS populates our Extension_Properties_AksAssignedIdentity_Spec from the provided source Extension_Properties_AksAssignedIdentity_STATUS
func (identity *Extension_Properties_AksAssignedIdentity_Spec) Initialize_From_Extension_Properties_AksAssignedIdentity_STATUS(source *Extension_Properties_AksAssignedIdentity_STATUS) error {

	// Type
	if source.Type != nil {
		typeVar := Extension_Properties_AksAssignedIdentity_Type_Spec(*source.Type)
		identity.Type = &typeVar
	} else {
		identity.Type = nil
	}

	// No error
	return nil
}

type Extension_Properties_AksAssignedIdentity_STATUS struct {
	// PrincipalId: The principal ID of resource identity.
	PrincipalId *string `json:"principalId,omitempty"`

	// TenantId: The tenant ID of resource.
	TenantId *string `json:"tenantId,omitempty"`

	// Type: The identity type.
	Type *Extension_Properties_AksAssignedIdentity_Type_STATUS `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &Extension_Properties_AksAssignedIdentity_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *Extension_Properties_AksAssignedIdentity_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Extension_Properties_AksAssignedIdentity_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *Extension_Properties_AksAssignedIdentity_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Extension_Properties_AksAssignedIdentity_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Extension_Properties_AksAssignedIdentity_STATUS_ARM, got %T", armInput)
	}

	// Set property "PrincipalId":
	if typedInput.PrincipalId != nil {
		principalId := *typedInput.PrincipalId
		identity.PrincipalId = &principalId
	}

	// Set property "TenantId":
	if typedInput.TenantId != nil {
		tenantId := *typedInput.TenantId
		identity.TenantId = &tenantId
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		identity.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_Extension_Properties_AksAssignedIdentity_STATUS populates our Extension_Properties_AksAssignedIdentity_STATUS from the provided source Extension_Properties_AksAssignedIdentity_STATUS
func (identity *Extension_Properties_AksAssignedIdentity_STATUS) AssignProperties_From_Extension_Properties_AksAssignedIdentity_STATUS(source *v20230501s.Extension_Properties_AksAssignedIdentity_STATUS) error {

	// PrincipalId
	identity.PrincipalId = genruntime.ClonePointerToString(source.PrincipalId)

	// TenantId
	identity.TenantId = genruntime.ClonePointerToString(source.TenantId)

	// Type
	if source.Type != nil {
		typeVar := Extension_Properties_AksAssignedIdentity_Type_STATUS(*source.Type)
		identity.Type = &typeVar
	} else {
		identity.Type = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Extension_Properties_AksAssignedIdentity_STATUS populates the provided destination Extension_Properties_AksAssignedIdentity_STATUS from our Extension_Properties_AksAssignedIdentity_STATUS
func (identity *Extension_Properties_AksAssignedIdentity_STATUS) AssignProperties_To_Extension_Properties_AksAssignedIdentity_STATUS(destination *v20230501s.Extension_Properties_AksAssignedIdentity_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PrincipalId
	destination.PrincipalId = genruntime.ClonePointerToString(identity.PrincipalId)

	// TenantId
	destination.TenantId = genruntime.ClonePointerToString(identity.TenantId)

	// Type
	if identity.Type != nil {
		typeVar := string(*identity.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Status from the extension.
type ExtensionStatus_STATUS struct {
	// Code: Status code provided by the Extension
	Code *string `json:"code,omitempty"`

	// DisplayStatus: Short description of status of the extension.
	DisplayStatus *string `json:"displayStatus,omitempty"`

	// Level: Level of the status.
	Level *ExtensionStatus_Level_STATUS `json:"level,omitempty"`

	// Message: Detailed message of the status from the Extension.
	Message *string `json:"message,omitempty"`

	// Time: DateLiteral (per ISO8601) noting the time of installation status.
	Time *string `json:"time,omitempty"`
}

var _ genruntime.FromARMConverter = &ExtensionStatus_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (status *ExtensionStatus_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ExtensionStatus_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (status *ExtensionStatus_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ExtensionStatus_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ExtensionStatus_STATUS_ARM, got %T", armInput)
	}

	// Set property "Code":
	if typedInput.Code != nil {
		code := *typedInput.Code
		status.Code = &code
	}

	// Set property "DisplayStatus":
	if typedInput.DisplayStatus != nil {
		displayStatus := *typedInput.DisplayStatus
		status.DisplayStatus = &displayStatus
	}

	// Set property "Level":
	if typedInput.Level != nil {
		level := *typedInput.Level
		status.Level = &level
	}

	// Set property "Message":
	if typedInput.Message != nil {
		message := *typedInput.Message
		status.Message = &message
	}

	// Set property "Time":
	if typedInput.Time != nil {
		time := *typedInput.Time
		status.Time = &time
	}

	// No error
	return nil
}

// AssignProperties_From_ExtensionStatus_STATUS populates our ExtensionStatus_STATUS from the provided source ExtensionStatus_STATUS
func (status *ExtensionStatus_STATUS) AssignProperties_From_ExtensionStatus_STATUS(source *v20230501s.ExtensionStatus_STATUS) error {

	// Code
	status.Code = genruntime.ClonePointerToString(source.Code)

	// DisplayStatus
	status.DisplayStatus = genruntime.ClonePointerToString(source.DisplayStatus)

	// Level
	if source.Level != nil {
		level := ExtensionStatus_Level_STATUS(*source.Level)
		status.Level = &level
	} else {
		status.Level = nil
	}

	// Message
	status.Message = genruntime.ClonePointerToString(source.Message)

	// Time
	status.Time = genruntime.ClonePointerToString(source.Time)

	// No error
	return nil
}

// AssignProperties_To_ExtensionStatus_STATUS populates the provided destination ExtensionStatus_STATUS from our ExtensionStatus_STATUS
func (status *ExtensionStatus_STATUS) AssignProperties_To_ExtensionStatus_STATUS(destination *v20230501s.ExtensionStatus_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Code
	destination.Code = genruntime.ClonePointerToString(status.Code)

	// DisplayStatus
	destination.DisplayStatus = genruntime.ClonePointerToString(status.DisplayStatus)

	// Level
	if status.Level != nil {
		level := string(*status.Level)
		destination.Level = &level
	} else {
		destination.Level = nil
	}

	// Message
	destination.Message = genruntime.ClonePointerToString(status.Message)

	// Time
	destination.Time = genruntime.ClonePointerToString(status.Time)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Identity for the resource.
type Identity struct {
	// Type: The identity type.
	Type *Identity_Type `json:"type,omitempty"`
}

var _ genruntime.ARMTransformer = &Identity{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (identity *Identity) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if identity == nil {
		return nil, nil
	}
	result := &Identity_ARM{}

	// Set property "Type":
	if identity.Type != nil {
		typeVar := *identity.Type
		result.Type = &typeVar
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *Identity) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Identity_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *Identity) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Identity_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Identity_ARM, got %T", armInput)
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		identity.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_Identity populates our Identity from the provided source Identity
func (identity *Identity) AssignProperties_From_Identity(source *v20230501s.Identity) error {

	// Type
	if source.Type != nil {
		typeVar := Identity_Type(*source.Type)
		identity.Type = &typeVar
	} else {
		identity.Type = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Identity populates the provided destination Identity from our Identity
func (identity *Identity) AssignProperties_To_Identity(destination *v20230501s.Identity) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Type
	if identity.Type != nil {
		typeVar := string(*identity.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_Identity_STATUS populates our Identity from the provided source Identity_STATUS
func (identity *Identity) Initialize_From_Identity_STATUS(source *Identity_STATUS) error {

	// Type
	if source.Type != nil {
		typeVar := Identity_Type(*source.Type)
		identity.Type = &typeVar
	} else {
		identity.Type = nil
	}

	// No error
	return nil
}

// Identity for the resource.
type Identity_STATUS struct {
	// PrincipalId: The principal ID of resource identity.
	PrincipalId *string `json:"principalId,omitempty"`

	// TenantId: The tenant ID of resource.
	TenantId *string `json:"tenantId,omitempty"`

	// Type: The identity type.
	Type *Identity_Type_STATUS `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &Identity_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *Identity_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Identity_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *Identity_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Identity_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Identity_STATUS_ARM, got %T", armInput)
	}

	// Set property "PrincipalId":
	if typedInput.PrincipalId != nil {
		principalId := *typedInput.PrincipalId
		identity.PrincipalId = &principalId
	}

	// Set property "TenantId":
	if typedInput.TenantId != nil {
		tenantId := *typedInput.TenantId
		identity.TenantId = &tenantId
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		identity.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_Identity_STATUS populates our Identity_STATUS from the provided source Identity_STATUS
func (identity *Identity_STATUS) AssignProperties_From_Identity_STATUS(source *v20230501s.Identity_STATUS) error {

	// PrincipalId
	identity.PrincipalId = genruntime.ClonePointerToString(source.PrincipalId)

	// TenantId
	identity.TenantId = genruntime.ClonePointerToString(source.TenantId)

	// Type
	if source.Type != nil {
		typeVar := Identity_Type_STATUS(*source.Type)
		identity.Type = &typeVar
	} else {
		identity.Type = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Identity_STATUS populates the provided destination Identity_STATUS from our Identity_STATUS
func (identity *Identity_STATUS) AssignProperties_To_Identity_STATUS(destination *v20230501s.Identity_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PrincipalId
	destination.PrincipalId = genruntime.ClonePointerToString(identity.PrincipalId)

	// TenantId
	destination.TenantId = genruntime.ClonePointerToString(identity.TenantId)

	// Type
	if identity.Type != nil {
		typeVar := string(*identity.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Plan for the resource.
type Plan struct {
	// +kubebuilder:validation:Required
	// Name: A user defined name of the 3rd Party Artifact that is being procured.
	Name *string `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// Product: The 3rd Party artifact that is being procured. E.g. NewRelic. Product maps to the OfferID specified for the
	// artifact at the time of Data Market onboarding.
	Product *string `json:"product,omitempty"`

	// PromotionCode: A publisher provided promotion code as provisioned in Data Market for the said product/artifact.
	PromotionCode *string `json:"promotionCode,omitempty"`

	// +kubebuilder:validation:Required
	// Publisher: The publisher of the 3rd Party Artifact that is being bought. E.g. NewRelic
	Publisher *string `json:"publisher,omitempty"`

	// Version: The version of the desired product/artifact.
	Version *string `json:"version,omitempty"`
}

var _ genruntime.ARMTransformer = &Plan{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (plan *Plan) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if plan == nil {
		return nil, nil
	}
	result := &Plan_ARM{}

	// Set property "Name":
	if plan.Name != nil {
		name := *plan.Name
		result.Name = &name
	}

	// Set property "Product":
	if plan.Product != nil {
		product := *plan.Product
		result.Product = &product
	}

	// Set property "PromotionCode":
	if plan.PromotionCode != nil {
		promotionCode := *plan.PromotionCode
		result.PromotionCode = &promotionCode
	}

	// Set property "Publisher":
	if plan.Publisher != nil {
		publisher := *plan.Publisher
		result.Publisher = &publisher
	}

	// Set property "Version":
	if plan.Version != nil {
		version := *plan.Version
		result.Version = &version
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (plan *Plan) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Plan_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (plan *Plan) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Plan_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Plan_ARM, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		plan.Name = &name
	}

	// Set property "Product":
	if typedInput.Product != nil {
		product := *typedInput.Product
		plan.Product = &product
	}

	// Set property "PromotionCode":
	if typedInput.PromotionCode != nil {
		promotionCode := *typedInput.PromotionCode
		plan.PromotionCode = &promotionCode
	}

	// Set property "Publisher":
	if typedInput.Publisher != nil {
		publisher := *typedInput.Publisher
		plan.Publisher = &publisher
	}

	// Set property "Version":
	if typedInput.Version != nil {
		version := *typedInput.Version
		plan.Version = &version
	}

	// No error
	return nil
}

// AssignProperties_From_Plan populates our Plan from the provided source Plan
func (plan *Plan) AssignProperties_From_Plan(source *v20230501s.Plan) error {

	// Name
	plan.Name = genruntime.ClonePointerToString(source.Name)

	// Product
	plan.Product = genruntime.ClonePointerToString(source.Product)

	// PromotionCode
	plan.PromotionCode = genruntime.ClonePointerToString(source.PromotionCode)

	// Publisher
	plan.Publisher = genruntime.ClonePointerToString(source.Publisher)

	// Version
	plan.Version = genruntime.ClonePointerToString(source.Version)

	// No error
	return nil
}

// AssignProperties_To_Plan populates the provided destination Plan from our Plan
func (plan *Plan) AssignProperties_To_Plan(destination *v20230501s.Plan) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(plan.Name)

	// Product
	destination.Product = genruntime.ClonePointerToString(plan.Product)

	// PromotionCode
	destination.PromotionCode = genruntime.ClonePointerToString(plan.PromotionCode)

	// Publisher
	destination.Publisher = genruntime.ClonePointerToString(plan.Publisher)

	// Version
	destination.Version = genruntime.ClonePointerToString(plan.Version)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_Plan_STATUS populates our Plan from the provided source Plan_STATUS
func (plan *Plan) Initialize_From_Plan_STATUS(source *Plan_STATUS) error {

	// Name
	plan.Name = genruntime.ClonePointerToString(source.Name)

	// Product
	plan.Product = genruntime.ClonePointerToString(source.Product)

	// PromotionCode
	plan.PromotionCode = genruntime.ClonePointerToString(source.PromotionCode)

	// Publisher
	plan.Publisher = genruntime.ClonePointerToString(source.Publisher)

	// Version
	plan.Version = genruntime.ClonePointerToString(source.Version)

	// No error
	return nil
}

// Plan for the resource.
type Plan_STATUS struct {
	// Name: A user defined name of the 3rd Party Artifact that is being procured.
	Name *string `json:"name,omitempty"`

	// Product: The 3rd Party artifact that is being procured. E.g. NewRelic. Product maps to the OfferID specified for the
	// artifact at the time of Data Market onboarding.
	Product *string `json:"product,omitempty"`

	// PromotionCode: A publisher provided promotion code as provisioned in Data Market for the said product/artifact.
	PromotionCode *string `json:"promotionCode,omitempty"`

	// Publisher: The publisher of the 3rd Party Artifact that is being bought. E.g. NewRelic
	Publisher *string `json:"publisher,omitempty"`

	// Version: The version of the desired product/artifact.
	Version *string `json:"version,omitempty"`
}

var _ genruntime.FromARMConverter = &Plan_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (plan *Plan_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Plan_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (plan *Plan_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Plan_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Plan_STATUS_ARM, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		plan.Name = &name
	}

	// Set property "Product":
	if typedInput.Product != nil {
		product := *typedInput.Product
		plan.Product = &product
	}

	// Set property "PromotionCode":
	if typedInput.PromotionCode != nil {
		promotionCode := *typedInput.PromotionCode
		plan.PromotionCode = &promotionCode
	}

	// Set property "Publisher":
	if typedInput.Publisher != nil {
		publisher := *typedInput.Publisher
		plan.Publisher = &publisher
	}

	// Set property "Version":
	if typedInput.Version != nil {
		version := *typedInput.Version
		plan.Version = &version
	}

	// No error
	return nil
}

// AssignProperties_From_Plan_STATUS populates our Plan_STATUS from the provided source Plan_STATUS
func (plan *Plan_STATUS) AssignProperties_From_Plan_STATUS(source *v20230501s.Plan_STATUS) error {

	// Name
	plan.Name = genruntime.ClonePointerToString(source.Name)

	// Product
	plan.Product = genruntime.ClonePointerToString(source.Product)

	// PromotionCode
	plan.PromotionCode = genruntime.ClonePointerToString(source.PromotionCode)

	// Publisher
	plan.Publisher = genruntime.ClonePointerToString(source.Publisher)

	// Version
	plan.Version = genruntime.ClonePointerToString(source.Version)

	// No error
	return nil
}

// AssignProperties_To_Plan_STATUS populates the provided destination Plan_STATUS from our Plan_STATUS
func (plan *Plan_STATUS) AssignProperties_To_Plan_STATUS(destination *v20230501s.Plan_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(plan.Name)

	// Product
	destination.Product = genruntime.ClonePointerToString(plan.Product)

	// PromotionCode
	destination.PromotionCode = genruntime.ClonePointerToString(plan.PromotionCode)

	// Publisher
	destination.Publisher = genruntime.ClonePointerToString(plan.Publisher)

	// Version
	destination.Version = genruntime.ClonePointerToString(plan.Version)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The provisioning state of the resource.
type ProvisioningStateDefinition_STATUS string

const (
	ProvisioningStateDefinition_STATUS_Canceled  = ProvisioningStateDefinition_STATUS("Canceled")
	ProvisioningStateDefinition_STATUS_Creating  = ProvisioningStateDefinition_STATUS("Creating")
	ProvisioningStateDefinition_STATUS_Deleting  = ProvisioningStateDefinition_STATUS("Deleting")
	ProvisioningStateDefinition_STATUS_Failed    = ProvisioningStateDefinition_STATUS("Failed")
	ProvisioningStateDefinition_STATUS_Succeeded = ProvisioningStateDefinition_STATUS("Succeeded")
	ProvisioningStateDefinition_STATUS_Updating  = ProvisioningStateDefinition_STATUS("Updating")
)

// Scope of the extension. It can be either Cluster or Namespace; but not both.
type Scope struct {
	// Cluster: Specifies that the scope of the extension is Cluster
	Cluster *ScopeCluster `json:"cluster,omitempty"`

	// Namespace: Specifies that the scope of the extension is Namespace
	Namespace *ScopeNamespace `json:"namespace,omitempty"`
}

var _ genruntime.ARMTransformer = &Scope{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (scope *Scope) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if scope == nil {
		return nil, nil
	}
	result := &Scope_ARM{}

	// Set property "Cluster":
	if scope.Cluster != nil {
		cluster_ARM, err := (*scope.Cluster).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		cluster := *cluster_ARM.(*ScopeCluster_ARM)
		result.Cluster = &cluster
	}

	// Set property "Namespace":
	if scope.Namespace != nil {
		namespace_ARM, err := (*scope.Namespace).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		namespace := *namespace_ARM.(*ScopeNamespace_ARM)
		result.Namespace = &namespace
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (scope *Scope) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Scope_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (scope *Scope) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Scope_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Scope_ARM, got %T", armInput)
	}

	// Set property "Cluster":
	if typedInput.Cluster != nil {
		var cluster1 ScopeCluster
		err := cluster1.PopulateFromARM(owner, *typedInput.Cluster)
		if err != nil {
			return err
		}
		cluster := cluster1
		scope.Cluster = &cluster
	}

	// Set property "Namespace":
	if typedInput.Namespace != nil {
		var namespace1 ScopeNamespace
		err := namespace1.PopulateFromARM(owner, *typedInput.Namespace)
		if err != nil {
			return err
		}
		namespace := namespace1
		scope.Namespace = &namespace
	}

	// No error
	return nil
}

// AssignProperties_From_Scope populates our Scope from the provided source Scope
func (scope *Scope) AssignProperties_From_Scope(source *v20230501s.Scope) error {

	// Cluster
	if source.Cluster != nil {
		var cluster ScopeCluster
		err := cluster.AssignProperties_From_ScopeCluster(source.Cluster)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ScopeCluster() to populate field Cluster")
		}
		scope.Cluster = &cluster
	} else {
		scope.Cluster = nil
	}

	// Namespace
	if source.Namespace != nil {
		var namespace ScopeNamespace
		err := namespace.AssignProperties_From_ScopeNamespace(source.Namespace)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ScopeNamespace() to populate field Namespace")
		}
		scope.Namespace = &namespace
	} else {
		scope.Namespace = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Scope populates the provided destination Scope from our Scope
func (scope *Scope) AssignProperties_To_Scope(destination *v20230501s.Scope) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Cluster
	if scope.Cluster != nil {
		var cluster v20230501s.ScopeCluster
		err := scope.Cluster.AssignProperties_To_ScopeCluster(&cluster)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ScopeCluster() to populate field Cluster")
		}
		destination.Cluster = &cluster
	} else {
		destination.Cluster = nil
	}

	// Namespace
	if scope.Namespace != nil {
		var namespace v20230501s.ScopeNamespace
		err := scope.Namespace.AssignProperties_To_ScopeNamespace(&namespace)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ScopeNamespace() to populate field Namespace")
		}
		destination.Namespace = &namespace
	} else {
		destination.Namespace = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_Scope_STATUS populates our Scope from the provided source Scope_STATUS
func (scope *Scope) Initialize_From_Scope_STATUS(source *Scope_STATUS) error {

	// Cluster
	if source.Cluster != nil {
		var cluster ScopeCluster
		err := cluster.Initialize_From_ScopeCluster_STATUS(source.Cluster)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_ScopeCluster_STATUS() to populate field Cluster")
		}
		scope.Cluster = &cluster
	} else {
		scope.Cluster = nil
	}

	// Namespace
	if source.Namespace != nil {
		var namespace ScopeNamespace
		err := namespace.Initialize_From_ScopeNamespace_STATUS(source.Namespace)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_ScopeNamespace_STATUS() to populate field Namespace")
		}
		scope.Namespace = &namespace
	} else {
		scope.Namespace = nil
	}

	// No error
	return nil
}

// Scope of the extension. It can be either Cluster or Namespace; but not both.
type Scope_STATUS struct {
	// Cluster: Specifies that the scope of the extension is Cluster
	Cluster *ScopeCluster_STATUS `json:"cluster,omitempty"`

	// Namespace: Specifies that the scope of the extension is Namespace
	Namespace *ScopeNamespace_STATUS `json:"namespace,omitempty"`
}

var _ genruntime.FromARMConverter = &Scope_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (scope *Scope_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Scope_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (scope *Scope_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Scope_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Scope_STATUS_ARM, got %T", armInput)
	}

	// Set property "Cluster":
	if typedInput.Cluster != nil {
		var cluster1 ScopeCluster_STATUS
		err := cluster1.PopulateFromARM(owner, *typedInput.Cluster)
		if err != nil {
			return err
		}
		cluster := cluster1
		scope.Cluster = &cluster
	}

	// Set property "Namespace":
	if typedInput.Namespace != nil {
		var namespace1 ScopeNamespace_STATUS
		err := namespace1.PopulateFromARM(owner, *typedInput.Namespace)
		if err != nil {
			return err
		}
		namespace := namespace1
		scope.Namespace = &namespace
	}

	// No error
	return nil
}

// AssignProperties_From_Scope_STATUS populates our Scope_STATUS from the provided source Scope_STATUS
func (scope *Scope_STATUS) AssignProperties_From_Scope_STATUS(source *v20230501s.Scope_STATUS) error {

	// Cluster
	if source.Cluster != nil {
		var cluster ScopeCluster_STATUS
		err := cluster.AssignProperties_From_ScopeCluster_STATUS(source.Cluster)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ScopeCluster_STATUS() to populate field Cluster")
		}
		scope.Cluster = &cluster
	} else {
		scope.Cluster = nil
	}

	// Namespace
	if source.Namespace != nil {
		var namespace ScopeNamespace_STATUS
		err := namespace.AssignProperties_From_ScopeNamespace_STATUS(source.Namespace)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ScopeNamespace_STATUS() to populate field Namespace")
		}
		scope.Namespace = &namespace
	} else {
		scope.Namespace = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Scope_STATUS populates the provided destination Scope_STATUS from our Scope_STATUS
func (scope *Scope_STATUS) AssignProperties_To_Scope_STATUS(destination *v20230501s.Scope_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Cluster
	if scope.Cluster != nil {
		var cluster v20230501s.ScopeCluster_STATUS
		err := scope.Cluster.AssignProperties_To_ScopeCluster_STATUS(&cluster)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ScopeCluster_STATUS() to populate field Cluster")
		}
		destination.Cluster = &cluster
	} else {
		destination.Cluster = nil
	}

	// Namespace
	if scope.Namespace != nil {
		var namespace v20230501s.ScopeNamespace_STATUS
		err := scope.Namespace.AssignProperties_To_ScopeNamespace_STATUS(&namespace)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ScopeNamespace_STATUS() to populate field Namespace")
		}
		destination.Namespace = &namespace
	} else {
		destination.Namespace = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Metadata pertaining to creation and last modification of the resource.
type SystemData struct {
	// CreatedAt: The timestamp of resource creation (UTC).
	CreatedAt *string `json:"createdAt,omitempty"`

	// CreatedBy: The identity that created the resource.
	CreatedBy *string `json:"createdBy,omitempty"`

	// CreatedByType: The type of identity that created the resource.
	CreatedByType *SystemData_CreatedByType `json:"createdByType,omitempty"`

	// LastModifiedAt: The timestamp of resource last modification (UTC)
	LastModifiedAt *string `json:"lastModifiedAt,omitempty"`

	// LastModifiedBy: The identity that last modified the resource.
	LastModifiedBy *string `json:"lastModifiedBy,omitempty"`

	// LastModifiedByType: The type of identity that last modified the resource.
	LastModifiedByType *SystemData_LastModifiedByType `json:"lastModifiedByType,omitempty"`
}

var _ genruntime.ARMTransformer = &SystemData{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (data *SystemData) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if data == nil {
		return nil, nil
	}
	result := &SystemData_ARM{}

	// Set property "CreatedAt":
	if data.CreatedAt != nil {
		createdAt := *data.CreatedAt
		result.CreatedAt = &createdAt
	}

	// Set property "CreatedBy":
	if data.CreatedBy != nil {
		createdBy := *data.CreatedBy
		result.CreatedBy = &createdBy
	}

	// Set property "CreatedByType":
	if data.CreatedByType != nil {
		createdByType := *data.CreatedByType
		result.CreatedByType = &createdByType
	}

	// Set property "LastModifiedAt":
	if data.LastModifiedAt != nil {
		lastModifiedAt := *data.LastModifiedAt
		result.LastModifiedAt = &lastModifiedAt
	}

	// Set property "LastModifiedBy":
	if data.LastModifiedBy != nil {
		lastModifiedBy := *data.LastModifiedBy
		result.LastModifiedBy = &lastModifiedBy
	}

	// Set property "LastModifiedByType":
	if data.LastModifiedByType != nil {
		lastModifiedByType := *data.LastModifiedByType
		result.LastModifiedByType = &lastModifiedByType
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (data *SystemData) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &SystemData_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (data *SystemData) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(SystemData_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected SystemData_ARM, got %T", armInput)
	}

	// Set property "CreatedAt":
	if typedInput.CreatedAt != nil {
		createdAt := *typedInput.CreatedAt
		data.CreatedAt = &createdAt
	}

	// Set property "CreatedBy":
	if typedInput.CreatedBy != nil {
		createdBy := *typedInput.CreatedBy
		data.CreatedBy = &createdBy
	}

	// Set property "CreatedByType":
	if typedInput.CreatedByType != nil {
		createdByType := *typedInput.CreatedByType
		data.CreatedByType = &createdByType
	}

	// Set property "LastModifiedAt":
	if typedInput.LastModifiedAt != nil {
		lastModifiedAt := *typedInput.LastModifiedAt
		data.LastModifiedAt = &lastModifiedAt
	}

	// Set property "LastModifiedBy":
	if typedInput.LastModifiedBy != nil {
		lastModifiedBy := *typedInput.LastModifiedBy
		data.LastModifiedBy = &lastModifiedBy
	}

	// Set property "LastModifiedByType":
	if typedInput.LastModifiedByType != nil {
		lastModifiedByType := *typedInput.LastModifiedByType
		data.LastModifiedByType = &lastModifiedByType
	}

	// No error
	return nil
}

// AssignProperties_From_SystemData populates our SystemData from the provided source SystemData
func (data *SystemData) AssignProperties_From_SystemData(source *v20230501s.SystemData) error {

	// CreatedAt
	data.CreatedAt = genruntime.ClonePointerToString(source.CreatedAt)

	// CreatedBy
	data.CreatedBy = genruntime.ClonePointerToString(source.CreatedBy)

	// CreatedByType
	if source.CreatedByType != nil {
		createdByType := SystemData_CreatedByType(*source.CreatedByType)
		data.CreatedByType = &createdByType
	} else {
		data.CreatedByType = nil
	}

	// LastModifiedAt
	data.LastModifiedAt = genruntime.ClonePointerToString(source.LastModifiedAt)

	// LastModifiedBy
	data.LastModifiedBy = genruntime.ClonePointerToString(source.LastModifiedBy)

	// LastModifiedByType
	if source.LastModifiedByType != nil {
		lastModifiedByType := SystemData_LastModifiedByType(*source.LastModifiedByType)
		data.LastModifiedByType = &lastModifiedByType
	} else {
		data.LastModifiedByType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_SystemData populates the provided destination SystemData from our SystemData
func (data *SystemData) AssignProperties_To_SystemData(destination *v20230501s.SystemData) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CreatedAt
	destination.CreatedAt = genruntime.ClonePointerToString(data.CreatedAt)

	// CreatedBy
	destination.CreatedBy = genruntime.ClonePointerToString(data.CreatedBy)

	// CreatedByType
	if data.CreatedByType != nil {
		createdByType := string(*data.CreatedByType)
		destination.CreatedByType = &createdByType
	} else {
		destination.CreatedByType = nil
	}

	// LastModifiedAt
	destination.LastModifiedAt = genruntime.ClonePointerToString(data.LastModifiedAt)

	// LastModifiedBy
	destination.LastModifiedBy = genruntime.ClonePointerToString(data.LastModifiedBy)

	// LastModifiedByType
	if data.LastModifiedByType != nil {
		lastModifiedByType := string(*data.LastModifiedByType)
		destination.LastModifiedByType = &lastModifiedByType
	} else {
		destination.LastModifiedByType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_SystemData_STATUS populates our SystemData from the provided source SystemData_STATUS
func (data *SystemData) Initialize_From_SystemData_STATUS(source *SystemData_STATUS) error {

	// CreatedAt
	data.CreatedAt = genruntime.ClonePointerToString(source.CreatedAt)

	// CreatedBy
	data.CreatedBy = genruntime.ClonePointerToString(source.CreatedBy)

	// CreatedByType
	if source.CreatedByType != nil {
		createdByType := SystemData_CreatedByType(*source.CreatedByType)
		data.CreatedByType = &createdByType
	} else {
		data.CreatedByType = nil
	}

	// LastModifiedAt
	data.LastModifiedAt = genruntime.ClonePointerToString(source.LastModifiedAt)

	// LastModifiedBy
	data.LastModifiedBy = genruntime.ClonePointerToString(source.LastModifiedBy)

	// LastModifiedByType
	if source.LastModifiedByType != nil {
		lastModifiedByType := SystemData_LastModifiedByType(*source.LastModifiedByType)
		data.LastModifiedByType = &lastModifiedByType
	} else {
		data.LastModifiedByType = nil
	}

	// No error
	return nil
}

// Metadata pertaining to creation and last modification of the resource.
type SystemData_STATUS struct {
	// CreatedAt: The timestamp of resource creation (UTC).
	CreatedAt *string `json:"createdAt,omitempty"`

	// CreatedBy: The identity that created the resource.
	CreatedBy *string `json:"createdBy,omitempty"`

	// CreatedByType: The type of identity that created the resource.
	CreatedByType *SystemData_CreatedByType_STATUS `json:"createdByType,omitempty"`

	// LastModifiedAt: The timestamp of resource last modification (UTC)
	LastModifiedAt *string `json:"lastModifiedAt,omitempty"`

	// LastModifiedBy: The identity that last modified the resource.
	LastModifiedBy *string `json:"lastModifiedBy,omitempty"`

	// LastModifiedByType: The type of identity that last modified the resource.
	LastModifiedByType *SystemData_LastModifiedByType_STATUS `json:"lastModifiedByType,omitempty"`
}

var _ genruntime.FromARMConverter = &SystemData_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (data *SystemData_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &SystemData_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (data *SystemData_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(SystemData_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected SystemData_STATUS_ARM, got %T", armInput)
	}

	// Set property "CreatedAt":
	if typedInput.CreatedAt != nil {
		createdAt := *typedInput.CreatedAt
		data.CreatedAt = &createdAt
	}

	// Set property "CreatedBy":
	if typedInput.CreatedBy != nil {
		createdBy := *typedInput.CreatedBy
		data.CreatedBy = &createdBy
	}

	// Set property "CreatedByType":
	if typedInput.CreatedByType != nil {
		createdByType := *typedInput.CreatedByType
		data.CreatedByType = &createdByType
	}

	// Set property "LastModifiedAt":
	if typedInput.LastModifiedAt != nil {
		lastModifiedAt := *typedInput.LastModifiedAt
		data.LastModifiedAt = &lastModifiedAt
	}

	// Set property "LastModifiedBy":
	if typedInput.LastModifiedBy != nil {
		lastModifiedBy := *typedInput.LastModifiedBy
		data.LastModifiedBy = &lastModifiedBy
	}

	// Set property "LastModifiedByType":
	if typedInput.LastModifiedByType != nil {
		lastModifiedByType := *typedInput.LastModifiedByType
		data.LastModifiedByType = &lastModifiedByType
	}

	// No error
	return nil
}

// AssignProperties_From_SystemData_STATUS populates our SystemData_STATUS from the provided source SystemData_STATUS
func (data *SystemData_STATUS) AssignProperties_From_SystemData_STATUS(source *v20230501s.SystemData_STATUS) error {

	// CreatedAt
	data.CreatedAt = genruntime.ClonePointerToString(source.CreatedAt)

	// CreatedBy
	data.CreatedBy = genruntime.ClonePointerToString(source.CreatedBy)

	// CreatedByType
	if source.CreatedByType != nil {
		createdByType := SystemData_CreatedByType_STATUS(*source.CreatedByType)
		data.CreatedByType = &createdByType
	} else {
		data.CreatedByType = nil
	}

	// LastModifiedAt
	data.LastModifiedAt = genruntime.ClonePointerToString(source.LastModifiedAt)

	// LastModifiedBy
	data.LastModifiedBy = genruntime.ClonePointerToString(source.LastModifiedBy)

	// LastModifiedByType
	if source.LastModifiedByType != nil {
		lastModifiedByType := SystemData_LastModifiedByType_STATUS(*source.LastModifiedByType)
		data.LastModifiedByType = &lastModifiedByType
	} else {
		data.LastModifiedByType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_SystemData_STATUS populates the provided destination SystemData_STATUS from our SystemData_STATUS
func (data *SystemData_STATUS) AssignProperties_To_SystemData_STATUS(destination *v20230501s.SystemData_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CreatedAt
	destination.CreatedAt = genruntime.ClonePointerToString(data.CreatedAt)

	// CreatedBy
	destination.CreatedBy = genruntime.ClonePointerToString(data.CreatedBy)

	// CreatedByType
	if data.CreatedByType != nil {
		createdByType := string(*data.CreatedByType)
		destination.CreatedByType = &createdByType
	} else {
		destination.CreatedByType = nil
	}

	// LastModifiedAt
	destination.LastModifiedAt = genruntime.ClonePointerToString(data.LastModifiedAt)

	// LastModifiedBy
	destination.LastModifiedBy = genruntime.ClonePointerToString(data.LastModifiedBy)

	// LastModifiedByType
	if data.LastModifiedByType != nil {
		lastModifiedByType := string(*data.LastModifiedByType)
		destination.LastModifiedByType = &lastModifiedByType
	} else {
		destination.LastModifiedByType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The resource management error additional info.
type ErrorAdditionalInfo_STATUS struct {
	// Info: The additional info.
	Info map[string]v1.JSON `json:"info,omitempty"`

	// Type: The additional info type.
	Type *string `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &ErrorAdditionalInfo_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (info *ErrorAdditionalInfo_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ErrorAdditionalInfo_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (info *ErrorAdditionalInfo_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ErrorAdditionalInfo_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ErrorAdditionalInfo_STATUS_ARM, got %T", armInput)
	}

	// Set property "Info":
	if typedInput.Info != nil {
		info.Info = make(map[string]v1.JSON, len(typedInput.Info))
		for key, value := range typedInput.Info {
			info.Info[key] = *value.DeepCopy()
		}
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		info.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_ErrorAdditionalInfo_STATUS populates our ErrorAdditionalInfo_STATUS from the provided source ErrorAdditionalInfo_STATUS
func (info *ErrorAdditionalInfo_STATUS) AssignProperties_From_ErrorAdditionalInfo_STATUS(source *v20230501s.ErrorAdditionalInfo_STATUS) error {

	// Info
	if source.Info != nil {
		infoMap := make(map[string]v1.JSON, len(source.Info))
		for infoKey, infoValue := range source.Info {
			// Shadow the loop variable to avoid aliasing
			infoValue := infoValue
			infoMap[infoKey] = *infoValue.DeepCopy()
		}
		info.Info = infoMap
	} else {
		info.Info = nil
	}

	// Type
	info.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignProperties_To_ErrorAdditionalInfo_STATUS populates the provided destination ErrorAdditionalInfo_STATUS from our ErrorAdditionalInfo_STATUS
func (info *ErrorAdditionalInfo_STATUS) AssignProperties_To_ErrorAdditionalInfo_STATUS(destination *v20230501s.ErrorAdditionalInfo_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Info
	if info.Info != nil {
		infoMap := make(map[string]v1.JSON, len(info.Info))
		for infoKey, infoValue := range info.Info {
			// Shadow the loop variable to avoid aliasing
			infoValue := infoValue
			infoMap[infoKey] = *infoValue.DeepCopy()
		}
		destination.Info = infoMap
	} else {
		destination.Info = nil
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(info.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ErrorDetail_STATUS_Unrolled struct {
	// AdditionalInfo: The error additional info.
	AdditionalInfo []ErrorAdditionalInfo_STATUS `json:"additionalInfo,omitempty"`

	// Code: The error code.
	Code *string `json:"code,omitempty"`

	// Message: The error message.
	Message *string `json:"message,omitempty"`

	// Target: The error target.
	Target *string `json:"target,omitempty"`
}

var _ genruntime.FromARMConverter = &ErrorDetail_STATUS_Unrolled{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (unrolled *ErrorDetail_STATUS_Unrolled) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ErrorDetail_STATUS_Unrolled_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (unrolled *ErrorDetail_STATUS_Unrolled) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ErrorDetail_STATUS_Unrolled_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ErrorDetail_STATUS_Unrolled_ARM, got %T", armInput)
	}

	// Set property "AdditionalInfo":
	for _, item := range typedInput.AdditionalInfo {
		var item1 ErrorAdditionalInfo_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		unrolled.AdditionalInfo = append(unrolled.AdditionalInfo, item1)
	}

	// Set property "Code":
	if typedInput.Code != nil {
		code := *typedInput.Code
		unrolled.Code = &code
	}

	// Set property "Message":
	if typedInput.Message != nil {
		message := *typedInput.Message
		unrolled.Message = &message
	}

	// Set property "Target":
	if typedInput.Target != nil {
		target := *typedInput.Target
		unrolled.Target = &target
	}

	// No error
	return nil
}

// AssignProperties_From_ErrorDetail_STATUS_Unrolled populates our ErrorDetail_STATUS_Unrolled from the provided source ErrorDetail_STATUS_Unrolled
func (unrolled *ErrorDetail_STATUS_Unrolled) AssignProperties_From_ErrorDetail_STATUS_Unrolled(source *v20230501s.ErrorDetail_STATUS_Unrolled) error {

	// AdditionalInfo
	if source.AdditionalInfo != nil {
		additionalInfoList := make([]ErrorAdditionalInfo_STATUS, len(source.AdditionalInfo))
		for additionalInfoIndex, additionalInfoItem := range source.AdditionalInfo {
			// Shadow the loop variable to avoid aliasing
			additionalInfoItem := additionalInfoItem
			var additionalInfo ErrorAdditionalInfo_STATUS
			err := additionalInfo.AssignProperties_From_ErrorAdditionalInfo_STATUS(&additionalInfoItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ErrorAdditionalInfo_STATUS() to populate field AdditionalInfo")
			}
			additionalInfoList[additionalInfoIndex] = additionalInfo
		}
		unrolled.AdditionalInfo = additionalInfoList
	} else {
		unrolled.AdditionalInfo = nil
	}

	// Code
	unrolled.Code = genruntime.ClonePointerToString(source.Code)

	// Message
	unrolled.Message = genruntime.ClonePointerToString(source.Message)

	// Target
	unrolled.Target = genruntime.ClonePointerToString(source.Target)

	// No error
	return nil
}

// AssignProperties_To_ErrorDetail_STATUS_Unrolled populates the provided destination ErrorDetail_STATUS_Unrolled from our ErrorDetail_STATUS_Unrolled
func (unrolled *ErrorDetail_STATUS_Unrolled) AssignProperties_To_ErrorDetail_STATUS_Unrolled(destination *v20230501s.ErrorDetail_STATUS_Unrolled) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdditionalInfo
	if unrolled.AdditionalInfo != nil {
		additionalInfoList := make([]v20230501s.ErrorAdditionalInfo_STATUS, len(unrolled.AdditionalInfo))
		for additionalInfoIndex, additionalInfoItem := range unrolled.AdditionalInfo {
			// Shadow the loop variable to avoid aliasing
			additionalInfoItem := additionalInfoItem
			var additionalInfo v20230501s.ErrorAdditionalInfo_STATUS
			err := additionalInfoItem.AssignProperties_To_ErrorAdditionalInfo_STATUS(&additionalInfo)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ErrorAdditionalInfo_STATUS() to populate field AdditionalInfo")
			}
			additionalInfoList[additionalInfoIndex] = additionalInfo
		}
		destination.AdditionalInfo = additionalInfoList
	} else {
		destination.AdditionalInfo = nil
	}

	// Code
	destination.Code = genruntime.ClonePointerToString(unrolled.Code)

	// Message
	destination.Message = genruntime.ClonePointerToString(unrolled.Message)

	// Target
	destination.Target = genruntime.ClonePointerToString(unrolled.Target)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"SystemAssigned","UserAssigned"}
type Extension_Properties_AksAssignedIdentity_Type_Spec string

const (
	Extension_Properties_AksAssignedIdentity_Type_Spec_SystemAssigned = Extension_Properties_AksAssignedIdentity_Type_Spec("SystemAssigned")
	Extension_Properties_AksAssignedIdentity_Type_Spec_UserAssigned   = Extension_Properties_AksAssignedIdentity_Type_Spec("UserAssigned")
)

type Extension_Properties_AksAssignedIdentity_Type_STATUS string

const (
	Extension_Properties_AksAssignedIdentity_Type_STATUS_SystemAssigned = Extension_Properties_AksAssignedIdentity_Type_STATUS("SystemAssigned")
	Extension_Properties_AksAssignedIdentity_Type_STATUS_UserAssigned   = Extension_Properties_AksAssignedIdentity_Type_STATUS("UserAssigned")
)

type ExtensionStatus_Level_STATUS string

const (
	ExtensionStatus_Level_STATUS_Error       = ExtensionStatus_Level_STATUS("Error")
	ExtensionStatus_Level_STATUS_Information = ExtensionStatus_Level_STATUS("Information")
	ExtensionStatus_Level_STATUS_Warning     = ExtensionStatus_Level_STATUS("Warning")
)

// Specifies that the scope of the extension is Cluster
type ScopeCluster struct {
	// ReleaseNamespace: Namespace where the extension Release must be placed, for a Cluster scoped extension.  If this
	// namespace does not exist, it will be created
	ReleaseNamespace *string `json:"releaseNamespace,omitempty"`
}

var _ genruntime.ARMTransformer = &ScopeCluster{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (cluster *ScopeCluster) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if cluster == nil {
		return nil, nil
	}
	result := &ScopeCluster_ARM{}

	// Set property "ReleaseNamespace":
	if cluster.ReleaseNamespace != nil {
		releaseNamespace := *cluster.ReleaseNamespace
		result.ReleaseNamespace = &releaseNamespace
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (cluster *ScopeCluster) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ScopeCluster_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (cluster *ScopeCluster) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ScopeCluster_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ScopeCluster_ARM, got %T", armInput)
	}

	// Set property "ReleaseNamespace":
	if typedInput.ReleaseNamespace != nil {
		releaseNamespace := *typedInput.ReleaseNamespace
		cluster.ReleaseNamespace = &releaseNamespace
	}

	// No error
	return nil
}

// AssignProperties_From_ScopeCluster populates our ScopeCluster from the provided source ScopeCluster
func (cluster *ScopeCluster) AssignProperties_From_ScopeCluster(source *v20230501s.ScopeCluster) error {

	// ReleaseNamespace
	cluster.ReleaseNamespace = genruntime.ClonePointerToString(source.ReleaseNamespace)

	// No error
	return nil
}

// AssignProperties_To_ScopeCluster populates the provided destination ScopeCluster from our ScopeCluster
func (cluster *ScopeCluster) AssignProperties_To_ScopeCluster(destination *v20230501s.ScopeCluster) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ReleaseNamespace
	destination.ReleaseNamespace = genruntime.ClonePointerToString(cluster.ReleaseNamespace)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ScopeCluster_STATUS populates our ScopeCluster from the provided source ScopeCluster_STATUS
func (cluster *ScopeCluster) Initialize_From_ScopeCluster_STATUS(source *ScopeCluster_STATUS) error {

	// ReleaseNamespace
	cluster.ReleaseNamespace = genruntime.ClonePointerToString(source.ReleaseNamespace)

	// No error
	return nil
}

// Specifies that the scope of the extension is Cluster
type ScopeCluster_STATUS struct {
	// ReleaseNamespace: Namespace where the extension Release must be placed, for a Cluster scoped extension.  If this
	// namespace does not exist, it will be created
	ReleaseNamespace *string `json:"releaseNamespace,omitempty"`
}

var _ genruntime.FromARMConverter = &ScopeCluster_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (cluster *ScopeCluster_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ScopeCluster_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (cluster *ScopeCluster_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ScopeCluster_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ScopeCluster_STATUS_ARM, got %T", armInput)
	}

	// Set property "ReleaseNamespace":
	if typedInput.ReleaseNamespace != nil {
		releaseNamespace := *typedInput.ReleaseNamespace
		cluster.ReleaseNamespace = &releaseNamespace
	}

	// No error
	return nil
}

// AssignProperties_From_ScopeCluster_STATUS populates our ScopeCluster_STATUS from the provided source ScopeCluster_STATUS
func (cluster *ScopeCluster_STATUS) AssignProperties_From_ScopeCluster_STATUS(source *v20230501s.ScopeCluster_STATUS) error {

	// ReleaseNamespace
	cluster.ReleaseNamespace = genruntime.ClonePointerToString(source.ReleaseNamespace)

	// No error
	return nil
}

// AssignProperties_To_ScopeCluster_STATUS populates the provided destination ScopeCluster_STATUS from our ScopeCluster_STATUS
func (cluster *ScopeCluster_STATUS) AssignProperties_To_ScopeCluster_STATUS(destination *v20230501s.ScopeCluster_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ReleaseNamespace
	destination.ReleaseNamespace = genruntime.ClonePointerToString(cluster.ReleaseNamespace)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Specifies that the scope of the extension is Namespace
type ScopeNamespace struct {
	// TargetNamespace: Namespace where the extension will be created for an Namespace scoped extension.  If this namespace
	// does not exist, it will be created
	TargetNamespace *string `json:"targetNamespace,omitempty"`
}

var _ genruntime.ARMTransformer = &ScopeNamespace{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (namespace *ScopeNamespace) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if namespace == nil {
		return nil, nil
	}
	result := &ScopeNamespace_ARM{}

	// Set property "TargetNamespace":
	if namespace.TargetNamespace != nil {
		targetNamespace := *namespace.TargetNamespace
		result.TargetNamespace = &targetNamespace
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (namespace *ScopeNamespace) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ScopeNamespace_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (namespace *ScopeNamespace) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ScopeNamespace_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ScopeNamespace_ARM, got %T", armInput)
	}

	// Set property "TargetNamespace":
	if typedInput.TargetNamespace != nil {
		targetNamespace := *typedInput.TargetNamespace
		namespace.TargetNamespace = &targetNamespace
	}

	// No error
	return nil
}

// AssignProperties_From_ScopeNamespace populates our ScopeNamespace from the provided source ScopeNamespace
func (namespace *ScopeNamespace) AssignProperties_From_ScopeNamespace(source *v20230501s.ScopeNamespace) error {

	// TargetNamespace
	namespace.TargetNamespace = genruntime.ClonePointerToString(source.TargetNamespace)

	// No error
	return nil
}

// AssignProperties_To_ScopeNamespace populates the provided destination ScopeNamespace from our ScopeNamespace
func (namespace *ScopeNamespace) AssignProperties_To_ScopeNamespace(destination *v20230501s.ScopeNamespace) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// TargetNamespace
	destination.TargetNamespace = genruntime.ClonePointerToString(namespace.TargetNamespace)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ScopeNamespace_STATUS populates our ScopeNamespace from the provided source ScopeNamespace_STATUS
func (namespace *ScopeNamespace) Initialize_From_ScopeNamespace_STATUS(source *ScopeNamespace_STATUS) error {

	// TargetNamespace
	namespace.TargetNamespace = genruntime.ClonePointerToString(source.TargetNamespace)

	// No error
	return nil
}

// Specifies that the scope of the extension is Namespace
type ScopeNamespace_STATUS struct {
	// TargetNamespace: Namespace where the extension will be created for an Namespace scoped extension.  If this namespace
	// does not exist, it will be created
	TargetNamespace *string `json:"targetNamespace,omitempty"`
}

var _ genruntime.FromARMConverter = &ScopeNamespace_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (namespace *ScopeNamespace_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ScopeNamespace_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (namespace *ScopeNamespace_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ScopeNamespace_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ScopeNamespace_STATUS_ARM, got %T", armInput)
	}

	// Set property "TargetNamespace":
	if typedInput.TargetNamespace != nil {
		targetNamespace := *typedInput.TargetNamespace
		namespace.TargetNamespace = &targetNamespace
	}

	// No error
	return nil
}

// AssignProperties_From_ScopeNamespace_STATUS populates our ScopeNamespace_STATUS from the provided source ScopeNamespace_STATUS
func (namespace *ScopeNamespace_STATUS) AssignProperties_From_ScopeNamespace_STATUS(source *v20230501s.ScopeNamespace_STATUS) error {

	// TargetNamespace
	namespace.TargetNamespace = genruntime.ClonePointerToString(source.TargetNamespace)

	// No error
	return nil
}

// AssignProperties_To_ScopeNamespace_STATUS populates the provided destination ScopeNamespace_STATUS from our ScopeNamespace_STATUS
func (namespace *ScopeNamespace_STATUS) AssignProperties_To_ScopeNamespace_STATUS(destination *v20230501s.ScopeNamespace_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// TargetNamespace
	destination.TargetNamespace = genruntime.ClonePointerToString(namespace.TargetNamespace)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

func init() {
	SchemeBuilder.Register(&Extension{}, &ExtensionList{})
}
