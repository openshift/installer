// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package compat

import (
	storage "github.com/Azure/azure-service-operator/v2/api/containerservice/v1api20231001/storage"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/pkg/errors"
)

// Storage version of v1api20230202preview.ServiceMeshProfile
// Service mesh profile for a managed cluster.
type ServiceMeshProfile struct {
	Istio       *IstioServiceMesh      `json:"istio,omitempty"`
	Mode        *string                `json:"mode,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_ServiceMeshProfile populates our ServiceMeshProfile from the provided source ServiceMeshProfile
func (profile *ServiceMeshProfile) AssignProperties_From_ServiceMeshProfile(source *storage.ServiceMeshProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Istio
	if source.Istio != nil {
		var istio IstioServiceMesh
		err := istio.AssignProperties_From_IstioServiceMesh(source.Istio)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_IstioServiceMesh() to populate field Istio")
		}
		profile.Istio = &istio
	} else {
		profile.Istio = nil
	}

	// Mode
	profile.Mode = genruntime.ClonePointerToString(source.Mode)

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// Invoke the augmentConversionForServiceMeshProfile interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForServiceMeshProfile); ok {
		err := augmentedProfile.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ServiceMeshProfile populates the provided destination ServiceMeshProfile from our ServiceMeshProfile
func (profile *ServiceMeshProfile) AssignProperties_To_ServiceMeshProfile(destination *storage.ServiceMeshProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// Istio
	if profile.Istio != nil {
		var istio storage.IstioServiceMesh
		err := profile.Istio.AssignProperties_To_IstioServiceMesh(&istio)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_IstioServiceMesh() to populate field Istio")
		}
		destination.Istio = &istio
	} else {
		destination.Istio = nil
	}

	// Mode
	destination.Mode = genruntime.ClonePointerToString(profile.Mode)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForServiceMeshProfile interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForServiceMeshProfile); ok {
		err := augmentedProfile.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

type augmentConversionForServiceMeshProfile interface {
	AssignPropertiesFrom(src *storage.ServiceMeshProfile) error
	AssignPropertiesTo(dst *storage.ServiceMeshProfile) error
}

// Storage version of v1api20230202preview.IstioServiceMesh
// Istio service mesh configuration.
type IstioServiceMesh struct {
	Components  *IstioComponents       `json:"components,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_IstioServiceMesh populates our IstioServiceMesh from the provided source IstioServiceMesh
func (mesh *IstioServiceMesh) AssignProperties_From_IstioServiceMesh(source *storage.IstioServiceMesh) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// CertificateAuthority
	if source.CertificateAuthority != nil {
		propertyBag.Add("CertificateAuthority", *source.CertificateAuthority)
	} else {
		propertyBag.Remove("CertificateAuthority")
	}

	// Components
	if source.Components != nil {
		var component IstioComponents
		err := component.AssignProperties_From_IstioComponents(source.Components)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_IstioComponents() to populate field Components")
		}
		mesh.Components = &component
	} else {
		mesh.Components = nil
	}

	// Revisions
	if len(source.Revisions) > 0 {
		propertyBag.Add("Revisions", source.Revisions)
	} else {
		propertyBag.Remove("Revisions")
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		mesh.PropertyBag = propertyBag
	} else {
		mesh.PropertyBag = nil
	}

	// Invoke the augmentConversionForIstioServiceMesh interface (if implemented) to customize the conversion
	var meshAsAny any = mesh
	if augmentedMesh, ok := meshAsAny.(augmentConversionForIstioServiceMesh); ok {
		err := augmentedMesh.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_IstioServiceMesh populates the provided destination IstioServiceMesh from our IstioServiceMesh
func (mesh *IstioServiceMesh) AssignProperties_To_IstioServiceMesh(destination *storage.IstioServiceMesh) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(mesh.PropertyBag)

	// CertificateAuthority
	if propertyBag.Contains("CertificateAuthority") {
		var certificateAuthority storage.IstioCertificateAuthority
		err := propertyBag.Pull("CertificateAuthority", &certificateAuthority)
		if err != nil {
			return errors.Wrap(err, "pulling 'CertificateAuthority' from propertyBag")
		}

		destination.CertificateAuthority = &certificateAuthority
	} else {
		destination.CertificateAuthority = nil
	}

	// Components
	if mesh.Components != nil {
		var component storage.IstioComponents
		err := mesh.Components.AssignProperties_To_IstioComponents(&component)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_IstioComponents() to populate field Components")
		}
		destination.Components = &component
	} else {
		destination.Components = nil
	}

	// Revisions
	if propertyBag.Contains("Revisions") {
		var revision []string
		err := propertyBag.Pull("Revisions", &revision)
		if err != nil {
			return errors.Wrap(err, "pulling 'Revisions' from propertyBag")
		}

		destination.Revisions = revision
	} else {
		destination.Revisions = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForIstioServiceMesh interface (if implemented) to customize the conversion
	var meshAsAny any = mesh
	if augmentedMesh, ok := meshAsAny.(augmentConversionForIstioServiceMesh); ok {
		err := augmentedMesh.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

type augmentConversionForIstioServiceMesh interface {
	AssignPropertiesFrom(src *storage.IstioServiceMesh) error
	AssignPropertiesTo(dst *storage.IstioServiceMesh) error
}

// Storage version of v1api20230202preview.IstioComponents
// Istio components configuration.
type IstioComponents struct {
	IngressGateways []IstioIngressGateway  `json:"ingressGateways,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_IstioComponents populates our IstioComponents from the provided source IstioComponents
func (components *IstioComponents) AssignProperties_From_IstioComponents(source *storage.IstioComponents) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// EgressGateways
	if len(source.EgressGateways) > 0 {
		propertyBag.Add("EgressGateways", source.EgressGateways)
	} else {
		propertyBag.Remove("EgressGateways")
	}

	// IngressGateways
	if source.IngressGateways != nil {
		ingressGatewayList := make([]IstioIngressGateway, len(source.IngressGateways))
		for ingressGatewayIndex, ingressGatewayItem := range source.IngressGateways {
			// Shadow the loop variable to avoid aliasing
			ingressGatewayItem := ingressGatewayItem
			var ingressGateway IstioIngressGateway
			err := ingressGateway.AssignProperties_From_IstioIngressGateway(&ingressGatewayItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_IstioIngressGateway() to populate field IngressGateways")
			}
			ingressGatewayList[ingressGatewayIndex] = ingressGateway
		}
		components.IngressGateways = ingressGatewayList
	} else {
		components.IngressGateways = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		components.PropertyBag = propertyBag
	} else {
		components.PropertyBag = nil
	}

	// Invoke the augmentConversionForIstioComponents interface (if implemented) to customize the conversion
	var componentsAsAny any = components
	if augmentedComponents, ok := componentsAsAny.(augmentConversionForIstioComponents); ok {
		err := augmentedComponents.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_IstioComponents populates the provided destination IstioComponents from our IstioComponents
func (components *IstioComponents) AssignProperties_To_IstioComponents(destination *storage.IstioComponents) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(components.PropertyBag)

	// EgressGateways
	if propertyBag.Contains("EgressGateways") {
		var egressGateway []storage.IstioEgressGateway
		err := propertyBag.Pull("EgressGateways", &egressGateway)
		if err != nil {
			return errors.Wrap(err, "pulling 'EgressGateways' from propertyBag")
		}

		destination.EgressGateways = egressGateway
	} else {
		destination.EgressGateways = nil
	}

	// IngressGateways
	if components.IngressGateways != nil {
		ingressGatewayList := make([]storage.IstioIngressGateway, len(components.IngressGateways))
		for ingressGatewayIndex, ingressGatewayItem := range components.IngressGateways {
			// Shadow the loop variable to avoid aliasing
			ingressGatewayItem := ingressGatewayItem
			var ingressGateway storage.IstioIngressGateway
			err := ingressGatewayItem.AssignProperties_To_IstioIngressGateway(&ingressGateway)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_IstioIngressGateway() to populate field IngressGateways")
			}
			ingressGatewayList[ingressGatewayIndex] = ingressGateway
		}
		destination.IngressGateways = ingressGatewayList
	} else {
		destination.IngressGateways = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForIstioComponents interface (if implemented) to customize the conversion
	var componentsAsAny any = components
	if augmentedComponents, ok := componentsAsAny.(augmentConversionForIstioComponents); ok {
		err := augmentedComponents.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

type augmentConversionForIstioComponents interface {
	AssignPropertiesFrom(src *storage.IstioComponents) error
	AssignPropertiesTo(dst *storage.IstioComponents) error
}

// Storage version of v1api20230202preview.IstioIngressGateway
// Istio ingress gateway configuration. For now, we support up to one external ingress gateway named
// `aks-istio-ingressgateway-external` and one internal ingress gateway named `aks-istio-ingressgateway-internal`.
type IstioIngressGateway struct {
	Enabled     *bool                  `json:"enabled,omitempty"`
	Mode        *string                `json:"mode,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_IstioIngressGateway populates our IstioIngressGateway from the provided source IstioIngressGateway
func (gateway *IstioIngressGateway) AssignProperties_From_IstioIngressGateway(source *storage.IstioIngressGateway) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		gateway.Enabled = &enabled
	} else {
		gateway.Enabled = nil
	}

	// Mode
	gateway.Mode = genruntime.ClonePointerToString(source.Mode)

	// Update the property bag
	if len(propertyBag) > 0 {
		gateway.PropertyBag = propertyBag
	} else {
		gateway.PropertyBag = nil
	}

	// Invoke the augmentConversionForIstioIngressGateway interface (if implemented) to customize the conversion
	var gatewayAsAny any = gateway
	if augmentedGateway, ok := gatewayAsAny.(augmentConversionForIstioIngressGateway); ok {
		err := augmentedGateway.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_IstioIngressGateway populates the provided destination IstioIngressGateway from our IstioIngressGateway
func (gateway *IstioIngressGateway) AssignProperties_To_IstioIngressGateway(destination *storage.IstioIngressGateway) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(gateway.PropertyBag)

	// Enabled
	if gateway.Enabled != nil {
		enabled := *gateway.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Mode
	destination.Mode = genruntime.ClonePointerToString(gateway.Mode)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForIstioIngressGateway interface (if implemented) to customize the conversion
	var gatewayAsAny any = gateway
	if augmentedGateway, ok := gatewayAsAny.(augmentConversionForIstioIngressGateway); ok {
		err := augmentedGateway.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

type augmentConversionForIstioIngressGateway interface {
	AssignPropertiesFrom(src *storage.IstioIngressGateway) error
	AssignPropertiesTo(dst *storage.IstioIngressGateway) error
}
