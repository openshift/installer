// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package storage

import (
	"fmt"
	v20220701s "github.com/Azure/azure-service-operator/v2/api/network/v1api20220701/storage"
	v20240101s "github.com/Azure/azure-service-operator/v2/api/network/v1api20240101/storage"
	v20240301s "github.com/Azure/azure-service-operator/v2/api/network/v1api20240301/storage"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/configmaps"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/core"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/secrets"
	"github.com/pkg/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
)

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Storage version of v1api20201101.LoadBalancer
// Generator information:
// - Generated from: /network/resource-manager/Microsoft.Network/stable/2020-11-01/loadBalancer.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/loadBalancers/{loadBalancerName}
type LoadBalancer struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              LoadBalancer_Spec   `json:"spec,omitempty"`
	Status            LoadBalancer_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &LoadBalancer{}

// GetConditions returns the conditions of the resource
func (balancer *LoadBalancer) GetConditions() conditions.Conditions {
	return balancer.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (balancer *LoadBalancer) SetConditions(conditions conditions.Conditions) {
	balancer.Status.Conditions = conditions
}

var _ conversion.Convertible = &LoadBalancer{}

// ConvertFrom populates our LoadBalancer from the provided hub LoadBalancer
func (balancer *LoadBalancer) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*v20240301s.LoadBalancer)
	if !ok {
		return fmt.Errorf("expected network/v1api20240301/storage/LoadBalancer but received %T instead", hub)
	}

	return balancer.AssignProperties_From_LoadBalancer(source)
}

// ConvertTo populates the provided hub LoadBalancer from our LoadBalancer
func (balancer *LoadBalancer) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*v20240301s.LoadBalancer)
	if !ok {
		return fmt.Errorf("expected network/v1api20240301/storage/LoadBalancer but received %T instead", hub)
	}

	return balancer.AssignProperties_To_LoadBalancer(destination)
}

var _ configmaps.Exporter = &LoadBalancer{}

// ConfigMapDestinationExpressions returns the Spec.OperatorSpec.ConfigMapExpressions property
func (balancer *LoadBalancer) ConfigMapDestinationExpressions() []*core.DestinationExpression {
	if balancer.Spec.OperatorSpec == nil {
		return nil
	}
	return balancer.Spec.OperatorSpec.ConfigMapExpressions
}

var _ secrets.Exporter = &LoadBalancer{}

// SecretDestinationExpressions returns the Spec.OperatorSpec.SecretExpressions property
func (balancer *LoadBalancer) SecretDestinationExpressions() []*core.DestinationExpression {
	if balancer.Spec.OperatorSpec == nil {
		return nil
	}
	return balancer.Spec.OperatorSpec.SecretExpressions
}

var _ genruntime.KubernetesResource = &LoadBalancer{}

// AzureName returns the Azure name of the resource
func (balancer *LoadBalancer) AzureName() string {
	return balancer.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2020-11-01"
func (balancer LoadBalancer) GetAPIVersion() string {
	return "2020-11-01"
}

// GetResourceScope returns the scope of the resource
func (balancer *LoadBalancer) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (balancer *LoadBalancer) GetSpec() genruntime.ConvertibleSpec {
	return &balancer.Spec
}

// GetStatus returns the status of this resource
func (balancer *LoadBalancer) GetStatus() genruntime.ConvertibleStatus {
	return &balancer.Status
}

// GetSupportedOperations returns the operations supported by the resource
func (balancer *LoadBalancer) GetSupportedOperations() []genruntime.ResourceOperation {
	return []genruntime.ResourceOperation{
		genruntime.ResourceOperationDelete,
		genruntime.ResourceOperationGet,
		genruntime.ResourceOperationPut,
	}
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.Network/loadBalancers"
func (balancer *LoadBalancer) GetType() string {
	return "Microsoft.Network/loadBalancers"
}

// NewEmptyStatus returns a new empty (blank) status
func (balancer *LoadBalancer) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &LoadBalancer_STATUS{}
}

// Owner returns the ResourceReference of the owner
func (balancer *LoadBalancer) Owner() *genruntime.ResourceReference {
	group, kind := genruntime.LookupOwnerGroupKind(balancer.Spec)
	return balancer.Spec.Owner.AsResourceReference(group, kind)
}

// SetStatus sets the status of this resource
func (balancer *LoadBalancer) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*LoadBalancer_STATUS); ok {
		balancer.Status = *st
		return nil
	}

	// Convert status to required version
	var st LoadBalancer_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return errors.Wrap(err, "failed to convert status")
	}

	balancer.Status = st
	return nil
}

// AssignProperties_From_LoadBalancer populates our LoadBalancer from the provided source LoadBalancer
func (balancer *LoadBalancer) AssignProperties_From_LoadBalancer(source *v20240301s.LoadBalancer) error {

	// ObjectMeta
	balancer.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec LoadBalancer_Spec
	err := spec.AssignProperties_From_LoadBalancer_Spec(&source.Spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_LoadBalancer_Spec() to populate field Spec")
	}
	balancer.Spec = spec

	// Status
	var status LoadBalancer_STATUS
	err = status.AssignProperties_From_LoadBalancer_STATUS(&source.Status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_LoadBalancer_STATUS() to populate field Status")
	}
	balancer.Status = status

	// Invoke the augmentConversionForLoadBalancer interface (if implemented) to customize the conversion
	var balancerAsAny any = balancer
	if augmentedBalancer, ok := balancerAsAny.(augmentConversionForLoadBalancer); ok {
		err := augmentedBalancer.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_LoadBalancer populates the provided destination LoadBalancer from our LoadBalancer
func (balancer *LoadBalancer) AssignProperties_To_LoadBalancer(destination *v20240301s.LoadBalancer) error {

	// ObjectMeta
	destination.ObjectMeta = *balancer.ObjectMeta.DeepCopy()

	// Spec
	var spec v20240301s.LoadBalancer_Spec
	err := balancer.Spec.AssignProperties_To_LoadBalancer_Spec(&spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_LoadBalancer_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status v20240301s.LoadBalancer_STATUS
	err = balancer.Status.AssignProperties_To_LoadBalancer_STATUS(&status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_LoadBalancer_STATUS() to populate field Status")
	}
	destination.Status = status

	// Invoke the augmentConversionForLoadBalancer interface (if implemented) to customize the conversion
	var balancerAsAny any = balancer
	if augmentedBalancer, ok := balancerAsAny.(augmentConversionForLoadBalancer); ok {
		err := augmentedBalancer.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (balancer *LoadBalancer) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: balancer.Spec.OriginalVersion,
		Kind:    "LoadBalancer",
	}
}

// +kubebuilder:object:root=true
// Storage version of v1api20201101.LoadBalancer
// Generator information:
// - Generated from: /network/resource-manager/Microsoft.Network/stable/2020-11-01/loadBalancer.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/loadBalancers/{loadBalancerName}
type LoadBalancerList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []LoadBalancer `json:"items"`
}

// Storage version of v1api20201101.APIVersion
// +kubebuilder:validation:Enum={"2020-11-01"}
type APIVersion string

const APIVersion_Value = APIVersion("2020-11-01")

type augmentConversionForLoadBalancer interface {
	AssignPropertiesFrom(src *v20240301s.LoadBalancer) error
	AssignPropertiesTo(dst *v20240301s.LoadBalancer) error
}

// Storage version of v1api20201101.LoadBalancer_Spec
type LoadBalancer_Spec struct {
	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName                string                                                     `json:"azureName,omitempty"`
	BackendAddressPools      []BackendAddressPool_LoadBalancer_SubResourceEmbedded      `json:"backendAddressPools,omitempty"`
	ExtendedLocation         *ExtendedLocation                                          `json:"extendedLocation,omitempty"`
	FrontendIPConfigurations []FrontendIPConfiguration_LoadBalancer_SubResourceEmbedded `json:"frontendIPConfigurations,omitempty"`
	InboundNatPools          []InboundNatPool                                           `json:"inboundNatPools,omitempty"`
	InboundNatRules          []InboundNatRule_LoadBalancer_SubResourceEmbedded          `json:"inboundNatRules,omitempty"`
	LoadBalancingRules       []LoadBalancingRule                                        `json:"loadBalancingRules,omitempty"`
	Location                 *string                                                    `json:"location,omitempty"`
	OperatorSpec             *LoadBalancerOperatorSpec                                  `json:"operatorSpec,omitempty"`
	OriginalVersion          string                                                     `json:"originalVersion,omitempty"`
	OutboundRules            []OutboundRule                                             `json:"outboundRules,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a resources.azure.com/ResourceGroup resource
	Owner       *genruntime.KnownResourceReference `group:"resources.azure.com" json:"owner,omitempty" kind:"ResourceGroup"`
	Probes      []Probe                            `json:"probes,omitempty"`
	PropertyBag genruntime.PropertyBag             `json:"$propertyBag,omitempty"`
	Sku         *LoadBalancerSku                   `json:"sku,omitempty"`
	Tags        map[string]string                  `json:"tags,omitempty"`
}

var _ genruntime.ConvertibleSpec = &LoadBalancer_Spec{}

// ConvertSpecFrom populates our LoadBalancer_Spec from the provided source
func (balancer *LoadBalancer_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*v20240301s.LoadBalancer_Spec)
	if ok {
		// Populate our instance from source
		return balancer.AssignProperties_From_LoadBalancer_Spec(src)
	}

	// Convert to an intermediate form
	src = &v20240301s.LoadBalancer_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = balancer.AssignProperties_From_LoadBalancer_Spec(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our LoadBalancer_Spec
func (balancer *LoadBalancer_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*v20240301s.LoadBalancer_Spec)
	if ok {
		// Populate destination from our instance
		return balancer.AssignProperties_To_LoadBalancer_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &v20240301s.LoadBalancer_Spec{}
	err := balancer.AssignProperties_To_LoadBalancer_Spec(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignProperties_From_LoadBalancer_Spec populates our LoadBalancer_Spec from the provided source LoadBalancer_Spec
func (balancer *LoadBalancer_Spec) AssignProperties_From_LoadBalancer_Spec(source *v20240301s.LoadBalancer_Spec) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AzureName
	balancer.AzureName = source.AzureName

	// BackendAddressPools
	if source.BackendAddressPools != nil {
		backendAddressPoolList := make([]BackendAddressPool_LoadBalancer_SubResourceEmbedded, len(source.BackendAddressPools))
		for backendAddressPoolIndex, backendAddressPoolItem := range source.BackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			backendAddressPoolItem := backendAddressPoolItem
			var backendAddressPool BackendAddressPool_LoadBalancer_SubResourceEmbedded
			err := backendAddressPool.AssignProperties_From_BackendAddressPool_LoadBalancer_SubResourceEmbedded(&backendAddressPoolItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_BackendAddressPool_LoadBalancer_SubResourceEmbedded() to populate field BackendAddressPools")
			}
			backendAddressPoolList[backendAddressPoolIndex] = backendAddressPool
		}
		balancer.BackendAddressPools = backendAddressPoolList
	} else {
		balancer.BackendAddressPools = nil
	}

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocationStash v20220701s.ExtendedLocation
		err := extendedLocationStash.AssignProperties_From_ExtendedLocation(source.ExtendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ExtendedLocation() to populate field ExtendedLocationStash from ExtendedLocation")
		}
		var extendedLocation ExtendedLocation
		err = extendedLocation.AssignProperties_From_ExtendedLocation(&extendedLocationStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ExtendedLocation() to populate field ExtendedLocation from ExtendedLocationStash")
		}
		balancer.ExtendedLocation = &extendedLocation
	} else {
		balancer.ExtendedLocation = nil
	}

	// FrontendIPConfigurations
	if source.FrontendIPConfigurations != nil {
		frontendIPConfigurationList := make([]FrontendIPConfiguration_LoadBalancer_SubResourceEmbedded, len(source.FrontendIPConfigurations))
		for frontendIPConfigurationIndex, frontendIPConfigurationItem := range source.FrontendIPConfigurations {
			// Shadow the loop variable to avoid aliasing
			frontendIPConfigurationItem := frontendIPConfigurationItem
			var frontendIPConfiguration FrontendIPConfiguration_LoadBalancer_SubResourceEmbedded
			err := frontendIPConfiguration.AssignProperties_From_FrontendIPConfiguration_LoadBalancer_SubResourceEmbedded(&frontendIPConfigurationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_FrontendIPConfiguration_LoadBalancer_SubResourceEmbedded() to populate field FrontendIPConfigurations")
			}
			frontendIPConfigurationList[frontendIPConfigurationIndex] = frontendIPConfiguration
		}
		balancer.FrontendIPConfigurations = frontendIPConfigurationList
	} else {
		balancer.FrontendIPConfigurations = nil
	}

	// InboundNatPools
	if source.InboundNatPools != nil {
		inboundNatPoolList := make([]InboundNatPool, len(source.InboundNatPools))
		for inboundNatPoolIndex, inboundNatPoolItem := range source.InboundNatPools {
			// Shadow the loop variable to avoid aliasing
			inboundNatPoolItem := inboundNatPoolItem
			var inboundNatPool InboundNatPool
			err := inboundNatPool.AssignProperties_From_InboundNatPool(&inboundNatPoolItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_InboundNatPool() to populate field InboundNatPools")
			}
			inboundNatPoolList[inboundNatPoolIndex] = inboundNatPool
		}
		balancer.InboundNatPools = inboundNatPoolList
	} else {
		balancer.InboundNatPools = nil
	}

	// InboundNatRules
	if source.InboundNatRules != nil {
		inboundNatRuleList := make([]InboundNatRule_LoadBalancer_SubResourceEmbedded, len(source.InboundNatRules))
		for inboundNatRuleIndex, inboundNatRuleItem := range source.InboundNatRules {
			// Shadow the loop variable to avoid aliasing
			inboundNatRuleItem := inboundNatRuleItem
			var inboundNatRule InboundNatRule_LoadBalancer_SubResourceEmbedded
			err := inboundNatRule.AssignProperties_From_InboundNatRule_LoadBalancer_SubResourceEmbedded(&inboundNatRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_InboundNatRule_LoadBalancer_SubResourceEmbedded() to populate field InboundNatRules")
			}
			inboundNatRuleList[inboundNatRuleIndex] = inboundNatRule
		}
		balancer.InboundNatRules = inboundNatRuleList
	} else {
		balancer.InboundNatRules = nil
	}

	// LoadBalancingRules
	if source.LoadBalancingRules != nil {
		loadBalancingRuleList := make([]LoadBalancingRule, len(source.LoadBalancingRules))
		for loadBalancingRuleIndex, loadBalancingRuleItem := range source.LoadBalancingRules {
			// Shadow the loop variable to avoid aliasing
			loadBalancingRuleItem := loadBalancingRuleItem
			var loadBalancingRule LoadBalancingRule
			err := loadBalancingRule.AssignProperties_From_LoadBalancingRule(&loadBalancingRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_LoadBalancingRule() to populate field LoadBalancingRules")
			}
			loadBalancingRuleList[loadBalancingRuleIndex] = loadBalancingRule
		}
		balancer.LoadBalancingRules = loadBalancingRuleList
	} else {
		balancer.LoadBalancingRules = nil
	}

	// Location
	balancer.Location = genruntime.ClonePointerToString(source.Location)

	// OperatorSpec
	if source.OperatorSpec != nil {
		var operatorSpec LoadBalancerOperatorSpec
		err := operatorSpec.AssignProperties_From_LoadBalancerOperatorSpec(source.OperatorSpec)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_LoadBalancerOperatorSpec() to populate field OperatorSpec")
		}
		balancer.OperatorSpec = &operatorSpec
	} else {
		balancer.OperatorSpec = nil
	}

	// OriginalVersion
	balancer.OriginalVersion = source.OriginalVersion

	// OutboundRules
	if source.OutboundRules != nil {
		outboundRuleList := make([]OutboundRule, len(source.OutboundRules))
		for outboundRuleIndex, outboundRuleItem := range source.OutboundRules {
			// Shadow the loop variable to avoid aliasing
			outboundRuleItem := outboundRuleItem
			var outboundRule OutboundRule
			err := outboundRule.AssignProperties_From_OutboundRule(&outboundRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_OutboundRule() to populate field OutboundRules")
			}
			outboundRuleList[outboundRuleIndex] = outboundRule
		}
		balancer.OutboundRules = outboundRuleList
	} else {
		balancer.OutboundRules = nil
	}

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		balancer.Owner = &owner
	} else {
		balancer.Owner = nil
	}

	// Probes
	if source.Probes != nil {
		probeList := make([]Probe, len(source.Probes))
		for probeIndex, probeItem := range source.Probes {
			// Shadow the loop variable to avoid aliasing
			probeItem := probeItem
			var probe Probe
			err := probe.AssignProperties_From_Probe(&probeItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_Probe() to populate field Probes")
			}
			probeList[probeIndex] = probe
		}
		balancer.Probes = probeList
	} else {
		balancer.Probes = nil
	}

	// Sku
	if source.Sku != nil {
		var sku LoadBalancerSku
		err := sku.AssignProperties_From_LoadBalancerSku(source.Sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_LoadBalancerSku() to populate field Sku")
		}
		balancer.Sku = &sku
	} else {
		balancer.Sku = nil
	}

	// Tags
	balancer.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Update the property bag
	if len(propertyBag) > 0 {
		balancer.PropertyBag = propertyBag
	} else {
		balancer.PropertyBag = nil
	}

	// Invoke the augmentConversionForLoadBalancer_Spec interface (if implemented) to customize the conversion
	var balancerAsAny any = balancer
	if augmentedBalancer, ok := balancerAsAny.(augmentConversionForLoadBalancer_Spec); ok {
		err := augmentedBalancer.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_LoadBalancer_Spec populates the provided destination LoadBalancer_Spec from our LoadBalancer_Spec
func (balancer *LoadBalancer_Spec) AssignProperties_To_LoadBalancer_Spec(destination *v20240301s.LoadBalancer_Spec) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(balancer.PropertyBag)

	// AzureName
	destination.AzureName = balancer.AzureName

	// BackendAddressPools
	if balancer.BackendAddressPools != nil {
		backendAddressPoolList := make([]v20240301s.BackendAddressPool_LoadBalancer_SubResourceEmbedded, len(balancer.BackendAddressPools))
		for backendAddressPoolIndex, backendAddressPoolItem := range balancer.BackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			backendAddressPoolItem := backendAddressPoolItem
			var backendAddressPool v20240301s.BackendAddressPool_LoadBalancer_SubResourceEmbedded
			err := backendAddressPoolItem.AssignProperties_To_BackendAddressPool_LoadBalancer_SubResourceEmbedded(&backendAddressPool)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_BackendAddressPool_LoadBalancer_SubResourceEmbedded() to populate field BackendAddressPools")
			}
			backendAddressPoolList[backendAddressPoolIndex] = backendAddressPool
		}
		destination.BackendAddressPools = backendAddressPoolList
	} else {
		destination.BackendAddressPools = nil
	}

	// ExtendedLocation
	if balancer.ExtendedLocation != nil {
		var extendedLocationStash v20220701s.ExtendedLocation
		err := balancer.ExtendedLocation.AssignProperties_To_ExtendedLocation(&extendedLocationStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ExtendedLocation() to populate field ExtendedLocationStash from ExtendedLocation")
		}
		var extendedLocation v20240301s.ExtendedLocation
		err = extendedLocationStash.AssignProperties_To_ExtendedLocation(&extendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ExtendedLocation() to populate field ExtendedLocation from ExtendedLocationStash")
		}
		destination.ExtendedLocation = &extendedLocation
	} else {
		destination.ExtendedLocation = nil
	}

	// FrontendIPConfigurations
	if balancer.FrontendIPConfigurations != nil {
		frontendIPConfigurationList := make([]v20240301s.FrontendIPConfiguration_LoadBalancer_SubResourceEmbedded, len(balancer.FrontendIPConfigurations))
		for frontendIPConfigurationIndex, frontendIPConfigurationItem := range balancer.FrontendIPConfigurations {
			// Shadow the loop variable to avoid aliasing
			frontendIPConfigurationItem := frontendIPConfigurationItem
			var frontendIPConfiguration v20240301s.FrontendIPConfiguration_LoadBalancer_SubResourceEmbedded
			err := frontendIPConfigurationItem.AssignProperties_To_FrontendIPConfiguration_LoadBalancer_SubResourceEmbedded(&frontendIPConfiguration)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_FrontendIPConfiguration_LoadBalancer_SubResourceEmbedded() to populate field FrontendIPConfigurations")
			}
			frontendIPConfigurationList[frontendIPConfigurationIndex] = frontendIPConfiguration
		}
		destination.FrontendIPConfigurations = frontendIPConfigurationList
	} else {
		destination.FrontendIPConfigurations = nil
	}

	// InboundNatPools
	if balancer.InboundNatPools != nil {
		inboundNatPoolList := make([]v20240301s.InboundNatPool, len(balancer.InboundNatPools))
		for inboundNatPoolIndex, inboundNatPoolItem := range balancer.InboundNatPools {
			// Shadow the loop variable to avoid aliasing
			inboundNatPoolItem := inboundNatPoolItem
			var inboundNatPool v20240301s.InboundNatPool
			err := inboundNatPoolItem.AssignProperties_To_InboundNatPool(&inboundNatPool)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_InboundNatPool() to populate field InboundNatPools")
			}
			inboundNatPoolList[inboundNatPoolIndex] = inboundNatPool
		}
		destination.InboundNatPools = inboundNatPoolList
	} else {
		destination.InboundNatPools = nil
	}

	// InboundNatRules
	if balancer.InboundNatRules != nil {
		inboundNatRuleList := make([]v20240301s.InboundNatRule_LoadBalancer_SubResourceEmbedded, len(balancer.InboundNatRules))
		for inboundNatRuleIndex, inboundNatRuleItem := range balancer.InboundNatRules {
			// Shadow the loop variable to avoid aliasing
			inboundNatRuleItem := inboundNatRuleItem
			var inboundNatRule v20240301s.InboundNatRule_LoadBalancer_SubResourceEmbedded
			err := inboundNatRuleItem.AssignProperties_To_InboundNatRule_LoadBalancer_SubResourceEmbedded(&inboundNatRule)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_InboundNatRule_LoadBalancer_SubResourceEmbedded() to populate field InboundNatRules")
			}
			inboundNatRuleList[inboundNatRuleIndex] = inboundNatRule
		}
		destination.InboundNatRules = inboundNatRuleList
	} else {
		destination.InboundNatRules = nil
	}

	// LoadBalancingRules
	if balancer.LoadBalancingRules != nil {
		loadBalancingRuleList := make([]v20240301s.LoadBalancingRule, len(balancer.LoadBalancingRules))
		for loadBalancingRuleIndex, loadBalancingRuleItem := range balancer.LoadBalancingRules {
			// Shadow the loop variable to avoid aliasing
			loadBalancingRuleItem := loadBalancingRuleItem
			var loadBalancingRule v20240301s.LoadBalancingRule
			err := loadBalancingRuleItem.AssignProperties_To_LoadBalancingRule(&loadBalancingRule)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_LoadBalancingRule() to populate field LoadBalancingRules")
			}
			loadBalancingRuleList[loadBalancingRuleIndex] = loadBalancingRule
		}
		destination.LoadBalancingRules = loadBalancingRuleList
	} else {
		destination.LoadBalancingRules = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(balancer.Location)

	// OperatorSpec
	if balancer.OperatorSpec != nil {
		var operatorSpec v20240301s.LoadBalancerOperatorSpec
		err := balancer.OperatorSpec.AssignProperties_To_LoadBalancerOperatorSpec(&operatorSpec)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_LoadBalancerOperatorSpec() to populate field OperatorSpec")
		}
		destination.OperatorSpec = &operatorSpec
	} else {
		destination.OperatorSpec = nil
	}

	// OriginalVersion
	destination.OriginalVersion = balancer.OriginalVersion

	// OutboundRules
	if balancer.OutboundRules != nil {
		outboundRuleList := make([]v20240301s.OutboundRule, len(balancer.OutboundRules))
		for outboundRuleIndex, outboundRuleItem := range balancer.OutboundRules {
			// Shadow the loop variable to avoid aliasing
			outboundRuleItem := outboundRuleItem
			var outboundRule v20240301s.OutboundRule
			err := outboundRuleItem.AssignProperties_To_OutboundRule(&outboundRule)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_OutboundRule() to populate field OutboundRules")
			}
			outboundRuleList[outboundRuleIndex] = outboundRule
		}
		destination.OutboundRules = outboundRuleList
	} else {
		destination.OutboundRules = nil
	}

	// Owner
	if balancer.Owner != nil {
		owner := balancer.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// Probes
	if balancer.Probes != nil {
		probeList := make([]v20240301s.Probe, len(balancer.Probes))
		for probeIndex, probeItem := range balancer.Probes {
			// Shadow the loop variable to avoid aliasing
			probeItem := probeItem
			var probe v20240301s.Probe
			err := probeItem.AssignProperties_To_Probe(&probe)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_Probe() to populate field Probes")
			}
			probeList[probeIndex] = probe
		}
		destination.Probes = probeList
	} else {
		destination.Probes = nil
	}

	// Sku
	if balancer.Sku != nil {
		var sku v20240301s.LoadBalancerSku
		err := balancer.Sku.AssignProperties_To_LoadBalancerSku(&sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_LoadBalancerSku() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(balancer.Tags)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForLoadBalancer_Spec interface (if implemented) to customize the conversion
	var balancerAsAny any = balancer
	if augmentedBalancer, ok := balancerAsAny.(augmentConversionForLoadBalancer_Spec); ok {
		err := augmentedBalancer.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201101.LoadBalancer_STATUS
// LoadBalancer resource.
type LoadBalancer_STATUS struct {
	BackendAddressPools      []BackendAddressPool_STATUS_LoadBalancer_SubResourceEmbedded      `json:"backendAddressPools,omitempty"`
	Conditions               []conditions.Condition                                            `json:"conditions,omitempty"`
	Etag                     *string                                                           `json:"etag,omitempty"`
	ExtendedLocation         *ExtendedLocation_STATUS                                          `json:"extendedLocation,omitempty"`
	FrontendIPConfigurations []FrontendIPConfiguration_STATUS_LoadBalancer_SubResourceEmbedded `json:"frontendIPConfigurations,omitempty"`
	Id                       *string                                                           `json:"id,omitempty"`
	InboundNatPools          []InboundNatPool_STATUS                                           `json:"inboundNatPools,omitempty"`
	InboundNatRules          []InboundNatRule_STATUS_LoadBalancer_SubResourceEmbedded          `json:"inboundNatRules,omitempty"`
	LoadBalancingRules       []LoadBalancingRule_STATUS                                        `json:"loadBalancingRules,omitempty"`
	Location                 *string                                                           `json:"location,omitempty"`
	Name                     *string                                                           `json:"name,omitempty"`
	OutboundRules            []OutboundRule_STATUS                                             `json:"outboundRules,omitempty"`
	Probes                   []Probe_STATUS                                                    `json:"probes,omitempty"`
	PropertyBag              genruntime.PropertyBag                                            `json:"$propertyBag,omitempty"`
	ProvisioningState        *string                                                           `json:"provisioningState,omitempty"`
	ResourceGuid             *string                                                           `json:"resourceGuid,omitempty"`
	Sku                      *LoadBalancerSku_STATUS                                           `json:"sku,omitempty"`
	Tags                     map[string]string                                                 `json:"tags,omitempty"`
	Type                     *string                                                           `json:"type,omitempty"`
}

var _ genruntime.ConvertibleStatus = &LoadBalancer_STATUS{}

// ConvertStatusFrom populates our LoadBalancer_STATUS from the provided source
func (balancer *LoadBalancer_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*v20240301s.LoadBalancer_STATUS)
	if ok {
		// Populate our instance from source
		return balancer.AssignProperties_From_LoadBalancer_STATUS(src)
	}

	// Convert to an intermediate form
	src = &v20240301s.LoadBalancer_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = balancer.AssignProperties_From_LoadBalancer_STATUS(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our LoadBalancer_STATUS
func (balancer *LoadBalancer_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*v20240301s.LoadBalancer_STATUS)
	if ok {
		// Populate destination from our instance
		return balancer.AssignProperties_To_LoadBalancer_STATUS(dst)
	}

	// Convert to an intermediate form
	dst = &v20240301s.LoadBalancer_STATUS{}
	err := balancer.AssignProperties_To_LoadBalancer_STATUS(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

// AssignProperties_From_LoadBalancer_STATUS populates our LoadBalancer_STATUS from the provided source LoadBalancer_STATUS
func (balancer *LoadBalancer_STATUS) AssignProperties_From_LoadBalancer_STATUS(source *v20240301s.LoadBalancer_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// BackendAddressPools
	if source.BackendAddressPools != nil {
		backendAddressPoolList := make([]BackendAddressPool_STATUS_LoadBalancer_SubResourceEmbedded, len(source.BackendAddressPools))
		for backendAddressPoolIndex, backendAddressPoolItem := range source.BackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			backendAddressPoolItem := backendAddressPoolItem
			var backendAddressPool BackendAddressPool_STATUS_LoadBalancer_SubResourceEmbedded
			err := backendAddressPool.AssignProperties_From_BackendAddressPool_STATUS_LoadBalancer_SubResourceEmbedded(&backendAddressPoolItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_BackendAddressPool_STATUS_LoadBalancer_SubResourceEmbedded() to populate field BackendAddressPools")
			}
			backendAddressPoolList[backendAddressPoolIndex] = backendAddressPool
		}
		balancer.BackendAddressPools = backendAddressPoolList
	} else {
		balancer.BackendAddressPools = nil
	}

	// Conditions
	balancer.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// Etag
	balancer.Etag = genruntime.ClonePointerToString(source.Etag)

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocationSTATUSStash v20220701s.ExtendedLocation_STATUS
		err := extendedLocationSTATUSStash.AssignProperties_From_ExtendedLocation_STATUS(source.ExtendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ExtendedLocation_STATUS() to populate field ExtendedLocation_STATUSStash from ExtendedLocation")
		}
		var extendedLocation ExtendedLocation_STATUS
		err = extendedLocation.AssignProperties_From_ExtendedLocation_STATUS(&extendedLocationSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ExtendedLocation_STATUS() to populate field ExtendedLocation from ExtendedLocation_STATUSStash")
		}
		balancer.ExtendedLocation = &extendedLocation
	} else {
		balancer.ExtendedLocation = nil
	}

	// FrontendIPConfigurations
	if source.FrontendIPConfigurations != nil {
		frontendIPConfigurationList := make([]FrontendIPConfiguration_STATUS_LoadBalancer_SubResourceEmbedded, len(source.FrontendIPConfigurations))
		for frontendIPConfigurationIndex, frontendIPConfigurationItem := range source.FrontendIPConfigurations {
			// Shadow the loop variable to avoid aliasing
			frontendIPConfigurationItem := frontendIPConfigurationItem
			var frontendIPConfiguration FrontendIPConfiguration_STATUS_LoadBalancer_SubResourceEmbedded
			err := frontendIPConfiguration.AssignProperties_From_FrontendIPConfiguration_STATUS_LoadBalancer_SubResourceEmbedded(&frontendIPConfigurationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_FrontendIPConfiguration_STATUS_LoadBalancer_SubResourceEmbedded() to populate field FrontendIPConfigurations")
			}
			frontendIPConfigurationList[frontendIPConfigurationIndex] = frontendIPConfiguration
		}
		balancer.FrontendIPConfigurations = frontendIPConfigurationList
	} else {
		balancer.FrontendIPConfigurations = nil
	}

	// Id
	balancer.Id = genruntime.ClonePointerToString(source.Id)

	// InboundNatPools
	if source.InboundNatPools != nil {
		inboundNatPoolList := make([]InboundNatPool_STATUS, len(source.InboundNatPools))
		for inboundNatPoolIndex, inboundNatPoolItem := range source.InboundNatPools {
			// Shadow the loop variable to avoid aliasing
			inboundNatPoolItem := inboundNatPoolItem
			var inboundNatPool InboundNatPool_STATUS
			err := inboundNatPool.AssignProperties_From_InboundNatPool_STATUS(&inboundNatPoolItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_InboundNatPool_STATUS() to populate field InboundNatPools")
			}
			inboundNatPoolList[inboundNatPoolIndex] = inboundNatPool
		}
		balancer.InboundNatPools = inboundNatPoolList
	} else {
		balancer.InboundNatPools = nil
	}

	// InboundNatRules
	if source.InboundNatRules != nil {
		inboundNatRuleList := make([]InboundNatRule_STATUS_LoadBalancer_SubResourceEmbedded, len(source.InboundNatRules))
		for inboundNatRuleIndex, inboundNatRuleItem := range source.InboundNatRules {
			// Shadow the loop variable to avoid aliasing
			inboundNatRuleItem := inboundNatRuleItem
			var inboundNatRule InboundNatRule_STATUS_LoadBalancer_SubResourceEmbedded
			err := inboundNatRule.AssignProperties_From_InboundNatRule_STATUS_LoadBalancer_SubResourceEmbedded(&inboundNatRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_InboundNatRule_STATUS_LoadBalancer_SubResourceEmbedded() to populate field InboundNatRules")
			}
			inboundNatRuleList[inboundNatRuleIndex] = inboundNatRule
		}
		balancer.InboundNatRules = inboundNatRuleList
	} else {
		balancer.InboundNatRules = nil
	}

	// LoadBalancingRules
	if source.LoadBalancingRules != nil {
		loadBalancingRuleList := make([]LoadBalancingRule_STATUS, len(source.LoadBalancingRules))
		for loadBalancingRuleIndex, loadBalancingRuleItem := range source.LoadBalancingRules {
			// Shadow the loop variable to avoid aliasing
			loadBalancingRuleItem := loadBalancingRuleItem
			var loadBalancingRule LoadBalancingRule_STATUS
			err := loadBalancingRule.AssignProperties_From_LoadBalancingRule_STATUS(&loadBalancingRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_LoadBalancingRule_STATUS() to populate field LoadBalancingRules")
			}
			loadBalancingRuleList[loadBalancingRuleIndex] = loadBalancingRule
		}
		balancer.LoadBalancingRules = loadBalancingRuleList
	} else {
		balancer.LoadBalancingRules = nil
	}

	// Location
	balancer.Location = genruntime.ClonePointerToString(source.Location)

	// Name
	balancer.Name = genruntime.ClonePointerToString(source.Name)

	// OutboundRules
	if source.OutboundRules != nil {
		outboundRuleList := make([]OutboundRule_STATUS, len(source.OutboundRules))
		for outboundRuleIndex, outboundRuleItem := range source.OutboundRules {
			// Shadow the loop variable to avoid aliasing
			outboundRuleItem := outboundRuleItem
			var outboundRule OutboundRule_STATUS
			err := outboundRule.AssignProperties_From_OutboundRule_STATUS(&outboundRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_OutboundRule_STATUS() to populate field OutboundRules")
			}
			outboundRuleList[outboundRuleIndex] = outboundRule
		}
		balancer.OutboundRules = outboundRuleList
	} else {
		balancer.OutboundRules = nil
	}

	// Probes
	if source.Probes != nil {
		probeList := make([]Probe_STATUS, len(source.Probes))
		for probeIndex, probeItem := range source.Probes {
			// Shadow the loop variable to avoid aliasing
			probeItem := probeItem
			var probe Probe_STATUS
			err := probe.AssignProperties_From_Probe_STATUS(&probeItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_Probe_STATUS() to populate field Probes")
			}
			probeList[probeIndex] = probe
		}
		balancer.Probes = probeList
	} else {
		balancer.Probes = nil
	}

	// ProvisioningState
	balancer.ProvisioningState = genruntime.ClonePointerToString(source.ProvisioningState)

	// ResourceGuid
	balancer.ResourceGuid = genruntime.ClonePointerToString(source.ResourceGuid)

	// Sku
	if source.Sku != nil {
		var sku LoadBalancerSku_STATUS
		err := sku.AssignProperties_From_LoadBalancerSku_STATUS(source.Sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_LoadBalancerSku_STATUS() to populate field Sku")
		}
		balancer.Sku = &sku
	} else {
		balancer.Sku = nil
	}

	// Tags
	balancer.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Type
	balancer.Type = genruntime.ClonePointerToString(source.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		balancer.PropertyBag = propertyBag
	} else {
		balancer.PropertyBag = nil
	}

	// Invoke the augmentConversionForLoadBalancer_STATUS interface (if implemented) to customize the conversion
	var balancerAsAny any = balancer
	if augmentedBalancer, ok := balancerAsAny.(augmentConversionForLoadBalancer_STATUS); ok {
		err := augmentedBalancer.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_LoadBalancer_STATUS populates the provided destination LoadBalancer_STATUS from our LoadBalancer_STATUS
func (balancer *LoadBalancer_STATUS) AssignProperties_To_LoadBalancer_STATUS(destination *v20240301s.LoadBalancer_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(balancer.PropertyBag)

	// BackendAddressPools
	if balancer.BackendAddressPools != nil {
		backendAddressPoolList := make([]v20240301s.BackendAddressPool_STATUS_LoadBalancer_SubResourceEmbedded, len(balancer.BackendAddressPools))
		for backendAddressPoolIndex, backendAddressPoolItem := range balancer.BackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			backendAddressPoolItem := backendAddressPoolItem
			var backendAddressPool v20240301s.BackendAddressPool_STATUS_LoadBalancer_SubResourceEmbedded
			err := backendAddressPoolItem.AssignProperties_To_BackendAddressPool_STATUS_LoadBalancer_SubResourceEmbedded(&backendAddressPool)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_BackendAddressPool_STATUS_LoadBalancer_SubResourceEmbedded() to populate field BackendAddressPools")
			}
			backendAddressPoolList[backendAddressPoolIndex] = backendAddressPool
		}
		destination.BackendAddressPools = backendAddressPoolList
	} else {
		destination.BackendAddressPools = nil
	}

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(balancer.Conditions)

	// Etag
	destination.Etag = genruntime.ClonePointerToString(balancer.Etag)

	// ExtendedLocation
	if balancer.ExtendedLocation != nil {
		var extendedLocationSTATUSStash v20220701s.ExtendedLocation_STATUS
		err := balancer.ExtendedLocation.AssignProperties_To_ExtendedLocation_STATUS(&extendedLocationSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ExtendedLocation_STATUS() to populate field ExtendedLocation_STATUSStash from ExtendedLocation")
		}
		var extendedLocation v20240301s.ExtendedLocation_STATUS
		err = extendedLocationSTATUSStash.AssignProperties_To_ExtendedLocation_STATUS(&extendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ExtendedLocation_STATUS() to populate field ExtendedLocation from ExtendedLocation_STATUSStash")
		}
		destination.ExtendedLocation = &extendedLocation
	} else {
		destination.ExtendedLocation = nil
	}

	// FrontendIPConfigurations
	if balancer.FrontendIPConfigurations != nil {
		frontendIPConfigurationList := make([]v20240301s.FrontendIPConfiguration_STATUS_LoadBalancer_SubResourceEmbedded, len(balancer.FrontendIPConfigurations))
		for frontendIPConfigurationIndex, frontendIPConfigurationItem := range balancer.FrontendIPConfigurations {
			// Shadow the loop variable to avoid aliasing
			frontendIPConfigurationItem := frontendIPConfigurationItem
			var frontendIPConfiguration v20240301s.FrontendIPConfiguration_STATUS_LoadBalancer_SubResourceEmbedded
			err := frontendIPConfigurationItem.AssignProperties_To_FrontendIPConfiguration_STATUS_LoadBalancer_SubResourceEmbedded(&frontendIPConfiguration)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_FrontendIPConfiguration_STATUS_LoadBalancer_SubResourceEmbedded() to populate field FrontendIPConfigurations")
			}
			frontendIPConfigurationList[frontendIPConfigurationIndex] = frontendIPConfiguration
		}
		destination.FrontendIPConfigurations = frontendIPConfigurationList
	} else {
		destination.FrontendIPConfigurations = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(balancer.Id)

	// InboundNatPools
	if balancer.InboundNatPools != nil {
		inboundNatPoolList := make([]v20240301s.InboundNatPool_STATUS, len(balancer.InboundNatPools))
		for inboundNatPoolIndex, inboundNatPoolItem := range balancer.InboundNatPools {
			// Shadow the loop variable to avoid aliasing
			inboundNatPoolItem := inboundNatPoolItem
			var inboundNatPool v20240301s.InboundNatPool_STATUS
			err := inboundNatPoolItem.AssignProperties_To_InboundNatPool_STATUS(&inboundNatPool)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_InboundNatPool_STATUS() to populate field InboundNatPools")
			}
			inboundNatPoolList[inboundNatPoolIndex] = inboundNatPool
		}
		destination.InboundNatPools = inboundNatPoolList
	} else {
		destination.InboundNatPools = nil
	}

	// InboundNatRules
	if balancer.InboundNatRules != nil {
		inboundNatRuleList := make([]v20240301s.InboundNatRule_STATUS_LoadBalancer_SubResourceEmbedded, len(balancer.InboundNatRules))
		for inboundNatRuleIndex, inboundNatRuleItem := range balancer.InboundNatRules {
			// Shadow the loop variable to avoid aliasing
			inboundNatRuleItem := inboundNatRuleItem
			var inboundNatRule v20240301s.InboundNatRule_STATUS_LoadBalancer_SubResourceEmbedded
			err := inboundNatRuleItem.AssignProperties_To_InboundNatRule_STATUS_LoadBalancer_SubResourceEmbedded(&inboundNatRule)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_InboundNatRule_STATUS_LoadBalancer_SubResourceEmbedded() to populate field InboundNatRules")
			}
			inboundNatRuleList[inboundNatRuleIndex] = inboundNatRule
		}
		destination.InboundNatRules = inboundNatRuleList
	} else {
		destination.InboundNatRules = nil
	}

	// LoadBalancingRules
	if balancer.LoadBalancingRules != nil {
		loadBalancingRuleList := make([]v20240301s.LoadBalancingRule_STATUS, len(balancer.LoadBalancingRules))
		for loadBalancingRuleIndex, loadBalancingRuleItem := range balancer.LoadBalancingRules {
			// Shadow the loop variable to avoid aliasing
			loadBalancingRuleItem := loadBalancingRuleItem
			var loadBalancingRule v20240301s.LoadBalancingRule_STATUS
			err := loadBalancingRuleItem.AssignProperties_To_LoadBalancingRule_STATUS(&loadBalancingRule)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_LoadBalancingRule_STATUS() to populate field LoadBalancingRules")
			}
			loadBalancingRuleList[loadBalancingRuleIndex] = loadBalancingRule
		}
		destination.LoadBalancingRules = loadBalancingRuleList
	} else {
		destination.LoadBalancingRules = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(balancer.Location)

	// Name
	destination.Name = genruntime.ClonePointerToString(balancer.Name)

	// OutboundRules
	if balancer.OutboundRules != nil {
		outboundRuleList := make([]v20240301s.OutboundRule_STATUS, len(balancer.OutboundRules))
		for outboundRuleIndex, outboundRuleItem := range balancer.OutboundRules {
			// Shadow the loop variable to avoid aliasing
			outboundRuleItem := outboundRuleItem
			var outboundRule v20240301s.OutboundRule_STATUS
			err := outboundRuleItem.AssignProperties_To_OutboundRule_STATUS(&outboundRule)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_OutboundRule_STATUS() to populate field OutboundRules")
			}
			outboundRuleList[outboundRuleIndex] = outboundRule
		}
		destination.OutboundRules = outboundRuleList
	} else {
		destination.OutboundRules = nil
	}

	// Probes
	if balancer.Probes != nil {
		probeList := make([]v20240301s.Probe_STATUS, len(balancer.Probes))
		for probeIndex, probeItem := range balancer.Probes {
			// Shadow the loop variable to avoid aliasing
			probeItem := probeItem
			var probe v20240301s.Probe_STATUS
			err := probeItem.AssignProperties_To_Probe_STATUS(&probe)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_Probe_STATUS() to populate field Probes")
			}
			probeList[probeIndex] = probe
		}
		destination.Probes = probeList
	} else {
		destination.Probes = nil
	}

	// ProvisioningState
	destination.ProvisioningState = genruntime.ClonePointerToString(balancer.ProvisioningState)

	// ResourceGuid
	destination.ResourceGuid = genruntime.ClonePointerToString(balancer.ResourceGuid)

	// Sku
	if balancer.Sku != nil {
		var sku v20240301s.LoadBalancerSku_STATUS
		err := balancer.Sku.AssignProperties_To_LoadBalancerSku_STATUS(&sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_LoadBalancerSku_STATUS() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(balancer.Tags)

	// Type
	destination.Type = genruntime.ClonePointerToString(balancer.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForLoadBalancer_STATUS interface (if implemented) to customize the conversion
	var balancerAsAny any = balancer
	if augmentedBalancer, ok := balancerAsAny.(augmentConversionForLoadBalancer_STATUS); ok {
		err := augmentedBalancer.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

type augmentConversionForLoadBalancer_Spec interface {
	AssignPropertiesFrom(src *v20240301s.LoadBalancer_Spec) error
	AssignPropertiesTo(dst *v20240301s.LoadBalancer_Spec) error
}

type augmentConversionForLoadBalancer_STATUS interface {
	AssignPropertiesFrom(src *v20240301s.LoadBalancer_STATUS) error
	AssignPropertiesTo(dst *v20240301s.LoadBalancer_STATUS) error
}

// Storage version of v1api20201101.BackendAddressPool_LoadBalancer_SubResourceEmbedded
// Pool of backend IP addresses.
type BackendAddressPool_LoadBalancer_SubResourceEmbedded struct {
	LoadBalancerBackendAddresses []LoadBalancerBackendAddress `json:"loadBalancerBackendAddresses,omitempty"`
	Name                         *string                      `json:"name,omitempty"`
	PropertyBag                  genruntime.PropertyBag       `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_BackendAddressPool_LoadBalancer_SubResourceEmbedded populates our BackendAddressPool_LoadBalancer_SubResourceEmbedded from the provided source BackendAddressPool_LoadBalancer_SubResourceEmbedded
func (embedded *BackendAddressPool_LoadBalancer_SubResourceEmbedded) AssignProperties_From_BackendAddressPool_LoadBalancer_SubResourceEmbedded(source *v20240301s.BackendAddressPool_LoadBalancer_SubResourceEmbedded) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// DrainPeriodInSeconds
	if source.DrainPeriodInSeconds != nil {
		propertyBag.Add("DrainPeriodInSeconds", *source.DrainPeriodInSeconds)
	} else {
		propertyBag.Remove("DrainPeriodInSeconds")
	}

	// LoadBalancerBackendAddresses
	if source.LoadBalancerBackendAddresses != nil {
		loadBalancerBackendAddressList := make([]LoadBalancerBackendAddress, len(source.LoadBalancerBackendAddresses))
		for loadBalancerBackendAddressIndex, loadBalancerBackendAddressItem := range source.LoadBalancerBackendAddresses {
			// Shadow the loop variable to avoid aliasing
			loadBalancerBackendAddressItem := loadBalancerBackendAddressItem
			var loadBalancerBackendAddress LoadBalancerBackendAddress
			err := loadBalancerBackendAddress.AssignProperties_From_LoadBalancerBackendAddress(&loadBalancerBackendAddressItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_LoadBalancerBackendAddress() to populate field LoadBalancerBackendAddresses")
			}
			loadBalancerBackendAddressList[loadBalancerBackendAddressIndex] = loadBalancerBackendAddress
		}
		embedded.LoadBalancerBackendAddresses = loadBalancerBackendAddressList
	} else {
		embedded.LoadBalancerBackendAddresses = nil
	}

	// Location
	if source.Location != nil {
		propertyBag.Add("Location", *source.Location)
	} else {
		propertyBag.Remove("Location")
	}

	// Name
	embedded.Name = genruntime.ClonePointerToString(source.Name)

	// SyncMode
	if source.SyncMode != nil {
		propertyBag.Add("SyncMode", *source.SyncMode)
	} else {
		propertyBag.Remove("SyncMode")
	}

	// TunnelInterfaces
	if len(source.TunnelInterfaces) > 0 {
		propertyBag.Add("TunnelInterfaces", source.TunnelInterfaces)
	} else {
		propertyBag.Remove("TunnelInterfaces")
	}

	// VirtualNetwork
	if source.VirtualNetwork != nil {
		propertyBag.Add("VirtualNetwork", *source.VirtualNetwork)
	} else {
		propertyBag.Remove("VirtualNetwork")
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		embedded.PropertyBag = propertyBag
	} else {
		embedded.PropertyBag = nil
	}

	// Invoke the augmentConversionForBackendAddressPool_LoadBalancer_SubResourceEmbedded interface (if implemented) to customize the conversion
	var embeddedAsAny any = embedded
	if augmentedEmbedded, ok := embeddedAsAny.(augmentConversionForBackendAddressPool_LoadBalancer_SubResourceEmbedded); ok {
		err := augmentedEmbedded.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_BackendAddressPool_LoadBalancer_SubResourceEmbedded populates the provided destination BackendAddressPool_LoadBalancer_SubResourceEmbedded from our BackendAddressPool_LoadBalancer_SubResourceEmbedded
func (embedded *BackendAddressPool_LoadBalancer_SubResourceEmbedded) AssignProperties_To_BackendAddressPool_LoadBalancer_SubResourceEmbedded(destination *v20240301s.BackendAddressPool_LoadBalancer_SubResourceEmbedded) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(embedded.PropertyBag)

	// DrainPeriodInSeconds
	if propertyBag.Contains("DrainPeriodInSeconds") {
		var drainPeriodInSecond int
		err := propertyBag.Pull("DrainPeriodInSeconds", &drainPeriodInSecond)
		if err != nil {
			return errors.Wrap(err, "pulling 'DrainPeriodInSeconds' from propertyBag")
		}

		destination.DrainPeriodInSeconds = &drainPeriodInSecond
	} else {
		destination.DrainPeriodInSeconds = nil
	}

	// LoadBalancerBackendAddresses
	if embedded.LoadBalancerBackendAddresses != nil {
		loadBalancerBackendAddressList := make([]v20240301s.LoadBalancerBackendAddress, len(embedded.LoadBalancerBackendAddresses))
		for loadBalancerBackendAddressIndex, loadBalancerBackendAddressItem := range embedded.LoadBalancerBackendAddresses {
			// Shadow the loop variable to avoid aliasing
			loadBalancerBackendAddressItem := loadBalancerBackendAddressItem
			var loadBalancerBackendAddress v20240301s.LoadBalancerBackendAddress
			err := loadBalancerBackendAddressItem.AssignProperties_To_LoadBalancerBackendAddress(&loadBalancerBackendAddress)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_LoadBalancerBackendAddress() to populate field LoadBalancerBackendAddresses")
			}
			loadBalancerBackendAddressList[loadBalancerBackendAddressIndex] = loadBalancerBackendAddress
		}
		destination.LoadBalancerBackendAddresses = loadBalancerBackendAddressList
	} else {
		destination.LoadBalancerBackendAddresses = nil
	}

	// Location
	if propertyBag.Contains("Location") {
		var location string
		err := propertyBag.Pull("Location", &location)
		if err != nil {
			return errors.Wrap(err, "pulling 'Location' from propertyBag")
		}

		destination.Location = &location
	} else {
		destination.Location = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(embedded.Name)

	// SyncMode
	if propertyBag.Contains("SyncMode") {
		var syncMode string
		err := propertyBag.Pull("SyncMode", &syncMode)
		if err != nil {
			return errors.Wrap(err, "pulling 'SyncMode' from propertyBag")
		}

		destination.SyncMode = &syncMode
	} else {
		destination.SyncMode = nil
	}

	// TunnelInterfaces
	if propertyBag.Contains("TunnelInterfaces") {
		var tunnelInterface []v20240301s.GatewayLoadBalancerTunnelInterface
		err := propertyBag.Pull("TunnelInterfaces", &tunnelInterface)
		if err != nil {
			return errors.Wrap(err, "pulling 'TunnelInterfaces' from propertyBag")
		}

		destination.TunnelInterfaces = tunnelInterface
	} else {
		destination.TunnelInterfaces = nil
	}

	// VirtualNetwork
	if propertyBag.Contains("VirtualNetwork") {
		var virtualNetwork v20240301s.SubResource
		err := propertyBag.Pull("VirtualNetwork", &virtualNetwork)
		if err != nil {
			return errors.Wrap(err, "pulling 'VirtualNetwork' from propertyBag")
		}

		destination.VirtualNetwork = &virtualNetwork
	} else {
		destination.VirtualNetwork = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForBackendAddressPool_LoadBalancer_SubResourceEmbedded interface (if implemented) to customize the conversion
	var embeddedAsAny any = embedded
	if augmentedEmbedded, ok := embeddedAsAny.(augmentConversionForBackendAddressPool_LoadBalancer_SubResourceEmbedded); ok {
		err := augmentedEmbedded.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201101.BackendAddressPool_STATUS_LoadBalancer_SubResourceEmbedded
// Pool of backend IP addresses.
type BackendAddressPool_STATUS_LoadBalancer_SubResourceEmbedded struct {
	BackendIPConfigurations      []NetworkInterfaceIPConfiguration_STATUS_LoadBalancer_SubResourceEmbedded `json:"backendIPConfigurations,omitempty"`
	Etag                         *string                                                                   `json:"etag,omitempty"`
	Id                           *string                                                                   `json:"id,omitempty"`
	LoadBalancerBackendAddresses []LoadBalancerBackendAddress_STATUS                                       `json:"loadBalancerBackendAddresses,omitempty"`
	LoadBalancingRules           []SubResource_STATUS                                                      `json:"loadBalancingRules,omitempty"`
	Name                         *string                                                                   `json:"name,omitempty"`
	OutboundRule                 *SubResource_STATUS                                                       `json:"outboundRule,omitempty"`
	OutboundRules                []SubResource_STATUS                                                      `json:"outboundRules,omitempty"`
	PropertyBag                  genruntime.PropertyBag                                                    `json:"$propertyBag,omitempty"`
	ProvisioningState            *string                                                                   `json:"provisioningState,omitempty"`
	Type                         *string                                                                   `json:"type,omitempty"`
}

// AssignProperties_From_BackendAddressPool_STATUS_LoadBalancer_SubResourceEmbedded populates our BackendAddressPool_STATUS_LoadBalancer_SubResourceEmbedded from the provided source BackendAddressPool_STATUS_LoadBalancer_SubResourceEmbedded
func (embedded *BackendAddressPool_STATUS_LoadBalancer_SubResourceEmbedded) AssignProperties_From_BackendAddressPool_STATUS_LoadBalancer_SubResourceEmbedded(source *v20240301s.BackendAddressPool_STATUS_LoadBalancer_SubResourceEmbedded) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// BackendIPConfigurations
	if source.BackendIPConfigurations != nil {
		backendIPConfigurationList := make([]NetworkInterfaceIPConfiguration_STATUS_LoadBalancer_SubResourceEmbedded, len(source.BackendIPConfigurations))
		for backendIPConfigurationIndex, backendIPConfigurationItem := range source.BackendIPConfigurations {
			// Shadow the loop variable to avoid aliasing
			backendIPConfigurationItem := backendIPConfigurationItem
			var backendIPConfiguration NetworkInterfaceIPConfiguration_STATUS_LoadBalancer_SubResourceEmbedded
			err := backendIPConfiguration.AssignProperties_From_NetworkInterfaceIPConfiguration_STATUS_LoadBalancer_SubResourceEmbedded(&backendIPConfigurationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_NetworkInterfaceIPConfiguration_STATUS_LoadBalancer_SubResourceEmbedded() to populate field BackendIPConfigurations")
			}
			backendIPConfigurationList[backendIPConfigurationIndex] = backendIPConfiguration
		}
		embedded.BackendIPConfigurations = backendIPConfigurationList
	} else {
		embedded.BackendIPConfigurations = nil
	}

	// DrainPeriodInSeconds
	if source.DrainPeriodInSeconds != nil {
		propertyBag.Add("DrainPeriodInSeconds", *source.DrainPeriodInSeconds)
	} else {
		propertyBag.Remove("DrainPeriodInSeconds")
	}

	// Etag
	embedded.Etag = genruntime.ClonePointerToString(source.Etag)

	// Id
	embedded.Id = genruntime.ClonePointerToString(source.Id)

	// InboundNatRules
	if len(source.InboundNatRules) > 0 {
		propertyBag.Add("InboundNatRules", source.InboundNatRules)
	} else {
		propertyBag.Remove("InboundNatRules")
	}

	// LoadBalancerBackendAddresses
	if source.LoadBalancerBackendAddresses != nil {
		loadBalancerBackendAddressList := make([]LoadBalancerBackendAddress_STATUS, len(source.LoadBalancerBackendAddresses))
		for loadBalancerBackendAddressIndex, loadBalancerBackendAddressItem := range source.LoadBalancerBackendAddresses {
			// Shadow the loop variable to avoid aliasing
			loadBalancerBackendAddressItem := loadBalancerBackendAddressItem
			var loadBalancerBackendAddress LoadBalancerBackendAddress_STATUS
			err := loadBalancerBackendAddress.AssignProperties_From_LoadBalancerBackendAddress_STATUS(&loadBalancerBackendAddressItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_LoadBalancerBackendAddress_STATUS() to populate field LoadBalancerBackendAddresses")
			}
			loadBalancerBackendAddressList[loadBalancerBackendAddressIndex] = loadBalancerBackendAddress
		}
		embedded.LoadBalancerBackendAddresses = loadBalancerBackendAddressList
	} else {
		embedded.LoadBalancerBackendAddresses = nil
	}

	// LoadBalancingRules
	if source.LoadBalancingRules != nil {
		loadBalancingRuleList := make([]SubResource_STATUS, len(source.LoadBalancingRules))
		for loadBalancingRuleIndex, loadBalancingRuleItem := range source.LoadBalancingRules {
			// Shadow the loop variable to avoid aliasing
			loadBalancingRuleItem := loadBalancingRuleItem
			var subResourceSTATUSStash v20240101s.SubResource_STATUS
			err := subResourceSTATUSStash.AssignProperties_From_SubResource_STATUS(&loadBalancingRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SubResource_STATUSStash from LoadBalancingRules")
			}
			var subResourceSTATUSStashLocal v20220701s.SubResource_STATUS
			err = subResourceSTATUSStashLocal.AssignProperties_From_SubResource_STATUS(&subResourceSTATUSStash)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SubResource_STATUSStash")
			}
			var loadBalancingRule SubResource_STATUS
			err = loadBalancingRule.AssignProperties_From_SubResource_STATUS(&subResourceSTATUSStashLocal)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field LoadBalancingRules from SubResource_STATUSStash")
			}
			loadBalancingRuleList[loadBalancingRuleIndex] = loadBalancingRule
		}
		embedded.LoadBalancingRules = loadBalancingRuleList
	} else {
		embedded.LoadBalancingRules = nil
	}

	// Location
	if source.Location != nil {
		propertyBag.Add("Location", *source.Location)
	} else {
		propertyBag.Remove("Location")
	}

	// Name
	embedded.Name = genruntime.ClonePointerToString(source.Name)

	// OutboundRule
	if source.OutboundRule != nil {
		var subResourceSTATUSStash v20240101s.SubResource_STATUS
		err := subResourceSTATUSStash.AssignProperties_From_SubResource_STATUS(source.OutboundRule)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SubResource_STATUSStash from OutboundRule")
		}
		var subResourceSTATUSStashLocal v20220701s.SubResource_STATUS
		err = subResourceSTATUSStashLocal.AssignProperties_From_SubResource_STATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SubResource_STATUSStash")
		}
		var outboundRule SubResource_STATUS
		err = outboundRule.AssignProperties_From_SubResource_STATUS(&subResourceSTATUSStashLocal)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field OutboundRule from SubResource_STATUSStash")
		}
		embedded.OutboundRule = &outboundRule
	} else {
		embedded.OutboundRule = nil
	}

	// OutboundRules
	if source.OutboundRules != nil {
		outboundRuleList := make([]SubResource_STATUS, len(source.OutboundRules))
		for outboundRuleIndex, outboundRuleItem := range source.OutboundRules {
			// Shadow the loop variable to avoid aliasing
			outboundRuleItem := outboundRuleItem
			var subResourceSTATUSStash v20240101s.SubResource_STATUS
			err := subResourceSTATUSStash.AssignProperties_From_SubResource_STATUS(&outboundRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SubResource_STATUSStash from OutboundRules")
			}
			var subResourceSTATUSStashLocal v20220701s.SubResource_STATUS
			err = subResourceSTATUSStashLocal.AssignProperties_From_SubResource_STATUS(&subResourceSTATUSStash)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SubResource_STATUSStash")
			}
			var outboundRule SubResource_STATUS
			err = outboundRule.AssignProperties_From_SubResource_STATUS(&subResourceSTATUSStashLocal)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field OutboundRules from SubResource_STATUSStash")
			}
			outboundRuleList[outboundRuleIndex] = outboundRule
		}
		embedded.OutboundRules = outboundRuleList
	} else {
		embedded.OutboundRules = nil
	}

	// ProvisioningState
	embedded.ProvisioningState = genruntime.ClonePointerToString(source.ProvisioningState)

	// SyncMode
	if source.SyncMode != nil {
		propertyBag.Add("SyncMode", *source.SyncMode)
	} else {
		propertyBag.Remove("SyncMode")
	}

	// TunnelInterfaces
	if len(source.TunnelInterfaces) > 0 {
		propertyBag.Add("TunnelInterfaces", source.TunnelInterfaces)
	} else {
		propertyBag.Remove("TunnelInterfaces")
	}

	// Type
	embedded.Type = genruntime.ClonePointerToString(source.Type)

	// VirtualNetwork
	if source.VirtualNetwork != nil {
		propertyBag.Add("VirtualNetwork", *source.VirtualNetwork)
	} else {
		propertyBag.Remove("VirtualNetwork")
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		embedded.PropertyBag = propertyBag
	} else {
		embedded.PropertyBag = nil
	}

	// Invoke the augmentConversionForBackendAddressPool_STATUS_LoadBalancer_SubResourceEmbedded interface (if implemented) to customize the conversion
	var embeddedAsAny any = embedded
	if augmentedEmbedded, ok := embeddedAsAny.(augmentConversionForBackendAddressPool_STATUS_LoadBalancer_SubResourceEmbedded); ok {
		err := augmentedEmbedded.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_BackendAddressPool_STATUS_LoadBalancer_SubResourceEmbedded populates the provided destination BackendAddressPool_STATUS_LoadBalancer_SubResourceEmbedded from our BackendAddressPool_STATUS_LoadBalancer_SubResourceEmbedded
func (embedded *BackendAddressPool_STATUS_LoadBalancer_SubResourceEmbedded) AssignProperties_To_BackendAddressPool_STATUS_LoadBalancer_SubResourceEmbedded(destination *v20240301s.BackendAddressPool_STATUS_LoadBalancer_SubResourceEmbedded) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(embedded.PropertyBag)

	// BackendIPConfigurations
	if embedded.BackendIPConfigurations != nil {
		backendIPConfigurationList := make([]v20240301s.NetworkInterfaceIPConfiguration_STATUS_LoadBalancer_SubResourceEmbedded, len(embedded.BackendIPConfigurations))
		for backendIPConfigurationIndex, backendIPConfigurationItem := range embedded.BackendIPConfigurations {
			// Shadow the loop variable to avoid aliasing
			backendIPConfigurationItem := backendIPConfigurationItem
			var backendIPConfiguration v20240301s.NetworkInterfaceIPConfiguration_STATUS_LoadBalancer_SubResourceEmbedded
			err := backendIPConfigurationItem.AssignProperties_To_NetworkInterfaceIPConfiguration_STATUS_LoadBalancer_SubResourceEmbedded(&backendIPConfiguration)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_NetworkInterfaceIPConfiguration_STATUS_LoadBalancer_SubResourceEmbedded() to populate field BackendIPConfigurations")
			}
			backendIPConfigurationList[backendIPConfigurationIndex] = backendIPConfiguration
		}
		destination.BackendIPConfigurations = backendIPConfigurationList
	} else {
		destination.BackendIPConfigurations = nil
	}

	// DrainPeriodInSeconds
	if propertyBag.Contains("DrainPeriodInSeconds") {
		var drainPeriodInSecond int
		err := propertyBag.Pull("DrainPeriodInSeconds", &drainPeriodInSecond)
		if err != nil {
			return errors.Wrap(err, "pulling 'DrainPeriodInSeconds' from propertyBag")
		}

		destination.DrainPeriodInSeconds = &drainPeriodInSecond
	} else {
		destination.DrainPeriodInSeconds = nil
	}

	// Etag
	destination.Etag = genruntime.ClonePointerToString(embedded.Etag)

	// Id
	destination.Id = genruntime.ClonePointerToString(embedded.Id)

	// InboundNatRules
	if propertyBag.Contains("InboundNatRules") {
		var inboundNatRule []v20240301s.SubResource_STATUS
		err := propertyBag.Pull("InboundNatRules", &inboundNatRule)
		if err != nil {
			return errors.Wrap(err, "pulling 'InboundNatRules' from propertyBag")
		}

		destination.InboundNatRules = inboundNatRule
	} else {
		destination.InboundNatRules = nil
	}

	// LoadBalancerBackendAddresses
	if embedded.LoadBalancerBackendAddresses != nil {
		loadBalancerBackendAddressList := make([]v20240301s.LoadBalancerBackendAddress_STATUS, len(embedded.LoadBalancerBackendAddresses))
		for loadBalancerBackendAddressIndex, loadBalancerBackendAddressItem := range embedded.LoadBalancerBackendAddresses {
			// Shadow the loop variable to avoid aliasing
			loadBalancerBackendAddressItem := loadBalancerBackendAddressItem
			var loadBalancerBackendAddress v20240301s.LoadBalancerBackendAddress_STATUS
			err := loadBalancerBackendAddressItem.AssignProperties_To_LoadBalancerBackendAddress_STATUS(&loadBalancerBackendAddress)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_LoadBalancerBackendAddress_STATUS() to populate field LoadBalancerBackendAddresses")
			}
			loadBalancerBackendAddressList[loadBalancerBackendAddressIndex] = loadBalancerBackendAddress
		}
		destination.LoadBalancerBackendAddresses = loadBalancerBackendAddressList
	} else {
		destination.LoadBalancerBackendAddresses = nil
	}

	// LoadBalancingRules
	if embedded.LoadBalancingRules != nil {
		loadBalancingRuleList := make([]v20240301s.SubResource_STATUS, len(embedded.LoadBalancingRules))
		for loadBalancingRuleIndex, loadBalancingRuleItem := range embedded.LoadBalancingRules {
			// Shadow the loop variable to avoid aliasing
			loadBalancingRuleItem := loadBalancingRuleItem
			var subResourceSTATUSStash v20220701s.SubResource_STATUS
			err := loadBalancingRuleItem.AssignProperties_To_SubResource_STATUS(&subResourceSTATUSStash)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SubResource_STATUSStash from LoadBalancingRules")
			}
			var subResourceSTATUSStashLocal v20240101s.SubResource_STATUS
			err = subResourceSTATUSStash.AssignProperties_To_SubResource_STATUS(&subResourceSTATUSStashLocal)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SubResource_STATUSStash")
			}
			var loadBalancingRule v20240301s.SubResource_STATUS
			err = subResourceSTATUSStashLocal.AssignProperties_To_SubResource_STATUS(&loadBalancingRule)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field LoadBalancingRules from SubResource_STATUSStash")
			}
			loadBalancingRuleList[loadBalancingRuleIndex] = loadBalancingRule
		}
		destination.LoadBalancingRules = loadBalancingRuleList
	} else {
		destination.LoadBalancingRules = nil
	}

	// Location
	if propertyBag.Contains("Location") {
		var location string
		err := propertyBag.Pull("Location", &location)
		if err != nil {
			return errors.Wrap(err, "pulling 'Location' from propertyBag")
		}

		destination.Location = &location
	} else {
		destination.Location = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(embedded.Name)

	// OutboundRule
	if embedded.OutboundRule != nil {
		var subResourceSTATUSStash v20220701s.SubResource_STATUS
		err := embedded.OutboundRule.AssignProperties_To_SubResource_STATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SubResource_STATUSStash from OutboundRule")
		}
		var subResourceSTATUSStashLocal v20240101s.SubResource_STATUS
		err = subResourceSTATUSStash.AssignProperties_To_SubResource_STATUS(&subResourceSTATUSStashLocal)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SubResource_STATUSStash")
		}
		var outboundRule v20240301s.SubResource_STATUS
		err = subResourceSTATUSStashLocal.AssignProperties_To_SubResource_STATUS(&outboundRule)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field OutboundRule from SubResource_STATUSStash")
		}
		destination.OutboundRule = &outboundRule
	} else {
		destination.OutboundRule = nil
	}

	// OutboundRules
	if embedded.OutboundRules != nil {
		outboundRuleList := make([]v20240301s.SubResource_STATUS, len(embedded.OutboundRules))
		for outboundRuleIndex, outboundRuleItem := range embedded.OutboundRules {
			// Shadow the loop variable to avoid aliasing
			outboundRuleItem := outboundRuleItem
			var subResourceSTATUSStash v20220701s.SubResource_STATUS
			err := outboundRuleItem.AssignProperties_To_SubResource_STATUS(&subResourceSTATUSStash)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SubResource_STATUSStash from OutboundRules")
			}
			var subResourceSTATUSStashLocal v20240101s.SubResource_STATUS
			err = subResourceSTATUSStash.AssignProperties_To_SubResource_STATUS(&subResourceSTATUSStashLocal)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SubResource_STATUSStash")
			}
			var outboundRule v20240301s.SubResource_STATUS
			err = subResourceSTATUSStashLocal.AssignProperties_To_SubResource_STATUS(&outboundRule)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field OutboundRules from SubResource_STATUSStash")
			}
			outboundRuleList[outboundRuleIndex] = outboundRule
		}
		destination.OutboundRules = outboundRuleList
	} else {
		destination.OutboundRules = nil
	}

	// ProvisioningState
	destination.ProvisioningState = genruntime.ClonePointerToString(embedded.ProvisioningState)

	// SyncMode
	if propertyBag.Contains("SyncMode") {
		var syncMode string
		err := propertyBag.Pull("SyncMode", &syncMode)
		if err != nil {
			return errors.Wrap(err, "pulling 'SyncMode' from propertyBag")
		}

		destination.SyncMode = &syncMode
	} else {
		destination.SyncMode = nil
	}

	// TunnelInterfaces
	if propertyBag.Contains("TunnelInterfaces") {
		var tunnelInterface []v20240301s.GatewayLoadBalancerTunnelInterface_STATUS
		err := propertyBag.Pull("TunnelInterfaces", &tunnelInterface)
		if err != nil {
			return errors.Wrap(err, "pulling 'TunnelInterfaces' from propertyBag")
		}

		destination.TunnelInterfaces = tunnelInterface
	} else {
		destination.TunnelInterfaces = nil
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(embedded.Type)

	// VirtualNetwork
	if propertyBag.Contains("VirtualNetwork") {
		var virtualNetwork v20240301s.SubResource_STATUS
		err := propertyBag.Pull("VirtualNetwork", &virtualNetwork)
		if err != nil {
			return errors.Wrap(err, "pulling 'VirtualNetwork' from propertyBag")
		}

		destination.VirtualNetwork = &virtualNetwork
	} else {
		destination.VirtualNetwork = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForBackendAddressPool_STATUS_LoadBalancer_SubResourceEmbedded interface (if implemented) to customize the conversion
	var embeddedAsAny any = embedded
	if augmentedEmbedded, ok := embeddedAsAny.(augmentConversionForBackendAddressPool_STATUS_LoadBalancer_SubResourceEmbedded); ok {
		err := augmentedEmbedded.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201101.ExtendedLocation
// ExtendedLocation complex type.
type ExtendedLocation struct {
	Name        *string                `json:"name,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Type        *string                `json:"type,omitempty"`
}

// AssignProperties_From_ExtendedLocation populates our ExtendedLocation from the provided source ExtendedLocation
func (location *ExtendedLocation) AssignProperties_From_ExtendedLocation(source *v20220701s.ExtendedLocation) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	location.Name = genruntime.ClonePointerToString(source.Name)

	// Type
	location.Type = genruntime.ClonePointerToString(source.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		location.PropertyBag = propertyBag
	} else {
		location.PropertyBag = nil
	}

	// Invoke the augmentConversionForExtendedLocation interface (if implemented) to customize the conversion
	var locationAsAny any = location
	if augmentedLocation, ok := locationAsAny.(augmentConversionForExtendedLocation); ok {
		err := augmentedLocation.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ExtendedLocation populates the provided destination ExtendedLocation from our ExtendedLocation
func (location *ExtendedLocation) AssignProperties_To_ExtendedLocation(destination *v20220701s.ExtendedLocation) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(location.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(location.Name)

	// Type
	destination.Type = genruntime.ClonePointerToString(location.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForExtendedLocation interface (if implemented) to customize the conversion
	var locationAsAny any = location
	if augmentedLocation, ok := locationAsAny.(augmentConversionForExtendedLocation); ok {
		err := augmentedLocation.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201101.ExtendedLocation_STATUS
// ExtendedLocation complex type.
type ExtendedLocation_STATUS struct {
	Name        *string                `json:"name,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Type        *string                `json:"type,omitempty"`
}

// AssignProperties_From_ExtendedLocation_STATUS populates our ExtendedLocation_STATUS from the provided source ExtendedLocation_STATUS
func (location *ExtendedLocation_STATUS) AssignProperties_From_ExtendedLocation_STATUS(source *v20220701s.ExtendedLocation_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	location.Name = genruntime.ClonePointerToString(source.Name)

	// Type
	location.Type = genruntime.ClonePointerToString(source.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		location.PropertyBag = propertyBag
	} else {
		location.PropertyBag = nil
	}

	// Invoke the augmentConversionForExtendedLocation_STATUS interface (if implemented) to customize the conversion
	var locationAsAny any = location
	if augmentedLocation, ok := locationAsAny.(augmentConversionForExtendedLocation_STATUS); ok {
		err := augmentedLocation.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ExtendedLocation_STATUS populates the provided destination ExtendedLocation_STATUS from our ExtendedLocation_STATUS
func (location *ExtendedLocation_STATUS) AssignProperties_To_ExtendedLocation_STATUS(destination *v20220701s.ExtendedLocation_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(location.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(location.Name)

	// Type
	destination.Type = genruntime.ClonePointerToString(location.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForExtendedLocation_STATUS interface (if implemented) to customize the conversion
	var locationAsAny any = location
	if augmentedLocation, ok := locationAsAny.(augmentConversionForExtendedLocation_STATUS); ok {
		err := augmentedLocation.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201101.FrontendIPConfiguration_LoadBalancer_SubResourceEmbedded
// Frontend IP address of the load balancer.
type FrontendIPConfiguration_LoadBalancer_SubResourceEmbedded struct {
	Name                      *string                                               `json:"name,omitempty"`
	PrivateIPAddress          *string                                               `json:"privateIPAddress,omitempty"`
	PrivateIPAddressVersion   *string                                               `json:"privateIPAddressVersion,omitempty"`
	PrivateIPAllocationMethod *string                                               `json:"privateIPAllocationMethod,omitempty"`
	PropertyBag               genruntime.PropertyBag                                `json:"$propertyBag,omitempty"`
	PublicIPAddress           *PublicIPAddressSpec_LoadBalancer_SubResourceEmbedded `json:"publicIPAddress,omitempty"`
	PublicIPPrefix            *SubResource                                          `json:"publicIPPrefix,omitempty"`
	Subnet                    *Subnet_LoadBalancer_SubResourceEmbedded              `json:"subnet,omitempty"`
	Zones                     []string                                              `json:"zones,omitempty"`
}

// AssignProperties_From_FrontendIPConfiguration_LoadBalancer_SubResourceEmbedded populates our FrontendIPConfiguration_LoadBalancer_SubResourceEmbedded from the provided source FrontendIPConfiguration_LoadBalancer_SubResourceEmbedded
func (embedded *FrontendIPConfiguration_LoadBalancer_SubResourceEmbedded) AssignProperties_From_FrontendIPConfiguration_LoadBalancer_SubResourceEmbedded(source *v20240301s.FrontendIPConfiguration_LoadBalancer_SubResourceEmbedded) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// GatewayLoadBalancer
	if source.GatewayLoadBalancer != nil {
		propertyBag.Add("GatewayLoadBalancer", *source.GatewayLoadBalancer)
	} else {
		propertyBag.Remove("GatewayLoadBalancer")
	}

	// Name
	embedded.Name = genruntime.ClonePointerToString(source.Name)

	// PrivateIPAddress
	embedded.PrivateIPAddress = genruntime.ClonePointerToString(source.PrivateIPAddress)

	// PrivateIPAddressVersion
	embedded.PrivateIPAddressVersion = genruntime.ClonePointerToString(source.PrivateIPAddressVersion)

	// PrivateIPAllocationMethod
	embedded.PrivateIPAllocationMethod = genruntime.ClonePointerToString(source.PrivateIPAllocationMethod)

	// PublicIPAddress
	if source.PublicIPAddress != nil {
		var publicIPAddress PublicIPAddressSpec_LoadBalancer_SubResourceEmbedded
		err := publicIPAddress.AssignProperties_From_PublicIPAddressSpec_LoadBalancer_SubResourceEmbedded(source.PublicIPAddress)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_PublicIPAddressSpec_LoadBalancer_SubResourceEmbedded() to populate field PublicIPAddress")
		}
		embedded.PublicIPAddress = &publicIPAddress
	} else {
		embedded.PublicIPAddress = nil
	}

	// PublicIPPrefix
	if source.PublicIPPrefix != nil {
		var subResourceStash v20220701s.SubResource
		err := subResourceStash.AssignProperties_From_SubResource(source.PublicIPPrefix)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field SubResourceStash from PublicIPPrefix")
		}
		var publicIPPrefix SubResource
		err = publicIPPrefix.AssignProperties_From_SubResource(&subResourceStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field PublicIPPrefix from SubResourceStash")
		}
		embedded.PublicIPPrefix = &publicIPPrefix
	} else {
		embedded.PublicIPPrefix = nil
	}

	// Subnet
	if source.Subnet != nil {
		var subnet Subnet_LoadBalancer_SubResourceEmbedded
		err := subnet.AssignProperties_From_Subnet_LoadBalancer_SubResourceEmbedded(source.Subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Subnet_LoadBalancer_SubResourceEmbedded() to populate field Subnet")
		}
		embedded.Subnet = &subnet
	} else {
		embedded.Subnet = nil
	}

	// Zones
	embedded.Zones = genruntime.CloneSliceOfString(source.Zones)

	// Update the property bag
	if len(propertyBag) > 0 {
		embedded.PropertyBag = propertyBag
	} else {
		embedded.PropertyBag = nil
	}

	// Invoke the augmentConversionForFrontendIPConfiguration_LoadBalancer_SubResourceEmbedded interface (if implemented) to customize the conversion
	var embeddedAsAny any = embedded
	if augmentedEmbedded, ok := embeddedAsAny.(augmentConversionForFrontendIPConfiguration_LoadBalancer_SubResourceEmbedded); ok {
		err := augmentedEmbedded.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_FrontendIPConfiguration_LoadBalancer_SubResourceEmbedded populates the provided destination FrontendIPConfiguration_LoadBalancer_SubResourceEmbedded from our FrontendIPConfiguration_LoadBalancer_SubResourceEmbedded
func (embedded *FrontendIPConfiguration_LoadBalancer_SubResourceEmbedded) AssignProperties_To_FrontendIPConfiguration_LoadBalancer_SubResourceEmbedded(destination *v20240301s.FrontendIPConfiguration_LoadBalancer_SubResourceEmbedded) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(embedded.PropertyBag)

	// GatewayLoadBalancer
	if propertyBag.Contains("GatewayLoadBalancer") {
		var gatewayLoadBalancer v20240301s.SubResource
		err := propertyBag.Pull("GatewayLoadBalancer", &gatewayLoadBalancer)
		if err != nil {
			return errors.Wrap(err, "pulling 'GatewayLoadBalancer' from propertyBag")
		}

		destination.GatewayLoadBalancer = &gatewayLoadBalancer
	} else {
		destination.GatewayLoadBalancer = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(embedded.Name)

	// PrivateIPAddress
	destination.PrivateIPAddress = genruntime.ClonePointerToString(embedded.PrivateIPAddress)

	// PrivateIPAddressVersion
	destination.PrivateIPAddressVersion = genruntime.ClonePointerToString(embedded.PrivateIPAddressVersion)

	// PrivateIPAllocationMethod
	destination.PrivateIPAllocationMethod = genruntime.ClonePointerToString(embedded.PrivateIPAllocationMethod)

	// PublicIPAddress
	if embedded.PublicIPAddress != nil {
		var publicIPAddress v20240301s.PublicIPAddressSpec_LoadBalancer_SubResourceEmbedded
		err := embedded.PublicIPAddress.AssignProperties_To_PublicIPAddressSpec_LoadBalancer_SubResourceEmbedded(&publicIPAddress)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_PublicIPAddressSpec_LoadBalancer_SubResourceEmbedded() to populate field PublicIPAddress")
		}
		destination.PublicIPAddress = &publicIPAddress
	} else {
		destination.PublicIPAddress = nil
	}

	// PublicIPPrefix
	if embedded.PublicIPPrefix != nil {
		var subResourceStash v20220701s.SubResource
		err := embedded.PublicIPPrefix.AssignProperties_To_SubResource(&subResourceStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field SubResourceStash from PublicIPPrefix")
		}
		var publicIPPrefix v20240301s.SubResource
		err = subResourceStash.AssignProperties_To_SubResource(&publicIPPrefix)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field PublicIPPrefix from SubResourceStash")
		}
		destination.PublicIPPrefix = &publicIPPrefix
	} else {
		destination.PublicIPPrefix = nil
	}

	// Subnet
	if embedded.Subnet != nil {
		var subnet v20240301s.Subnet_LoadBalancer_SubResourceEmbedded
		err := embedded.Subnet.AssignProperties_To_Subnet_LoadBalancer_SubResourceEmbedded(&subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Subnet_LoadBalancer_SubResourceEmbedded() to populate field Subnet")
		}
		destination.Subnet = &subnet
	} else {
		destination.Subnet = nil
	}

	// Zones
	destination.Zones = genruntime.CloneSliceOfString(embedded.Zones)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForFrontendIPConfiguration_LoadBalancer_SubResourceEmbedded interface (if implemented) to customize the conversion
	var embeddedAsAny any = embedded
	if augmentedEmbedded, ok := embeddedAsAny.(augmentConversionForFrontendIPConfiguration_LoadBalancer_SubResourceEmbedded); ok {
		err := augmentedEmbedded.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201101.FrontendIPConfiguration_STATUS_LoadBalancer_SubResourceEmbedded
// Frontend IP address of the load balancer.
type FrontendIPConfiguration_STATUS_LoadBalancer_SubResourceEmbedded struct {
	Etag                      *string                                                  `json:"etag,omitempty"`
	Id                        *string                                                  `json:"id,omitempty"`
	InboundNatPools           []SubResource_STATUS                                     `json:"inboundNatPools,omitempty"`
	InboundNatRules           []SubResource_STATUS                                     `json:"inboundNatRules,omitempty"`
	LoadBalancingRules        []SubResource_STATUS                                     `json:"loadBalancingRules,omitempty"`
	Name                      *string                                                  `json:"name,omitempty"`
	OutboundRules             []SubResource_STATUS                                     `json:"outboundRules,omitempty"`
	PrivateIPAddress          *string                                                  `json:"privateIPAddress,omitempty"`
	PrivateIPAddressVersion   *string                                                  `json:"privateIPAddressVersion,omitempty"`
	PrivateIPAllocationMethod *string                                                  `json:"privateIPAllocationMethod,omitempty"`
	PropertyBag               genruntime.PropertyBag                                   `json:"$propertyBag,omitempty"`
	ProvisioningState         *string                                                  `json:"provisioningState,omitempty"`
	PublicIPAddress           *PublicIPAddress_STATUS_LoadBalancer_SubResourceEmbedded `json:"publicIPAddress,omitempty"`
	PublicIPPrefix            *SubResource_STATUS                                      `json:"publicIPPrefix,omitempty"`
	Subnet                    *Subnet_STATUS_LoadBalancer_SubResourceEmbedded          `json:"subnet,omitempty"`
	Type                      *string                                                  `json:"type,omitempty"`
	Zones                     []string                                                 `json:"zones,omitempty"`
}

// AssignProperties_From_FrontendIPConfiguration_STATUS_LoadBalancer_SubResourceEmbedded populates our FrontendIPConfiguration_STATUS_LoadBalancer_SubResourceEmbedded from the provided source FrontendIPConfiguration_STATUS_LoadBalancer_SubResourceEmbedded
func (embedded *FrontendIPConfiguration_STATUS_LoadBalancer_SubResourceEmbedded) AssignProperties_From_FrontendIPConfiguration_STATUS_LoadBalancer_SubResourceEmbedded(source *v20240301s.FrontendIPConfiguration_STATUS_LoadBalancer_SubResourceEmbedded) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Etag
	embedded.Etag = genruntime.ClonePointerToString(source.Etag)

	// GatewayLoadBalancer
	if source.GatewayLoadBalancer != nil {
		propertyBag.Add("GatewayLoadBalancer", *source.GatewayLoadBalancer)
	} else {
		propertyBag.Remove("GatewayLoadBalancer")
	}

	// Id
	embedded.Id = genruntime.ClonePointerToString(source.Id)

	// InboundNatPools
	if source.InboundNatPools != nil {
		inboundNatPoolList := make([]SubResource_STATUS, len(source.InboundNatPools))
		for inboundNatPoolIndex, inboundNatPoolItem := range source.InboundNatPools {
			// Shadow the loop variable to avoid aliasing
			inboundNatPoolItem := inboundNatPoolItem
			var subResourceSTATUSStash v20240101s.SubResource_STATUS
			err := subResourceSTATUSStash.AssignProperties_From_SubResource_STATUS(&inboundNatPoolItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SubResource_STATUSStash from InboundNatPools")
			}
			var subResourceSTATUSStashLocal v20220701s.SubResource_STATUS
			err = subResourceSTATUSStashLocal.AssignProperties_From_SubResource_STATUS(&subResourceSTATUSStash)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SubResource_STATUSStash")
			}
			var inboundNatPool SubResource_STATUS
			err = inboundNatPool.AssignProperties_From_SubResource_STATUS(&subResourceSTATUSStashLocal)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field InboundNatPools from SubResource_STATUSStash")
			}
			inboundNatPoolList[inboundNatPoolIndex] = inboundNatPool
		}
		embedded.InboundNatPools = inboundNatPoolList
	} else {
		embedded.InboundNatPools = nil
	}

	// InboundNatRules
	if source.InboundNatRules != nil {
		inboundNatRuleList := make([]SubResource_STATUS, len(source.InboundNatRules))
		for inboundNatRuleIndex, inboundNatRuleItem := range source.InboundNatRules {
			// Shadow the loop variable to avoid aliasing
			inboundNatRuleItem := inboundNatRuleItem
			var subResourceSTATUSStash v20240101s.SubResource_STATUS
			err := subResourceSTATUSStash.AssignProperties_From_SubResource_STATUS(&inboundNatRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SubResource_STATUSStash from InboundNatRules")
			}
			var subResourceSTATUSStashLocal v20220701s.SubResource_STATUS
			err = subResourceSTATUSStashLocal.AssignProperties_From_SubResource_STATUS(&subResourceSTATUSStash)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SubResource_STATUSStash")
			}
			var inboundNatRule SubResource_STATUS
			err = inboundNatRule.AssignProperties_From_SubResource_STATUS(&subResourceSTATUSStashLocal)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field InboundNatRules from SubResource_STATUSStash")
			}
			inboundNatRuleList[inboundNatRuleIndex] = inboundNatRule
		}
		embedded.InboundNatRules = inboundNatRuleList
	} else {
		embedded.InboundNatRules = nil
	}

	// LoadBalancingRules
	if source.LoadBalancingRules != nil {
		loadBalancingRuleList := make([]SubResource_STATUS, len(source.LoadBalancingRules))
		for loadBalancingRuleIndex, loadBalancingRuleItem := range source.LoadBalancingRules {
			// Shadow the loop variable to avoid aliasing
			loadBalancingRuleItem := loadBalancingRuleItem
			var subResourceSTATUSStash v20240101s.SubResource_STATUS
			err := subResourceSTATUSStash.AssignProperties_From_SubResource_STATUS(&loadBalancingRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SubResource_STATUSStash from LoadBalancingRules")
			}
			var subResourceSTATUSStashLocal v20220701s.SubResource_STATUS
			err = subResourceSTATUSStashLocal.AssignProperties_From_SubResource_STATUS(&subResourceSTATUSStash)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SubResource_STATUSStash")
			}
			var loadBalancingRule SubResource_STATUS
			err = loadBalancingRule.AssignProperties_From_SubResource_STATUS(&subResourceSTATUSStashLocal)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field LoadBalancingRules from SubResource_STATUSStash")
			}
			loadBalancingRuleList[loadBalancingRuleIndex] = loadBalancingRule
		}
		embedded.LoadBalancingRules = loadBalancingRuleList
	} else {
		embedded.LoadBalancingRules = nil
	}

	// Name
	embedded.Name = genruntime.ClonePointerToString(source.Name)

	// OutboundRules
	if source.OutboundRules != nil {
		outboundRuleList := make([]SubResource_STATUS, len(source.OutboundRules))
		for outboundRuleIndex, outboundRuleItem := range source.OutboundRules {
			// Shadow the loop variable to avoid aliasing
			outboundRuleItem := outboundRuleItem
			var subResourceSTATUSStash v20240101s.SubResource_STATUS
			err := subResourceSTATUSStash.AssignProperties_From_SubResource_STATUS(&outboundRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SubResource_STATUSStash from OutboundRules")
			}
			var subResourceSTATUSStashLocal v20220701s.SubResource_STATUS
			err = subResourceSTATUSStashLocal.AssignProperties_From_SubResource_STATUS(&subResourceSTATUSStash)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SubResource_STATUSStash")
			}
			var outboundRule SubResource_STATUS
			err = outboundRule.AssignProperties_From_SubResource_STATUS(&subResourceSTATUSStashLocal)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field OutboundRules from SubResource_STATUSStash")
			}
			outboundRuleList[outboundRuleIndex] = outboundRule
		}
		embedded.OutboundRules = outboundRuleList
	} else {
		embedded.OutboundRules = nil
	}

	// PrivateIPAddress
	embedded.PrivateIPAddress = genruntime.ClonePointerToString(source.PrivateIPAddress)

	// PrivateIPAddressVersion
	embedded.PrivateIPAddressVersion = genruntime.ClonePointerToString(source.PrivateIPAddressVersion)

	// PrivateIPAllocationMethod
	embedded.PrivateIPAllocationMethod = genruntime.ClonePointerToString(source.PrivateIPAllocationMethod)

	// ProvisioningState
	embedded.ProvisioningState = genruntime.ClonePointerToString(source.ProvisioningState)

	// PublicIPAddress
	if source.PublicIPAddress != nil {
		var publicIPAddress PublicIPAddress_STATUS_LoadBalancer_SubResourceEmbedded
		err := publicIPAddress.AssignProperties_From_PublicIPAddress_STATUS_LoadBalancer_SubResourceEmbedded(source.PublicIPAddress)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_PublicIPAddress_STATUS_LoadBalancer_SubResourceEmbedded() to populate field PublicIPAddress")
		}
		embedded.PublicIPAddress = &publicIPAddress
	} else {
		embedded.PublicIPAddress = nil
	}

	// PublicIPPrefix
	if source.PublicIPPrefix != nil {
		var subResourceSTATUSStash v20240101s.SubResource_STATUS
		err := subResourceSTATUSStash.AssignProperties_From_SubResource_STATUS(source.PublicIPPrefix)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SubResource_STATUSStash from PublicIPPrefix")
		}
		var subResourceSTATUSStashLocal v20220701s.SubResource_STATUS
		err = subResourceSTATUSStashLocal.AssignProperties_From_SubResource_STATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SubResource_STATUSStash")
		}
		var publicIPPrefix SubResource_STATUS
		err = publicIPPrefix.AssignProperties_From_SubResource_STATUS(&subResourceSTATUSStashLocal)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field PublicIPPrefix from SubResource_STATUSStash")
		}
		embedded.PublicIPPrefix = &publicIPPrefix
	} else {
		embedded.PublicIPPrefix = nil
	}

	// Subnet
	if source.Subnet != nil {
		var subnet Subnet_STATUS_LoadBalancer_SubResourceEmbedded
		err := subnet.AssignProperties_From_Subnet_STATUS_LoadBalancer_SubResourceEmbedded(source.Subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Subnet_STATUS_LoadBalancer_SubResourceEmbedded() to populate field Subnet")
		}
		embedded.Subnet = &subnet
	} else {
		embedded.Subnet = nil
	}

	// Type
	embedded.Type = genruntime.ClonePointerToString(source.Type)

	// Zones
	embedded.Zones = genruntime.CloneSliceOfString(source.Zones)

	// Update the property bag
	if len(propertyBag) > 0 {
		embedded.PropertyBag = propertyBag
	} else {
		embedded.PropertyBag = nil
	}

	// Invoke the augmentConversionForFrontendIPConfiguration_STATUS_LoadBalancer_SubResourceEmbedded interface (if implemented) to customize the conversion
	var embeddedAsAny any = embedded
	if augmentedEmbedded, ok := embeddedAsAny.(augmentConversionForFrontendIPConfiguration_STATUS_LoadBalancer_SubResourceEmbedded); ok {
		err := augmentedEmbedded.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_FrontendIPConfiguration_STATUS_LoadBalancer_SubResourceEmbedded populates the provided destination FrontendIPConfiguration_STATUS_LoadBalancer_SubResourceEmbedded from our FrontendIPConfiguration_STATUS_LoadBalancer_SubResourceEmbedded
func (embedded *FrontendIPConfiguration_STATUS_LoadBalancer_SubResourceEmbedded) AssignProperties_To_FrontendIPConfiguration_STATUS_LoadBalancer_SubResourceEmbedded(destination *v20240301s.FrontendIPConfiguration_STATUS_LoadBalancer_SubResourceEmbedded) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(embedded.PropertyBag)

	// Etag
	destination.Etag = genruntime.ClonePointerToString(embedded.Etag)

	// GatewayLoadBalancer
	if propertyBag.Contains("GatewayLoadBalancer") {
		var gatewayLoadBalancer v20240301s.SubResource_STATUS
		err := propertyBag.Pull("GatewayLoadBalancer", &gatewayLoadBalancer)
		if err != nil {
			return errors.Wrap(err, "pulling 'GatewayLoadBalancer' from propertyBag")
		}

		destination.GatewayLoadBalancer = &gatewayLoadBalancer
	} else {
		destination.GatewayLoadBalancer = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(embedded.Id)

	// InboundNatPools
	if embedded.InboundNatPools != nil {
		inboundNatPoolList := make([]v20240301s.SubResource_STATUS, len(embedded.InboundNatPools))
		for inboundNatPoolIndex, inboundNatPoolItem := range embedded.InboundNatPools {
			// Shadow the loop variable to avoid aliasing
			inboundNatPoolItem := inboundNatPoolItem
			var subResourceSTATUSStash v20220701s.SubResource_STATUS
			err := inboundNatPoolItem.AssignProperties_To_SubResource_STATUS(&subResourceSTATUSStash)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SubResource_STATUSStash from InboundNatPools")
			}
			var subResourceSTATUSStashLocal v20240101s.SubResource_STATUS
			err = subResourceSTATUSStash.AssignProperties_To_SubResource_STATUS(&subResourceSTATUSStashLocal)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SubResource_STATUSStash")
			}
			var inboundNatPool v20240301s.SubResource_STATUS
			err = subResourceSTATUSStashLocal.AssignProperties_To_SubResource_STATUS(&inboundNatPool)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field InboundNatPools from SubResource_STATUSStash")
			}
			inboundNatPoolList[inboundNatPoolIndex] = inboundNatPool
		}
		destination.InboundNatPools = inboundNatPoolList
	} else {
		destination.InboundNatPools = nil
	}

	// InboundNatRules
	if embedded.InboundNatRules != nil {
		inboundNatRuleList := make([]v20240301s.SubResource_STATUS, len(embedded.InboundNatRules))
		for inboundNatRuleIndex, inboundNatRuleItem := range embedded.InboundNatRules {
			// Shadow the loop variable to avoid aliasing
			inboundNatRuleItem := inboundNatRuleItem
			var subResourceSTATUSStash v20220701s.SubResource_STATUS
			err := inboundNatRuleItem.AssignProperties_To_SubResource_STATUS(&subResourceSTATUSStash)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SubResource_STATUSStash from InboundNatRules")
			}
			var subResourceSTATUSStashLocal v20240101s.SubResource_STATUS
			err = subResourceSTATUSStash.AssignProperties_To_SubResource_STATUS(&subResourceSTATUSStashLocal)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SubResource_STATUSStash")
			}
			var inboundNatRule v20240301s.SubResource_STATUS
			err = subResourceSTATUSStashLocal.AssignProperties_To_SubResource_STATUS(&inboundNatRule)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field InboundNatRules from SubResource_STATUSStash")
			}
			inboundNatRuleList[inboundNatRuleIndex] = inboundNatRule
		}
		destination.InboundNatRules = inboundNatRuleList
	} else {
		destination.InboundNatRules = nil
	}

	// LoadBalancingRules
	if embedded.LoadBalancingRules != nil {
		loadBalancingRuleList := make([]v20240301s.SubResource_STATUS, len(embedded.LoadBalancingRules))
		for loadBalancingRuleIndex, loadBalancingRuleItem := range embedded.LoadBalancingRules {
			// Shadow the loop variable to avoid aliasing
			loadBalancingRuleItem := loadBalancingRuleItem
			var subResourceSTATUSStash v20220701s.SubResource_STATUS
			err := loadBalancingRuleItem.AssignProperties_To_SubResource_STATUS(&subResourceSTATUSStash)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SubResource_STATUSStash from LoadBalancingRules")
			}
			var subResourceSTATUSStashLocal v20240101s.SubResource_STATUS
			err = subResourceSTATUSStash.AssignProperties_To_SubResource_STATUS(&subResourceSTATUSStashLocal)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SubResource_STATUSStash")
			}
			var loadBalancingRule v20240301s.SubResource_STATUS
			err = subResourceSTATUSStashLocal.AssignProperties_To_SubResource_STATUS(&loadBalancingRule)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field LoadBalancingRules from SubResource_STATUSStash")
			}
			loadBalancingRuleList[loadBalancingRuleIndex] = loadBalancingRule
		}
		destination.LoadBalancingRules = loadBalancingRuleList
	} else {
		destination.LoadBalancingRules = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(embedded.Name)

	// OutboundRules
	if embedded.OutboundRules != nil {
		outboundRuleList := make([]v20240301s.SubResource_STATUS, len(embedded.OutboundRules))
		for outboundRuleIndex, outboundRuleItem := range embedded.OutboundRules {
			// Shadow the loop variable to avoid aliasing
			outboundRuleItem := outboundRuleItem
			var subResourceSTATUSStash v20220701s.SubResource_STATUS
			err := outboundRuleItem.AssignProperties_To_SubResource_STATUS(&subResourceSTATUSStash)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SubResource_STATUSStash from OutboundRules")
			}
			var subResourceSTATUSStashLocal v20240101s.SubResource_STATUS
			err = subResourceSTATUSStash.AssignProperties_To_SubResource_STATUS(&subResourceSTATUSStashLocal)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SubResource_STATUSStash")
			}
			var outboundRule v20240301s.SubResource_STATUS
			err = subResourceSTATUSStashLocal.AssignProperties_To_SubResource_STATUS(&outboundRule)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field OutboundRules from SubResource_STATUSStash")
			}
			outboundRuleList[outboundRuleIndex] = outboundRule
		}
		destination.OutboundRules = outboundRuleList
	} else {
		destination.OutboundRules = nil
	}

	// PrivateIPAddress
	destination.PrivateIPAddress = genruntime.ClonePointerToString(embedded.PrivateIPAddress)

	// PrivateIPAddressVersion
	destination.PrivateIPAddressVersion = genruntime.ClonePointerToString(embedded.PrivateIPAddressVersion)

	// PrivateIPAllocationMethod
	destination.PrivateIPAllocationMethod = genruntime.ClonePointerToString(embedded.PrivateIPAllocationMethod)

	// ProvisioningState
	destination.ProvisioningState = genruntime.ClonePointerToString(embedded.ProvisioningState)

	// PublicIPAddress
	if embedded.PublicIPAddress != nil {
		var publicIPAddress v20240301s.PublicIPAddress_STATUS_LoadBalancer_SubResourceEmbedded
		err := embedded.PublicIPAddress.AssignProperties_To_PublicIPAddress_STATUS_LoadBalancer_SubResourceEmbedded(&publicIPAddress)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_PublicIPAddress_STATUS_LoadBalancer_SubResourceEmbedded() to populate field PublicIPAddress")
		}
		destination.PublicIPAddress = &publicIPAddress
	} else {
		destination.PublicIPAddress = nil
	}

	// PublicIPPrefix
	if embedded.PublicIPPrefix != nil {
		var subResourceSTATUSStash v20220701s.SubResource_STATUS
		err := embedded.PublicIPPrefix.AssignProperties_To_SubResource_STATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SubResource_STATUSStash from PublicIPPrefix")
		}
		var subResourceSTATUSStashLocal v20240101s.SubResource_STATUS
		err = subResourceSTATUSStash.AssignProperties_To_SubResource_STATUS(&subResourceSTATUSStashLocal)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SubResource_STATUSStash")
		}
		var publicIPPrefix v20240301s.SubResource_STATUS
		err = subResourceSTATUSStashLocal.AssignProperties_To_SubResource_STATUS(&publicIPPrefix)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field PublicIPPrefix from SubResource_STATUSStash")
		}
		destination.PublicIPPrefix = &publicIPPrefix
	} else {
		destination.PublicIPPrefix = nil
	}

	// Subnet
	if embedded.Subnet != nil {
		var subnet v20240301s.Subnet_STATUS_LoadBalancer_SubResourceEmbedded
		err := embedded.Subnet.AssignProperties_To_Subnet_STATUS_LoadBalancer_SubResourceEmbedded(&subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Subnet_STATUS_LoadBalancer_SubResourceEmbedded() to populate field Subnet")
		}
		destination.Subnet = &subnet
	} else {
		destination.Subnet = nil
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(embedded.Type)

	// Zones
	destination.Zones = genruntime.CloneSliceOfString(embedded.Zones)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForFrontendIPConfiguration_STATUS_LoadBalancer_SubResourceEmbedded interface (if implemented) to customize the conversion
	var embeddedAsAny any = embedded
	if augmentedEmbedded, ok := embeddedAsAny.(augmentConversionForFrontendIPConfiguration_STATUS_LoadBalancer_SubResourceEmbedded); ok {
		err := augmentedEmbedded.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201101.InboundNatPool
// Inbound NAT pool of the load balancer.
type InboundNatPool struct {
	BackendPort             *int                   `json:"backendPort,omitempty"`
	EnableFloatingIP        *bool                  `json:"enableFloatingIP,omitempty"`
	EnableTcpReset          *bool                  `json:"enableTcpReset,omitempty"`
	FrontendIPConfiguration *SubResource           `json:"frontendIPConfiguration,omitempty"`
	FrontendPortRangeEnd    *int                   `json:"frontendPortRangeEnd,omitempty"`
	FrontendPortRangeStart  *int                   `json:"frontendPortRangeStart,omitempty"`
	IdleTimeoutInMinutes    *int                   `json:"idleTimeoutInMinutes,omitempty"`
	Name                    *string                `json:"name,omitempty"`
	PropertyBag             genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Protocol                *string                `json:"protocol,omitempty"`
}

// AssignProperties_From_InboundNatPool populates our InboundNatPool from the provided source InboundNatPool
func (pool *InboundNatPool) AssignProperties_From_InboundNatPool(source *v20240301s.InboundNatPool) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// BackendPort
	pool.BackendPort = genruntime.ClonePointerToInt(source.BackendPort)

	// EnableFloatingIP
	if source.EnableFloatingIP != nil {
		enableFloatingIP := *source.EnableFloatingIP
		pool.EnableFloatingIP = &enableFloatingIP
	} else {
		pool.EnableFloatingIP = nil
	}

	// EnableTcpReset
	if source.EnableTcpReset != nil {
		enableTcpReset := *source.EnableTcpReset
		pool.EnableTcpReset = &enableTcpReset
	} else {
		pool.EnableTcpReset = nil
	}

	// FrontendIPConfiguration
	if source.FrontendIPConfiguration != nil {
		var subResourceStash v20220701s.SubResource
		err := subResourceStash.AssignProperties_From_SubResource(source.FrontendIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field SubResourceStash from FrontendIPConfiguration")
		}
		var frontendIPConfiguration SubResource
		err = frontendIPConfiguration.AssignProperties_From_SubResource(&subResourceStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field FrontendIPConfiguration from SubResourceStash")
		}
		pool.FrontendIPConfiguration = &frontendIPConfiguration
	} else {
		pool.FrontendIPConfiguration = nil
	}

	// FrontendPortRangeEnd
	pool.FrontendPortRangeEnd = genruntime.ClonePointerToInt(source.FrontendPortRangeEnd)

	// FrontendPortRangeStart
	pool.FrontendPortRangeStart = genruntime.ClonePointerToInt(source.FrontendPortRangeStart)

	// IdleTimeoutInMinutes
	pool.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(source.IdleTimeoutInMinutes)

	// Name
	pool.Name = genruntime.ClonePointerToString(source.Name)

	// Protocol
	pool.Protocol = genruntime.ClonePointerToString(source.Protocol)

	// Update the property bag
	if len(propertyBag) > 0 {
		pool.PropertyBag = propertyBag
	} else {
		pool.PropertyBag = nil
	}

	// Invoke the augmentConversionForInboundNatPool interface (if implemented) to customize the conversion
	var poolAsAny any = pool
	if augmentedPool, ok := poolAsAny.(augmentConversionForInboundNatPool); ok {
		err := augmentedPool.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_InboundNatPool populates the provided destination InboundNatPool from our InboundNatPool
func (pool *InboundNatPool) AssignProperties_To_InboundNatPool(destination *v20240301s.InboundNatPool) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(pool.PropertyBag)

	// BackendPort
	destination.BackendPort = genruntime.ClonePointerToInt(pool.BackendPort)

	// EnableFloatingIP
	if pool.EnableFloatingIP != nil {
		enableFloatingIP := *pool.EnableFloatingIP
		destination.EnableFloatingIP = &enableFloatingIP
	} else {
		destination.EnableFloatingIP = nil
	}

	// EnableTcpReset
	if pool.EnableTcpReset != nil {
		enableTcpReset := *pool.EnableTcpReset
		destination.EnableTcpReset = &enableTcpReset
	} else {
		destination.EnableTcpReset = nil
	}

	// FrontendIPConfiguration
	if pool.FrontendIPConfiguration != nil {
		var subResourceStash v20220701s.SubResource
		err := pool.FrontendIPConfiguration.AssignProperties_To_SubResource(&subResourceStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field SubResourceStash from FrontendIPConfiguration")
		}
		var frontendIPConfiguration v20240301s.SubResource
		err = subResourceStash.AssignProperties_To_SubResource(&frontendIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field FrontendIPConfiguration from SubResourceStash")
		}
		destination.FrontendIPConfiguration = &frontendIPConfiguration
	} else {
		destination.FrontendIPConfiguration = nil
	}

	// FrontendPortRangeEnd
	destination.FrontendPortRangeEnd = genruntime.ClonePointerToInt(pool.FrontendPortRangeEnd)

	// FrontendPortRangeStart
	destination.FrontendPortRangeStart = genruntime.ClonePointerToInt(pool.FrontendPortRangeStart)

	// IdleTimeoutInMinutes
	destination.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(pool.IdleTimeoutInMinutes)

	// Name
	destination.Name = genruntime.ClonePointerToString(pool.Name)

	// Protocol
	destination.Protocol = genruntime.ClonePointerToString(pool.Protocol)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForInboundNatPool interface (if implemented) to customize the conversion
	var poolAsAny any = pool
	if augmentedPool, ok := poolAsAny.(augmentConversionForInboundNatPool); ok {
		err := augmentedPool.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201101.InboundNatPool_STATUS
// Inbound NAT pool of the load balancer.
type InboundNatPool_STATUS struct {
	BackendPort             *int                   `json:"backendPort,omitempty"`
	EnableFloatingIP        *bool                  `json:"enableFloatingIP,omitempty"`
	EnableTcpReset          *bool                  `json:"enableTcpReset,omitempty"`
	Etag                    *string                `json:"etag,omitempty"`
	FrontendIPConfiguration *SubResource_STATUS    `json:"frontendIPConfiguration,omitempty"`
	FrontendPortRangeEnd    *int                   `json:"frontendPortRangeEnd,omitempty"`
	FrontendPortRangeStart  *int                   `json:"frontendPortRangeStart,omitempty"`
	Id                      *string                `json:"id,omitempty"`
	IdleTimeoutInMinutes    *int                   `json:"idleTimeoutInMinutes,omitempty"`
	Name                    *string                `json:"name,omitempty"`
	PropertyBag             genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Protocol                *string                `json:"protocol,omitempty"`
	ProvisioningState       *string                `json:"provisioningState,omitempty"`
	Type                    *string                `json:"type,omitempty"`
}

// AssignProperties_From_InboundNatPool_STATUS populates our InboundNatPool_STATUS from the provided source InboundNatPool_STATUS
func (pool *InboundNatPool_STATUS) AssignProperties_From_InboundNatPool_STATUS(source *v20240301s.InboundNatPool_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// BackendPort
	pool.BackendPort = genruntime.ClonePointerToInt(source.BackendPort)

	// EnableFloatingIP
	if source.EnableFloatingIP != nil {
		enableFloatingIP := *source.EnableFloatingIP
		pool.EnableFloatingIP = &enableFloatingIP
	} else {
		pool.EnableFloatingIP = nil
	}

	// EnableTcpReset
	if source.EnableTcpReset != nil {
		enableTcpReset := *source.EnableTcpReset
		pool.EnableTcpReset = &enableTcpReset
	} else {
		pool.EnableTcpReset = nil
	}

	// Etag
	pool.Etag = genruntime.ClonePointerToString(source.Etag)

	// FrontendIPConfiguration
	if source.FrontendIPConfiguration != nil {
		var subResourceSTATUSStash v20240101s.SubResource_STATUS
		err := subResourceSTATUSStash.AssignProperties_From_SubResource_STATUS(source.FrontendIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SubResource_STATUSStash from FrontendIPConfiguration")
		}
		var subResourceSTATUSStashLocal v20220701s.SubResource_STATUS
		err = subResourceSTATUSStashLocal.AssignProperties_From_SubResource_STATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SubResource_STATUSStash")
		}
		var frontendIPConfiguration SubResource_STATUS
		err = frontendIPConfiguration.AssignProperties_From_SubResource_STATUS(&subResourceSTATUSStashLocal)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field FrontendIPConfiguration from SubResource_STATUSStash")
		}
		pool.FrontendIPConfiguration = &frontendIPConfiguration
	} else {
		pool.FrontendIPConfiguration = nil
	}

	// FrontendPortRangeEnd
	pool.FrontendPortRangeEnd = genruntime.ClonePointerToInt(source.FrontendPortRangeEnd)

	// FrontendPortRangeStart
	pool.FrontendPortRangeStart = genruntime.ClonePointerToInt(source.FrontendPortRangeStart)

	// Id
	pool.Id = genruntime.ClonePointerToString(source.Id)

	// IdleTimeoutInMinutes
	pool.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(source.IdleTimeoutInMinutes)

	// Name
	pool.Name = genruntime.ClonePointerToString(source.Name)

	// Protocol
	pool.Protocol = genruntime.ClonePointerToString(source.Protocol)

	// ProvisioningState
	pool.ProvisioningState = genruntime.ClonePointerToString(source.ProvisioningState)

	// Type
	pool.Type = genruntime.ClonePointerToString(source.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		pool.PropertyBag = propertyBag
	} else {
		pool.PropertyBag = nil
	}

	// Invoke the augmentConversionForInboundNatPool_STATUS interface (if implemented) to customize the conversion
	var poolAsAny any = pool
	if augmentedPool, ok := poolAsAny.(augmentConversionForInboundNatPool_STATUS); ok {
		err := augmentedPool.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_InboundNatPool_STATUS populates the provided destination InboundNatPool_STATUS from our InboundNatPool_STATUS
func (pool *InboundNatPool_STATUS) AssignProperties_To_InboundNatPool_STATUS(destination *v20240301s.InboundNatPool_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(pool.PropertyBag)

	// BackendPort
	destination.BackendPort = genruntime.ClonePointerToInt(pool.BackendPort)

	// EnableFloatingIP
	if pool.EnableFloatingIP != nil {
		enableFloatingIP := *pool.EnableFloatingIP
		destination.EnableFloatingIP = &enableFloatingIP
	} else {
		destination.EnableFloatingIP = nil
	}

	// EnableTcpReset
	if pool.EnableTcpReset != nil {
		enableTcpReset := *pool.EnableTcpReset
		destination.EnableTcpReset = &enableTcpReset
	} else {
		destination.EnableTcpReset = nil
	}

	// Etag
	destination.Etag = genruntime.ClonePointerToString(pool.Etag)

	// FrontendIPConfiguration
	if pool.FrontendIPConfiguration != nil {
		var subResourceSTATUSStash v20220701s.SubResource_STATUS
		err := pool.FrontendIPConfiguration.AssignProperties_To_SubResource_STATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SubResource_STATUSStash from FrontendIPConfiguration")
		}
		var subResourceSTATUSStashLocal v20240101s.SubResource_STATUS
		err = subResourceSTATUSStash.AssignProperties_To_SubResource_STATUS(&subResourceSTATUSStashLocal)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SubResource_STATUSStash")
		}
		var frontendIPConfiguration v20240301s.SubResource_STATUS
		err = subResourceSTATUSStashLocal.AssignProperties_To_SubResource_STATUS(&frontendIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field FrontendIPConfiguration from SubResource_STATUSStash")
		}
		destination.FrontendIPConfiguration = &frontendIPConfiguration
	} else {
		destination.FrontendIPConfiguration = nil
	}

	// FrontendPortRangeEnd
	destination.FrontendPortRangeEnd = genruntime.ClonePointerToInt(pool.FrontendPortRangeEnd)

	// FrontendPortRangeStart
	destination.FrontendPortRangeStart = genruntime.ClonePointerToInt(pool.FrontendPortRangeStart)

	// Id
	destination.Id = genruntime.ClonePointerToString(pool.Id)

	// IdleTimeoutInMinutes
	destination.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(pool.IdleTimeoutInMinutes)

	// Name
	destination.Name = genruntime.ClonePointerToString(pool.Name)

	// Protocol
	destination.Protocol = genruntime.ClonePointerToString(pool.Protocol)

	// ProvisioningState
	destination.ProvisioningState = genruntime.ClonePointerToString(pool.ProvisioningState)

	// Type
	destination.Type = genruntime.ClonePointerToString(pool.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForInboundNatPool_STATUS interface (if implemented) to customize the conversion
	var poolAsAny any = pool
	if augmentedPool, ok := poolAsAny.(augmentConversionForInboundNatPool_STATUS); ok {
		err := augmentedPool.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201101.InboundNatRule_LoadBalancer_SubResourceEmbedded
// Inbound NAT rule of the load balancer.
type InboundNatRule_LoadBalancer_SubResourceEmbedded struct {
	BackendPort             *int                   `json:"backendPort,omitempty"`
	EnableFloatingIP        *bool                  `json:"enableFloatingIP,omitempty"`
	EnableTcpReset          *bool                  `json:"enableTcpReset,omitempty"`
	FrontendIPConfiguration *SubResource           `json:"frontendIPConfiguration,omitempty"`
	FrontendPort            *int                   `json:"frontendPort,omitempty"`
	IdleTimeoutInMinutes    *int                   `json:"idleTimeoutInMinutes,omitempty"`
	Name                    *string                `json:"name,omitempty"`
	PropertyBag             genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Protocol                *string                `json:"protocol,omitempty"`
}

// AssignProperties_From_InboundNatRule_LoadBalancer_SubResourceEmbedded populates our InboundNatRule_LoadBalancer_SubResourceEmbedded from the provided source InboundNatRule_LoadBalancer_SubResourceEmbedded
func (embedded *InboundNatRule_LoadBalancer_SubResourceEmbedded) AssignProperties_From_InboundNatRule_LoadBalancer_SubResourceEmbedded(source *v20240301s.InboundNatRule_LoadBalancer_SubResourceEmbedded) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// BackendAddressPool
	if source.BackendAddressPool != nil {
		propertyBag.Add("BackendAddressPool", *source.BackendAddressPool)
	} else {
		propertyBag.Remove("BackendAddressPool")
	}

	// BackendPort
	embedded.BackendPort = genruntime.ClonePointerToInt(source.BackendPort)

	// EnableFloatingIP
	if source.EnableFloatingIP != nil {
		enableFloatingIP := *source.EnableFloatingIP
		embedded.EnableFloatingIP = &enableFloatingIP
	} else {
		embedded.EnableFloatingIP = nil
	}

	// EnableTcpReset
	if source.EnableTcpReset != nil {
		enableTcpReset := *source.EnableTcpReset
		embedded.EnableTcpReset = &enableTcpReset
	} else {
		embedded.EnableTcpReset = nil
	}

	// FrontendIPConfiguration
	if source.FrontendIPConfiguration != nil {
		var subResourceStash v20220701s.SubResource
		err := subResourceStash.AssignProperties_From_SubResource(source.FrontendIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field SubResourceStash from FrontendIPConfiguration")
		}
		var frontendIPConfiguration SubResource
		err = frontendIPConfiguration.AssignProperties_From_SubResource(&subResourceStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field FrontendIPConfiguration from SubResourceStash")
		}
		embedded.FrontendIPConfiguration = &frontendIPConfiguration
	} else {
		embedded.FrontendIPConfiguration = nil
	}

	// FrontendPort
	embedded.FrontendPort = genruntime.ClonePointerToInt(source.FrontendPort)

	// FrontendPortRangeEnd
	if source.FrontendPortRangeEnd != nil {
		propertyBag.Add("FrontendPortRangeEnd", *source.FrontendPortRangeEnd)
	} else {
		propertyBag.Remove("FrontendPortRangeEnd")
	}

	// FrontendPortRangeStart
	if source.FrontendPortRangeStart != nil {
		propertyBag.Add("FrontendPortRangeStart", *source.FrontendPortRangeStart)
	} else {
		propertyBag.Remove("FrontendPortRangeStart")
	}

	// IdleTimeoutInMinutes
	embedded.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(source.IdleTimeoutInMinutes)

	// Name
	embedded.Name = genruntime.ClonePointerToString(source.Name)

	// Protocol
	embedded.Protocol = genruntime.ClonePointerToString(source.Protocol)

	// Update the property bag
	if len(propertyBag) > 0 {
		embedded.PropertyBag = propertyBag
	} else {
		embedded.PropertyBag = nil
	}

	// Invoke the augmentConversionForInboundNatRule_LoadBalancer_SubResourceEmbedded interface (if implemented) to customize the conversion
	var embeddedAsAny any = embedded
	if augmentedEmbedded, ok := embeddedAsAny.(augmentConversionForInboundNatRule_LoadBalancer_SubResourceEmbedded); ok {
		err := augmentedEmbedded.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_InboundNatRule_LoadBalancer_SubResourceEmbedded populates the provided destination InboundNatRule_LoadBalancer_SubResourceEmbedded from our InboundNatRule_LoadBalancer_SubResourceEmbedded
func (embedded *InboundNatRule_LoadBalancer_SubResourceEmbedded) AssignProperties_To_InboundNatRule_LoadBalancer_SubResourceEmbedded(destination *v20240301s.InboundNatRule_LoadBalancer_SubResourceEmbedded) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(embedded.PropertyBag)

	// BackendAddressPool
	if propertyBag.Contains("BackendAddressPool") {
		var backendAddressPool v20240301s.SubResource
		err := propertyBag.Pull("BackendAddressPool", &backendAddressPool)
		if err != nil {
			return errors.Wrap(err, "pulling 'BackendAddressPool' from propertyBag")
		}

		destination.BackendAddressPool = &backendAddressPool
	} else {
		destination.BackendAddressPool = nil
	}

	// BackendPort
	destination.BackendPort = genruntime.ClonePointerToInt(embedded.BackendPort)

	// EnableFloatingIP
	if embedded.EnableFloatingIP != nil {
		enableFloatingIP := *embedded.EnableFloatingIP
		destination.EnableFloatingIP = &enableFloatingIP
	} else {
		destination.EnableFloatingIP = nil
	}

	// EnableTcpReset
	if embedded.EnableTcpReset != nil {
		enableTcpReset := *embedded.EnableTcpReset
		destination.EnableTcpReset = &enableTcpReset
	} else {
		destination.EnableTcpReset = nil
	}

	// FrontendIPConfiguration
	if embedded.FrontendIPConfiguration != nil {
		var subResourceStash v20220701s.SubResource
		err := embedded.FrontendIPConfiguration.AssignProperties_To_SubResource(&subResourceStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field SubResourceStash from FrontendIPConfiguration")
		}
		var frontendIPConfiguration v20240301s.SubResource
		err = subResourceStash.AssignProperties_To_SubResource(&frontendIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field FrontendIPConfiguration from SubResourceStash")
		}
		destination.FrontendIPConfiguration = &frontendIPConfiguration
	} else {
		destination.FrontendIPConfiguration = nil
	}

	// FrontendPort
	destination.FrontendPort = genruntime.ClonePointerToInt(embedded.FrontendPort)

	// FrontendPortRangeEnd
	if propertyBag.Contains("FrontendPortRangeEnd") {
		var frontendPortRangeEnd int
		err := propertyBag.Pull("FrontendPortRangeEnd", &frontendPortRangeEnd)
		if err != nil {
			return errors.Wrap(err, "pulling 'FrontendPortRangeEnd' from propertyBag")
		}

		destination.FrontendPortRangeEnd = &frontendPortRangeEnd
	} else {
		destination.FrontendPortRangeEnd = nil
	}

	// FrontendPortRangeStart
	if propertyBag.Contains("FrontendPortRangeStart") {
		var frontendPortRangeStart int
		err := propertyBag.Pull("FrontendPortRangeStart", &frontendPortRangeStart)
		if err != nil {
			return errors.Wrap(err, "pulling 'FrontendPortRangeStart' from propertyBag")
		}

		destination.FrontendPortRangeStart = &frontendPortRangeStart
	} else {
		destination.FrontendPortRangeStart = nil
	}

	// IdleTimeoutInMinutes
	destination.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(embedded.IdleTimeoutInMinutes)

	// Name
	destination.Name = genruntime.ClonePointerToString(embedded.Name)

	// Protocol
	destination.Protocol = genruntime.ClonePointerToString(embedded.Protocol)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForInboundNatRule_LoadBalancer_SubResourceEmbedded interface (if implemented) to customize the conversion
	var embeddedAsAny any = embedded
	if augmentedEmbedded, ok := embeddedAsAny.(augmentConversionForInboundNatRule_LoadBalancer_SubResourceEmbedded); ok {
		err := augmentedEmbedded.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201101.InboundNatRule_STATUS_LoadBalancer_SubResourceEmbedded
// Inbound NAT rule of the load balancer.
type InboundNatRule_STATUS_LoadBalancer_SubResourceEmbedded struct {
	BackendIPConfiguration  *NetworkInterfaceIPConfiguration_STATUS_LoadBalancer_SubResourceEmbedded `json:"backendIPConfiguration,omitempty"`
	BackendPort             *int                                                                     `json:"backendPort,omitempty"`
	EnableFloatingIP        *bool                                                                    `json:"enableFloatingIP,omitempty"`
	EnableTcpReset          *bool                                                                    `json:"enableTcpReset,omitempty"`
	Etag                    *string                                                                  `json:"etag,omitempty"`
	FrontendIPConfiguration *SubResource_STATUS                                                      `json:"frontendIPConfiguration,omitempty"`
	FrontendPort            *int                                                                     `json:"frontendPort,omitempty"`
	Id                      *string                                                                  `json:"id,omitempty"`
	IdleTimeoutInMinutes    *int                                                                     `json:"idleTimeoutInMinutes,omitempty"`
	Name                    *string                                                                  `json:"name,omitempty"`
	PropertyBag             genruntime.PropertyBag                                                   `json:"$propertyBag,omitempty"`
	Protocol                *string                                                                  `json:"protocol,omitempty"`
	ProvisioningState       *string                                                                  `json:"provisioningState,omitempty"`
	Type                    *string                                                                  `json:"type,omitempty"`
}

// AssignProperties_From_InboundNatRule_STATUS_LoadBalancer_SubResourceEmbedded populates our InboundNatRule_STATUS_LoadBalancer_SubResourceEmbedded from the provided source InboundNatRule_STATUS_LoadBalancer_SubResourceEmbedded
func (embedded *InboundNatRule_STATUS_LoadBalancer_SubResourceEmbedded) AssignProperties_From_InboundNatRule_STATUS_LoadBalancer_SubResourceEmbedded(source *v20240301s.InboundNatRule_STATUS_LoadBalancer_SubResourceEmbedded) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// BackendAddressPool
	if source.BackendAddressPool != nil {
		propertyBag.Add("BackendAddressPool", *source.BackendAddressPool)
	} else {
		propertyBag.Remove("BackendAddressPool")
	}

	// BackendIPConfiguration
	if source.BackendIPConfiguration != nil {
		var backendIPConfiguration NetworkInterfaceIPConfiguration_STATUS_LoadBalancer_SubResourceEmbedded
		err := backendIPConfiguration.AssignProperties_From_NetworkInterfaceIPConfiguration_STATUS_LoadBalancer_SubResourceEmbedded(source.BackendIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_NetworkInterfaceIPConfiguration_STATUS_LoadBalancer_SubResourceEmbedded() to populate field BackendIPConfiguration")
		}
		embedded.BackendIPConfiguration = &backendIPConfiguration
	} else {
		embedded.BackendIPConfiguration = nil
	}

	// BackendPort
	embedded.BackendPort = genruntime.ClonePointerToInt(source.BackendPort)

	// EnableFloatingIP
	if source.EnableFloatingIP != nil {
		enableFloatingIP := *source.EnableFloatingIP
		embedded.EnableFloatingIP = &enableFloatingIP
	} else {
		embedded.EnableFloatingIP = nil
	}

	// EnableTcpReset
	if source.EnableTcpReset != nil {
		enableTcpReset := *source.EnableTcpReset
		embedded.EnableTcpReset = &enableTcpReset
	} else {
		embedded.EnableTcpReset = nil
	}

	// Etag
	embedded.Etag = genruntime.ClonePointerToString(source.Etag)

	// FrontendIPConfiguration
	if source.FrontendIPConfiguration != nil {
		var subResourceSTATUSStash v20240101s.SubResource_STATUS
		err := subResourceSTATUSStash.AssignProperties_From_SubResource_STATUS(source.FrontendIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SubResource_STATUSStash from FrontendIPConfiguration")
		}
		var subResourceSTATUSStashLocal v20220701s.SubResource_STATUS
		err = subResourceSTATUSStashLocal.AssignProperties_From_SubResource_STATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SubResource_STATUSStash")
		}
		var frontendIPConfiguration SubResource_STATUS
		err = frontendIPConfiguration.AssignProperties_From_SubResource_STATUS(&subResourceSTATUSStashLocal)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field FrontendIPConfiguration from SubResource_STATUSStash")
		}
		embedded.FrontendIPConfiguration = &frontendIPConfiguration
	} else {
		embedded.FrontendIPConfiguration = nil
	}

	// FrontendPort
	embedded.FrontendPort = genruntime.ClonePointerToInt(source.FrontendPort)

	// FrontendPortRangeEnd
	if source.FrontendPortRangeEnd != nil {
		propertyBag.Add("FrontendPortRangeEnd", *source.FrontendPortRangeEnd)
	} else {
		propertyBag.Remove("FrontendPortRangeEnd")
	}

	// FrontendPortRangeStart
	if source.FrontendPortRangeStart != nil {
		propertyBag.Add("FrontendPortRangeStart", *source.FrontendPortRangeStart)
	} else {
		propertyBag.Remove("FrontendPortRangeStart")
	}

	// Id
	embedded.Id = genruntime.ClonePointerToString(source.Id)

	// IdleTimeoutInMinutes
	embedded.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(source.IdleTimeoutInMinutes)

	// Name
	embedded.Name = genruntime.ClonePointerToString(source.Name)

	// Protocol
	embedded.Protocol = genruntime.ClonePointerToString(source.Protocol)

	// ProvisioningState
	embedded.ProvisioningState = genruntime.ClonePointerToString(source.ProvisioningState)

	// Type
	embedded.Type = genruntime.ClonePointerToString(source.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		embedded.PropertyBag = propertyBag
	} else {
		embedded.PropertyBag = nil
	}

	// Invoke the augmentConversionForInboundNatRule_STATUS_LoadBalancer_SubResourceEmbedded interface (if implemented) to customize the conversion
	var embeddedAsAny any = embedded
	if augmentedEmbedded, ok := embeddedAsAny.(augmentConversionForInboundNatRule_STATUS_LoadBalancer_SubResourceEmbedded); ok {
		err := augmentedEmbedded.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_InboundNatRule_STATUS_LoadBalancer_SubResourceEmbedded populates the provided destination InboundNatRule_STATUS_LoadBalancer_SubResourceEmbedded from our InboundNatRule_STATUS_LoadBalancer_SubResourceEmbedded
func (embedded *InboundNatRule_STATUS_LoadBalancer_SubResourceEmbedded) AssignProperties_To_InboundNatRule_STATUS_LoadBalancer_SubResourceEmbedded(destination *v20240301s.InboundNatRule_STATUS_LoadBalancer_SubResourceEmbedded) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(embedded.PropertyBag)

	// BackendAddressPool
	if propertyBag.Contains("BackendAddressPool") {
		var backendAddressPool v20240301s.SubResource_STATUS
		err := propertyBag.Pull("BackendAddressPool", &backendAddressPool)
		if err != nil {
			return errors.Wrap(err, "pulling 'BackendAddressPool' from propertyBag")
		}

		destination.BackendAddressPool = &backendAddressPool
	} else {
		destination.BackendAddressPool = nil
	}

	// BackendIPConfiguration
	if embedded.BackendIPConfiguration != nil {
		var backendIPConfiguration v20240301s.NetworkInterfaceIPConfiguration_STATUS_LoadBalancer_SubResourceEmbedded
		err := embedded.BackendIPConfiguration.AssignProperties_To_NetworkInterfaceIPConfiguration_STATUS_LoadBalancer_SubResourceEmbedded(&backendIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_NetworkInterfaceIPConfiguration_STATUS_LoadBalancer_SubResourceEmbedded() to populate field BackendIPConfiguration")
		}
		destination.BackendIPConfiguration = &backendIPConfiguration
	} else {
		destination.BackendIPConfiguration = nil
	}

	// BackendPort
	destination.BackendPort = genruntime.ClonePointerToInt(embedded.BackendPort)

	// EnableFloatingIP
	if embedded.EnableFloatingIP != nil {
		enableFloatingIP := *embedded.EnableFloatingIP
		destination.EnableFloatingIP = &enableFloatingIP
	} else {
		destination.EnableFloatingIP = nil
	}

	// EnableTcpReset
	if embedded.EnableTcpReset != nil {
		enableTcpReset := *embedded.EnableTcpReset
		destination.EnableTcpReset = &enableTcpReset
	} else {
		destination.EnableTcpReset = nil
	}

	// Etag
	destination.Etag = genruntime.ClonePointerToString(embedded.Etag)

	// FrontendIPConfiguration
	if embedded.FrontendIPConfiguration != nil {
		var subResourceSTATUSStash v20220701s.SubResource_STATUS
		err := embedded.FrontendIPConfiguration.AssignProperties_To_SubResource_STATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SubResource_STATUSStash from FrontendIPConfiguration")
		}
		var subResourceSTATUSStashLocal v20240101s.SubResource_STATUS
		err = subResourceSTATUSStash.AssignProperties_To_SubResource_STATUS(&subResourceSTATUSStashLocal)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SubResource_STATUSStash")
		}
		var frontendIPConfiguration v20240301s.SubResource_STATUS
		err = subResourceSTATUSStashLocal.AssignProperties_To_SubResource_STATUS(&frontendIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field FrontendIPConfiguration from SubResource_STATUSStash")
		}
		destination.FrontendIPConfiguration = &frontendIPConfiguration
	} else {
		destination.FrontendIPConfiguration = nil
	}

	// FrontendPort
	destination.FrontendPort = genruntime.ClonePointerToInt(embedded.FrontendPort)

	// FrontendPortRangeEnd
	if propertyBag.Contains("FrontendPortRangeEnd") {
		var frontendPortRangeEnd int
		err := propertyBag.Pull("FrontendPortRangeEnd", &frontendPortRangeEnd)
		if err != nil {
			return errors.Wrap(err, "pulling 'FrontendPortRangeEnd' from propertyBag")
		}

		destination.FrontendPortRangeEnd = &frontendPortRangeEnd
	} else {
		destination.FrontendPortRangeEnd = nil
	}

	// FrontendPortRangeStart
	if propertyBag.Contains("FrontendPortRangeStart") {
		var frontendPortRangeStart int
		err := propertyBag.Pull("FrontendPortRangeStart", &frontendPortRangeStart)
		if err != nil {
			return errors.Wrap(err, "pulling 'FrontendPortRangeStart' from propertyBag")
		}

		destination.FrontendPortRangeStart = &frontendPortRangeStart
	} else {
		destination.FrontendPortRangeStart = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(embedded.Id)

	// IdleTimeoutInMinutes
	destination.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(embedded.IdleTimeoutInMinutes)

	// Name
	destination.Name = genruntime.ClonePointerToString(embedded.Name)

	// Protocol
	destination.Protocol = genruntime.ClonePointerToString(embedded.Protocol)

	// ProvisioningState
	destination.ProvisioningState = genruntime.ClonePointerToString(embedded.ProvisioningState)

	// Type
	destination.Type = genruntime.ClonePointerToString(embedded.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForInboundNatRule_STATUS_LoadBalancer_SubResourceEmbedded interface (if implemented) to customize the conversion
	var embeddedAsAny any = embedded
	if augmentedEmbedded, ok := embeddedAsAny.(augmentConversionForInboundNatRule_STATUS_LoadBalancer_SubResourceEmbedded); ok {
		err := augmentedEmbedded.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201101.LoadBalancerOperatorSpec
// Details for configuring operator behavior. Fields in this struct are interpreted by the operator directly rather than being passed to Azure
type LoadBalancerOperatorSpec struct {
	ConfigMapExpressions []*core.DestinationExpression `json:"configMapExpressions,omitempty"`
	PropertyBag          genruntime.PropertyBag        `json:"$propertyBag,omitempty"`
	SecretExpressions    []*core.DestinationExpression `json:"secretExpressions,omitempty"`
}

// AssignProperties_From_LoadBalancerOperatorSpec populates our LoadBalancerOperatorSpec from the provided source LoadBalancerOperatorSpec
func (operator *LoadBalancerOperatorSpec) AssignProperties_From_LoadBalancerOperatorSpec(source *v20240301s.LoadBalancerOperatorSpec) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ConfigMapExpressions
	if source.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(source.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range source.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		operator.ConfigMapExpressions = configMapExpressionList
	} else {
		operator.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if source.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(source.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range source.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		operator.SecretExpressions = secretExpressionList
	} else {
		operator.SecretExpressions = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		operator.PropertyBag = propertyBag
	} else {
		operator.PropertyBag = nil
	}

	// Invoke the augmentConversionForLoadBalancerOperatorSpec interface (if implemented) to customize the conversion
	var operatorAsAny any = operator
	if augmentedOperator, ok := operatorAsAny.(augmentConversionForLoadBalancerOperatorSpec); ok {
		err := augmentedOperator.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_LoadBalancerOperatorSpec populates the provided destination LoadBalancerOperatorSpec from our LoadBalancerOperatorSpec
func (operator *LoadBalancerOperatorSpec) AssignProperties_To_LoadBalancerOperatorSpec(destination *v20240301s.LoadBalancerOperatorSpec) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(operator.PropertyBag)

	// ConfigMapExpressions
	if operator.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(operator.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range operator.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		destination.ConfigMapExpressions = configMapExpressionList
	} else {
		destination.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if operator.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(operator.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range operator.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		destination.SecretExpressions = secretExpressionList
	} else {
		destination.SecretExpressions = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForLoadBalancerOperatorSpec interface (if implemented) to customize the conversion
	var operatorAsAny any = operator
	if augmentedOperator, ok := operatorAsAny.(augmentConversionForLoadBalancerOperatorSpec); ok {
		err := augmentedOperator.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201101.LoadBalancerSku
// SKU of a load balancer.
type LoadBalancerSku struct {
	Name        *string                `json:"name,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Tier        *string                `json:"tier,omitempty"`
}

// AssignProperties_From_LoadBalancerSku populates our LoadBalancerSku from the provided source LoadBalancerSku
func (balancerSku *LoadBalancerSku) AssignProperties_From_LoadBalancerSku(source *v20240301s.LoadBalancerSku) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	balancerSku.Name = genruntime.ClonePointerToString(source.Name)

	// Tier
	balancerSku.Tier = genruntime.ClonePointerToString(source.Tier)

	// Update the property bag
	if len(propertyBag) > 0 {
		balancerSku.PropertyBag = propertyBag
	} else {
		balancerSku.PropertyBag = nil
	}

	// Invoke the augmentConversionForLoadBalancerSku interface (if implemented) to customize the conversion
	var balancerSkuAsAny any = balancerSku
	if augmentedBalancerSku, ok := balancerSkuAsAny.(augmentConversionForLoadBalancerSku); ok {
		err := augmentedBalancerSku.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_LoadBalancerSku populates the provided destination LoadBalancerSku from our LoadBalancerSku
func (balancerSku *LoadBalancerSku) AssignProperties_To_LoadBalancerSku(destination *v20240301s.LoadBalancerSku) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(balancerSku.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(balancerSku.Name)

	// Tier
	destination.Tier = genruntime.ClonePointerToString(balancerSku.Tier)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForLoadBalancerSku interface (if implemented) to customize the conversion
	var balancerSkuAsAny any = balancerSku
	if augmentedBalancerSku, ok := balancerSkuAsAny.(augmentConversionForLoadBalancerSku); ok {
		err := augmentedBalancerSku.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201101.LoadBalancerSku_STATUS
// SKU of a load balancer.
type LoadBalancerSku_STATUS struct {
	Name        *string                `json:"name,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Tier        *string                `json:"tier,omitempty"`
}

// AssignProperties_From_LoadBalancerSku_STATUS populates our LoadBalancerSku_STATUS from the provided source LoadBalancerSku_STATUS
func (balancerSku *LoadBalancerSku_STATUS) AssignProperties_From_LoadBalancerSku_STATUS(source *v20240301s.LoadBalancerSku_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	balancerSku.Name = genruntime.ClonePointerToString(source.Name)

	// Tier
	balancerSku.Tier = genruntime.ClonePointerToString(source.Tier)

	// Update the property bag
	if len(propertyBag) > 0 {
		balancerSku.PropertyBag = propertyBag
	} else {
		balancerSku.PropertyBag = nil
	}

	// Invoke the augmentConversionForLoadBalancerSku_STATUS interface (if implemented) to customize the conversion
	var balancerSkuAsAny any = balancerSku
	if augmentedBalancerSku, ok := balancerSkuAsAny.(augmentConversionForLoadBalancerSku_STATUS); ok {
		err := augmentedBalancerSku.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_LoadBalancerSku_STATUS populates the provided destination LoadBalancerSku_STATUS from our LoadBalancerSku_STATUS
func (balancerSku *LoadBalancerSku_STATUS) AssignProperties_To_LoadBalancerSku_STATUS(destination *v20240301s.LoadBalancerSku_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(balancerSku.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(balancerSku.Name)

	// Tier
	destination.Tier = genruntime.ClonePointerToString(balancerSku.Tier)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForLoadBalancerSku_STATUS interface (if implemented) to customize the conversion
	var balancerSkuAsAny any = balancerSku
	if augmentedBalancerSku, ok := balancerSkuAsAny.(augmentConversionForLoadBalancerSku_STATUS); ok {
		err := augmentedBalancerSku.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201101.LoadBalancingRule
// A load balancing rule for a load balancer.
type LoadBalancingRule struct {
	BackendAddressPool      *SubResource           `json:"backendAddressPool,omitempty"`
	BackendPort             *int                   `json:"backendPort,omitempty"`
	DisableOutboundSnat     *bool                  `json:"disableOutboundSnat,omitempty"`
	EnableFloatingIP        *bool                  `json:"enableFloatingIP,omitempty"`
	EnableTcpReset          *bool                  `json:"enableTcpReset,omitempty"`
	FrontendIPConfiguration *SubResource           `json:"frontendIPConfiguration,omitempty"`
	FrontendPort            *int                   `json:"frontendPort,omitempty"`
	IdleTimeoutInMinutes    *int                   `json:"idleTimeoutInMinutes,omitempty"`
	LoadDistribution        *string                `json:"loadDistribution,omitempty"`
	Name                    *string                `json:"name,omitempty"`
	Probe                   *SubResource           `json:"probe,omitempty"`
	PropertyBag             genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Protocol                *string                `json:"protocol,omitempty"`
}

// AssignProperties_From_LoadBalancingRule populates our LoadBalancingRule from the provided source LoadBalancingRule
func (rule *LoadBalancingRule) AssignProperties_From_LoadBalancingRule(source *v20240301s.LoadBalancingRule) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// BackendAddressPool
	if source.BackendAddressPool != nil {
		var subResourceStash v20220701s.SubResource
		err := subResourceStash.AssignProperties_From_SubResource(source.BackendAddressPool)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field SubResourceStash from BackendAddressPool")
		}
		var backendAddressPool SubResource
		err = backendAddressPool.AssignProperties_From_SubResource(&subResourceStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field BackendAddressPool from SubResourceStash")
		}
		rule.BackendAddressPool = &backendAddressPool
	} else {
		rule.BackendAddressPool = nil
	}

	// BackendAddressPools
	if len(source.BackendAddressPools) > 0 {
		propertyBag.Add("BackendAddressPools", source.BackendAddressPools)
	} else {
		propertyBag.Remove("BackendAddressPools")
	}

	// BackendPort
	rule.BackendPort = genruntime.ClonePointerToInt(source.BackendPort)

	// DisableOutboundSnat
	if source.DisableOutboundSnat != nil {
		disableOutboundSnat := *source.DisableOutboundSnat
		rule.DisableOutboundSnat = &disableOutboundSnat
	} else {
		rule.DisableOutboundSnat = nil
	}

	// EnableFloatingIP
	if source.EnableFloatingIP != nil {
		enableFloatingIP := *source.EnableFloatingIP
		rule.EnableFloatingIP = &enableFloatingIP
	} else {
		rule.EnableFloatingIP = nil
	}

	// EnableTcpReset
	if source.EnableTcpReset != nil {
		enableTcpReset := *source.EnableTcpReset
		rule.EnableTcpReset = &enableTcpReset
	} else {
		rule.EnableTcpReset = nil
	}

	// FrontendIPConfiguration
	if source.FrontendIPConfiguration != nil {
		var subResourceStash v20220701s.SubResource
		err := subResourceStash.AssignProperties_From_SubResource(source.FrontendIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field SubResourceStash from FrontendIPConfiguration")
		}
		var frontendIPConfiguration SubResource
		err = frontendIPConfiguration.AssignProperties_From_SubResource(&subResourceStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field FrontendIPConfiguration from SubResourceStash")
		}
		rule.FrontendIPConfiguration = &frontendIPConfiguration
	} else {
		rule.FrontendIPConfiguration = nil
	}

	// FrontendPort
	rule.FrontendPort = genruntime.ClonePointerToInt(source.FrontendPort)

	// IdleTimeoutInMinutes
	rule.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(source.IdleTimeoutInMinutes)

	// LoadDistribution
	rule.LoadDistribution = genruntime.ClonePointerToString(source.LoadDistribution)

	// Name
	rule.Name = genruntime.ClonePointerToString(source.Name)

	// Probe
	if source.Probe != nil {
		var subResourceStash v20220701s.SubResource
		err := subResourceStash.AssignProperties_From_SubResource(source.Probe)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field SubResourceStash from Probe")
		}
		var probe SubResource
		err = probe.AssignProperties_From_SubResource(&subResourceStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field Probe from SubResourceStash")
		}
		rule.Probe = &probe
	} else {
		rule.Probe = nil
	}

	// Protocol
	rule.Protocol = genruntime.ClonePointerToString(source.Protocol)

	// Update the property bag
	if len(propertyBag) > 0 {
		rule.PropertyBag = propertyBag
	} else {
		rule.PropertyBag = nil
	}

	// Invoke the augmentConversionForLoadBalancingRule interface (if implemented) to customize the conversion
	var ruleAsAny any = rule
	if augmentedRule, ok := ruleAsAny.(augmentConversionForLoadBalancingRule); ok {
		err := augmentedRule.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_LoadBalancingRule populates the provided destination LoadBalancingRule from our LoadBalancingRule
func (rule *LoadBalancingRule) AssignProperties_To_LoadBalancingRule(destination *v20240301s.LoadBalancingRule) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(rule.PropertyBag)

	// BackendAddressPool
	if rule.BackendAddressPool != nil {
		var subResourceStash v20220701s.SubResource
		err := rule.BackendAddressPool.AssignProperties_To_SubResource(&subResourceStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field SubResourceStash from BackendAddressPool")
		}
		var backendAddressPool v20240301s.SubResource
		err = subResourceStash.AssignProperties_To_SubResource(&backendAddressPool)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field BackendAddressPool from SubResourceStash")
		}
		destination.BackendAddressPool = &backendAddressPool
	} else {
		destination.BackendAddressPool = nil
	}

	// BackendAddressPools
	if propertyBag.Contains("BackendAddressPools") {
		var backendAddressPool []v20240301s.SubResource
		err := propertyBag.Pull("BackendAddressPools", &backendAddressPool)
		if err != nil {
			return errors.Wrap(err, "pulling 'BackendAddressPools' from propertyBag")
		}

		destination.BackendAddressPools = backendAddressPool
	} else {
		destination.BackendAddressPools = nil
	}

	// BackendPort
	destination.BackendPort = genruntime.ClonePointerToInt(rule.BackendPort)

	// DisableOutboundSnat
	if rule.DisableOutboundSnat != nil {
		disableOutboundSnat := *rule.DisableOutboundSnat
		destination.DisableOutboundSnat = &disableOutboundSnat
	} else {
		destination.DisableOutboundSnat = nil
	}

	// EnableFloatingIP
	if rule.EnableFloatingIP != nil {
		enableFloatingIP := *rule.EnableFloatingIP
		destination.EnableFloatingIP = &enableFloatingIP
	} else {
		destination.EnableFloatingIP = nil
	}

	// EnableTcpReset
	if rule.EnableTcpReset != nil {
		enableTcpReset := *rule.EnableTcpReset
		destination.EnableTcpReset = &enableTcpReset
	} else {
		destination.EnableTcpReset = nil
	}

	// FrontendIPConfiguration
	if rule.FrontendIPConfiguration != nil {
		var subResourceStash v20220701s.SubResource
		err := rule.FrontendIPConfiguration.AssignProperties_To_SubResource(&subResourceStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field SubResourceStash from FrontendIPConfiguration")
		}
		var frontendIPConfiguration v20240301s.SubResource
		err = subResourceStash.AssignProperties_To_SubResource(&frontendIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field FrontendIPConfiguration from SubResourceStash")
		}
		destination.FrontendIPConfiguration = &frontendIPConfiguration
	} else {
		destination.FrontendIPConfiguration = nil
	}

	// FrontendPort
	destination.FrontendPort = genruntime.ClonePointerToInt(rule.FrontendPort)

	// IdleTimeoutInMinutes
	destination.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(rule.IdleTimeoutInMinutes)

	// LoadDistribution
	destination.LoadDistribution = genruntime.ClonePointerToString(rule.LoadDistribution)

	// Name
	destination.Name = genruntime.ClonePointerToString(rule.Name)

	// Probe
	if rule.Probe != nil {
		var subResourceStash v20220701s.SubResource
		err := rule.Probe.AssignProperties_To_SubResource(&subResourceStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field SubResourceStash from Probe")
		}
		var probe v20240301s.SubResource
		err = subResourceStash.AssignProperties_To_SubResource(&probe)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field Probe from SubResourceStash")
		}
		destination.Probe = &probe
	} else {
		destination.Probe = nil
	}

	// Protocol
	destination.Protocol = genruntime.ClonePointerToString(rule.Protocol)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForLoadBalancingRule interface (if implemented) to customize the conversion
	var ruleAsAny any = rule
	if augmentedRule, ok := ruleAsAny.(augmentConversionForLoadBalancingRule); ok {
		err := augmentedRule.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201101.LoadBalancingRule_STATUS
// A load balancing rule for a load balancer.
type LoadBalancingRule_STATUS struct {
	BackendAddressPool      *SubResource_STATUS    `json:"backendAddressPool,omitempty"`
	BackendPort             *int                   `json:"backendPort,omitempty"`
	DisableOutboundSnat     *bool                  `json:"disableOutboundSnat,omitempty"`
	EnableFloatingIP        *bool                  `json:"enableFloatingIP,omitempty"`
	EnableTcpReset          *bool                  `json:"enableTcpReset,omitempty"`
	Etag                    *string                `json:"etag,omitempty"`
	FrontendIPConfiguration *SubResource_STATUS    `json:"frontendIPConfiguration,omitempty"`
	FrontendPort            *int                   `json:"frontendPort,omitempty"`
	Id                      *string                `json:"id,omitempty"`
	IdleTimeoutInMinutes    *int                   `json:"idleTimeoutInMinutes,omitempty"`
	LoadDistribution        *string                `json:"loadDistribution,omitempty"`
	Name                    *string                `json:"name,omitempty"`
	Probe                   *SubResource_STATUS    `json:"probe,omitempty"`
	PropertyBag             genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Protocol                *string                `json:"protocol,omitempty"`
	ProvisioningState       *string                `json:"provisioningState,omitempty"`
	Type                    *string                `json:"type,omitempty"`
}

// AssignProperties_From_LoadBalancingRule_STATUS populates our LoadBalancingRule_STATUS from the provided source LoadBalancingRule_STATUS
func (rule *LoadBalancingRule_STATUS) AssignProperties_From_LoadBalancingRule_STATUS(source *v20240301s.LoadBalancingRule_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// BackendAddressPool
	if source.BackendAddressPool != nil {
		var subResourceSTATUSStash v20240101s.SubResource_STATUS
		err := subResourceSTATUSStash.AssignProperties_From_SubResource_STATUS(source.BackendAddressPool)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SubResource_STATUSStash from BackendAddressPool")
		}
		var subResourceSTATUSStashLocal v20220701s.SubResource_STATUS
		err = subResourceSTATUSStashLocal.AssignProperties_From_SubResource_STATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SubResource_STATUSStash")
		}
		var backendAddressPool SubResource_STATUS
		err = backendAddressPool.AssignProperties_From_SubResource_STATUS(&subResourceSTATUSStashLocal)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field BackendAddressPool from SubResource_STATUSStash")
		}
		rule.BackendAddressPool = &backendAddressPool
	} else {
		rule.BackendAddressPool = nil
	}

	// BackendAddressPools
	if len(source.BackendAddressPools) > 0 {
		propertyBag.Add("BackendAddressPools", source.BackendAddressPools)
	} else {
		propertyBag.Remove("BackendAddressPools")
	}

	// BackendPort
	rule.BackendPort = genruntime.ClonePointerToInt(source.BackendPort)

	// DisableOutboundSnat
	if source.DisableOutboundSnat != nil {
		disableOutboundSnat := *source.DisableOutboundSnat
		rule.DisableOutboundSnat = &disableOutboundSnat
	} else {
		rule.DisableOutboundSnat = nil
	}

	// EnableFloatingIP
	if source.EnableFloatingIP != nil {
		enableFloatingIP := *source.EnableFloatingIP
		rule.EnableFloatingIP = &enableFloatingIP
	} else {
		rule.EnableFloatingIP = nil
	}

	// EnableTcpReset
	if source.EnableTcpReset != nil {
		enableTcpReset := *source.EnableTcpReset
		rule.EnableTcpReset = &enableTcpReset
	} else {
		rule.EnableTcpReset = nil
	}

	// Etag
	rule.Etag = genruntime.ClonePointerToString(source.Etag)

	// FrontendIPConfiguration
	if source.FrontendIPConfiguration != nil {
		var subResourceSTATUSStash v20240101s.SubResource_STATUS
		err := subResourceSTATUSStash.AssignProperties_From_SubResource_STATUS(source.FrontendIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SubResource_STATUSStash from FrontendIPConfiguration")
		}
		var subResourceSTATUSStashLocal v20220701s.SubResource_STATUS
		err = subResourceSTATUSStashLocal.AssignProperties_From_SubResource_STATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SubResource_STATUSStash")
		}
		var frontendIPConfiguration SubResource_STATUS
		err = frontendIPConfiguration.AssignProperties_From_SubResource_STATUS(&subResourceSTATUSStashLocal)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field FrontendIPConfiguration from SubResource_STATUSStash")
		}
		rule.FrontendIPConfiguration = &frontendIPConfiguration
	} else {
		rule.FrontendIPConfiguration = nil
	}

	// FrontendPort
	rule.FrontendPort = genruntime.ClonePointerToInt(source.FrontendPort)

	// Id
	rule.Id = genruntime.ClonePointerToString(source.Id)

	// IdleTimeoutInMinutes
	rule.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(source.IdleTimeoutInMinutes)

	// LoadDistribution
	rule.LoadDistribution = genruntime.ClonePointerToString(source.LoadDistribution)

	// Name
	rule.Name = genruntime.ClonePointerToString(source.Name)

	// Probe
	if source.Probe != nil {
		var subResourceSTATUSStash v20240101s.SubResource_STATUS
		err := subResourceSTATUSStash.AssignProperties_From_SubResource_STATUS(source.Probe)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SubResource_STATUSStash from Probe")
		}
		var subResourceSTATUSStashLocal v20220701s.SubResource_STATUS
		err = subResourceSTATUSStashLocal.AssignProperties_From_SubResource_STATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SubResource_STATUSStash")
		}
		var probe SubResource_STATUS
		err = probe.AssignProperties_From_SubResource_STATUS(&subResourceSTATUSStashLocal)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field Probe from SubResource_STATUSStash")
		}
		rule.Probe = &probe
	} else {
		rule.Probe = nil
	}

	// Protocol
	rule.Protocol = genruntime.ClonePointerToString(source.Protocol)

	// ProvisioningState
	rule.ProvisioningState = genruntime.ClonePointerToString(source.ProvisioningState)

	// Type
	rule.Type = genruntime.ClonePointerToString(source.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		rule.PropertyBag = propertyBag
	} else {
		rule.PropertyBag = nil
	}

	// Invoke the augmentConversionForLoadBalancingRule_STATUS interface (if implemented) to customize the conversion
	var ruleAsAny any = rule
	if augmentedRule, ok := ruleAsAny.(augmentConversionForLoadBalancingRule_STATUS); ok {
		err := augmentedRule.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_LoadBalancingRule_STATUS populates the provided destination LoadBalancingRule_STATUS from our LoadBalancingRule_STATUS
func (rule *LoadBalancingRule_STATUS) AssignProperties_To_LoadBalancingRule_STATUS(destination *v20240301s.LoadBalancingRule_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(rule.PropertyBag)

	// BackendAddressPool
	if rule.BackendAddressPool != nil {
		var subResourceSTATUSStash v20220701s.SubResource_STATUS
		err := rule.BackendAddressPool.AssignProperties_To_SubResource_STATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SubResource_STATUSStash from BackendAddressPool")
		}
		var subResourceSTATUSStashLocal v20240101s.SubResource_STATUS
		err = subResourceSTATUSStash.AssignProperties_To_SubResource_STATUS(&subResourceSTATUSStashLocal)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SubResource_STATUSStash")
		}
		var backendAddressPool v20240301s.SubResource_STATUS
		err = subResourceSTATUSStashLocal.AssignProperties_To_SubResource_STATUS(&backendAddressPool)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field BackendAddressPool from SubResource_STATUSStash")
		}
		destination.BackendAddressPool = &backendAddressPool
	} else {
		destination.BackendAddressPool = nil
	}

	// BackendAddressPools
	if propertyBag.Contains("BackendAddressPools") {
		var backendAddressPool []v20240301s.SubResource_STATUS
		err := propertyBag.Pull("BackendAddressPools", &backendAddressPool)
		if err != nil {
			return errors.Wrap(err, "pulling 'BackendAddressPools' from propertyBag")
		}

		destination.BackendAddressPools = backendAddressPool
	} else {
		destination.BackendAddressPools = nil
	}

	// BackendPort
	destination.BackendPort = genruntime.ClonePointerToInt(rule.BackendPort)

	// DisableOutboundSnat
	if rule.DisableOutboundSnat != nil {
		disableOutboundSnat := *rule.DisableOutboundSnat
		destination.DisableOutboundSnat = &disableOutboundSnat
	} else {
		destination.DisableOutboundSnat = nil
	}

	// EnableFloatingIP
	if rule.EnableFloatingIP != nil {
		enableFloatingIP := *rule.EnableFloatingIP
		destination.EnableFloatingIP = &enableFloatingIP
	} else {
		destination.EnableFloatingIP = nil
	}

	// EnableTcpReset
	if rule.EnableTcpReset != nil {
		enableTcpReset := *rule.EnableTcpReset
		destination.EnableTcpReset = &enableTcpReset
	} else {
		destination.EnableTcpReset = nil
	}

	// Etag
	destination.Etag = genruntime.ClonePointerToString(rule.Etag)

	// FrontendIPConfiguration
	if rule.FrontendIPConfiguration != nil {
		var subResourceSTATUSStash v20220701s.SubResource_STATUS
		err := rule.FrontendIPConfiguration.AssignProperties_To_SubResource_STATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SubResource_STATUSStash from FrontendIPConfiguration")
		}
		var subResourceSTATUSStashLocal v20240101s.SubResource_STATUS
		err = subResourceSTATUSStash.AssignProperties_To_SubResource_STATUS(&subResourceSTATUSStashLocal)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SubResource_STATUSStash")
		}
		var frontendIPConfiguration v20240301s.SubResource_STATUS
		err = subResourceSTATUSStashLocal.AssignProperties_To_SubResource_STATUS(&frontendIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field FrontendIPConfiguration from SubResource_STATUSStash")
		}
		destination.FrontendIPConfiguration = &frontendIPConfiguration
	} else {
		destination.FrontendIPConfiguration = nil
	}

	// FrontendPort
	destination.FrontendPort = genruntime.ClonePointerToInt(rule.FrontendPort)

	// Id
	destination.Id = genruntime.ClonePointerToString(rule.Id)

	// IdleTimeoutInMinutes
	destination.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(rule.IdleTimeoutInMinutes)

	// LoadDistribution
	destination.LoadDistribution = genruntime.ClonePointerToString(rule.LoadDistribution)

	// Name
	destination.Name = genruntime.ClonePointerToString(rule.Name)

	// Probe
	if rule.Probe != nil {
		var subResourceSTATUSStash v20220701s.SubResource_STATUS
		err := rule.Probe.AssignProperties_To_SubResource_STATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SubResource_STATUSStash from Probe")
		}
		var subResourceSTATUSStashLocal v20240101s.SubResource_STATUS
		err = subResourceSTATUSStash.AssignProperties_To_SubResource_STATUS(&subResourceSTATUSStashLocal)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SubResource_STATUSStash")
		}
		var probe v20240301s.SubResource_STATUS
		err = subResourceSTATUSStashLocal.AssignProperties_To_SubResource_STATUS(&probe)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field Probe from SubResource_STATUSStash")
		}
		destination.Probe = &probe
	} else {
		destination.Probe = nil
	}

	// Protocol
	destination.Protocol = genruntime.ClonePointerToString(rule.Protocol)

	// ProvisioningState
	destination.ProvisioningState = genruntime.ClonePointerToString(rule.ProvisioningState)

	// Type
	destination.Type = genruntime.ClonePointerToString(rule.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForLoadBalancingRule_STATUS interface (if implemented) to customize the conversion
	var ruleAsAny any = rule
	if augmentedRule, ok := ruleAsAny.(augmentConversionForLoadBalancingRule_STATUS); ok {
		err := augmentedRule.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201101.OutboundRule
// Outbound rule of the load balancer.
type OutboundRule struct {
	AllocatedOutboundPorts   *int                   `json:"allocatedOutboundPorts,omitempty"`
	BackendAddressPool       *SubResource           `json:"backendAddressPool,omitempty"`
	EnableTcpReset           *bool                  `json:"enableTcpReset,omitempty"`
	FrontendIPConfigurations []SubResource          `json:"frontendIPConfigurations,omitempty"`
	IdleTimeoutInMinutes     *int                   `json:"idleTimeoutInMinutes,omitempty"`
	Name                     *string                `json:"name,omitempty"`
	PropertyBag              genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Protocol                 *string                `json:"protocol,omitempty"`
}

// AssignProperties_From_OutboundRule populates our OutboundRule from the provided source OutboundRule
func (rule *OutboundRule) AssignProperties_From_OutboundRule(source *v20240301s.OutboundRule) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AllocatedOutboundPorts
	rule.AllocatedOutboundPorts = genruntime.ClonePointerToInt(source.AllocatedOutboundPorts)

	// BackendAddressPool
	if source.BackendAddressPool != nil {
		var subResourceStash v20220701s.SubResource
		err := subResourceStash.AssignProperties_From_SubResource(source.BackendAddressPool)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field SubResourceStash from BackendAddressPool")
		}
		var backendAddressPool SubResource
		err = backendAddressPool.AssignProperties_From_SubResource(&subResourceStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field BackendAddressPool from SubResourceStash")
		}
		rule.BackendAddressPool = &backendAddressPool
	} else {
		rule.BackendAddressPool = nil
	}

	// EnableTcpReset
	if source.EnableTcpReset != nil {
		enableTcpReset := *source.EnableTcpReset
		rule.EnableTcpReset = &enableTcpReset
	} else {
		rule.EnableTcpReset = nil
	}

	// FrontendIPConfigurations
	if source.FrontendIPConfigurations != nil {
		frontendIPConfigurationList := make([]SubResource, len(source.FrontendIPConfigurations))
		for frontendIPConfigurationIndex, frontendIPConfigurationItem := range source.FrontendIPConfigurations {
			// Shadow the loop variable to avoid aliasing
			frontendIPConfigurationItem := frontendIPConfigurationItem
			var subResourceStash v20220701s.SubResource
			err := subResourceStash.AssignProperties_From_SubResource(&frontendIPConfigurationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field SubResourceStash from FrontendIPConfigurations")
			}
			var frontendIPConfiguration SubResource
			err = frontendIPConfiguration.AssignProperties_From_SubResource(&subResourceStash)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field FrontendIPConfigurations from SubResourceStash")
			}
			frontendIPConfigurationList[frontendIPConfigurationIndex] = frontendIPConfiguration
		}
		rule.FrontendIPConfigurations = frontendIPConfigurationList
	} else {
		rule.FrontendIPConfigurations = nil
	}

	// IdleTimeoutInMinutes
	rule.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(source.IdleTimeoutInMinutes)

	// Name
	rule.Name = genruntime.ClonePointerToString(source.Name)

	// Protocol
	rule.Protocol = genruntime.ClonePointerToString(source.Protocol)

	// Update the property bag
	if len(propertyBag) > 0 {
		rule.PropertyBag = propertyBag
	} else {
		rule.PropertyBag = nil
	}

	// Invoke the augmentConversionForOutboundRule interface (if implemented) to customize the conversion
	var ruleAsAny any = rule
	if augmentedRule, ok := ruleAsAny.(augmentConversionForOutboundRule); ok {
		err := augmentedRule.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_OutboundRule populates the provided destination OutboundRule from our OutboundRule
func (rule *OutboundRule) AssignProperties_To_OutboundRule(destination *v20240301s.OutboundRule) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(rule.PropertyBag)

	// AllocatedOutboundPorts
	destination.AllocatedOutboundPorts = genruntime.ClonePointerToInt(rule.AllocatedOutboundPorts)

	// BackendAddressPool
	if rule.BackendAddressPool != nil {
		var subResourceStash v20220701s.SubResource
		err := rule.BackendAddressPool.AssignProperties_To_SubResource(&subResourceStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field SubResourceStash from BackendAddressPool")
		}
		var backendAddressPool v20240301s.SubResource
		err = subResourceStash.AssignProperties_To_SubResource(&backendAddressPool)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field BackendAddressPool from SubResourceStash")
		}
		destination.BackendAddressPool = &backendAddressPool
	} else {
		destination.BackendAddressPool = nil
	}

	// EnableTcpReset
	if rule.EnableTcpReset != nil {
		enableTcpReset := *rule.EnableTcpReset
		destination.EnableTcpReset = &enableTcpReset
	} else {
		destination.EnableTcpReset = nil
	}

	// FrontendIPConfigurations
	if rule.FrontendIPConfigurations != nil {
		frontendIPConfigurationList := make([]v20240301s.SubResource, len(rule.FrontendIPConfigurations))
		for frontendIPConfigurationIndex, frontendIPConfigurationItem := range rule.FrontendIPConfigurations {
			// Shadow the loop variable to avoid aliasing
			frontendIPConfigurationItem := frontendIPConfigurationItem
			var subResourceStash v20220701s.SubResource
			err := frontendIPConfigurationItem.AssignProperties_To_SubResource(&subResourceStash)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field SubResourceStash from FrontendIPConfigurations")
			}
			var frontendIPConfiguration v20240301s.SubResource
			err = subResourceStash.AssignProperties_To_SubResource(&frontendIPConfiguration)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field FrontendIPConfigurations from SubResourceStash")
			}
			frontendIPConfigurationList[frontendIPConfigurationIndex] = frontendIPConfiguration
		}
		destination.FrontendIPConfigurations = frontendIPConfigurationList
	} else {
		destination.FrontendIPConfigurations = nil
	}

	// IdleTimeoutInMinutes
	destination.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(rule.IdleTimeoutInMinutes)

	// Name
	destination.Name = genruntime.ClonePointerToString(rule.Name)

	// Protocol
	destination.Protocol = genruntime.ClonePointerToString(rule.Protocol)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForOutboundRule interface (if implemented) to customize the conversion
	var ruleAsAny any = rule
	if augmentedRule, ok := ruleAsAny.(augmentConversionForOutboundRule); ok {
		err := augmentedRule.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201101.OutboundRule_STATUS
// Outbound rule of the load balancer.
type OutboundRule_STATUS struct {
	AllocatedOutboundPorts   *int                   `json:"allocatedOutboundPorts,omitempty"`
	BackendAddressPool       *SubResource_STATUS    `json:"backendAddressPool,omitempty"`
	EnableTcpReset           *bool                  `json:"enableTcpReset,omitempty"`
	Etag                     *string                `json:"etag,omitempty"`
	FrontendIPConfigurations []SubResource_STATUS   `json:"frontendIPConfigurations,omitempty"`
	Id                       *string                `json:"id,omitempty"`
	IdleTimeoutInMinutes     *int                   `json:"idleTimeoutInMinutes,omitempty"`
	Name                     *string                `json:"name,omitempty"`
	PropertyBag              genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Protocol                 *string                `json:"protocol,omitempty"`
	ProvisioningState        *string                `json:"provisioningState,omitempty"`
	Type                     *string                `json:"type,omitempty"`
}

// AssignProperties_From_OutboundRule_STATUS populates our OutboundRule_STATUS from the provided source OutboundRule_STATUS
func (rule *OutboundRule_STATUS) AssignProperties_From_OutboundRule_STATUS(source *v20240301s.OutboundRule_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AllocatedOutboundPorts
	rule.AllocatedOutboundPorts = genruntime.ClonePointerToInt(source.AllocatedOutboundPorts)

	// BackendAddressPool
	if source.BackendAddressPool != nil {
		var subResourceSTATUSStash v20240101s.SubResource_STATUS
		err := subResourceSTATUSStash.AssignProperties_From_SubResource_STATUS(source.BackendAddressPool)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SubResource_STATUSStash from BackendAddressPool")
		}
		var subResourceSTATUSStashLocal v20220701s.SubResource_STATUS
		err = subResourceSTATUSStashLocal.AssignProperties_From_SubResource_STATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SubResource_STATUSStash")
		}
		var backendAddressPool SubResource_STATUS
		err = backendAddressPool.AssignProperties_From_SubResource_STATUS(&subResourceSTATUSStashLocal)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field BackendAddressPool from SubResource_STATUSStash")
		}
		rule.BackendAddressPool = &backendAddressPool
	} else {
		rule.BackendAddressPool = nil
	}

	// EnableTcpReset
	if source.EnableTcpReset != nil {
		enableTcpReset := *source.EnableTcpReset
		rule.EnableTcpReset = &enableTcpReset
	} else {
		rule.EnableTcpReset = nil
	}

	// Etag
	rule.Etag = genruntime.ClonePointerToString(source.Etag)

	// FrontendIPConfigurations
	if source.FrontendIPConfigurations != nil {
		frontendIPConfigurationList := make([]SubResource_STATUS, len(source.FrontendIPConfigurations))
		for frontendIPConfigurationIndex, frontendIPConfigurationItem := range source.FrontendIPConfigurations {
			// Shadow the loop variable to avoid aliasing
			frontendIPConfigurationItem := frontendIPConfigurationItem
			var subResourceSTATUSStash v20240101s.SubResource_STATUS
			err := subResourceSTATUSStash.AssignProperties_From_SubResource_STATUS(&frontendIPConfigurationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SubResource_STATUSStash from FrontendIPConfigurations")
			}
			var subResourceSTATUSStashLocal v20220701s.SubResource_STATUS
			err = subResourceSTATUSStashLocal.AssignProperties_From_SubResource_STATUS(&subResourceSTATUSStash)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SubResource_STATUSStash")
			}
			var frontendIPConfiguration SubResource_STATUS
			err = frontendIPConfiguration.AssignProperties_From_SubResource_STATUS(&subResourceSTATUSStashLocal)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field FrontendIPConfigurations from SubResource_STATUSStash")
			}
			frontendIPConfigurationList[frontendIPConfigurationIndex] = frontendIPConfiguration
		}
		rule.FrontendIPConfigurations = frontendIPConfigurationList
	} else {
		rule.FrontendIPConfigurations = nil
	}

	// Id
	rule.Id = genruntime.ClonePointerToString(source.Id)

	// IdleTimeoutInMinutes
	rule.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(source.IdleTimeoutInMinutes)

	// Name
	rule.Name = genruntime.ClonePointerToString(source.Name)

	// Protocol
	rule.Protocol = genruntime.ClonePointerToString(source.Protocol)

	// ProvisioningState
	rule.ProvisioningState = genruntime.ClonePointerToString(source.ProvisioningState)

	// Type
	rule.Type = genruntime.ClonePointerToString(source.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		rule.PropertyBag = propertyBag
	} else {
		rule.PropertyBag = nil
	}

	// Invoke the augmentConversionForOutboundRule_STATUS interface (if implemented) to customize the conversion
	var ruleAsAny any = rule
	if augmentedRule, ok := ruleAsAny.(augmentConversionForOutboundRule_STATUS); ok {
		err := augmentedRule.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_OutboundRule_STATUS populates the provided destination OutboundRule_STATUS from our OutboundRule_STATUS
func (rule *OutboundRule_STATUS) AssignProperties_To_OutboundRule_STATUS(destination *v20240301s.OutboundRule_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(rule.PropertyBag)

	// AllocatedOutboundPorts
	destination.AllocatedOutboundPorts = genruntime.ClonePointerToInt(rule.AllocatedOutboundPorts)

	// BackendAddressPool
	if rule.BackendAddressPool != nil {
		var subResourceSTATUSStash v20220701s.SubResource_STATUS
		err := rule.BackendAddressPool.AssignProperties_To_SubResource_STATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SubResource_STATUSStash from BackendAddressPool")
		}
		var subResourceSTATUSStashLocal v20240101s.SubResource_STATUS
		err = subResourceSTATUSStash.AssignProperties_To_SubResource_STATUS(&subResourceSTATUSStashLocal)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SubResource_STATUSStash")
		}
		var backendAddressPool v20240301s.SubResource_STATUS
		err = subResourceSTATUSStashLocal.AssignProperties_To_SubResource_STATUS(&backendAddressPool)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field BackendAddressPool from SubResource_STATUSStash")
		}
		destination.BackendAddressPool = &backendAddressPool
	} else {
		destination.BackendAddressPool = nil
	}

	// EnableTcpReset
	if rule.EnableTcpReset != nil {
		enableTcpReset := *rule.EnableTcpReset
		destination.EnableTcpReset = &enableTcpReset
	} else {
		destination.EnableTcpReset = nil
	}

	// Etag
	destination.Etag = genruntime.ClonePointerToString(rule.Etag)

	// FrontendIPConfigurations
	if rule.FrontendIPConfigurations != nil {
		frontendIPConfigurationList := make([]v20240301s.SubResource_STATUS, len(rule.FrontendIPConfigurations))
		for frontendIPConfigurationIndex, frontendIPConfigurationItem := range rule.FrontendIPConfigurations {
			// Shadow the loop variable to avoid aliasing
			frontendIPConfigurationItem := frontendIPConfigurationItem
			var subResourceSTATUSStash v20220701s.SubResource_STATUS
			err := frontendIPConfigurationItem.AssignProperties_To_SubResource_STATUS(&subResourceSTATUSStash)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SubResource_STATUSStash from FrontendIPConfigurations")
			}
			var subResourceSTATUSStashLocal v20240101s.SubResource_STATUS
			err = subResourceSTATUSStash.AssignProperties_To_SubResource_STATUS(&subResourceSTATUSStashLocal)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SubResource_STATUSStash")
			}
			var frontendIPConfiguration v20240301s.SubResource_STATUS
			err = subResourceSTATUSStashLocal.AssignProperties_To_SubResource_STATUS(&frontendIPConfiguration)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field FrontendIPConfigurations from SubResource_STATUSStash")
			}
			frontendIPConfigurationList[frontendIPConfigurationIndex] = frontendIPConfiguration
		}
		destination.FrontendIPConfigurations = frontendIPConfigurationList
	} else {
		destination.FrontendIPConfigurations = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(rule.Id)

	// IdleTimeoutInMinutes
	destination.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(rule.IdleTimeoutInMinutes)

	// Name
	destination.Name = genruntime.ClonePointerToString(rule.Name)

	// Protocol
	destination.Protocol = genruntime.ClonePointerToString(rule.Protocol)

	// ProvisioningState
	destination.ProvisioningState = genruntime.ClonePointerToString(rule.ProvisioningState)

	// Type
	destination.Type = genruntime.ClonePointerToString(rule.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForOutboundRule_STATUS interface (if implemented) to customize the conversion
	var ruleAsAny any = rule
	if augmentedRule, ok := ruleAsAny.(augmentConversionForOutboundRule_STATUS); ok {
		err := augmentedRule.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201101.Probe
// A load balancer probe.
type Probe struct {
	IntervalInSeconds *int                   `json:"intervalInSeconds,omitempty"`
	Name              *string                `json:"name,omitempty"`
	NumberOfProbes    *int                   `json:"numberOfProbes,omitempty"`
	Port              *int                   `json:"port,omitempty"`
	PropertyBag       genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Protocol          *string                `json:"protocol,omitempty"`
	RequestPath       *string                `json:"requestPath,omitempty"`
}

// AssignProperties_From_Probe populates our Probe from the provided source Probe
func (probe *Probe) AssignProperties_From_Probe(source *v20240301s.Probe) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// IntervalInSeconds
	probe.IntervalInSeconds = genruntime.ClonePointerToInt(source.IntervalInSeconds)

	// Name
	probe.Name = genruntime.ClonePointerToString(source.Name)

	// NoHealthyBackendsBehavior
	if source.NoHealthyBackendsBehavior != nil {
		propertyBag.Add("NoHealthyBackendsBehavior", *source.NoHealthyBackendsBehavior)
	} else {
		propertyBag.Remove("NoHealthyBackendsBehavior")
	}

	// NumberOfProbes
	probe.NumberOfProbes = genruntime.ClonePointerToInt(source.NumberOfProbes)

	// Port
	probe.Port = genruntime.ClonePointerToInt(source.Port)

	// ProbeThreshold
	if source.ProbeThreshold != nil {
		propertyBag.Add("ProbeThreshold", *source.ProbeThreshold)
	} else {
		propertyBag.Remove("ProbeThreshold")
	}

	// Protocol
	probe.Protocol = genruntime.ClonePointerToString(source.Protocol)

	// RequestPath
	probe.RequestPath = genruntime.ClonePointerToString(source.RequestPath)

	// Update the property bag
	if len(propertyBag) > 0 {
		probe.PropertyBag = propertyBag
	} else {
		probe.PropertyBag = nil
	}

	// Invoke the augmentConversionForProbe interface (if implemented) to customize the conversion
	var probeAsAny any = probe
	if augmentedProbe, ok := probeAsAny.(augmentConversionForProbe); ok {
		err := augmentedProbe.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_Probe populates the provided destination Probe from our Probe
func (probe *Probe) AssignProperties_To_Probe(destination *v20240301s.Probe) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(probe.PropertyBag)

	// IntervalInSeconds
	destination.IntervalInSeconds = genruntime.ClonePointerToInt(probe.IntervalInSeconds)

	// Name
	destination.Name = genruntime.ClonePointerToString(probe.Name)

	// NoHealthyBackendsBehavior
	if propertyBag.Contains("NoHealthyBackendsBehavior") {
		var noHealthyBackendsBehavior string
		err := propertyBag.Pull("NoHealthyBackendsBehavior", &noHealthyBackendsBehavior)
		if err != nil {
			return errors.Wrap(err, "pulling 'NoHealthyBackendsBehavior' from propertyBag")
		}

		destination.NoHealthyBackendsBehavior = &noHealthyBackendsBehavior
	} else {
		destination.NoHealthyBackendsBehavior = nil
	}

	// NumberOfProbes
	destination.NumberOfProbes = genruntime.ClonePointerToInt(probe.NumberOfProbes)

	// Port
	destination.Port = genruntime.ClonePointerToInt(probe.Port)

	// ProbeThreshold
	if propertyBag.Contains("ProbeThreshold") {
		var probeThreshold int
		err := propertyBag.Pull("ProbeThreshold", &probeThreshold)
		if err != nil {
			return errors.Wrap(err, "pulling 'ProbeThreshold' from propertyBag")
		}

		destination.ProbeThreshold = &probeThreshold
	} else {
		destination.ProbeThreshold = nil
	}

	// Protocol
	destination.Protocol = genruntime.ClonePointerToString(probe.Protocol)

	// RequestPath
	destination.RequestPath = genruntime.ClonePointerToString(probe.RequestPath)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForProbe interface (if implemented) to customize the conversion
	var probeAsAny any = probe
	if augmentedProbe, ok := probeAsAny.(augmentConversionForProbe); ok {
		err := augmentedProbe.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201101.Probe_STATUS
// A load balancer probe.
type Probe_STATUS struct {
	Etag               *string                `json:"etag,omitempty"`
	Id                 *string                `json:"id,omitempty"`
	IntervalInSeconds  *int                   `json:"intervalInSeconds,omitempty"`
	LoadBalancingRules []SubResource_STATUS   `json:"loadBalancingRules,omitempty"`
	Name               *string                `json:"name,omitempty"`
	NumberOfProbes     *int                   `json:"numberOfProbes,omitempty"`
	Port               *int                   `json:"port,omitempty"`
	PropertyBag        genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Protocol           *string                `json:"protocol,omitempty"`
	ProvisioningState  *string                `json:"provisioningState,omitempty"`
	RequestPath        *string                `json:"requestPath,omitempty"`
	Type               *string                `json:"type,omitempty"`
}

// AssignProperties_From_Probe_STATUS populates our Probe_STATUS from the provided source Probe_STATUS
func (probe *Probe_STATUS) AssignProperties_From_Probe_STATUS(source *v20240301s.Probe_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Etag
	probe.Etag = genruntime.ClonePointerToString(source.Etag)

	// Id
	probe.Id = genruntime.ClonePointerToString(source.Id)

	// IntervalInSeconds
	probe.IntervalInSeconds = genruntime.ClonePointerToInt(source.IntervalInSeconds)

	// LoadBalancingRules
	if source.LoadBalancingRules != nil {
		loadBalancingRuleList := make([]SubResource_STATUS, len(source.LoadBalancingRules))
		for loadBalancingRuleIndex, loadBalancingRuleItem := range source.LoadBalancingRules {
			// Shadow the loop variable to avoid aliasing
			loadBalancingRuleItem := loadBalancingRuleItem
			var subResourceSTATUSStash v20240101s.SubResource_STATUS
			err := subResourceSTATUSStash.AssignProperties_From_SubResource_STATUS(&loadBalancingRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SubResource_STATUSStash from LoadBalancingRules")
			}
			var subResourceSTATUSStashLocal v20220701s.SubResource_STATUS
			err = subResourceSTATUSStashLocal.AssignProperties_From_SubResource_STATUS(&subResourceSTATUSStash)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SubResource_STATUSStash")
			}
			var loadBalancingRule SubResource_STATUS
			err = loadBalancingRule.AssignProperties_From_SubResource_STATUS(&subResourceSTATUSStashLocal)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field LoadBalancingRules from SubResource_STATUSStash")
			}
			loadBalancingRuleList[loadBalancingRuleIndex] = loadBalancingRule
		}
		probe.LoadBalancingRules = loadBalancingRuleList
	} else {
		probe.LoadBalancingRules = nil
	}

	// Name
	probe.Name = genruntime.ClonePointerToString(source.Name)

	// NoHealthyBackendsBehavior
	if source.NoHealthyBackendsBehavior != nil {
		propertyBag.Add("NoHealthyBackendsBehavior", *source.NoHealthyBackendsBehavior)
	} else {
		propertyBag.Remove("NoHealthyBackendsBehavior")
	}

	// NumberOfProbes
	probe.NumberOfProbes = genruntime.ClonePointerToInt(source.NumberOfProbes)

	// Port
	probe.Port = genruntime.ClonePointerToInt(source.Port)

	// ProbeThreshold
	if source.ProbeThreshold != nil {
		propertyBag.Add("ProbeThreshold", *source.ProbeThreshold)
	} else {
		propertyBag.Remove("ProbeThreshold")
	}

	// Protocol
	probe.Protocol = genruntime.ClonePointerToString(source.Protocol)

	// ProvisioningState
	probe.ProvisioningState = genruntime.ClonePointerToString(source.ProvisioningState)

	// RequestPath
	probe.RequestPath = genruntime.ClonePointerToString(source.RequestPath)

	// Type
	probe.Type = genruntime.ClonePointerToString(source.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		probe.PropertyBag = propertyBag
	} else {
		probe.PropertyBag = nil
	}

	// Invoke the augmentConversionForProbe_STATUS interface (if implemented) to customize the conversion
	var probeAsAny any = probe
	if augmentedProbe, ok := probeAsAny.(augmentConversionForProbe_STATUS); ok {
		err := augmentedProbe.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_Probe_STATUS populates the provided destination Probe_STATUS from our Probe_STATUS
func (probe *Probe_STATUS) AssignProperties_To_Probe_STATUS(destination *v20240301s.Probe_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(probe.PropertyBag)

	// Etag
	destination.Etag = genruntime.ClonePointerToString(probe.Etag)

	// Id
	destination.Id = genruntime.ClonePointerToString(probe.Id)

	// IntervalInSeconds
	destination.IntervalInSeconds = genruntime.ClonePointerToInt(probe.IntervalInSeconds)

	// LoadBalancingRules
	if probe.LoadBalancingRules != nil {
		loadBalancingRuleList := make([]v20240301s.SubResource_STATUS, len(probe.LoadBalancingRules))
		for loadBalancingRuleIndex, loadBalancingRuleItem := range probe.LoadBalancingRules {
			// Shadow the loop variable to avoid aliasing
			loadBalancingRuleItem := loadBalancingRuleItem
			var subResourceSTATUSStash v20220701s.SubResource_STATUS
			err := loadBalancingRuleItem.AssignProperties_To_SubResource_STATUS(&subResourceSTATUSStash)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SubResource_STATUSStash from LoadBalancingRules")
			}
			var subResourceSTATUSStashLocal v20240101s.SubResource_STATUS
			err = subResourceSTATUSStash.AssignProperties_To_SubResource_STATUS(&subResourceSTATUSStashLocal)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SubResource_STATUSStash")
			}
			var loadBalancingRule v20240301s.SubResource_STATUS
			err = subResourceSTATUSStashLocal.AssignProperties_To_SubResource_STATUS(&loadBalancingRule)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field LoadBalancingRules from SubResource_STATUSStash")
			}
			loadBalancingRuleList[loadBalancingRuleIndex] = loadBalancingRule
		}
		destination.LoadBalancingRules = loadBalancingRuleList
	} else {
		destination.LoadBalancingRules = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(probe.Name)

	// NoHealthyBackendsBehavior
	if propertyBag.Contains("NoHealthyBackendsBehavior") {
		var noHealthyBackendsBehavior string
		err := propertyBag.Pull("NoHealthyBackendsBehavior", &noHealthyBackendsBehavior)
		if err != nil {
			return errors.Wrap(err, "pulling 'NoHealthyBackendsBehavior' from propertyBag")
		}

		destination.NoHealthyBackendsBehavior = &noHealthyBackendsBehavior
	} else {
		destination.NoHealthyBackendsBehavior = nil
	}

	// NumberOfProbes
	destination.NumberOfProbes = genruntime.ClonePointerToInt(probe.NumberOfProbes)

	// Port
	destination.Port = genruntime.ClonePointerToInt(probe.Port)

	// ProbeThreshold
	if propertyBag.Contains("ProbeThreshold") {
		var probeThreshold int
		err := propertyBag.Pull("ProbeThreshold", &probeThreshold)
		if err != nil {
			return errors.Wrap(err, "pulling 'ProbeThreshold' from propertyBag")
		}

		destination.ProbeThreshold = &probeThreshold
	} else {
		destination.ProbeThreshold = nil
	}

	// Protocol
	destination.Protocol = genruntime.ClonePointerToString(probe.Protocol)

	// ProvisioningState
	destination.ProvisioningState = genruntime.ClonePointerToString(probe.ProvisioningState)

	// RequestPath
	destination.RequestPath = genruntime.ClonePointerToString(probe.RequestPath)

	// Type
	destination.Type = genruntime.ClonePointerToString(probe.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForProbe_STATUS interface (if implemented) to customize the conversion
	var probeAsAny any = probe
	if augmentedProbe, ok := probeAsAny.(augmentConversionForProbe_STATUS); ok {
		err := augmentedProbe.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

type augmentConversionForBackendAddressPool_LoadBalancer_SubResourceEmbedded interface {
	AssignPropertiesFrom(src *v20240301s.BackendAddressPool_LoadBalancer_SubResourceEmbedded) error
	AssignPropertiesTo(dst *v20240301s.BackendAddressPool_LoadBalancer_SubResourceEmbedded) error
}

type augmentConversionForBackendAddressPool_STATUS_LoadBalancer_SubResourceEmbedded interface {
	AssignPropertiesFrom(src *v20240301s.BackendAddressPool_STATUS_LoadBalancer_SubResourceEmbedded) error
	AssignPropertiesTo(dst *v20240301s.BackendAddressPool_STATUS_LoadBalancer_SubResourceEmbedded) error
}

type augmentConversionForExtendedLocation interface {
	AssignPropertiesFrom(src *v20220701s.ExtendedLocation) error
	AssignPropertiesTo(dst *v20220701s.ExtendedLocation) error
}

type augmentConversionForExtendedLocation_STATUS interface {
	AssignPropertiesFrom(src *v20220701s.ExtendedLocation_STATUS) error
	AssignPropertiesTo(dst *v20220701s.ExtendedLocation_STATUS) error
}

type augmentConversionForFrontendIPConfiguration_LoadBalancer_SubResourceEmbedded interface {
	AssignPropertiesFrom(src *v20240301s.FrontendIPConfiguration_LoadBalancer_SubResourceEmbedded) error
	AssignPropertiesTo(dst *v20240301s.FrontendIPConfiguration_LoadBalancer_SubResourceEmbedded) error
}

type augmentConversionForFrontendIPConfiguration_STATUS_LoadBalancer_SubResourceEmbedded interface {
	AssignPropertiesFrom(src *v20240301s.FrontendIPConfiguration_STATUS_LoadBalancer_SubResourceEmbedded) error
	AssignPropertiesTo(dst *v20240301s.FrontendIPConfiguration_STATUS_LoadBalancer_SubResourceEmbedded) error
}

type augmentConversionForInboundNatPool interface {
	AssignPropertiesFrom(src *v20240301s.InboundNatPool) error
	AssignPropertiesTo(dst *v20240301s.InboundNatPool) error
}

type augmentConversionForInboundNatPool_STATUS interface {
	AssignPropertiesFrom(src *v20240301s.InboundNatPool_STATUS) error
	AssignPropertiesTo(dst *v20240301s.InboundNatPool_STATUS) error
}

type augmentConversionForInboundNatRule_LoadBalancer_SubResourceEmbedded interface {
	AssignPropertiesFrom(src *v20240301s.InboundNatRule_LoadBalancer_SubResourceEmbedded) error
	AssignPropertiesTo(dst *v20240301s.InboundNatRule_LoadBalancer_SubResourceEmbedded) error
}

type augmentConversionForInboundNatRule_STATUS_LoadBalancer_SubResourceEmbedded interface {
	AssignPropertiesFrom(src *v20240301s.InboundNatRule_STATUS_LoadBalancer_SubResourceEmbedded) error
	AssignPropertiesTo(dst *v20240301s.InboundNatRule_STATUS_LoadBalancer_SubResourceEmbedded) error
}

type augmentConversionForLoadBalancerOperatorSpec interface {
	AssignPropertiesFrom(src *v20240301s.LoadBalancerOperatorSpec) error
	AssignPropertiesTo(dst *v20240301s.LoadBalancerOperatorSpec) error
}

type augmentConversionForLoadBalancerSku interface {
	AssignPropertiesFrom(src *v20240301s.LoadBalancerSku) error
	AssignPropertiesTo(dst *v20240301s.LoadBalancerSku) error
}

type augmentConversionForLoadBalancerSku_STATUS interface {
	AssignPropertiesFrom(src *v20240301s.LoadBalancerSku_STATUS) error
	AssignPropertiesTo(dst *v20240301s.LoadBalancerSku_STATUS) error
}

type augmentConversionForLoadBalancingRule interface {
	AssignPropertiesFrom(src *v20240301s.LoadBalancingRule) error
	AssignPropertiesTo(dst *v20240301s.LoadBalancingRule) error
}

type augmentConversionForLoadBalancingRule_STATUS interface {
	AssignPropertiesFrom(src *v20240301s.LoadBalancingRule_STATUS) error
	AssignPropertiesTo(dst *v20240301s.LoadBalancingRule_STATUS) error
}

type augmentConversionForOutboundRule interface {
	AssignPropertiesFrom(src *v20240301s.OutboundRule) error
	AssignPropertiesTo(dst *v20240301s.OutboundRule) error
}

type augmentConversionForOutboundRule_STATUS interface {
	AssignPropertiesFrom(src *v20240301s.OutboundRule_STATUS) error
	AssignPropertiesTo(dst *v20240301s.OutboundRule_STATUS) error
}

type augmentConversionForProbe interface {
	AssignPropertiesFrom(src *v20240301s.Probe) error
	AssignPropertiesTo(dst *v20240301s.Probe) error
}

type augmentConversionForProbe_STATUS interface {
	AssignPropertiesFrom(src *v20240301s.Probe_STATUS) error
	AssignPropertiesTo(dst *v20240301s.Probe_STATUS) error
}

// Storage version of v1api20201101.LoadBalancerBackendAddress
// Load balancer backend addresses.
type LoadBalancerBackendAddress struct {
	IpAddress                           *string                `json:"ipAddress,omitempty"`
	LoadBalancerFrontendIPConfiguration *SubResource           `json:"loadBalancerFrontendIPConfiguration,omitempty"`
	Name                                *string                `json:"name,omitempty"`
	PropertyBag                         genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Subnet                              *SubResource           `json:"subnet,omitempty"`
	VirtualNetwork                      *SubResource           `json:"virtualNetwork,omitempty"`
}

// AssignProperties_From_LoadBalancerBackendAddress populates our LoadBalancerBackendAddress from the provided source LoadBalancerBackendAddress
func (address *LoadBalancerBackendAddress) AssignProperties_From_LoadBalancerBackendAddress(source *v20240301s.LoadBalancerBackendAddress) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AdminState
	if source.AdminState != nil {
		propertyBag.Add("AdminState", *source.AdminState)
	} else {
		propertyBag.Remove("AdminState")
	}

	// IpAddress
	address.IpAddress = genruntime.ClonePointerToString(source.IpAddress)

	// LoadBalancerFrontendIPConfiguration
	if source.LoadBalancerFrontendIPConfiguration != nil {
		var subResourceStash v20220701s.SubResource
		err := subResourceStash.AssignProperties_From_SubResource(source.LoadBalancerFrontendIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field SubResourceStash from LoadBalancerFrontendIPConfiguration")
		}
		var loadBalancerFrontendIPConfiguration SubResource
		err = loadBalancerFrontendIPConfiguration.AssignProperties_From_SubResource(&subResourceStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field LoadBalancerFrontendIPConfiguration from SubResourceStash")
		}
		address.LoadBalancerFrontendIPConfiguration = &loadBalancerFrontendIPConfiguration
	} else {
		address.LoadBalancerFrontendIPConfiguration = nil
	}

	// Name
	address.Name = genruntime.ClonePointerToString(source.Name)

	// Subnet
	if source.Subnet != nil {
		var subResourceStash v20220701s.SubResource
		err := subResourceStash.AssignProperties_From_SubResource(source.Subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field SubResourceStash from Subnet")
		}
		var subnet SubResource
		err = subnet.AssignProperties_From_SubResource(&subResourceStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field Subnet from SubResourceStash")
		}
		address.Subnet = &subnet
	} else {
		address.Subnet = nil
	}

	// VirtualNetwork
	if source.VirtualNetwork != nil {
		var subResourceStash v20220701s.SubResource
		err := subResourceStash.AssignProperties_From_SubResource(source.VirtualNetwork)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field SubResourceStash from VirtualNetwork")
		}
		var virtualNetwork SubResource
		err = virtualNetwork.AssignProperties_From_SubResource(&subResourceStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field VirtualNetwork from SubResourceStash")
		}
		address.VirtualNetwork = &virtualNetwork
	} else {
		address.VirtualNetwork = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		address.PropertyBag = propertyBag
	} else {
		address.PropertyBag = nil
	}

	// Invoke the augmentConversionForLoadBalancerBackendAddress interface (if implemented) to customize the conversion
	var addressAsAny any = address
	if augmentedAddress, ok := addressAsAny.(augmentConversionForLoadBalancerBackendAddress); ok {
		err := augmentedAddress.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_LoadBalancerBackendAddress populates the provided destination LoadBalancerBackendAddress from our LoadBalancerBackendAddress
func (address *LoadBalancerBackendAddress) AssignProperties_To_LoadBalancerBackendAddress(destination *v20240301s.LoadBalancerBackendAddress) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(address.PropertyBag)

	// AdminState
	if propertyBag.Contains("AdminState") {
		var adminState string
		err := propertyBag.Pull("AdminState", &adminState)
		if err != nil {
			return errors.Wrap(err, "pulling 'AdminState' from propertyBag")
		}

		destination.AdminState = &adminState
	} else {
		destination.AdminState = nil
	}

	// IpAddress
	destination.IpAddress = genruntime.ClonePointerToString(address.IpAddress)

	// LoadBalancerFrontendIPConfiguration
	if address.LoadBalancerFrontendIPConfiguration != nil {
		var subResourceStash v20220701s.SubResource
		err := address.LoadBalancerFrontendIPConfiguration.AssignProperties_To_SubResource(&subResourceStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field SubResourceStash from LoadBalancerFrontendIPConfiguration")
		}
		var loadBalancerFrontendIPConfiguration v20240301s.SubResource
		err = subResourceStash.AssignProperties_To_SubResource(&loadBalancerFrontendIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field LoadBalancerFrontendIPConfiguration from SubResourceStash")
		}
		destination.LoadBalancerFrontendIPConfiguration = &loadBalancerFrontendIPConfiguration
	} else {
		destination.LoadBalancerFrontendIPConfiguration = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(address.Name)

	// Subnet
	if address.Subnet != nil {
		var subResourceStash v20220701s.SubResource
		err := address.Subnet.AssignProperties_To_SubResource(&subResourceStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field SubResourceStash from Subnet")
		}
		var subnet v20240301s.SubResource
		err = subResourceStash.AssignProperties_To_SubResource(&subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field Subnet from SubResourceStash")
		}
		destination.Subnet = &subnet
	} else {
		destination.Subnet = nil
	}

	// VirtualNetwork
	if address.VirtualNetwork != nil {
		var subResourceStash v20220701s.SubResource
		err := address.VirtualNetwork.AssignProperties_To_SubResource(&subResourceStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field SubResourceStash from VirtualNetwork")
		}
		var virtualNetwork v20240301s.SubResource
		err = subResourceStash.AssignProperties_To_SubResource(&virtualNetwork)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field VirtualNetwork from SubResourceStash")
		}
		destination.VirtualNetwork = &virtualNetwork
	} else {
		destination.VirtualNetwork = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForLoadBalancerBackendAddress interface (if implemented) to customize the conversion
	var addressAsAny any = address
	if augmentedAddress, ok := addressAsAny.(augmentConversionForLoadBalancerBackendAddress); ok {
		err := augmentedAddress.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201101.LoadBalancerBackendAddress_STATUS
// Load balancer backend addresses.
type LoadBalancerBackendAddress_STATUS struct {
	IpAddress                           *string                `json:"ipAddress,omitempty"`
	LoadBalancerFrontendIPConfiguration *SubResource_STATUS    `json:"loadBalancerFrontendIPConfiguration,omitempty"`
	Name                                *string                `json:"name,omitempty"`
	NetworkInterfaceIPConfiguration     *SubResource_STATUS    `json:"networkInterfaceIPConfiguration,omitempty"`
	PropertyBag                         genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Subnet                              *SubResource_STATUS    `json:"subnet,omitempty"`
	VirtualNetwork                      *SubResource_STATUS    `json:"virtualNetwork,omitempty"`
}

// AssignProperties_From_LoadBalancerBackendAddress_STATUS populates our LoadBalancerBackendAddress_STATUS from the provided source LoadBalancerBackendAddress_STATUS
func (address *LoadBalancerBackendAddress_STATUS) AssignProperties_From_LoadBalancerBackendAddress_STATUS(source *v20240301s.LoadBalancerBackendAddress_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AdminState
	if source.AdminState != nil {
		propertyBag.Add("AdminState", *source.AdminState)
	} else {
		propertyBag.Remove("AdminState")
	}

	// InboundNatRulesPortMapping
	if len(source.InboundNatRulesPortMapping) > 0 {
		propertyBag.Add("InboundNatRulesPortMapping", source.InboundNatRulesPortMapping)
	} else {
		propertyBag.Remove("InboundNatRulesPortMapping")
	}

	// IpAddress
	address.IpAddress = genruntime.ClonePointerToString(source.IpAddress)

	// LoadBalancerFrontendIPConfiguration
	if source.LoadBalancerFrontendIPConfiguration != nil {
		var subResourceSTATUSStash v20240101s.SubResource_STATUS
		err := subResourceSTATUSStash.AssignProperties_From_SubResource_STATUS(source.LoadBalancerFrontendIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SubResource_STATUSStash from LoadBalancerFrontendIPConfiguration")
		}
		var subResourceSTATUSStashLocal v20220701s.SubResource_STATUS
		err = subResourceSTATUSStashLocal.AssignProperties_From_SubResource_STATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SubResource_STATUSStash")
		}
		var loadBalancerFrontendIPConfiguration SubResource_STATUS
		err = loadBalancerFrontendIPConfiguration.AssignProperties_From_SubResource_STATUS(&subResourceSTATUSStashLocal)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field LoadBalancerFrontendIPConfiguration from SubResource_STATUSStash")
		}
		address.LoadBalancerFrontendIPConfiguration = &loadBalancerFrontendIPConfiguration
	} else {
		address.LoadBalancerFrontendIPConfiguration = nil
	}

	// Name
	address.Name = genruntime.ClonePointerToString(source.Name)

	// NetworkInterfaceIPConfiguration
	if source.NetworkInterfaceIPConfiguration != nil {
		var subResourceSTATUSStash v20240101s.SubResource_STATUS
		err := subResourceSTATUSStash.AssignProperties_From_SubResource_STATUS(source.NetworkInterfaceIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SubResource_STATUSStash from NetworkInterfaceIPConfiguration")
		}
		var subResourceSTATUSStashLocal v20220701s.SubResource_STATUS
		err = subResourceSTATUSStashLocal.AssignProperties_From_SubResource_STATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SubResource_STATUSStash")
		}
		var networkInterfaceIPConfiguration SubResource_STATUS
		err = networkInterfaceIPConfiguration.AssignProperties_From_SubResource_STATUS(&subResourceSTATUSStashLocal)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field NetworkInterfaceIPConfiguration from SubResource_STATUSStash")
		}
		address.NetworkInterfaceIPConfiguration = &networkInterfaceIPConfiguration
	} else {
		address.NetworkInterfaceIPConfiguration = nil
	}

	// Subnet
	if source.Subnet != nil {
		var subResourceSTATUSStash v20240101s.SubResource_STATUS
		err := subResourceSTATUSStash.AssignProperties_From_SubResource_STATUS(source.Subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SubResource_STATUSStash from Subnet")
		}
		var subResourceSTATUSStashLocal v20220701s.SubResource_STATUS
		err = subResourceSTATUSStashLocal.AssignProperties_From_SubResource_STATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SubResource_STATUSStash")
		}
		var subnet SubResource_STATUS
		err = subnet.AssignProperties_From_SubResource_STATUS(&subResourceSTATUSStashLocal)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field Subnet from SubResource_STATUSStash")
		}
		address.Subnet = &subnet
	} else {
		address.Subnet = nil
	}

	// VirtualNetwork
	if source.VirtualNetwork != nil {
		var subResourceSTATUSStash v20240101s.SubResource_STATUS
		err := subResourceSTATUSStash.AssignProperties_From_SubResource_STATUS(source.VirtualNetwork)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SubResource_STATUSStash from VirtualNetwork")
		}
		var subResourceSTATUSStashLocal v20220701s.SubResource_STATUS
		err = subResourceSTATUSStashLocal.AssignProperties_From_SubResource_STATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SubResource_STATUSStash")
		}
		var virtualNetwork SubResource_STATUS
		err = virtualNetwork.AssignProperties_From_SubResource_STATUS(&subResourceSTATUSStashLocal)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field VirtualNetwork from SubResource_STATUSStash")
		}
		address.VirtualNetwork = &virtualNetwork
	} else {
		address.VirtualNetwork = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		address.PropertyBag = propertyBag
	} else {
		address.PropertyBag = nil
	}

	// Invoke the augmentConversionForLoadBalancerBackendAddress_STATUS interface (if implemented) to customize the conversion
	var addressAsAny any = address
	if augmentedAddress, ok := addressAsAny.(augmentConversionForLoadBalancerBackendAddress_STATUS); ok {
		err := augmentedAddress.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_LoadBalancerBackendAddress_STATUS populates the provided destination LoadBalancerBackendAddress_STATUS from our LoadBalancerBackendAddress_STATUS
func (address *LoadBalancerBackendAddress_STATUS) AssignProperties_To_LoadBalancerBackendAddress_STATUS(destination *v20240301s.LoadBalancerBackendAddress_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(address.PropertyBag)

	// AdminState
	if propertyBag.Contains("AdminState") {
		var adminState string
		err := propertyBag.Pull("AdminState", &adminState)
		if err != nil {
			return errors.Wrap(err, "pulling 'AdminState' from propertyBag")
		}

		destination.AdminState = &adminState
	} else {
		destination.AdminState = nil
	}

	// InboundNatRulesPortMapping
	if propertyBag.Contains("InboundNatRulesPortMapping") {
		var inboundNatRulesPortMapping []v20240301s.NatRulePortMapping_STATUS
		err := propertyBag.Pull("InboundNatRulesPortMapping", &inboundNatRulesPortMapping)
		if err != nil {
			return errors.Wrap(err, "pulling 'InboundNatRulesPortMapping' from propertyBag")
		}

		destination.InboundNatRulesPortMapping = inboundNatRulesPortMapping
	} else {
		destination.InboundNatRulesPortMapping = nil
	}

	// IpAddress
	destination.IpAddress = genruntime.ClonePointerToString(address.IpAddress)

	// LoadBalancerFrontendIPConfiguration
	if address.LoadBalancerFrontendIPConfiguration != nil {
		var subResourceSTATUSStash v20220701s.SubResource_STATUS
		err := address.LoadBalancerFrontendIPConfiguration.AssignProperties_To_SubResource_STATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SubResource_STATUSStash from LoadBalancerFrontendIPConfiguration")
		}
		var subResourceSTATUSStashLocal v20240101s.SubResource_STATUS
		err = subResourceSTATUSStash.AssignProperties_To_SubResource_STATUS(&subResourceSTATUSStashLocal)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SubResource_STATUSStash")
		}
		var loadBalancerFrontendIPConfiguration v20240301s.SubResource_STATUS
		err = subResourceSTATUSStashLocal.AssignProperties_To_SubResource_STATUS(&loadBalancerFrontendIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field LoadBalancerFrontendIPConfiguration from SubResource_STATUSStash")
		}
		destination.LoadBalancerFrontendIPConfiguration = &loadBalancerFrontendIPConfiguration
	} else {
		destination.LoadBalancerFrontendIPConfiguration = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(address.Name)

	// NetworkInterfaceIPConfiguration
	if address.NetworkInterfaceIPConfiguration != nil {
		var subResourceSTATUSStash v20220701s.SubResource_STATUS
		err := address.NetworkInterfaceIPConfiguration.AssignProperties_To_SubResource_STATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SubResource_STATUSStash from NetworkInterfaceIPConfiguration")
		}
		var subResourceSTATUSStashLocal v20240101s.SubResource_STATUS
		err = subResourceSTATUSStash.AssignProperties_To_SubResource_STATUS(&subResourceSTATUSStashLocal)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SubResource_STATUSStash")
		}
		var networkInterfaceIPConfiguration v20240301s.SubResource_STATUS
		err = subResourceSTATUSStashLocal.AssignProperties_To_SubResource_STATUS(&networkInterfaceIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field NetworkInterfaceIPConfiguration from SubResource_STATUSStash")
		}
		destination.NetworkInterfaceIPConfiguration = &networkInterfaceIPConfiguration
	} else {
		destination.NetworkInterfaceIPConfiguration = nil
	}

	// Subnet
	if address.Subnet != nil {
		var subResourceSTATUSStash v20220701s.SubResource_STATUS
		err := address.Subnet.AssignProperties_To_SubResource_STATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SubResource_STATUSStash from Subnet")
		}
		var subResourceSTATUSStashLocal v20240101s.SubResource_STATUS
		err = subResourceSTATUSStash.AssignProperties_To_SubResource_STATUS(&subResourceSTATUSStashLocal)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SubResource_STATUSStash")
		}
		var subnet v20240301s.SubResource_STATUS
		err = subResourceSTATUSStashLocal.AssignProperties_To_SubResource_STATUS(&subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field Subnet from SubResource_STATUSStash")
		}
		destination.Subnet = &subnet
	} else {
		destination.Subnet = nil
	}

	// VirtualNetwork
	if address.VirtualNetwork != nil {
		var subResourceSTATUSStash v20220701s.SubResource_STATUS
		err := address.VirtualNetwork.AssignProperties_To_SubResource_STATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SubResource_STATUSStash from VirtualNetwork")
		}
		var subResourceSTATUSStashLocal v20240101s.SubResource_STATUS
		err = subResourceSTATUSStash.AssignProperties_To_SubResource_STATUS(&subResourceSTATUSStashLocal)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SubResource_STATUSStash")
		}
		var virtualNetwork v20240301s.SubResource_STATUS
		err = subResourceSTATUSStashLocal.AssignProperties_To_SubResource_STATUS(&virtualNetwork)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field VirtualNetwork from SubResource_STATUSStash")
		}
		destination.VirtualNetwork = &virtualNetwork
	} else {
		destination.VirtualNetwork = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForLoadBalancerBackendAddress_STATUS interface (if implemented) to customize the conversion
	var addressAsAny any = address
	if augmentedAddress, ok := addressAsAny.(augmentConversionForLoadBalancerBackendAddress_STATUS); ok {
		err := augmentedAddress.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201101.NetworkInterfaceIPConfiguration_STATUS_LoadBalancer_SubResourceEmbedded
// IPConfiguration in a network interface.
type NetworkInterfaceIPConfiguration_STATUS_LoadBalancer_SubResourceEmbedded struct {
	Id          *string                `json:"id,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_NetworkInterfaceIPConfiguration_STATUS_LoadBalancer_SubResourceEmbedded populates our NetworkInterfaceIPConfiguration_STATUS_LoadBalancer_SubResourceEmbedded from the provided source NetworkInterfaceIPConfiguration_STATUS_LoadBalancer_SubResourceEmbedded
func (embedded *NetworkInterfaceIPConfiguration_STATUS_LoadBalancer_SubResourceEmbedded) AssignProperties_From_NetworkInterfaceIPConfiguration_STATUS_LoadBalancer_SubResourceEmbedded(source *v20240301s.NetworkInterfaceIPConfiguration_STATUS_LoadBalancer_SubResourceEmbedded) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Id
	embedded.Id = genruntime.ClonePointerToString(source.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		embedded.PropertyBag = propertyBag
	} else {
		embedded.PropertyBag = nil
	}

	// Invoke the augmentConversionForNetworkInterfaceIPConfiguration_STATUS_LoadBalancer_SubResourceEmbedded interface (if implemented) to customize the conversion
	var embeddedAsAny any = embedded
	if augmentedEmbedded, ok := embeddedAsAny.(augmentConversionForNetworkInterfaceIPConfiguration_STATUS_LoadBalancer_SubResourceEmbedded); ok {
		err := augmentedEmbedded.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_NetworkInterfaceIPConfiguration_STATUS_LoadBalancer_SubResourceEmbedded populates the provided destination NetworkInterfaceIPConfiguration_STATUS_LoadBalancer_SubResourceEmbedded from our NetworkInterfaceIPConfiguration_STATUS_LoadBalancer_SubResourceEmbedded
func (embedded *NetworkInterfaceIPConfiguration_STATUS_LoadBalancer_SubResourceEmbedded) AssignProperties_To_NetworkInterfaceIPConfiguration_STATUS_LoadBalancer_SubResourceEmbedded(destination *v20240301s.NetworkInterfaceIPConfiguration_STATUS_LoadBalancer_SubResourceEmbedded) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(embedded.PropertyBag)

	// Id
	destination.Id = genruntime.ClonePointerToString(embedded.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForNetworkInterfaceIPConfiguration_STATUS_LoadBalancer_SubResourceEmbedded interface (if implemented) to customize the conversion
	var embeddedAsAny any = embedded
	if augmentedEmbedded, ok := embeddedAsAny.(augmentConversionForNetworkInterfaceIPConfiguration_STATUS_LoadBalancer_SubResourceEmbedded); ok {
		err := augmentedEmbedded.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201101.PublicIPAddress_STATUS_LoadBalancer_SubResourceEmbedded
// Public IP address resource.
type PublicIPAddress_STATUS_LoadBalancer_SubResourceEmbedded struct {
	Id          *string                `json:"id,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_PublicIPAddress_STATUS_LoadBalancer_SubResourceEmbedded populates our PublicIPAddress_STATUS_LoadBalancer_SubResourceEmbedded from the provided source PublicIPAddress_STATUS_LoadBalancer_SubResourceEmbedded
func (embedded *PublicIPAddress_STATUS_LoadBalancer_SubResourceEmbedded) AssignProperties_From_PublicIPAddress_STATUS_LoadBalancer_SubResourceEmbedded(source *v20240301s.PublicIPAddress_STATUS_LoadBalancer_SubResourceEmbedded) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Id
	embedded.Id = genruntime.ClonePointerToString(source.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		embedded.PropertyBag = propertyBag
	} else {
		embedded.PropertyBag = nil
	}

	// Invoke the augmentConversionForPublicIPAddress_STATUS_LoadBalancer_SubResourceEmbedded interface (if implemented) to customize the conversion
	var embeddedAsAny any = embedded
	if augmentedEmbedded, ok := embeddedAsAny.(augmentConversionForPublicIPAddress_STATUS_LoadBalancer_SubResourceEmbedded); ok {
		err := augmentedEmbedded.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_PublicIPAddress_STATUS_LoadBalancer_SubResourceEmbedded populates the provided destination PublicIPAddress_STATUS_LoadBalancer_SubResourceEmbedded from our PublicIPAddress_STATUS_LoadBalancer_SubResourceEmbedded
func (embedded *PublicIPAddress_STATUS_LoadBalancer_SubResourceEmbedded) AssignProperties_To_PublicIPAddress_STATUS_LoadBalancer_SubResourceEmbedded(destination *v20240301s.PublicIPAddress_STATUS_LoadBalancer_SubResourceEmbedded) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(embedded.PropertyBag)

	// Id
	destination.Id = genruntime.ClonePointerToString(embedded.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForPublicIPAddress_STATUS_LoadBalancer_SubResourceEmbedded interface (if implemented) to customize the conversion
	var embeddedAsAny any = embedded
	if augmentedEmbedded, ok := embeddedAsAny.(augmentConversionForPublicIPAddress_STATUS_LoadBalancer_SubResourceEmbedded); ok {
		err := augmentedEmbedded.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201101.PublicIPAddressSpec_LoadBalancer_SubResourceEmbedded
// Public IP address resource.
type PublicIPAddressSpec_LoadBalancer_SubResourceEmbedded struct {
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`

	// Reference: Resource ID.
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

// AssignProperties_From_PublicIPAddressSpec_LoadBalancer_SubResourceEmbedded populates our PublicIPAddressSpec_LoadBalancer_SubResourceEmbedded from the provided source PublicIPAddressSpec_LoadBalancer_SubResourceEmbedded
func (embedded *PublicIPAddressSpec_LoadBalancer_SubResourceEmbedded) AssignProperties_From_PublicIPAddressSpec_LoadBalancer_SubResourceEmbedded(source *v20240301s.PublicIPAddressSpec_LoadBalancer_SubResourceEmbedded) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		embedded.Reference = &reference
	} else {
		embedded.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		embedded.PropertyBag = propertyBag
	} else {
		embedded.PropertyBag = nil
	}

	// Invoke the augmentConversionForPublicIPAddressSpec_LoadBalancer_SubResourceEmbedded interface (if implemented) to customize the conversion
	var embeddedAsAny any = embedded
	if augmentedEmbedded, ok := embeddedAsAny.(augmentConversionForPublicIPAddressSpec_LoadBalancer_SubResourceEmbedded); ok {
		err := augmentedEmbedded.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_PublicIPAddressSpec_LoadBalancer_SubResourceEmbedded populates the provided destination PublicIPAddressSpec_LoadBalancer_SubResourceEmbedded from our PublicIPAddressSpec_LoadBalancer_SubResourceEmbedded
func (embedded *PublicIPAddressSpec_LoadBalancer_SubResourceEmbedded) AssignProperties_To_PublicIPAddressSpec_LoadBalancer_SubResourceEmbedded(destination *v20240301s.PublicIPAddressSpec_LoadBalancer_SubResourceEmbedded) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(embedded.PropertyBag)

	// Reference
	if embedded.Reference != nil {
		reference := embedded.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForPublicIPAddressSpec_LoadBalancer_SubResourceEmbedded interface (if implemented) to customize the conversion
	var embeddedAsAny any = embedded
	if augmentedEmbedded, ok := embeddedAsAny.(augmentConversionForPublicIPAddressSpec_LoadBalancer_SubResourceEmbedded); ok {
		err := augmentedEmbedded.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201101.Subnet_LoadBalancer_SubResourceEmbedded
// Subnet in a virtual network resource.
type Subnet_LoadBalancer_SubResourceEmbedded struct {
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`

	// Reference: Resource ID.
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

// AssignProperties_From_Subnet_LoadBalancer_SubResourceEmbedded populates our Subnet_LoadBalancer_SubResourceEmbedded from the provided source Subnet_LoadBalancer_SubResourceEmbedded
func (embedded *Subnet_LoadBalancer_SubResourceEmbedded) AssignProperties_From_Subnet_LoadBalancer_SubResourceEmbedded(source *v20240301s.Subnet_LoadBalancer_SubResourceEmbedded) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		embedded.Reference = &reference
	} else {
		embedded.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		embedded.PropertyBag = propertyBag
	} else {
		embedded.PropertyBag = nil
	}

	// Invoke the augmentConversionForSubnet_LoadBalancer_SubResourceEmbedded interface (if implemented) to customize the conversion
	var embeddedAsAny any = embedded
	if augmentedEmbedded, ok := embeddedAsAny.(augmentConversionForSubnet_LoadBalancer_SubResourceEmbedded); ok {
		err := augmentedEmbedded.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_Subnet_LoadBalancer_SubResourceEmbedded populates the provided destination Subnet_LoadBalancer_SubResourceEmbedded from our Subnet_LoadBalancer_SubResourceEmbedded
func (embedded *Subnet_LoadBalancer_SubResourceEmbedded) AssignProperties_To_Subnet_LoadBalancer_SubResourceEmbedded(destination *v20240301s.Subnet_LoadBalancer_SubResourceEmbedded) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(embedded.PropertyBag)

	// Reference
	if embedded.Reference != nil {
		reference := embedded.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForSubnet_LoadBalancer_SubResourceEmbedded interface (if implemented) to customize the conversion
	var embeddedAsAny any = embedded
	if augmentedEmbedded, ok := embeddedAsAny.(augmentConversionForSubnet_LoadBalancer_SubResourceEmbedded); ok {
		err := augmentedEmbedded.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201101.Subnet_STATUS_LoadBalancer_SubResourceEmbedded
// Subnet in a virtual network resource.
type Subnet_STATUS_LoadBalancer_SubResourceEmbedded struct {
	Id          *string                `json:"id,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_Subnet_STATUS_LoadBalancer_SubResourceEmbedded populates our Subnet_STATUS_LoadBalancer_SubResourceEmbedded from the provided source Subnet_STATUS_LoadBalancer_SubResourceEmbedded
func (embedded *Subnet_STATUS_LoadBalancer_SubResourceEmbedded) AssignProperties_From_Subnet_STATUS_LoadBalancer_SubResourceEmbedded(source *v20240301s.Subnet_STATUS_LoadBalancer_SubResourceEmbedded) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Id
	embedded.Id = genruntime.ClonePointerToString(source.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		embedded.PropertyBag = propertyBag
	} else {
		embedded.PropertyBag = nil
	}

	// Invoke the augmentConversionForSubnet_STATUS_LoadBalancer_SubResourceEmbedded interface (if implemented) to customize the conversion
	var embeddedAsAny any = embedded
	if augmentedEmbedded, ok := embeddedAsAny.(augmentConversionForSubnet_STATUS_LoadBalancer_SubResourceEmbedded); ok {
		err := augmentedEmbedded.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_Subnet_STATUS_LoadBalancer_SubResourceEmbedded populates the provided destination Subnet_STATUS_LoadBalancer_SubResourceEmbedded from our Subnet_STATUS_LoadBalancer_SubResourceEmbedded
func (embedded *Subnet_STATUS_LoadBalancer_SubResourceEmbedded) AssignProperties_To_Subnet_STATUS_LoadBalancer_SubResourceEmbedded(destination *v20240301s.Subnet_STATUS_LoadBalancer_SubResourceEmbedded) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(embedded.PropertyBag)

	// Id
	destination.Id = genruntime.ClonePointerToString(embedded.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForSubnet_STATUS_LoadBalancer_SubResourceEmbedded interface (if implemented) to customize the conversion
	var embeddedAsAny any = embedded
	if augmentedEmbedded, ok := embeddedAsAny.(augmentConversionForSubnet_STATUS_LoadBalancer_SubResourceEmbedded); ok {
		err := augmentedEmbedded.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

type augmentConversionForLoadBalancerBackendAddress interface {
	AssignPropertiesFrom(src *v20240301s.LoadBalancerBackendAddress) error
	AssignPropertiesTo(dst *v20240301s.LoadBalancerBackendAddress) error
}

type augmentConversionForLoadBalancerBackendAddress_STATUS interface {
	AssignPropertiesFrom(src *v20240301s.LoadBalancerBackendAddress_STATUS) error
	AssignPropertiesTo(dst *v20240301s.LoadBalancerBackendAddress_STATUS) error
}

type augmentConversionForNetworkInterfaceIPConfiguration_STATUS_LoadBalancer_SubResourceEmbedded interface {
	AssignPropertiesFrom(src *v20240301s.NetworkInterfaceIPConfiguration_STATUS_LoadBalancer_SubResourceEmbedded) error
	AssignPropertiesTo(dst *v20240301s.NetworkInterfaceIPConfiguration_STATUS_LoadBalancer_SubResourceEmbedded) error
}

type augmentConversionForPublicIPAddress_STATUS_LoadBalancer_SubResourceEmbedded interface {
	AssignPropertiesFrom(src *v20240301s.PublicIPAddress_STATUS_LoadBalancer_SubResourceEmbedded) error
	AssignPropertiesTo(dst *v20240301s.PublicIPAddress_STATUS_LoadBalancer_SubResourceEmbedded) error
}

type augmentConversionForPublicIPAddressSpec_LoadBalancer_SubResourceEmbedded interface {
	AssignPropertiesFrom(src *v20240301s.PublicIPAddressSpec_LoadBalancer_SubResourceEmbedded) error
	AssignPropertiesTo(dst *v20240301s.PublicIPAddressSpec_LoadBalancer_SubResourceEmbedded) error
}

type augmentConversionForSubnet_LoadBalancer_SubResourceEmbedded interface {
	AssignPropertiesFrom(src *v20240301s.Subnet_LoadBalancer_SubResourceEmbedded) error
	AssignPropertiesTo(dst *v20240301s.Subnet_LoadBalancer_SubResourceEmbedded) error
}

type augmentConversionForSubnet_STATUS_LoadBalancer_SubResourceEmbedded interface {
	AssignPropertiesFrom(src *v20240301s.Subnet_STATUS_LoadBalancer_SubResourceEmbedded) error
	AssignPropertiesTo(dst *v20240301s.Subnet_STATUS_LoadBalancer_SubResourceEmbedded) error
}

func init() {
	SchemeBuilder.Register(&LoadBalancer{}, &LoadBalancerList{})
}
