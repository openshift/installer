// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20220701

import (
	"fmt"
	arm "github.com/Azure/azure-service-operator/v2/api/network/v1api20220701/arm"
	storage "github.com/Azure/azure-service-operator/v2/api/network/v1api20220701/storage"
	"github.com/Azure/azure-service-operator/v2/internal/reflecthelpers"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/configmaps"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/core"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/secrets"
	"github.com/pkg/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
	"sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Generator information:
// - Generated from: /network/resource-manager/Microsoft.Network/stable/2022-07-01/applicationGateway.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/applicationGateways/{applicationGatewayName}
type ApplicationGateway struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ApplicationGateway_Spec                                          `json:"spec,omitempty"`
	Status            ApplicationGateway_STATUS_ApplicationGateway_SubResourceEmbedded `json:"status,omitempty"`
}

var _ conditions.Conditioner = &ApplicationGateway{}

// GetConditions returns the conditions of the resource
func (gateway *ApplicationGateway) GetConditions() conditions.Conditions {
	return gateway.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (gateway *ApplicationGateway) SetConditions(conditions conditions.Conditions) {
	gateway.Status.Conditions = conditions
}

var _ conversion.Convertible = &ApplicationGateway{}

// ConvertFrom populates our ApplicationGateway from the provided hub ApplicationGateway
func (gateway *ApplicationGateway) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*storage.ApplicationGateway)
	if !ok {
		return fmt.Errorf("expected network/v1api20220701/storage/ApplicationGateway but received %T instead", hub)
	}

	return gateway.AssignProperties_From_ApplicationGateway(source)
}

// ConvertTo populates the provided hub ApplicationGateway from our ApplicationGateway
func (gateway *ApplicationGateway) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*storage.ApplicationGateway)
	if !ok {
		return fmt.Errorf("expected network/v1api20220701/storage/ApplicationGateway but received %T instead", hub)
	}

	return gateway.AssignProperties_To_ApplicationGateway(destination)
}

// +kubebuilder:webhook:path=/mutate-network-azure-com-v1api20220701-applicationgateway,mutating=true,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=network.azure.com,resources=applicationgateways,verbs=create;update,versions=v1api20220701,name=default.v1api20220701.applicationgateways.network.azure.com,admissionReviewVersions=v1

var _ admission.Defaulter = &ApplicationGateway{}

// Default applies defaults to the ApplicationGateway resource
func (gateway *ApplicationGateway) Default() {
	gateway.defaultImpl()
	var temp any = gateway
	if runtimeDefaulter, ok := temp.(genruntime.Defaulter); ok {
		runtimeDefaulter.CustomDefault()
	}
}

// defaultAzureName defaults the Azure name of the resource to the Kubernetes name
func (gateway *ApplicationGateway) defaultAzureName() {
	if gateway.Spec.AzureName == "" {
		gateway.Spec.AzureName = gateway.Name
	}
}

// defaultImpl applies the code generated defaults to the ApplicationGateway resource
func (gateway *ApplicationGateway) defaultImpl() { gateway.defaultAzureName() }

var _ configmaps.Exporter = &ApplicationGateway{}

// ConfigMapDestinationExpressions returns the Spec.OperatorSpec.ConfigMapExpressions property
func (gateway *ApplicationGateway) ConfigMapDestinationExpressions() []*core.DestinationExpression {
	if gateway.Spec.OperatorSpec == nil {
		return nil
	}
	return gateway.Spec.OperatorSpec.ConfigMapExpressions
}

var _ secrets.Exporter = &ApplicationGateway{}

// SecretDestinationExpressions returns the Spec.OperatorSpec.SecretExpressions property
func (gateway *ApplicationGateway) SecretDestinationExpressions() []*core.DestinationExpression {
	if gateway.Spec.OperatorSpec == nil {
		return nil
	}
	return gateway.Spec.OperatorSpec.SecretExpressions
}

var _ genruntime.ImportableResource = &ApplicationGateway{}

// InitializeSpec initializes the spec for this resource from the given status
func (gateway *ApplicationGateway) InitializeSpec(status genruntime.ConvertibleStatus) error {
	if s, ok := status.(*ApplicationGateway_STATUS_ApplicationGateway_SubResourceEmbedded); ok {
		return gateway.Spec.Initialize_From_ApplicationGateway_STATUS_ApplicationGateway_SubResourceEmbedded(s)
	}

	return fmt.Errorf("expected Status of type ApplicationGateway_STATUS_ApplicationGateway_SubResourceEmbedded but received %T instead", status)
}

var _ genruntime.KubernetesResource = &ApplicationGateway{}

// AzureName returns the Azure name of the resource
func (gateway *ApplicationGateway) AzureName() string {
	return gateway.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2022-07-01"
func (gateway ApplicationGateway) GetAPIVersion() string {
	return "2022-07-01"
}

// GetResourceScope returns the scope of the resource
func (gateway *ApplicationGateway) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (gateway *ApplicationGateway) GetSpec() genruntime.ConvertibleSpec {
	return &gateway.Spec
}

// GetStatus returns the status of this resource
func (gateway *ApplicationGateway) GetStatus() genruntime.ConvertibleStatus {
	return &gateway.Status
}

// GetSupportedOperations returns the operations supported by the resource
func (gateway *ApplicationGateway) GetSupportedOperations() []genruntime.ResourceOperation {
	return []genruntime.ResourceOperation{
		genruntime.ResourceOperationDelete,
		genruntime.ResourceOperationGet,
		genruntime.ResourceOperationPut,
	}
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.Network/applicationGateways"
func (gateway *ApplicationGateway) GetType() string {
	return "Microsoft.Network/applicationGateways"
}

// NewEmptyStatus returns a new empty (blank) status
func (gateway *ApplicationGateway) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &ApplicationGateway_STATUS_ApplicationGateway_SubResourceEmbedded{}
}

// Owner returns the ResourceReference of the owner
func (gateway *ApplicationGateway) Owner() *genruntime.ResourceReference {
	group, kind := genruntime.LookupOwnerGroupKind(gateway.Spec)
	return gateway.Spec.Owner.AsResourceReference(group, kind)
}

// SetStatus sets the status of this resource
func (gateway *ApplicationGateway) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*ApplicationGateway_STATUS_ApplicationGateway_SubResourceEmbedded); ok {
		gateway.Status = *st
		return nil
	}

	// Convert status to required version
	var st ApplicationGateway_STATUS_ApplicationGateway_SubResourceEmbedded
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return errors.Wrap(err, "failed to convert status")
	}

	gateway.Status = st
	return nil
}

// +kubebuilder:webhook:path=/validate-network-azure-com-v1api20220701-applicationgateway,mutating=false,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=network.azure.com,resources=applicationgateways,verbs=create;update,versions=v1api20220701,name=validate.v1api20220701.applicationgateways.network.azure.com,admissionReviewVersions=v1

var _ admission.Validator = &ApplicationGateway{}

// ValidateCreate validates the creation of the resource
func (gateway *ApplicationGateway) ValidateCreate() (admission.Warnings, error) {
	validations := gateway.createValidations()
	var temp any = gateway
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.CreateValidations()...)
	}
	return genruntime.ValidateCreate(validations)
}

// ValidateDelete validates the deletion of the resource
func (gateway *ApplicationGateway) ValidateDelete() (admission.Warnings, error) {
	validations := gateway.deleteValidations()
	var temp any = gateway
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.DeleteValidations()...)
	}
	return genruntime.ValidateDelete(validations)
}

// ValidateUpdate validates an update of the resource
func (gateway *ApplicationGateway) ValidateUpdate(old runtime.Object) (admission.Warnings, error) {
	validations := gateway.updateValidations()
	var temp any = gateway
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.UpdateValidations()...)
	}
	return genruntime.ValidateUpdate(old, validations)
}

// createValidations validates the creation of the resource
func (gateway *ApplicationGateway) createValidations() []func() (admission.Warnings, error) {
	return []func() (admission.Warnings, error){gateway.validateResourceReferences, gateway.validateOwnerReference, gateway.validateSecretDestinations, gateway.validateConfigMapDestinations}
}

// deleteValidations validates the deletion of the resource
func (gateway *ApplicationGateway) deleteValidations() []func() (admission.Warnings, error) {
	return nil
}

// updateValidations validates the update of the resource
func (gateway *ApplicationGateway) updateValidations() []func(old runtime.Object) (admission.Warnings, error) {
	return []func(old runtime.Object) (admission.Warnings, error){
		func(old runtime.Object) (admission.Warnings, error) {
			return gateway.validateResourceReferences()
		},
		gateway.validateWriteOnceProperties,
		func(old runtime.Object) (admission.Warnings, error) {
			return gateway.validateOwnerReference()
		},
		func(old runtime.Object) (admission.Warnings, error) {
			return gateway.validateSecretDestinations()
		},
		func(old runtime.Object) (admission.Warnings, error) {
			return gateway.validateConfigMapDestinations()
		},
	}
}

// validateConfigMapDestinations validates there are no colliding genruntime.ConfigMapDestinations
func (gateway *ApplicationGateway) validateConfigMapDestinations() (admission.Warnings, error) {
	if gateway.Spec.OperatorSpec == nil {
		return nil, nil
	}
	return configmaps.ValidateDestinations(gateway, nil, gateway.Spec.OperatorSpec.ConfigMapExpressions)
}

// validateOwnerReference validates the owner field
func (gateway *ApplicationGateway) validateOwnerReference() (admission.Warnings, error) {
	return genruntime.ValidateOwner(gateway)
}

// validateResourceReferences validates all resource references
func (gateway *ApplicationGateway) validateResourceReferences() (admission.Warnings, error) {
	refs, err := reflecthelpers.FindResourceReferences(&gateway.Spec)
	if err != nil {
		return nil, err
	}
	return genruntime.ValidateResourceReferences(refs)
}

// validateSecretDestinations validates there are no colliding genruntime.SecretDestination's
func (gateway *ApplicationGateway) validateSecretDestinations() (admission.Warnings, error) {
	if gateway.Spec.OperatorSpec == nil {
		return nil, nil
	}
	return secrets.ValidateDestinations(gateway, nil, gateway.Spec.OperatorSpec.SecretExpressions)
}

// validateWriteOnceProperties validates all WriteOnce properties
func (gateway *ApplicationGateway) validateWriteOnceProperties(old runtime.Object) (admission.Warnings, error) {
	oldObj, ok := old.(*ApplicationGateway)
	if !ok {
		return nil, nil
	}

	return genruntime.ValidateWriteOnceProperties(oldObj, gateway)
}

// AssignProperties_From_ApplicationGateway populates our ApplicationGateway from the provided source ApplicationGateway
func (gateway *ApplicationGateway) AssignProperties_From_ApplicationGateway(source *storage.ApplicationGateway) error {

	// ObjectMeta
	gateway.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec ApplicationGateway_Spec
	err := spec.AssignProperties_From_ApplicationGateway_Spec(&source.Spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_ApplicationGateway_Spec() to populate field Spec")
	}
	gateway.Spec = spec

	// Status
	var status ApplicationGateway_STATUS_ApplicationGateway_SubResourceEmbedded
	err = status.AssignProperties_From_ApplicationGateway_STATUS_ApplicationGateway_SubResourceEmbedded(&source.Status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_ApplicationGateway_STATUS_ApplicationGateway_SubResourceEmbedded() to populate field Status")
	}
	gateway.Status = status

	// No error
	return nil
}

// AssignProperties_To_ApplicationGateway populates the provided destination ApplicationGateway from our ApplicationGateway
func (gateway *ApplicationGateway) AssignProperties_To_ApplicationGateway(destination *storage.ApplicationGateway) error {

	// ObjectMeta
	destination.ObjectMeta = *gateway.ObjectMeta.DeepCopy()

	// Spec
	var spec storage.ApplicationGateway_Spec
	err := gateway.Spec.AssignProperties_To_ApplicationGateway_Spec(&spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_ApplicationGateway_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status storage.ApplicationGateway_STATUS_ApplicationGateway_SubResourceEmbedded
	err = gateway.Status.AssignProperties_To_ApplicationGateway_STATUS_ApplicationGateway_SubResourceEmbedded(&status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_ApplicationGateway_STATUS_ApplicationGateway_SubResourceEmbedded() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (gateway *ApplicationGateway) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: gateway.Spec.OriginalVersion(),
		Kind:    "ApplicationGateway",
	}
}

// +kubebuilder:object:root=true
// Generator information:
// - Generated from: /network/resource-manager/Microsoft.Network/stable/2022-07-01/applicationGateway.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/applicationGateways/{applicationGatewayName}
type ApplicationGatewayList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ApplicationGateway `json:"items"`
}

// +kubebuilder:validation:Enum={"2022-07-01"}
type APIVersion string

const APIVersion_Value = APIVersion("2022-07-01")

type ApplicationGateway_Spec struct {
	// AuthenticationCertificates: Authentication certificates of the application gateway resource. For default limits, see
	// [Application Gateway
	// limits](https://docs.microsoft.com/azure/azure-subscription-service-limits#application-gateway-limits).
	AuthenticationCertificates []ApplicationGatewayAuthenticationCertificate `json:"authenticationCertificates,omitempty"`

	// AutoscaleConfiguration: Autoscale Configuration.
	AutoscaleConfiguration *ApplicationGatewayAutoscaleConfiguration `json:"autoscaleConfiguration,omitempty"`

	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName string `json:"azureName,omitempty"`

	// BackendAddressPools: Backend address pool of the application gateway resource. For default limits, see [Application
	// Gateway limits](https://docs.microsoft.com/azure/azure-subscription-service-limits#application-gateway-limits).
	BackendAddressPools []ApplicationGatewayBackendAddressPool `json:"backendAddressPools,omitempty"`

	// BackendHttpSettingsCollection: Backend http settings of the application gateway resource. For default limits, see
	// [Application Gateway
	// limits](https://docs.microsoft.com/azure/azure-subscription-service-limits#application-gateway-limits).
	BackendHttpSettingsCollection []ApplicationGatewayBackendHttpSettings `json:"backendHttpSettingsCollection,omitempty"`

	// BackendSettingsCollection: Backend settings of the application gateway resource. For default limits, see [Application
	// Gateway limits](https://docs.microsoft.com/azure/azure-subscription-service-limits#application-gateway-limits).
	BackendSettingsCollection []ApplicationGatewayBackendSettings `json:"backendSettingsCollection,omitempty"`

	// CustomErrorConfigurations: Custom error configurations of the application gateway resource.
	CustomErrorConfigurations []ApplicationGatewayCustomError `json:"customErrorConfigurations,omitempty"`

	// EnableFips: Whether FIPS is enabled on the application gateway resource.
	EnableFips *bool `json:"enableFips,omitempty"`

	// EnableHttp2: Whether HTTP2 is enabled on the application gateway resource.
	EnableHttp2 *bool `json:"enableHttp2,omitempty"`

	// FirewallPolicy: Reference to the FirewallPolicy resource.
	FirewallPolicy *SubResource `json:"firewallPolicy,omitempty"`

	// ForceFirewallPolicyAssociation: If true, associates a firewall policy with an application gateway regardless whether the
	// policy differs from the WAF Config.
	ForceFirewallPolicyAssociation *bool `json:"forceFirewallPolicyAssociation,omitempty"`

	// FrontendIPConfigurations: Frontend IP addresses of the application gateway resource. For default limits, see
	// [Application Gateway
	// limits](https://docs.microsoft.com/azure/azure-subscription-service-limits#application-gateway-limits).
	FrontendIPConfigurations []ApplicationGatewayFrontendIPConfiguration `json:"frontendIPConfigurations,omitempty"`

	// FrontendPorts: Frontend ports of the application gateway resource. For default limits, see [Application Gateway
	// limits](https://docs.microsoft.com/azure/azure-subscription-service-limits#application-gateway-limits).
	FrontendPorts []ApplicationGatewayFrontendPort `json:"frontendPorts,omitempty"`

	// GatewayIPConfigurations: Subnets of the application gateway resource. For default limits, see [Application Gateway
	// limits](https://docs.microsoft.com/azure/azure-subscription-service-limits#application-gateway-limits).
	GatewayIPConfigurations []ApplicationGatewayIPConfiguration_ApplicationGateway_SubResourceEmbedded `json:"gatewayIPConfigurations,omitempty"`

	// GlobalConfiguration: Global Configuration.
	GlobalConfiguration *ApplicationGatewayGlobalConfiguration `json:"globalConfiguration,omitempty"`

	// HttpListeners: Http listeners of the application gateway resource. For default limits, see [Application Gateway
	// limits](https://docs.microsoft.com/azure/azure-subscription-service-limits#application-gateway-limits).
	HttpListeners []ApplicationGatewayHttpListener `json:"httpListeners,omitempty"`

	// Identity: The identity of the application gateway, if configured.
	Identity *ManagedServiceIdentity `json:"identity,omitempty"`

	// Listeners: Listeners of the application gateway resource. For default limits, see [Application Gateway
	// limits](https://docs.microsoft.com/azure/azure-subscription-service-limits#application-gateway-limits).
	Listeners []ApplicationGatewayListener `json:"listeners,omitempty"`

	// LoadDistributionPolicies: Load distribution policies of the application gateway resource.
	LoadDistributionPolicies []ApplicationGatewayLoadDistributionPolicy `json:"loadDistributionPolicies,omitempty"`

	// Location: Resource location.
	Location *string `json:"location,omitempty"`

	// OperatorSpec: The specification for configuring operator behavior. This field is interpreted by the operator and not
	// passed directly to Azure
	OperatorSpec *ApplicationGatewayOperatorSpec `json:"operatorSpec,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a resources.azure.com/ResourceGroup resource
	Owner *genruntime.KnownResourceReference `group:"resources.azure.com" json:"owner,omitempty" kind:"ResourceGroup"`

	// PrivateLinkConfigurations: PrivateLink configurations on application gateway.
	PrivateLinkConfigurations []ApplicationGatewayPrivateLinkConfiguration `json:"privateLinkConfigurations,omitempty"`

	// Probes: Probes of the application gateway resource.
	Probes []ApplicationGatewayProbe `json:"probes,omitempty"`

	// RedirectConfigurations: Redirect configurations of the application gateway resource. For default limits, see
	// [Application Gateway
	// limits](https://docs.microsoft.com/azure/azure-subscription-service-limits#application-gateway-limits).
	RedirectConfigurations []ApplicationGatewayRedirectConfiguration `json:"redirectConfigurations,omitempty"`

	// RequestRoutingRules: Request routing rules of the application gateway resource.
	RequestRoutingRules []ApplicationGatewayRequestRoutingRule `json:"requestRoutingRules,omitempty"`

	// RewriteRuleSets: Rewrite rules for the application gateway resource.
	RewriteRuleSets []ApplicationGatewayRewriteRuleSet `json:"rewriteRuleSets,omitempty"`

	// RoutingRules: Routing rules of the application gateway resource.
	RoutingRules []ApplicationGatewayRoutingRule `json:"routingRules,omitempty"`

	// Sku: SKU of the application gateway resource.
	Sku *ApplicationGatewaySku `json:"sku,omitempty"`

	// SslCertificates: SSL certificates of the application gateway resource. For default limits, see [Application Gateway
	// limits](https://docs.microsoft.com/azure/azure-subscription-service-limits#application-gateway-limits).
	SslCertificates []ApplicationGatewaySslCertificate `json:"sslCertificates,omitempty"`

	// SslPolicy: SSL policy of the application gateway resource.
	SslPolicy *ApplicationGatewaySslPolicy `json:"sslPolicy,omitempty"`

	// SslProfiles: SSL profiles of the application gateway resource. For default limits, see [Application Gateway
	// limits](https://docs.microsoft.com/azure/azure-subscription-service-limits#application-gateway-limits).
	SslProfiles []ApplicationGatewaySslProfile `json:"sslProfiles,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`

	// TrustedClientCertificates: Trusted client certificates of the application gateway resource. For default limits, see
	// [Application Gateway
	// limits](https://docs.microsoft.com/azure/azure-subscription-service-limits#application-gateway-limits).
	TrustedClientCertificates []ApplicationGatewayTrustedClientCertificate `json:"trustedClientCertificates,omitempty"`

	// TrustedRootCertificates: Trusted Root certificates of the application gateway resource. For default limits, see
	// [Application Gateway
	// limits](https://docs.microsoft.com/azure/azure-subscription-service-limits#application-gateway-limits).
	TrustedRootCertificates []ApplicationGatewayTrustedRootCertificate `json:"trustedRootCertificates,omitempty"`

	// UrlPathMaps: URL path map of the application gateway resource. For default limits, see [Application Gateway
	// limits](https://docs.microsoft.com/azure/azure-subscription-service-limits#application-gateway-limits).
	UrlPathMaps []ApplicationGatewayUrlPathMap `json:"urlPathMaps,omitempty"`

	// WebApplicationFirewallConfiguration: Web application firewall configuration.
	WebApplicationFirewallConfiguration *ApplicationGatewayWebApplicationFirewallConfiguration `json:"webApplicationFirewallConfiguration,omitempty"`

	// Zones: A list of availability zones denoting where the resource needs to come from.
	Zones []string `json:"zones,omitempty"`
}

var _ genruntime.ARMTransformer = &ApplicationGateway_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (gateway *ApplicationGateway_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if gateway == nil {
		return nil, nil
	}
	result := &arm.ApplicationGateway_Spec{}

	// Set property "Identity":
	if gateway.Identity != nil {
		identity_ARM, err := (*gateway.Identity).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		identity := *identity_ARM.(*arm.ManagedServiceIdentity)
		result.Identity = &identity
	}

	// Set property "Location":
	if gateway.Location != nil {
		location := *gateway.Location
		result.Location = &location
	}

	// Set property "Name":
	result.Name = resolved.Name

	// Set property "Properties":
	if gateway.AuthenticationCertificates != nil ||
		gateway.AutoscaleConfiguration != nil ||
		gateway.BackendAddressPools != nil ||
		gateway.BackendHttpSettingsCollection != nil ||
		gateway.BackendSettingsCollection != nil ||
		gateway.CustomErrorConfigurations != nil ||
		gateway.EnableFips != nil ||
		gateway.EnableHttp2 != nil ||
		gateway.FirewallPolicy != nil ||
		gateway.ForceFirewallPolicyAssociation != nil ||
		gateway.FrontendIPConfigurations != nil ||
		gateway.FrontendPorts != nil ||
		gateway.GatewayIPConfigurations != nil ||
		gateway.GlobalConfiguration != nil ||
		gateway.HttpListeners != nil ||
		gateway.Listeners != nil ||
		gateway.LoadDistributionPolicies != nil ||
		gateway.PrivateLinkConfigurations != nil ||
		gateway.Probes != nil ||
		gateway.RedirectConfigurations != nil ||
		gateway.RequestRoutingRules != nil ||
		gateway.RewriteRuleSets != nil ||
		gateway.RoutingRules != nil ||
		gateway.Sku != nil ||
		gateway.SslCertificates != nil ||
		gateway.SslPolicy != nil ||
		gateway.SslProfiles != nil ||
		gateway.TrustedClientCertificates != nil ||
		gateway.TrustedRootCertificates != nil ||
		gateway.UrlPathMaps != nil ||
		gateway.WebApplicationFirewallConfiguration != nil {
		result.Properties = &arm.ApplicationGatewayPropertiesFormat{}
	}
	for _, item := range gateway.AuthenticationCertificates {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.AuthenticationCertificates = append(result.Properties.AuthenticationCertificates, *item_ARM.(*arm.ApplicationGatewayAuthenticationCertificate))
	}
	if gateway.AutoscaleConfiguration != nil {
		autoscaleConfiguration_ARM, err := (*gateway.AutoscaleConfiguration).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		autoscaleConfiguration := *autoscaleConfiguration_ARM.(*arm.ApplicationGatewayAutoscaleConfiguration)
		result.Properties.AutoscaleConfiguration = &autoscaleConfiguration
	}
	for _, item := range gateway.BackendAddressPools {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.BackendAddressPools = append(result.Properties.BackendAddressPools, *item_ARM.(*arm.ApplicationGatewayBackendAddressPool))
	}
	for _, item := range gateway.BackendHttpSettingsCollection {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.BackendHttpSettingsCollection = append(result.Properties.BackendHttpSettingsCollection, *item_ARM.(*arm.ApplicationGatewayBackendHttpSettings))
	}
	for _, item := range gateway.BackendSettingsCollection {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.BackendSettingsCollection = append(result.Properties.BackendSettingsCollection, *item_ARM.(*arm.ApplicationGatewayBackendSettings))
	}
	for _, item := range gateway.CustomErrorConfigurations {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.CustomErrorConfigurations = append(result.Properties.CustomErrorConfigurations, *item_ARM.(*arm.ApplicationGatewayCustomError))
	}
	if gateway.EnableFips != nil {
		enableFips := *gateway.EnableFips
		result.Properties.EnableFips = &enableFips
	}
	if gateway.EnableHttp2 != nil {
		enableHttp2 := *gateway.EnableHttp2
		result.Properties.EnableHttp2 = &enableHttp2
	}
	if gateway.FirewallPolicy != nil {
		firewallPolicy_ARM, err := (*gateway.FirewallPolicy).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		firewallPolicy := *firewallPolicy_ARM.(*arm.SubResource)
		result.Properties.FirewallPolicy = &firewallPolicy
	}
	if gateway.ForceFirewallPolicyAssociation != nil {
		forceFirewallPolicyAssociation := *gateway.ForceFirewallPolicyAssociation
		result.Properties.ForceFirewallPolicyAssociation = &forceFirewallPolicyAssociation
	}
	for _, item := range gateway.FrontendIPConfigurations {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.FrontendIPConfigurations = append(result.Properties.FrontendIPConfigurations, *item_ARM.(*arm.ApplicationGatewayFrontendIPConfiguration))
	}
	for _, item := range gateway.FrontendPorts {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.FrontendPorts = append(result.Properties.FrontendPorts, *item_ARM.(*arm.ApplicationGatewayFrontendPort))
	}
	for _, item := range gateway.GatewayIPConfigurations {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.GatewayIPConfigurations = append(result.Properties.GatewayIPConfigurations, *item_ARM.(*arm.ApplicationGatewayIPConfiguration_ApplicationGateway_SubResourceEmbedded))
	}
	if gateway.GlobalConfiguration != nil {
		globalConfiguration_ARM, err := (*gateway.GlobalConfiguration).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		globalConfiguration := *globalConfiguration_ARM.(*arm.ApplicationGatewayGlobalConfiguration)
		result.Properties.GlobalConfiguration = &globalConfiguration
	}
	for _, item := range gateway.HttpListeners {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.HttpListeners = append(result.Properties.HttpListeners, *item_ARM.(*arm.ApplicationGatewayHttpListener))
	}
	for _, item := range gateway.Listeners {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.Listeners = append(result.Properties.Listeners, *item_ARM.(*arm.ApplicationGatewayListener))
	}
	for _, item := range gateway.LoadDistributionPolicies {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.LoadDistributionPolicies = append(result.Properties.LoadDistributionPolicies, *item_ARM.(*arm.ApplicationGatewayLoadDistributionPolicy))
	}
	for _, item := range gateway.PrivateLinkConfigurations {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.PrivateLinkConfigurations = append(result.Properties.PrivateLinkConfigurations, *item_ARM.(*arm.ApplicationGatewayPrivateLinkConfiguration))
	}
	for _, item := range gateway.Probes {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.Probes = append(result.Properties.Probes, *item_ARM.(*arm.ApplicationGatewayProbe))
	}
	for _, item := range gateway.RedirectConfigurations {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.RedirectConfigurations = append(result.Properties.RedirectConfigurations, *item_ARM.(*arm.ApplicationGatewayRedirectConfiguration))
	}
	for _, item := range gateway.RequestRoutingRules {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.RequestRoutingRules = append(result.Properties.RequestRoutingRules, *item_ARM.(*arm.ApplicationGatewayRequestRoutingRule))
	}
	for _, item := range gateway.RewriteRuleSets {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.RewriteRuleSets = append(result.Properties.RewriteRuleSets, *item_ARM.(*arm.ApplicationGatewayRewriteRuleSet))
	}
	for _, item := range gateway.RoutingRules {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.RoutingRules = append(result.Properties.RoutingRules, *item_ARM.(*arm.ApplicationGatewayRoutingRule))
	}
	if gateway.Sku != nil {
		sku_ARM, err := (*gateway.Sku).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		sku := *sku_ARM.(*arm.ApplicationGatewaySku)
		result.Properties.Sku = &sku
	}
	for _, item := range gateway.SslCertificates {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.SslCertificates = append(result.Properties.SslCertificates, *item_ARM.(*arm.ApplicationGatewaySslCertificate))
	}
	if gateway.SslPolicy != nil {
		sslPolicy_ARM, err := (*gateway.SslPolicy).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		sslPolicy := *sslPolicy_ARM.(*arm.ApplicationGatewaySslPolicy)
		result.Properties.SslPolicy = &sslPolicy
	}
	for _, item := range gateway.SslProfiles {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.SslProfiles = append(result.Properties.SslProfiles, *item_ARM.(*arm.ApplicationGatewaySslProfile))
	}
	for _, item := range gateway.TrustedClientCertificates {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.TrustedClientCertificates = append(result.Properties.TrustedClientCertificates, *item_ARM.(*arm.ApplicationGatewayTrustedClientCertificate))
	}
	for _, item := range gateway.TrustedRootCertificates {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.TrustedRootCertificates = append(result.Properties.TrustedRootCertificates, *item_ARM.(*arm.ApplicationGatewayTrustedRootCertificate))
	}
	for _, item := range gateway.UrlPathMaps {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.UrlPathMaps = append(result.Properties.UrlPathMaps, *item_ARM.(*arm.ApplicationGatewayUrlPathMap))
	}
	if gateway.WebApplicationFirewallConfiguration != nil {
		webApplicationFirewallConfiguration_ARM, err := (*gateway.WebApplicationFirewallConfiguration).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		webApplicationFirewallConfiguration := *webApplicationFirewallConfiguration_ARM.(*arm.ApplicationGatewayWebApplicationFirewallConfiguration)
		result.Properties.WebApplicationFirewallConfiguration = &webApplicationFirewallConfiguration
	}

	// Set property "Tags":
	if gateway.Tags != nil {
		result.Tags = make(map[string]string, len(gateway.Tags))
		for key, value := range gateway.Tags {
			result.Tags[key] = value
		}
	}

	// Set property "Zones":
	for _, item := range gateway.Zones {
		result.Zones = append(result.Zones, item)
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (gateway *ApplicationGateway_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApplicationGateway_Spec{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (gateway *ApplicationGateway_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApplicationGateway_Spec)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApplicationGateway_Spec, got %T", armInput)
	}

	// Set property "AuthenticationCertificates":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.AuthenticationCertificates {
			var item1 ApplicationGatewayAuthenticationCertificate
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			gateway.AuthenticationCertificates = append(gateway.AuthenticationCertificates, item1)
		}
	}

	// Set property "AutoscaleConfiguration":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AutoscaleConfiguration != nil {
			var autoscaleConfiguration1 ApplicationGatewayAutoscaleConfiguration
			err := autoscaleConfiguration1.PopulateFromARM(owner, *typedInput.Properties.AutoscaleConfiguration)
			if err != nil {
				return err
			}
			autoscaleConfiguration := autoscaleConfiguration1
			gateway.AutoscaleConfiguration = &autoscaleConfiguration
		}
	}

	// Set property "AzureName":
	gateway.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property "BackendAddressPools":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.BackendAddressPools {
			var item1 ApplicationGatewayBackendAddressPool
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			gateway.BackendAddressPools = append(gateway.BackendAddressPools, item1)
		}
	}

	// Set property "BackendHttpSettingsCollection":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.BackendHttpSettingsCollection {
			var item1 ApplicationGatewayBackendHttpSettings
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			gateway.BackendHttpSettingsCollection = append(gateway.BackendHttpSettingsCollection, item1)
		}
	}

	// Set property "BackendSettingsCollection":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.BackendSettingsCollection {
			var item1 ApplicationGatewayBackendSettings
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			gateway.BackendSettingsCollection = append(gateway.BackendSettingsCollection, item1)
		}
	}

	// Set property "CustomErrorConfigurations":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.CustomErrorConfigurations {
			var item1 ApplicationGatewayCustomError
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			gateway.CustomErrorConfigurations = append(gateway.CustomErrorConfigurations, item1)
		}
	}

	// Set property "EnableFips":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableFips != nil {
			enableFips := *typedInput.Properties.EnableFips
			gateway.EnableFips = &enableFips
		}
	}

	// Set property "EnableHttp2":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableHttp2 != nil {
			enableHttp2 := *typedInput.Properties.EnableHttp2
			gateway.EnableHttp2 = &enableHttp2
		}
	}

	// Set property "FirewallPolicy":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.FirewallPolicy != nil {
			var firewallPolicy1 SubResource
			err := firewallPolicy1.PopulateFromARM(owner, *typedInput.Properties.FirewallPolicy)
			if err != nil {
				return err
			}
			firewallPolicy := firewallPolicy1
			gateway.FirewallPolicy = &firewallPolicy
		}
	}

	// Set property "ForceFirewallPolicyAssociation":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ForceFirewallPolicyAssociation != nil {
			forceFirewallPolicyAssociation := *typedInput.Properties.ForceFirewallPolicyAssociation
			gateway.ForceFirewallPolicyAssociation = &forceFirewallPolicyAssociation
		}
	}

	// Set property "FrontendIPConfigurations":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.FrontendIPConfigurations {
			var item1 ApplicationGatewayFrontendIPConfiguration
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			gateway.FrontendIPConfigurations = append(gateway.FrontendIPConfigurations, item1)
		}
	}

	// Set property "FrontendPorts":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.FrontendPorts {
			var item1 ApplicationGatewayFrontendPort
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			gateway.FrontendPorts = append(gateway.FrontendPorts, item1)
		}
	}

	// Set property "GatewayIPConfigurations":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.GatewayIPConfigurations {
			var item1 ApplicationGatewayIPConfiguration_ApplicationGateway_SubResourceEmbedded
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			gateway.GatewayIPConfigurations = append(gateway.GatewayIPConfigurations, item1)
		}
	}

	// Set property "GlobalConfiguration":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.GlobalConfiguration != nil {
			var globalConfiguration1 ApplicationGatewayGlobalConfiguration
			err := globalConfiguration1.PopulateFromARM(owner, *typedInput.Properties.GlobalConfiguration)
			if err != nil {
				return err
			}
			globalConfiguration := globalConfiguration1
			gateway.GlobalConfiguration = &globalConfiguration
		}
	}

	// Set property "HttpListeners":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.HttpListeners {
			var item1 ApplicationGatewayHttpListener
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			gateway.HttpListeners = append(gateway.HttpListeners, item1)
		}
	}

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 ManagedServiceIdentity
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		gateway.Identity = &identity
	}

	// Set property "Listeners":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Listeners {
			var item1 ApplicationGatewayListener
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			gateway.Listeners = append(gateway.Listeners, item1)
		}
	}

	// Set property "LoadDistributionPolicies":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.LoadDistributionPolicies {
			var item1 ApplicationGatewayLoadDistributionPolicy
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			gateway.LoadDistributionPolicies = append(gateway.LoadDistributionPolicies, item1)
		}
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		gateway.Location = &location
	}

	// no assignment for property "OperatorSpec"

	// Set property "Owner":
	gateway.Owner = &genruntime.KnownResourceReference{
		Name:  owner.Name,
		ARMID: owner.ARMID,
	}

	// Set property "PrivateLinkConfigurations":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.PrivateLinkConfigurations {
			var item1 ApplicationGatewayPrivateLinkConfiguration
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			gateway.PrivateLinkConfigurations = append(gateway.PrivateLinkConfigurations, item1)
		}
	}

	// Set property "Probes":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Probes {
			var item1 ApplicationGatewayProbe
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			gateway.Probes = append(gateway.Probes, item1)
		}
	}

	// Set property "RedirectConfigurations":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.RedirectConfigurations {
			var item1 ApplicationGatewayRedirectConfiguration
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			gateway.RedirectConfigurations = append(gateway.RedirectConfigurations, item1)
		}
	}

	// Set property "RequestRoutingRules":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.RequestRoutingRules {
			var item1 ApplicationGatewayRequestRoutingRule
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			gateway.RequestRoutingRules = append(gateway.RequestRoutingRules, item1)
		}
	}

	// Set property "RewriteRuleSets":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.RewriteRuleSets {
			var item1 ApplicationGatewayRewriteRuleSet
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			gateway.RewriteRuleSets = append(gateway.RewriteRuleSets, item1)
		}
	}

	// Set property "RoutingRules":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.RoutingRules {
			var item1 ApplicationGatewayRoutingRule
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			gateway.RoutingRules = append(gateway.RoutingRules, item1)
		}
	}

	// Set property "Sku":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Sku != nil {
			var sku1 ApplicationGatewaySku
			err := sku1.PopulateFromARM(owner, *typedInput.Properties.Sku)
			if err != nil {
				return err
			}
			sku := sku1
			gateway.Sku = &sku
		}
	}

	// Set property "SslCertificates":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.SslCertificates {
			var item1 ApplicationGatewaySslCertificate
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			gateway.SslCertificates = append(gateway.SslCertificates, item1)
		}
	}

	// Set property "SslPolicy":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.SslPolicy != nil {
			var sslPolicy1 ApplicationGatewaySslPolicy
			err := sslPolicy1.PopulateFromARM(owner, *typedInput.Properties.SslPolicy)
			if err != nil {
				return err
			}
			sslPolicy := sslPolicy1
			gateway.SslPolicy = &sslPolicy
		}
	}

	// Set property "SslProfiles":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.SslProfiles {
			var item1 ApplicationGatewaySslProfile
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			gateway.SslProfiles = append(gateway.SslProfiles, item1)
		}
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		gateway.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			gateway.Tags[key] = value
		}
	}

	// Set property "TrustedClientCertificates":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.TrustedClientCertificates {
			var item1 ApplicationGatewayTrustedClientCertificate
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			gateway.TrustedClientCertificates = append(gateway.TrustedClientCertificates, item1)
		}
	}

	// Set property "TrustedRootCertificates":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.TrustedRootCertificates {
			var item1 ApplicationGatewayTrustedRootCertificate
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			gateway.TrustedRootCertificates = append(gateway.TrustedRootCertificates, item1)
		}
	}

	// Set property "UrlPathMaps":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.UrlPathMaps {
			var item1 ApplicationGatewayUrlPathMap
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			gateway.UrlPathMaps = append(gateway.UrlPathMaps, item1)
		}
	}

	// Set property "WebApplicationFirewallConfiguration":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.WebApplicationFirewallConfiguration != nil {
			var webApplicationFirewallConfiguration1 ApplicationGatewayWebApplicationFirewallConfiguration
			err := webApplicationFirewallConfiguration1.PopulateFromARM(owner, *typedInput.Properties.WebApplicationFirewallConfiguration)
			if err != nil {
				return err
			}
			webApplicationFirewallConfiguration := webApplicationFirewallConfiguration1
			gateway.WebApplicationFirewallConfiguration = &webApplicationFirewallConfiguration
		}
	}

	// Set property "Zones":
	for _, item := range typedInput.Zones {
		gateway.Zones = append(gateway.Zones, item)
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &ApplicationGateway_Spec{}

// ConvertSpecFrom populates our ApplicationGateway_Spec from the provided source
func (gateway *ApplicationGateway_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*storage.ApplicationGateway_Spec)
	if ok {
		// Populate our instance from source
		return gateway.AssignProperties_From_ApplicationGateway_Spec(src)
	}

	// Convert to an intermediate form
	src = &storage.ApplicationGateway_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = gateway.AssignProperties_From_ApplicationGateway_Spec(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our ApplicationGateway_Spec
func (gateway *ApplicationGateway_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*storage.ApplicationGateway_Spec)
	if ok {
		// Populate destination from our instance
		return gateway.AssignProperties_To_ApplicationGateway_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &storage.ApplicationGateway_Spec{}
	err := gateway.AssignProperties_To_ApplicationGateway_Spec(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignProperties_From_ApplicationGateway_Spec populates our ApplicationGateway_Spec from the provided source ApplicationGateway_Spec
func (gateway *ApplicationGateway_Spec) AssignProperties_From_ApplicationGateway_Spec(source *storage.ApplicationGateway_Spec) error {

	// AuthenticationCertificates
	if source.AuthenticationCertificates != nil {
		authenticationCertificateList := make([]ApplicationGatewayAuthenticationCertificate, len(source.AuthenticationCertificates))
		for authenticationCertificateIndex, authenticationCertificateItem := range source.AuthenticationCertificates {
			// Shadow the loop variable to avoid aliasing
			authenticationCertificateItem := authenticationCertificateItem
			var authenticationCertificate ApplicationGatewayAuthenticationCertificate
			err := authenticationCertificate.AssignProperties_From_ApplicationGatewayAuthenticationCertificate(&authenticationCertificateItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ApplicationGatewayAuthenticationCertificate() to populate field AuthenticationCertificates")
			}
			authenticationCertificateList[authenticationCertificateIndex] = authenticationCertificate
		}
		gateway.AuthenticationCertificates = authenticationCertificateList
	} else {
		gateway.AuthenticationCertificates = nil
	}

	// AutoscaleConfiguration
	if source.AutoscaleConfiguration != nil {
		var autoscaleConfiguration ApplicationGatewayAutoscaleConfiguration
		err := autoscaleConfiguration.AssignProperties_From_ApplicationGatewayAutoscaleConfiguration(source.AutoscaleConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ApplicationGatewayAutoscaleConfiguration() to populate field AutoscaleConfiguration")
		}
		gateway.AutoscaleConfiguration = &autoscaleConfiguration
	} else {
		gateway.AutoscaleConfiguration = nil
	}

	// AzureName
	gateway.AzureName = source.AzureName

	// BackendAddressPools
	if source.BackendAddressPools != nil {
		backendAddressPoolList := make([]ApplicationGatewayBackendAddressPool, len(source.BackendAddressPools))
		for backendAddressPoolIndex, backendAddressPoolItem := range source.BackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			backendAddressPoolItem := backendAddressPoolItem
			var backendAddressPool ApplicationGatewayBackendAddressPool
			err := backendAddressPool.AssignProperties_From_ApplicationGatewayBackendAddressPool(&backendAddressPoolItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ApplicationGatewayBackendAddressPool() to populate field BackendAddressPools")
			}
			backendAddressPoolList[backendAddressPoolIndex] = backendAddressPool
		}
		gateway.BackendAddressPools = backendAddressPoolList
	} else {
		gateway.BackendAddressPools = nil
	}

	// BackendHttpSettingsCollection
	if source.BackendHttpSettingsCollection != nil {
		backendHttpSettingsCollectionList := make([]ApplicationGatewayBackendHttpSettings, len(source.BackendHttpSettingsCollection))
		for backendHttpSettingsCollectionIndex, backendHttpSettingsCollectionItem := range source.BackendHttpSettingsCollection {
			// Shadow the loop variable to avoid aliasing
			backendHttpSettingsCollectionItem := backendHttpSettingsCollectionItem
			var backendHttpSettingsCollection ApplicationGatewayBackendHttpSettings
			err := backendHttpSettingsCollection.AssignProperties_From_ApplicationGatewayBackendHttpSettings(&backendHttpSettingsCollectionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ApplicationGatewayBackendHttpSettings() to populate field BackendHttpSettingsCollection")
			}
			backendHttpSettingsCollectionList[backendHttpSettingsCollectionIndex] = backendHttpSettingsCollection
		}
		gateway.BackendHttpSettingsCollection = backendHttpSettingsCollectionList
	} else {
		gateway.BackendHttpSettingsCollection = nil
	}

	// BackendSettingsCollection
	if source.BackendSettingsCollection != nil {
		backendSettingsCollectionList := make([]ApplicationGatewayBackendSettings, len(source.BackendSettingsCollection))
		for backendSettingsCollectionIndex, backendSettingsCollectionItem := range source.BackendSettingsCollection {
			// Shadow the loop variable to avoid aliasing
			backendSettingsCollectionItem := backendSettingsCollectionItem
			var backendSettingsCollection ApplicationGatewayBackendSettings
			err := backendSettingsCollection.AssignProperties_From_ApplicationGatewayBackendSettings(&backendSettingsCollectionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ApplicationGatewayBackendSettings() to populate field BackendSettingsCollection")
			}
			backendSettingsCollectionList[backendSettingsCollectionIndex] = backendSettingsCollection
		}
		gateway.BackendSettingsCollection = backendSettingsCollectionList
	} else {
		gateway.BackendSettingsCollection = nil
	}

	// CustomErrorConfigurations
	if source.CustomErrorConfigurations != nil {
		customErrorConfigurationList := make([]ApplicationGatewayCustomError, len(source.CustomErrorConfigurations))
		for customErrorConfigurationIndex, customErrorConfigurationItem := range source.CustomErrorConfigurations {
			// Shadow the loop variable to avoid aliasing
			customErrorConfigurationItem := customErrorConfigurationItem
			var customErrorConfiguration ApplicationGatewayCustomError
			err := customErrorConfiguration.AssignProperties_From_ApplicationGatewayCustomError(&customErrorConfigurationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ApplicationGatewayCustomError() to populate field CustomErrorConfigurations")
			}
			customErrorConfigurationList[customErrorConfigurationIndex] = customErrorConfiguration
		}
		gateway.CustomErrorConfigurations = customErrorConfigurationList
	} else {
		gateway.CustomErrorConfigurations = nil
	}

	// EnableFips
	if source.EnableFips != nil {
		enableFip := *source.EnableFips
		gateway.EnableFips = &enableFip
	} else {
		gateway.EnableFips = nil
	}

	// EnableHttp2
	if source.EnableHttp2 != nil {
		enableHttp2 := *source.EnableHttp2
		gateway.EnableHttp2 = &enableHttp2
	} else {
		gateway.EnableHttp2 = nil
	}

	// FirewallPolicy
	if source.FirewallPolicy != nil {
		var firewallPolicy SubResource
		err := firewallPolicy.AssignProperties_From_SubResource(source.FirewallPolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field FirewallPolicy")
		}
		gateway.FirewallPolicy = &firewallPolicy
	} else {
		gateway.FirewallPolicy = nil
	}

	// ForceFirewallPolicyAssociation
	if source.ForceFirewallPolicyAssociation != nil {
		forceFirewallPolicyAssociation := *source.ForceFirewallPolicyAssociation
		gateway.ForceFirewallPolicyAssociation = &forceFirewallPolicyAssociation
	} else {
		gateway.ForceFirewallPolicyAssociation = nil
	}

	// FrontendIPConfigurations
	if source.FrontendIPConfigurations != nil {
		frontendIPConfigurationList := make([]ApplicationGatewayFrontendIPConfiguration, len(source.FrontendIPConfigurations))
		for frontendIPConfigurationIndex, frontendIPConfigurationItem := range source.FrontendIPConfigurations {
			// Shadow the loop variable to avoid aliasing
			frontendIPConfigurationItem := frontendIPConfigurationItem
			var frontendIPConfiguration ApplicationGatewayFrontendIPConfiguration
			err := frontendIPConfiguration.AssignProperties_From_ApplicationGatewayFrontendIPConfiguration(&frontendIPConfigurationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ApplicationGatewayFrontendIPConfiguration() to populate field FrontendIPConfigurations")
			}
			frontendIPConfigurationList[frontendIPConfigurationIndex] = frontendIPConfiguration
		}
		gateway.FrontendIPConfigurations = frontendIPConfigurationList
	} else {
		gateway.FrontendIPConfigurations = nil
	}

	// FrontendPorts
	if source.FrontendPorts != nil {
		frontendPortList := make([]ApplicationGatewayFrontendPort, len(source.FrontendPorts))
		for frontendPortIndex, frontendPortItem := range source.FrontendPorts {
			// Shadow the loop variable to avoid aliasing
			frontendPortItem := frontendPortItem
			var frontendPort ApplicationGatewayFrontendPort
			err := frontendPort.AssignProperties_From_ApplicationGatewayFrontendPort(&frontendPortItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ApplicationGatewayFrontendPort() to populate field FrontendPorts")
			}
			frontendPortList[frontendPortIndex] = frontendPort
		}
		gateway.FrontendPorts = frontendPortList
	} else {
		gateway.FrontendPorts = nil
	}

	// GatewayIPConfigurations
	if source.GatewayIPConfigurations != nil {
		gatewayIPConfigurationList := make([]ApplicationGatewayIPConfiguration_ApplicationGateway_SubResourceEmbedded, len(source.GatewayIPConfigurations))
		for gatewayIPConfigurationIndex, gatewayIPConfigurationItem := range source.GatewayIPConfigurations {
			// Shadow the loop variable to avoid aliasing
			gatewayIPConfigurationItem := gatewayIPConfigurationItem
			var gatewayIPConfiguration ApplicationGatewayIPConfiguration_ApplicationGateway_SubResourceEmbedded
			err := gatewayIPConfiguration.AssignProperties_From_ApplicationGatewayIPConfiguration_ApplicationGateway_SubResourceEmbedded(&gatewayIPConfigurationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ApplicationGatewayIPConfiguration_ApplicationGateway_SubResourceEmbedded() to populate field GatewayIPConfigurations")
			}
			gatewayIPConfigurationList[gatewayIPConfigurationIndex] = gatewayIPConfiguration
		}
		gateway.GatewayIPConfigurations = gatewayIPConfigurationList
	} else {
		gateway.GatewayIPConfigurations = nil
	}

	// GlobalConfiguration
	if source.GlobalConfiguration != nil {
		var globalConfiguration ApplicationGatewayGlobalConfiguration
		err := globalConfiguration.AssignProperties_From_ApplicationGatewayGlobalConfiguration(source.GlobalConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ApplicationGatewayGlobalConfiguration() to populate field GlobalConfiguration")
		}
		gateway.GlobalConfiguration = &globalConfiguration
	} else {
		gateway.GlobalConfiguration = nil
	}

	// HttpListeners
	if source.HttpListeners != nil {
		httpListenerList := make([]ApplicationGatewayHttpListener, len(source.HttpListeners))
		for httpListenerIndex, httpListenerItem := range source.HttpListeners {
			// Shadow the loop variable to avoid aliasing
			httpListenerItem := httpListenerItem
			var httpListener ApplicationGatewayHttpListener
			err := httpListener.AssignProperties_From_ApplicationGatewayHttpListener(&httpListenerItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ApplicationGatewayHttpListener() to populate field HttpListeners")
			}
			httpListenerList[httpListenerIndex] = httpListener
		}
		gateway.HttpListeners = httpListenerList
	} else {
		gateway.HttpListeners = nil
	}

	// Identity
	if source.Identity != nil {
		var identity ManagedServiceIdentity
		err := identity.AssignProperties_From_ManagedServiceIdentity(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedServiceIdentity() to populate field Identity")
		}
		gateway.Identity = &identity
	} else {
		gateway.Identity = nil
	}

	// Listeners
	if source.Listeners != nil {
		listenerList := make([]ApplicationGatewayListener, len(source.Listeners))
		for listenerIndex, listenerItem := range source.Listeners {
			// Shadow the loop variable to avoid aliasing
			listenerItem := listenerItem
			var listener ApplicationGatewayListener
			err := listener.AssignProperties_From_ApplicationGatewayListener(&listenerItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ApplicationGatewayListener() to populate field Listeners")
			}
			listenerList[listenerIndex] = listener
		}
		gateway.Listeners = listenerList
	} else {
		gateway.Listeners = nil
	}

	// LoadDistributionPolicies
	if source.LoadDistributionPolicies != nil {
		loadDistributionPolicyList := make([]ApplicationGatewayLoadDistributionPolicy, len(source.LoadDistributionPolicies))
		for loadDistributionPolicyIndex, loadDistributionPolicyItem := range source.LoadDistributionPolicies {
			// Shadow the loop variable to avoid aliasing
			loadDistributionPolicyItem := loadDistributionPolicyItem
			var loadDistributionPolicy ApplicationGatewayLoadDistributionPolicy
			err := loadDistributionPolicy.AssignProperties_From_ApplicationGatewayLoadDistributionPolicy(&loadDistributionPolicyItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ApplicationGatewayLoadDistributionPolicy() to populate field LoadDistributionPolicies")
			}
			loadDistributionPolicyList[loadDistributionPolicyIndex] = loadDistributionPolicy
		}
		gateway.LoadDistributionPolicies = loadDistributionPolicyList
	} else {
		gateway.LoadDistributionPolicies = nil
	}

	// Location
	gateway.Location = genruntime.ClonePointerToString(source.Location)

	// OperatorSpec
	if source.OperatorSpec != nil {
		var operatorSpec ApplicationGatewayOperatorSpec
		err := operatorSpec.AssignProperties_From_ApplicationGatewayOperatorSpec(source.OperatorSpec)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ApplicationGatewayOperatorSpec() to populate field OperatorSpec")
		}
		gateway.OperatorSpec = &operatorSpec
	} else {
		gateway.OperatorSpec = nil
	}

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		gateway.Owner = &owner
	} else {
		gateway.Owner = nil
	}

	// PrivateLinkConfigurations
	if source.PrivateLinkConfigurations != nil {
		privateLinkConfigurationList := make([]ApplicationGatewayPrivateLinkConfiguration, len(source.PrivateLinkConfigurations))
		for privateLinkConfigurationIndex, privateLinkConfigurationItem := range source.PrivateLinkConfigurations {
			// Shadow the loop variable to avoid aliasing
			privateLinkConfigurationItem := privateLinkConfigurationItem
			var privateLinkConfiguration ApplicationGatewayPrivateLinkConfiguration
			err := privateLinkConfiguration.AssignProperties_From_ApplicationGatewayPrivateLinkConfiguration(&privateLinkConfigurationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ApplicationGatewayPrivateLinkConfiguration() to populate field PrivateLinkConfigurations")
			}
			privateLinkConfigurationList[privateLinkConfigurationIndex] = privateLinkConfiguration
		}
		gateway.PrivateLinkConfigurations = privateLinkConfigurationList
	} else {
		gateway.PrivateLinkConfigurations = nil
	}

	// Probes
	if source.Probes != nil {
		probeList := make([]ApplicationGatewayProbe, len(source.Probes))
		for probeIndex, probeItem := range source.Probes {
			// Shadow the loop variable to avoid aliasing
			probeItem := probeItem
			var probe ApplicationGatewayProbe
			err := probe.AssignProperties_From_ApplicationGatewayProbe(&probeItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ApplicationGatewayProbe() to populate field Probes")
			}
			probeList[probeIndex] = probe
		}
		gateway.Probes = probeList
	} else {
		gateway.Probes = nil
	}

	// RedirectConfigurations
	if source.RedirectConfigurations != nil {
		redirectConfigurationList := make([]ApplicationGatewayRedirectConfiguration, len(source.RedirectConfigurations))
		for redirectConfigurationIndex, redirectConfigurationItem := range source.RedirectConfigurations {
			// Shadow the loop variable to avoid aliasing
			redirectConfigurationItem := redirectConfigurationItem
			var redirectConfiguration ApplicationGatewayRedirectConfiguration
			err := redirectConfiguration.AssignProperties_From_ApplicationGatewayRedirectConfiguration(&redirectConfigurationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ApplicationGatewayRedirectConfiguration() to populate field RedirectConfigurations")
			}
			redirectConfigurationList[redirectConfigurationIndex] = redirectConfiguration
		}
		gateway.RedirectConfigurations = redirectConfigurationList
	} else {
		gateway.RedirectConfigurations = nil
	}

	// RequestRoutingRules
	if source.RequestRoutingRules != nil {
		requestRoutingRuleList := make([]ApplicationGatewayRequestRoutingRule, len(source.RequestRoutingRules))
		for requestRoutingRuleIndex, requestRoutingRuleItem := range source.RequestRoutingRules {
			// Shadow the loop variable to avoid aliasing
			requestRoutingRuleItem := requestRoutingRuleItem
			var requestRoutingRule ApplicationGatewayRequestRoutingRule
			err := requestRoutingRule.AssignProperties_From_ApplicationGatewayRequestRoutingRule(&requestRoutingRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ApplicationGatewayRequestRoutingRule() to populate field RequestRoutingRules")
			}
			requestRoutingRuleList[requestRoutingRuleIndex] = requestRoutingRule
		}
		gateway.RequestRoutingRules = requestRoutingRuleList
	} else {
		gateway.RequestRoutingRules = nil
	}

	// RewriteRuleSets
	if source.RewriteRuleSets != nil {
		rewriteRuleSetList := make([]ApplicationGatewayRewriteRuleSet, len(source.RewriteRuleSets))
		for rewriteRuleSetIndex, rewriteRuleSetItem := range source.RewriteRuleSets {
			// Shadow the loop variable to avoid aliasing
			rewriteRuleSetItem := rewriteRuleSetItem
			var rewriteRuleSet ApplicationGatewayRewriteRuleSet
			err := rewriteRuleSet.AssignProperties_From_ApplicationGatewayRewriteRuleSet(&rewriteRuleSetItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ApplicationGatewayRewriteRuleSet() to populate field RewriteRuleSets")
			}
			rewriteRuleSetList[rewriteRuleSetIndex] = rewriteRuleSet
		}
		gateway.RewriteRuleSets = rewriteRuleSetList
	} else {
		gateway.RewriteRuleSets = nil
	}

	// RoutingRules
	if source.RoutingRules != nil {
		routingRuleList := make([]ApplicationGatewayRoutingRule, len(source.RoutingRules))
		for routingRuleIndex, routingRuleItem := range source.RoutingRules {
			// Shadow the loop variable to avoid aliasing
			routingRuleItem := routingRuleItem
			var routingRule ApplicationGatewayRoutingRule
			err := routingRule.AssignProperties_From_ApplicationGatewayRoutingRule(&routingRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ApplicationGatewayRoutingRule() to populate field RoutingRules")
			}
			routingRuleList[routingRuleIndex] = routingRule
		}
		gateway.RoutingRules = routingRuleList
	} else {
		gateway.RoutingRules = nil
	}

	// Sku
	if source.Sku != nil {
		var sku ApplicationGatewaySku
		err := sku.AssignProperties_From_ApplicationGatewaySku(source.Sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ApplicationGatewaySku() to populate field Sku")
		}
		gateway.Sku = &sku
	} else {
		gateway.Sku = nil
	}

	// SslCertificates
	if source.SslCertificates != nil {
		sslCertificateList := make([]ApplicationGatewaySslCertificate, len(source.SslCertificates))
		for sslCertificateIndex, sslCertificateItem := range source.SslCertificates {
			// Shadow the loop variable to avoid aliasing
			sslCertificateItem := sslCertificateItem
			var sslCertificate ApplicationGatewaySslCertificate
			err := sslCertificate.AssignProperties_From_ApplicationGatewaySslCertificate(&sslCertificateItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ApplicationGatewaySslCertificate() to populate field SslCertificates")
			}
			sslCertificateList[sslCertificateIndex] = sslCertificate
		}
		gateway.SslCertificates = sslCertificateList
	} else {
		gateway.SslCertificates = nil
	}

	// SslPolicy
	if source.SslPolicy != nil {
		var sslPolicy ApplicationGatewaySslPolicy
		err := sslPolicy.AssignProperties_From_ApplicationGatewaySslPolicy(source.SslPolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ApplicationGatewaySslPolicy() to populate field SslPolicy")
		}
		gateway.SslPolicy = &sslPolicy
	} else {
		gateway.SslPolicy = nil
	}

	// SslProfiles
	if source.SslProfiles != nil {
		sslProfileList := make([]ApplicationGatewaySslProfile, len(source.SslProfiles))
		for sslProfileIndex, sslProfileItem := range source.SslProfiles {
			// Shadow the loop variable to avoid aliasing
			sslProfileItem := sslProfileItem
			var sslProfile ApplicationGatewaySslProfile
			err := sslProfile.AssignProperties_From_ApplicationGatewaySslProfile(&sslProfileItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ApplicationGatewaySslProfile() to populate field SslProfiles")
			}
			sslProfileList[sslProfileIndex] = sslProfile
		}
		gateway.SslProfiles = sslProfileList
	} else {
		gateway.SslProfiles = nil
	}

	// Tags
	gateway.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// TrustedClientCertificates
	if source.TrustedClientCertificates != nil {
		trustedClientCertificateList := make([]ApplicationGatewayTrustedClientCertificate, len(source.TrustedClientCertificates))
		for trustedClientCertificateIndex, trustedClientCertificateItem := range source.TrustedClientCertificates {
			// Shadow the loop variable to avoid aliasing
			trustedClientCertificateItem := trustedClientCertificateItem
			var trustedClientCertificate ApplicationGatewayTrustedClientCertificate
			err := trustedClientCertificate.AssignProperties_From_ApplicationGatewayTrustedClientCertificate(&trustedClientCertificateItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ApplicationGatewayTrustedClientCertificate() to populate field TrustedClientCertificates")
			}
			trustedClientCertificateList[trustedClientCertificateIndex] = trustedClientCertificate
		}
		gateway.TrustedClientCertificates = trustedClientCertificateList
	} else {
		gateway.TrustedClientCertificates = nil
	}

	// TrustedRootCertificates
	if source.TrustedRootCertificates != nil {
		trustedRootCertificateList := make([]ApplicationGatewayTrustedRootCertificate, len(source.TrustedRootCertificates))
		for trustedRootCertificateIndex, trustedRootCertificateItem := range source.TrustedRootCertificates {
			// Shadow the loop variable to avoid aliasing
			trustedRootCertificateItem := trustedRootCertificateItem
			var trustedRootCertificate ApplicationGatewayTrustedRootCertificate
			err := trustedRootCertificate.AssignProperties_From_ApplicationGatewayTrustedRootCertificate(&trustedRootCertificateItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ApplicationGatewayTrustedRootCertificate() to populate field TrustedRootCertificates")
			}
			trustedRootCertificateList[trustedRootCertificateIndex] = trustedRootCertificate
		}
		gateway.TrustedRootCertificates = trustedRootCertificateList
	} else {
		gateway.TrustedRootCertificates = nil
	}

	// UrlPathMaps
	if source.UrlPathMaps != nil {
		urlPathMapList := make([]ApplicationGatewayUrlPathMap, len(source.UrlPathMaps))
		for urlPathMapIndex, urlPathMapItem := range source.UrlPathMaps {
			// Shadow the loop variable to avoid aliasing
			urlPathMapItem := urlPathMapItem
			var urlPathMap ApplicationGatewayUrlPathMap
			err := urlPathMap.AssignProperties_From_ApplicationGatewayUrlPathMap(&urlPathMapItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ApplicationGatewayUrlPathMap() to populate field UrlPathMaps")
			}
			urlPathMapList[urlPathMapIndex] = urlPathMap
		}
		gateway.UrlPathMaps = urlPathMapList
	} else {
		gateway.UrlPathMaps = nil
	}

	// WebApplicationFirewallConfiguration
	if source.WebApplicationFirewallConfiguration != nil {
		var webApplicationFirewallConfiguration ApplicationGatewayWebApplicationFirewallConfiguration
		err := webApplicationFirewallConfiguration.AssignProperties_From_ApplicationGatewayWebApplicationFirewallConfiguration(source.WebApplicationFirewallConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ApplicationGatewayWebApplicationFirewallConfiguration() to populate field WebApplicationFirewallConfiguration")
		}
		gateway.WebApplicationFirewallConfiguration = &webApplicationFirewallConfiguration
	} else {
		gateway.WebApplicationFirewallConfiguration = nil
	}

	// Zones
	gateway.Zones = genruntime.CloneSliceOfString(source.Zones)

	// No error
	return nil
}

// AssignProperties_To_ApplicationGateway_Spec populates the provided destination ApplicationGateway_Spec from our ApplicationGateway_Spec
func (gateway *ApplicationGateway_Spec) AssignProperties_To_ApplicationGateway_Spec(destination *storage.ApplicationGateway_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AuthenticationCertificates
	if gateway.AuthenticationCertificates != nil {
		authenticationCertificateList := make([]storage.ApplicationGatewayAuthenticationCertificate, len(gateway.AuthenticationCertificates))
		for authenticationCertificateIndex, authenticationCertificateItem := range gateway.AuthenticationCertificates {
			// Shadow the loop variable to avoid aliasing
			authenticationCertificateItem := authenticationCertificateItem
			var authenticationCertificate storage.ApplicationGatewayAuthenticationCertificate
			err := authenticationCertificateItem.AssignProperties_To_ApplicationGatewayAuthenticationCertificate(&authenticationCertificate)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ApplicationGatewayAuthenticationCertificate() to populate field AuthenticationCertificates")
			}
			authenticationCertificateList[authenticationCertificateIndex] = authenticationCertificate
		}
		destination.AuthenticationCertificates = authenticationCertificateList
	} else {
		destination.AuthenticationCertificates = nil
	}

	// AutoscaleConfiguration
	if gateway.AutoscaleConfiguration != nil {
		var autoscaleConfiguration storage.ApplicationGatewayAutoscaleConfiguration
		err := gateway.AutoscaleConfiguration.AssignProperties_To_ApplicationGatewayAutoscaleConfiguration(&autoscaleConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ApplicationGatewayAutoscaleConfiguration() to populate field AutoscaleConfiguration")
		}
		destination.AutoscaleConfiguration = &autoscaleConfiguration
	} else {
		destination.AutoscaleConfiguration = nil
	}

	// AzureName
	destination.AzureName = gateway.AzureName

	// BackendAddressPools
	if gateway.BackendAddressPools != nil {
		backendAddressPoolList := make([]storage.ApplicationGatewayBackendAddressPool, len(gateway.BackendAddressPools))
		for backendAddressPoolIndex, backendAddressPoolItem := range gateway.BackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			backendAddressPoolItem := backendAddressPoolItem
			var backendAddressPool storage.ApplicationGatewayBackendAddressPool
			err := backendAddressPoolItem.AssignProperties_To_ApplicationGatewayBackendAddressPool(&backendAddressPool)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ApplicationGatewayBackendAddressPool() to populate field BackendAddressPools")
			}
			backendAddressPoolList[backendAddressPoolIndex] = backendAddressPool
		}
		destination.BackendAddressPools = backendAddressPoolList
	} else {
		destination.BackendAddressPools = nil
	}

	// BackendHttpSettingsCollection
	if gateway.BackendHttpSettingsCollection != nil {
		backendHttpSettingsCollectionList := make([]storage.ApplicationGatewayBackendHttpSettings, len(gateway.BackendHttpSettingsCollection))
		for backendHttpSettingsCollectionIndex, backendHttpSettingsCollectionItem := range gateway.BackendHttpSettingsCollection {
			// Shadow the loop variable to avoid aliasing
			backendHttpSettingsCollectionItem := backendHttpSettingsCollectionItem
			var backendHttpSettingsCollection storage.ApplicationGatewayBackendHttpSettings
			err := backendHttpSettingsCollectionItem.AssignProperties_To_ApplicationGatewayBackendHttpSettings(&backendHttpSettingsCollection)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ApplicationGatewayBackendHttpSettings() to populate field BackendHttpSettingsCollection")
			}
			backendHttpSettingsCollectionList[backendHttpSettingsCollectionIndex] = backendHttpSettingsCollection
		}
		destination.BackendHttpSettingsCollection = backendHttpSettingsCollectionList
	} else {
		destination.BackendHttpSettingsCollection = nil
	}

	// BackendSettingsCollection
	if gateway.BackendSettingsCollection != nil {
		backendSettingsCollectionList := make([]storage.ApplicationGatewayBackendSettings, len(gateway.BackendSettingsCollection))
		for backendSettingsCollectionIndex, backendSettingsCollectionItem := range gateway.BackendSettingsCollection {
			// Shadow the loop variable to avoid aliasing
			backendSettingsCollectionItem := backendSettingsCollectionItem
			var backendSettingsCollection storage.ApplicationGatewayBackendSettings
			err := backendSettingsCollectionItem.AssignProperties_To_ApplicationGatewayBackendSettings(&backendSettingsCollection)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ApplicationGatewayBackendSettings() to populate field BackendSettingsCollection")
			}
			backendSettingsCollectionList[backendSettingsCollectionIndex] = backendSettingsCollection
		}
		destination.BackendSettingsCollection = backendSettingsCollectionList
	} else {
		destination.BackendSettingsCollection = nil
	}

	// CustomErrorConfigurations
	if gateway.CustomErrorConfigurations != nil {
		customErrorConfigurationList := make([]storage.ApplicationGatewayCustomError, len(gateway.CustomErrorConfigurations))
		for customErrorConfigurationIndex, customErrorConfigurationItem := range gateway.CustomErrorConfigurations {
			// Shadow the loop variable to avoid aliasing
			customErrorConfigurationItem := customErrorConfigurationItem
			var customErrorConfiguration storage.ApplicationGatewayCustomError
			err := customErrorConfigurationItem.AssignProperties_To_ApplicationGatewayCustomError(&customErrorConfiguration)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ApplicationGatewayCustomError() to populate field CustomErrorConfigurations")
			}
			customErrorConfigurationList[customErrorConfigurationIndex] = customErrorConfiguration
		}
		destination.CustomErrorConfigurations = customErrorConfigurationList
	} else {
		destination.CustomErrorConfigurations = nil
	}

	// EnableFips
	if gateway.EnableFips != nil {
		enableFip := *gateway.EnableFips
		destination.EnableFips = &enableFip
	} else {
		destination.EnableFips = nil
	}

	// EnableHttp2
	if gateway.EnableHttp2 != nil {
		enableHttp2 := *gateway.EnableHttp2
		destination.EnableHttp2 = &enableHttp2
	} else {
		destination.EnableHttp2 = nil
	}

	// FirewallPolicy
	if gateway.FirewallPolicy != nil {
		var firewallPolicy storage.SubResource
		err := gateway.FirewallPolicy.AssignProperties_To_SubResource(&firewallPolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field FirewallPolicy")
		}
		destination.FirewallPolicy = &firewallPolicy
	} else {
		destination.FirewallPolicy = nil
	}

	// ForceFirewallPolicyAssociation
	if gateway.ForceFirewallPolicyAssociation != nil {
		forceFirewallPolicyAssociation := *gateway.ForceFirewallPolicyAssociation
		destination.ForceFirewallPolicyAssociation = &forceFirewallPolicyAssociation
	} else {
		destination.ForceFirewallPolicyAssociation = nil
	}

	// FrontendIPConfigurations
	if gateway.FrontendIPConfigurations != nil {
		frontendIPConfigurationList := make([]storage.ApplicationGatewayFrontendIPConfiguration, len(gateway.FrontendIPConfigurations))
		for frontendIPConfigurationIndex, frontendIPConfigurationItem := range gateway.FrontendIPConfigurations {
			// Shadow the loop variable to avoid aliasing
			frontendIPConfigurationItem := frontendIPConfigurationItem
			var frontendIPConfiguration storage.ApplicationGatewayFrontendIPConfiguration
			err := frontendIPConfigurationItem.AssignProperties_To_ApplicationGatewayFrontendIPConfiguration(&frontendIPConfiguration)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ApplicationGatewayFrontendIPConfiguration() to populate field FrontendIPConfigurations")
			}
			frontendIPConfigurationList[frontendIPConfigurationIndex] = frontendIPConfiguration
		}
		destination.FrontendIPConfigurations = frontendIPConfigurationList
	} else {
		destination.FrontendIPConfigurations = nil
	}

	// FrontendPorts
	if gateway.FrontendPorts != nil {
		frontendPortList := make([]storage.ApplicationGatewayFrontendPort, len(gateway.FrontendPorts))
		for frontendPortIndex, frontendPortItem := range gateway.FrontendPorts {
			// Shadow the loop variable to avoid aliasing
			frontendPortItem := frontendPortItem
			var frontendPort storage.ApplicationGatewayFrontendPort
			err := frontendPortItem.AssignProperties_To_ApplicationGatewayFrontendPort(&frontendPort)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ApplicationGatewayFrontendPort() to populate field FrontendPorts")
			}
			frontendPortList[frontendPortIndex] = frontendPort
		}
		destination.FrontendPorts = frontendPortList
	} else {
		destination.FrontendPorts = nil
	}

	// GatewayIPConfigurations
	if gateway.GatewayIPConfigurations != nil {
		gatewayIPConfigurationList := make([]storage.ApplicationGatewayIPConfiguration_ApplicationGateway_SubResourceEmbedded, len(gateway.GatewayIPConfigurations))
		for gatewayIPConfigurationIndex, gatewayIPConfigurationItem := range gateway.GatewayIPConfigurations {
			// Shadow the loop variable to avoid aliasing
			gatewayIPConfigurationItem := gatewayIPConfigurationItem
			var gatewayIPConfiguration storage.ApplicationGatewayIPConfiguration_ApplicationGateway_SubResourceEmbedded
			err := gatewayIPConfigurationItem.AssignProperties_To_ApplicationGatewayIPConfiguration_ApplicationGateway_SubResourceEmbedded(&gatewayIPConfiguration)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ApplicationGatewayIPConfiguration_ApplicationGateway_SubResourceEmbedded() to populate field GatewayIPConfigurations")
			}
			gatewayIPConfigurationList[gatewayIPConfigurationIndex] = gatewayIPConfiguration
		}
		destination.GatewayIPConfigurations = gatewayIPConfigurationList
	} else {
		destination.GatewayIPConfigurations = nil
	}

	// GlobalConfiguration
	if gateway.GlobalConfiguration != nil {
		var globalConfiguration storage.ApplicationGatewayGlobalConfiguration
		err := gateway.GlobalConfiguration.AssignProperties_To_ApplicationGatewayGlobalConfiguration(&globalConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ApplicationGatewayGlobalConfiguration() to populate field GlobalConfiguration")
		}
		destination.GlobalConfiguration = &globalConfiguration
	} else {
		destination.GlobalConfiguration = nil
	}

	// HttpListeners
	if gateway.HttpListeners != nil {
		httpListenerList := make([]storage.ApplicationGatewayHttpListener, len(gateway.HttpListeners))
		for httpListenerIndex, httpListenerItem := range gateway.HttpListeners {
			// Shadow the loop variable to avoid aliasing
			httpListenerItem := httpListenerItem
			var httpListener storage.ApplicationGatewayHttpListener
			err := httpListenerItem.AssignProperties_To_ApplicationGatewayHttpListener(&httpListener)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ApplicationGatewayHttpListener() to populate field HttpListeners")
			}
			httpListenerList[httpListenerIndex] = httpListener
		}
		destination.HttpListeners = httpListenerList
	} else {
		destination.HttpListeners = nil
	}

	// Identity
	if gateway.Identity != nil {
		var identity storage.ManagedServiceIdentity
		err := gateway.Identity.AssignProperties_To_ManagedServiceIdentity(&identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedServiceIdentity() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// Listeners
	if gateway.Listeners != nil {
		listenerList := make([]storage.ApplicationGatewayListener, len(gateway.Listeners))
		for listenerIndex, listenerItem := range gateway.Listeners {
			// Shadow the loop variable to avoid aliasing
			listenerItem := listenerItem
			var listener storage.ApplicationGatewayListener
			err := listenerItem.AssignProperties_To_ApplicationGatewayListener(&listener)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ApplicationGatewayListener() to populate field Listeners")
			}
			listenerList[listenerIndex] = listener
		}
		destination.Listeners = listenerList
	} else {
		destination.Listeners = nil
	}

	// LoadDistributionPolicies
	if gateway.LoadDistributionPolicies != nil {
		loadDistributionPolicyList := make([]storage.ApplicationGatewayLoadDistributionPolicy, len(gateway.LoadDistributionPolicies))
		for loadDistributionPolicyIndex, loadDistributionPolicyItem := range gateway.LoadDistributionPolicies {
			// Shadow the loop variable to avoid aliasing
			loadDistributionPolicyItem := loadDistributionPolicyItem
			var loadDistributionPolicy storage.ApplicationGatewayLoadDistributionPolicy
			err := loadDistributionPolicyItem.AssignProperties_To_ApplicationGatewayLoadDistributionPolicy(&loadDistributionPolicy)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ApplicationGatewayLoadDistributionPolicy() to populate field LoadDistributionPolicies")
			}
			loadDistributionPolicyList[loadDistributionPolicyIndex] = loadDistributionPolicy
		}
		destination.LoadDistributionPolicies = loadDistributionPolicyList
	} else {
		destination.LoadDistributionPolicies = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(gateway.Location)

	// OperatorSpec
	if gateway.OperatorSpec != nil {
		var operatorSpec storage.ApplicationGatewayOperatorSpec
		err := gateway.OperatorSpec.AssignProperties_To_ApplicationGatewayOperatorSpec(&operatorSpec)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ApplicationGatewayOperatorSpec() to populate field OperatorSpec")
		}
		destination.OperatorSpec = &operatorSpec
	} else {
		destination.OperatorSpec = nil
	}

	// OriginalVersion
	destination.OriginalVersion = gateway.OriginalVersion()

	// Owner
	if gateway.Owner != nil {
		owner := gateway.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// PrivateLinkConfigurations
	if gateway.PrivateLinkConfigurations != nil {
		privateLinkConfigurationList := make([]storage.ApplicationGatewayPrivateLinkConfiguration, len(gateway.PrivateLinkConfigurations))
		for privateLinkConfigurationIndex, privateLinkConfigurationItem := range gateway.PrivateLinkConfigurations {
			// Shadow the loop variable to avoid aliasing
			privateLinkConfigurationItem := privateLinkConfigurationItem
			var privateLinkConfiguration storage.ApplicationGatewayPrivateLinkConfiguration
			err := privateLinkConfigurationItem.AssignProperties_To_ApplicationGatewayPrivateLinkConfiguration(&privateLinkConfiguration)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ApplicationGatewayPrivateLinkConfiguration() to populate field PrivateLinkConfigurations")
			}
			privateLinkConfigurationList[privateLinkConfigurationIndex] = privateLinkConfiguration
		}
		destination.PrivateLinkConfigurations = privateLinkConfigurationList
	} else {
		destination.PrivateLinkConfigurations = nil
	}

	// Probes
	if gateway.Probes != nil {
		probeList := make([]storage.ApplicationGatewayProbe, len(gateway.Probes))
		for probeIndex, probeItem := range gateway.Probes {
			// Shadow the loop variable to avoid aliasing
			probeItem := probeItem
			var probe storage.ApplicationGatewayProbe
			err := probeItem.AssignProperties_To_ApplicationGatewayProbe(&probe)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ApplicationGatewayProbe() to populate field Probes")
			}
			probeList[probeIndex] = probe
		}
		destination.Probes = probeList
	} else {
		destination.Probes = nil
	}

	// RedirectConfigurations
	if gateway.RedirectConfigurations != nil {
		redirectConfigurationList := make([]storage.ApplicationGatewayRedirectConfiguration, len(gateway.RedirectConfigurations))
		for redirectConfigurationIndex, redirectConfigurationItem := range gateway.RedirectConfigurations {
			// Shadow the loop variable to avoid aliasing
			redirectConfigurationItem := redirectConfigurationItem
			var redirectConfiguration storage.ApplicationGatewayRedirectConfiguration
			err := redirectConfigurationItem.AssignProperties_To_ApplicationGatewayRedirectConfiguration(&redirectConfiguration)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ApplicationGatewayRedirectConfiguration() to populate field RedirectConfigurations")
			}
			redirectConfigurationList[redirectConfigurationIndex] = redirectConfiguration
		}
		destination.RedirectConfigurations = redirectConfigurationList
	} else {
		destination.RedirectConfigurations = nil
	}

	// RequestRoutingRules
	if gateway.RequestRoutingRules != nil {
		requestRoutingRuleList := make([]storage.ApplicationGatewayRequestRoutingRule, len(gateway.RequestRoutingRules))
		for requestRoutingRuleIndex, requestRoutingRuleItem := range gateway.RequestRoutingRules {
			// Shadow the loop variable to avoid aliasing
			requestRoutingRuleItem := requestRoutingRuleItem
			var requestRoutingRule storage.ApplicationGatewayRequestRoutingRule
			err := requestRoutingRuleItem.AssignProperties_To_ApplicationGatewayRequestRoutingRule(&requestRoutingRule)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ApplicationGatewayRequestRoutingRule() to populate field RequestRoutingRules")
			}
			requestRoutingRuleList[requestRoutingRuleIndex] = requestRoutingRule
		}
		destination.RequestRoutingRules = requestRoutingRuleList
	} else {
		destination.RequestRoutingRules = nil
	}

	// RewriteRuleSets
	if gateway.RewriteRuleSets != nil {
		rewriteRuleSetList := make([]storage.ApplicationGatewayRewriteRuleSet, len(gateway.RewriteRuleSets))
		for rewriteRuleSetIndex, rewriteRuleSetItem := range gateway.RewriteRuleSets {
			// Shadow the loop variable to avoid aliasing
			rewriteRuleSetItem := rewriteRuleSetItem
			var rewriteRuleSet storage.ApplicationGatewayRewriteRuleSet
			err := rewriteRuleSetItem.AssignProperties_To_ApplicationGatewayRewriteRuleSet(&rewriteRuleSet)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ApplicationGatewayRewriteRuleSet() to populate field RewriteRuleSets")
			}
			rewriteRuleSetList[rewriteRuleSetIndex] = rewriteRuleSet
		}
		destination.RewriteRuleSets = rewriteRuleSetList
	} else {
		destination.RewriteRuleSets = nil
	}

	// RoutingRules
	if gateway.RoutingRules != nil {
		routingRuleList := make([]storage.ApplicationGatewayRoutingRule, len(gateway.RoutingRules))
		for routingRuleIndex, routingRuleItem := range gateway.RoutingRules {
			// Shadow the loop variable to avoid aliasing
			routingRuleItem := routingRuleItem
			var routingRule storage.ApplicationGatewayRoutingRule
			err := routingRuleItem.AssignProperties_To_ApplicationGatewayRoutingRule(&routingRule)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ApplicationGatewayRoutingRule() to populate field RoutingRules")
			}
			routingRuleList[routingRuleIndex] = routingRule
		}
		destination.RoutingRules = routingRuleList
	} else {
		destination.RoutingRules = nil
	}

	// Sku
	if gateway.Sku != nil {
		var sku storage.ApplicationGatewaySku
		err := gateway.Sku.AssignProperties_To_ApplicationGatewaySku(&sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ApplicationGatewaySku() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// SslCertificates
	if gateway.SslCertificates != nil {
		sslCertificateList := make([]storage.ApplicationGatewaySslCertificate, len(gateway.SslCertificates))
		for sslCertificateIndex, sslCertificateItem := range gateway.SslCertificates {
			// Shadow the loop variable to avoid aliasing
			sslCertificateItem := sslCertificateItem
			var sslCertificate storage.ApplicationGatewaySslCertificate
			err := sslCertificateItem.AssignProperties_To_ApplicationGatewaySslCertificate(&sslCertificate)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ApplicationGatewaySslCertificate() to populate field SslCertificates")
			}
			sslCertificateList[sslCertificateIndex] = sslCertificate
		}
		destination.SslCertificates = sslCertificateList
	} else {
		destination.SslCertificates = nil
	}

	// SslPolicy
	if gateway.SslPolicy != nil {
		var sslPolicy storage.ApplicationGatewaySslPolicy
		err := gateway.SslPolicy.AssignProperties_To_ApplicationGatewaySslPolicy(&sslPolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ApplicationGatewaySslPolicy() to populate field SslPolicy")
		}
		destination.SslPolicy = &sslPolicy
	} else {
		destination.SslPolicy = nil
	}

	// SslProfiles
	if gateway.SslProfiles != nil {
		sslProfileList := make([]storage.ApplicationGatewaySslProfile, len(gateway.SslProfiles))
		for sslProfileIndex, sslProfileItem := range gateway.SslProfiles {
			// Shadow the loop variable to avoid aliasing
			sslProfileItem := sslProfileItem
			var sslProfile storage.ApplicationGatewaySslProfile
			err := sslProfileItem.AssignProperties_To_ApplicationGatewaySslProfile(&sslProfile)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ApplicationGatewaySslProfile() to populate field SslProfiles")
			}
			sslProfileList[sslProfileIndex] = sslProfile
		}
		destination.SslProfiles = sslProfileList
	} else {
		destination.SslProfiles = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(gateway.Tags)

	// TrustedClientCertificates
	if gateway.TrustedClientCertificates != nil {
		trustedClientCertificateList := make([]storage.ApplicationGatewayTrustedClientCertificate, len(gateway.TrustedClientCertificates))
		for trustedClientCertificateIndex, trustedClientCertificateItem := range gateway.TrustedClientCertificates {
			// Shadow the loop variable to avoid aliasing
			trustedClientCertificateItem := trustedClientCertificateItem
			var trustedClientCertificate storage.ApplicationGatewayTrustedClientCertificate
			err := trustedClientCertificateItem.AssignProperties_To_ApplicationGatewayTrustedClientCertificate(&trustedClientCertificate)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ApplicationGatewayTrustedClientCertificate() to populate field TrustedClientCertificates")
			}
			trustedClientCertificateList[trustedClientCertificateIndex] = trustedClientCertificate
		}
		destination.TrustedClientCertificates = trustedClientCertificateList
	} else {
		destination.TrustedClientCertificates = nil
	}

	// TrustedRootCertificates
	if gateway.TrustedRootCertificates != nil {
		trustedRootCertificateList := make([]storage.ApplicationGatewayTrustedRootCertificate, len(gateway.TrustedRootCertificates))
		for trustedRootCertificateIndex, trustedRootCertificateItem := range gateway.TrustedRootCertificates {
			// Shadow the loop variable to avoid aliasing
			trustedRootCertificateItem := trustedRootCertificateItem
			var trustedRootCertificate storage.ApplicationGatewayTrustedRootCertificate
			err := trustedRootCertificateItem.AssignProperties_To_ApplicationGatewayTrustedRootCertificate(&trustedRootCertificate)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ApplicationGatewayTrustedRootCertificate() to populate field TrustedRootCertificates")
			}
			trustedRootCertificateList[trustedRootCertificateIndex] = trustedRootCertificate
		}
		destination.TrustedRootCertificates = trustedRootCertificateList
	} else {
		destination.TrustedRootCertificates = nil
	}

	// UrlPathMaps
	if gateway.UrlPathMaps != nil {
		urlPathMapList := make([]storage.ApplicationGatewayUrlPathMap, len(gateway.UrlPathMaps))
		for urlPathMapIndex, urlPathMapItem := range gateway.UrlPathMaps {
			// Shadow the loop variable to avoid aliasing
			urlPathMapItem := urlPathMapItem
			var urlPathMap storage.ApplicationGatewayUrlPathMap
			err := urlPathMapItem.AssignProperties_To_ApplicationGatewayUrlPathMap(&urlPathMap)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ApplicationGatewayUrlPathMap() to populate field UrlPathMaps")
			}
			urlPathMapList[urlPathMapIndex] = urlPathMap
		}
		destination.UrlPathMaps = urlPathMapList
	} else {
		destination.UrlPathMaps = nil
	}

	// WebApplicationFirewallConfiguration
	if gateway.WebApplicationFirewallConfiguration != nil {
		var webApplicationFirewallConfiguration storage.ApplicationGatewayWebApplicationFirewallConfiguration
		err := gateway.WebApplicationFirewallConfiguration.AssignProperties_To_ApplicationGatewayWebApplicationFirewallConfiguration(&webApplicationFirewallConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ApplicationGatewayWebApplicationFirewallConfiguration() to populate field WebApplicationFirewallConfiguration")
		}
		destination.WebApplicationFirewallConfiguration = &webApplicationFirewallConfiguration
	} else {
		destination.WebApplicationFirewallConfiguration = nil
	}

	// Zones
	destination.Zones = genruntime.CloneSliceOfString(gateway.Zones)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ApplicationGateway_STATUS_ApplicationGateway_SubResourceEmbedded populates our ApplicationGateway_Spec from the provided source ApplicationGateway_STATUS_ApplicationGateway_SubResourceEmbedded
func (gateway *ApplicationGateway_Spec) Initialize_From_ApplicationGateway_STATUS_ApplicationGateway_SubResourceEmbedded(source *ApplicationGateway_STATUS_ApplicationGateway_SubResourceEmbedded) error {

	// AuthenticationCertificates
	if source.AuthenticationCertificates != nil {
		authenticationCertificateList := make([]ApplicationGatewayAuthenticationCertificate, len(source.AuthenticationCertificates))
		for authenticationCertificateIndex, authenticationCertificateItem := range source.AuthenticationCertificates {
			// Shadow the loop variable to avoid aliasing
			authenticationCertificateItem := authenticationCertificateItem
			var authenticationCertificate ApplicationGatewayAuthenticationCertificate
			err := authenticationCertificate.Initialize_From_ApplicationGatewayAuthenticationCertificate_STATUS(&authenticationCertificateItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_ApplicationGatewayAuthenticationCertificate_STATUS() to populate field AuthenticationCertificates")
			}
			authenticationCertificateList[authenticationCertificateIndex] = authenticationCertificate
		}
		gateway.AuthenticationCertificates = authenticationCertificateList
	} else {
		gateway.AuthenticationCertificates = nil
	}

	// AutoscaleConfiguration
	if source.AutoscaleConfiguration != nil {
		var autoscaleConfiguration ApplicationGatewayAutoscaleConfiguration
		err := autoscaleConfiguration.Initialize_From_ApplicationGatewayAutoscaleConfiguration_STATUS(source.AutoscaleConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_ApplicationGatewayAutoscaleConfiguration_STATUS() to populate field AutoscaleConfiguration")
		}
		gateway.AutoscaleConfiguration = &autoscaleConfiguration
	} else {
		gateway.AutoscaleConfiguration = nil
	}

	// BackendAddressPools
	if source.BackendAddressPools != nil {
		backendAddressPoolList := make([]ApplicationGatewayBackendAddressPool, len(source.BackendAddressPools))
		for backendAddressPoolIndex, backendAddressPoolItem := range source.BackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			backendAddressPoolItem := backendAddressPoolItem
			var backendAddressPool ApplicationGatewayBackendAddressPool
			err := backendAddressPool.Initialize_From_ApplicationGatewayBackendAddressPool_STATUS(&backendAddressPoolItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_ApplicationGatewayBackendAddressPool_STATUS() to populate field BackendAddressPools")
			}
			backendAddressPoolList[backendAddressPoolIndex] = backendAddressPool
		}
		gateway.BackendAddressPools = backendAddressPoolList
	} else {
		gateway.BackendAddressPools = nil
	}

	// BackendHttpSettingsCollection
	if source.BackendHttpSettingsCollection != nil {
		backendHttpSettingsCollectionList := make([]ApplicationGatewayBackendHttpSettings, len(source.BackendHttpSettingsCollection))
		for backendHttpSettingsCollectionIndex, backendHttpSettingsCollectionItem := range source.BackendHttpSettingsCollection {
			// Shadow the loop variable to avoid aliasing
			backendHttpSettingsCollectionItem := backendHttpSettingsCollectionItem
			var backendHttpSettingsCollection ApplicationGatewayBackendHttpSettings
			err := backendHttpSettingsCollection.Initialize_From_ApplicationGatewayBackendHttpSettings_STATUS(&backendHttpSettingsCollectionItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_ApplicationGatewayBackendHttpSettings_STATUS() to populate field BackendHttpSettingsCollection")
			}
			backendHttpSettingsCollectionList[backendHttpSettingsCollectionIndex] = backendHttpSettingsCollection
		}
		gateway.BackendHttpSettingsCollection = backendHttpSettingsCollectionList
	} else {
		gateway.BackendHttpSettingsCollection = nil
	}

	// BackendSettingsCollection
	if source.BackendSettingsCollection != nil {
		backendSettingsCollectionList := make([]ApplicationGatewayBackendSettings, len(source.BackendSettingsCollection))
		for backendSettingsCollectionIndex, backendSettingsCollectionItem := range source.BackendSettingsCollection {
			// Shadow the loop variable to avoid aliasing
			backendSettingsCollectionItem := backendSettingsCollectionItem
			var backendSettingsCollection ApplicationGatewayBackendSettings
			err := backendSettingsCollection.Initialize_From_ApplicationGatewayBackendSettings_STATUS(&backendSettingsCollectionItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_ApplicationGatewayBackendSettings_STATUS() to populate field BackendSettingsCollection")
			}
			backendSettingsCollectionList[backendSettingsCollectionIndex] = backendSettingsCollection
		}
		gateway.BackendSettingsCollection = backendSettingsCollectionList
	} else {
		gateway.BackendSettingsCollection = nil
	}

	// CustomErrorConfigurations
	if source.CustomErrorConfigurations != nil {
		customErrorConfigurationList := make([]ApplicationGatewayCustomError, len(source.CustomErrorConfigurations))
		for customErrorConfigurationIndex, customErrorConfigurationItem := range source.CustomErrorConfigurations {
			// Shadow the loop variable to avoid aliasing
			customErrorConfigurationItem := customErrorConfigurationItem
			var customErrorConfiguration ApplicationGatewayCustomError
			err := customErrorConfiguration.Initialize_From_ApplicationGatewayCustomError_STATUS(&customErrorConfigurationItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_ApplicationGatewayCustomError_STATUS() to populate field CustomErrorConfigurations")
			}
			customErrorConfigurationList[customErrorConfigurationIndex] = customErrorConfiguration
		}
		gateway.CustomErrorConfigurations = customErrorConfigurationList
	} else {
		gateway.CustomErrorConfigurations = nil
	}

	// EnableFips
	if source.EnableFips != nil {
		enableFip := *source.EnableFips
		gateway.EnableFips = &enableFip
	} else {
		gateway.EnableFips = nil
	}

	// EnableHttp2
	if source.EnableHttp2 != nil {
		enableHttp2 := *source.EnableHttp2
		gateway.EnableHttp2 = &enableHttp2
	} else {
		gateway.EnableHttp2 = nil
	}

	// FirewallPolicy
	if source.FirewallPolicy != nil {
		var firewallPolicy SubResource
		err := firewallPolicy.Initialize_From_SubResource_STATUS(source.FirewallPolicy)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_SubResource_STATUS() to populate field FirewallPolicy")
		}
		gateway.FirewallPolicy = &firewallPolicy
	} else {
		gateway.FirewallPolicy = nil
	}

	// ForceFirewallPolicyAssociation
	if source.ForceFirewallPolicyAssociation != nil {
		forceFirewallPolicyAssociation := *source.ForceFirewallPolicyAssociation
		gateway.ForceFirewallPolicyAssociation = &forceFirewallPolicyAssociation
	} else {
		gateway.ForceFirewallPolicyAssociation = nil
	}

	// FrontendIPConfigurations
	if source.FrontendIPConfigurations != nil {
		frontendIPConfigurationList := make([]ApplicationGatewayFrontendIPConfiguration, len(source.FrontendIPConfigurations))
		for frontendIPConfigurationIndex, frontendIPConfigurationItem := range source.FrontendIPConfigurations {
			// Shadow the loop variable to avoid aliasing
			frontendIPConfigurationItem := frontendIPConfigurationItem
			var frontendIPConfiguration ApplicationGatewayFrontendIPConfiguration
			err := frontendIPConfiguration.Initialize_From_ApplicationGatewayFrontendIPConfiguration_STATUS(&frontendIPConfigurationItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_ApplicationGatewayFrontendIPConfiguration_STATUS() to populate field FrontendIPConfigurations")
			}
			frontendIPConfigurationList[frontendIPConfigurationIndex] = frontendIPConfiguration
		}
		gateway.FrontendIPConfigurations = frontendIPConfigurationList
	} else {
		gateway.FrontendIPConfigurations = nil
	}

	// FrontendPorts
	if source.FrontendPorts != nil {
		frontendPortList := make([]ApplicationGatewayFrontendPort, len(source.FrontendPorts))
		for frontendPortIndex, frontendPortItem := range source.FrontendPorts {
			// Shadow the loop variable to avoid aliasing
			frontendPortItem := frontendPortItem
			var frontendPort ApplicationGatewayFrontendPort
			err := frontendPort.Initialize_From_ApplicationGatewayFrontendPort_STATUS(&frontendPortItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_ApplicationGatewayFrontendPort_STATUS() to populate field FrontendPorts")
			}
			frontendPortList[frontendPortIndex] = frontendPort
		}
		gateway.FrontendPorts = frontendPortList
	} else {
		gateway.FrontendPorts = nil
	}

	// GatewayIPConfigurations
	if source.GatewayIPConfigurations != nil {
		gatewayIPConfigurationList := make([]ApplicationGatewayIPConfiguration_ApplicationGateway_SubResourceEmbedded, len(source.GatewayIPConfigurations))
		for gatewayIPConfigurationIndex, gatewayIPConfigurationItem := range source.GatewayIPConfigurations {
			// Shadow the loop variable to avoid aliasing
			gatewayIPConfigurationItem := gatewayIPConfigurationItem
			var gatewayIPConfiguration ApplicationGatewayIPConfiguration_ApplicationGateway_SubResourceEmbedded
			err := gatewayIPConfiguration.Initialize_From_ApplicationGatewayIPConfiguration_STATUS_ApplicationGateway_SubResourceEmbedded(&gatewayIPConfigurationItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_ApplicationGatewayIPConfiguration_STATUS_ApplicationGateway_SubResourceEmbedded() to populate field GatewayIPConfigurations")
			}
			gatewayIPConfigurationList[gatewayIPConfigurationIndex] = gatewayIPConfiguration
		}
		gateway.GatewayIPConfigurations = gatewayIPConfigurationList
	} else {
		gateway.GatewayIPConfigurations = nil
	}

	// GlobalConfiguration
	if source.GlobalConfiguration != nil {
		var globalConfiguration ApplicationGatewayGlobalConfiguration
		err := globalConfiguration.Initialize_From_ApplicationGatewayGlobalConfiguration_STATUS(source.GlobalConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_ApplicationGatewayGlobalConfiguration_STATUS() to populate field GlobalConfiguration")
		}
		gateway.GlobalConfiguration = &globalConfiguration
	} else {
		gateway.GlobalConfiguration = nil
	}

	// HttpListeners
	if source.HttpListeners != nil {
		httpListenerList := make([]ApplicationGatewayHttpListener, len(source.HttpListeners))
		for httpListenerIndex, httpListenerItem := range source.HttpListeners {
			// Shadow the loop variable to avoid aliasing
			httpListenerItem := httpListenerItem
			var httpListener ApplicationGatewayHttpListener
			err := httpListener.Initialize_From_ApplicationGatewayHttpListener_STATUS(&httpListenerItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_ApplicationGatewayHttpListener_STATUS() to populate field HttpListeners")
			}
			httpListenerList[httpListenerIndex] = httpListener
		}
		gateway.HttpListeners = httpListenerList
	} else {
		gateway.HttpListeners = nil
	}

	// Identity
	if source.Identity != nil {
		var identity ManagedServiceIdentity
		err := identity.Initialize_From_ManagedServiceIdentity_STATUS(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_ManagedServiceIdentity_STATUS() to populate field Identity")
		}
		gateway.Identity = &identity
	} else {
		gateway.Identity = nil
	}

	// Listeners
	if source.Listeners != nil {
		listenerList := make([]ApplicationGatewayListener, len(source.Listeners))
		for listenerIndex, listenerItem := range source.Listeners {
			// Shadow the loop variable to avoid aliasing
			listenerItem := listenerItem
			var listener ApplicationGatewayListener
			err := listener.Initialize_From_ApplicationGatewayListener_STATUS(&listenerItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_ApplicationGatewayListener_STATUS() to populate field Listeners")
			}
			listenerList[listenerIndex] = listener
		}
		gateway.Listeners = listenerList
	} else {
		gateway.Listeners = nil
	}

	// LoadDistributionPolicies
	if source.LoadDistributionPolicies != nil {
		loadDistributionPolicyList := make([]ApplicationGatewayLoadDistributionPolicy, len(source.LoadDistributionPolicies))
		for loadDistributionPolicyIndex, loadDistributionPolicyItem := range source.LoadDistributionPolicies {
			// Shadow the loop variable to avoid aliasing
			loadDistributionPolicyItem := loadDistributionPolicyItem
			var loadDistributionPolicy ApplicationGatewayLoadDistributionPolicy
			err := loadDistributionPolicy.Initialize_From_ApplicationGatewayLoadDistributionPolicy_STATUS(&loadDistributionPolicyItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_ApplicationGatewayLoadDistributionPolicy_STATUS() to populate field LoadDistributionPolicies")
			}
			loadDistributionPolicyList[loadDistributionPolicyIndex] = loadDistributionPolicy
		}
		gateway.LoadDistributionPolicies = loadDistributionPolicyList
	} else {
		gateway.LoadDistributionPolicies = nil
	}

	// Location
	gateway.Location = genruntime.ClonePointerToString(source.Location)

	// PrivateLinkConfigurations
	if source.PrivateLinkConfigurations != nil {
		privateLinkConfigurationList := make([]ApplicationGatewayPrivateLinkConfiguration, len(source.PrivateLinkConfigurations))
		for privateLinkConfigurationIndex, privateLinkConfigurationItem := range source.PrivateLinkConfigurations {
			// Shadow the loop variable to avoid aliasing
			privateLinkConfigurationItem := privateLinkConfigurationItem
			var privateLinkConfiguration ApplicationGatewayPrivateLinkConfiguration
			err := privateLinkConfiguration.Initialize_From_ApplicationGatewayPrivateLinkConfiguration_STATUS(&privateLinkConfigurationItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_ApplicationGatewayPrivateLinkConfiguration_STATUS() to populate field PrivateLinkConfigurations")
			}
			privateLinkConfigurationList[privateLinkConfigurationIndex] = privateLinkConfiguration
		}
		gateway.PrivateLinkConfigurations = privateLinkConfigurationList
	} else {
		gateway.PrivateLinkConfigurations = nil
	}

	// Probes
	if source.Probes != nil {
		probeList := make([]ApplicationGatewayProbe, len(source.Probes))
		for probeIndex, probeItem := range source.Probes {
			// Shadow the loop variable to avoid aliasing
			probeItem := probeItem
			var probe ApplicationGatewayProbe
			err := probe.Initialize_From_ApplicationGatewayProbe_STATUS(&probeItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_ApplicationGatewayProbe_STATUS() to populate field Probes")
			}
			probeList[probeIndex] = probe
		}
		gateway.Probes = probeList
	} else {
		gateway.Probes = nil
	}

	// RedirectConfigurations
	if source.RedirectConfigurations != nil {
		redirectConfigurationList := make([]ApplicationGatewayRedirectConfiguration, len(source.RedirectConfigurations))
		for redirectConfigurationIndex, redirectConfigurationItem := range source.RedirectConfigurations {
			// Shadow the loop variable to avoid aliasing
			redirectConfigurationItem := redirectConfigurationItem
			var redirectConfiguration ApplicationGatewayRedirectConfiguration
			err := redirectConfiguration.Initialize_From_ApplicationGatewayRedirectConfiguration_STATUS(&redirectConfigurationItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_ApplicationGatewayRedirectConfiguration_STATUS() to populate field RedirectConfigurations")
			}
			redirectConfigurationList[redirectConfigurationIndex] = redirectConfiguration
		}
		gateway.RedirectConfigurations = redirectConfigurationList
	} else {
		gateway.RedirectConfigurations = nil
	}

	// RequestRoutingRules
	if source.RequestRoutingRules != nil {
		requestRoutingRuleList := make([]ApplicationGatewayRequestRoutingRule, len(source.RequestRoutingRules))
		for requestRoutingRuleIndex, requestRoutingRuleItem := range source.RequestRoutingRules {
			// Shadow the loop variable to avoid aliasing
			requestRoutingRuleItem := requestRoutingRuleItem
			var requestRoutingRule ApplicationGatewayRequestRoutingRule
			err := requestRoutingRule.Initialize_From_ApplicationGatewayRequestRoutingRule_STATUS(&requestRoutingRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_ApplicationGatewayRequestRoutingRule_STATUS() to populate field RequestRoutingRules")
			}
			requestRoutingRuleList[requestRoutingRuleIndex] = requestRoutingRule
		}
		gateway.RequestRoutingRules = requestRoutingRuleList
	} else {
		gateway.RequestRoutingRules = nil
	}

	// RewriteRuleSets
	if source.RewriteRuleSets != nil {
		rewriteRuleSetList := make([]ApplicationGatewayRewriteRuleSet, len(source.RewriteRuleSets))
		for rewriteRuleSetIndex, rewriteRuleSetItem := range source.RewriteRuleSets {
			// Shadow the loop variable to avoid aliasing
			rewriteRuleSetItem := rewriteRuleSetItem
			var rewriteRuleSet ApplicationGatewayRewriteRuleSet
			err := rewriteRuleSet.Initialize_From_ApplicationGatewayRewriteRuleSet_STATUS(&rewriteRuleSetItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_ApplicationGatewayRewriteRuleSet_STATUS() to populate field RewriteRuleSets")
			}
			rewriteRuleSetList[rewriteRuleSetIndex] = rewriteRuleSet
		}
		gateway.RewriteRuleSets = rewriteRuleSetList
	} else {
		gateway.RewriteRuleSets = nil
	}

	// RoutingRules
	if source.RoutingRules != nil {
		routingRuleList := make([]ApplicationGatewayRoutingRule, len(source.RoutingRules))
		for routingRuleIndex, routingRuleItem := range source.RoutingRules {
			// Shadow the loop variable to avoid aliasing
			routingRuleItem := routingRuleItem
			var routingRule ApplicationGatewayRoutingRule
			err := routingRule.Initialize_From_ApplicationGatewayRoutingRule_STATUS(&routingRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_ApplicationGatewayRoutingRule_STATUS() to populate field RoutingRules")
			}
			routingRuleList[routingRuleIndex] = routingRule
		}
		gateway.RoutingRules = routingRuleList
	} else {
		gateway.RoutingRules = nil
	}

	// Sku
	if source.Sku != nil {
		var sku ApplicationGatewaySku
		err := sku.Initialize_From_ApplicationGatewaySku_STATUS(source.Sku)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_ApplicationGatewaySku_STATUS() to populate field Sku")
		}
		gateway.Sku = &sku
	} else {
		gateway.Sku = nil
	}

	// SslCertificates
	if source.SslCertificates != nil {
		sslCertificateList := make([]ApplicationGatewaySslCertificate, len(source.SslCertificates))
		for sslCertificateIndex, sslCertificateItem := range source.SslCertificates {
			// Shadow the loop variable to avoid aliasing
			sslCertificateItem := sslCertificateItem
			var sslCertificate ApplicationGatewaySslCertificate
			err := sslCertificate.Initialize_From_ApplicationGatewaySslCertificate_STATUS(&sslCertificateItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_ApplicationGatewaySslCertificate_STATUS() to populate field SslCertificates")
			}
			sslCertificateList[sslCertificateIndex] = sslCertificate
		}
		gateway.SslCertificates = sslCertificateList
	} else {
		gateway.SslCertificates = nil
	}

	// SslPolicy
	if source.SslPolicy != nil {
		var sslPolicy ApplicationGatewaySslPolicy
		err := sslPolicy.Initialize_From_ApplicationGatewaySslPolicy_STATUS(source.SslPolicy)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_ApplicationGatewaySslPolicy_STATUS() to populate field SslPolicy")
		}
		gateway.SslPolicy = &sslPolicy
	} else {
		gateway.SslPolicy = nil
	}

	// SslProfiles
	if source.SslProfiles != nil {
		sslProfileList := make([]ApplicationGatewaySslProfile, len(source.SslProfiles))
		for sslProfileIndex, sslProfileItem := range source.SslProfiles {
			// Shadow the loop variable to avoid aliasing
			sslProfileItem := sslProfileItem
			var sslProfile ApplicationGatewaySslProfile
			err := sslProfile.Initialize_From_ApplicationGatewaySslProfile_STATUS(&sslProfileItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_ApplicationGatewaySslProfile_STATUS() to populate field SslProfiles")
			}
			sslProfileList[sslProfileIndex] = sslProfile
		}
		gateway.SslProfiles = sslProfileList
	} else {
		gateway.SslProfiles = nil
	}

	// Tags
	gateway.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// TrustedClientCertificates
	if source.TrustedClientCertificates != nil {
		trustedClientCertificateList := make([]ApplicationGatewayTrustedClientCertificate, len(source.TrustedClientCertificates))
		for trustedClientCertificateIndex, trustedClientCertificateItem := range source.TrustedClientCertificates {
			// Shadow the loop variable to avoid aliasing
			trustedClientCertificateItem := trustedClientCertificateItem
			var trustedClientCertificate ApplicationGatewayTrustedClientCertificate
			err := trustedClientCertificate.Initialize_From_ApplicationGatewayTrustedClientCertificate_STATUS(&trustedClientCertificateItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_ApplicationGatewayTrustedClientCertificate_STATUS() to populate field TrustedClientCertificates")
			}
			trustedClientCertificateList[trustedClientCertificateIndex] = trustedClientCertificate
		}
		gateway.TrustedClientCertificates = trustedClientCertificateList
	} else {
		gateway.TrustedClientCertificates = nil
	}

	// TrustedRootCertificates
	if source.TrustedRootCertificates != nil {
		trustedRootCertificateList := make([]ApplicationGatewayTrustedRootCertificate, len(source.TrustedRootCertificates))
		for trustedRootCertificateIndex, trustedRootCertificateItem := range source.TrustedRootCertificates {
			// Shadow the loop variable to avoid aliasing
			trustedRootCertificateItem := trustedRootCertificateItem
			var trustedRootCertificate ApplicationGatewayTrustedRootCertificate
			err := trustedRootCertificate.Initialize_From_ApplicationGatewayTrustedRootCertificate_STATUS(&trustedRootCertificateItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_ApplicationGatewayTrustedRootCertificate_STATUS() to populate field TrustedRootCertificates")
			}
			trustedRootCertificateList[trustedRootCertificateIndex] = trustedRootCertificate
		}
		gateway.TrustedRootCertificates = trustedRootCertificateList
	} else {
		gateway.TrustedRootCertificates = nil
	}

	// UrlPathMaps
	if source.UrlPathMaps != nil {
		urlPathMapList := make([]ApplicationGatewayUrlPathMap, len(source.UrlPathMaps))
		for urlPathMapIndex, urlPathMapItem := range source.UrlPathMaps {
			// Shadow the loop variable to avoid aliasing
			urlPathMapItem := urlPathMapItem
			var urlPathMap ApplicationGatewayUrlPathMap
			err := urlPathMap.Initialize_From_ApplicationGatewayUrlPathMap_STATUS(&urlPathMapItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_ApplicationGatewayUrlPathMap_STATUS() to populate field UrlPathMaps")
			}
			urlPathMapList[urlPathMapIndex] = urlPathMap
		}
		gateway.UrlPathMaps = urlPathMapList
	} else {
		gateway.UrlPathMaps = nil
	}

	// WebApplicationFirewallConfiguration
	if source.WebApplicationFirewallConfiguration != nil {
		var webApplicationFirewallConfiguration ApplicationGatewayWebApplicationFirewallConfiguration
		err := webApplicationFirewallConfiguration.Initialize_From_ApplicationGatewayWebApplicationFirewallConfiguration_STATUS(source.WebApplicationFirewallConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_ApplicationGatewayWebApplicationFirewallConfiguration_STATUS() to populate field WebApplicationFirewallConfiguration")
		}
		gateway.WebApplicationFirewallConfiguration = &webApplicationFirewallConfiguration
	} else {
		gateway.WebApplicationFirewallConfiguration = nil
	}

	// Zones
	gateway.Zones = genruntime.CloneSliceOfString(source.Zones)

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (gateway *ApplicationGateway_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (gateway *ApplicationGateway_Spec) SetAzureName(azureName string) { gateway.AzureName = azureName }

// Application gateway resource.
type ApplicationGateway_STATUS_ApplicationGateway_SubResourceEmbedded struct {
	// AuthenticationCertificates: Authentication certificates of the application gateway resource. For default limits, see
	// [Application Gateway
	// limits](https://docs.microsoft.com/azure/azure-subscription-service-limits#application-gateway-limits).
	AuthenticationCertificates []ApplicationGatewayAuthenticationCertificate_STATUS `json:"authenticationCertificates,omitempty"`

	// AutoscaleConfiguration: Autoscale Configuration.
	AutoscaleConfiguration *ApplicationGatewayAutoscaleConfiguration_STATUS `json:"autoscaleConfiguration,omitempty"`

	// BackendAddressPools: Backend address pool of the application gateway resource. For default limits, see [Application
	// Gateway limits](https://docs.microsoft.com/azure/azure-subscription-service-limits#application-gateway-limits).
	BackendAddressPools []ApplicationGatewayBackendAddressPool_STATUS `json:"backendAddressPools,omitempty"`

	// BackendHttpSettingsCollection: Backend http settings of the application gateway resource. For default limits, see
	// [Application Gateway
	// limits](https://docs.microsoft.com/azure/azure-subscription-service-limits#application-gateway-limits).
	BackendHttpSettingsCollection []ApplicationGatewayBackendHttpSettings_STATUS `json:"backendHttpSettingsCollection,omitempty"`

	// BackendSettingsCollection: Backend settings of the application gateway resource. For default limits, see [Application
	// Gateway limits](https://docs.microsoft.com/azure/azure-subscription-service-limits#application-gateway-limits).
	BackendSettingsCollection []ApplicationGatewayBackendSettings_STATUS `json:"backendSettingsCollection,omitempty"`

	// Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	// CustomErrorConfigurations: Custom error configurations of the application gateway resource.
	CustomErrorConfigurations []ApplicationGatewayCustomError_STATUS `json:"customErrorConfigurations,omitempty"`

	// EnableFips: Whether FIPS is enabled on the application gateway resource.
	EnableFips *bool `json:"enableFips,omitempty"`

	// EnableHttp2: Whether HTTP2 is enabled on the application gateway resource.
	EnableHttp2 *bool `json:"enableHttp2,omitempty"`

	// Etag: A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`

	// FirewallPolicy: Reference to the FirewallPolicy resource.
	FirewallPolicy *SubResource_STATUS `json:"firewallPolicy,omitempty"`

	// ForceFirewallPolicyAssociation: If true, associates a firewall policy with an application gateway regardless whether the
	// policy differs from the WAF Config.
	ForceFirewallPolicyAssociation *bool `json:"forceFirewallPolicyAssociation,omitempty"`

	// FrontendIPConfigurations: Frontend IP addresses of the application gateway resource. For default limits, see
	// [Application Gateway
	// limits](https://docs.microsoft.com/azure/azure-subscription-service-limits#application-gateway-limits).
	FrontendIPConfigurations []ApplicationGatewayFrontendIPConfiguration_STATUS `json:"frontendIPConfigurations,omitempty"`

	// FrontendPorts: Frontend ports of the application gateway resource. For default limits, see [Application Gateway
	// limits](https://docs.microsoft.com/azure/azure-subscription-service-limits#application-gateway-limits).
	FrontendPorts []ApplicationGatewayFrontendPort_STATUS `json:"frontendPorts,omitempty"`

	// GatewayIPConfigurations: Subnets of the application gateway resource. For default limits, see [Application Gateway
	// limits](https://docs.microsoft.com/azure/azure-subscription-service-limits#application-gateway-limits).
	GatewayIPConfigurations []ApplicationGatewayIPConfiguration_STATUS_ApplicationGateway_SubResourceEmbedded `json:"gatewayIPConfigurations,omitempty"`

	// GlobalConfiguration: Global Configuration.
	GlobalConfiguration *ApplicationGatewayGlobalConfiguration_STATUS `json:"globalConfiguration,omitempty"`

	// HttpListeners: Http listeners of the application gateway resource. For default limits, see [Application Gateway
	// limits](https://docs.microsoft.com/azure/azure-subscription-service-limits#application-gateway-limits).
	HttpListeners []ApplicationGatewayHttpListener_STATUS `json:"httpListeners,omitempty"`

	// Id: Resource ID.
	Id *string `json:"id,omitempty"`

	// Identity: The identity of the application gateway, if configured.
	Identity *ManagedServiceIdentity_STATUS `json:"identity,omitempty"`

	// Listeners: Listeners of the application gateway resource. For default limits, see [Application Gateway
	// limits](https://docs.microsoft.com/azure/azure-subscription-service-limits#application-gateway-limits).
	Listeners []ApplicationGatewayListener_STATUS `json:"listeners,omitempty"`

	// LoadDistributionPolicies: Load distribution policies of the application gateway resource.
	LoadDistributionPolicies []ApplicationGatewayLoadDistributionPolicy_STATUS `json:"loadDistributionPolicies,omitempty"`

	// Location: Resource location.
	Location *string `json:"location,omitempty"`

	// Name: Resource name.
	Name *string `json:"name,omitempty"`

	// OperationalState: Operational state of the application gateway resource.
	OperationalState *ApplicationGatewayPropertiesFormat_OperationalState_STATUS `json:"operationalState,omitempty"`

	// PrivateEndpointConnections: Private Endpoint connections on application gateway.
	PrivateEndpointConnections []ApplicationGatewayPrivateEndpointConnection_STATUS `json:"privateEndpointConnections,omitempty"`

	// PrivateLinkConfigurations: PrivateLink configurations on application gateway.
	PrivateLinkConfigurations []ApplicationGatewayPrivateLinkConfiguration_STATUS `json:"privateLinkConfigurations,omitempty"`

	// Probes: Probes of the application gateway resource.
	Probes []ApplicationGatewayProbe_STATUS `json:"probes,omitempty"`

	// ProvisioningState: The provisioning state of the application gateway resource.
	ProvisioningState *ApplicationGatewayProvisioningState_STATUS `json:"provisioningState,omitempty"`

	// RedirectConfigurations: Redirect configurations of the application gateway resource. For default limits, see
	// [Application Gateway
	// limits](https://docs.microsoft.com/azure/azure-subscription-service-limits#application-gateway-limits).
	RedirectConfigurations []ApplicationGatewayRedirectConfiguration_STATUS `json:"redirectConfigurations,omitempty"`

	// RequestRoutingRules: Request routing rules of the application gateway resource.
	RequestRoutingRules []ApplicationGatewayRequestRoutingRule_STATUS `json:"requestRoutingRules,omitempty"`

	// ResourceGuid: The resource GUID property of the application gateway resource.
	ResourceGuid *string `json:"resourceGuid,omitempty"`

	// RewriteRuleSets: Rewrite rules for the application gateway resource.
	RewriteRuleSets []ApplicationGatewayRewriteRuleSet_STATUS `json:"rewriteRuleSets,omitempty"`

	// RoutingRules: Routing rules of the application gateway resource.
	RoutingRules []ApplicationGatewayRoutingRule_STATUS `json:"routingRules,omitempty"`

	// Sku: SKU of the application gateway resource.
	Sku *ApplicationGatewaySku_STATUS `json:"sku,omitempty"`

	// SslCertificates: SSL certificates of the application gateway resource. For default limits, see [Application Gateway
	// limits](https://docs.microsoft.com/azure/azure-subscription-service-limits#application-gateway-limits).
	SslCertificates []ApplicationGatewaySslCertificate_STATUS `json:"sslCertificates,omitempty"`

	// SslPolicy: SSL policy of the application gateway resource.
	SslPolicy *ApplicationGatewaySslPolicy_STATUS `json:"sslPolicy,omitempty"`

	// SslProfiles: SSL profiles of the application gateway resource. For default limits, see [Application Gateway
	// limits](https://docs.microsoft.com/azure/azure-subscription-service-limits#application-gateway-limits).
	SslProfiles []ApplicationGatewaySslProfile_STATUS `json:"sslProfiles,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`

	// TrustedClientCertificates: Trusted client certificates of the application gateway resource. For default limits, see
	// [Application Gateway
	// limits](https://docs.microsoft.com/azure/azure-subscription-service-limits#application-gateway-limits).
	TrustedClientCertificates []ApplicationGatewayTrustedClientCertificate_STATUS `json:"trustedClientCertificates,omitempty"`

	// TrustedRootCertificates: Trusted Root certificates of the application gateway resource. For default limits, see
	// [Application Gateway
	// limits](https://docs.microsoft.com/azure/azure-subscription-service-limits#application-gateway-limits).
	TrustedRootCertificates []ApplicationGatewayTrustedRootCertificate_STATUS `json:"trustedRootCertificates,omitempty"`

	// Type: Resource type.
	Type *string `json:"type,omitempty"`

	// UrlPathMaps: URL path map of the application gateway resource. For default limits, see [Application Gateway
	// limits](https://docs.microsoft.com/azure/azure-subscription-service-limits#application-gateway-limits).
	UrlPathMaps []ApplicationGatewayUrlPathMap_STATUS `json:"urlPathMaps,omitempty"`

	// WebApplicationFirewallConfiguration: Web application firewall configuration.
	WebApplicationFirewallConfiguration *ApplicationGatewayWebApplicationFirewallConfiguration_STATUS `json:"webApplicationFirewallConfiguration,omitempty"`

	// Zones: A list of availability zones denoting where the resource needs to come from.
	Zones []string `json:"zones,omitempty"`
}

var _ genruntime.ConvertibleStatus = &ApplicationGateway_STATUS_ApplicationGateway_SubResourceEmbedded{}

// ConvertStatusFrom populates our ApplicationGateway_STATUS_ApplicationGateway_SubResourceEmbedded from the provided source
func (embedded *ApplicationGateway_STATUS_ApplicationGateway_SubResourceEmbedded) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*storage.ApplicationGateway_STATUS_ApplicationGateway_SubResourceEmbedded)
	if ok {
		// Populate our instance from source
		return embedded.AssignProperties_From_ApplicationGateway_STATUS_ApplicationGateway_SubResourceEmbedded(src)
	}

	// Convert to an intermediate form
	src = &storage.ApplicationGateway_STATUS_ApplicationGateway_SubResourceEmbedded{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = embedded.AssignProperties_From_ApplicationGateway_STATUS_ApplicationGateway_SubResourceEmbedded(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our ApplicationGateway_STATUS_ApplicationGateway_SubResourceEmbedded
func (embedded *ApplicationGateway_STATUS_ApplicationGateway_SubResourceEmbedded) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*storage.ApplicationGateway_STATUS_ApplicationGateway_SubResourceEmbedded)
	if ok {
		// Populate destination from our instance
		return embedded.AssignProperties_To_ApplicationGateway_STATUS_ApplicationGateway_SubResourceEmbedded(dst)
	}

	// Convert to an intermediate form
	dst = &storage.ApplicationGateway_STATUS_ApplicationGateway_SubResourceEmbedded{}
	err := embedded.AssignProperties_To_ApplicationGateway_STATUS_ApplicationGateway_SubResourceEmbedded(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &ApplicationGateway_STATUS_ApplicationGateway_SubResourceEmbedded{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (embedded *ApplicationGateway_STATUS_ApplicationGateway_SubResourceEmbedded) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApplicationGateway_STATUS_ApplicationGateway_SubResourceEmbedded{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (embedded *ApplicationGateway_STATUS_ApplicationGateway_SubResourceEmbedded) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApplicationGateway_STATUS_ApplicationGateway_SubResourceEmbedded)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApplicationGateway_STATUS_ApplicationGateway_SubResourceEmbedded, got %T", armInput)
	}

	// Set property "AuthenticationCertificates":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.AuthenticationCertificates {
			var item1 ApplicationGatewayAuthenticationCertificate_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			embedded.AuthenticationCertificates = append(embedded.AuthenticationCertificates, item1)
		}
	}

	// Set property "AutoscaleConfiguration":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AutoscaleConfiguration != nil {
			var autoscaleConfiguration1 ApplicationGatewayAutoscaleConfiguration_STATUS
			err := autoscaleConfiguration1.PopulateFromARM(owner, *typedInput.Properties.AutoscaleConfiguration)
			if err != nil {
				return err
			}
			autoscaleConfiguration := autoscaleConfiguration1
			embedded.AutoscaleConfiguration = &autoscaleConfiguration
		}
	}

	// Set property "BackendAddressPools":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.BackendAddressPools {
			var item1 ApplicationGatewayBackendAddressPool_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			embedded.BackendAddressPools = append(embedded.BackendAddressPools, item1)
		}
	}

	// Set property "BackendHttpSettingsCollection":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.BackendHttpSettingsCollection {
			var item1 ApplicationGatewayBackendHttpSettings_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			embedded.BackendHttpSettingsCollection = append(embedded.BackendHttpSettingsCollection, item1)
		}
	}

	// Set property "BackendSettingsCollection":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.BackendSettingsCollection {
			var item1 ApplicationGatewayBackendSettings_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			embedded.BackendSettingsCollection = append(embedded.BackendSettingsCollection, item1)
		}
	}

	// no assignment for property "Conditions"

	// Set property "CustomErrorConfigurations":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.CustomErrorConfigurations {
			var item1 ApplicationGatewayCustomError_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			embedded.CustomErrorConfigurations = append(embedded.CustomErrorConfigurations, item1)
		}
	}

	// Set property "EnableFips":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableFips != nil {
			enableFips := *typedInput.Properties.EnableFips
			embedded.EnableFips = &enableFips
		}
	}

	// Set property "EnableHttp2":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableHttp2 != nil {
			enableHttp2 := *typedInput.Properties.EnableHttp2
			embedded.EnableHttp2 = &enableHttp2
		}
	}

	// Set property "Etag":
	if typedInput.Etag != nil {
		etag := *typedInput.Etag
		embedded.Etag = &etag
	}

	// Set property "FirewallPolicy":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.FirewallPolicy != nil {
			var firewallPolicy1 SubResource_STATUS
			err := firewallPolicy1.PopulateFromARM(owner, *typedInput.Properties.FirewallPolicy)
			if err != nil {
				return err
			}
			firewallPolicy := firewallPolicy1
			embedded.FirewallPolicy = &firewallPolicy
		}
	}

	// Set property "ForceFirewallPolicyAssociation":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ForceFirewallPolicyAssociation != nil {
			forceFirewallPolicyAssociation := *typedInput.Properties.ForceFirewallPolicyAssociation
			embedded.ForceFirewallPolicyAssociation = &forceFirewallPolicyAssociation
		}
	}

	// Set property "FrontendIPConfigurations":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.FrontendIPConfigurations {
			var item1 ApplicationGatewayFrontendIPConfiguration_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			embedded.FrontendIPConfigurations = append(embedded.FrontendIPConfigurations, item1)
		}
	}

	// Set property "FrontendPorts":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.FrontendPorts {
			var item1 ApplicationGatewayFrontendPort_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			embedded.FrontendPorts = append(embedded.FrontendPorts, item1)
		}
	}

	// Set property "GatewayIPConfigurations":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.GatewayIPConfigurations {
			var item1 ApplicationGatewayIPConfiguration_STATUS_ApplicationGateway_SubResourceEmbedded
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			embedded.GatewayIPConfigurations = append(embedded.GatewayIPConfigurations, item1)
		}
	}

	// Set property "GlobalConfiguration":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.GlobalConfiguration != nil {
			var globalConfiguration1 ApplicationGatewayGlobalConfiguration_STATUS
			err := globalConfiguration1.PopulateFromARM(owner, *typedInput.Properties.GlobalConfiguration)
			if err != nil {
				return err
			}
			globalConfiguration := globalConfiguration1
			embedded.GlobalConfiguration = &globalConfiguration
		}
	}

	// Set property "HttpListeners":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.HttpListeners {
			var item1 ApplicationGatewayHttpListener_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			embedded.HttpListeners = append(embedded.HttpListeners, item1)
		}
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		embedded.Id = &id
	}

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 ManagedServiceIdentity_STATUS
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		embedded.Identity = &identity
	}

	// Set property "Listeners":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Listeners {
			var item1 ApplicationGatewayListener_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			embedded.Listeners = append(embedded.Listeners, item1)
		}
	}

	// Set property "LoadDistributionPolicies":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.LoadDistributionPolicies {
			var item1 ApplicationGatewayLoadDistributionPolicy_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			embedded.LoadDistributionPolicies = append(embedded.LoadDistributionPolicies, item1)
		}
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		embedded.Location = &location
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		embedded.Name = &name
	}

	// Set property "OperationalState":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.OperationalState != nil {
			var temp string
			temp = string(*typedInput.Properties.OperationalState)
			operationalState := ApplicationGatewayPropertiesFormat_OperationalState_STATUS(temp)
			embedded.OperationalState = &operationalState
		}
	}

	// Set property "PrivateEndpointConnections":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.PrivateEndpointConnections {
			var item1 ApplicationGatewayPrivateEndpointConnection_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			embedded.PrivateEndpointConnections = append(embedded.PrivateEndpointConnections, item1)
		}
	}

	// Set property "PrivateLinkConfigurations":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.PrivateLinkConfigurations {
			var item1 ApplicationGatewayPrivateLinkConfiguration_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			embedded.PrivateLinkConfigurations = append(embedded.PrivateLinkConfigurations, item1)
		}
	}

	// Set property "Probes":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Probes {
			var item1 ApplicationGatewayProbe_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			embedded.Probes = append(embedded.Probes, item1)
		}
	}

	// Set property "ProvisioningState":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			var temp string
			temp = string(*typedInput.Properties.ProvisioningState)
			provisioningState := ApplicationGatewayProvisioningState_STATUS(temp)
			embedded.ProvisioningState = &provisioningState
		}
	}

	// Set property "RedirectConfigurations":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.RedirectConfigurations {
			var item1 ApplicationGatewayRedirectConfiguration_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			embedded.RedirectConfigurations = append(embedded.RedirectConfigurations, item1)
		}
	}

	// Set property "RequestRoutingRules":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.RequestRoutingRules {
			var item1 ApplicationGatewayRequestRoutingRule_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			embedded.RequestRoutingRules = append(embedded.RequestRoutingRules, item1)
		}
	}

	// Set property "ResourceGuid":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ResourceGuid != nil {
			resourceGuid := *typedInput.Properties.ResourceGuid
			embedded.ResourceGuid = &resourceGuid
		}
	}

	// Set property "RewriteRuleSets":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.RewriteRuleSets {
			var item1 ApplicationGatewayRewriteRuleSet_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			embedded.RewriteRuleSets = append(embedded.RewriteRuleSets, item1)
		}
	}

	// Set property "RoutingRules":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.RoutingRules {
			var item1 ApplicationGatewayRoutingRule_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			embedded.RoutingRules = append(embedded.RoutingRules, item1)
		}
	}

	// Set property "Sku":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Sku != nil {
			var sku1 ApplicationGatewaySku_STATUS
			err := sku1.PopulateFromARM(owner, *typedInput.Properties.Sku)
			if err != nil {
				return err
			}
			sku := sku1
			embedded.Sku = &sku
		}
	}

	// Set property "SslCertificates":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.SslCertificates {
			var item1 ApplicationGatewaySslCertificate_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			embedded.SslCertificates = append(embedded.SslCertificates, item1)
		}
	}

	// Set property "SslPolicy":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.SslPolicy != nil {
			var sslPolicy1 ApplicationGatewaySslPolicy_STATUS
			err := sslPolicy1.PopulateFromARM(owner, *typedInput.Properties.SslPolicy)
			if err != nil {
				return err
			}
			sslPolicy := sslPolicy1
			embedded.SslPolicy = &sslPolicy
		}
	}

	// Set property "SslProfiles":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.SslProfiles {
			var item1 ApplicationGatewaySslProfile_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			embedded.SslProfiles = append(embedded.SslProfiles, item1)
		}
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		embedded.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			embedded.Tags[key] = value
		}
	}

	// Set property "TrustedClientCertificates":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.TrustedClientCertificates {
			var item1 ApplicationGatewayTrustedClientCertificate_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			embedded.TrustedClientCertificates = append(embedded.TrustedClientCertificates, item1)
		}
	}

	// Set property "TrustedRootCertificates":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.TrustedRootCertificates {
			var item1 ApplicationGatewayTrustedRootCertificate_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			embedded.TrustedRootCertificates = append(embedded.TrustedRootCertificates, item1)
		}
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		embedded.Type = &typeVar
	}

	// Set property "UrlPathMaps":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.UrlPathMaps {
			var item1 ApplicationGatewayUrlPathMap_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			embedded.UrlPathMaps = append(embedded.UrlPathMaps, item1)
		}
	}

	// Set property "WebApplicationFirewallConfiguration":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.WebApplicationFirewallConfiguration != nil {
			var webApplicationFirewallConfiguration1 ApplicationGatewayWebApplicationFirewallConfiguration_STATUS
			err := webApplicationFirewallConfiguration1.PopulateFromARM(owner, *typedInput.Properties.WebApplicationFirewallConfiguration)
			if err != nil {
				return err
			}
			webApplicationFirewallConfiguration := webApplicationFirewallConfiguration1
			embedded.WebApplicationFirewallConfiguration = &webApplicationFirewallConfiguration
		}
	}

	// Set property "Zones":
	for _, item := range typedInput.Zones {
		embedded.Zones = append(embedded.Zones, item)
	}

	// No error
	return nil
}

// AssignProperties_From_ApplicationGateway_STATUS_ApplicationGateway_SubResourceEmbedded populates our ApplicationGateway_STATUS_ApplicationGateway_SubResourceEmbedded from the provided source ApplicationGateway_STATUS_ApplicationGateway_SubResourceEmbedded
func (embedded *ApplicationGateway_STATUS_ApplicationGateway_SubResourceEmbedded) AssignProperties_From_ApplicationGateway_STATUS_ApplicationGateway_SubResourceEmbedded(source *storage.ApplicationGateway_STATUS_ApplicationGateway_SubResourceEmbedded) error {

	// AuthenticationCertificates
	if source.AuthenticationCertificates != nil {
		authenticationCertificateList := make([]ApplicationGatewayAuthenticationCertificate_STATUS, len(source.AuthenticationCertificates))
		for authenticationCertificateIndex, authenticationCertificateItem := range source.AuthenticationCertificates {
			// Shadow the loop variable to avoid aliasing
			authenticationCertificateItem := authenticationCertificateItem
			var authenticationCertificate ApplicationGatewayAuthenticationCertificate_STATUS
			err := authenticationCertificate.AssignProperties_From_ApplicationGatewayAuthenticationCertificate_STATUS(&authenticationCertificateItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ApplicationGatewayAuthenticationCertificate_STATUS() to populate field AuthenticationCertificates")
			}
			authenticationCertificateList[authenticationCertificateIndex] = authenticationCertificate
		}
		embedded.AuthenticationCertificates = authenticationCertificateList
	} else {
		embedded.AuthenticationCertificates = nil
	}

	// AutoscaleConfiguration
	if source.AutoscaleConfiguration != nil {
		var autoscaleConfiguration ApplicationGatewayAutoscaleConfiguration_STATUS
		err := autoscaleConfiguration.AssignProperties_From_ApplicationGatewayAutoscaleConfiguration_STATUS(source.AutoscaleConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ApplicationGatewayAutoscaleConfiguration_STATUS() to populate field AutoscaleConfiguration")
		}
		embedded.AutoscaleConfiguration = &autoscaleConfiguration
	} else {
		embedded.AutoscaleConfiguration = nil
	}

	// BackendAddressPools
	if source.BackendAddressPools != nil {
		backendAddressPoolList := make([]ApplicationGatewayBackendAddressPool_STATUS, len(source.BackendAddressPools))
		for backendAddressPoolIndex, backendAddressPoolItem := range source.BackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			backendAddressPoolItem := backendAddressPoolItem
			var backendAddressPool ApplicationGatewayBackendAddressPool_STATUS
			err := backendAddressPool.AssignProperties_From_ApplicationGatewayBackendAddressPool_STATUS(&backendAddressPoolItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ApplicationGatewayBackendAddressPool_STATUS() to populate field BackendAddressPools")
			}
			backendAddressPoolList[backendAddressPoolIndex] = backendAddressPool
		}
		embedded.BackendAddressPools = backendAddressPoolList
	} else {
		embedded.BackendAddressPools = nil
	}

	// BackendHttpSettingsCollection
	if source.BackendHttpSettingsCollection != nil {
		backendHttpSettingsCollectionList := make([]ApplicationGatewayBackendHttpSettings_STATUS, len(source.BackendHttpSettingsCollection))
		for backendHttpSettingsCollectionIndex, backendHttpSettingsCollectionItem := range source.BackendHttpSettingsCollection {
			// Shadow the loop variable to avoid aliasing
			backendHttpSettingsCollectionItem := backendHttpSettingsCollectionItem
			var backendHttpSettingsCollection ApplicationGatewayBackendHttpSettings_STATUS
			err := backendHttpSettingsCollection.AssignProperties_From_ApplicationGatewayBackendHttpSettings_STATUS(&backendHttpSettingsCollectionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ApplicationGatewayBackendHttpSettings_STATUS() to populate field BackendHttpSettingsCollection")
			}
			backendHttpSettingsCollectionList[backendHttpSettingsCollectionIndex] = backendHttpSettingsCollection
		}
		embedded.BackendHttpSettingsCollection = backendHttpSettingsCollectionList
	} else {
		embedded.BackendHttpSettingsCollection = nil
	}

	// BackendSettingsCollection
	if source.BackendSettingsCollection != nil {
		backendSettingsCollectionList := make([]ApplicationGatewayBackendSettings_STATUS, len(source.BackendSettingsCollection))
		for backendSettingsCollectionIndex, backendSettingsCollectionItem := range source.BackendSettingsCollection {
			// Shadow the loop variable to avoid aliasing
			backendSettingsCollectionItem := backendSettingsCollectionItem
			var backendSettingsCollection ApplicationGatewayBackendSettings_STATUS
			err := backendSettingsCollection.AssignProperties_From_ApplicationGatewayBackendSettings_STATUS(&backendSettingsCollectionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ApplicationGatewayBackendSettings_STATUS() to populate field BackendSettingsCollection")
			}
			backendSettingsCollectionList[backendSettingsCollectionIndex] = backendSettingsCollection
		}
		embedded.BackendSettingsCollection = backendSettingsCollectionList
	} else {
		embedded.BackendSettingsCollection = nil
	}

	// Conditions
	embedded.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// CustomErrorConfigurations
	if source.CustomErrorConfigurations != nil {
		customErrorConfigurationList := make([]ApplicationGatewayCustomError_STATUS, len(source.CustomErrorConfigurations))
		for customErrorConfigurationIndex, customErrorConfigurationItem := range source.CustomErrorConfigurations {
			// Shadow the loop variable to avoid aliasing
			customErrorConfigurationItem := customErrorConfigurationItem
			var customErrorConfiguration ApplicationGatewayCustomError_STATUS
			err := customErrorConfiguration.AssignProperties_From_ApplicationGatewayCustomError_STATUS(&customErrorConfigurationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ApplicationGatewayCustomError_STATUS() to populate field CustomErrorConfigurations")
			}
			customErrorConfigurationList[customErrorConfigurationIndex] = customErrorConfiguration
		}
		embedded.CustomErrorConfigurations = customErrorConfigurationList
	} else {
		embedded.CustomErrorConfigurations = nil
	}

	// EnableFips
	if source.EnableFips != nil {
		enableFip := *source.EnableFips
		embedded.EnableFips = &enableFip
	} else {
		embedded.EnableFips = nil
	}

	// EnableHttp2
	if source.EnableHttp2 != nil {
		enableHttp2 := *source.EnableHttp2
		embedded.EnableHttp2 = &enableHttp2
	} else {
		embedded.EnableHttp2 = nil
	}

	// Etag
	embedded.Etag = genruntime.ClonePointerToString(source.Etag)

	// FirewallPolicy
	if source.FirewallPolicy != nil {
		var firewallPolicy SubResource_STATUS
		err := firewallPolicy.AssignProperties_From_SubResource_STATUS(source.FirewallPolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field FirewallPolicy")
		}
		embedded.FirewallPolicy = &firewallPolicy
	} else {
		embedded.FirewallPolicy = nil
	}

	// ForceFirewallPolicyAssociation
	if source.ForceFirewallPolicyAssociation != nil {
		forceFirewallPolicyAssociation := *source.ForceFirewallPolicyAssociation
		embedded.ForceFirewallPolicyAssociation = &forceFirewallPolicyAssociation
	} else {
		embedded.ForceFirewallPolicyAssociation = nil
	}

	// FrontendIPConfigurations
	if source.FrontendIPConfigurations != nil {
		frontendIPConfigurationList := make([]ApplicationGatewayFrontendIPConfiguration_STATUS, len(source.FrontendIPConfigurations))
		for frontendIPConfigurationIndex, frontendIPConfigurationItem := range source.FrontendIPConfigurations {
			// Shadow the loop variable to avoid aliasing
			frontendIPConfigurationItem := frontendIPConfigurationItem
			var frontendIPConfiguration ApplicationGatewayFrontendIPConfiguration_STATUS
			err := frontendIPConfiguration.AssignProperties_From_ApplicationGatewayFrontendIPConfiguration_STATUS(&frontendIPConfigurationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ApplicationGatewayFrontendIPConfiguration_STATUS() to populate field FrontendIPConfigurations")
			}
			frontendIPConfigurationList[frontendIPConfigurationIndex] = frontendIPConfiguration
		}
		embedded.FrontendIPConfigurations = frontendIPConfigurationList
	} else {
		embedded.FrontendIPConfigurations = nil
	}

	// FrontendPorts
	if source.FrontendPorts != nil {
		frontendPortList := make([]ApplicationGatewayFrontendPort_STATUS, len(source.FrontendPorts))
		for frontendPortIndex, frontendPortItem := range source.FrontendPorts {
			// Shadow the loop variable to avoid aliasing
			frontendPortItem := frontendPortItem
			var frontendPort ApplicationGatewayFrontendPort_STATUS
			err := frontendPort.AssignProperties_From_ApplicationGatewayFrontendPort_STATUS(&frontendPortItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ApplicationGatewayFrontendPort_STATUS() to populate field FrontendPorts")
			}
			frontendPortList[frontendPortIndex] = frontendPort
		}
		embedded.FrontendPorts = frontendPortList
	} else {
		embedded.FrontendPorts = nil
	}

	// GatewayIPConfigurations
	if source.GatewayIPConfigurations != nil {
		gatewayIPConfigurationList := make([]ApplicationGatewayIPConfiguration_STATUS_ApplicationGateway_SubResourceEmbedded, len(source.GatewayIPConfigurations))
		for gatewayIPConfigurationIndex, gatewayIPConfigurationItem := range source.GatewayIPConfigurations {
			// Shadow the loop variable to avoid aliasing
			gatewayIPConfigurationItem := gatewayIPConfigurationItem
			var gatewayIPConfiguration ApplicationGatewayIPConfiguration_STATUS_ApplicationGateway_SubResourceEmbedded
			err := gatewayIPConfiguration.AssignProperties_From_ApplicationGatewayIPConfiguration_STATUS_ApplicationGateway_SubResourceEmbedded(&gatewayIPConfigurationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ApplicationGatewayIPConfiguration_STATUS_ApplicationGateway_SubResourceEmbedded() to populate field GatewayIPConfigurations")
			}
			gatewayIPConfigurationList[gatewayIPConfigurationIndex] = gatewayIPConfiguration
		}
		embedded.GatewayIPConfigurations = gatewayIPConfigurationList
	} else {
		embedded.GatewayIPConfigurations = nil
	}

	// GlobalConfiguration
	if source.GlobalConfiguration != nil {
		var globalConfiguration ApplicationGatewayGlobalConfiguration_STATUS
		err := globalConfiguration.AssignProperties_From_ApplicationGatewayGlobalConfiguration_STATUS(source.GlobalConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ApplicationGatewayGlobalConfiguration_STATUS() to populate field GlobalConfiguration")
		}
		embedded.GlobalConfiguration = &globalConfiguration
	} else {
		embedded.GlobalConfiguration = nil
	}

	// HttpListeners
	if source.HttpListeners != nil {
		httpListenerList := make([]ApplicationGatewayHttpListener_STATUS, len(source.HttpListeners))
		for httpListenerIndex, httpListenerItem := range source.HttpListeners {
			// Shadow the loop variable to avoid aliasing
			httpListenerItem := httpListenerItem
			var httpListener ApplicationGatewayHttpListener_STATUS
			err := httpListener.AssignProperties_From_ApplicationGatewayHttpListener_STATUS(&httpListenerItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ApplicationGatewayHttpListener_STATUS() to populate field HttpListeners")
			}
			httpListenerList[httpListenerIndex] = httpListener
		}
		embedded.HttpListeners = httpListenerList
	} else {
		embedded.HttpListeners = nil
	}

	// Id
	embedded.Id = genruntime.ClonePointerToString(source.Id)

	// Identity
	if source.Identity != nil {
		var identity ManagedServiceIdentity_STATUS
		err := identity.AssignProperties_From_ManagedServiceIdentity_STATUS(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedServiceIdentity_STATUS() to populate field Identity")
		}
		embedded.Identity = &identity
	} else {
		embedded.Identity = nil
	}

	// Listeners
	if source.Listeners != nil {
		listenerList := make([]ApplicationGatewayListener_STATUS, len(source.Listeners))
		for listenerIndex, listenerItem := range source.Listeners {
			// Shadow the loop variable to avoid aliasing
			listenerItem := listenerItem
			var listener ApplicationGatewayListener_STATUS
			err := listener.AssignProperties_From_ApplicationGatewayListener_STATUS(&listenerItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ApplicationGatewayListener_STATUS() to populate field Listeners")
			}
			listenerList[listenerIndex] = listener
		}
		embedded.Listeners = listenerList
	} else {
		embedded.Listeners = nil
	}

	// LoadDistributionPolicies
	if source.LoadDistributionPolicies != nil {
		loadDistributionPolicyList := make([]ApplicationGatewayLoadDistributionPolicy_STATUS, len(source.LoadDistributionPolicies))
		for loadDistributionPolicyIndex, loadDistributionPolicyItem := range source.LoadDistributionPolicies {
			// Shadow the loop variable to avoid aliasing
			loadDistributionPolicyItem := loadDistributionPolicyItem
			var loadDistributionPolicy ApplicationGatewayLoadDistributionPolicy_STATUS
			err := loadDistributionPolicy.AssignProperties_From_ApplicationGatewayLoadDistributionPolicy_STATUS(&loadDistributionPolicyItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ApplicationGatewayLoadDistributionPolicy_STATUS() to populate field LoadDistributionPolicies")
			}
			loadDistributionPolicyList[loadDistributionPolicyIndex] = loadDistributionPolicy
		}
		embedded.LoadDistributionPolicies = loadDistributionPolicyList
	} else {
		embedded.LoadDistributionPolicies = nil
	}

	// Location
	embedded.Location = genruntime.ClonePointerToString(source.Location)

	// Name
	embedded.Name = genruntime.ClonePointerToString(source.Name)

	// OperationalState
	if source.OperationalState != nil {
		operationalState := *source.OperationalState
		operationalStateTemp := genruntime.ToEnum(operationalState, applicationGatewayPropertiesFormat_OperationalState_STATUS_Values)
		embedded.OperationalState = &operationalStateTemp
	} else {
		embedded.OperationalState = nil
	}

	// PrivateEndpointConnections
	if source.PrivateEndpointConnections != nil {
		privateEndpointConnectionList := make([]ApplicationGatewayPrivateEndpointConnection_STATUS, len(source.PrivateEndpointConnections))
		for privateEndpointConnectionIndex, privateEndpointConnectionItem := range source.PrivateEndpointConnections {
			// Shadow the loop variable to avoid aliasing
			privateEndpointConnectionItem := privateEndpointConnectionItem
			var privateEndpointConnection ApplicationGatewayPrivateEndpointConnection_STATUS
			err := privateEndpointConnection.AssignProperties_From_ApplicationGatewayPrivateEndpointConnection_STATUS(&privateEndpointConnectionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ApplicationGatewayPrivateEndpointConnection_STATUS() to populate field PrivateEndpointConnections")
			}
			privateEndpointConnectionList[privateEndpointConnectionIndex] = privateEndpointConnection
		}
		embedded.PrivateEndpointConnections = privateEndpointConnectionList
	} else {
		embedded.PrivateEndpointConnections = nil
	}

	// PrivateLinkConfigurations
	if source.PrivateLinkConfigurations != nil {
		privateLinkConfigurationList := make([]ApplicationGatewayPrivateLinkConfiguration_STATUS, len(source.PrivateLinkConfigurations))
		for privateLinkConfigurationIndex, privateLinkConfigurationItem := range source.PrivateLinkConfigurations {
			// Shadow the loop variable to avoid aliasing
			privateLinkConfigurationItem := privateLinkConfigurationItem
			var privateLinkConfiguration ApplicationGatewayPrivateLinkConfiguration_STATUS
			err := privateLinkConfiguration.AssignProperties_From_ApplicationGatewayPrivateLinkConfiguration_STATUS(&privateLinkConfigurationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ApplicationGatewayPrivateLinkConfiguration_STATUS() to populate field PrivateLinkConfigurations")
			}
			privateLinkConfigurationList[privateLinkConfigurationIndex] = privateLinkConfiguration
		}
		embedded.PrivateLinkConfigurations = privateLinkConfigurationList
	} else {
		embedded.PrivateLinkConfigurations = nil
	}

	// Probes
	if source.Probes != nil {
		probeList := make([]ApplicationGatewayProbe_STATUS, len(source.Probes))
		for probeIndex, probeItem := range source.Probes {
			// Shadow the loop variable to avoid aliasing
			probeItem := probeItem
			var probe ApplicationGatewayProbe_STATUS
			err := probe.AssignProperties_From_ApplicationGatewayProbe_STATUS(&probeItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ApplicationGatewayProbe_STATUS() to populate field Probes")
			}
			probeList[probeIndex] = probe
		}
		embedded.Probes = probeList
	} else {
		embedded.Probes = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := *source.ProvisioningState
		provisioningStateTemp := genruntime.ToEnum(provisioningState, applicationGatewayProvisioningState_STATUS_Values)
		embedded.ProvisioningState = &provisioningStateTemp
	} else {
		embedded.ProvisioningState = nil
	}

	// RedirectConfigurations
	if source.RedirectConfigurations != nil {
		redirectConfigurationList := make([]ApplicationGatewayRedirectConfiguration_STATUS, len(source.RedirectConfigurations))
		for redirectConfigurationIndex, redirectConfigurationItem := range source.RedirectConfigurations {
			// Shadow the loop variable to avoid aliasing
			redirectConfigurationItem := redirectConfigurationItem
			var redirectConfiguration ApplicationGatewayRedirectConfiguration_STATUS
			err := redirectConfiguration.AssignProperties_From_ApplicationGatewayRedirectConfiguration_STATUS(&redirectConfigurationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ApplicationGatewayRedirectConfiguration_STATUS() to populate field RedirectConfigurations")
			}
			redirectConfigurationList[redirectConfigurationIndex] = redirectConfiguration
		}
		embedded.RedirectConfigurations = redirectConfigurationList
	} else {
		embedded.RedirectConfigurations = nil
	}

	// RequestRoutingRules
	if source.RequestRoutingRules != nil {
		requestRoutingRuleList := make([]ApplicationGatewayRequestRoutingRule_STATUS, len(source.RequestRoutingRules))
		for requestRoutingRuleIndex, requestRoutingRuleItem := range source.RequestRoutingRules {
			// Shadow the loop variable to avoid aliasing
			requestRoutingRuleItem := requestRoutingRuleItem
			var requestRoutingRule ApplicationGatewayRequestRoutingRule_STATUS
			err := requestRoutingRule.AssignProperties_From_ApplicationGatewayRequestRoutingRule_STATUS(&requestRoutingRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ApplicationGatewayRequestRoutingRule_STATUS() to populate field RequestRoutingRules")
			}
			requestRoutingRuleList[requestRoutingRuleIndex] = requestRoutingRule
		}
		embedded.RequestRoutingRules = requestRoutingRuleList
	} else {
		embedded.RequestRoutingRules = nil
	}

	// ResourceGuid
	embedded.ResourceGuid = genruntime.ClonePointerToString(source.ResourceGuid)

	// RewriteRuleSets
	if source.RewriteRuleSets != nil {
		rewriteRuleSetList := make([]ApplicationGatewayRewriteRuleSet_STATUS, len(source.RewriteRuleSets))
		for rewriteRuleSetIndex, rewriteRuleSetItem := range source.RewriteRuleSets {
			// Shadow the loop variable to avoid aliasing
			rewriteRuleSetItem := rewriteRuleSetItem
			var rewriteRuleSet ApplicationGatewayRewriteRuleSet_STATUS
			err := rewriteRuleSet.AssignProperties_From_ApplicationGatewayRewriteRuleSet_STATUS(&rewriteRuleSetItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ApplicationGatewayRewriteRuleSet_STATUS() to populate field RewriteRuleSets")
			}
			rewriteRuleSetList[rewriteRuleSetIndex] = rewriteRuleSet
		}
		embedded.RewriteRuleSets = rewriteRuleSetList
	} else {
		embedded.RewriteRuleSets = nil
	}

	// RoutingRules
	if source.RoutingRules != nil {
		routingRuleList := make([]ApplicationGatewayRoutingRule_STATUS, len(source.RoutingRules))
		for routingRuleIndex, routingRuleItem := range source.RoutingRules {
			// Shadow the loop variable to avoid aliasing
			routingRuleItem := routingRuleItem
			var routingRule ApplicationGatewayRoutingRule_STATUS
			err := routingRule.AssignProperties_From_ApplicationGatewayRoutingRule_STATUS(&routingRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ApplicationGatewayRoutingRule_STATUS() to populate field RoutingRules")
			}
			routingRuleList[routingRuleIndex] = routingRule
		}
		embedded.RoutingRules = routingRuleList
	} else {
		embedded.RoutingRules = nil
	}

	// Sku
	if source.Sku != nil {
		var sku ApplicationGatewaySku_STATUS
		err := sku.AssignProperties_From_ApplicationGatewaySku_STATUS(source.Sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ApplicationGatewaySku_STATUS() to populate field Sku")
		}
		embedded.Sku = &sku
	} else {
		embedded.Sku = nil
	}

	// SslCertificates
	if source.SslCertificates != nil {
		sslCertificateList := make([]ApplicationGatewaySslCertificate_STATUS, len(source.SslCertificates))
		for sslCertificateIndex, sslCertificateItem := range source.SslCertificates {
			// Shadow the loop variable to avoid aliasing
			sslCertificateItem := sslCertificateItem
			var sslCertificate ApplicationGatewaySslCertificate_STATUS
			err := sslCertificate.AssignProperties_From_ApplicationGatewaySslCertificate_STATUS(&sslCertificateItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ApplicationGatewaySslCertificate_STATUS() to populate field SslCertificates")
			}
			sslCertificateList[sslCertificateIndex] = sslCertificate
		}
		embedded.SslCertificates = sslCertificateList
	} else {
		embedded.SslCertificates = nil
	}

	// SslPolicy
	if source.SslPolicy != nil {
		var sslPolicy ApplicationGatewaySslPolicy_STATUS
		err := sslPolicy.AssignProperties_From_ApplicationGatewaySslPolicy_STATUS(source.SslPolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ApplicationGatewaySslPolicy_STATUS() to populate field SslPolicy")
		}
		embedded.SslPolicy = &sslPolicy
	} else {
		embedded.SslPolicy = nil
	}

	// SslProfiles
	if source.SslProfiles != nil {
		sslProfileList := make([]ApplicationGatewaySslProfile_STATUS, len(source.SslProfiles))
		for sslProfileIndex, sslProfileItem := range source.SslProfiles {
			// Shadow the loop variable to avoid aliasing
			sslProfileItem := sslProfileItem
			var sslProfile ApplicationGatewaySslProfile_STATUS
			err := sslProfile.AssignProperties_From_ApplicationGatewaySslProfile_STATUS(&sslProfileItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ApplicationGatewaySslProfile_STATUS() to populate field SslProfiles")
			}
			sslProfileList[sslProfileIndex] = sslProfile
		}
		embedded.SslProfiles = sslProfileList
	} else {
		embedded.SslProfiles = nil
	}

	// Tags
	embedded.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// TrustedClientCertificates
	if source.TrustedClientCertificates != nil {
		trustedClientCertificateList := make([]ApplicationGatewayTrustedClientCertificate_STATUS, len(source.TrustedClientCertificates))
		for trustedClientCertificateIndex, trustedClientCertificateItem := range source.TrustedClientCertificates {
			// Shadow the loop variable to avoid aliasing
			trustedClientCertificateItem := trustedClientCertificateItem
			var trustedClientCertificate ApplicationGatewayTrustedClientCertificate_STATUS
			err := trustedClientCertificate.AssignProperties_From_ApplicationGatewayTrustedClientCertificate_STATUS(&trustedClientCertificateItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ApplicationGatewayTrustedClientCertificate_STATUS() to populate field TrustedClientCertificates")
			}
			trustedClientCertificateList[trustedClientCertificateIndex] = trustedClientCertificate
		}
		embedded.TrustedClientCertificates = trustedClientCertificateList
	} else {
		embedded.TrustedClientCertificates = nil
	}

	// TrustedRootCertificates
	if source.TrustedRootCertificates != nil {
		trustedRootCertificateList := make([]ApplicationGatewayTrustedRootCertificate_STATUS, len(source.TrustedRootCertificates))
		for trustedRootCertificateIndex, trustedRootCertificateItem := range source.TrustedRootCertificates {
			// Shadow the loop variable to avoid aliasing
			trustedRootCertificateItem := trustedRootCertificateItem
			var trustedRootCertificate ApplicationGatewayTrustedRootCertificate_STATUS
			err := trustedRootCertificate.AssignProperties_From_ApplicationGatewayTrustedRootCertificate_STATUS(&trustedRootCertificateItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ApplicationGatewayTrustedRootCertificate_STATUS() to populate field TrustedRootCertificates")
			}
			trustedRootCertificateList[trustedRootCertificateIndex] = trustedRootCertificate
		}
		embedded.TrustedRootCertificates = trustedRootCertificateList
	} else {
		embedded.TrustedRootCertificates = nil
	}

	// Type
	embedded.Type = genruntime.ClonePointerToString(source.Type)

	// UrlPathMaps
	if source.UrlPathMaps != nil {
		urlPathMapList := make([]ApplicationGatewayUrlPathMap_STATUS, len(source.UrlPathMaps))
		for urlPathMapIndex, urlPathMapItem := range source.UrlPathMaps {
			// Shadow the loop variable to avoid aliasing
			urlPathMapItem := urlPathMapItem
			var urlPathMap ApplicationGatewayUrlPathMap_STATUS
			err := urlPathMap.AssignProperties_From_ApplicationGatewayUrlPathMap_STATUS(&urlPathMapItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ApplicationGatewayUrlPathMap_STATUS() to populate field UrlPathMaps")
			}
			urlPathMapList[urlPathMapIndex] = urlPathMap
		}
		embedded.UrlPathMaps = urlPathMapList
	} else {
		embedded.UrlPathMaps = nil
	}

	// WebApplicationFirewallConfiguration
	if source.WebApplicationFirewallConfiguration != nil {
		var webApplicationFirewallConfiguration ApplicationGatewayWebApplicationFirewallConfiguration_STATUS
		err := webApplicationFirewallConfiguration.AssignProperties_From_ApplicationGatewayWebApplicationFirewallConfiguration_STATUS(source.WebApplicationFirewallConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ApplicationGatewayWebApplicationFirewallConfiguration_STATUS() to populate field WebApplicationFirewallConfiguration")
		}
		embedded.WebApplicationFirewallConfiguration = &webApplicationFirewallConfiguration
	} else {
		embedded.WebApplicationFirewallConfiguration = nil
	}

	// Zones
	embedded.Zones = genruntime.CloneSliceOfString(source.Zones)

	// No error
	return nil
}

// AssignProperties_To_ApplicationGateway_STATUS_ApplicationGateway_SubResourceEmbedded populates the provided destination ApplicationGateway_STATUS_ApplicationGateway_SubResourceEmbedded from our ApplicationGateway_STATUS_ApplicationGateway_SubResourceEmbedded
func (embedded *ApplicationGateway_STATUS_ApplicationGateway_SubResourceEmbedded) AssignProperties_To_ApplicationGateway_STATUS_ApplicationGateway_SubResourceEmbedded(destination *storage.ApplicationGateway_STATUS_ApplicationGateway_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AuthenticationCertificates
	if embedded.AuthenticationCertificates != nil {
		authenticationCertificateList := make([]storage.ApplicationGatewayAuthenticationCertificate_STATUS, len(embedded.AuthenticationCertificates))
		for authenticationCertificateIndex, authenticationCertificateItem := range embedded.AuthenticationCertificates {
			// Shadow the loop variable to avoid aliasing
			authenticationCertificateItem := authenticationCertificateItem
			var authenticationCertificate storage.ApplicationGatewayAuthenticationCertificate_STATUS
			err := authenticationCertificateItem.AssignProperties_To_ApplicationGatewayAuthenticationCertificate_STATUS(&authenticationCertificate)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ApplicationGatewayAuthenticationCertificate_STATUS() to populate field AuthenticationCertificates")
			}
			authenticationCertificateList[authenticationCertificateIndex] = authenticationCertificate
		}
		destination.AuthenticationCertificates = authenticationCertificateList
	} else {
		destination.AuthenticationCertificates = nil
	}

	// AutoscaleConfiguration
	if embedded.AutoscaleConfiguration != nil {
		var autoscaleConfiguration storage.ApplicationGatewayAutoscaleConfiguration_STATUS
		err := embedded.AutoscaleConfiguration.AssignProperties_To_ApplicationGatewayAutoscaleConfiguration_STATUS(&autoscaleConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ApplicationGatewayAutoscaleConfiguration_STATUS() to populate field AutoscaleConfiguration")
		}
		destination.AutoscaleConfiguration = &autoscaleConfiguration
	} else {
		destination.AutoscaleConfiguration = nil
	}

	// BackendAddressPools
	if embedded.BackendAddressPools != nil {
		backendAddressPoolList := make([]storage.ApplicationGatewayBackendAddressPool_STATUS, len(embedded.BackendAddressPools))
		for backendAddressPoolIndex, backendAddressPoolItem := range embedded.BackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			backendAddressPoolItem := backendAddressPoolItem
			var backendAddressPool storage.ApplicationGatewayBackendAddressPool_STATUS
			err := backendAddressPoolItem.AssignProperties_To_ApplicationGatewayBackendAddressPool_STATUS(&backendAddressPool)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ApplicationGatewayBackendAddressPool_STATUS() to populate field BackendAddressPools")
			}
			backendAddressPoolList[backendAddressPoolIndex] = backendAddressPool
		}
		destination.BackendAddressPools = backendAddressPoolList
	} else {
		destination.BackendAddressPools = nil
	}

	// BackendHttpSettingsCollection
	if embedded.BackendHttpSettingsCollection != nil {
		backendHttpSettingsCollectionList := make([]storage.ApplicationGatewayBackendHttpSettings_STATUS, len(embedded.BackendHttpSettingsCollection))
		for backendHttpSettingsCollectionIndex, backendHttpSettingsCollectionItem := range embedded.BackendHttpSettingsCollection {
			// Shadow the loop variable to avoid aliasing
			backendHttpSettingsCollectionItem := backendHttpSettingsCollectionItem
			var backendHttpSettingsCollection storage.ApplicationGatewayBackendHttpSettings_STATUS
			err := backendHttpSettingsCollectionItem.AssignProperties_To_ApplicationGatewayBackendHttpSettings_STATUS(&backendHttpSettingsCollection)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ApplicationGatewayBackendHttpSettings_STATUS() to populate field BackendHttpSettingsCollection")
			}
			backendHttpSettingsCollectionList[backendHttpSettingsCollectionIndex] = backendHttpSettingsCollection
		}
		destination.BackendHttpSettingsCollection = backendHttpSettingsCollectionList
	} else {
		destination.BackendHttpSettingsCollection = nil
	}

	// BackendSettingsCollection
	if embedded.BackendSettingsCollection != nil {
		backendSettingsCollectionList := make([]storage.ApplicationGatewayBackendSettings_STATUS, len(embedded.BackendSettingsCollection))
		for backendSettingsCollectionIndex, backendSettingsCollectionItem := range embedded.BackendSettingsCollection {
			// Shadow the loop variable to avoid aliasing
			backendSettingsCollectionItem := backendSettingsCollectionItem
			var backendSettingsCollection storage.ApplicationGatewayBackendSettings_STATUS
			err := backendSettingsCollectionItem.AssignProperties_To_ApplicationGatewayBackendSettings_STATUS(&backendSettingsCollection)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ApplicationGatewayBackendSettings_STATUS() to populate field BackendSettingsCollection")
			}
			backendSettingsCollectionList[backendSettingsCollectionIndex] = backendSettingsCollection
		}
		destination.BackendSettingsCollection = backendSettingsCollectionList
	} else {
		destination.BackendSettingsCollection = nil
	}

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(embedded.Conditions)

	// CustomErrorConfigurations
	if embedded.CustomErrorConfigurations != nil {
		customErrorConfigurationList := make([]storage.ApplicationGatewayCustomError_STATUS, len(embedded.CustomErrorConfigurations))
		for customErrorConfigurationIndex, customErrorConfigurationItem := range embedded.CustomErrorConfigurations {
			// Shadow the loop variable to avoid aliasing
			customErrorConfigurationItem := customErrorConfigurationItem
			var customErrorConfiguration storage.ApplicationGatewayCustomError_STATUS
			err := customErrorConfigurationItem.AssignProperties_To_ApplicationGatewayCustomError_STATUS(&customErrorConfiguration)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ApplicationGatewayCustomError_STATUS() to populate field CustomErrorConfigurations")
			}
			customErrorConfigurationList[customErrorConfigurationIndex] = customErrorConfiguration
		}
		destination.CustomErrorConfigurations = customErrorConfigurationList
	} else {
		destination.CustomErrorConfigurations = nil
	}

	// EnableFips
	if embedded.EnableFips != nil {
		enableFip := *embedded.EnableFips
		destination.EnableFips = &enableFip
	} else {
		destination.EnableFips = nil
	}

	// EnableHttp2
	if embedded.EnableHttp2 != nil {
		enableHttp2 := *embedded.EnableHttp2
		destination.EnableHttp2 = &enableHttp2
	} else {
		destination.EnableHttp2 = nil
	}

	// Etag
	destination.Etag = genruntime.ClonePointerToString(embedded.Etag)

	// FirewallPolicy
	if embedded.FirewallPolicy != nil {
		var firewallPolicy storage.SubResource_STATUS
		err := embedded.FirewallPolicy.AssignProperties_To_SubResource_STATUS(&firewallPolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field FirewallPolicy")
		}
		destination.FirewallPolicy = &firewallPolicy
	} else {
		destination.FirewallPolicy = nil
	}

	// ForceFirewallPolicyAssociation
	if embedded.ForceFirewallPolicyAssociation != nil {
		forceFirewallPolicyAssociation := *embedded.ForceFirewallPolicyAssociation
		destination.ForceFirewallPolicyAssociation = &forceFirewallPolicyAssociation
	} else {
		destination.ForceFirewallPolicyAssociation = nil
	}

	// FrontendIPConfigurations
	if embedded.FrontendIPConfigurations != nil {
		frontendIPConfigurationList := make([]storage.ApplicationGatewayFrontendIPConfiguration_STATUS, len(embedded.FrontendIPConfigurations))
		for frontendIPConfigurationIndex, frontendIPConfigurationItem := range embedded.FrontendIPConfigurations {
			// Shadow the loop variable to avoid aliasing
			frontendIPConfigurationItem := frontendIPConfigurationItem
			var frontendIPConfiguration storage.ApplicationGatewayFrontendIPConfiguration_STATUS
			err := frontendIPConfigurationItem.AssignProperties_To_ApplicationGatewayFrontendIPConfiguration_STATUS(&frontendIPConfiguration)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ApplicationGatewayFrontendIPConfiguration_STATUS() to populate field FrontendIPConfigurations")
			}
			frontendIPConfigurationList[frontendIPConfigurationIndex] = frontendIPConfiguration
		}
		destination.FrontendIPConfigurations = frontendIPConfigurationList
	} else {
		destination.FrontendIPConfigurations = nil
	}

	// FrontendPorts
	if embedded.FrontendPorts != nil {
		frontendPortList := make([]storage.ApplicationGatewayFrontendPort_STATUS, len(embedded.FrontendPorts))
		for frontendPortIndex, frontendPortItem := range embedded.FrontendPorts {
			// Shadow the loop variable to avoid aliasing
			frontendPortItem := frontendPortItem
			var frontendPort storage.ApplicationGatewayFrontendPort_STATUS
			err := frontendPortItem.AssignProperties_To_ApplicationGatewayFrontendPort_STATUS(&frontendPort)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ApplicationGatewayFrontendPort_STATUS() to populate field FrontendPorts")
			}
			frontendPortList[frontendPortIndex] = frontendPort
		}
		destination.FrontendPorts = frontendPortList
	} else {
		destination.FrontendPorts = nil
	}

	// GatewayIPConfigurations
	if embedded.GatewayIPConfigurations != nil {
		gatewayIPConfigurationList := make([]storage.ApplicationGatewayIPConfiguration_STATUS_ApplicationGateway_SubResourceEmbedded, len(embedded.GatewayIPConfigurations))
		for gatewayIPConfigurationIndex, gatewayIPConfigurationItem := range embedded.GatewayIPConfigurations {
			// Shadow the loop variable to avoid aliasing
			gatewayIPConfigurationItem := gatewayIPConfigurationItem
			var gatewayIPConfiguration storage.ApplicationGatewayIPConfiguration_STATUS_ApplicationGateway_SubResourceEmbedded
			err := gatewayIPConfigurationItem.AssignProperties_To_ApplicationGatewayIPConfiguration_STATUS_ApplicationGateway_SubResourceEmbedded(&gatewayIPConfiguration)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ApplicationGatewayIPConfiguration_STATUS_ApplicationGateway_SubResourceEmbedded() to populate field GatewayIPConfigurations")
			}
			gatewayIPConfigurationList[gatewayIPConfigurationIndex] = gatewayIPConfiguration
		}
		destination.GatewayIPConfigurations = gatewayIPConfigurationList
	} else {
		destination.GatewayIPConfigurations = nil
	}

	// GlobalConfiguration
	if embedded.GlobalConfiguration != nil {
		var globalConfiguration storage.ApplicationGatewayGlobalConfiguration_STATUS
		err := embedded.GlobalConfiguration.AssignProperties_To_ApplicationGatewayGlobalConfiguration_STATUS(&globalConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ApplicationGatewayGlobalConfiguration_STATUS() to populate field GlobalConfiguration")
		}
		destination.GlobalConfiguration = &globalConfiguration
	} else {
		destination.GlobalConfiguration = nil
	}

	// HttpListeners
	if embedded.HttpListeners != nil {
		httpListenerList := make([]storage.ApplicationGatewayHttpListener_STATUS, len(embedded.HttpListeners))
		for httpListenerIndex, httpListenerItem := range embedded.HttpListeners {
			// Shadow the loop variable to avoid aliasing
			httpListenerItem := httpListenerItem
			var httpListener storage.ApplicationGatewayHttpListener_STATUS
			err := httpListenerItem.AssignProperties_To_ApplicationGatewayHttpListener_STATUS(&httpListener)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ApplicationGatewayHttpListener_STATUS() to populate field HttpListeners")
			}
			httpListenerList[httpListenerIndex] = httpListener
		}
		destination.HttpListeners = httpListenerList
	} else {
		destination.HttpListeners = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(embedded.Id)

	// Identity
	if embedded.Identity != nil {
		var identity storage.ManagedServiceIdentity_STATUS
		err := embedded.Identity.AssignProperties_To_ManagedServiceIdentity_STATUS(&identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedServiceIdentity_STATUS() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// Listeners
	if embedded.Listeners != nil {
		listenerList := make([]storage.ApplicationGatewayListener_STATUS, len(embedded.Listeners))
		for listenerIndex, listenerItem := range embedded.Listeners {
			// Shadow the loop variable to avoid aliasing
			listenerItem := listenerItem
			var listener storage.ApplicationGatewayListener_STATUS
			err := listenerItem.AssignProperties_To_ApplicationGatewayListener_STATUS(&listener)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ApplicationGatewayListener_STATUS() to populate field Listeners")
			}
			listenerList[listenerIndex] = listener
		}
		destination.Listeners = listenerList
	} else {
		destination.Listeners = nil
	}

	// LoadDistributionPolicies
	if embedded.LoadDistributionPolicies != nil {
		loadDistributionPolicyList := make([]storage.ApplicationGatewayLoadDistributionPolicy_STATUS, len(embedded.LoadDistributionPolicies))
		for loadDistributionPolicyIndex, loadDistributionPolicyItem := range embedded.LoadDistributionPolicies {
			// Shadow the loop variable to avoid aliasing
			loadDistributionPolicyItem := loadDistributionPolicyItem
			var loadDistributionPolicy storage.ApplicationGatewayLoadDistributionPolicy_STATUS
			err := loadDistributionPolicyItem.AssignProperties_To_ApplicationGatewayLoadDistributionPolicy_STATUS(&loadDistributionPolicy)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ApplicationGatewayLoadDistributionPolicy_STATUS() to populate field LoadDistributionPolicies")
			}
			loadDistributionPolicyList[loadDistributionPolicyIndex] = loadDistributionPolicy
		}
		destination.LoadDistributionPolicies = loadDistributionPolicyList
	} else {
		destination.LoadDistributionPolicies = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(embedded.Location)

	// Name
	destination.Name = genruntime.ClonePointerToString(embedded.Name)

	// OperationalState
	if embedded.OperationalState != nil {
		operationalState := string(*embedded.OperationalState)
		destination.OperationalState = &operationalState
	} else {
		destination.OperationalState = nil
	}

	// PrivateEndpointConnections
	if embedded.PrivateEndpointConnections != nil {
		privateEndpointConnectionList := make([]storage.ApplicationGatewayPrivateEndpointConnection_STATUS, len(embedded.PrivateEndpointConnections))
		for privateEndpointConnectionIndex, privateEndpointConnectionItem := range embedded.PrivateEndpointConnections {
			// Shadow the loop variable to avoid aliasing
			privateEndpointConnectionItem := privateEndpointConnectionItem
			var privateEndpointConnection storage.ApplicationGatewayPrivateEndpointConnection_STATUS
			err := privateEndpointConnectionItem.AssignProperties_To_ApplicationGatewayPrivateEndpointConnection_STATUS(&privateEndpointConnection)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ApplicationGatewayPrivateEndpointConnection_STATUS() to populate field PrivateEndpointConnections")
			}
			privateEndpointConnectionList[privateEndpointConnectionIndex] = privateEndpointConnection
		}
		destination.PrivateEndpointConnections = privateEndpointConnectionList
	} else {
		destination.PrivateEndpointConnections = nil
	}

	// PrivateLinkConfigurations
	if embedded.PrivateLinkConfigurations != nil {
		privateLinkConfigurationList := make([]storage.ApplicationGatewayPrivateLinkConfiguration_STATUS, len(embedded.PrivateLinkConfigurations))
		for privateLinkConfigurationIndex, privateLinkConfigurationItem := range embedded.PrivateLinkConfigurations {
			// Shadow the loop variable to avoid aliasing
			privateLinkConfigurationItem := privateLinkConfigurationItem
			var privateLinkConfiguration storage.ApplicationGatewayPrivateLinkConfiguration_STATUS
			err := privateLinkConfigurationItem.AssignProperties_To_ApplicationGatewayPrivateLinkConfiguration_STATUS(&privateLinkConfiguration)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ApplicationGatewayPrivateLinkConfiguration_STATUS() to populate field PrivateLinkConfigurations")
			}
			privateLinkConfigurationList[privateLinkConfigurationIndex] = privateLinkConfiguration
		}
		destination.PrivateLinkConfigurations = privateLinkConfigurationList
	} else {
		destination.PrivateLinkConfigurations = nil
	}

	// Probes
	if embedded.Probes != nil {
		probeList := make([]storage.ApplicationGatewayProbe_STATUS, len(embedded.Probes))
		for probeIndex, probeItem := range embedded.Probes {
			// Shadow the loop variable to avoid aliasing
			probeItem := probeItem
			var probe storage.ApplicationGatewayProbe_STATUS
			err := probeItem.AssignProperties_To_ApplicationGatewayProbe_STATUS(&probe)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ApplicationGatewayProbe_STATUS() to populate field Probes")
			}
			probeList[probeIndex] = probe
		}
		destination.Probes = probeList
	} else {
		destination.Probes = nil
	}

	// ProvisioningState
	if embedded.ProvisioningState != nil {
		provisioningState := string(*embedded.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// RedirectConfigurations
	if embedded.RedirectConfigurations != nil {
		redirectConfigurationList := make([]storage.ApplicationGatewayRedirectConfiguration_STATUS, len(embedded.RedirectConfigurations))
		for redirectConfigurationIndex, redirectConfigurationItem := range embedded.RedirectConfigurations {
			// Shadow the loop variable to avoid aliasing
			redirectConfigurationItem := redirectConfigurationItem
			var redirectConfiguration storage.ApplicationGatewayRedirectConfiguration_STATUS
			err := redirectConfigurationItem.AssignProperties_To_ApplicationGatewayRedirectConfiguration_STATUS(&redirectConfiguration)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ApplicationGatewayRedirectConfiguration_STATUS() to populate field RedirectConfigurations")
			}
			redirectConfigurationList[redirectConfigurationIndex] = redirectConfiguration
		}
		destination.RedirectConfigurations = redirectConfigurationList
	} else {
		destination.RedirectConfigurations = nil
	}

	// RequestRoutingRules
	if embedded.RequestRoutingRules != nil {
		requestRoutingRuleList := make([]storage.ApplicationGatewayRequestRoutingRule_STATUS, len(embedded.RequestRoutingRules))
		for requestRoutingRuleIndex, requestRoutingRuleItem := range embedded.RequestRoutingRules {
			// Shadow the loop variable to avoid aliasing
			requestRoutingRuleItem := requestRoutingRuleItem
			var requestRoutingRule storage.ApplicationGatewayRequestRoutingRule_STATUS
			err := requestRoutingRuleItem.AssignProperties_To_ApplicationGatewayRequestRoutingRule_STATUS(&requestRoutingRule)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ApplicationGatewayRequestRoutingRule_STATUS() to populate field RequestRoutingRules")
			}
			requestRoutingRuleList[requestRoutingRuleIndex] = requestRoutingRule
		}
		destination.RequestRoutingRules = requestRoutingRuleList
	} else {
		destination.RequestRoutingRules = nil
	}

	// ResourceGuid
	destination.ResourceGuid = genruntime.ClonePointerToString(embedded.ResourceGuid)

	// RewriteRuleSets
	if embedded.RewriteRuleSets != nil {
		rewriteRuleSetList := make([]storage.ApplicationGatewayRewriteRuleSet_STATUS, len(embedded.RewriteRuleSets))
		for rewriteRuleSetIndex, rewriteRuleSetItem := range embedded.RewriteRuleSets {
			// Shadow the loop variable to avoid aliasing
			rewriteRuleSetItem := rewriteRuleSetItem
			var rewriteRuleSet storage.ApplicationGatewayRewriteRuleSet_STATUS
			err := rewriteRuleSetItem.AssignProperties_To_ApplicationGatewayRewriteRuleSet_STATUS(&rewriteRuleSet)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ApplicationGatewayRewriteRuleSet_STATUS() to populate field RewriteRuleSets")
			}
			rewriteRuleSetList[rewriteRuleSetIndex] = rewriteRuleSet
		}
		destination.RewriteRuleSets = rewriteRuleSetList
	} else {
		destination.RewriteRuleSets = nil
	}

	// RoutingRules
	if embedded.RoutingRules != nil {
		routingRuleList := make([]storage.ApplicationGatewayRoutingRule_STATUS, len(embedded.RoutingRules))
		for routingRuleIndex, routingRuleItem := range embedded.RoutingRules {
			// Shadow the loop variable to avoid aliasing
			routingRuleItem := routingRuleItem
			var routingRule storage.ApplicationGatewayRoutingRule_STATUS
			err := routingRuleItem.AssignProperties_To_ApplicationGatewayRoutingRule_STATUS(&routingRule)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ApplicationGatewayRoutingRule_STATUS() to populate field RoutingRules")
			}
			routingRuleList[routingRuleIndex] = routingRule
		}
		destination.RoutingRules = routingRuleList
	} else {
		destination.RoutingRules = nil
	}

	// Sku
	if embedded.Sku != nil {
		var sku storage.ApplicationGatewaySku_STATUS
		err := embedded.Sku.AssignProperties_To_ApplicationGatewaySku_STATUS(&sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ApplicationGatewaySku_STATUS() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// SslCertificates
	if embedded.SslCertificates != nil {
		sslCertificateList := make([]storage.ApplicationGatewaySslCertificate_STATUS, len(embedded.SslCertificates))
		for sslCertificateIndex, sslCertificateItem := range embedded.SslCertificates {
			// Shadow the loop variable to avoid aliasing
			sslCertificateItem := sslCertificateItem
			var sslCertificate storage.ApplicationGatewaySslCertificate_STATUS
			err := sslCertificateItem.AssignProperties_To_ApplicationGatewaySslCertificate_STATUS(&sslCertificate)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ApplicationGatewaySslCertificate_STATUS() to populate field SslCertificates")
			}
			sslCertificateList[sslCertificateIndex] = sslCertificate
		}
		destination.SslCertificates = sslCertificateList
	} else {
		destination.SslCertificates = nil
	}

	// SslPolicy
	if embedded.SslPolicy != nil {
		var sslPolicy storage.ApplicationGatewaySslPolicy_STATUS
		err := embedded.SslPolicy.AssignProperties_To_ApplicationGatewaySslPolicy_STATUS(&sslPolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ApplicationGatewaySslPolicy_STATUS() to populate field SslPolicy")
		}
		destination.SslPolicy = &sslPolicy
	} else {
		destination.SslPolicy = nil
	}

	// SslProfiles
	if embedded.SslProfiles != nil {
		sslProfileList := make([]storage.ApplicationGatewaySslProfile_STATUS, len(embedded.SslProfiles))
		for sslProfileIndex, sslProfileItem := range embedded.SslProfiles {
			// Shadow the loop variable to avoid aliasing
			sslProfileItem := sslProfileItem
			var sslProfile storage.ApplicationGatewaySslProfile_STATUS
			err := sslProfileItem.AssignProperties_To_ApplicationGatewaySslProfile_STATUS(&sslProfile)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ApplicationGatewaySslProfile_STATUS() to populate field SslProfiles")
			}
			sslProfileList[sslProfileIndex] = sslProfile
		}
		destination.SslProfiles = sslProfileList
	} else {
		destination.SslProfiles = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(embedded.Tags)

	// TrustedClientCertificates
	if embedded.TrustedClientCertificates != nil {
		trustedClientCertificateList := make([]storage.ApplicationGatewayTrustedClientCertificate_STATUS, len(embedded.TrustedClientCertificates))
		for trustedClientCertificateIndex, trustedClientCertificateItem := range embedded.TrustedClientCertificates {
			// Shadow the loop variable to avoid aliasing
			trustedClientCertificateItem := trustedClientCertificateItem
			var trustedClientCertificate storage.ApplicationGatewayTrustedClientCertificate_STATUS
			err := trustedClientCertificateItem.AssignProperties_To_ApplicationGatewayTrustedClientCertificate_STATUS(&trustedClientCertificate)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ApplicationGatewayTrustedClientCertificate_STATUS() to populate field TrustedClientCertificates")
			}
			trustedClientCertificateList[trustedClientCertificateIndex] = trustedClientCertificate
		}
		destination.TrustedClientCertificates = trustedClientCertificateList
	} else {
		destination.TrustedClientCertificates = nil
	}

	// TrustedRootCertificates
	if embedded.TrustedRootCertificates != nil {
		trustedRootCertificateList := make([]storage.ApplicationGatewayTrustedRootCertificate_STATUS, len(embedded.TrustedRootCertificates))
		for trustedRootCertificateIndex, trustedRootCertificateItem := range embedded.TrustedRootCertificates {
			// Shadow the loop variable to avoid aliasing
			trustedRootCertificateItem := trustedRootCertificateItem
			var trustedRootCertificate storage.ApplicationGatewayTrustedRootCertificate_STATUS
			err := trustedRootCertificateItem.AssignProperties_To_ApplicationGatewayTrustedRootCertificate_STATUS(&trustedRootCertificate)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ApplicationGatewayTrustedRootCertificate_STATUS() to populate field TrustedRootCertificates")
			}
			trustedRootCertificateList[trustedRootCertificateIndex] = trustedRootCertificate
		}
		destination.TrustedRootCertificates = trustedRootCertificateList
	} else {
		destination.TrustedRootCertificates = nil
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(embedded.Type)

	// UrlPathMaps
	if embedded.UrlPathMaps != nil {
		urlPathMapList := make([]storage.ApplicationGatewayUrlPathMap_STATUS, len(embedded.UrlPathMaps))
		for urlPathMapIndex, urlPathMapItem := range embedded.UrlPathMaps {
			// Shadow the loop variable to avoid aliasing
			urlPathMapItem := urlPathMapItem
			var urlPathMap storage.ApplicationGatewayUrlPathMap_STATUS
			err := urlPathMapItem.AssignProperties_To_ApplicationGatewayUrlPathMap_STATUS(&urlPathMap)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ApplicationGatewayUrlPathMap_STATUS() to populate field UrlPathMaps")
			}
			urlPathMapList[urlPathMapIndex] = urlPathMap
		}
		destination.UrlPathMaps = urlPathMapList
	} else {
		destination.UrlPathMaps = nil
	}

	// WebApplicationFirewallConfiguration
	if embedded.WebApplicationFirewallConfiguration != nil {
		var webApplicationFirewallConfiguration storage.ApplicationGatewayWebApplicationFirewallConfiguration_STATUS
		err := embedded.WebApplicationFirewallConfiguration.AssignProperties_To_ApplicationGatewayWebApplicationFirewallConfiguration_STATUS(&webApplicationFirewallConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ApplicationGatewayWebApplicationFirewallConfiguration_STATUS() to populate field WebApplicationFirewallConfiguration")
		}
		destination.WebApplicationFirewallConfiguration = &webApplicationFirewallConfiguration
	} else {
		destination.WebApplicationFirewallConfiguration = nil
	}

	// Zones
	destination.Zones = genruntime.CloneSliceOfString(embedded.Zones)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Authentication certificates of an application gateway.
type ApplicationGatewayAuthenticationCertificate struct {
	// Data: Certificate public data.
	Data *genruntime.SecretReference `json:"data,omitempty"`

	// Name: Name of the authentication certificate that is unique within an Application Gateway.
	Name *string `json:"name,omitempty"`
}

var _ genruntime.ARMTransformer = &ApplicationGatewayAuthenticationCertificate{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (certificate *ApplicationGatewayAuthenticationCertificate) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if certificate == nil {
		return nil, nil
	}
	result := &arm.ApplicationGatewayAuthenticationCertificate{}

	// Set property "Name":
	if certificate.Name != nil {
		name := *certificate.Name
		result.Name = &name
	}

	// Set property "Properties":
	if certificate.Data != nil {
		result.Properties = &arm.ApplicationGatewayAuthenticationCertificatePropertiesFormat{}
	}
	if certificate.Data != nil {
		dataSecret, err := resolved.ResolvedSecrets.Lookup(*certificate.Data)
		if err != nil {
			return nil, errors.Wrap(err, "looking up secret for property Data")
		}
		data := dataSecret
		result.Properties.Data = &data
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (certificate *ApplicationGatewayAuthenticationCertificate) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApplicationGatewayAuthenticationCertificate{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (certificate *ApplicationGatewayAuthenticationCertificate) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApplicationGatewayAuthenticationCertificate)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApplicationGatewayAuthenticationCertificate, got %T", armInput)
	}

	// no assignment for property "Data"

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		certificate.Name = &name
	}

	// No error
	return nil
}

// AssignProperties_From_ApplicationGatewayAuthenticationCertificate populates our ApplicationGatewayAuthenticationCertificate from the provided source ApplicationGatewayAuthenticationCertificate
func (certificate *ApplicationGatewayAuthenticationCertificate) AssignProperties_From_ApplicationGatewayAuthenticationCertificate(source *storage.ApplicationGatewayAuthenticationCertificate) error {

	// Data
	if source.Data != nil {
		datum := source.Data.Copy()
		certificate.Data = &datum
	} else {
		certificate.Data = nil
	}

	// Name
	certificate.Name = genruntime.ClonePointerToString(source.Name)

	// No error
	return nil
}

// AssignProperties_To_ApplicationGatewayAuthenticationCertificate populates the provided destination ApplicationGatewayAuthenticationCertificate from our ApplicationGatewayAuthenticationCertificate
func (certificate *ApplicationGatewayAuthenticationCertificate) AssignProperties_To_ApplicationGatewayAuthenticationCertificate(destination *storage.ApplicationGatewayAuthenticationCertificate) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Data
	if certificate.Data != nil {
		datum := certificate.Data.Copy()
		destination.Data = &datum
	} else {
		destination.Data = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(certificate.Name)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ApplicationGatewayAuthenticationCertificate_STATUS populates our ApplicationGatewayAuthenticationCertificate from the provided source ApplicationGatewayAuthenticationCertificate_STATUS
func (certificate *ApplicationGatewayAuthenticationCertificate) Initialize_From_ApplicationGatewayAuthenticationCertificate_STATUS(source *ApplicationGatewayAuthenticationCertificate_STATUS) error {

	// No error
	return nil
}

// Authentication certificates of an application gateway.
type ApplicationGatewayAuthenticationCertificate_STATUS struct {
	// Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &ApplicationGatewayAuthenticationCertificate_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (certificate *ApplicationGatewayAuthenticationCertificate_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApplicationGatewayAuthenticationCertificate_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (certificate *ApplicationGatewayAuthenticationCertificate_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApplicationGatewayAuthenticationCertificate_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApplicationGatewayAuthenticationCertificate_STATUS, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		certificate.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_ApplicationGatewayAuthenticationCertificate_STATUS populates our ApplicationGatewayAuthenticationCertificate_STATUS from the provided source ApplicationGatewayAuthenticationCertificate_STATUS
func (certificate *ApplicationGatewayAuthenticationCertificate_STATUS) AssignProperties_From_ApplicationGatewayAuthenticationCertificate_STATUS(source *storage.ApplicationGatewayAuthenticationCertificate_STATUS) error {

	// Id
	certificate.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_ApplicationGatewayAuthenticationCertificate_STATUS populates the provided destination ApplicationGatewayAuthenticationCertificate_STATUS from our ApplicationGatewayAuthenticationCertificate_STATUS
func (certificate *ApplicationGatewayAuthenticationCertificate_STATUS) AssignProperties_To_ApplicationGatewayAuthenticationCertificate_STATUS(destination *storage.ApplicationGatewayAuthenticationCertificate_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(certificate.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Application Gateway autoscale configuration.
type ApplicationGatewayAutoscaleConfiguration struct {
	// +kubebuilder:validation:Minimum=2
	// MaxCapacity: Upper bound on number of Application Gateway capacity.
	MaxCapacity *int `json:"maxCapacity,omitempty"`

	// +kubebuilder:validation:Required
	// +kubebuilder:validation:Minimum=0
	// MinCapacity: Lower bound on number of Application Gateway capacity.
	MinCapacity *int `json:"minCapacity,omitempty"`
}

var _ genruntime.ARMTransformer = &ApplicationGatewayAutoscaleConfiguration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (configuration *ApplicationGatewayAutoscaleConfiguration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if configuration == nil {
		return nil, nil
	}
	result := &arm.ApplicationGatewayAutoscaleConfiguration{}

	// Set property "MaxCapacity":
	if configuration.MaxCapacity != nil {
		maxCapacity := *configuration.MaxCapacity
		result.MaxCapacity = &maxCapacity
	}

	// Set property "MinCapacity":
	if configuration.MinCapacity != nil {
		minCapacity := *configuration.MinCapacity
		result.MinCapacity = &minCapacity
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *ApplicationGatewayAutoscaleConfiguration) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApplicationGatewayAutoscaleConfiguration{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *ApplicationGatewayAutoscaleConfiguration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApplicationGatewayAutoscaleConfiguration)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApplicationGatewayAutoscaleConfiguration, got %T", armInput)
	}

	// Set property "MaxCapacity":
	if typedInput.MaxCapacity != nil {
		maxCapacity := *typedInput.MaxCapacity
		configuration.MaxCapacity = &maxCapacity
	}

	// Set property "MinCapacity":
	if typedInput.MinCapacity != nil {
		minCapacity := *typedInput.MinCapacity
		configuration.MinCapacity = &minCapacity
	}

	// No error
	return nil
}

// AssignProperties_From_ApplicationGatewayAutoscaleConfiguration populates our ApplicationGatewayAutoscaleConfiguration from the provided source ApplicationGatewayAutoscaleConfiguration
func (configuration *ApplicationGatewayAutoscaleConfiguration) AssignProperties_From_ApplicationGatewayAutoscaleConfiguration(source *storage.ApplicationGatewayAutoscaleConfiguration) error {

	// MaxCapacity
	if source.MaxCapacity != nil {
		maxCapacity := *source.MaxCapacity
		configuration.MaxCapacity = &maxCapacity
	} else {
		configuration.MaxCapacity = nil
	}

	// MinCapacity
	if source.MinCapacity != nil {
		minCapacity := *source.MinCapacity
		configuration.MinCapacity = &minCapacity
	} else {
		configuration.MinCapacity = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ApplicationGatewayAutoscaleConfiguration populates the provided destination ApplicationGatewayAutoscaleConfiguration from our ApplicationGatewayAutoscaleConfiguration
func (configuration *ApplicationGatewayAutoscaleConfiguration) AssignProperties_To_ApplicationGatewayAutoscaleConfiguration(destination *storage.ApplicationGatewayAutoscaleConfiguration) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MaxCapacity
	if configuration.MaxCapacity != nil {
		maxCapacity := *configuration.MaxCapacity
		destination.MaxCapacity = &maxCapacity
	} else {
		destination.MaxCapacity = nil
	}

	// MinCapacity
	if configuration.MinCapacity != nil {
		minCapacity := *configuration.MinCapacity
		destination.MinCapacity = &minCapacity
	} else {
		destination.MinCapacity = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ApplicationGatewayAutoscaleConfiguration_STATUS populates our ApplicationGatewayAutoscaleConfiguration from the provided source ApplicationGatewayAutoscaleConfiguration_STATUS
func (configuration *ApplicationGatewayAutoscaleConfiguration) Initialize_From_ApplicationGatewayAutoscaleConfiguration_STATUS(source *ApplicationGatewayAutoscaleConfiguration_STATUS) error {

	// MaxCapacity
	if source.MaxCapacity != nil {
		maxCapacity := *source.MaxCapacity
		configuration.MaxCapacity = &maxCapacity
	} else {
		configuration.MaxCapacity = nil
	}

	// MinCapacity
	if source.MinCapacity != nil {
		minCapacity := *source.MinCapacity
		configuration.MinCapacity = &minCapacity
	} else {
		configuration.MinCapacity = nil
	}

	// No error
	return nil
}

// Application Gateway autoscale configuration.
type ApplicationGatewayAutoscaleConfiguration_STATUS struct {
	// MaxCapacity: Upper bound on number of Application Gateway capacity.
	MaxCapacity *int `json:"maxCapacity,omitempty"`

	// MinCapacity: Lower bound on number of Application Gateway capacity.
	MinCapacity *int `json:"minCapacity,omitempty"`
}

var _ genruntime.FromARMConverter = &ApplicationGatewayAutoscaleConfiguration_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *ApplicationGatewayAutoscaleConfiguration_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApplicationGatewayAutoscaleConfiguration_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *ApplicationGatewayAutoscaleConfiguration_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApplicationGatewayAutoscaleConfiguration_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApplicationGatewayAutoscaleConfiguration_STATUS, got %T", armInput)
	}

	// Set property "MaxCapacity":
	if typedInput.MaxCapacity != nil {
		maxCapacity := *typedInput.MaxCapacity
		configuration.MaxCapacity = &maxCapacity
	}

	// Set property "MinCapacity":
	if typedInput.MinCapacity != nil {
		minCapacity := *typedInput.MinCapacity
		configuration.MinCapacity = &minCapacity
	}

	// No error
	return nil
}

// AssignProperties_From_ApplicationGatewayAutoscaleConfiguration_STATUS populates our ApplicationGatewayAutoscaleConfiguration_STATUS from the provided source ApplicationGatewayAutoscaleConfiguration_STATUS
func (configuration *ApplicationGatewayAutoscaleConfiguration_STATUS) AssignProperties_From_ApplicationGatewayAutoscaleConfiguration_STATUS(source *storage.ApplicationGatewayAutoscaleConfiguration_STATUS) error {

	// MaxCapacity
	configuration.MaxCapacity = genruntime.ClonePointerToInt(source.MaxCapacity)

	// MinCapacity
	configuration.MinCapacity = genruntime.ClonePointerToInt(source.MinCapacity)

	// No error
	return nil
}

// AssignProperties_To_ApplicationGatewayAutoscaleConfiguration_STATUS populates the provided destination ApplicationGatewayAutoscaleConfiguration_STATUS from our ApplicationGatewayAutoscaleConfiguration_STATUS
func (configuration *ApplicationGatewayAutoscaleConfiguration_STATUS) AssignProperties_To_ApplicationGatewayAutoscaleConfiguration_STATUS(destination *storage.ApplicationGatewayAutoscaleConfiguration_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MaxCapacity
	destination.MaxCapacity = genruntime.ClonePointerToInt(configuration.MaxCapacity)

	// MinCapacity
	destination.MinCapacity = genruntime.ClonePointerToInt(configuration.MinCapacity)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Backend Address Pool of an application gateway.
type ApplicationGatewayBackendAddressPool struct {
	// BackendAddresses: Backend addresses.
	BackendAddresses []ApplicationGatewayBackendAddress `json:"backendAddresses,omitempty"`

	// Name: Name of the backend address pool that is unique within an Application Gateway.
	Name *string `json:"name,omitempty"`
}

var _ genruntime.ARMTransformer = &ApplicationGatewayBackendAddressPool{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (pool *ApplicationGatewayBackendAddressPool) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if pool == nil {
		return nil, nil
	}
	result := &arm.ApplicationGatewayBackendAddressPool{}

	// Set property "Name":
	if pool.Name != nil {
		name := *pool.Name
		result.Name = &name
	}

	// Set property "Properties":
	if pool.BackendAddresses != nil {
		result.Properties = &arm.ApplicationGatewayBackendAddressPoolPropertiesFormat{}
	}
	for _, item := range pool.BackendAddresses {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.BackendAddresses = append(result.Properties.BackendAddresses, *item_ARM.(*arm.ApplicationGatewayBackendAddress))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (pool *ApplicationGatewayBackendAddressPool) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApplicationGatewayBackendAddressPool{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (pool *ApplicationGatewayBackendAddressPool) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApplicationGatewayBackendAddressPool)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApplicationGatewayBackendAddressPool, got %T", armInput)
	}

	// Set property "BackendAddresses":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.BackendAddresses {
			var item1 ApplicationGatewayBackendAddress
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			pool.BackendAddresses = append(pool.BackendAddresses, item1)
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		pool.Name = &name
	}

	// No error
	return nil
}

// AssignProperties_From_ApplicationGatewayBackendAddressPool populates our ApplicationGatewayBackendAddressPool from the provided source ApplicationGatewayBackendAddressPool
func (pool *ApplicationGatewayBackendAddressPool) AssignProperties_From_ApplicationGatewayBackendAddressPool(source *storage.ApplicationGatewayBackendAddressPool) error {

	// BackendAddresses
	if source.BackendAddresses != nil {
		backendAddressList := make([]ApplicationGatewayBackendAddress, len(source.BackendAddresses))
		for backendAddressIndex, backendAddressItem := range source.BackendAddresses {
			// Shadow the loop variable to avoid aliasing
			backendAddressItem := backendAddressItem
			var backendAddress ApplicationGatewayBackendAddress
			err := backendAddress.AssignProperties_From_ApplicationGatewayBackendAddress(&backendAddressItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ApplicationGatewayBackendAddress() to populate field BackendAddresses")
			}
			backendAddressList[backendAddressIndex] = backendAddress
		}
		pool.BackendAddresses = backendAddressList
	} else {
		pool.BackendAddresses = nil
	}

	// Name
	pool.Name = genruntime.ClonePointerToString(source.Name)

	// No error
	return nil
}

// AssignProperties_To_ApplicationGatewayBackendAddressPool populates the provided destination ApplicationGatewayBackendAddressPool from our ApplicationGatewayBackendAddressPool
func (pool *ApplicationGatewayBackendAddressPool) AssignProperties_To_ApplicationGatewayBackendAddressPool(destination *storage.ApplicationGatewayBackendAddressPool) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BackendAddresses
	if pool.BackendAddresses != nil {
		backendAddressList := make([]storage.ApplicationGatewayBackendAddress, len(pool.BackendAddresses))
		for backendAddressIndex, backendAddressItem := range pool.BackendAddresses {
			// Shadow the loop variable to avoid aliasing
			backendAddressItem := backendAddressItem
			var backendAddress storage.ApplicationGatewayBackendAddress
			err := backendAddressItem.AssignProperties_To_ApplicationGatewayBackendAddress(&backendAddress)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ApplicationGatewayBackendAddress() to populate field BackendAddresses")
			}
			backendAddressList[backendAddressIndex] = backendAddress
		}
		destination.BackendAddresses = backendAddressList
	} else {
		destination.BackendAddresses = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(pool.Name)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ApplicationGatewayBackendAddressPool_STATUS populates our ApplicationGatewayBackendAddressPool from the provided source ApplicationGatewayBackendAddressPool_STATUS
func (pool *ApplicationGatewayBackendAddressPool) Initialize_From_ApplicationGatewayBackendAddressPool_STATUS(source *ApplicationGatewayBackendAddressPool_STATUS) error {

	// No error
	return nil
}

// Backend Address Pool of an application gateway.
type ApplicationGatewayBackendAddressPool_STATUS struct {
	// Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &ApplicationGatewayBackendAddressPool_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (pool *ApplicationGatewayBackendAddressPool_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApplicationGatewayBackendAddressPool_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (pool *ApplicationGatewayBackendAddressPool_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApplicationGatewayBackendAddressPool_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApplicationGatewayBackendAddressPool_STATUS, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		pool.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_ApplicationGatewayBackendAddressPool_STATUS populates our ApplicationGatewayBackendAddressPool_STATUS from the provided source ApplicationGatewayBackendAddressPool_STATUS
func (pool *ApplicationGatewayBackendAddressPool_STATUS) AssignProperties_From_ApplicationGatewayBackendAddressPool_STATUS(source *storage.ApplicationGatewayBackendAddressPool_STATUS) error {

	// Id
	pool.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_ApplicationGatewayBackendAddressPool_STATUS populates the provided destination ApplicationGatewayBackendAddressPool_STATUS from our ApplicationGatewayBackendAddressPool_STATUS
func (pool *ApplicationGatewayBackendAddressPool_STATUS) AssignProperties_To_ApplicationGatewayBackendAddressPool_STATUS(destination *storage.ApplicationGatewayBackendAddressPool_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(pool.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Backend address pool settings of an application gateway.
type ApplicationGatewayBackendHttpSettings struct {
	// AffinityCookieName: Cookie name to use for the affinity cookie.
	AffinityCookieName *string `json:"affinityCookieName,omitempty"`

	// AuthenticationCertificates: Array of references to application gateway authentication certificates.
	AuthenticationCertificates []SubResource `json:"authenticationCertificates,omitempty"`

	// ConnectionDraining: Connection draining of the backend http settings resource.
	ConnectionDraining *ApplicationGatewayConnectionDraining `json:"connectionDraining,omitempty"`

	// CookieBasedAffinity: Cookie based affinity.
	CookieBasedAffinity *ApplicationGatewayBackendHttpSettingsPropertiesFormat_CookieBasedAffinity `json:"cookieBasedAffinity,omitempty"`

	// HostName: Host header to be sent to the backend servers.
	HostName *string `json:"hostName,omitempty"`

	// Name: Name of the backend http settings that is unique within an Application Gateway.
	Name *string `json:"name,omitempty"`

	// Path: Path which should be used as a prefix for all HTTP requests. Null means no path will be prefixed. Default value is
	// null.
	Path *string `json:"path,omitempty"`

	// PickHostNameFromBackendAddress: Whether to pick host header should be picked from the host name of the backend server.
	// Default value is false.
	PickHostNameFromBackendAddress *bool `json:"pickHostNameFromBackendAddress,omitempty"`

	// Port: The destination port on the backend.
	Port *int `json:"port,omitempty"`

	// Probe: Probe resource of an application gateway.
	Probe *SubResource `json:"probe,omitempty"`

	// ProbeEnabled: Whether the probe is enabled. Default value is false.
	ProbeEnabled *bool `json:"probeEnabled,omitempty"`

	// Protocol: The protocol used to communicate with the backend.
	Protocol *ApplicationGatewayProtocol `json:"protocol,omitempty"`

	// RequestTimeout: Request timeout in seconds. Application Gateway will fail the request if response is not received within
	// RequestTimeout. Acceptable values are from 1 second to 86400 seconds.
	RequestTimeout *int `json:"requestTimeout,omitempty"`

	// TrustedRootCertificates: Array of references to application gateway trusted root certificates.
	TrustedRootCertificates []SubResource `json:"trustedRootCertificates,omitempty"`
}

var _ genruntime.ARMTransformer = &ApplicationGatewayBackendHttpSettings{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (settings *ApplicationGatewayBackendHttpSettings) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if settings == nil {
		return nil, nil
	}
	result := &arm.ApplicationGatewayBackendHttpSettings{}

	// Set property "Name":
	if settings.Name != nil {
		name := *settings.Name
		result.Name = &name
	}

	// Set property "Properties":
	if settings.AffinityCookieName != nil ||
		settings.AuthenticationCertificates != nil ||
		settings.ConnectionDraining != nil ||
		settings.CookieBasedAffinity != nil ||
		settings.HostName != nil ||
		settings.Path != nil ||
		settings.PickHostNameFromBackendAddress != nil ||
		settings.Port != nil ||
		settings.Probe != nil ||
		settings.ProbeEnabled != nil ||
		settings.Protocol != nil ||
		settings.RequestTimeout != nil ||
		settings.TrustedRootCertificates != nil {
		result.Properties = &arm.ApplicationGatewayBackendHttpSettingsPropertiesFormat{}
	}
	if settings.AffinityCookieName != nil {
		affinityCookieName := *settings.AffinityCookieName
		result.Properties.AffinityCookieName = &affinityCookieName
	}
	for _, item := range settings.AuthenticationCertificates {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.AuthenticationCertificates = append(result.Properties.AuthenticationCertificates, *item_ARM.(*arm.SubResource))
	}
	if settings.ConnectionDraining != nil {
		connectionDraining_ARM, err := (*settings.ConnectionDraining).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		connectionDraining := *connectionDraining_ARM.(*arm.ApplicationGatewayConnectionDraining)
		result.Properties.ConnectionDraining = &connectionDraining
	}
	if settings.CookieBasedAffinity != nil {
		var temp string
		temp = string(*settings.CookieBasedAffinity)
		cookieBasedAffinity := arm.ApplicationGatewayBackendHttpSettingsPropertiesFormat_CookieBasedAffinity(temp)
		result.Properties.CookieBasedAffinity = &cookieBasedAffinity
	}
	if settings.HostName != nil {
		hostName := *settings.HostName
		result.Properties.HostName = &hostName
	}
	if settings.Path != nil {
		path := *settings.Path
		result.Properties.Path = &path
	}
	if settings.PickHostNameFromBackendAddress != nil {
		pickHostNameFromBackendAddress := *settings.PickHostNameFromBackendAddress
		result.Properties.PickHostNameFromBackendAddress = &pickHostNameFromBackendAddress
	}
	if settings.Port != nil {
		port := *settings.Port
		result.Properties.Port = &port
	}
	if settings.Probe != nil {
		probe_ARM, err := (*settings.Probe).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		probe := *probe_ARM.(*arm.SubResource)
		result.Properties.Probe = &probe
	}
	if settings.ProbeEnabled != nil {
		probeEnabled := *settings.ProbeEnabled
		result.Properties.ProbeEnabled = &probeEnabled
	}
	if settings.Protocol != nil {
		var temp string
		temp = string(*settings.Protocol)
		protocol := arm.ApplicationGatewayProtocol(temp)
		result.Properties.Protocol = &protocol
	}
	if settings.RequestTimeout != nil {
		requestTimeout := *settings.RequestTimeout
		result.Properties.RequestTimeout = &requestTimeout
	}
	for _, item := range settings.TrustedRootCertificates {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.TrustedRootCertificates = append(result.Properties.TrustedRootCertificates, *item_ARM.(*arm.SubResource))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *ApplicationGatewayBackendHttpSettings) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApplicationGatewayBackendHttpSettings{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *ApplicationGatewayBackendHttpSettings) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApplicationGatewayBackendHttpSettings)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApplicationGatewayBackendHttpSettings, got %T", armInput)
	}

	// Set property "AffinityCookieName":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AffinityCookieName != nil {
			affinityCookieName := *typedInput.Properties.AffinityCookieName
			settings.AffinityCookieName = &affinityCookieName
		}
	}

	// Set property "AuthenticationCertificates":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.AuthenticationCertificates {
			var item1 SubResource
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			settings.AuthenticationCertificates = append(settings.AuthenticationCertificates, item1)
		}
	}

	// Set property "ConnectionDraining":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ConnectionDraining != nil {
			var connectionDraining1 ApplicationGatewayConnectionDraining
			err := connectionDraining1.PopulateFromARM(owner, *typedInput.Properties.ConnectionDraining)
			if err != nil {
				return err
			}
			connectionDraining := connectionDraining1
			settings.ConnectionDraining = &connectionDraining
		}
	}

	// Set property "CookieBasedAffinity":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.CookieBasedAffinity != nil {
			var temp string
			temp = string(*typedInput.Properties.CookieBasedAffinity)
			cookieBasedAffinity := ApplicationGatewayBackendHttpSettingsPropertiesFormat_CookieBasedAffinity(temp)
			settings.CookieBasedAffinity = &cookieBasedAffinity
		}
	}

	// Set property "HostName":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HostName != nil {
			hostName := *typedInput.Properties.HostName
			settings.HostName = &hostName
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		settings.Name = &name
	}

	// Set property "Path":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Path != nil {
			path := *typedInput.Properties.Path
			settings.Path = &path
		}
	}

	// Set property "PickHostNameFromBackendAddress":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PickHostNameFromBackendAddress != nil {
			pickHostNameFromBackendAddress := *typedInput.Properties.PickHostNameFromBackendAddress
			settings.PickHostNameFromBackendAddress = &pickHostNameFromBackendAddress
		}
	}

	// Set property "Port":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Port != nil {
			port := *typedInput.Properties.Port
			settings.Port = &port
		}
	}

	// Set property "Probe":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Probe != nil {
			var probe1 SubResource
			err := probe1.PopulateFromARM(owner, *typedInput.Properties.Probe)
			if err != nil {
				return err
			}
			probe := probe1
			settings.Probe = &probe
		}
	}

	// Set property "ProbeEnabled":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProbeEnabled != nil {
			probeEnabled := *typedInput.Properties.ProbeEnabled
			settings.ProbeEnabled = &probeEnabled
		}
	}

	// Set property "Protocol":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Protocol != nil {
			var temp string
			temp = string(*typedInput.Properties.Protocol)
			protocol := ApplicationGatewayProtocol(temp)
			settings.Protocol = &protocol
		}
	}

	// Set property "RequestTimeout":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.RequestTimeout != nil {
			requestTimeout := *typedInput.Properties.RequestTimeout
			settings.RequestTimeout = &requestTimeout
		}
	}

	// Set property "TrustedRootCertificates":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.TrustedRootCertificates {
			var item1 SubResource
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			settings.TrustedRootCertificates = append(settings.TrustedRootCertificates, item1)
		}
	}

	// No error
	return nil
}

// AssignProperties_From_ApplicationGatewayBackendHttpSettings populates our ApplicationGatewayBackendHttpSettings from the provided source ApplicationGatewayBackendHttpSettings
func (settings *ApplicationGatewayBackendHttpSettings) AssignProperties_From_ApplicationGatewayBackendHttpSettings(source *storage.ApplicationGatewayBackendHttpSettings) error {

	// AffinityCookieName
	settings.AffinityCookieName = genruntime.ClonePointerToString(source.AffinityCookieName)

	// AuthenticationCertificates
	if source.AuthenticationCertificates != nil {
		authenticationCertificateList := make([]SubResource, len(source.AuthenticationCertificates))
		for authenticationCertificateIndex, authenticationCertificateItem := range source.AuthenticationCertificates {
			// Shadow the loop variable to avoid aliasing
			authenticationCertificateItem := authenticationCertificateItem
			var authenticationCertificate SubResource
			err := authenticationCertificate.AssignProperties_From_SubResource(&authenticationCertificateItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field AuthenticationCertificates")
			}
			authenticationCertificateList[authenticationCertificateIndex] = authenticationCertificate
		}
		settings.AuthenticationCertificates = authenticationCertificateList
	} else {
		settings.AuthenticationCertificates = nil
	}

	// ConnectionDraining
	if source.ConnectionDraining != nil {
		var connectionDraining ApplicationGatewayConnectionDraining
		err := connectionDraining.AssignProperties_From_ApplicationGatewayConnectionDraining(source.ConnectionDraining)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ApplicationGatewayConnectionDraining() to populate field ConnectionDraining")
		}
		settings.ConnectionDraining = &connectionDraining
	} else {
		settings.ConnectionDraining = nil
	}

	// CookieBasedAffinity
	if source.CookieBasedAffinity != nil {
		cookieBasedAffinity := *source.CookieBasedAffinity
		cookieBasedAffinityTemp := genruntime.ToEnum(cookieBasedAffinity, applicationGatewayBackendHttpSettingsPropertiesFormat_CookieBasedAffinity_Values)
		settings.CookieBasedAffinity = &cookieBasedAffinityTemp
	} else {
		settings.CookieBasedAffinity = nil
	}

	// HostName
	settings.HostName = genruntime.ClonePointerToString(source.HostName)

	// Name
	settings.Name = genruntime.ClonePointerToString(source.Name)

	// Path
	settings.Path = genruntime.ClonePointerToString(source.Path)

	// PickHostNameFromBackendAddress
	if source.PickHostNameFromBackendAddress != nil {
		pickHostNameFromBackendAddress := *source.PickHostNameFromBackendAddress
		settings.PickHostNameFromBackendAddress = &pickHostNameFromBackendAddress
	} else {
		settings.PickHostNameFromBackendAddress = nil
	}

	// Port
	settings.Port = genruntime.ClonePointerToInt(source.Port)

	// Probe
	if source.Probe != nil {
		var probe SubResource
		err := probe.AssignProperties_From_SubResource(source.Probe)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field Probe")
		}
		settings.Probe = &probe
	} else {
		settings.Probe = nil
	}

	// ProbeEnabled
	if source.ProbeEnabled != nil {
		probeEnabled := *source.ProbeEnabled
		settings.ProbeEnabled = &probeEnabled
	} else {
		settings.ProbeEnabled = nil
	}

	// Protocol
	if source.Protocol != nil {
		protocol := *source.Protocol
		protocolTemp := genruntime.ToEnum(protocol, applicationGatewayProtocol_Values)
		settings.Protocol = &protocolTemp
	} else {
		settings.Protocol = nil
	}

	// RequestTimeout
	settings.RequestTimeout = genruntime.ClonePointerToInt(source.RequestTimeout)

	// TrustedRootCertificates
	if source.TrustedRootCertificates != nil {
		trustedRootCertificateList := make([]SubResource, len(source.TrustedRootCertificates))
		for trustedRootCertificateIndex, trustedRootCertificateItem := range source.TrustedRootCertificates {
			// Shadow the loop variable to avoid aliasing
			trustedRootCertificateItem := trustedRootCertificateItem
			var trustedRootCertificate SubResource
			err := trustedRootCertificate.AssignProperties_From_SubResource(&trustedRootCertificateItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field TrustedRootCertificates")
			}
			trustedRootCertificateList[trustedRootCertificateIndex] = trustedRootCertificate
		}
		settings.TrustedRootCertificates = trustedRootCertificateList
	} else {
		settings.TrustedRootCertificates = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ApplicationGatewayBackendHttpSettings populates the provided destination ApplicationGatewayBackendHttpSettings from our ApplicationGatewayBackendHttpSettings
func (settings *ApplicationGatewayBackendHttpSettings) AssignProperties_To_ApplicationGatewayBackendHttpSettings(destination *storage.ApplicationGatewayBackendHttpSettings) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AffinityCookieName
	destination.AffinityCookieName = genruntime.ClonePointerToString(settings.AffinityCookieName)

	// AuthenticationCertificates
	if settings.AuthenticationCertificates != nil {
		authenticationCertificateList := make([]storage.SubResource, len(settings.AuthenticationCertificates))
		for authenticationCertificateIndex, authenticationCertificateItem := range settings.AuthenticationCertificates {
			// Shadow the loop variable to avoid aliasing
			authenticationCertificateItem := authenticationCertificateItem
			var authenticationCertificate storage.SubResource
			err := authenticationCertificateItem.AssignProperties_To_SubResource(&authenticationCertificate)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field AuthenticationCertificates")
			}
			authenticationCertificateList[authenticationCertificateIndex] = authenticationCertificate
		}
		destination.AuthenticationCertificates = authenticationCertificateList
	} else {
		destination.AuthenticationCertificates = nil
	}

	// ConnectionDraining
	if settings.ConnectionDraining != nil {
		var connectionDraining storage.ApplicationGatewayConnectionDraining
		err := settings.ConnectionDraining.AssignProperties_To_ApplicationGatewayConnectionDraining(&connectionDraining)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ApplicationGatewayConnectionDraining() to populate field ConnectionDraining")
		}
		destination.ConnectionDraining = &connectionDraining
	} else {
		destination.ConnectionDraining = nil
	}

	// CookieBasedAffinity
	if settings.CookieBasedAffinity != nil {
		cookieBasedAffinity := string(*settings.CookieBasedAffinity)
		destination.CookieBasedAffinity = &cookieBasedAffinity
	} else {
		destination.CookieBasedAffinity = nil
	}

	// HostName
	destination.HostName = genruntime.ClonePointerToString(settings.HostName)

	// Name
	destination.Name = genruntime.ClonePointerToString(settings.Name)

	// Path
	destination.Path = genruntime.ClonePointerToString(settings.Path)

	// PickHostNameFromBackendAddress
	if settings.PickHostNameFromBackendAddress != nil {
		pickHostNameFromBackendAddress := *settings.PickHostNameFromBackendAddress
		destination.PickHostNameFromBackendAddress = &pickHostNameFromBackendAddress
	} else {
		destination.PickHostNameFromBackendAddress = nil
	}

	// Port
	destination.Port = genruntime.ClonePointerToInt(settings.Port)

	// Probe
	if settings.Probe != nil {
		var probe storage.SubResource
		err := settings.Probe.AssignProperties_To_SubResource(&probe)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field Probe")
		}
		destination.Probe = &probe
	} else {
		destination.Probe = nil
	}

	// ProbeEnabled
	if settings.ProbeEnabled != nil {
		probeEnabled := *settings.ProbeEnabled
		destination.ProbeEnabled = &probeEnabled
	} else {
		destination.ProbeEnabled = nil
	}

	// Protocol
	if settings.Protocol != nil {
		protocol := string(*settings.Protocol)
		destination.Protocol = &protocol
	} else {
		destination.Protocol = nil
	}

	// RequestTimeout
	destination.RequestTimeout = genruntime.ClonePointerToInt(settings.RequestTimeout)

	// TrustedRootCertificates
	if settings.TrustedRootCertificates != nil {
		trustedRootCertificateList := make([]storage.SubResource, len(settings.TrustedRootCertificates))
		for trustedRootCertificateIndex, trustedRootCertificateItem := range settings.TrustedRootCertificates {
			// Shadow the loop variable to avoid aliasing
			trustedRootCertificateItem := trustedRootCertificateItem
			var trustedRootCertificate storage.SubResource
			err := trustedRootCertificateItem.AssignProperties_To_SubResource(&trustedRootCertificate)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field TrustedRootCertificates")
			}
			trustedRootCertificateList[trustedRootCertificateIndex] = trustedRootCertificate
		}
		destination.TrustedRootCertificates = trustedRootCertificateList
	} else {
		destination.TrustedRootCertificates = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ApplicationGatewayBackendHttpSettings_STATUS populates our ApplicationGatewayBackendHttpSettings from the provided source ApplicationGatewayBackendHttpSettings_STATUS
func (settings *ApplicationGatewayBackendHttpSettings) Initialize_From_ApplicationGatewayBackendHttpSettings_STATUS(source *ApplicationGatewayBackendHttpSettings_STATUS) error {

	// No error
	return nil
}

// Backend address pool settings of an application gateway.
type ApplicationGatewayBackendHttpSettings_STATUS struct {
	// Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &ApplicationGatewayBackendHttpSettings_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *ApplicationGatewayBackendHttpSettings_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApplicationGatewayBackendHttpSettings_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *ApplicationGatewayBackendHttpSettings_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApplicationGatewayBackendHttpSettings_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApplicationGatewayBackendHttpSettings_STATUS, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		settings.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_ApplicationGatewayBackendHttpSettings_STATUS populates our ApplicationGatewayBackendHttpSettings_STATUS from the provided source ApplicationGatewayBackendHttpSettings_STATUS
func (settings *ApplicationGatewayBackendHttpSettings_STATUS) AssignProperties_From_ApplicationGatewayBackendHttpSettings_STATUS(source *storage.ApplicationGatewayBackendHttpSettings_STATUS) error {

	// Id
	settings.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_ApplicationGatewayBackendHttpSettings_STATUS populates the provided destination ApplicationGatewayBackendHttpSettings_STATUS from our ApplicationGatewayBackendHttpSettings_STATUS
func (settings *ApplicationGatewayBackendHttpSettings_STATUS) AssignProperties_To_ApplicationGatewayBackendHttpSettings_STATUS(destination *storage.ApplicationGatewayBackendHttpSettings_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(settings.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Backend address pool settings of an application gateway.
type ApplicationGatewayBackendSettings struct {
	// HostName: Server name indication to be sent to the backend servers for Tls protocol.
	HostName *string `json:"hostName,omitempty"`

	// Name: Name of the backend settings that is unique within an Application Gateway.
	Name *string `json:"name,omitempty"`

	// PickHostNameFromBackendAddress: Whether to pick server name indication from the host name of the backend server for Tls
	// protocol. Default value is false.
	PickHostNameFromBackendAddress *bool `json:"pickHostNameFromBackendAddress,omitempty"`

	// Port: The destination port on the backend.
	Port *int `json:"port,omitempty"`

	// Probe: Probe resource of an application gateway.
	Probe *SubResource `json:"probe,omitempty"`

	// Protocol: The protocol used to communicate with the backend.
	Protocol *ApplicationGatewayProtocol `json:"protocol,omitempty"`

	// Timeout: Connection timeout in seconds. Application Gateway will fail the request if response is not received within
	// ConnectionTimeout. Acceptable values are from 1 second to 86400 seconds.
	Timeout *int `json:"timeout,omitempty"`

	// TrustedRootCertificates: Array of references to application gateway trusted root certificates.
	TrustedRootCertificates []SubResource `json:"trustedRootCertificates,omitempty"`
}

var _ genruntime.ARMTransformer = &ApplicationGatewayBackendSettings{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (settings *ApplicationGatewayBackendSettings) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if settings == nil {
		return nil, nil
	}
	result := &arm.ApplicationGatewayBackendSettings{}

	// Set property "Name":
	if settings.Name != nil {
		name := *settings.Name
		result.Name = &name
	}

	// Set property "Properties":
	if settings.HostName != nil ||
		settings.PickHostNameFromBackendAddress != nil ||
		settings.Port != nil ||
		settings.Probe != nil ||
		settings.Protocol != nil ||
		settings.Timeout != nil ||
		settings.TrustedRootCertificates != nil {
		result.Properties = &arm.ApplicationGatewayBackendSettingsPropertiesFormat{}
	}
	if settings.HostName != nil {
		hostName := *settings.HostName
		result.Properties.HostName = &hostName
	}
	if settings.PickHostNameFromBackendAddress != nil {
		pickHostNameFromBackendAddress := *settings.PickHostNameFromBackendAddress
		result.Properties.PickHostNameFromBackendAddress = &pickHostNameFromBackendAddress
	}
	if settings.Port != nil {
		port := *settings.Port
		result.Properties.Port = &port
	}
	if settings.Probe != nil {
		probe_ARM, err := (*settings.Probe).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		probe := *probe_ARM.(*arm.SubResource)
		result.Properties.Probe = &probe
	}
	if settings.Protocol != nil {
		var temp string
		temp = string(*settings.Protocol)
		protocol := arm.ApplicationGatewayProtocol(temp)
		result.Properties.Protocol = &protocol
	}
	if settings.Timeout != nil {
		timeout := *settings.Timeout
		result.Properties.Timeout = &timeout
	}
	for _, item := range settings.TrustedRootCertificates {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.TrustedRootCertificates = append(result.Properties.TrustedRootCertificates, *item_ARM.(*arm.SubResource))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *ApplicationGatewayBackendSettings) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApplicationGatewayBackendSettings{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *ApplicationGatewayBackendSettings) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApplicationGatewayBackendSettings)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApplicationGatewayBackendSettings, got %T", armInput)
	}

	// Set property "HostName":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HostName != nil {
			hostName := *typedInput.Properties.HostName
			settings.HostName = &hostName
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		settings.Name = &name
	}

	// Set property "PickHostNameFromBackendAddress":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PickHostNameFromBackendAddress != nil {
			pickHostNameFromBackendAddress := *typedInput.Properties.PickHostNameFromBackendAddress
			settings.PickHostNameFromBackendAddress = &pickHostNameFromBackendAddress
		}
	}

	// Set property "Port":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Port != nil {
			port := *typedInput.Properties.Port
			settings.Port = &port
		}
	}

	// Set property "Probe":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Probe != nil {
			var probe1 SubResource
			err := probe1.PopulateFromARM(owner, *typedInput.Properties.Probe)
			if err != nil {
				return err
			}
			probe := probe1
			settings.Probe = &probe
		}
	}

	// Set property "Protocol":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Protocol != nil {
			var temp string
			temp = string(*typedInput.Properties.Protocol)
			protocol := ApplicationGatewayProtocol(temp)
			settings.Protocol = &protocol
		}
	}

	// Set property "Timeout":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Timeout != nil {
			timeout := *typedInput.Properties.Timeout
			settings.Timeout = &timeout
		}
	}

	// Set property "TrustedRootCertificates":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.TrustedRootCertificates {
			var item1 SubResource
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			settings.TrustedRootCertificates = append(settings.TrustedRootCertificates, item1)
		}
	}

	// No error
	return nil
}

// AssignProperties_From_ApplicationGatewayBackendSettings populates our ApplicationGatewayBackendSettings from the provided source ApplicationGatewayBackendSettings
func (settings *ApplicationGatewayBackendSettings) AssignProperties_From_ApplicationGatewayBackendSettings(source *storage.ApplicationGatewayBackendSettings) error {

	// HostName
	settings.HostName = genruntime.ClonePointerToString(source.HostName)

	// Name
	settings.Name = genruntime.ClonePointerToString(source.Name)

	// PickHostNameFromBackendAddress
	if source.PickHostNameFromBackendAddress != nil {
		pickHostNameFromBackendAddress := *source.PickHostNameFromBackendAddress
		settings.PickHostNameFromBackendAddress = &pickHostNameFromBackendAddress
	} else {
		settings.PickHostNameFromBackendAddress = nil
	}

	// Port
	settings.Port = genruntime.ClonePointerToInt(source.Port)

	// Probe
	if source.Probe != nil {
		var probe SubResource
		err := probe.AssignProperties_From_SubResource(source.Probe)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field Probe")
		}
		settings.Probe = &probe
	} else {
		settings.Probe = nil
	}

	// Protocol
	if source.Protocol != nil {
		protocol := *source.Protocol
		protocolTemp := genruntime.ToEnum(protocol, applicationGatewayProtocol_Values)
		settings.Protocol = &protocolTemp
	} else {
		settings.Protocol = nil
	}

	// Timeout
	settings.Timeout = genruntime.ClonePointerToInt(source.Timeout)

	// TrustedRootCertificates
	if source.TrustedRootCertificates != nil {
		trustedRootCertificateList := make([]SubResource, len(source.TrustedRootCertificates))
		for trustedRootCertificateIndex, trustedRootCertificateItem := range source.TrustedRootCertificates {
			// Shadow the loop variable to avoid aliasing
			trustedRootCertificateItem := trustedRootCertificateItem
			var trustedRootCertificate SubResource
			err := trustedRootCertificate.AssignProperties_From_SubResource(&trustedRootCertificateItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field TrustedRootCertificates")
			}
			trustedRootCertificateList[trustedRootCertificateIndex] = trustedRootCertificate
		}
		settings.TrustedRootCertificates = trustedRootCertificateList
	} else {
		settings.TrustedRootCertificates = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ApplicationGatewayBackendSettings populates the provided destination ApplicationGatewayBackendSettings from our ApplicationGatewayBackendSettings
func (settings *ApplicationGatewayBackendSettings) AssignProperties_To_ApplicationGatewayBackendSettings(destination *storage.ApplicationGatewayBackendSettings) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// HostName
	destination.HostName = genruntime.ClonePointerToString(settings.HostName)

	// Name
	destination.Name = genruntime.ClonePointerToString(settings.Name)

	// PickHostNameFromBackendAddress
	if settings.PickHostNameFromBackendAddress != nil {
		pickHostNameFromBackendAddress := *settings.PickHostNameFromBackendAddress
		destination.PickHostNameFromBackendAddress = &pickHostNameFromBackendAddress
	} else {
		destination.PickHostNameFromBackendAddress = nil
	}

	// Port
	destination.Port = genruntime.ClonePointerToInt(settings.Port)

	// Probe
	if settings.Probe != nil {
		var probe storage.SubResource
		err := settings.Probe.AssignProperties_To_SubResource(&probe)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field Probe")
		}
		destination.Probe = &probe
	} else {
		destination.Probe = nil
	}

	// Protocol
	if settings.Protocol != nil {
		protocol := string(*settings.Protocol)
		destination.Protocol = &protocol
	} else {
		destination.Protocol = nil
	}

	// Timeout
	destination.Timeout = genruntime.ClonePointerToInt(settings.Timeout)

	// TrustedRootCertificates
	if settings.TrustedRootCertificates != nil {
		trustedRootCertificateList := make([]storage.SubResource, len(settings.TrustedRootCertificates))
		for trustedRootCertificateIndex, trustedRootCertificateItem := range settings.TrustedRootCertificates {
			// Shadow the loop variable to avoid aliasing
			trustedRootCertificateItem := trustedRootCertificateItem
			var trustedRootCertificate storage.SubResource
			err := trustedRootCertificateItem.AssignProperties_To_SubResource(&trustedRootCertificate)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field TrustedRootCertificates")
			}
			trustedRootCertificateList[trustedRootCertificateIndex] = trustedRootCertificate
		}
		destination.TrustedRootCertificates = trustedRootCertificateList
	} else {
		destination.TrustedRootCertificates = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ApplicationGatewayBackendSettings_STATUS populates our ApplicationGatewayBackendSettings from the provided source ApplicationGatewayBackendSettings_STATUS
func (settings *ApplicationGatewayBackendSettings) Initialize_From_ApplicationGatewayBackendSettings_STATUS(source *ApplicationGatewayBackendSettings_STATUS) error {

	// No error
	return nil
}

// Backend address pool settings of an application gateway.
type ApplicationGatewayBackendSettings_STATUS struct {
	// Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &ApplicationGatewayBackendSettings_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *ApplicationGatewayBackendSettings_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApplicationGatewayBackendSettings_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *ApplicationGatewayBackendSettings_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApplicationGatewayBackendSettings_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApplicationGatewayBackendSettings_STATUS, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		settings.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_ApplicationGatewayBackendSettings_STATUS populates our ApplicationGatewayBackendSettings_STATUS from the provided source ApplicationGatewayBackendSettings_STATUS
func (settings *ApplicationGatewayBackendSettings_STATUS) AssignProperties_From_ApplicationGatewayBackendSettings_STATUS(source *storage.ApplicationGatewayBackendSettings_STATUS) error {

	// Id
	settings.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_ApplicationGatewayBackendSettings_STATUS populates the provided destination ApplicationGatewayBackendSettings_STATUS from our ApplicationGatewayBackendSettings_STATUS
func (settings *ApplicationGatewayBackendSettings_STATUS) AssignProperties_To_ApplicationGatewayBackendSettings_STATUS(destination *storage.ApplicationGatewayBackendSettings_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(settings.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Customer error of an application gateway.
type ApplicationGatewayCustomError struct {
	// CustomErrorPageUrl: Error page URL of the application gateway customer error.
	CustomErrorPageUrl *string `json:"customErrorPageUrl,omitempty"`

	// StatusCode: Status code of the application gateway customer error.
	StatusCode *ApplicationGatewayCustomError_StatusCode `json:"statusCode,omitempty"`
}

var _ genruntime.ARMTransformer = &ApplicationGatewayCustomError{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (error *ApplicationGatewayCustomError) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if error == nil {
		return nil, nil
	}
	result := &arm.ApplicationGatewayCustomError{}

	// Set property "CustomErrorPageUrl":
	if error.CustomErrorPageUrl != nil {
		customErrorPageUrl := *error.CustomErrorPageUrl
		result.CustomErrorPageUrl = &customErrorPageUrl
	}

	// Set property "StatusCode":
	if error.StatusCode != nil {
		var temp string
		temp = string(*error.StatusCode)
		statusCode := arm.ApplicationGatewayCustomError_StatusCode(temp)
		result.StatusCode = &statusCode
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (error *ApplicationGatewayCustomError) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApplicationGatewayCustomError{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (error *ApplicationGatewayCustomError) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApplicationGatewayCustomError)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApplicationGatewayCustomError, got %T", armInput)
	}

	// Set property "CustomErrorPageUrl":
	if typedInput.CustomErrorPageUrl != nil {
		customErrorPageUrl := *typedInput.CustomErrorPageUrl
		error.CustomErrorPageUrl = &customErrorPageUrl
	}

	// Set property "StatusCode":
	if typedInput.StatusCode != nil {
		var temp string
		temp = string(*typedInput.StatusCode)
		statusCode := ApplicationGatewayCustomError_StatusCode(temp)
		error.StatusCode = &statusCode
	}

	// No error
	return nil
}

// AssignProperties_From_ApplicationGatewayCustomError populates our ApplicationGatewayCustomError from the provided source ApplicationGatewayCustomError
func (error *ApplicationGatewayCustomError) AssignProperties_From_ApplicationGatewayCustomError(source *storage.ApplicationGatewayCustomError) error {

	// CustomErrorPageUrl
	error.CustomErrorPageUrl = genruntime.ClonePointerToString(source.CustomErrorPageUrl)

	// StatusCode
	if source.StatusCode != nil {
		statusCode := *source.StatusCode
		statusCodeTemp := genruntime.ToEnum(statusCode, applicationGatewayCustomError_StatusCode_Values)
		error.StatusCode = &statusCodeTemp
	} else {
		error.StatusCode = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ApplicationGatewayCustomError populates the provided destination ApplicationGatewayCustomError from our ApplicationGatewayCustomError
func (error *ApplicationGatewayCustomError) AssignProperties_To_ApplicationGatewayCustomError(destination *storage.ApplicationGatewayCustomError) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CustomErrorPageUrl
	destination.CustomErrorPageUrl = genruntime.ClonePointerToString(error.CustomErrorPageUrl)

	// StatusCode
	if error.StatusCode != nil {
		statusCode := string(*error.StatusCode)
		destination.StatusCode = &statusCode
	} else {
		destination.StatusCode = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ApplicationGatewayCustomError_STATUS populates our ApplicationGatewayCustomError from the provided source ApplicationGatewayCustomError_STATUS
func (error *ApplicationGatewayCustomError) Initialize_From_ApplicationGatewayCustomError_STATUS(source *ApplicationGatewayCustomError_STATUS) error {

	// CustomErrorPageUrl
	error.CustomErrorPageUrl = genruntime.ClonePointerToString(source.CustomErrorPageUrl)

	// StatusCode
	if source.StatusCode != nil {
		statusCode := genruntime.ToEnum(string(*source.StatusCode), applicationGatewayCustomError_StatusCode_Values)
		error.StatusCode = &statusCode
	} else {
		error.StatusCode = nil
	}

	// No error
	return nil
}

// Customer error of an application gateway.
type ApplicationGatewayCustomError_STATUS struct {
	// CustomErrorPageUrl: Error page URL of the application gateway customer error.
	CustomErrorPageUrl *string `json:"customErrorPageUrl,omitempty"`

	// StatusCode: Status code of the application gateway customer error.
	StatusCode *ApplicationGatewayCustomError_StatusCode_STATUS `json:"statusCode,omitempty"`
}

var _ genruntime.FromARMConverter = &ApplicationGatewayCustomError_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (error *ApplicationGatewayCustomError_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApplicationGatewayCustomError_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (error *ApplicationGatewayCustomError_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApplicationGatewayCustomError_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApplicationGatewayCustomError_STATUS, got %T", armInput)
	}

	// Set property "CustomErrorPageUrl":
	if typedInput.CustomErrorPageUrl != nil {
		customErrorPageUrl := *typedInput.CustomErrorPageUrl
		error.CustomErrorPageUrl = &customErrorPageUrl
	}

	// Set property "StatusCode":
	if typedInput.StatusCode != nil {
		var temp string
		temp = string(*typedInput.StatusCode)
		statusCode := ApplicationGatewayCustomError_StatusCode_STATUS(temp)
		error.StatusCode = &statusCode
	}

	// No error
	return nil
}

// AssignProperties_From_ApplicationGatewayCustomError_STATUS populates our ApplicationGatewayCustomError_STATUS from the provided source ApplicationGatewayCustomError_STATUS
func (error *ApplicationGatewayCustomError_STATUS) AssignProperties_From_ApplicationGatewayCustomError_STATUS(source *storage.ApplicationGatewayCustomError_STATUS) error {

	// CustomErrorPageUrl
	error.CustomErrorPageUrl = genruntime.ClonePointerToString(source.CustomErrorPageUrl)

	// StatusCode
	if source.StatusCode != nil {
		statusCode := *source.StatusCode
		statusCodeTemp := genruntime.ToEnum(statusCode, applicationGatewayCustomError_StatusCode_STATUS_Values)
		error.StatusCode = &statusCodeTemp
	} else {
		error.StatusCode = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ApplicationGatewayCustomError_STATUS populates the provided destination ApplicationGatewayCustomError_STATUS from our ApplicationGatewayCustomError_STATUS
func (error *ApplicationGatewayCustomError_STATUS) AssignProperties_To_ApplicationGatewayCustomError_STATUS(destination *storage.ApplicationGatewayCustomError_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CustomErrorPageUrl
	destination.CustomErrorPageUrl = genruntime.ClonePointerToString(error.CustomErrorPageUrl)

	// StatusCode
	if error.StatusCode != nil {
		statusCode := string(*error.StatusCode)
		destination.StatusCode = &statusCode
	} else {
		destination.StatusCode = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Frontend IP configuration of an application gateway.
type ApplicationGatewayFrontendIPConfiguration struct {
	// Name: Name of the frontend IP configuration that is unique within an Application Gateway.
	Name *string `json:"name,omitempty"`

	// PrivateIPAddress: PrivateIPAddress of the network interface IP Configuration.
	PrivateIPAddress *string `json:"privateIPAddress,omitempty"`

	// PrivateIPAllocationMethod: The private IP address allocation method.
	PrivateIPAllocationMethod *IPAllocationMethod `json:"privateIPAllocationMethod,omitempty"`

	// PrivateLinkConfiguration: Reference to the application gateway private link configuration.
	PrivateLinkConfiguration *SubResource `json:"privateLinkConfiguration,omitempty"`

	// PublicIPAddress: Reference to the PublicIP resource.
	PublicIPAddress *SubResource `json:"publicIPAddress,omitempty"`

	// Subnet: Reference to the subnet resource.
	Subnet *SubResource `json:"subnet,omitempty"`
}

var _ genruntime.ARMTransformer = &ApplicationGatewayFrontendIPConfiguration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (configuration *ApplicationGatewayFrontendIPConfiguration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if configuration == nil {
		return nil, nil
	}
	result := &arm.ApplicationGatewayFrontendIPConfiguration{}

	// Set property "Name":
	if configuration.Name != nil {
		name := *configuration.Name
		result.Name = &name
	}

	// Set property "Properties":
	if configuration.PrivateIPAddress != nil ||
		configuration.PrivateIPAllocationMethod != nil ||
		configuration.PrivateLinkConfiguration != nil ||
		configuration.PublicIPAddress != nil ||
		configuration.Subnet != nil {
		result.Properties = &arm.ApplicationGatewayFrontendIPConfigurationPropertiesFormat{}
	}
	if configuration.PrivateIPAddress != nil {
		privateIPAddress := *configuration.PrivateIPAddress
		result.Properties.PrivateIPAddress = &privateIPAddress
	}
	if configuration.PrivateIPAllocationMethod != nil {
		var temp string
		temp = string(*configuration.PrivateIPAllocationMethod)
		privateIPAllocationMethod := arm.IPAllocationMethod(temp)
		result.Properties.PrivateIPAllocationMethod = &privateIPAllocationMethod
	}
	if configuration.PrivateLinkConfiguration != nil {
		privateLinkConfiguration_ARM, err := (*configuration.PrivateLinkConfiguration).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		privateLinkConfiguration := *privateLinkConfiguration_ARM.(*arm.SubResource)
		result.Properties.PrivateLinkConfiguration = &privateLinkConfiguration
	}
	if configuration.PublicIPAddress != nil {
		publicIPAddress_ARM, err := (*configuration.PublicIPAddress).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		publicIPAddress := *publicIPAddress_ARM.(*arm.SubResource)
		result.Properties.PublicIPAddress = &publicIPAddress
	}
	if configuration.Subnet != nil {
		subnet_ARM, err := (*configuration.Subnet).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		subnet := *subnet_ARM.(*arm.SubResource)
		result.Properties.Subnet = &subnet
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *ApplicationGatewayFrontendIPConfiguration) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApplicationGatewayFrontendIPConfiguration{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *ApplicationGatewayFrontendIPConfiguration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApplicationGatewayFrontendIPConfiguration)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApplicationGatewayFrontendIPConfiguration, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		configuration.Name = &name
	}

	// Set property "PrivateIPAddress":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateIPAddress != nil {
			privateIPAddress := *typedInput.Properties.PrivateIPAddress
			configuration.PrivateIPAddress = &privateIPAddress
		}
	}

	// Set property "PrivateIPAllocationMethod":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateIPAllocationMethod != nil {
			var temp string
			temp = string(*typedInput.Properties.PrivateIPAllocationMethod)
			privateIPAllocationMethod := IPAllocationMethod(temp)
			configuration.PrivateIPAllocationMethod = &privateIPAllocationMethod
		}
	}

	// Set property "PrivateLinkConfiguration":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateLinkConfiguration != nil {
			var privateLinkConfiguration1 SubResource
			err := privateLinkConfiguration1.PopulateFromARM(owner, *typedInput.Properties.PrivateLinkConfiguration)
			if err != nil {
				return err
			}
			privateLinkConfiguration := privateLinkConfiguration1
			configuration.PrivateLinkConfiguration = &privateLinkConfiguration
		}
	}

	// Set property "PublicIPAddress":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicIPAddress != nil {
			var publicIPAddress1 SubResource
			err := publicIPAddress1.PopulateFromARM(owner, *typedInput.Properties.PublicIPAddress)
			if err != nil {
				return err
			}
			publicIPAddress := publicIPAddress1
			configuration.PublicIPAddress = &publicIPAddress
		}
	}

	// Set property "Subnet":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Subnet != nil {
			var subnet1 SubResource
			err := subnet1.PopulateFromARM(owner, *typedInput.Properties.Subnet)
			if err != nil {
				return err
			}
			subnet := subnet1
			configuration.Subnet = &subnet
		}
	}

	// No error
	return nil
}

// AssignProperties_From_ApplicationGatewayFrontendIPConfiguration populates our ApplicationGatewayFrontendIPConfiguration from the provided source ApplicationGatewayFrontendIPConfiguration
func (configuration *ApplicationGatewayFrontendIPConfiguration) AssignProperties_From_ApplicationGatewayFrontendIPConfiguration(source *storage.ApplicationGatewayFrontendIPConfiguration) error {

	// Name
	configuration.Name = genruntime.ClonePointerToString(source.Name)

	// PrivateIPAddress
	configuration.PrivateIPAddress = genruntime.ClonePointerToString(source.PrivateIPAddress)

	// PrivateIPAllocationMethod
	if source.PrivateIPAllocationMethod != nil {
		privateIPAllocationMethod := *source.PrivateIPAllocationMethod
		privateIPAllocationMethodTemp := genruntime.ToEnum(privateIPAllocationMethod, iPAllocationMethod_Values)
		configuration.PrivateIPAllocationMethod = &privateIPAllocationMethodTemp
	} else {
		configuration.PrivateIPAllocationMethod = nil
	}

	// PrivateLinkConfiguration
	if source.PrivateLinkConfiguration != nil {
		var privateLinkConfiguration SubResource
		err := privateLinkConfiguration.AssignProperties_From_SubResource(source.PrivateLinkConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field PrivateLinkConfiguration")
		}
		configuration.PrivateLinkConfiguration = &privateLinkConfiguration
	} else {
		configuration.PrivateLinkConfiguration = nil
	}

	// PublicIPAddress
	if source.PublicIPAddress != nil {
		var publicIPAddress SubResource
		err := publicIPAddress.AssignProperties_From_SubResource(source.PublicIPAddress)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field PublicIPAddress")
		}
		configuration.PublicIPAddress = &publicIPAddress
	} else {
		configuration.PublicIPAddress = nil
	}

	// Subnet
	if source.Subnet != nil {
		var subnet SubResource
		err := subnet.AssignProperties_From_SubResource(source.Subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field Subnet")
		}
		configuration.Subnet = &subnet
	} else {
		configuration.Subnet = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ApplicationGatewayFrontendIPConfiguration populates the provided destination ApplicationGatewayFrontendIPConfiguration from our ApplicationGatewayFrontendIPConfiguration
func (configuration *ApplicationGatewayFrontendIPConfiguration) AssignProperties_To_ApplicationGatewayFrontendIPConfiguration(destination *storage.ApplicationGatewayFrontendIPConfiguration) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(configuration.Name)

	// PrivateIPAddress
	destination.PrivateIPAddress = genruntime.ClonePointerToString(configuration.PrivateIPAddress)

	// PrivateIPAllocationMethod
	if configuration.PrivateIPAllocationMethod != nil {
		privateIPAllocationMethod := string(*configuration.PrivateIPAllocationMethod)
		destination.PrivateIPAllocationMethod = &privateIPAllocationMethod
	} else {
		destination.PrivateIPAllocationMethod = nil
	}

	// PrivateLinkConfiguration
	if configuration.PrivateLinkConfiguration != nil {
		var privateLinkConfiguration storage.SubResource
		err := configuration.PrivateLinkConfiguration.AssignProperties_To_SubResource(&privateLinkConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field PrivateLinkConfiguration")
		}
		destination.PrivateLinkConfiguration = &privateLinkConfiguration
	} else {
		destination.PrivateLinkConfiguration = nil
	}

	// PublicIPAddress
	if configuration.PublicIPAddress != nil {
		var publicIPAddress storage.SubResource
		err := configuration.PublicIPAddress.AssignProperties_To_SubResource(&publicIPAddress)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field PublicIPAddress")
		}
		destination.PublicIPAddress = &publicIPAddress
	} else {
		destination.PublicIPAddress = nil
	}

	// Subnet
	if configuration.Subnet != nil {
		var subnet storage.SubResource
		err := configuration.Subnet.AssignProperties_To_SubResource(&subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field Subnet")
		}
		destination.Subnet = &subnet
	} else {
		destination.Subnet = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ApplicationGatewayFrontendIPConfiguration_STATUS populates our ApplicationGatewayFrontendIPConfiguration from the provided source ApplicationGatewayFrontendIPConfiguration_STATUS
func (configuration *ApplicationGatewayFrontendIPConfiguration) Initialize_From_ApplicationGatewayFrontendIPConfiguration_STATUS(source *ApplicationGatewayFrontendIPConfiguration_STATUS) error {

	// No error
	return nil
}

// Frontend IP configuration of an application gateway.
type ApplicationGatewayFrontendIPConfiguration_STATUS struct {
	// Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &ApplicationGatewayFrontendIPConfiguration_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *ApplicationGatewayFrontendIPConfiguration_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApplicationGatewayFrontendIPConfiguration_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *ApplicationGatewayFrontendIPConfiguration_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApplicationGatewayFrontendIPConfiguration_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApplicationGatewayFrontendIPConfiguration_STATUS, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		configuration.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_ApplicationGatewayFrontendIPConfiguration_STATUS populates our ApplicationGatewayFrontendIPConfiguration_STATUS from the provided source ApplicationGatewayFrontendIPConfiguration_STATUS
func (configuration *ApplicationGatewayFrontendIPConfiguration_STATUS) AssignProperties_From_ApplicationGatewayFrontendIPConfiguration_STATUS(source *storage.ApplicationGatewayFrontendIPConfiguration_STATUS) error {

	// Id
	configuration.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_ApplicationGatewayFrontendIPConfiguration_STATUS populates the provided destination ApplicationGatewayFrontendIPConfiguration_STATUS from our ApplicationGatewayFrontendIPConfiguration_STATUS
func (configuration *ApplicationGatewayFrontendIPConfiguration_STATUS) AssignProperties_To_ApplicationGatewayFrontendIPConfiguration_STATUS(destination *storage.ApplicationGatewayFrontendIPConfiguration_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(configuration.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Frontend port of an application gateway.
type ApplicationGatewayFrontendPort struct {
	// Name: Name of the frontend port that is unique within an Application Gateway.
	Name *string `json:"name,omitempty"`

	// Port: Frontend port.
	Port *int `json:"port,omitempty"`
}

var _ genruntime.ARMTransformer = &ApplicationGatewayFrontendPort{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (port *ApplicationGatewayFrontendPort) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if port == nil {
		return nil, nil
	}
	result := &arm.ApplicationGatewayFrontendPort{}

	// Set property "Name":
	if port.Name != nil {
		name := *port.Name
		result.Name = &name
	}

	// Set property "Properties":
	if port.Port != nil {
		result.Properties = &arm.ApplicationGatewayFrontendPortPropertiesFormat{}
	}
	if port.Port != nil {
		port1 := *port.Port
		result.Properties.Port = &port1
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (port *ApplicationGatewayFrontendPort) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApplicationGatewayFrontendPort{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (port *ApplicationGatewayFrontendPort) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApplicationGatewayFrontendPort)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApplicationGatewayFrontendPort, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		port.Name = &name
	}

	// Set property "Port":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Port != nil {
			port1 := *typedInput.Properties.Port
			port.Port = &port1
		}
	}

	// No error
	return nil
}

// AssignProperties_From_ApplicationGatewayFrontendPort populates our ApplicationGatewayFrontendPort from the provided source ApplicationGatewayFrontendPort
func (port *ApplicationGatewayFrontendPort) AssignProperties_From_ApplicationGatewayFrontendPort(source *storage.ApplicationGatewayFrontendPort) error {

	// Name
	port.Name = genruntime.ClonePointerToString(source.Name)

	// Port
	port.Port = genruntime.ClonePointerToInt(source.Port)

	// No error
	return nil
}

// AssignProperties_To_ApplicationGatewayFrontendPort populates the provided destination ApplicationGatewayFrontendPort from our ApplicationGatewayFrontendPort
func (port *ApplicationGatewayFrontendPort) AssignProperties_To_ApplicationGatewayFrontendPort(destination *storage.ApplicationGatewayFrontendPort) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(port.Name)

	// Port
	destination.Port = genruntime.ClonePointerToInt(port.Port)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ApplicationGatewayFrontendPort_STATUS populates our ApplicationGatewayFrontendPort from the provided source ApplicationGatewayFrontendPort_STATUS
func (port *ApplicationGatewayFrontendPort) Initialize_From_ApplicationGatewayFrontendPort_STATUS(source *ApplicationGatewayFrontendPort_STATUS) error {

	// No error
	return nil
}

// Frontend port of an application gateway.
type ApplicationGatewayFrontendPort_STATUS struct {
	// Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &ApplicationGatewayFrontendPort_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (port *ApplicationGatewayFrontendPort_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApplicationGatewayFrontendPort_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (port *ApplicationGatewayFrontendPort_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApplicationGatewayFrontendPort_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApplicationGatewayFrontendPort_STATUS, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		port.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_ApplicationGatewayFrontendPort_STATUS populates our ApplicationGatewayFrontendPort_STATUS from the provided source ApplicationGatewayFrontendPort_STATUS
func (port *ApplicationGatewayFrontendPort_STATUS) AssignProperties_From_ApplicationGatewayFrontendPort_STATUS(source *storage.ApplicationGatewayFrontendPort_STATUS) error {

	// Id
	port.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_ApplicationGatewayFrontendPort_STATUS populates the provided destination ApplicationGatewayFrontendPort_STATUS from our ApplicationGatewayFrontendPort_STATUS
func (port *ApplicationGatewayFrontendPort_STATUS) AssignProperties_To_ApplicationGatewayFrontendPort_STATUS(destination *storage.ApplicationGatewayFrontendPort_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(port.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Application Gateway global configuration.
type ApplicationGatewayGlobalConfiguration struct {
	// EnableRequestBuffering: Enable request buffering.
	EnableRequestBuffering *bool `json:"enableRequestBuffering,omitempty"`

	// EnableResponseBuffering: Enable response buffering.
	EnableResponseBuffering *bool `json:"enableResponseBuffering,omitempty"`
}

var _ genruntime.ARMTransformer = &ApplicationGatewayGlobalConfiguration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (configuration *ApplicationGatewayGlobalConfiguration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if configuration == nil {
		return nil, nil
	}
	result := &arm.ApplicationGatewayGlobalConfiguration{}

	// Set property "EnableRequestBuffering":
	if configuration.EnableRequestBuffering != nil {
		enableRequestBuffering := *configuration.EnableRequestBuffering
		result.EnableRequestBuffering = &enableRequestBuffering
	}

	// Set property "EnableResponseBuffering":
	if configuration.EnableResponseBuffering != nil {
		enableResponseBuffering := *configuration.EnableResponseBuffering
		result.EnableResponseBuffering = &enableResponseBuffering
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *ApplicationGatewayGlobalConfiguration) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApplicationGatewayGlobalConfiguration{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *ApplicationGatewayGlobalConfiguration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApplicationGatewayGlobalConfiguration)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApplicationGatewayGlobalConfiguration, got %T", armInput)
	}

	// Set property "EnableRequestBuffering":
	if typedInput.EnableRequestBuffering != nil {
		enableRequestBuffering := *typedInput.EnableRequestBuffering
		configuration.EnableRequestBuffering = &enableRequestBuffering
	}

	// Set property "EnableResponseBuffering":
	if typedInput.EnableResponseBuffering != nil {
		enableResponseBuffering := *typedInput.EnableResponseBuffering
		configuration.EnableResponseBuffering = &enableResponseBuffering
	}

	// No error
	return nil
}

// AssignProperties_From_ApplicationGatewayGlobalConfiguration populates our ApplicationGatewayGlobalConfiguration from the provided source ApplicationGatewayGlobalConfiguration
func (configuration *ApplicationGatewayGlobalConfiguration) AssignProperties_From_ApplicationGatewayGlobalConfiguration(source *storage.ApplicationGatewayGlobalConfiguration) error {

	// EnableRequestBuffering
	if source.EnableRequestBuffering != nil {
		enableRequestBuffering := *source.EnableRequestBuffering
		configuration.EnableRequestBuffering = &enableRequestBuffering
	} else {
		configuration.EnableRequestBuffering = nil
	}

	// EnableResponseBuffering
	if source.EnableResponseBuffering != nil {
		enableResponseBuffering := *source.EnableResponseBuffering
		configuration.EnableResponseBuffering = &enableResponseBuffering
	} else {
		configuration.EnableResponseBuffering = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ApplicationGatewayGlobalConfiguration populates the provided destination ApplicationGatewayGlobalConfiguration from our ApplicationGatewayGlobalConfiguration
func (configuration *ApplicationGatewayGlobalConfiguration) AssignProperties_To_ApplicationGatewayGlobalConfiguration(destination *storage.ApplicationGatewayGlobalConfiguration) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// EnableRequestBuffering
	if configuration.EnableRequestBuffering != nil {
		enableRequestBuffering := *configuration.EnableRequestBuffering
		destination.EnableRequestBuffering = &enableRequestBuffering
	} else {
		destination.EnableRequestBuffering = nil
	}

	// EnableResponseBuffering
	if configuration.EnableResponseBuffering != nil {
		enableResponseBuffering := *configuration.EnableResponseBuffering
		destination.EnableResponseBuffering = &enableResponseBuffering
	} else {
		destination.EnableResponseBuffering = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ApplicationGatewayGlobalConfiguration_STATUS populates our ApplicationGatewayGlobalConfiguration from the provided source ApplicationGatewayGlobalConfiguration_STATUS
func (configuration *ApplicationGatewayGlobalConfiguration) Initialize_From_ApplicationGatewayGlobalConfiguration_STATUS(source *ApplicationGatewayGlobalConfiguration_STATUS) error {

	// EnableRequestBuffering
	if source.EnableRequestBuffering != nil {
		enableRequestBuffering := *source.EnableRequestBuffering
		configuration.EnableRequestBuffering = &enableRequestBuffering
	} else {
		configuration.EnableRequestBuffering = nil
	}

	// EnableResponseBuffering
	if source.EnableResponseBuffering != nil {
		enableResponseBuffering := *source.EnableResponseBuffering
		configuration.EnableResponseBuffering = &enableResponseBuffering
	} else {
		configuration.EnableResponseBuffering = nil
	}

	// No error
	return nil
}

// Application Gateway global configuration.
type ApplicationGatewayGlobalConfiguration_STATUS struct {
	// EnableRequestBuffering: Enable request buffering.
	EnableRequestBuffering *bool `json:"enableRequestBuffering,omitempty"`

	// EnableResponseBuffering: Enable response buffering.
	EnableResponseBuffering *bool `json:"enableResponseBuffering,omitempty"`
}

var _ genruntime.FromARMConverter = &ApplicationGatewayGlobalConfiguration_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *ApplicationGatewayGlobalConfiguration_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApplicationGatewayGlobalConfiguration_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *ApplicationGatewayGlobalConfiguration_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApplicationGatewayGlobalConfiguration_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApplicationGatewayGlobalConfiguration_STATUS, got %T", armInput)
	}

	// Set property "EnableRequestBuffering":
	if typedInput.EnableRequestBuffering != nil {
		enableRequestBuffering := *typedInput.EnableRequestBuffering
		configuration.EnableRequestBuffering = &enableRequestBuffering
	}

	// Set property "EnableResponseBuffering":
	if typedInput.EnableResponseBuffering != nil {
		enableResponseBuffering := *typedInput.EnableResponseBuffering
		configuration.EnableResponseBuffering = &enableResponseBuffering
	}

	// No error
	return nil
}

// AssignProperties_From_ApplicationGatewayGlobalConfiguration_STATUS populates our ApplicationGatewayGlobalConfiguration_STATUS from the provided source ApplicationGatewayGlobalConfiguration_STATUS
func (configuration *ApplicationGatewayGlobalConfiguration_STATUS) AssignProperties_From_ApplicationGatewayGlobalConfiguration_STATUS(source *storage.ApplicationGatewayGlobalConfiguration_STATUS) error {

	// EnableRequestBuffering
	if source.EnableRequestBuffering != nil {
		enableRequestBuffering := *source.EnableRequestBuffering
		configuration.EnableRequestBuffering = &enableRequestBuffering
	} else {
		configuration.EnableRequestBuffering = nil
	}

	// EnableResponseBuffering
	if source.EnableResponseBuffering != nil {
		enableResponseBuffering := *source.EnableResponseBuffering
		configuration.EnableResponseBuffering = &enableResponseBuffering
	} else {
		configuration.EnableResponseBuffering = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ApplicationGatewayGlobalConfiguration_STATUS populates the provided destination ApplicationGatewayGlobalConfiguration_STATUS from our ApplicationGatewayGlobalConfiguration_STATUS
func (configuration *ApplicationGatewayGlobalConfiguration_STATUS) AssignProperties_To_ApplicationGatewayGlobalConfiguration_STATUS(destination *storage.ApplicationGatewayGlobalConfiguration_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// EnableRequestBuffering
	if configuration.EnableRequestBuffering != nil {
		enableRequestBuffering := *configuration.EnableRequestBuffering
		destination.EnableRequestBuffering = &enableRequestBuffering
	} else {
		destination.EnableRequestBuffering = nil
	}

	// EnableResponseBuffering
	if configuration.EnableResponseBuffering != nil {
		enableResponseBuffering := *configuration.EnableResponseBuffering
		destination.EnableResponseBuffering = &enableResponseBuffering
	} else {
		destination.EnableResponseBuffering = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Http listener of an application gateway.
type ApplicationGatewayHttpListener struct {
	// CustomErrorConfigurations: Custom error configurations of the HTTP listener.
	CustomErrorConfigurations []ApplicationGatewayCustomError `json:"customErrorConfigurations,omitempty"`

	// FirewallPolicy: Reference to the FirewallPolicy resource.
	FirewallPolicy *SubResource `json:"firewallPolicy,omitempty"`

	// FrontendIPConfiguration: Frontend IP configuration resource of an application gateway.
	FrontendIPConfiguration *SubResource `json:"frontendIPConfiguration,omitempty"`

	// FrontendPort: Frontend port resource of an application gateway.
	FrontendPort *SubResource `json:"frontendPort,omitempty"`

	// HostName: Host name of HTTP listener.
	HostName *string `json:"hostName,omitempty"`

	// HostNames: List of Host names for HTTP Listener that allows special wildcard characters as well.
	HostNames []string `json:"hostNames,omitempty"`

	// Name: Name of the HTTP listener that is unique within an Application Gateway.
	Name *string `json:"name,omitempty"`

	// Protocol: Protocol of the HTTP listener.
	Protocol *ApplicationGatewayProtocol `json:"protocol,omitempty"`

	// RequireServerNameIndication: Applicable only if protocol is https. Enables SNI for multi-hosting.
	RequireServerNameIndication *bool `json:"requireServerNameIndication,omitempty"`

	// SslCertificate: SSL certificate resource of an application gateway.
	SslCertificate *SubResource `json:"sslCertificate,omitempty"`

	// SslProfile: SSL profile resource of the application gateway.
	SslProfile *SubResource `json:"sslProfile,omitempty"`
}

var _ genruntime.ARMTransformer = &ApplicationGatewayHttpListener{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (listener *ApplicationGatewayHttpListener) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if listener == nil {
		return nil, nil
	}
	result := &arm.ApplicationGatewayHttpListener{}

	// Set property "Name":
	if listener.Name != nil {
		name := *listener.Name
		result.Name = &name
	}

	// Set property "Properties":
	if listener.CustomErrorConfigurations != nil ||
		listener.FirewallPolicy != nil ||
		listener.FrontendIPConfiguration != nil ||
		listener.FrontendPort != nil ||
		listener.HostName != nil ||
		listener.HostNames != nil ||
		listener.Protocol != nil ||
		listener.RequireServerNameIndication != nil ||
		listener.SslCertificate != nil ||
		listener.SslProfile != nil {
		result.Properties = &arm.ApplicationGatewayHttpListenerPropertiesFormat{}
	}
	for _, item := range listener.CustomErrorConfigurations {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.CustomErrorConfigurations = append(result.Properties.CustomErrorConfigurations, *item_ARM.(*arm.ApplicationGatewayCustomError))
	}
	if listener.FirewallPolicy != nil {
		firewallPolicy_ARM, err := (*listener.FirewallPolicy).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		firewallPolicy := *firewallPolicy_ARM.(*arm.SubResource)
		result.Properties.FirewallPolicy = &firewallPolicy
	}
	if listener.FrontendIPConfiguration != nil {
		frontendIPConfiguration_ARM, err := (*listener.FrontendIPConfiguration).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		frontendIPConfiguration := *frontendIPConfiguration_ARM.(*arm.SubResource)
		result.Properties.FrontendIPConfiguration = &frontendIPConfiguration
	}
	if listener.FrontendPort != nil {
		frontendPort_ARM, err := (*listener.FrontendPort).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		frontendPort := *frontendPort_ARM.(*arm.SubResource)
		result.Properties.FrontendPort = &frontendPort
	}
	if listener.HostName != nil {
		hostName := *listener.HostName
		result.Properties.HostName = &hostName
	}
	for _, item := range listener.HostNames {
		result.Properties.HostNames = append(result.Properties.HostNames, item)
	}
	if listener.Protocol != nil {
		var temp string
		temp = string(*listener.Protocol)
		protocol := arm.ApplicationGatewayProtocol(temp)
		result.Properties.Protocol = &protocol
	}
	if listener.RequireServerNameIndication != nil {
		requireServerNameIndication := *listener.RequireServerNameIndication
		result.Properties.RequireServerNameIndication = &requireServerNameIndication
	}
	if listener.SslCertificate != nil {
		sslCertificate_ARM, err := (*listener.SslCertificate).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		sslCertificate := *sslCertificate_ARM.(*arm.SubResource)
		result.Properties.SslCertificate = &sslCertificate
	}
	if listener.SslProfile != nil {
		sslProfile_ARM, err := (*listener.SslProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		sslProfile := *sslProfile_ARM.(*arm.SubResource)
		result.Properties.SslProfile = &sslProfile
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (listener *ApplicationGatewayHttpListener) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApplicationGatewayHttpListener{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (listener *ApplicationGatewayHttpListener) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApplicationGatewayHttpListener)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApplicationGatewayHttpListener, got %T", armInput)
	}

	// Set property "CustomErrorConfigurations":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.CustomErrorConfigurations {
			var item1 ApplicationGatewayCustomError
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			listener.CustomErrorConfigurations = append(listener.CustomErrorConfigurations, item1)
		}
	}

	// Set property "FirewallPolicy":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.FirewallPolicy != nil {
			var firewallPolicy1 SubResource
			err := firewallPolicy1.PopulateFromARM(owner, *typedInput.Properties.FirewallPolicy)
			if err != nil {
				return err
			}
			firewallPolicy := firewallPolicy1
			listener.FirewallPolicy = &firewallPolicy
		}
	}

	// Set property "FrontendIPConfiguration":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.FrontendIPConfiguration != nil {
			var frontendIPConfiguration1 SubResource
			err := frontendIPConfiguration1.PopulateFromARM(owner, *typedInput.Properties.FrontendIPConfiguration)
			if err != nil {
				return err
			}
			frontendIPConfiguration := frontendIPConfiguration1
			listener.FrontendIPConfiguration = &frontendIPConfiguration
		}
	}

	// Set property "FrontendPort":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.FrontendPort != nil {
			var frontendPort1 SubResource
			err := frontendPort1.PopulateFromARM(owner, *typedInput.Properties.FrontendPort)
			if err != nil {
				return err
			}
			frontendPort := frontendPort1
			listener.FrontendPort = &frontendPort
		}
	}

	// Set property "HostName":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HostName != nil {
			hostName := *typedInput.Properties.HostName
			listener.HostName = &hostName
		}
	}

	// Set property "HostNames":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.HostNames {
			listener.HostNames = append(listener.HostNames, item)
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		listener.Name = &name
	}

	// Set property "Protocol":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Protocol != nil {
			var temp string
			temp = string(*typedInput.Properties.Protocol)
			protocol := ApplicationGatewayProtocol(temp)
			listener.Protocol = &protocol
		}
	}

	// Set property "RequireServerNameIndication":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.RequireServerNameIndication != nil {
			requireServerNameIndication := *typedInput.Properties.RequireServerNameIndication
			listener.RequireServerNameIndication = &requireServerNameIndication
		}
	}

	// Set property "SslCertificate":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.SslCertificate != nil {
			var sslCertificate1 SubResource
			err := sslCertificate1.PopulateFromARM(owner, *typedInput.Properties.SslCertificate)
			if err != nil {
				return err
			}
			sslCertificate := sslCertificate1
			listener.SslCertificate = &sslCertificate
		}
	}

	// Set property "SslProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.SslProfile != nil {
			var sslProfile1 SubResource
			err := sslProfile1.PopulateFromARM(owner, *typedInput.Properties.SslProfile)
			if err != nil {
				return err
			}
			sslProfile := sslProfile1
			listener.SslProfile = &sslProfile
		}
	}

	// No error
	return nil
}

// AssignProperties_From_ApplicationGatewayHttpListener populates our ApplicationGatewayHttpListener from the provided source ApplicationGatewayHttpListener
func (listener *ApplicationGatewayHttpListener) AssignProperties_From_ApplicationGatewayHttpListener(source *storage.ApplicationGatewayHttpListener) error {

	// CustomErrorConfigurations
	if source.CustomErrorConfigurations != nil {
		customErrorConfigurationList := make([]ApplicationGatewayCustomError, len(source.CustomErrorConfigurations))
		for customErrorConfigurationIndex, customErrorConfigurationItem := range source.CustomErrorConfigurations {
			// Shadow the loop variable to avoid aliasing
			customErrorConfigurationItem := customErrorConfigurationItem
			var customErrorConfiguration ApplicationGatewayCustomError
			err := customErrorConfiguration.AssignProperties_From_ApplicationGatewayCustomError(&customErrorConfigurationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ApplicationGatewayCustomError() to populate field CustomErrorConfigurations")
			}
			customErrorConfigurationList[customErrorConfigurationIndex] = customErrorConfiguration
		}
		listener.CustomErrorConfigurations = customErrorConfigurationList
	} else {
		listener.CustomErrorConfigurations = nil
	}

	// FirewallPolicy
	if source.FirewallPolicy != nil {
		var firewallPolicy SubResource
		err := firewallPolicy.AssignProperties_From_SubResource(source.FirewallPolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field FirewallPolicy")
		}
		listener.FirewallPolicy = &firewallPolicy
	} else {
		listener.FirewallPolicy = nil
	}

	// FrontendIPConfiguration
	if source.FrontendIPConfiguration != nil {
		var frontendIPConfiguration SubResource
		err := frontendIPConfiguration.AssignProperties_From_SubResource(source.FrontendIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field FrontendIPConfiguration")
		}
		listener.FrontendIPConfiguration = &frontendIPConfiguration
	} else {
		listener.FrontendIPConfiguration = nil
	}

	// FrontendPort
	if source.FrontendPort != nil {
		var frontendPort SubResource
		err := frontendPort.AssignProperties_From_SubResource(source.FrontendPort)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field FrontendPort")
		}
		listener.FrontendPort = &frontendPort
	} else {
		listener.FrontendPort = nil
	}

	// HostName
	listener.HostName = genruntime.ClonePointerToString(source.HostName)

	// HostNames
	listener.HostNames = genruntime.CloneSliceOfString(source.HostNames)

	// Name
	listener.Name = genruntime.ClonePointerToString(source.Name)

	// Protocol
	if source.Protocol != nil {
		protocol := *source.Protocol
		protocolTemp := genruntime.ToEnum(protocol, applicationGatewayProtocol_Values)
		listener.Protocol = &protocolTemp
	} else {
		listener.Protocol = nil
	}

	// RequireServerNameIndication
	if source.RequireServerNameIndication != nil {
		requireServerNameIndication := *source.RequireServerNameIndication
		listener.RequireServerNameIndication = &requireServerNameIndication
	} else {
		listener.RequireServerNameIndication = nil
	}

	// SslCertificate
	if source.SslCertificate != nil {
		var sslCertificate SubResource
		err := sslCertificate.AssignProperties_From_SubResource(source.SslCertificate)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field SslCertificate")
		}
		listener.SslCertificate = &sslCertificate
	} else {
		listener.SslCertificate = nil
	}

	// SslProfile
	if source.SslProfile != nil {
		var sslProfile SubResource
		err := sslProfile.AssignProperties_From_SubResource(source.SslProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field SslProfile")
		}
		listener.SslProfile = &sslProfile
	} else {
		listener.SslProfile = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ApplicationGatewayHttpListener populates the provided destination ApplicationGatewayHttpListener from our ApplicationGatewayHttpListener
func (listener *ApplicationGatewayHttpListener) AssignProperties_To_ApplicationGatewayHttpListener(destination *storage.ApplicationGatewayHttpListener) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CustomErrorConfigurations
	if listener.CustomErrorConfigurations != nil {
		customErrorConfigurationList := make([]storage.ApplicationGatewayCustomError, len(listener.CustomErrorConfigurations))
		for customErrorConfigurationIndex, customErrorConfigurationItem := range listener.CustomErrorConfigurations {
			// Shadow the loop variable to avoid aliasing
			customErrorConfigurationItem := customErrorConfigurationItem
			var customErrorConfiguration storage.ApplicationGatewayCustomError
			err := customErrorConfigurationItem.AssignProperties_To_ApplicationGatewayCustomError(&customErrorConfiguration)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ApplicationGatewayCustomError() to populate field CustomErrorConfigurations")
			}
			customErrorConfigurationList[customErrorConfigurationIndex] = customErrorConfiguration
		}
		destination.CustomErrorConfigurations = customErrorConfigurationList
	} else {
		destination.CustomErrorConfigurations = nil
	}

	// FirewallPolicy
	if listener.FirewallPolicy != nil {
		var firewallPolicy storage.SubResource
		err := listener.FirewallPolicy.AssignProperties_To_SubResource(&firewallPolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field FirewallPolicy")
		}
		destination.FirewallPolicy = &firewallPolicy
	} else {
		destination.FirewallPolicy = nil
	}

	// FrontendIPConfiguration
	if listener.FrontendIPConfiguration != nil {
		var frontendIPConfiguration storage.SubResource
		err := listener.FrontendIPConfiguration.AssignProperties_To_SubResource(&frontendIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field FrontendIPConfiguration")
		}
		destination.FrontendIPConfiguration = &frontendIPConfiguration
	} else {
		destination.FrontendIPConfiguration = nil
	}

	// FrontendPort
	if listener.FrontendPort != nil {
		var frontendPort storage.SubResource
		err := listener.FrontendPort.AssignProperties_To_SubResource(&frontendPort)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field FrontendPort")
		}
		destination.FrontendPort = &frontendPort
	} else {
		destination.FrontendPort = nil
	}

	// HostName
	destination.HostName = genruntime.ClonePointerToString(listener.HostName)

	// HostNames
	destination.HostNames = genruntime.CloneSliceOfString(listener.HostNames)

	// Name
	destination.Name = genruntime.ClonePointerToString(listener.Name)

	// Protocol
	if listener.Protocol != nil {
		protocol := string(*listener.Protocol)
		destination.Protocol = &protocol
	} else {
		destination.Protocol = nil
	}

	// RequireServerNameIndication
	if listener.RequireServerNameIndication != nil {
		requireServerNameIndication := *listener.RequireServerNameIndication
		destination.RequireServerNameIndication = &requireServerNameIndication
	} else {
		destination.RequireServerNameIndication = nil
	}

	// SslCertificate
	if listener.SslCertificate != nil {
		var sslCertificate storage.SubResource
		err := listener.SslCertificate.AssignProperties_To_SubResource(&sslCertificate)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field SslCertificate")
		}
		destination.SslCertificate = &sslCertificate
	} else {
		destination.SslCertificate = nil
	}

	// SslProfile
	if listener.SslProfile != nil {
		var sslProfile storage.SubResource
		err := listener.SslProfile.AssignProperties_To_SubResource(&sslProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field SslProfile")
		}
		destination.SslProfile = &sslProfile
	} else {
		destination.SslProfile = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ApplicationGatewayHttpListener_STATUS populates our ApplicationGatewayHttpListener from the provided source ApplicationGatewayHttpListener_STATUS
func (listener *ApplicationGatewayHttpListener) Initialize_From_ApplicationGatewayHttpListener_STATUS(source *ApplicationGatewayHttpListener_STATUS) error {

	// No error
	return nil
}

// Http listener of an application gateway.
type ApplicationGatewayHttpListener_STATUS struct {
	// Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &ApplicationGatewayHttpListener_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (listener *ApplicationGatewayHttpListener_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApplicationGatewayHttpListener_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (listener *ApplicationGatewayHttpListener_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApplicationGatewayHttpListener_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApplicationGatewayHttpListener_STATUS, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		listener.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_ApplicationGatewayHttpListener_STATUS populates our ApplicationGatewayHttpListener_STATUS from the provided source ApplicationGatewayHttpListener_STATUS
func (listener *ApplicationGatewayHttpListener_STATUS) AssignProperties_From_ApplicationGatewayHttpListener_STATUS(source *storage.ApplicationGatewayHttpListener_STATUS) error {

	// Id
	listener.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_ApplicationGatewayHttpListener_STATUS populates the provided destination ApplicationGatewayHttpListener_STATUS from our ApplicationGatewayHttpListener_STATUS
func (listener *ApplicationGatewayHttpListener_STATUS) AssignProperties_To_ApplicationGatewayHttpListener_STATUS(destination *storage.ApplicationGatewayHttpListener_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(listener.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// IP configuration of an application gateway. Currently 1 public and 1 private IP configuration is allowed.
type ApplicationGatewayIPConfiguration_ApplicationGateway_SubResourceEmbedded struct {
	// Name: Name of the IP configuration that is unique within an Application Gateway.
	Name *string `json:"name,omitempty"`

	// Subnet: Reference to the subnet resource. A subnet from where application gateway gets its private address.
	Subnet *SubResource `json:"subnet,omitempty"`
}

var _ genruntime.ARMTransformer = &ApplicationGatewayIPConfiguration_ApplicationGateway_SubResourceEmbedded{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (embedded *ApplicationGatewayIPConfiguration_ApplicationGateway_SubResourceEmbedded) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if embedded == nil {
		return nil, nil
	}
	result := &arm.ApplicationGatewayIPConfiguration_ApplicationGateway_SubResourceEmbedded{}

	// Set property "Name":
	if embedded.Name != nil {
		name := *embedded.Name
		result.Name = &name
	}

	// Set property "Properties":
	if embedded.Subnet != nil {
		result.Properties = &arm.ApplicationGatewayIPConfigurationPropertiesFormat{}
	}
	if embedded.Subnet != nil {
		subnet_ARM, err := (*embedded.Subnet).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		subnet := *subnet_ARM.(*arm.SubResource)
		result.Properties.Subnet = &subnet
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (embedded *ApplicationGatewayIPConfiguration_ApplicationGateway_SubResourceEmbedded) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApplicationGatewayIPConfiguration_ApplicationGateway_SubResourceEmbedded{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (embedded *ApplicationGatewayIPConfiguration_ApplicationGateway_SubResourceEmbedded) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApplicationGatewayIPConfiguration_ApplicationGateway_SubResourceEmbedded)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApplicationGatewayIPConfiguration_ApplicationGateway_SubResourceEmbedded, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		embedded.Name = &name
	}

	// Set property "Subnet":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Subnet != nil {
			var subnet1 SubResource
			err := subnet1.PopulateFromARM(owner, *typedInput.Properties.Subnet)
			if err != nil {
				return err
			}
			subnet := subnet1
			embedded.Subnet = &subnet
		}
	}

	// No error
	return nil
}

// AssignProperties_From_ApplicationGatewayIPConfiguration_ApplicationGateway_SubResourceEmbedded populates our ApplicationGatewayIPConfiguration_ApplicationGateway_SubResourceEmbedded from the provided source ApplicationGatewayIPConfiguration_ApplicationGateway_SubResourceEmbedded
func (embedded *ApplicationGatewayIPConfiguration_ApplicationGateway_SubResourceEmbedded) AssignProperties_From_ApplicationGatewayIPConfiguration_ApplicationGateway_SubResourceEmbedded(source *storage.ApplicationGatewayIPConfiguration_ApplicationGateway_SubResourceEmbedded) error {

	// Name
	embedded.Name = genruntime.ClonePointerToString(source.Name)

	// Subnet
	if source.Subnet != nil {
		var subnet SubResource
		err := subnet.AssignProperties_From_SubResource(source.Subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field Subnet")
		}
		embedded.Subnet = &subnet
	} else {
		embedded.Subnet = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ApplicationGatewayIPConfiguration_ApplicationGateway_SubResourceEmbedded populates the provided destination ApplicationGatewayIPConfiguration_ApplicationGateway_SubResourceEmbedded from our ApplicationGatewayIPConfiguration_ApplicationGateway_SubResourceEmbedded
func (embedded *ApplicationGatewayIPConfiguration_ApplicationGateway_SubResourceEmbedded) AssignProperties_To_ApplicationGatewayIPConfiguration_ApplicationGateway_SubResourceEmbedded(destination *storage.ApplicationGatewayIPConfiguration_ApplicationGateway_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(embedded.Name)

	// Subnet
	if embedded.Subnet != nil {
		var subnet storage.SubResource
		err := embedded.Subnet.AssignProperties_To_SubResource(&subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field Subnet")
		}
		destination.Subnet = &subnet
	} else {
		destination.Subnet = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ApplicationGatewayIPConfiguration_STATUS_ApplicationGateway_SubResourceEmbedded populates our ApplicationGatewayIPConfiguration_ApplicationGateway_SubResourceEmbedded from the provided source ApplicationGatewayIPConfiguration_STATUS_ApplicationGateway_SubResourceEmbedded
func (embedded *ApplicationGatewayIPConfiguration_ApplicationGateway_SubResourceEmbedded) Initialize_From_ApplicationGatewayIPConfiguration_STATUS_ApplicationGateway_SubResourceEmbedded(source *ApplicationGatewayIPConfiguration_STATUS_ApplicationGateway_SubResourceEmbedded) error {

	// No error
	return nil
}

// IP configuration of an application gateway. Currently 1 public and 1 private IP configuration is allowed.
type ApplicationGatewayIPConfiguration_STATUS_ApplicationGateway_SubResourceEmbedded struct {
	// Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &ApplicationGatewayIPConfiguration_STATUS_ApplicationGateway_SubResourceEmbedded{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (embedded *ApplicationGatewayIPConfiguration_STATUS_ApplicationGateway_SubResourceEmbedded) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApplicationGatewayIPConfiguration_STATUS_ApplicationGateway_SubResourceEmbedded{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (embedded *ApplicationGatewayIPConfiguration_STATUS_ApplicationGateway_SubResourceEmbedded) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApplicationGatewayIPConfiguration_STATUS_ApplicationGateway_SubResourceEmbedded)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApplicationGatewayIPConfiguration_STATUS_ApplicationGateway_SubResourceEmbedded, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		embedded.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_ApplicationGatewayIPConfiguration_STATUS_ApplicationGateway_SubResourceEmbedded populates our ApplicationGatewayIPConfiguration_STATUS_ApplicationGateway_SubResourceEmbedded from the provided source ApplicationGatewayIPConfiguration_STATUS_ApplicationGateway_SubResourceEmbedded
func (embedded *ApplicationGatewayIPConfiguration_STATUS_ApplicationGateway_SubResourceEmbedded) AssignProperties_From_ApplicationGatewayIPConfiguration_STATUS_ApplicationGateway_SubResourceEmbedded(source *storage.ApplicationGatewayIPConfiguration_STATUS_ApplicationGateway_SubResourceEmbedded) error {

	// Id
	embedded.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_ApplicationGatewayIPConfiguration_STATUS_ApplicationGateway_SubResourceEmbedded populates the provided destination ApplicationGatewayIPConfiguration_STATUS_ApplicationGateway_SubResourceEmbedded from our ApplicationGatewayIPConfiguration_STATUS_ApplicationGateway_SubResourceEmbedded
func (embedded *ApplicationGatewayIPConfiguration_STATUS_ApplicationGateway_SubResourceEmbedded) AssignProperties_To_ApplicationGatewayIPConfiguration_STATUS_ApplicationGateway_SubResourceEmbedded(destination *storage.ApplicationGatewayIPConfiguration_STATUS_ApplicationGateway_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(embedded.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Listener of an application gateway.
type ApplicationGatewayListener struct {
	// FrontendIPConfiguration: Frontend IP configuration resource of an application gateway.
	FrontendIPConfiguration *SubResource `json:"frontendIPConfiguration,omitempty"`

	// FrontendPort: Frontend port resource of an application gateway.
	FrontendPort *SubResource `json:"frontendPort,omitempty"`

	// Name: Name of the listener that is unique within an Application Gateway.
	Name *string `json:"name,omitempty"`

	// Protocol: Protocol of the listener.
	Protocol *ApplicationGatewayProtocol `json:"protocol,omitempty"`

	// SslCertificate: SSL certificate resource of an application gateway.
	SslCertificate *SubResource `json:"sslCertificate,omitempty"`

	// SslProfile: SSL profile resource of the application gateway.
	SslProfile *SubResource `json:"sslProfile,omitempty"`
}

var _ genruntime.ARMTransformer = &ApplicationGatewayListener{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (listener *ApplicationGatewayListener) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if listener == nil {
		return nil, nil
	}
	result := &arm.ApplicationGatewayListener{}

	// Set property "Name":
	if listener.Name != nil {
		name := *listener.Name
		result.Name = &name
	}

	// Set property "Properties":
	if listener.FrontendIPConfiguration != nil ||
		listener.FrontendPort != nil ||
		listener.Protocol != nil ||
		listener.SslCertificate != nil ||
		listener.SslProfile != nil {
		result.Properties = &arm.ApplicationGatewayListenerPropertiesFormat{}
	}
	if listener.FrontendIPConfiguration != nil {
		frontendIPConfiguration_ARM, err := (*listener.FrontendIPConfiguration).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		frontendIPConfiguration := *frontendIPConfiguration_ARM.(*arm.SubResource)
		result.Properties.FrontendIPConfiguration = &frontendIPConfiguration
	}
	if listener.FrontendPort != nil {
		frontendPort_ARM, err := (*listener.FrontendPort).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		frontendPort := *frontendPort_ARM.(*arm.SubResource)
		result.Properties.FrontendPort = &frontendPort
	}
	if listener.Protocol != nil {
		var temp string
		temp = string(*listener.Protocol)
		protocol := arm.ApplicationGatewayProtocol(temp)
		result.Properties.Protocol = &protocol
	}
	if listener.SslCertificate != nil {
		sslCertificate_ARM, err := (*listener.SslCertificate).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		sslCertificate := *sslCertificate_ARM.(*arm.SubResource)
		result.Properties.SslCertificate = &sslCertificate
	}
	if listener.SslProfile != nil {
		sslProfile_ARM, err := (*listener.SslProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		sslProfile := *sslProfile_ARM.(*arm.SubResource)
		result.Properties.SslProfile = &sslProfile
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (listener *ApplicationGatewayListener) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApplicationGatewayListener{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (listener *ApplicationGatewayListener) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApplicationGatewayListener)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApplicationGatewayListener, got %T", armInput)
	}

	// Set property "FrontendIPConfiguration":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.FrontendIPConfiguration != nil {
			var frontendIPConfiguration1 SubResource
			err := frontendIPConfiguration1.PopulateFromARM(owner, *typedInput.Properties.FrontendIPConfiguration)
			if err != nil {
				return err
			}
			frontendIPConfiguration := frontendIPConfiguration1
			listener.FrontendIPConfiguration = &frontendIPConfiguration
		}
	}

	// Set property "FrontendPort":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.FrontendPort != nil {
			var frontendPort1 SubResource
			err := frontendPort1.PopulateFromARM(owner, *typedInput.Properties.FrontendPort)
			if err != nil {
				return err
			}
			frontendPort := frontendPort1
			listener.FrontendPort = &frontendPort
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		listener.Name = &name
	}

	// Set property "Protocol":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Protocol != nil {
			var temp string
			temp = string(*typedInput.Properties.Protocol)
			protocol := ApplicationGatewayProtocol(temp)
			listener.Protocol = &protocol
		}
	}

	// Set property "SslCertificate":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.SslCertificate != nil {
			var sslCertificate1 SubResource
			err := sslCertificate1.PopulateFromARM(owner, *typedInput.Properties.SslCertificate)
			if err != nil {
				return err
			}
			sslCertificate := sslCertificate1
			listener.SslCertificate = &sslCertificate
		}
	}

	// Set property "SslProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.SslProfile != nil {
			var sslProfile1 SubResource
			err := sslProfile1.PopulateFromARM(owner, *typedInput.Properties.SslProfile)
			if err != nil {
				return err
			}
			sslProfile := sslProfile1
			listener.SslProfile = &sslProfile
		}
	}

	// No error
	return nil
}

// AssignProperties_From_ApplicationGatewayListener populates our ApplicationGatewayListener from the provided source ApplicationGatewayListener
func (listener *ApplicationGatewayListener) AssignProperties_From_ApplicationGatewayListener(source *storage.ApplicationGatewayListener) error {

	// FrontendIPConfiguration
	if source.FrontendIPConfiguration != nil {
		var frontendIPConfiguration SubResource
		err := frontendIPConfiguration.AssignProperties_From_SubResource(source.FrontendIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field FrontendIPConfiguration")
		}
		listener.FrontendIPConfiguration = &frontendIPConfiguration
	} else {
		listener.FrontendIPConfiguration = nil
	}

	// FrontendPort
	if source.FrontendPort != nil {
		var frontendPort SubResource
		err := frontendPort.AssignProperties_From_SubResource(source.FrontendPort)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field FrontendPort")
		}
		listener.FrontendPort = &frontendPort
	} else {
		listener.FrontendPort = nil
	}

	// Name
	listener.Name = genruntime.ClonePointerToString(source.Name)

	// Protocol
	if source.Protocol != nil {
		protocol := *source.Protocol
		protocolTemp := genruntime.ToEnum(protocol, applicationGatewayProtocol_Values)
		listener.Protocol = &protocolTemp
	} else {
		listener.Protocol = nil
	}

	// SslCertificate
	if source.SslCertificate != nil {
		var sslCertificate SubResource
		err := sslCertificate.AssignProperties_From_SubResource(source.SslCertificate)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field SslCertificate")
		}
		listener.SslCertificate = &sslCertificate
	} else {
		listener.SslCertificate = nil
	}

	// SslProfile
	if source.SslProfile != nil {
		var sslProfile SubResource
		err := sslProfile.AssignProperties_From_SubResource(source.SslProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field SslProfile")
		}
		listener.SslProfile = &sslProfile
	} else {
		listener.SslProfile = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ApplicationGatewayListener populates the provided destination ApplicationGatewayListener from our ApplicationGatewayListener
func (listener *ApplicationGatewayListener) AssignProperties_To_ApplicationGatewayListener(destination *storage.ApplicationGatewayListener) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// FrontendIPConfiguration
	if listener.FrontendIPConfiguration != nil {
		var frontendIPConfiguration storage.SubResource
		err := listener.FrontendIPConfiguration.AssignProperties_To_SubResource(&frontendIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field FrontendIPConfiguration")
		}
		destination.FrontendIPConfiguration = &frontendIPConfiguration
	} else {
		destination.FrontendIPConfiguration = nil
	}

	// FrontendPort
	if listener.FrontendPort != nil {
		var frontendPort storage.SubResource
		err := listener.FrontendPort.AssignProperties_To_SubResource(&frontendPort)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field FrontendPort")
		}
		destination.FrontendPort = &frontendPort
	} else {
		destination.FrontendPort = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(listener.Name)

	// Protocol
	if listener.Protocol != nil {
		protocol := string(*listener.Protocol)
		destination.Protocol = &protocol
	} else {
		destination.Protocol = nil
	}

	// SslCertificate
	if listener.SslCertificate != nil {
		var sslCertificate storage.SubResource
		err := listener.SslCertificate.AssignProperties_To_SubResource(&sslCertificate)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field SslCertificate")
		}
		destination.SslCertificate = &sslCertificate
	} else {
		destination.SslCertificate = nil
	}

	// SslProfile
	if listener.SslProfile != nil {
		var sslProfile storage.SubResource
		err := listener.SslProfile.AssignProperties_To_SubResource(&sslProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field SslProfile")
		}
		destination.SslProfile = &sslProfile
	} else {
		destination.SslProfile = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ApplicationGatewayListener_STATUS populates our ApplicationGatewayListener from the provided source ApplicationGatewayListener_STATUS
func (listener *ApplicationGatewayListener) Initialize_From_ApplicationGatewayListener_STATUS(source *ApplicationGatewayListener_STATUS) error {

	// No error
	return nil
}

// Listener of an application gateway.
type ApplicationGatewayListener_STATUS struct {
	// Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &ApplicationGatewayListener_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (listener *ApplicationGatewayListener_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApplicationGatewayListener_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (listener *ApplicationGatewayListener_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApplicationGatewayListener_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApplicationGatewayListener_STATUS, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		listener.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_ApplicationGatewayListener_STATUS populates our ApplicationGatewayListener_STATUS from the provided source ApplicationGatewayListener_STATUS
func (listener *ApplicationGatewayListener_STATUS) AssignProperties_From_ApplicationGatewayListener_STATUS(source *storage.ApplicationGatewayListener_STATUS) error {

	// Id
	listener.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_ApplicationGatewayListener_STATUS populates the provided destination ApplicationGatewayListener_STATUS from our ApplicationGatewayListener_STATUS
func (listener *ApplicationGatewayListener_STATUS) AssignProperties_To_ApplicationGatewayListener_STATUS(destination *storage.ApplicationGatewayListener_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(listener.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Load Distribution Policy of an application gateway.
type ApplicationGatewayLoadDistributionPolicy struct {
	// LoadDistributionAlgorithm: Load Distribution Targets resource of an application gateway.
	LoadDistributionAlgorithm *ApplicationGatewayLoadDistributionAlgorithmEnum `json:"loadDistributionAlgorithm,omitempty"`

	// LoadDistributionTargets: Load Distribution Targets resource of an application gateway.
	LoadDistributionTargets []ApplicationGatewayLoadDistributionTarget `json:"loadDistributionTargets,omitempty"`

	// Name: Name of the load distribution policy that is unique within an Application Gateway.
	Name *string `json:"name,omitempty"`
}

var _ genruntime.ARMTransformer = &ApplicationGatewayLoadDistributionPolicy{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (policy *ApplicationGatewayLoadDistributionPolicy) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if policy == nil {
		return nil, nil
	}
	result := &arm.ApplicationGatewayLoadDistributionPolicy{}

	// Set property "Name":
	if policy.Name != nil {
		name := *policy.Name
		result.Name = &name
	}

	// Set property "Properties":
	if policy.LoadDistributionAlgorithm != nil || policy.LoadDistributionTargets != nil {
		result.Properties = &arm.ApplicationGatewayLoadDistributionPolicyPropertiesFormat{}
	}
	if policy.LoadDistributionAlgorithm != nil {
		var temp string
		temp = string(*policy.LoadDistributionAlgorithm)
		loadDistributionAlgorithm := arm.ApplicationGatewayLoadDistributionAlgorithmEnum(temp)
		result.Properties.LoadDistributionAlgorithm = &loadDistributionAlgorithm
	}
	for _, item := range policy.LoadDistributionTargets {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.LoadDistributionTargets = append(result.Properties.LoadDistributionTargets, *item_ARM.(*arm.ApplicationGatewayLoadDistributionTarget))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (policy *ApplicationGatewayLoadDistributionPolicy) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApplicationGatewayLoadDistributionPolicy{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (policy *ApplicationGatewayLoadDistributionPolicy) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApplicationGatewayLoadDistributionPolicy)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApplicationGatewayLoadDistributionPolicy, got %T", armInput)
	}

	// Set property "LoadDistributionAlgorithm":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.LoadDistributionAlgorithm != nil {
			var temp string
			temp = string(*typedInput.Properties.LoadDistributionAlgorithm)
			loadDistributionAlgorithm := ApplicationGatewayLoadDistributionAlgorithmEnum(temp)
			policy.LoadDistributionAlgorithm = &loadDistributionAlgorithm
		}
	}

	// Set property "LoadDistributionTargets":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.LoadDistributionTargets {
			var item1 ApplicationGatewayLoadDistributionTarget
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			policy.LoadDistributionTargets = append(policy.LoadDistributionTargets, item1)
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		policy.Name = &name
	}

	// No error
	return nil
}

// AssignProperties_From_ApplicationGatewayLoadDistributionPolicy populates our ApplicationGatewayLoadDistributionPolicy from the provided source ApplicationGatewayLoadDistributionPolicy
func (policy *ApplicationGatewayLoadDistributionPolicy) AssignProperties_From_ApplicationGatewayLoadDistributionPolicy(source *storage.ApplicationGatewayLoadDistributionPolicy) error {

	// LoadDistributionAlgorithm
	if source.LoadDistributionAlgorithm != nil {
		loadDistributionAlgorithm := *source.LoadDistributionAlgorithm
		loadDistributionAlgorithmTemp := genruntime.ToEnum(loadDistributionAlgorithm, applicationGatewayLoadDistributionAlgorithmEnum_Values)
		policy.LoadDistributionAlgorithm = &loadDistributionAlgorithmTemp
	} else {
		policy.LoadDistributionAlgorithm = nil
	}

	// LoadDistributionTargets
	if source.LoadDistributionTargets != nil {
		loadDistributionTargetList := make([]ApplicationGatewayLoadDistributionTarget, len(source.LoadDistributionTargets))
		for loadDistributionTargetIndex, loadDistributionTargetItem := range source.LoadDistributionTargets {
			// Shadow the loop variable to avoid aliasing
			loadDistributionTargetItem := loadDistributionTargetItem
			var loadDistributionTarget ApplicationGatewayLoadDistributionTarget
			err := loadDistributionTarget.AssignProperties_From_ApplicationGatewayLoadDistributionTarget(&loadDistributionTargetItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ApplicationGatewayLoadDistributionTarget() to populate field LoadDistributionTargets")
			}
			loadDistributionTargetList[loadDistributionTargetIndex] = loadDistributionTarget
		}
		policy.LoadDistributionTargets = loadDistributionTargetList
	} else {
		policy.LoadDistributionTargets = nil
	}

	// Name
	policy.Name = genruntime.ClonePointerToString(source.Name)

	// No error
	return nil
}

// AssignProperties_To_ApplicationGatewayLoadDistributionPolicy populates the provided destination ApplicationGatewayLoadDistributionPolicy from our ApplicationGatewayLoadDistributionPolicy
func (policy *ApplicationGatewayLoadDistributionPolicy) AssignProperties_To_ApplicationGatewayLoadDistributionPolicy(destination *storage.ApplicationGatewayLoadDistributionPolicy) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// LoadDistributionAlgorithm
	if policy.LoadDistributionAlgorithm != nil {
		loadDistributionAlgorithm := string(*policy.LoadDistributionAlgorithm)
		destination.LoadDistributionAlgorithm = &loadDistributionAlgorithm
	} else {
		destination.LoadDistributionAlgorithm = nil
	}

	// LoadDistributionTargets
	if policy.LoadDistributionTargets != nil {
		loadDistributionTargetList := make([]storage.ApplicationGatewayLoadDistributionTarget, len(policy.LoadDistributionTargets))
		for loadDistributionTargetIndex, loadDistributionTargetItem := range policy.LoadDistributionTargets {
			// Shadow the loop variable to avoid aliasing
			loadDistributionTargetItem := loadDistributionTargetItem
			var loadDistributionTarget storage.ApplicationGatewayLoadDistributionTarget
			err := loadDistributionTargetItem.AssignProperties_To_ApplicationGatewayLoadDistributionTarget(&loadDistributionTarget)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ApplicationGatewayLoadDistributionTarget() to populate field LoadDistributionTargets")
			}
			loadDistributionTargetList[loadDistributionTargetIndex] = loadDistributionTarget
		}
		destination.LoadDistributionTargets = loadDistributionTargetList
	} else {
		destination.LoadDistributionTargets = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(policy.Name)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ApplicationGatewayLoadDistributionPolicy_STATUS populates our ApplicationGatewayLoadDistributionPolicy from the provided source ApplicationGatewayLoadDistributionPolicy_STATUS
func (policy *ApplicationGatewayLoadDistributionPolicy) Initialize_From_ApplicationGatewayLoadDistributionPolicy_STATUS(source *ApplicationGatewayLoadDistributionPolicy_STATUS) error {

	// No error
	return nil
}

// Load Distribution Policy of an application gateway.
type ApplicationGatewayLoadDistributionPolicy_STATUS struct {
	// Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &ApplicationGatewayLoadDistributionPolicy_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (policy *ApplicationGatewayLoadDistributionPolicy_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApplicationGatewayLoadDistributionPolicy_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (policy *ApplicationGatewayLoadDistributionPolicy_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApplicationGatewayLoadDistributionPolicy_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApplicationGatewayLoadDistributionPolicy_STATUS, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		policy.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_ApplicationGatewayLoadDistributionPolicy_STATUS populates our ApplicationGatewayLoadDistributionPolicy_STATUS from the provided source ApplicationGatewayLoadDistributionPolicy_STATUS
func (policy *ApplicationGatewayLoadDistributionPolicy_STATUS) AssignProperties_From_ApplicationGatewayLoadDistributionPolicy_STATUS(source *storage.ApplicationGatewayLoadDistributionPolicy_STATUS) error {

	// Id
	policy.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_ApplicationGatewayLoadDistributionPolicy_STATUS populates the provided destination ApplicationGatewayLoadDistributionPolicy_STATUS from our ApplicationGatewayLoadDistributionPolicy_STATUS
func (policy *ApplicationGatewayLoadDistributionPolicy_STATUS) AssignProperties_To_ApplicationGatewayLoadDistributionPolicy_STATUS(destination *storage.ApplicationGatewayLoadDistributionPolicy_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(policy.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Details for configuring operator behavior. Fields in this struct are interpreted by the operator directly rather than being passed to Azure
type ApplicationGatewayOperatorSpec struct {
	// ConfigMapExpressions: configures where to place operator written dynamic ConfigMaps (created with CEL expressions).
	ConfigMapExpressions []*core.DestinationExpression `json:"configMapExpressions,omitempty"`

	// SecretExpressions: configures where to place operator written dynamic secrets (created with CEL expressions).
	SecretExpressions []*core.DestinationExpression `json:"secretExpressions,omitempty"`
}

// AssignProperties_From_ApplicationGatewayOperatorSpec populates our ApplicationGatewayOperatorSpec from the provided source ApplicationGatewayOperatorSpec
func (operator *ApplicationGatewayOperatorSpec) AssignProperties_From_ApplicationGatewayOperatorSpec(source *storage.ApplicationGatewayOperatorSpec) error {

	// ConfigMapExpressions
	if source.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(source.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range source.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		operator.ConfigMapExpressions = configMapExpressionList
	} else {
		operator.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if source.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(source.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range source.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		operator.SecretExpressions = secretExpressionList
	} else {
		operator.SecretExpressions = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ApplicationGatewayOperatorSpec populates the provided destination ApplicationGatewayOperatorSpec from our ApplicationGatewayOperatorSpec
func (operator *ApplicationGatewayOperatorSpec) AssignProperties_To_ApplicationGatewayOperatorSpec(destination *storage.ApplicationGatewayOperatorSpec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ConfigMapExpressions
	if operator.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(operator.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range operator.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		destination.ConfigMapExpressions = configMapExpressionList
	} else {
		destination.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if operator.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(operator.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range operator.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		destination.SecretExpressions = secretExpressionList
	} else {
		destination.SecretExpressions = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Private Endpoint connection on an application gateway.
type ApplicationGatewayPrivateEndpointConnection_STATUS struct {
	// Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &ApplicationGatewayPrivateEndpointConnection_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (connection *ApplicationGatewayPrivateEndpointConnection_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApplicationGatewayPrivateEndpointConnection_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (connection *ApplicationGatewayPrivateEndpointConnection_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApplicationGatewayPrivateEndpointConnection_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApplicationGatewayPrivateEndpointConnection_STATUS, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		connection.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_ApplicationGatewayPrivateEndpointConnection_STATUS populates our ApplicationGatewayPrivateEndpointConnection_STATUS from the provided source ApplicationGatewayPrivateEndpointConnection_STATUS
func (connection *ApplicationGatewayPrivateEndpointConnection_STATUS) AssignProperties_From_ApplicationGatewayPrivateEndpointConnection_STATUS(source *storage.ApplicationGatewayPrivateEndpointConnection_STATUS) error {

	// Id
	connection.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_ApplicationGatewayPrivateEndpointConnection_STATUS populates the provided destination ApplicationGatewayPrivateEndpointConnection_STATUS from our ApplicationGatewayPrivateEndpointConnection_STATUS
func (connection *ApplicationGatewayPrivateEndpointConnection_STATUS) AssignProperties_To_ApplicationGatewayPrivateEndpointConnection_STATUS(destination *storage.ApplicationGatewayPrivateEndpointConnection_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(connection.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Private Link Configuration on an application gateway.
type ApplicationGatewayPrivateLinkConfiguration struct {
	// IpConfigurations: An array of application gateway private link ip configurations.
	IpConfigurations []ApplicationGatewayPrivateLinkIpConfiguration `json:"ipConfigurations,omitempty"`

	// Name: Name of the private link configuration that is unique within an Application Gateway.
	Name *string `json:"name,omitempty"`
}

var _ genruntime.ARMTransformer = &ApplicationGatewayPrivateLinkConfiguration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (configuration *ApplicationGatewayPrivateLinkConfiguration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if configuration == nil {
		return nil, nil
	}
	result := &arm.ApplicationGatewayPrivateLinkConfiguration{}

	// Set property "Name":
	if configuration.Name != nil {
		name := *configuration.Name
		result.Name = &name
	}

	// Set property "Properties":
	if configuration.IpConfigurations != nil {
		result.Properties = &arm.ApplicationGatewayPrivateLinkConfigurationProperties{}
	}
	for _, item := range configuration.IpConfigurations {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.IpConfigurations = append(result.Properties.IpConfigurations, *item_ARM.(*arm.ApplicationGatewayPrivateLinkIpConfiguration))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *ApplicationGatewayPrivateLinkConfiguration) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApplicationGatewayPrivateLinkConfiguration{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *ApplicationGatewayPrivateLinkConfiguration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApplicationGatewayPrivateLinkConfiguration)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApplicationGatewayPrivateLinkConfiguration, got %T", armInput)
	}

	// Set property "IpConfigurations":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.IpConfigurations {
			var item1 ApplicationGatewayPrivateLinkIpConfiguration
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			configuration.IpConfigurations = append(configuration.IpConfigurations, item1)
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		configuration.Name = &name
	}

	// No error
	return nil
}

// AssignProperties_From_ApplicationGatewayPrivateLinkConfiguration populates our ApplicationGatewayPrivateLinkConfiguration from the provided source ApplicationGatewayPrivateLinkConfiguration
func (configuration *ApplicationGatewayPrivateLinkConfiguration) AssignProperties_From_ApplicationGatewayPrivateLinkConfiguration(source *storage.ApplicationGatewayPrivateLinkConfiguration) error {

	// IpConfigurations
	if source.IpConfigurations != nil {
		ipConfigurationList := make([]ApplicationGatewayPrivateLinkIpConfiguration, len(source.IpConfigurations))
		for ipConfigurationIndex, ipConfigurationItem := range source.IpConfigurations {
			// Shadow the loop variable to avoid aliasing
			ipConfigurationItem := ipConfigurationItem
			var ipConfiguration ApplicationGatewayPrivateLinkIpConfiguration
			err := ipConfiguration.AssignProperties_From_ApplicationGatewayPrivateLinkIpConfiguration(&ipConfigurationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ApplicationGatewayPrivateLinkIpConfiguration() to populate field IpConfigurations")
			}
			ipConfigurationList[ipConfigurationIndex] = ipConfiguration
		}
		configuration.IpConfigurations = ipConfigurationList
	} else {
		configuration.IpConfigurations = nil
	}

	// Name
	configuration.Name = genruntime.ClonePointerToString(source.Name)

	// No error
	return nil
}

// AssignProperties_To_ApplicationGatewayPrivateLinkConfiguration populates the provided destination ApplicationGatewayPrivateLinkConfiguration from our ApplicationGatewayPrivateLinkConfiguration
func (configuration *ApplicationGatewayPrivateLinkConfiguration) AssignProperties_To_ApplicationGatewayPrivateLinkConfiguration(destination *storage.ApplicationGatewayPrivateLinkConfiguration) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// IpConfigurations
	if configuration.IpConfigurations != nil {
		ipConfigurationList := make([]storage.ApplicationGatewayPrivateLinkIpConfiguration, len(configuration.IpConfigurations))
		for ipConfigurationIndex, ipConfigurationItem := range configuration.IpConfigurations {
			// Shadow the loop variable to avoid aliasing
			ipConfigurationItem := ipConfigurationItem
			var ipConfiguration storage.ApplicationGatewayPrivateLinkIpConfiguration
			err := ipConfigurationItem.AssignProperties_To_ApplicationGatewayPrivateLinkIpConfiguration(&ipConfiguration)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ApplicationGatewayPrivateLinkIpConfiguration() to populate field IpConfigurations")
			}
			ipConfigurationList[ipConfigurationIndex] = ipConfiguration
		}
		destination.IpConfigurations = ipConfigurationList
	} else {
		destination.IpConfigurations = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(configuration.Name)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ApplicationGatewayPrivateLinkConfiguration_STATUS populates our ApplicationGatewayPrivateLinkConfiguration from the provided source ApplicationGatewayPrivateLinkConfiguration_STATUS
func (configuration *ApplicationGatewayPrivateLinkConfiguration) Initialize_From_ApplicationGatewayPrivateLinkConfiguration_STATUS(source *ApplicationGatewayPrivateLinkConfiguration_STATUS) error {

	// No error
	return nil
}

// Private Link Configuration on an application gateway.
type ApplicationGatewayPrivateLinkConfiguration_STATUS struct {
	// Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &ApplicationGatewayPrivateLinkConfiguration_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *ApplicationGatewayPrivateLinkConfiguration_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApplicationGatewayPrivateLinkConfiguration_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *ApplicationGatewayPrivateLinkConfiguration_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApplicationGatewayPrivateLinkConfiguration_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApplicationGatewayPrivateLinkConfiguration_STATUS, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		configuration.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_ApplicationGatewayPrivateLinkConfiguration_STATUS populates our ApplicationGatewayPrivateLinkConfiguration_STATUS from the provided source ApplicationGatewayPrivateLinkConfiguration_STATUS
func (configuration *ApplicationGatewayPrivateLinkConfiguration_STATUS) AssignProperties_From_ApplicationGatewayPrivateLinkConfiguration_STATUS(source *storage.ApplicationGatewayPrivateLinkConfiguration_STATUS) error {

	// Id
	configuration.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_ApplicationGatewayPrivateLinkConfiguration_STATUS populates the provided destination ApplicationGatewayPrivateLinkConfiguration_STATUS from our ApplicationGatewayPrivateLinkConfiguration_STATUS
func (configuration *ApplicationGatewayPrivateLinkConfiguration_STATUS) AssignProperties_To_ApplicationGatewayPrivateLinkConfiguration_STATUS(destination *storage.ApplicationGatewayPrivateLinkConfiguration_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(configuration.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Probe of the application gateway.
type ApplicationGatewayProbe struct {
	// Host: Host name to send the probe to.
	Host *string `json:"host,omitempty"`

	// Interval: The probing interval in seconds. This is the time interval between two consecutive probes. Acceptable values
	// are from 1 second to 86400 seconds.
	Interval *int `json:"interval,omitempty"`

	// Match: Criterion for classifying a healthy probe response.
	Match *ApplicationGatewayProbeHealthResponseMatch `json:"match,omitempty"`

	// MinServers: Minimum number of servers that are always marked healthy. Default value is 0.
	MinServers *int `json:"minServers,omitempty"`

	// Name: Name of the probe that is unique within an Application Gateway.
	Name *string `json:"name,omitempty"`

	// Path: Relative path of probe. Valid path starts from '/'. Probe is sent to <Protocol>://<host>:<port><path>.
	Path *string `json:"path,omitempty"`

	// PickHostNameFromBackendHttpSettings: Whether the host header should be picked from the backend http settings. Default
	// value is false.
	PickHostNameFromBackendHttpSettings *bool `json:"pickHostNameFromBackendHttpSettings,omitempty"`

	// PickHostNameFromBackendSettings: Whether the server name indication should be picked from the backend settings for Tls
	// protocol. Default value is false.
	PickHostNameFromBackendSettings *bool `json:"pickHostNameFromBackendSettings,omitempty"`

	// +kubebuilder:validation:Maximum=65535
	// +kubebuilder:validation:Minimum=1
	// Port: Custom port which will be used for probing the backend servers. The valid value ranges from 1 to 65535. In case
	// not set, port from http settings will be used. This property is valid for Standard_v2 and WAF_v2 only.
	Port *int `json:"port,omitempty"`

	// Protocol: The protocol used for the probe.
	Protocol *ApplicationGatewayProtocol `json:"protocol,omitempty"`

	// Timeout: The probe timeout in seconds. Probe marked as failed if valid response is not received with this timeout
	// period. Acceptable values are from 1 second to 86400 seconds.
	Timeout *int `json:"timeout,omitempty"`

	// UnhealthyThreshold: The probe retry count. Backend server is marked down after consecutive probe failure count reaches
	// UnhealthyThreshold. Acceptable values are from 1 second to 20.
	UnhealthyThreshold *int `json:"unhealthyThreshold,omitempty"`
}

var _ genruntime.ARMTransformer = &ApplicationGatewayProbe{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (probe *ApplicationGatewayProbe) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if probe == nil {
		return nil, nil
	}
	result := &arm.ApplicationGatewayProbe{}

	// Set property "Name":
	if probe.Name != nil {
		name := *probe.Name
		result.Name = &name
	}

	// Set property "Properties":
	if probe.Host != nil ||
		probe.Interval != nil ||
		probe.Match != nil ||
		probe.MinServers != nil ||
		probe.Path != nil ||
		probe.PickHostNameFromBackendHttpSettings != nil ||
		probe.PickHostNameFromBackendSettings != nil ||
		probe.Port != nil ||
		probe.Protocol != nil ||
		probe.Timeout != nil ||
		probe.UnhealthyThreshold != nil {
		result.Properties = &arm.ApplicationGatewayProbePropertiesFormat{}
	}
	if probe.Host != nil {
		host := *probe.Host
		result.Properties.Host = &host
	}
	if probe.Interval != nil {
		interval := *probe.Interval
		result.Properties.Interval = &interval
	}
	if probe.Match != nil {
		match_ARM, err := (*probe.Match).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		match := *match_ARM.(*arm.ApplicationGatewayProbeHealthResponseMatch)
		result.Properties.Match = &match
	}
	if probe.MinServers != nil {
		minServers := *probe.MinServers
		result.Properties.MinServers = &minServers
	}
	if probe.Path != nil {
		path := *probe.Path
		result.Properties.Path = &path
	}
	if probe.PickHostNameFromBackendHttpSettings != nil {
		pickHostNameFromBackendHttpSettings := *probe.PickHostNameFromBackendHttpSettings
		result.Properties.PickHostNameFromBackendHttpSettings = &pickHostNameFromBackendHttpSettings
	}
	if probe.PickHostNameFromBackendSettings != nil {
		pickHostNameFromBackendSettings := *probe.PickHostNameFromBackendSettings
		result.Properties.PickHostNameFromBackendSettings = &pickHostNameFromBackendSettings
	}
	if probe.Port != nil {
		port := *probe.Port
		result.Properties.Port = &port
	}
	if probe.Protocol != nil {
		var temp string
		temp = string(*probe.Protocol)
		protocol := arm.ApplicationGatewayProtocol(temp)
		result.Properties.Protocol = &protocol
	}
	if probe.Timeout != nil {
		timeout := *probe.Timeout
		result.Properties.Timeout = &timeout
	}
	if probe.UnhealthyThreshold != nil {
		unhealthyThreshold := *probe.UnhealthyThreshold
		result.Properties.UnhealthyThreshold = &unhealthyThreshold
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (probe *ApplicationGatewayProbe) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApplicationGatewayProbe{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (probe *ApplicationGatewayProbe) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApplicationGatewayProbe)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApplicationGatewayProbe, got %T", armInput)
	}

	// Set property "Host":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Host != nil {
			host := *typedInput.Properties.Host
			probe.Host = &host
		}
	}

	// Set property "Interval":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Interval != nil {
			interval := *typedInput.Properties.Interval
			probe.Interval = &interval
		}
	}

	// Set property "Match":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Match != nil {
			var match1 ApplicationGatewayProbeHealthResponseMatch
			err := match1.PopulateFromARM(owner, *typedInput.Properties.Match)
			if err != nil {
				return err
			}
			match := match1
			probe.Match = &match
		}
	}

	// Set property "MinServers":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MinServers != nil {
			minServers := *typedInput.Properties.MinServers
			probe.MinServers = &minServers
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		probe.Name = &name
	}

	// Set property "Path":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Path != nil {
			path := *typedInput.Properties.Path
			probe.Path = &path
		}
	}

	// Set property "PickHostNameFromBackendHttpSettings":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PickHostNameFromBackendHttpSettings != nil {
			pickHostNameFromBackendHttpSettings := *typedInput.Properties.PickHostNameFromBackendHttpSettings
			probe.PickHostNameFromBackendHttpSettings = &pickHostNameFromBackendHttpSettings
		}
	}

	// Set property "PickHostNameFromBackendSettings":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PickHostNameFromBackendSettings != nil {
			pickHostNameFromBackendSettings := *typedInput.Properties.PickHostNameFromBackendSettings
			probe.PickHostNameFromBackendSettings = &pickHostNameFromBackendSettings
		}
	}

	// Set property "Port":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Port != nil {
			port := *typedInput.Properties.Port
			probe.Port = &port
		}
	}

	// Set property "Protocol":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Protocol != nil {
			var temp string
			temp = string(*typedInput.Properties.Protocol)
			protocol := ApplicationGatewayProtocol(temp)
			probe.Protocol = &protocol
		}
	}

	// Set property "Timeout":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Timeout != nil {
			timeout := *typedInput.Properties.Timeout
			probe.Timeout = &timeout
		}
	}

	// Set property "UnhealthyThreshold":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.UnhealthyThreshold != nil {
			unhealthyThreshold := *typedInput.Properties.UnhealthyThreshold
			probe.UnhealthyThreshold = &unhealthyThreshold
		}
	}

	// No error
	return nil
}

// AssignProperties_From_ApplicationGatewayProbe populates our ApplicationGatewayProbe from the provided source ApplicationGatewayProbe
func (probe *ApplicationGatewayProbe) AssignProperties_From_ApplicationGatewayProbe(source *storage.ApplicationGatewayProbe) error {

	// Host
	probe.Host = genruntime.ClonePointerToString(source.Host)

	// Interval
	probe.Interval = genruntime.ClonePointerToInt(source.Interval)

	// Match
	if source.Match != nil {
		var match ApplicationGatewayProbeHealthResponseMatch
		err := match.AssignProperties_From_ApplicationGatewayProbeHealthResponseMatch(source.Match)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ApplicationGatewayProbeHealthResponseMatch() to populate field Match")
		}
		probe.Match = &match
	} else {
		probe.Match = nil
	}

	// MinServers
	probe.MinServers = genruntime.ClonePointerToInt(source.MinServers)

	// Name
	probe.Name = genruntime.ClonePointerToString(source.Name)

	// Path
	probe.Path = genruntime.ClonePointerToString(source.Path)

	// PickHostNameFromBackendHttpSettings
	if source.PickHostNameFromBackendHttpSettings != nil {
		pickHostNameFromBackendHttpSetting := *source.PickHostNameFromBackendHttpSettings
		probe.PickHostNameFromBackendHttpSettings = &pickHostNameFromBackendHttpSetting
	} else {
		probe.PickHostNameFromBackendHttpSettings = nil
	}

	// PickHostNameFromBackendSettings
	if source.PickHostNameFromBackendSettings != nil {
		pickHostNameFromBackendSetting := *source.PickHostNameFromBackendSettings
		probe.PickHostNameFromBackendSettings = &pickHostNameFromBackendSetting
	} else {
		probe.PickHostNameFromBackendSettings = nil
	}

	// Port
	if source.Port != nil {
		port := *source.Port
		probe.Port = &port
	} else {
		probe.Port = nil
	}

	// Protocol
	if source.Protocol != nil {
		protocol := *source.Protocol
		protocolTemp := genruntime.ToEnum(protocol, applicationGatewayProtocol_Values)
		probe.Protocol = &protocolTemp
	} else {
		probe.Protocol = nil
	}

	// Timeout
	probe.Timeout = genruntime.ClonePointerToInt(source.Timeout)

	// UnhealthyThreshold
	probe.UnhealthyThreshold = genruntime.ClonePointerToInt(source.UnhealthyThreshold)

	// No error
	return nil
}

// AssignProperties_To_ApplicationGatewayProbe populates the provided destination ApplicationGatewayProbe from our ApplicationGatewayProbe
func (probe *ApplicationGatewayProbe) AssignProperties_To_ApplicationGatewayProbe(destination *storage.ApplicationGatewayProbe) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Host
	destination.Host = genruntime.ClonePointerToString(probe.Host)

	// Interval
	destination.Interval = genruntime.ClonePointerToInt(probe.Interval)

	// Match
	if probe.Match != nil {
		var match storage.ApplicationGatewayProbeHealthResponseMatch
		err := probe.Match.AssignProperties_To_ApplicationGatewayProbeHealthResponseMatch(&match)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ApplicationGatewayProbeHealthResponseMatch() to populate field Match")
		}
		destination.Match = &match
	} else {
		destination.Match = nil
	}

	// MinServers
	destination.MinServers = genruntime.ClonePointerToInt(probe.MinServers)

	// Name
	destination.Name = genruntime.ClonePointerToString(probe.Name)

	// Path
	destination.Path = genruntime.ClonePointerToString(probe.Path)

	// PickHostNameFromBackendHttpSettings
	if probe.PickHostNameFromBackendHttpSettings != nil {
		pickHostNameFromBackendHttpSetting := *probe.PickHostNameFromBackendHttpSettings
		destination.PickHostNameFromBackendHttpSettings = &pickHostNameFromBackendHttpSetting
	} else {
		destination.PickHostNameFromBackendHttpSettings = nil
	}

	// PickHostNameFromBackendSettings
	if probe.PickHostNameFromBackendSettings != nil {
		pickHostNameFromBackendSetting := *probe.PickHostNameFromBackendSettings
		destination.PickHostNameFromBackendSettings = &pickHostNameFromBackendSetting
	} else {
		destination.PickHostNameFromBackendSettings = nil
	}

	// Port
	if probe.Port != nil {
		port := *probe.Port
		destination.Port = &port
	} else {
		destination.Port = nil
	}

	// Protocol
	if probe.Protocol != nil {
		protocol := string(*probe.Protocol)
		destination.Protocol = &protocol
	} else {
		destination.Protocol = nil
	}

	// Timeout
	destination.Timeout = genruntime.ClonePointerToInt(probe.Timeout)

	// UnhealthyThreshold
	destination.UnhealthyThreshold = genruntime.ClonePointerToInt(probe.UnhealthyThreshold)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ApplicationGatewayProbe_STATUS populates our ApplicationGatewayProbe from the provided source ApplicationGatewayProbe_STATUS
func (probe *ApplicationGatewayProbe) Initialize_From_ApplicationGatewayProbe_STATUS(source *ApplicationGatewayProbe_STATUS) error {

	// No error
	return nil
}

// Probe of the application gateway.
type ApplicationGatewayProbe_STATUS struct {
	// Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &ApplicationGatewayProbe_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (probe *ApplicationGatewayProbe_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApplicationGatewayProbe_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (probe *ApplicationGatewayProbe_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApplicationGatewayProbe_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApplicationGatewayProbe_STATUS, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		probe.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_ApplicationGatewayProbe_STATUS populates our ApplicationGatewayProbe_STATUS from the provided source ApplicationGatewayProbe_STATUS
func (probe *ApplicationGatewayProbe_STATUS) AssignProperties_From_ApplicationGatewayProbe_STATUS(source *storage.ApplicationGatewayProbe_STATUS) error {

	// Id
	probe.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_ApplicationGatewayProbe_STATUS populates the provided destination ApplicationGatewayProbe_STATUS from our ApplicationGatewayProbe_STATUS
func (probe *ApplicationGatewayProbe_STATUS) AssignProperties_To_ApplicationGatewayProbe_STATUS(destination *storage.ApplicationGatewayProbe_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(probe.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ApplicationGatewayPropertiesFormat_OperationalState_STATUS string

const (
	ApplicationGatewayPropertiesFormat_OperationalState_STATUS_Running  = ApplicationGatewayPropertiesFormat_OperationalState_STATUS("Running")
	ApplicationGatewayPropertiesFormat_OperationalState_STATUS_Starting = ApplicationGatewayPropertiesFormat_OperationalState_STATUS("Starting")
	ApplicationGatewayPropertiesFormat_OperationalState_STATUS_Stopped  = ApplicationGatewayPropertiesFormat_OperationalState_STATUS("Stopped")
	ApplicationGatewayPropertiesFormat_OperationalState_STATUS_Stopping = ApplicationGatewayPropertiesFormat_OperationalState_STATUS("Stopping")
)

// Mapping from string to ApplicationGatewayPropertiesFormat_OperationalState_STATUS
var applicationGatewayPropertiesFormat_OperationalState_STATUS_Values = map[string]ApplicationGatewayPropertiesFormat_OperationalState_STATUS{
	"running":  ApplicationGatewayPropertiesFormat_OperationalState_STATUS_Running,
	"starting": ApplicationGatewayPropertiesFormat_OperationalState_STATUS_Starting,
	"stopped":  ApplicationGatewayPropertiesFormat_OperationalState_STATUS_Stopped,
	"stopping": ApplicationGatewayPropertiesFormat_OperationalState_STATUS_Stopping,
}

// The current provisioning state.
type ApplicationGatewayProvisioningState_STATUS string

const (
	ApplicationGatewayProvisioningState_STATUS_Deleting  = ApplicationGatewayProvisioningState_STATUS("Deleting")
	ApplicationGatewayProvisioningState_STATUS_Failed    = ApplicationGatewayProvisioningState_STATUS("Failed")
	ApplicationGatewayProvisioningState_STATUS_Succeeded = ApplicationGatewayProvisioningState_STATUS("Succeeded")
	ApplicationGatewayProvisioningState_STATUS_Updating  = ApplicationGatewayProvisioningState_STATUS("Updating")
)

// Mapping from string to ApplicationGatewayProvisioningState_STATUS
var applicationGatewayProvisioningState_STATUS_Values = map[string]ApplicationGatewayProvisioningState_STATUS{
	"deleting":  ApplicationGatewayProvisioningState_STATUS_Deleting,
	"failed":    ApplicationGatewayProvisioningState_STATUS_Failed,
	"succeeded": ApplicationGatewayProvisioningState_STATUS_Succeeded,
	"updating":  ApplicationGatewayProvisioningState_STATUS_Updating,
}

// Redirect configuration of an application gateway.
type ApplicationGatewayRedirectConfiguration struct {
	// IncludePath: Include path in the redirected url.
	IncludePath *bool `json:"includePath,omitempty"`

	// IncludeQueryString: Include query string in the redirected url.
	IncludeQueryString *bool `json:"includeQueryString,omitempty"`

	// Name: Name of the redirect configuration that is unique within an Application Gateway.
	Name *string `json:"name,omitempty"`

	// PathRules: Path rules specifying redirect configuration.
	PathRules []SubResource `json:"pathRules,omitempty"`

	// RedirectType: HTTP redirection type.
	RedirectType *RedirectTypeEnum `json:"redirectType,omitempty"`

	// RequestRoutingRules: Request routing specifying redirect configuration.
	RequestRoutingRules []SubResource `json:"requestRoutingRules,omitempty"`

	// TargetListener: Reference to a listener to redirect the request to.
	TargetListener *SubResource `json:"targetListener,omitempty"`

	// TargetUrl: Url to redirect the request to.
	TargetUrl *string `json:"targetUrl,omitempty"`

	// UrlPathMaps: Url path maps specifying default redirect configuration.
	UrlPathMaps []SubResource `json:"urlPathMaps,omitempty"`
}

var _ genruntime.ARMTransformer = &ApplicationGatewayRedirectConfiguration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (configuration *ApplicationGatewayRedirectConfiguration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if configuration == nil {
		return nil, nil
	}
	result := &arm.ApplicationGatewayRedirectConfiguration{}

	// Set property "Name":
	if configuration.Name != nil {
		name := *configuration.Name
		result.Name = &name
	}

	// Set property "Properties":
	if configuration.IncludePath != nil ||
		configuration.IncludeQueryString != nil ||
		configuration.PathRules != nil ||
		configuration.RedirectType != nil ||
		configuration.RequestRoutingRules != nil ||
		configuration.TargetListener != nil ||
		configuration.TargetUrl != nil ||
		configuration.UrlPathMaps != nil {
		result.Properties = &arm.ApplicationGatewayRedirectConfigurationPropertiesFormat{}
	}
	if configuration.IncludePath != nil {
		includePath := *configuration.IncludePath
		result.Properties.IncludePath = &includePath
	}
	if configuration.IncludeQueryString != nil {
		includeQueryString := *configuration.IncludeQueryString
		result.Properties.IncludeQueryString = &includeQueryString
	}
	for _, item := range configuration.PathRules {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.PathRules = append(result.Properties.PathRules, *item_ARM.(*arm.SubResource))
	}
	if configuration.RedirectType != nil {
		var temp string
		temp = string(*configuration.RedirectType)
		redirectType := arm.RedirectTypeEnum(temp)
		result.Properties.RedirectType = &redirectType
	}
	for _, item := range configuration.RequestRoutingRules {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.RequestRoutingRules = append(result.Properties.RequestRoutingRules, *item_ARM.(*arm.SubResource))
	}
	if configuration.TargetListener != nil {
		targetListener_ARM, err := (*configuration.TargetListener).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		targetListener := *targetListener_ARM.(*arm.SubResource)
		result.Properties.TargetListener = &targetListener
	}
	if configuration.TargetUrl != nil {
		targetUrl := *configuration.TargetUrl
		result.Properties.TargetUrl = &targetUrl
	}
	for _, item := range configuration.UrlPathMaps {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.UrlPathMaps = append(result.Properties.UrlPathMaps, *item_ARM.(*arm.SubResource))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *ApplicationGatewayRedirectConfiguration) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApplicationGatewayRedirectConfiguration{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *ApplicationGatewayRedirectConfiguration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApplicationGatewayRedirectConfiguration)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApplicationGatewayRedirectConfiguration, got %T", armInput)
	}

	// Set property "IncludePath":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IncludePath != nil {
			includePath := *typedInput.Properties.IncludePath
			configuration.IncludePath = &includePath
		}
	}

	// Set property "IncludeQueryString":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IncludeQueryString != nil {
			includeQueryString := *typedInput.Properties.IncludeQueryString
			configuration.IncludeQueryString = &includeQueryString
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		configuration.Name = &name
	}

	// Set property "PathRules":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.PathRules {
			var item1 SubResource
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			configuration.PathRules = append(configuration.PathRules, item1)
		}
	}

	// Set property "RedirectType":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.RedirectType != nil {
			var temp string
			temp = string(*typedInput.Properties.RedirectType)
			redirectType := RedirectTypeEnum(temp)
			configuration.RedirectType = &redirectType
		}
	}

	// Set property "RequestRoutingRules":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.RequestRoutingRules {
			var item1 SubResource
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			configuration.RequestRoutingRules = append(configuration.RequestRoutingRules, item1)
		}
	}

	// Set property "TargetListener":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.TargetListener != nil {
			var targetListener1 SubResource
			err := targetListener1.PopulateFromARM(owner, *typedInput.Properties.TargetListener)
			if err != nil {
				return err
			}
			targetListener := targetListener1
			configuration.TargetListener = &targetListener
		}
	}

	// Set property "TargetUrl":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.TargetUrl != nil {
			targetUrl := *typedInput.Properties.TargetUrl
			configuration.TargetUrl = &targetUrl
		}
	}

	// Set property "UrlPathMaps":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.UrlPathMaps {
			var item1 SubResource
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			configuration.UrlPathMaps = append(configuration.UrlPathMaps, item1)
		}
	}

	// No error
	return nil
}

// AssignProperties_From_ApplicationGatewayRedirectConfiguration populates our ApplicationGatewayRedirectConfiguration from the provided source ApplicationGatewayRedirectConfiguration
func (configuration *ApplicationGatewayRedirectConfiguration) AssignProperties_From_ApplicationGatewayRedirectConfiguration(source *storage.ApplicationGatewayRedirectConfiguration) error {

	// IncludePath
	if source.IncludePath != nil {
		includePath := *source.IncludePath
		configuration.IncludePath = &includePath
	} else {
		configuration.IncludePath = nil
	}

	// IncludeQueryString
	if source.IncludeQueryString != nil {
		includeQueryString := *source.IncludeQueryString
		configuration.IncludeQueryString = &includeQueryString
	} else {
		configuration.IncludeQueryString = nil
	}

	// Name
	configuration.Name = genruntime.ClonePointerToString(source.Name)

	// PathRules
	if source.PathRules != nil {
		pathRuleList := make([]SubResource, len(source.PathRules))
		for pathRuleIndex, pathRuleItem := range source.PathRules {
			// Shadow the loop variable to avoid aliasing
			pathRuleItem := pathRuleItem
			var pathRule SubResource
			err := pathRule.AssignProperties_From_SubResource(&pathRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field PathRules")
			}
			pathRuleList[pathRuleIndex] = pathRule
		}
		configuration.PathRules = pathRuleList
	} else {
		configuration.PathRules = nil
	}

	// RedirectType
	if source.RedirectType != nil {
		redirectType := *source.RedirectType
		redirectTypeTemp := genruntime.ToEnum(redirectType, redirectTypeEnum_Values)
		configuration.RedirectType = &redirectTypeTemp
	} else {
		configuration.RedirectType = nil
	}

	// RequestRoutingRules
	if source.RequestRoutingRules != nil {
		requestRoutingRuleList := make([]SubResource, len(source.RequestRoutingRules))
		for requestRoutingRuleIndex, requestRoutingRuleItem := range source.RequestRoutingRules {
			// Shadow the loop variable to avoid aliasing
			requestRoutingRuleItem := requestRoutingRuleItem
			var requestRoutingRule SubResource
			err := requestRoutingRule.AssignProperties_From_SubResource(&requestRoutingRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field RequestRoutingRules")
			}
			requestRoutingRuleList[requestRoutingRuleIndex] = requestRoutingRule
		}
		configuration.RequestRoutingRules = requestRoutingRuleList
	} else {
		configuration.RequestRoutingRules = nil
	}

	// TargetListener
	if source.TargetListener != nil {
		var targetListener SubResource
		err := targetListener.AssignProperties_From_SubResource(source.TargetListener)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field TargetListener")
		}
		configuration.TargetListener = &targetListener
	} else {
		configuration.TargetListener = nil
	}

	// TargetUrl
	configuration.TargetUrl = genruntime.ClonePointerToString(source.TargetUrl)

	// UrlPathMaps
	if source.UrlPathMaps != nil {
		urlPathMapList := make([]SubResource, len(source.UrlPathMaps))
		for urlPathMapIndex, urlPathMapItem := range source.UrlPathMaps {
			// Shadow the loop variable to avoid aliasing
			urlPathMapItem := urlPathMapItem
			var urlPathMap SubResource
			err := urlPathMap.AssignProperties_From_SubResource(&urlPathMapItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field UrlPathMaps")
			}
			urlPathMapList[urlPathMapIndex] = urlPathMap
		}
		configuration.UrlPathMaps = urlPathMapList
	} else {
		configuration.UrlPathMaps = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ApplicationGatewayRedirectConfiguration populates the provided destination ApplicationGatewayRedirectConfiguration from our ApplicationGatewayRedirectConfiguration
func (configuration *ApplicationGatewayRedirectConfiguration) AssignProperties_To_ApplicationGatewayRedirectConfiguration(destination *storage.ApplicationGatewayRedirectConfiguration) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// IncludePath
	if configuration.IncludePath != nil {
		includePath := *configuration.IncludePath
		destination.IncludePath = &includePath
	} else {
		destination.IncludePath = nil
	}

	// IncludeQueryString
	if configuration.IncludeQueryString != nil {
		includeQueryString := *configuration.IncludeQueryString
		destination.IncludeQueryString = &includeQueryString
	} else {
		destination.IncludeQueryString = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(configuration.Name)

	// PathRules
	if configuration.PathRules != nil {
		pathRuleList := make([]storage.SubResource, len(configuration.PathRules))
		for pathRuleIndex, pathRuleItem := range configuration.PathRules {
			// Shadow the loop variable to avoid aliasing
			pathRuleItem := pathRuleItem
			var pathRule storage.SubResource
			err := pathRuleItem.AssignProperties_To_SubResource(&pathRule)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field PathRules")
			}
			pathRuleList[pathRuleIndex] = pathRule
		}
		destination.PathRules = pathRuleList
	} else {
		destination.PathRules = nil
	}

	// RedirectType
	if configuration.RedirectType != nil {
		redirectType := string(*configuration.RedirectType)
		destination.RedirectType = &redirectType
	} else {
		destination.RedirectType = nil
	}

	// RequestRoutingRules
	if configuration.RequestRoutingRules != nil {
		requestRoutingRuleList := make([]storage.SubResource, len(configuration.RequestRoutingRules))
		for requestRoutingRuleIndex, requestRoutingRuleItem := range configuration.RequestRoutingRules {
			// Shadow the loop variable to avoid aliasing
			requestRoutingRuleItem := requestRoutingRuleItem
			var requestRoutingRule storage.SubResource
			err := requestRoutingRuleItem.AssignProperties_To_SubResource(&requestRoutingRule)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field RequestRoutingRules")
			}
			requestRoutingRuleList[requestRoutingRuleIndex] = requestRoutingRule
		}
		destination.RequestRoutingRules = requestRoutingRuleList
	} else {
		destination.RequestRoutingRules = nil
	}

	// TargetListener
	if configuration.TargetListener != nil {
		var targetListener storage.SubResource
		err := configuration.TargetListener.AssignProperties_To_SubResource(&targetListener)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field TargetListener")
		}
		destination.TargetListener = &targetListener
	} else {
		destination.TargetListener = nil
	}

	// TargetUrl
	destination.TargetUrl = genruntime.ClonePointerToString(configuration.TargetUrl)

	// UrlPathMaps
	if configuration.UrlPathMaps != nil {
		urlPathMapList := make([]storage.SubResource, len(configuration.UrlPathMaps))
		for urlPathMapIndex, urlPathMapItem := range configuration.UrlPathMaps {
			// Shadow the loop variable to avoid aliasing
			urlPathMapItem := urlPathMapItem
			var urlPathMap storage.SubResource
			err := urlPathMapItem.AssignProperties_To_SubResource(&urlPathMap)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field UrlPathMaps")
			}
			urlPathMapList[urlPathMapIndex] = urlPathMap
		}
		destination.UrlPathMaps = urlPathMapList
	} else {
		destination.UrlPathMaps = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ApplicationGatewayRedirectConfiguration_STATUS populates our ApplicationGatewayRedirectConfiguration from the provided source ApplicationGatewayRedirectConfiguration_STATUS
func (configuration *ApplicationGatewayRedirectConfiguration) Initialize_From_ApplicationGatewayRedirectConfiguration_STATUS(source *ApplicationGatewayRedirectConfiguration_STATUS) error {

	// No error
	return nil
}

// Redirect configuration of an application gateway.
type ApplicationGatewayRedirectConfiguration_STATUS struct {
	// Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &ApplicationGatewayRedirectConfiguration_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *ApplicationGatewayRedirectConfiguration_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApplicationGatewayRedirectConfiguration_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *ApplicationGatewayRedirectConfiguration_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApplicationGatewayRedirectConfiguration_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApplicationGatewayRedirectConfiguration_STATUS, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		configuration.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_ApplicationGatewayRedirectConfiguration_STATUS populates our ApplicationGatewayRedirectConfiguration_STATUS from the provided source ApplicationGatewayRedirectConfiguration_STATUS
func (configuration *ApplicationGatewayRedirectConfiguration_STATUS) AssignProperties_From_ApplicationGatewayRedirectConfiguration_STATUS(source *storage.ApplicationGatewayRedirectConfiguration_STATUS) error {

	// Id
	configuration.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_ApplicationGatewayRedirectConfiguration_STATUS populates the provided destination ApplicationGatewayRedirectConfiguration_STATUS from our ApplicationGatewayRedirectConfiguration_STATUS
func (configuration *ApplicationGatewayRedirectConfiguration_STATUS) AssignProperties_To_ApplicationGatewayRedirectConfiguration_STATUS(destination *storage.ApplicationGatewayRedirectConfiguration_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(configuration.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Request routing rule of an application gateway.
type ApplicationGatewayRequestRoutingRule struct {
	// BackendAddressPool: Backend address pool resource of the application gateway.
	BackendAddressPool *SubResource `json:"backendAddressPool,omitempty"`

	// BackendHttpSettings: Backend http settings resource of the application gateway.
	BackendHttpSettings *SubResource `json:"backendHttpSettings,omitempty"`

	// HttpListener: Http listener resource of the application gateway.
	HttpListener *SubResource `json:"httpListener,omitempty"`

	// LoadDistributionPolicy: Load Distribution Policy resource of the application gateway.
	LoadDistributionPolicy *SubResource `json:"loadDistributionPolicy,omitempty"`

	// Name: Name of the request routing rule that is unique within an Application Gateway.
	Name *string `json:"name,omitempty"`

	// +kubebuilder:validation:Maximum=20000
	// +kubebuilder:validation:Minimum=1
	// Priority: Priority of the request routing rule.
	Priority *int `json:"priority,omitempty"`

	// RedirectConfiguration: Redirect configuration resource of the application gateway.
	RedirectConfiguration *SubResource `json:"redirectConfiguration,omitempty"`

	// RewriteRuleSet: Rewrite Rule Set resource in Basic rule of the application gateway.
	RewriteRuleSet *SubResource `json:"rewriteRuleSet,omitempty"`

	// RuleType: Rule type.
	RuleType *ApplicationGatewayRequestRoutingRulePropertiesFormat_RuleType `json:"ruleType,omitempty"`

	// UrlPathMap: URL path map resource of the application gateway.
	UrlPathMap *SubResource `json:"urlPathMap,omitempty"`
}

var _ genruntime.ARMTransformer = &ApplicationGatewayRequestRoutingRule{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (rule *ApplicationGatewayRequestRoutingRule) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if rule == nil {
		return nil, nil
	}
	result := &arm.ApplicationGatewayRequestRoutingRule{}

	// Set property "Name":
	if rule.Name != nil {
		name := *rule.Name
		result.Name = &name
	}

	// Set property "Properties":
	if rule.BackendAddressPool != nil ||
		rule.BackendHttpSettings != nil ||
		rule.HttpListener != nil ||
		rule.LoadDistributionPolicy != nil ||
		rule.Priority != nil ||
		rule.RedirectConfiguration != nil ||
		rule.RewriteRuleSet != nil ||
		rule.RuleType != nil ||
		rule.UrlPathMap != nil {
		result.Properties = &arm.ApplicationGatewayRequestRoutingRulePropertiesFormat{}
	}
	if rule.BackendAddressPool != nil {
		backendAddressPool_ARM, err := (*rule.BackendAddressPool).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		backendAddressPool := *backendAddressPool_ARM.(*arm.SubResource)
		result.Properties.BackendAddressPool = &backendAddressPool
	}
	if rule.BackendHttpSettings != nil {
		backendHttpSettings_ARM, err := (*rule.BackendHttpSettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		backendHttpSettings := *backendHttpSettings_ARM.(*arm.SubResource)
		result.Properties.BackendHttpSettings = &backendHttpSettings
	}
	if rule.HttpListener != nil {
		httpListener_ARM, err := (*rule.HttpListener).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		httpListener := *httpListener_ARM.(*arm.SubResource)
		result.Properties.HttpListener = &httpListener
	}
	if rule.LoadDistributionPolicy != nil {
		loadDistributionPolicy_ARM, err := (*rule.LoadDistributionPolicy).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		loadDistributionPolicy := *loadDistributionPolicy_ARM.(*arm.SubResource)
		result.Properties.LoadDistributionPolicy = &loadDistributionPolicy
	}
	if rule.Priority != nil {
		priority := *rule.Priority
		result.Properties.Priority = &priority
	}
	if rule.RedirectConfiguration != nil {
		redirectConfiguration_ARM, err := (*rule.RedirectConfiguration).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		redirectConfiguration := *redirectConfiguration_ARM.(*arm.SubResource)
		result.Properties.RedirectConfiguration = &redirectConfiguration
	}
	if rule.RewriteRuleSet != nil {
		rewriteRuleSet_ARM, err := (*rule.RewriteRuleSet).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		rewriteRuleSet := *rewriteRuleSet_ARM.(*arm.SubResource)
		result.Properties.RewriteRuleSet = &rewriteRuleSet
	}
	if rule.RuleType != nil {
		var temp string
		temp = string(*rule.RuleType)
		ruleType := arm.ApplicationGatewayRequestRoutingRulePropertiesFormat_RuleType(temp)
		result.Properties.RuleType = &ruleType
	}
	if rule.UrlPathMap != nil {
		urlPathMap_ARM, err := (*rule.UrlPathMap).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		urlPathMap := *urlPathMap_ARM.(*arm.SubResource)
		result.Properties.UrlPathMap = &urlPathMap
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *ApplicationGatewayRequestRoutingRule) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApplicationGatewayRequestRoutingRule{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *ApplicationGatewayRequestRoutingRule) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApplicationGatewayRequestRoutingRule)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApplicationGatewayRequestRoutingRule, got %T", armInput)
	}

	// Set property "BackendAddressPool":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.BackendAddressPool != nil {
			var backendAddressPool1 SubResource
			err := backendAddressPool1.PopulateFromARM(owner, *typedInput.Properties.BackendAddressPool)
			if err != nil {
				return err
			}
			backendAddressPool := backendAddressPool1
			rule.BackendAddressPool = &backendAddressPool
		}
	}

	// Set property "BackendHttpSettings":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.BackendHttpSettings != nil {
			var backendHttpSettings1 SubResource
			err := backendHttpSettings1.PopulateFromARM(owner, *typedInput.Properties.BackendHttpSettings)
			if err != nil {
				return err
			}
			backendHttpSettings := backendHttpSettings1
			rule.BackendHttpSettings = &backendHttpSettings
		}
	}

	// Set property "HttpListener":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HttpListener != nil {
			var httpListener1 SubResource
			err := httpListener1.PopulateFromARM(owner, *typedInput.Properties.HttpListener)
			if err != nil {
				return err
			}
			httpListener := httpListener1
			rule.HttpListener = &httpListener
		}
	}

	// Set property "LoadDistributionPolicy":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.LoadDistributionPolicy != nil {
			var loadDistributionPolicy1 SubResource
			err := loadDistributionPolicy1.PopulateFromARM(owner, *typedInput.Properties.LoadDistributionPolicy)
			if err != nil {
				return err
			}
			loadDistributionPolicy := loadDistributionPolicy1
			rule.LoadDistributionPolicy = &loadDistributionPolicy
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		rule.Name = &name
	}

	// Set property "Priority":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Priority != nil {
			priority := *typedInput.Properties.Priority
			rule.Priority = &priority
		}
	}

	// Set property "RedirectConfiguration":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.RedirectConfiguration != nil {
			var redirectConfiguration1 SubResource
			err := redirectConfiguration1.PopulateFromARM(owner, *typedInput.Properties.RedirectConfiguration)
			if err != nil {
				return err
			}
			redirectConfiguration := redirectConfiguration1
			rule.RedirectConfiguration = &redirectConfiguration
		}
	}

	// Set property "RewriteRuleSet":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.RewriteRuleSet != nil {
			var rewriteRuleSet1 SubResource
			err := rewriteRuleSet1.PopulateFromARM(owner, *typedInput.Properties.RewriteRuleSet)
			if err != nil {
				return err
			}
			rewriteRuleSet := rewriteRuleSet1
			rule.RewriteRuleSet = &rewriteRuleSet
		}
	}

	// Set property "RuleType":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.RuleType != nil {
			var temp string
			temp = string(*typedInput.Properties.RuleType)
			ruleType := ApplicationGatewayRequestRoutingRulePropertiesFormat_RuleType(temp)
			rule.RuleType = &ruleType
		}
	}

	// Set property "UrlPathMap":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.UrlPathMap != nil {
			var urlPathMap1 SubResource
			err := urlPathMap1.PopulateFromARM(owner, *typedInput.Properties.UrlPathMap)
			if err != nil {
				return err
			}
			urlPathMap := urlPathMap1
			rule.UrlPathMap = &urlPathMap
		}
	}

	// No error
	return nil
}

// AssignProperties_From_ApplicationGatewayRequestRoutingRule populates our ApplicationGatewayRequestRoutingRule from the provided source ApplicationGatewayRequestRoutingRule
func (rule *ApplicationGatewayRequestRoutingRule) AssignProperties_From_ApplicationGatewayRequestRoutingRule(source *storage.ApplicationGatewayRequestRoutingRule) error {

	// BackendAddressPool
	if source.BackendAddressPool != nil {
		var backendAddressPool SubResource
		err := backendAddressPool.AssignProperties_From_SubResource(source.BackendAddressPool)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field BackendAddressPool")
		}
		rule.BackendAddressPool = &backendAddressPool
	} else {
		rule.BackendAddressPool = nil
	}

	// BackendHttpSettings
	if source.BackendHttpSettings != nil {
		var backendHttpSetting SubResource
		err := backendHttpSetting.AssignProperties_From_SubResource(source.BackendHttpSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field BackendHttpSettings")
		}
		rule.BackendHttpSettings = &backendHttpSetting
	} else {
		rule.BackendHttpSettings = nil
	}

	// HttpListener
	if source.HttpListener != nil {
		var httpListener SubResource
		err := httpListener.AssignProperties_From_SubResource(source.HttpListener)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field HttpListener")
		}
		rule.HttpListener = &httpListener
	} else {
		rule.HttpListener = nil
	}

	// LoadDistributionPolicy
	if source.LoadDistributionPolicy != nil {
		var loadDistributionPolicy SubResource
		err := loadDistributionPolicy.AssignProperties_From_SubResource(source.LoadDistributionPolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field LoadDistributionPolicy")
		}
		rule.LoadDistributionPolicy = &loadDistributionPolicy
	} else {
		rule.LoadDistributionPolicy = nil
	}

	// Name
	rule.Name = genruntime.ClonePointerToString(source.Name)

	// Priority
	if source.Priority != nil {
		priority := *source.Priority
		rule.Priority = &priority
	} else {
		rule.Priority = nil
	}

	// RedirectConfiguration
	if source.RedirectConfiguration != nil {
		var redirectConfiguration SubResource
		err := redirectConfiguration.AssignProperties_From_SubResource(source.RedirectConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field RedirectConfiguration")
		}
		rule.RedirectConfiguration = &redirectConfiguration
	} else {
		rule.RedirectConfiguration = nil
	}

	// RewriteRuleSet
	if source.RewriteRuleSet != nil {
		var rewriteRuleSet SubResource
		err := rewriteRuleSet.AssignProperties_From_SubResource(source.RewriteRuleSet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field RewriteRuleSet")
		}
		rule.RewriteRuleSet = &rewriteRuleSet
	} else {
		rule.RewriteRuleSet = nil
	}

	// RuleType
	if source.RuleType != nil {
		ruleType := *source.RuleType
		ruleTypeTemp := genruntime.ToEnum(ruleType, applicationGatewayRequestRoutingRulePropertiesFormat_RuleType_Values)
		rule.RuleType = &ruleTypeTemp
	} else {
		rule.RuleType = nil
	}

	// UrlPathMap
	if source.UrlPathMap != nil {
		var urlPathMap SubResource
		err := urlPathMap.AssignProperties_From_SubResource(source.UrlPathMap)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field UrlPathMap")
		}
		rule.UrlPathMap = &urlPathMap
	} else {
		rule.UrlPathMap = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ApplicationGatewayRequestRoutingRule populates the provided destination ApplicationGatewayRequestRoutingRule from our ApplicationGatewayRequestRoutingRule
func (rule *ApplicationGatewayRequestRoutingRule) AssignProperties_To_ApplicationGatewayRequestRoutingRule(destination *storage.ApplicationGatewayRequestRoutingRule) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BackendAddressPool
	if rule.BackendAddressPool != nil {
		var backendAddressPool storage.SubResource
		err := rule.BackendAddressPool.AssignProperties_To_SubResource(&backendAddressPool)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field BackendAddressPool")
		}
		destination.BackendAddressPool = &backendAddressPool
	} else {
		destination.BackendAddressPool = nil
	}

	// BackendHttpSettings
	if rule.BackendHttpSettings != nil {
		var backendHttpSetting storage.SubResource
		err := rule.BackendHttpSettings.AssignProperties_To_SubResource(&backendHttpSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field BackendHttpSettings")
		}
		destination.BackendHttpSettings = &backendHttpSetting
	} else {
		destination.BackendHttpSettings = nil
	}

	// HttpListener
	if rule.HttpListener != nil {
		var httpListener storage.SubResource
		err := rule.HttpListener.AssignProperties_To_SubResource(&httpListener)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field HttpListener")
		}
		destination.HttpListener = &httpListener
	} else {
		destination.HttpListener = nil
	}

	// LoadDistributionPolicy
	if rule.LoadDistributionPolicy != nil {
		var loadDistributionPolicy storage.SubResource
		err := rule.LoadDistributionPolicy.AssignProperties_To_SubResource(&loadDistributionPolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field LoadDistributionPolicy")
		}
		destination.LoadDistributionPolicy = &loadDistributionPolicy
	} else {
		destination.LoadDistributionPolicy = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(rule.Name)

	// Priority
	if rule.Priority != nil {
		priority := *rule.Priority
		destination.Priority = &priority
	} else {
		destination.Priority = nil
	}

	// RedirectConfiguration
	if rule.RedirectConfiguration != nil {
		var redirectConfiguration storage.SubResource
		err := rule.RedirectConfiguration.AssignProperties_To_SubResource(&redirectConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field RedirectConfiguration")
		}
		destination.RedirectConfiguration = &redirectConfiguration
	} else {
		destination.RedirectConfiguration = nil
	}

	// RewriteRuleSet
	if rule.RewriteRuleSet != nil {
		var rewriteRuleSet storage.SubResource
		err := rule.RewriteRuleSet.AssignProperties_To_SubResource(&rewriteRuleSet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field RewriteRuleSet")
		}
		destination.RewriteRuleSet = &rewriteRuleSet
	} else {
		destination.RewriteRuleSet = nil
	}

	// RuleType
	if rule.RuleType != nil {
		ruleType := string(*rule.RuleType)
		destination.RuleType = &ruleType
	} else {
		destination.RuleType = nil
	}

	// UrlPathMap
	if rule.UrlPathMap != nil {
		var urlPathMap storage.SubResource
		err := rule.UrlPathMap.AssignProperties_To_SubResource(&urlPathMap)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field UrlPathMap")
		}
		destination.UrlPathMap = &urlPathMap
	} else {
		destination.UrlPathMap = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ApplicationGatewayRequestRoutingRule_STATUS populates our ApplicationGatewayRequestRoutingRule from the provided source ApplicationGatewayRequestRoutingRule_STATUS
func (rule *ApplicationGatewayRequestRoutingRule) Initialize_From_ApplicationGatewayRequestRoutingRule_STATUS(source *ApplicationGatewayRequestRoutingRule_STATUS) error {

	// No error
	return nil
}

// Request routing rule of an application gateway.
type ApplicationGatewayRequestRoutingRule_STATUS struct {
	// Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &ApplicationGatewayRequestRoutingRule_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *ApplicationGatewayRequestRoutingRule_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApplicationGatewayRequestRoutingRule_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *ApplicationGatewayRequestRoutingRule_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApplicationGatewayRequestRoutingRule_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApplicationGatewayRequestRoutingRule_STATUS, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		rule.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_ApplicationGatewayRequestRoutingRule_STATUS populates our ApplicationGatewayRequestRoutingRule_STATUS from the provided source ApplicationGatewayRequestRoutingRule_STATUS
func (rule *ApplicationGatewayRequestRoutingRule_STATUS) AssignProperties_From_ApplicationGatewayRequestRoutingRule_STATUS(source *storage.ApplicationGatewayRequestRoutingRule_STATUS) error {

	// Id
	rule.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_ApplicationGatewayRequestRoutingRule_STATUS populates the provided destination ApplicationGatewayRequestRoutingRule_STATUS from our ApplicationGatewayRequestRoutingRule_STATUS
func (rule *ApplicationGatewayRequestRoutingRule_STATUS) AssignProperties_To_ApplicationGatewayRequestRoutingRule_STATUS(destination *storage.ApplicationGatewayRequestRoutingRule_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(rule.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Rewrite rule set of an application gateway.
type ApplicationGatewayRewriteRuleSet struct {
	// Name: Name of the rewrite rule set that is unique within an Application Gateway.
	Name *string `json:"name,omitempty"`

	// RewriteRules: Rewrite rules in the rewrite rule set.
	RewriteRules []ApplicationGatewayRewriteRule `json:"rewriteRules,omitempty"`
}

var _ genruntime.ARMTransformer = &ApplicationGatewayRewriteRuleSet{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (ruleSet *ApplicationGatewayRewriteRuleSet) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if ruleSet == nil {
		return nil, nil
	}
	result := &arm.ApplicationGatewayRewriteRuleSet{}

	// Set property "Name":
	if ruleSet.Name != nil {
		name := *ruleSet.Name
		result.Name = &name
	}

	// Set property "Properties":
	if ruleSet.RewriteRules != nil {
		result.Properties = &arm.ApplicationGatewayRewriteRuleSetPropertiesFormat{}
	}
	for _, item := range ruleSet.RewriteRules {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.RewriteRules = append(result.Properties.RewriteRules, *item_ARM.(*arm.ApplicationGatewayRewriteRule))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (ruleSet *ApplicationGatewayRewriteRuleSet) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApplicationGatewayRewriteRuleSet{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (ruleSet *ApplicationGatewayRewriteRuleSet) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApplicationGatewayRewriteRuleSet)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApplicationGatewayRewriteRuleSet, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		ruleSet.Name = &name
	}

	// Set property "RewriteRules":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.RewriteRules {
			var item1 ApplicationGatewayRewriteRule
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			ruleSet.RewriteRules = append(ruleSet.RewriteRules, item1)
		}
	}

	// No error
	return nil
}

// AssignProperties_From_ApplicationGatewayRewriteRuleSet populates our ApplicationGatewayRewriteRuleSet from the provided source ApplicationGatewayRewriteRuleSet
func (ruleSet *ApplicationGatewayRewriteRuleSet) AssignProperties_From_ApplicationGatewayRewriteRuleSet(source *storage.ApplicationGatewayRewriteRuleSet) error {

	// Name
	ruleSet.Name = genruntime.ClonePointerToString(source.Name)

	// RewriteRules
	if source.RewriteRules != nil {
		rewriteRuleList := make([]ApplicationGatewayRewriteRule, len(source.RewriteRules))
		for rewriteRuleIndex, rewriteRuleItem := range source.RewriteRules {
			// Shadow the loop variable to avoid aliasing
			rewriteRuleItem := rewriteRuleItem
			var rewriteRule ApplicationGatewayRewriteRule
			err := rewriteRule.AssignProperties_From_ApplicationGatewayRewriteRule(&rewriteRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ApplicationGatewayRewriteRule() to populate field RewriteRules")
			}
			rewriteRuleList[rewriteRuleIndex] = rewriteRule
		}
		ruleSet.RewriteRules = rewriteRuleList
	} else {
		ruleSet.RewriteRules = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ApplicationGatewayRewriteRuleSet populates the provided destination ApplicationGatewayRewriteRuleSet from our ApplicationGatewayRewriteRuleSet
func (ruleSet *ApplicationGatewayRewriteRuleSet) AssignProperties_To_ApplicationGatewayRewriteRuleSet(destination *storage.ApplicationGatewayRewriteRuleSet) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(ruleSet.Name)

	// RewriteRules
	if ruleSet.RewriteRules != nil {
		rewriteRuleList := make([]storage.ApplicationGatewayRewriteRule, len(ruleSet.RewriteRules))
		for rewriteRuleIndex, rewriteRuleItem := range ruleSet.RewriteRules {
			// Shadow the loop variable to avoid aliasing
			rewriteRuleItem := rewriteRuleItem
			var rewriteRule storage.ApplicationGatewayRewriteRule
			err := rewriteRuleItem.AssignProperties_To_ApplicationGatewayRewriteRule(&rewriteRule)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ApplicationGatewayRewriteRule() to populate field RewriteRules")
			}
			rewriteRuleList[rewriteRuleIndex] = rewriteRule
		}
		destination.RewriteRules = rewriteRuleList
	} else {
		destination.RewriteRules = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ApplicationGatewayRewriteRuleSet_STATUS populates our ApplicationGatewayRewriteRuleSet from the provided source ApplicationGatewayRewriteRuleSet_STATUS
func (ruleSet *ApplicationGatewayRewriteRuleSet) Initialize_From_ApplicationGatewayRewriteRuleSet_STATUS(source *ApplicationGatewayRewriteRuleSet_STATUS) error {

	// No error
	return nil
}

// Rewrite rule set of an application gateway.
type ApplicationGatewayRewriteRuleSet_STATUS struct {
	// Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &ApplicationGatewayRewriteRuleSet_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (ruleSet *ApplicationGatewayRewriteRuleSet_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApplicationGatewayRewriteRuleSet_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (ruleSet *ApplicationGatewayRewriteRuleSet_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApplicationGatewayRewriteRuleSet_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApplicationGatewayRewriteRuleSet_STATUS, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		ruleSet.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_ApplicationGatewayRewriteRuleSet_STATUS populates our ApplicationGatewayRewriteRuleSet_STATUS from the provided source ApplicationGatewayRewriteRuleSet_STATUS
func (ruleSet *ApplicationGatewayRewriteRuleSet_STATUS) AssignProperties_From_ApplicationGatewayRewriteRuleSet_STATUS(source *storage.ApplicationGatewayRewriteRuleSet_STATUS) error {

	// Id
	ruleSet.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_ApplicationGatewayRewriteRuleSet_STATUS populates the provided destination ApplicationGatewayRewriteRuleSet_STATUS from our ApplicationGatewayRewriteRuleSet_STATUS
func (ruleSet *ApplicationGatewayRewriteRuleSet_STATUS) AssignProperties_To_ApplicationGatewayRewriteRuleSet_STATUS(destination *storage.ApplicationGatewayRewriteRuleSet_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(ruleSet.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Routing rule of an application gateway.
type ApplicationGatewayRoutingRule struct {
	// BackendAddressPool: Backend address pool resource of the application gateway.
	BackendAddressPool *SubResource `json:"backendAddressPool,omitempty"`

	// BackendSettings: Backend settings resource of the application gateway.
	BackendSettings *SubResource `json:"backendSettings,omitempty"`

	// Listener: Listener resource of the application gateway.
	Listener *SubResource `json:"listener,omitempty"`

	// Name: Name of the routing rule that is unique within an Application Gateway.
	Name *string `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// +kubebuilder:validation:Maximum=20000
	// +kubebuilder:validation:Minimum=1
	// Priority: Priority of the routing rule.
	Priority *int `json:"priority,omitempty"`

	// RuleType: Rule type.
	RuleType *ApplicationGatewayRoutingRulePropertiesFormat_RuleType `json:"ruleType,omitempty"`
}

var _ genruntime.ARMTransformer = &ApplicationGatewayRoutingRule{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (rule *ApplicationGatewayRoutingRule) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if rule == nil {
		return nil, nil
	}
	result := &arm.ApplicationGatewayRoutingRule{}

	// Set property "Name":
	if rule.Name != nil {
		name := *rule.Name
		result.Name = &name
	}

	// Set property "Properties":
	if rule.BackendAddressPool != nil ||
		rule.BackendSettings != nil ||
		rule.Listener != nil ||
		rule.Priority != nil ||
		rule.RuleType != nil {
		result.Properties = &arm.ApplicationGatewayRoutingRulePropertiesFormat{}
	}
	if rule.BackendAddressPool != nil {
		backendAddressPool_ARM, err := (*rule.BackendAddressPool).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		backendAddressPool := *backendAddressPool_ARM.(*arm.SubResource)
		result.Properties.BackendAddressPool = &backendAddressPool
	}
	if rule.BackendSettings != nil {
		backendSettings_ARM, err := (*rule.BackendSettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		backendSettings := *backendSettings_ARM.(*arm.SubResource)
		result.Properties.BackendSettings = &backendSettings
	}
	if rule.Listener != nil {
		listener_ARM, err := (*rule.Listener).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		listener := *listener_ARM.(*arm.SubResource)
		result.Properties.Listener = &listener
	}
	if rule.Priority != nil {
		priority := *rule.Priority
		result.Properties.Priority = &priority
	}
	if rule.RuleType != nil {
		var temp string
		temp = string(*rule.RuleType)
		ruleType := arm.ApplicationGatewayRoutingRulePropertiesFormat_RuleType(temp)
		result.Properties.RuleType = &ruleType
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *ApplicationGatewayRoutingRule) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApplicationGatewayRoutingRule{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *ApplicationGatewayRoutingRule) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApplicationGatewayRoutingRule)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApplicationGatewayRoutingRule, got %T", armInput)
	}

	// Set property "BackendAddressPool":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.BackendAddressPool != nil {
			var backendAddressPool1 SubResource
			err := backendAddressPool1.PopulateFromARM(owner, *typedInput.Properties.BackendAddressPool)
			if err != nil {
				return err
			}
			backendAddressPool := backendAddressPool1
			rule.BackendAddressPool = &backendAddressPool
		}
	}

	// Set property "BackendSettings":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.BackendSettings != nil {
			var backendSettings1 SubResource
			err := backendSettings1.PopulateFromARM(owner, *typedInput.Properties.BackendSettings)
			if err != nil {
				return err
			}
			backendSettings := backendSettings1
			rule.BackendSettings = &backendSettings
		}
	}

	// Set property "Listener":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Listener != nil {
			var listener1 SubResource
			err := listener1.PopulateFromARM(owner, *typedInput.Properties.Listener)
			if err != nil {
				return err
			}
			listener := listener1
			rule.Listener = &listener
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		rule.Name = &name
	}

	// Set property "Priority":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Priority != nil {
			priority := *typedInput.Properties.Priority
			rule.Priority = &priority
		}
	}

	// Set property "RuleType":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.RuleType != nil {
			var temp string
			temp = string(*typedInput.Properties.RuleType)
			ruleType := ApplicationGatewayRoutingRulePropertiesFormat_RuleType(temp)
			rule.RuleType = &ruleType
		}
	}

	// No error
	return nil
}

// AssignProperties_From_ApplicationGatewayRoutingRule populates our ApplicationGatewayRoutingRule from the provided source ApplicationGatewayRoutingRule
func (rule *ApplicationGatewayRoutingRule) AssignProperties_From_ApplicationGatewayRoutingRule(source *storage.ApplicationGatewayRoutingRule) error {

	// BackendAddressPool
	if source.BackendAddressPool != nil {
		var backendAddressPool SubResource
		err := backendAddressPool.AssignProperties_From_SubResource(source.BackendAddressPool)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field BackendAddressPool")
		}
		rule.BackendAddressPool = &backendAddressPool
	} else {
		rule.BackendAddressPool = nil
	}

	// BackendSettings
	if source.BackendSettings != nil {
		var backendSetting SubResource
		err := backendSetting.AssignProperties_From_SubResource(source.BackendSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field BackendSettings")
		}
		rule.BackendSettings = &backendSetting
	} else {
		rule.BackendSettings = nil
	}

	// Listener
	if source.Listener != nil {
		var listener SubResource
		err := listener.AssignProperties_From_SubResource(source.Listener)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field Listener")
		}
		rule.Listener = &listener
	} else {
		rule.Listener = nil
	}

	// Name
	rule.Name = genruntime.ClonePointerToString(source.Name)

	// Priority
	if source.Priority != nil {
		priority := *source.Priority
		rule.Priority = &priority
	} else {
		rule.Priority = nil
	}

	// RuleType
	if source.RuleType != nil {
		ruleType := *source.RuleType
		ruleTypeTemp := genruntime.ToEnum(ruleType, applicationGatewayRoutingRulePropertiesFormat_RuleType_Values)
		rule.RuleType = &ruleTypeTemp
	} else {
		rule.RuleType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ApplicationGatewayRoutingRule populates the provided destination ApplicationGatewayRoutingRule from our ApplicationGatewayRoutingRule
func (rule *ApplicationGatewayRoutingRule) AssignProperties_To_ApplicationGatewayRoutingRule(destination *storage.ApplicationGatewayRoutingRule) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BackendAddressPool
	if rule.BackendAddressPool != nil {
		var backendAddressPool storage.SubResource
		err := rule.BackendAddressPool.AssignProperties_To_SubResource(&backendAddressPool)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field BackendAddressPool")
		}
		destination.BackendAddressPool = &backendAddressPool
	} else {
		destination.BackendAddressPool = nil
	}

	// BackendSettings
	if rule.BackendSettings != nil {
		var backendSetting storage.SubResource
		err := rule.BackendSettings.AssignProperties_To_SubResource(&backendSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field BackendSettings")
		}
		destination.BackendSettings = &backendSetting
	} else {
		destination.BackendSettings = nil
	}

	// Listener
	if rule.Listener != nil {
		var listener storage.SubResource
		err := rule.Listener.AssignProperties_To_SubResource(&listener)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field Listener")
		}
		destination.Listener = &listener
	} else {
		destination.Listener = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(rule.Name)

	// Priority
	if rule.Priority != nil {
		priority := *rule.Priority
		destination.Priority = &priority
	} else {
		destination.Priority = nil
	}

	// RuleType
	if rule.RuleType != nil {
		ruleType := string(*rule.RuleType)
		destination.RuleType = &ruleType
	} else {
		destination.RuleType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ApplicationGatewayRoutingRule_STATUS populates our ApplicationGatewayRoutingRule from the provided source ApplicationGatewayRoutingRule_STATUS
func (rule *ApplicationGatewayRoutingRule) Initialize_From_ApplicationGatewayRoutingRule_STATUS(source *ApplicationGatewayRoutingRule_STATUS) error {

	// No error
	return nil
}

// Routing rule of an application gateway.
type ApplicationGatewayRoutingRule_STATUS struct {
	// Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &ApplicationGatewayRoutingRule_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *ApplicationGatewayRoutingRule_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApplicationGatewayRoutingRule_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *ApplicationGatewayRoutingRule_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApplicationGatewayRoutingRule_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApplicationGatewayRoutingRule_STATUS, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		rule.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_ApplicationGatewayRoutingRule_STATUS populates our ApplicationGatewayRoutingRule_STATUS from the provided source ApplicationGatewayRoutingRule_STATUS
func (rule *ApplicationGatewayRoutingRule_STATUS) AssignProperties_From_ApplicationGatewayRoutingRule_STATUS(source *storage.ApplicationGatewayRoutingRule_STATUS) error {

	// Id
	rule.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_ApplicationGatewayRoutingRule_STATUS populates the provided destination ApplicationGatewayRoutingRule_STATUS from our ApplicationGatewayRoutingRule_STATUS
func (rule *ApplicationGatewayRoutingRule_STATUS) AssignProperties_To_ApplicationGatewayRoutingRule_STATUS(destination *storage.ApplicationGatewayRoutingRule_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(rule.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// SKU of an application gateway.
type ApplicationGatewaySku struct {
	// Capacity: Capacity (instance count) of an application gateway.
	Capacity *int `json:"capacity,omitempty"`

	// Name: Name of an application gateway SKU.
	Name *ApplicationGatewaySku_Name `json:"name,omitempty"`

	// Tier: Tier of an application gateway.
	Tier *ApplicationGatewaySku_Tier `json:"tier,omitempty"`
}

var _ genruntime.ARMTransformer = &ApplicationGatewaySku{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (gatewaySku *ApplicationGatewaySku) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if gatewaySku == nil {
		return nil, nil
	}
	result := &arm.ApplicationGatewaySku{}

	// Set property "Capacity":
	if gatewaySku.Capacity != nil {
		capacity := *gatewaySku.Capacity
		result.Capacity = &capacity
	}

	// Set property "Name":
	if gatewaySku.Name != nil {
		var temp string
		temp = string(*gatewaySku.Name)
		name := arm.ApplicationGatewaySku_Name(temp)
		result.Name = &name
	}

	// Set property "Tier":
	if gatewaySku.Tier != nil {
		var temp string
		temp = string(*gatewaySku.Tier)
		tier := arm.ApplicationGatewaySku_Tier(temp)
		result.Tier = &tier
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (gatewaySku *ApplicationGatewaySku) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApplicationGatewaySku{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (gatewaySku *ApplicationGatewaySku) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApplicationGatewaySku)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApplicationGatewaySku, got %T", armInput)
	}

	// Set property "Capacity":
	if typedInput.Capacity != nil {
		capacity := *typedInput.Capacity
		gatewaySku.Capacity = &capacity
	}

	// Set property "Name":
	if typedInput.Name != nil {
		var temp string
		temp = string(*typedInput.Name)
		name := ApplicationGatewaySku_Name(temp)
		gatewaySku.Name = &name
	}

	// Set property "Tier":
	if typedInput.Tier != nil {
		var temp string
		temp = string(*typedInput.Tier)
		tier := ApplicationGatewaySku_Tier(temp)
		gatewaySku.Tier = &tier
	}

	// No error
	return nil
}

// AssignProperties_From_ApplicationGatewaySku populates our ApplicationGatewaySku from the provided source ApplicationGatewaySku
func (gatewaySku *ApplicationGatewaySku) AssignProperties_From_ApplicationGatewaySku(source *storage.ApplicationGatewaySku) error {

	// Capacity
	gatewaySku.Capacity = genruntime.ClonePointerToInt(source.Capacity)

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, applicationGatewaySku_Name_Values)
		gatewaySku.Name = &nameTemp
	} else {
		gatewaySku.Name = nil
	}

	// Tier
	if source.Tier != nil {
		tier := *source.Tier
		tierTemp := genruntime.ToEnum(tier, applicationGatewaySku_Tier_Values)
		gatewaySku.Tier = &tierTemp
	} else {
		gatewaySku.Tier = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ApplicationGatewaySku populates the provided destination ApplicationGatewaySku from our ApplicationGatewaySku
func (gatewaySku *ApplicationGatewaySku) AssignProperties_To_ApplicationGatewaySku(destination *storage.ApplicationGatewaySku) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Capacity
	destination.Capacity = genruntime.ClonePointerToInt(gatewaySku.Capacity)

	// Name
	if gatewaySku.Name != nil {
		name := string(*gatewaySku.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Tier
	if gatewaySku.Tier != nil {
		tier := string(*gatewaySku.Tier)
		destination.Tier = &tier
	} else {
		destination.Tier = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ApplicationGatewaySku_STATUS populates our ApplicationGatewaySku from the provided source ApplicationGatewaySku_STATUS
func (gatewaySku *ApplicationGatewaySku) Initialize_From_ApplicationGatewaySku_STATUS(source *ApplicationGatewaySku_STATUS) error {

	// Capacity
	gatewaySku.Capacity = genruntime.ClonePointerToInt(source.Capacity)

	// Name
	if source.Name != nil {
		name := genruntime.ToEnum(string(*source.Name), applicationGatewaySku_Name_Values)
		gatewaySku.Name = &name
	} else {
		gatewaySku.Name = nil
	}

	// Tier
	if source.Tier != nil {
		tier := genruntime.ToEnum(string(*source.Tier), applicationGatewaySku_Tier_Values)
		gatewaySku.Tier = &tier
	} else {
		gatewaySku.Tier = nil
	}

	// No error
	return nil
}

// SKU of an application gateway.
type ApplicationGatewaySku_STATUS struct {
	// Capacity: Capacity (instance count) of an application gateway.
	Capacity *int `json:"capacity,omitempty"`

	// Name: Name of an application gateway SKU.
	Name *ApplicationGatewaySku_Name_STATUS `json:"name,omitempty"`

	// Tier: Tier of an application gateway.
	Tier *ApplicationGatewaySku_Tier_STATUS `json:"tier,omitempty"`
}

var _ genruntime.FromARMConverter = &ApplicationGatewaySku_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (gatewaySku *ApplicationGatewaySku_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApplicationGatewaySku_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (gatewaySku *ApplicationGatewaySku_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApplicationGatewaySku_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApplicationGatewaySku_STATUS, got %T", armInput)
	}

	// Set property "Capacity":
	if typedInput.Capacity != nil {
		capacity := *typedInput.Capacity
		gatewaySku.Capacity = &capacity
	}

	// Set property "Name":
	if typedInput.Name != nil {
		var temp string
		temp = string(*typedInput.Name)
		name := ApplicationGatewaySku_Name_STATUS(temp)
		gatewaySku.Name = &name
	}

	// Set property "Tier":
	if typedInput.Tier != nil {
		var temp string
		temp = string(*typedInput.Tier)
		tier := ApplicationGatewaySku_Tier_STATUS(temp)
		gatewaySku.Tier = &tier
	}

	// No error
	return nil
}

// AssignProperties_From_ApplicationGatewaySku_STATUS populates our ApplicationGatewaySku_STATUS from the provided source ApplicationGatewaySku_STATUS
func (gatewaySku *ApplicationGatewaySku_STATUS) AssignProperties_From_ApplicationGatewaySku_STATUS(source *storage.ApplicationGatewaySku_STATUS) error {

	// Capacity
	gatewaySku.Capacity = genruntime.ClonePointerToInt(source.Capacity)

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, applicationGatewaySku_Name_STATUS_Values)
		gatewaySku.Name = &nameTemp
	} else {
		gatewaySku.Name = nil
	}

	// Tier
	if source.Tier != nil {
		tier := *source.Tier
		tierTemp := genruntime.ToEnum(tier, applicationGatewaySku_Tier_STATUS_Values)
		gatewaySku.Tier = &tierTemp
	} else {
		gatewaySku.Tier = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ApplicationGatewaySku_STATUS populates the provided destination ApplicationGatewaySku_STATUS from our ApplicationGatewaySku_STATUS
func (gatewaySku *ApplicationGatewaySku_STATUS) AssignProperties_To_ApplicationGatewaySku_STATUS(destination *storage.ApplicationGatewaySku_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Capacity
	destination.Capacity = genruntime.ClonePointerToInt(gatewaySku.Capacity)

	// Name
	if gatewaySku.Name != nil {
		name := string(*gatewaySku.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Tier
	if gatewaySku.Tier != nil {
		tier := string(*gatewaySku.Tier)
		destination.Tier = &tier
	} else {
		destination.Tier = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// SSL certificates of an application gateway.
type ApplicationGatewaySslCertificate struct {
	// Data: Base-64 encoded pfx certificate. Only applicable in PUT Request.
	Data *genruntime.SecretReference `json:"data,omitempty"`

	// KeyVaultSecretId: Secret Id of (base-64 encoded unencrypted pfx) 'Secret' or 'Certificate' object stored in KeyVault.
	KeyVaultSecretId *string `json:"keyVaultSecretId,omitempty"`

	// Name: Name of the SSL certificate that is unique within an Application Gateway.
	Name *string `json:"name,omitempty"`

	// Password: Password for the pfx file specified in data. Only applicable in PUT request.
	Password *genruntime.SecretReference `json:"password,omitempty"`
}

var _ genruntime.ARMTransformer = &ApplicationGatewaySslCertificate{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (certificate *ApplicationGatewaySslCertificate) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if certificate == nil {
		return nil, nil
	}
	result := &arm.ApplicationGatewaySslCertificate{}

	// Set property "Name":
	if certificate.Name != nil {
		name := *certificate.Name
		result.Name = &name
	}

	// Set property "Properties":
	if certificate.Data != nil ||
		certificate.KeyVaultSecretId != nil ||
		certificate.Password != nil {
		result.Properties = &arm.ApplicationGatewaySslCertificatePropertiesFormat{}
	}
	if certificate.Data != nil {
		dataSecret, err := resolved.ResolvedSecrets.Lookup(*certificate.Data)
		if err != nil {
			return nil, errors.Wrap(err, "looking up secret for property Data")
		}
		data := dataSecret
		result.Properties.Data = &data
	}
	if certificate.KeyVaultSecretId != nil {
		keyVaultSecretId := *certificate.KeyVaultSecretId
		result.Properties.KeyVaultSecretId = &keyVaultSecretId
	}
	if certificate.Password != nil {
		passwordSecret, err := resolved.ResolvedSecrets.Lookup(*certificate.Password)
		if err != nil {
			return nil, errors.Wrap(err, "looking up secret for property Password")
		}
		password := passwordSecret
		result.Properties.Password = &password
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (certificate *ApplicationGatewaySslCertificate) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApplicationGatewaySslCertificate{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (certificate *ApplicationGatewaySslCertificate) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApplicationGatewaySslCertificate)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApplicationGatewaySslCertificate, got %T", armInput)
	}

	// no assignment for property "Data"

	// Set property "KeyVaultSecretId":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.KeyVaultSecretId != nil {
			keyVaultSecretId := *typedInput.Properties.KeyVaultSecretId
			certificate.KeyVaultSecretId = &keyVaultSecretId
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		certificate.Name = &name
	}

	// no assignment for property "Password"

	// No error
	return nil
}

// AssignProperties_From_ApplicationGatewaySslCertificate populates our ApplicationGatewaySslCertificate from the provided source ApplicationGatewaySslCertificate
func (certificate *ApplicationGatewaySslCertificate) AssignProperties_From_ApplicationGatewaySslCertificate(source *storage.ApplicationGatewaySslCertificate) error {

	// Data
	if source.Data != nil {
		datum := source.Data.Copy()
		certificate.Data = &datum
	} else {
		certificate.Data = nil
	}

	// KeyVaultSecretId
	certificate.KeyVaultSecretId = genruntime.ClonePointerToString(source.KeyVaultSecretId)

	// Name
	certificate.Name = genruntime.ClonePointerToString(source.Name)

	// Password
	if source.Password != nil {
		password := source.Password.Copy()
		certificate.Password = &password
	} else {
		certificate.Password = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ApplicationGatewaySslCertificate populates the provided destination ApplicationGatewaySslCertificate from our ApplicationGatewaySslCertificate
func (certificate *ApplicationGatewaySslCertificate) AssignProperties_To_ApplicationGatewaySslCertificate(destination *storage.ApplicationGatewaySslCertificate) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Data
	if certificate.Data != nil {
		datum := certificate.Data.Copy()
		destination.Data = &datum
	} else {
		destination.Data = nil
	}

	// KeyVaultSecretId
	destination.KeyVaultSecretId = genruntime.ClonePointerToString(certificate.KeyVaultSecretId)

	// Name
	destination.Name = genruntime.ClonePointerToString(certificate.Name)

	// Password
	if certificate.Password != nil {
		password := certificate.Password.Copy()
		destination.Password = &password
	} else {
		destination.Password = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ApplicationGatewaySslCertificate_STATUS populates our ApplicationGatewaySslCertificate from the provided source ApplicationGatewaySslCertificate_STATUS
func (certificate *ApplicationGatewaySslCertificate) Initialize_From_ApplicationGatewaySslCertificate_STATUS(source *ApplicationGatewaySslCertificate_STATUS) error {

	// No error
	return nil
}

// SSL certificates of an application gateway.
type ApplicationGatewaySslCertificate_STATUS struct {
	// Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &ApplicationGatewaySslCertificate_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (certificate *ApplicationGatewaySslCertificate_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApplicationGatewaySslCertificate_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (certificate *ApplicationGatewaySslCertificate_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApplicationGatewaySslCertificate_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApplicationGatewaySslCertificate_STATUS, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		certificate.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_ApplicationGatewaySslCertificate_STATUS populates our ApplicationGatewaySslCertificate_STATUS from the provided source ApplicationGatewaySslCertificate_STATUS
func (certificate *ApplicationGatewaySslCertificate_STATUS) AssignProperties_From_ApplicationGatewaySslCertificate_STATUS(source *storage.ApplicationGatewaySslCertificate_STATUS) error {

	// Id
	certificate.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_ApplicationGatewaySslCertificate_STATUS populates the provided destination ApplicationGatewaySslCertificate_STATUS from our ApplicationGatewaySslCertificate_STATUS
func (certificate *ApplicationGatewaySslCertificate_STATUS) AssignProperties_To_ApplicationGatewaySslCertificate_STATUS(destination *storage.ApplicationGatewaySslCertificate_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(certificate.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Application Gateway Ssl policy.
type ApplicationGatewaySslPolicy struct {
	// CipherSuites: Ssl cipher suites to be enabled in the specified order to application gateway.
	CipherSuites []CipherSuitesEnum `json:"cipherSuites,omitempty"`

	// DisabledSslProtocols: Ssl protocols to be disabled on application gateway.
	DisabledSslProtocols []ProtocolsEnum `json:"disabledSslProtocols,omitempty"`

	// MinProtocolVersion: Minimum version of Ssl protocol to be supported on application gateway.
	MinProtocolVersion *ProtocolsEnum `json:"minProtocolVersion,omitempty"`

	// PolicyName: Name of Ssl predefined policy.
	PolicyName *PolicyNameEnum `json:"policyName,omitempty"`

	// PolicyType: Type of Ssl Policy.
	PolicyType *ApplicationGatewaySslPolicy_PolicyType `json:"policyType,omitempty"`
}

var _ genruntime.ARMTransformer = &ApplicationGatewaySslPolicy{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (policy *ApplicationGatewaySslPolicy) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if policy == nil {
		return nil, nil
	}
	result := &arm.ApplicationGatewaySslPolicy{}

	// Set property "CipherSuites":
	for _, item := range policy.CipherSuites {
		var temp string
		temp = string(item)
		result.CipherSuites = append(result.CipherSuites, arm.CipherSuitesEnum(temp))
	}

	// Set property "DisabledSslProtocols":
	for _, item := range policy.DisabledSslProtocols {
		var temp string
		temp = string(item)
		result.DisabledSslProtocols = append(result.DisabledSslProtocols, arm.ProtocolsEnum(temp))
	}

	// Set property "MinProtocolVersion":
	if policy.MinProtocolVersion != nil {
		var temp string
		temp = string(*policy.MinProtocolVersion)
		minProtocolVersion := arm.ProtocolsEnum(temp)
		result.MinProtocolVersion = &minProtocolVersion
	}

	// Set property "PolicyName":
	if policy.PolicyName != nil {
		var temp string
		temp = string(*policy.PolicyName)
		policyName := arm.PolicyNameEnum(temp)
		result.PolicyName = &policyName
	}

	// Set property "PolicyType":
	if policy.PolicyType != nil {
		var temp string
		temp = string(*policy.PolicyType)
		policyType := arm.ApplicationGatewaySslPolicy_PolicyType(temp)
		result.PolicyType = &policyType
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (policy *ApplicationGatewaySslPolicy) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApplicationGatewaySslPolicy{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (policy *ApplicationGatewaySslPolicy) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApplicationGatewaySslPolicy)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApplicationGatewaySslPolicy, got %T", armInput)
	}

	// Set property "CipherSuites":
	for _, item := range typedInput.CipherSuites {
		var temp string
		temp = string(item)
		policy.CipherSuites = append(policy.CipherSuites, CipherSuitesEnum(temp))
	}

	// Set property "DisabledSslProtocols":
	for _, item := range typedInput.DisabledSslProtocols {
		var temp string
		temp = string(item)
		policy.DisabledSslProtocols = append(policy.DisabledSslProtocols, ProtocolsEnum(temp))
	}

	// Set property "MinProtocolVersion":
	if typedInput.MinProtocolVersion != nil {
		var temp string
		temp = string(*typedInput.MinProtocolVersion)
		minProtocolVersion := ProtocolsEnum(temp)
		policy.MinProtocolVersion = &minProtocolVersion
	}

	// Set property "PolicyName":
	if typedInput.PolicyName != nil {
		var temp string
		temp = string(*typedInput.PolicyName)
		policyName := PolicyNameEnum(temp)
		policy.PolicyName = &policyName
	}

	// Set property "PolicyType":
	if typedInput.PolicyType != nil {
		var temp string
		temp = string(*typedInput.PolicyType)
		policyType := ApplicationGatewaySslPolicy_PolicyType(temp)
		policy.PolicyType = &policyType
	}

	// No error
	return nil
}

// AssignProperties_From_ApplicationGatewaySslPolicy populates our ApplicationGatewaySslPolicy from the provided source ApplicationGatewaySslPolicy
func (policy *ApplicationGatewaySslPolicy) AssignProperties_From_ApplicationGatewaySslPolicy(source *storage.ApplicationGatewaySslPolicy) error {

	// CipherSuites
	if source.CipherSuites != nil {
		cipherSuiteList := make([]CipherSuitesEnum, len(source.CipherSuites))
		for cipherSuiteIndex, cipherSuiteItem := range source.CipherSuites {
			// Shadow the loop variable to avoid aliasing
			cipherSuiteItem := cipherSuiteItem
			cipherSuiteList[cipherSuiteIndex] = genruntime.ToEnum(cipherSuiteItem, cipherSuitesEnum_Values)
		}
		policy.CipherSuites = cipherSuiteList
	} else {
		policy.CipherSuites = nil
	}

	// DisabledSslProtocols
	if source.DisabledSslProtocols != nil {
		disabledSslProtocolList := make([]ProtocolsEnum, len(source.DisabledSslProtocols))
		for disabledSslProtocolIndex, disabledSslProtocolItem := range source.DisabledSslProtocols {
			// Shadow the loop variable to avoid aliasing
			disabledSslProtocolItem := disabledSslProtocolItem
			disabledSslProtocolList[disabledSslProtocolIndex] = genruntime.ToEnum(disabledSslProtocolItem, protocolsEnum_Values)
		}
		policy.DisabledSslProtocols = disabledSslProtocolList
	} else {
		policy.DisabledSslProtocols = nil
	}

	// MinProtocolVersion
	if source.MinProtocolVersion != nil {
		minProtocolVersion := *source.MinProtocolVersion
		minProtocolVersionTemp := genruntime.ToEnum(minProtocolVersion, protocolsEnum_Values)
		policy.MinProtocolVersion = &minProtocolVersionTemp
	} else {
		policy.MinProtocolVersion = nil
	}

	// PolicyName
	if source.PolicyName != nil {
		policyName := *source.PolicyName
		policyNameTemp := genruntime.ToEnum(policyName, policyNameEnum_Values)
		policy.PolicyName = &policyNameTemp
	} else {
		policy.PolicyName = nil
	}

	// PolicyType
	if source.PolicyType != nil {
		policyType := *source.PolicyType
		policyTypeTemp := genruntime.ToEnum(policyType, applicationGatewaySslPolicy_PolicyType_Values)
		policy.PolicyType = &policyTypeTemp
	} else {
		policy.PolicyType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ApplicationGatewaySslPolicy populates the provided destination ApplicationGatewaySslPolicy from our ApplicationGatewaySslPolicy
func (policy *ApplicationGatewaySslPolicy) AssignProperties_To_ApplicationGatewaySslPolicy(destination *storage.ApplicationGatewaySslPolicy) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CipherSuites
	if policy.CipherSuites != nil {
		cipherSuiteList := make([]string, len(policy.CipherSuites))
		for cipherSuiteIndex, cipherSuiteItem := range policy.CipherSuites {
			// Shadow the loop variable to avoid aliasing
			cipherSuiteItem := cipherSuiteItem
			cipherSuiteList[cipherSuiteIndex] = string(cipherSuiteItem)
		}
		destination.CipherSuites = cipherSuiteList
	} else {
		destination.CipherSuites = nil
	}

	// DisabledSslProtocols
	if policy.DisabledSslProtocols != nil {
		disabledSslProtocolList := make([]string, len(policy.DisabledSslProtocols))
		for disabledSslProtocolIndex, disabledSslProtocolItem := range policy.DisabledSslProtocols {
			// Shadow the loop variable to avoid aliasing
			disabledSslProtocolItem := disabledSslProtocolItem
			disabledSslProtocolList[disabledSslProtocolIndex] = string(disabledSslProtocolItem)
		}
		destination.DisabledSslProtocols = disabledSslProtocolList
	} else {
		destination.DisabledSslProtocols = nil
	}

	// MinProtocolVersion
	if policy.MinProtocolVersion != nil {
		minProtocolVersion := string(*policy.MinProtocolVersion)
		destination.MinProtocolVersion = &minProtocolVersion
	} else {
		destination.MinProtocolVersion = nil
	}

	// PolicyName
	if policy.PolicyName != nil {
		policyName := string(*policy.PolicyName)
		destination.PolicyName = &policyName
	} else {
		destination.PolicyName = nil
	}

	// PolicyType
	if policy.PolicyType != nil {
		policyType := string(*policy.PolicyType)
		destination.PolicyType = &policyType
	} else {
		destination.PolicyType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ApplicationGatewaySslPolicy_STATUS populates our ApplicationGatewaySslPolicy from the provided source ApplicationGatewaySslPolicy_STATUS
func (policy *ApplicationGatewaySslPolicy) Initialize_From_ApplicationGatewaySslPolicy_STATUS(source *ApplicationGatewaySslPolicy_STATUS) error {

	// CipherSuites
	if source.CipherSuites != nil {
		cipherSuiteList := make([]CipherSuitesEnum, len(source.CipherSuites))
		for cipherSuiteIndex, cipherSuiteItem := range source.CipherSuites {
			// Shadow the loop variable to avoid aliasing
			cipherSuiteItem := cipherSuiteItem
			cipherSuite := genruntime.ToEnum(string(cipherSuiteItem), cipherSuitesEnum_Values)
			cipherSuiteList[cipherSuiteIndex] = cipherSuite
		}
		policy.CipherSuites = cipherSuiteList
	} else {
		policy.CipherSuites = nil
	}

	// DisabledSslProtocols
	if source.DisabledSslProtocols != nil {
		disabledSslProtocolList := make([]ProtocolsEnum, len(source.DisabledSslProtocols))
		for disabledSslProtocolIndex, disabledSslProtocolItem := range source.DisabledSslProtocols {
			// Shadow the loop variable to avoid aliasing
			disabledSslProtocolItem := disabledSslProtocolItem
			disabledSslProtocol := genruntime.ToEnum(string(disabledSslProtocolItem), protocolsEnum_Values)
			disabledSslProtocolList[disabledSslProtocolIndex] = disabledSslProtocol
		}
		policy.DisabledSslProtocols = disabledSslProtocolList
	} else {
		policy.DisabledSslProtocols = nil
	}

	// MinProtocolVersion
	if source.MinProtocolVersion != nil {
		minProtocolVersion := genruntime.ToEnum(string(*source.MinProtocolVersion), protocolsEnum_Values)
		policy.MinProtocolVersion = &minProtocolVersion
	} else {
		policy.MinProtocolVersion = nil
	}

	// PolicyName
	if source.PolicyName != nil {
		policyName := genruntime.ToEnum(string(*source.PolicyName), policyNameEnum_Values)
		policy.PolicyName = &policyName
	} else {
		policy.PolicyName = nil
	}

	// PolicyType
	if source.PolicyType != nil {
		policyType := genruntime.ToEnum(string(*source.PolicyType), applicationGatewaySslPolicy_PolicyType_Values)
		policy.PolicyType = &policyType
	} else {
		policy.PolicyType = nil
	}

	// No error
	return nil
}

// Application Gateway Ssl policy.
type ApplicationGatewaySslPolicy_STATUS struct {
	// CipherSuites: Ssl cipher suites to be enabled in the specified order to application gateway.
	CipherSuites []CipherSuitesEnum_STATUS `json:"cipherSuites,omitempty"`

	// DisabledSslProtocols: Ssl protocols to be disabled on application gateway.
	DisabledSslProtocols []ProtocolsEnum_STATUS `json:"disabledSslProtocols,omitempty"`

	// MinProtocolVersion: Minimum version of Ssl protocol to be supported on application gateway.
	MinProtocolVersion *ProtocolsEnum_STATUS `json:"minProtocolVersion,omitempty"`

	// PolicyName: Name of Ssl predefined policy.
	PolicyName *PolicyNameEnum_STATUS `json:"policyName,omitempty"`

	// PolicyType: Type of Ssl Policy.
	PolicyType *ApplicationGatewaySslPolicy_PolicyType_STATUS `json:"policyType,omitempty"`
}

var _ genruntime.FromARMConverter = &ApplicationGatewaySslPolicy_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (policy *ApplicationGatewaySslPolicy_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApplicationGatewaySslPolicy_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (policy *ApplicationGatewaySslPolicy_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApplicationGatewaySslPolicy_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApplicationGatewaySslPolicy_STATUS, got %T", armInput)
	}

	// Set property "CipherSuites":
	for _, item := range typedInput.CipherSuites {
		var temp string
		temp = string(item)
		policy.CipherSuites = append(policy.CipherSuites, CipherSuitesEnum_STATUS(temp))
	}

	// Set property "DisabledSslProtocols":
	for _, item := range typedInput.DisabledSslProtocols {
		var temp string
		temp = string(item)
		policy.DisabledSslProtocols = append(policy.DisabledSslProtocols, ProtocolsEnum_STATUS(temp))
	}

	// Set property "MinProtocolVersion":
	if typedInput.MinProtocolVersion != nil {
		var temp string
		temp = string(*typedInput.MinProtocolVersion)
		minProtocolVersion := ProtocolsEnum_STATUS(temp)
		policy.MinProtocolVersion = &minProtocolVersion
	}

	// Set property "PolicyName":
	if typedInput.PolicyName != nil {
		var temp string
		temp = string(*typedInput.PolicyName)
		policyName := PolicyNameEnum_STATUS(temp)
		policy.PolicyName = &policyName
	}

	// Set property "PolicyType":
	if typedInput.PolicyType != nil {
		var temp string
		temp = string(*typedInput.PolicyType)
		policyType := ApplicationGatewaySslPolicy_PolicyType_STATUS(temp)
		policy.PolicyType = &policyType
	}

	// No error
	return nil
}

// AssignProperties_From_ApplicationGatewaySslPolicy_STATUS populates our ApplicationGatewaySslPolicy_STATUS from the provided source ApplicationGatewaySslPolicy_STATUS
func (policy *ApplicationGatewaySslPolicy_STATUS) AssignProperties_From_ApplicationGatewaySslPolicy_STATUS(source *storage.ApplicationGatewaySslPolicy_STATUS) error {

	// CipherSuites
	if source.CipherSuites != nil {
		cipherSuiteList := make([]CipherSuitesEnum_STATUS, len(source.CipherSuites))
		for cipherSuiteIndex, cipherSuiteItem := range source.CipherSuites {
			// Shadow the loop variable to avoid aliasing
			cipherSuiteItem := cipherSuiteItem
			cipherSuiteList[cipherSuiteIndex] = genruntime.ToEnum(cipherSuiteItem, cipherSuitesEnum_STATUS_Values)
		}
		policy.CipherSuites = cipherSuiteList
	} else {
		policy.CipherSuites = nil
	}

	// DisabledSslProtocols
	if source.DisabledSslProtocols != nil {
		disabledSslProtocolList := make([]ProtocolsEnum_STATUS, len(source.DisabledSslProtocols))
		for disabledSslProtocolIndex, disabledSslProtocolItem := range source.DisabledSslProtocols {
			// Shadow the loop variable to avoid aliasing
			disabledSslProtocolItem := disabledSslProtocolItem
			disabledSslProtocolList[disabledSslProtocolIndex] = genruntime.ToEnum(disabledSslProtocolItem, protocolsEnum_STATUS_Values)
		}
		policy.DisabledSslProtocols = disabledSslProtocolList
	} else {
		policy.DisabledSslProtocols = nil
	}

	// MinProtocolVersion
	if source.MinProtocolVersion != nil {
		minProtocolVersion := *source.MinProtocolVersion
		minProtocolVersionTemp := genruntime.ToEnum(minProtocolVersion, protocolsEnum_STATUS_Values)
		policy.MinProtocolVersion = &minProtocolVersionTemp
	} else {
		policy.MinProtocolVersion = nil
	}

	// PolicyName
	if source.PolicyName != nil {
		policyName := *source.PolicyName
		policyNameTemp := genruntime.ToEnum(policyName, policyNameEnum_STATUS_Values)
		policy.PolicyName = &policyNameTemp
	} else {
		policy.PolicyName = nil
	}

	// PolicyType
	if source.PolicyType != nil {
		policyType := *source.PolicyType
		policyTypeTemp := genruntime.ToEnum(policyType, applicationGatewaySslPolicy_PolicyType_STATUS_Values)
		policy.PolicyType = &policyTypeTemp
	} else {
		policy.PolicyType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ApplicationGatewaySslPolicy_STATUS populates the provided destination ApplicationGatewaySslPolicy_STATUS from our ApplicationGatewaySslPolicy_STATUS
func (policy *ApplicationGatewaySslPolicy_STATUS) AssignProperties_To_ApplicationGatewaySslPolicy_STATUS(destination *storage.ApplicationGatewaySslPolicy_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CipherSuites
	if policy.CipherSuites != nil {
		cipherSuiteList := make([]string, len(policy.CipherSuites))
		for cipherSuiteIndex, cipherSuiteItem := range policy.CipherSuites {
			// Shadow the loop variable to avoid aliasing
			cipherSuiteItem := cipherSuiteItem
			cipherSuiteList[cipherSuiteIndex] = string(cipherSuiteItem)
		}
		destination.CipherSuites = cipherSuiteList
	} else {
		destination.CipherSuites = nil
	}

	// DisabledSslProtocols
	if policy.DisabledSslProtocols != nil {
		disabledSslProtocolList := make([]string, len(policy.DisabledSslProtocols))
		for disabledSslProtocolIndex, disabledSslProtocolItem := range policy.DisabledSslProtocols {
			// Shadow the loop variable to avoid aliasing
			disabledSslProtocolItem := disabledSslProtocolItem
			disabledSslProtocolList[disabledSslProtocolIndex] = string(disabledSslProtocolItem)
		}
		destination.DisabledSslProtocols = disabledSslProtocolList
	} else {
		destination.DisabledSslProtocols = nil
	}

	// MinProtocolVersion
	if policy.MinProtocolVersion != nil {
		minProtocolVersion := string(*policy.MinProtocolVersion)
		destination.MinProtocolVersion = &minProtocolVersion
	} else {
		destination.MinProtocolVersion = nil
	}

	// PolicyName
	if policy.PolicyName != nil {
		policyName := string(*policy.PolicyName)
		destination.PolicyName = &policyName
	} else {
		destination.PolicyName = nil
	}

	// PolicyType
	if policy.PolicyType != nil {
		policyType := string(*policy.PolicyType)
		destination.PolicyType = &policyType
	} else {
		destination.PolicyType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// SSL profile of an application gateway.
type ApplicationGatewaySslProfile struct {
	// ClientAuthConfiguration: Client authentication configuration of the application gateway resource.
	ClientAuthConfiguration *ApplicationGatewayClientAuthConfiguration `json:"clientAuthConfiguration,omitempty"`

	// Name: Name of the SSL profile that is unique within an Application Gateway.
	Name *string `json:"name,omitempty"`

	// SslPolicy: SSL policy of the application gateway resource.
	SslPolicy *ApplicationGatewaySslPolicy `json:"sslPolicy,omitempty"`

	// TrustedClientCertificates: Array of references to application gateway trusted client certificates.
	TrustedClientCertificates []SubResource `json:"trustedClientCertificates,omitempty"`
}

var _ genruntime.ARMTransformer = &ApplicationGatewaySslProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *ApplicationGatewaySslProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.ApplicationGatewaySslProfile{}

	// Set property "Name":
	if profile.Name != nil {
		name := *profile.Name
		result.Name = &name
	}

	// Set property "Properties":
	if profile.ClientAuthConfiguration != nil ||
		profile.SslPolicy != nil ||
		profile.TrustedClientCertificates != nil {
		result.Properties = &arm.ApplicationGatewaySslProfilePropertiesFormat{}
	}
	if profile.ClientAuthConfiguration != nil {
		clientAuthConfiguration_ARM, err := (*profile.ClientAuthConfiguration).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		clientAuthConfiguration := *clientAuthConfiguration_ARM.(*arm.ApplicationGatewayClientAuthConfiguration)
		result.Properties.ClientAuthConfiguration = &clientAuthConfiguration
	}
	if profile.SslPolicy != nil {
		sslPolicy_ARM, err := (*profile.SslPolicy).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		sslPolicy := *sslPolicy_ARM.(*arm.ApplicationGatewaySslPolicy)
		result.Properties.SslPolicy = &sslPolicy
	}
	for _, item := range profile.TrustedClientCertificates {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.TrustedClientCertificates = append(result.Properties.TrustedClientCertificates, *item_ARM.(*arm.SubResource))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ApplicationGatewaySslProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApplicationGatewaySslProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ApplicationGatewaySslProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApplicationGatewaySslProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApplicationGatewaySslProfile, got %T", armInput)
	}

	// Set property "ClientAuthConfiguration":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ClientAuthConfiguration != nil {
			var clientAuthConfiguration1 ApplicationGatewayClientAuthConfiguration
			err := clientAuthConfiguration1.PopulateFromARM(owner, *typedInput.Properties.ClientAuthConfiguration)
			if err != nil {
				return err
			}
			clientAuthConfiguration := clientAuthConfiguration1
			profile.ClientAuthConfiguration = &clientAuthConfiguration
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		profile.Name = &name
	}

	// Set property "SslPolicy":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.SslPolicy != nil {
			var sslPolicy1 ApplicationGatewaySslPolicy
			err := sslPolicy1.PopulateFromARM(owner, *typedInput.Properties.SslPolicy)
			if err != nil {
				return err
			}
			sslPolicy := sslPolicy1
			profile.SslPolicy = &sslPolicy
		}
	}

	// Set property "TrustedClientCertificates":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.TrustedClientCertificates {
			var item1 SubResource
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			profile.TrustedClientCertificates = append(profile.TrustedClientCertificates, item1)
		}
	}

	// No error
	return nil
}

// AssignProperties_From_ApplicationGatewaySslProfile populates our ApplicationGatewaySslProfile from the provided source ApplicationGatewaySslProfile
func (profile *ApplicationGatewaySslProfile) AssignProperties_From_ApplicationGatewaySslProfile(source *storage.ApplicationGatewaySslProfile) error {

	// ClientAuthConfiguration
	if source.ClientAuthConfiguration != nil {
		var clientAuthConfiguration ApplicationGatewayClientAuthConfiguration
		err := clientAuthConfiguration.AssignProperties_From_ApplicationGatewayClientAuthConfiguration(source.ClientAuthConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ApplicationGatewayClientAuthConfiguration() to populate field ClientAuthConfiguration")
		}
		profile.ClientAuthConfiguration = &clientAuthConfiguration
	} else {
		profile.ClientAuthConfiguration = nil
	}

	// Name
	profile.Name = genruntime.ClonePointerToString(source.Name)

	// SslPolicy
	if source.SslPolicy != nil {
		var sslPolicy ApplicationGatewaySslPolicy
		err := sslPolicy.AssignProperties_From_ApplicationGatewaySslPolicy(source.SslPolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ApplicationGatewaySslPolicy() to populate field SslPolicy")
		}
		profile.SslPolicy = &sslPolicy
	} else {
		profile.SslPolicy = nil
	}

	// TrustedClientCertificates
	if source.TrustedClientCertificates != nil {
		trustedClientCertificateList := make([]SubResource, len(source.TrustedClientCertificates))
		for trustedClientCertificateIndex, trustedClientCertificateItem := range source.TrustedClientCertificates {
			// Shadow the loop variable to avoid aliasing
			trustedClientCertificateItem := trustedClientCertificateItem
			var trustedClientCertificate SubResource
			err := trustedClientCertificate.AssignProperties_From_SubResource(&trustedClientCertificateItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field TrustedClientCertificates")
			}
			trustedClientCertificateList[trustedClientCertificateIndex] = trustedClientCertificate
		}
		profile.TrustedClientCertificates = trustedClientCertificateList
	} else {
		profile.TrustedClientCertificates = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ApplicationGatewaySslProfile populates the provided destination ApplicationGatewaySslProfile from our ApplicationGatewaySslProfile
func (profile *ApplicationGatewaySslProfile) AssignProperties_To_ApplicationGatewaySslProfile(destination *storage.ApplicationGatewaySslProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ClientAuthConfiguration
	if profile.ClientAuthConfiguration != nil {
		var clientAuthConfiguration storage.ApplicationGatewayClientAuthConfiguration
		err := profile.ClientAuthConfiguration.AssignProperties_To_ApplicationGatewayClientAuthConfiguration(&clientAuthConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ApplicationGatewayClientAuthConfiguration() to populate field ClientAuthConfiguration")
		}
		destination.ClientAuthConfiguration = &clientAuthConfiguration
	} else {
		destination.ClientAuthConfiguration = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(profile.Name)

	// SslPolicy
	if profile.SslPolicy != nil {
		var sslPolicy storage.ApplicationGatewaySslPolicy
		err := profile.SslPolicy.AssignProperties_To_ApplicationGatewaySslPolicy(&sslPolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ApplicationGatewaySslPolicy() to populate field SslPolicy")
		}
		destination.SslPolicy = &sslPolicy
	} else {
		destination.SslPolicy = nil
	}

	// TrustedClientCertificates
	if profile.TrustedClientCertificates != nil {
		trustedClientCertificateList := make([]storage.SubResource, len(profile.TrustedClientCertificates))
		for trustedClientCertificateIndex, trustedClientCertificateItem := range profile.TrustedClientCertificates {
			// Shadow the loop variable to avoid aliasing
			trustedClientCertificateItem := trustedClientCertificateItem
			var trustedClientCertificate storage.SubResource
			err := trustedClientCertificateItem.AssignProperties_To_SubResource(&trustedClientCertificate)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field TrustedClientCertificates")
			}
			trustedClientCertificateList[trustedClientCertificateIndex] = trustedClientCertificate
		}
		destination.TrustedClientCertificates = trustedClientCertificateList
	} else {
		destination.TrustedClientCertificates = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ApplicationGatewaySslProfile_STATUS populates our ApplicationGatewaySslProfile from the provided source ApplicationGatewaySslProfile_STATUS
func (profile *ApplicationGatewaySslProfile) Initialize_From_ApplicationGatewaySslProfile_STATUS(source *ApplicationGatewaySslProfile_STATUS) error {

	// No error
	return nil
}

// SSL profile of an application gateway.
type ApplicationGatewaySslProfile_STATUS struct {
	// Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &ApplicationGatewaySslProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ApplicationGatewaySslProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApplicationGatewaySslProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ApplicationGatewaySslProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApplicationGatewaySslProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApplicationGatewaySslProfile_STATUS, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		profile.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_ApplicationGatewaySslProfile_STATUS populates our ApplicationGatewaySslProfile_STATUS from the provided source ApplicationGatewaySslProfile_STATUS
func (profile *ApplicationGatewaySslProfile_STATUS) AssignProperties_From_ApplicationGatewaySslProfile_STATUS(source *storage.ApplicationGatewaySslProfile_STATUS) error {

	// Id
	profile.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_ApplicationGatewaySslProfile_STATUS populates the provided destination ApplicationGatewaySslProfile_STATUS from our ApplicationGatewaySslProfile_STATUS
func (profile *ApplicationGatewaySslProfile_STATUS) AssignProperties_To_ApplicationGatewaySslProfile_STATUS(destination *storage.ApplicationGatewaySslProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(profile.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Trusted client certificates of an application gateway.
type ApplicationGatewayTrustedClientCertificate struct {
	// Data: Certificate public data.
	Data *genruntime.SecretReference `json:"data,omitempty"`

	// Name: Name of the trusted client certificate that is unique within an Application Gateway.
	Name *string `json:"name,omitempty"`
}

var _ genruntime.ARMTransformer = &ApplicationGatewayTrustedClientCertificate{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (certificate *ApplicationGatewayTrustedClientCertificate) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if certificate == nil {
		return nil, nil
	}
	result := &arm.ApplicationGatewayTrustedClientCertificate{}

	// Set property "Name":
	if certificate.Name != nil {
		name := *certificate.Name
		result.Name = &name
	}

	// Set property "Properties":
	if certificate.Data != nil {
		result.Properties = &arm.ApplicationGatewayTrustedClientCertificatePropertiesFormat{}
	}
	if certificate.Data != nil {
		dataSecret, err := resolved.ResolvedSecrets.Lookup(*certificate.Data)
		if err != nil {
			return nil, errors.Wrap(err, "looking up secret for property Data")
		}
		data := dataSecret
		result.Properties.Data = &data
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (certificate *ApplicationGatewayTrustedClientCertificate) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApplicationGatewayTrustedClientCertificate{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (certificate *ApplicationGatewayTrustedClientCertificate) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApplicationGatewayTrustedClientCertificate)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApplicationGatewayTrustedClientCertificate, got %T", armInput)
	}

	// no assignment for property "Data"

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		certificate.Name = &name
	}

	// No error
	return nil
}

// AssignProperties_From_ApplicationGatewayTrustedClientCertificate populates our ApplicationGatewayTrustedClientCertificate from the provided source ApplicationGatewayTrustedClientCertificate
func (certificate *ApplicationGatewayTrustedClientCertificate) AssignProperties_From_ApplicationGatewayTrustedClientCertificate(source *storage.ApplicationGatewayTrustedClientCertificate) error {

	// Data
	if source.Data != nil {
		datum := source.Data.Copy()
		certificate.Data = &datum
	} else {
		certificate.Data = nil
	}

	// Name
	certificate.Name = genruntime.ClonePointerToString(source.Name)

	// No error
	return nil
}

// AssignProperties_To_ApplicationGatewayTrustedClientCertificate populates the provided destination ApplicationGatewayTrustedClientCertificate from our ApplicationGatewayTrustedClientCertificate
func (certificate *ApplicationGatewayTrustedClientCertificate) AssignProperties_To_ApplicationGatewayTrustedClientCertificate(destination *storage.ApplicationGatewayTrustedClientCertificate) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Data
	if certificate.Data != nil {
		datum := certificate.Data.Copy()
		destination.Data = &datum
	} else {
		destination.Data = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(certificate.Name)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ApplicationGatewayTrustedClientCertificate_STATUS populates our ApplicationGatewayTrustedClientCertificate from the provided source ApplicationGatewayTrustedClientCertificate_STATUS
func (certificate *ApplicationGatewayTrustedClientCertificate) Initialize_From_ApplicationGatewayTrustedClientCertificate_STATUS(source *ApplicationGatewayTrustedClientCertificate_STATUS) error {

	// No error
	return nil
}

// Trusted client certificates of an application gateway.
type ApplicationGatewayTrustedClientCertificate_STATUS struct {
	// Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &ApplicationGatewayTrustedClientCertificate_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (certificate *ApplicationGatewayTrustedClientCertificate_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApplicationGatewayTrustedClientCertificate_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (certificate *ApplicationGatewayTrustedClientCertificate_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApplicationGatewayTrustedClientCertificate_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApplicationGatewayTrustedClientCertificate_STATUS, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		certificate.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_ApplicationGatewayTrustedClientCertificate_STATUS populates our ApplicationGatewayTrustedClientCertificate_STATUS from the provided source ApplicationGatewayTrustedClientCertificate_STATUS
func (certificate *ApplicationGatewayTrustedClientCertificate_STATUS) AssignProperties_From_ApplicationGatewayTrustedClientCertificate_STATUS(source *storage.ApplicationGatewayTrustedClientCertificate_STATUS) error {

	// Id
	certificate.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_ApplicationGatewayTrustedClientCertificate_STATUS populates the provided destination ApplicationGatewayTrustedClientCertificate_STATUS from our ApplicationGatewayTrustedClientCertificate_STATUS
func (certificate *ApplicationGatewayTrustedClientCertificate_STATUS) AssignProperties_To_ApplicationGatewayTrustedClientCertificate_STATUS(destination *storage.ApplicationGatewayTrustedClientCertificate_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(certificate.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Trusted Root certificates of an application gateway.
type ApplicationGatewayTrustedRootCertificate struct {
	// Data: Certificate public data.
	Data *genruntime.SecretReference `json:"data,omitempty"`

	// KeyVaultSecretId: Secret Id of (base-64 encoded unencrypted pfx) 'Secret' or 'Certificate' object stored in KeyVault.
	KeyVaultSecretId *string `json:"keyVaultSecretId,omitempty"`

	// Name: Name of the trusted root certificate that is unique within an Application Gateway.
	Name *string `json:"name,omitempty"`
}

var _ genruntime.ARMTransformer = &ApplicationGatewayTrustedRootCertificate{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (certificate *ApplicationGatewayTrustedRootCertificate) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if certificate == nil {
		return nil, nil
	}
	result := &arm.ApplicationGatewayTrustedRootCertificate{}

	// Set property "Name":
	if certificate.Name != nil {
		name := *certificate.Name
		result.Name = &name
	}

	// Set property "Properties":
	if certificate.Data != nil || certificate.KeyVaultSecretId != nil {
		result.Properties = &arm.ApplicationGatewayTrustedRootCertificatePropertiesFormat{}
	}
	if certificate.Data != nil {
		dataSecret, err := resolved.ResolvedSecrets.Lookup(*certificate.Data)
		if err != nil {
			return nil, errors.Wrap(err, "looking up secret for property Data")
		}
		data := dataSecret
		result.Properties.Data = &data
	}
	if certificate.KeyVaultSecretId != nil {
		keyVaultSecretId := *certificate.KeyVaultSecretId
		result.Properties.KeyVaultSecretId = &keyVaultSecretId
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (certificate *ApplicationGatewayTrustedRootCertificate) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApplicationGatewayTrustedRootCertificate{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (certificate *ApplicationGatewayTrustedRootCertificate) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApplicationGatewayTrustedRootCertificate)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApplicationGatewayTrustedRootCertificate, got %T", armInput)
	}

	// no assignment for property "Data"

	// Set property "KeyVaultSecretId":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.KeyVaultSecretId != nil {
			keyVaultSecretId := *typedInput.Properties.KeyVaultSecretId
			certificate.KeyVaultSecretId = &keyVaultSecretId
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		certificate.Name = &name
	}

	// No error
	return nil
}

// AssignProperties_From_ApplicationGatewayTrustedRootCertificate populates our ApplicationGatewayTrustedRootCertificate from the provided source ApplicationGatewayTrustedRootCertificate
func (certificate *ApplicationGatewayTrustedRootCertificate) AssignProperties_From_ApplicationGatewayTrustedRootCertificate(source *storage.ApplicationGatewayTrustedRootCertificate) error {

	// Data
	if source.Data != nil {
		datum := source.Data.Copy()
		certificate.Data = &datum
	} else {
		certificate.Data = nil
	}

	// KeyVaultSecretId
	certificate.KeyVaultSecretId = genruntime.ClonePointerToString(source.KeyVaultSecretId)

	// Name
	certificate.Name = genruntime.ClonePointerToString(source.Name)

	// No error
	return nil
}

// AssignProperties_To_ApplicationGatewayTrustedRootCertificate populates the provided destination ApplicationGatewayTrustedRootCertificate from our ApplicationGatewayTrustedRootCertificate
func (certificate *ApplicationGatewayTrustedRootCertificate) AssignProperties_To_ApplicationGatewayTrustedRootCertificate(destination *storage.ApplicationGatewayTrustedRootCertificate) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Data
	if certificate.Data != nil {
		datum := certificate.Data.Copy()
		destination.Data = &datum
	} else {
		destination.Data = nil
	}

	// KeyVaultSecretId
	destination.KeyVaultSecretId = genruntime.ClonePointerToString(certificate.KeyVaultSecretId)

	// Name
	destination.Name = genruntime.ClonePointerToString(certificate.Name)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ApplicationGatewayTrustedRootCertificate_STATUS populates our ApplicationGatewayTrustedRootCertificate from the provided source ApplicationGatewayTrustedRootCertificate_STATUS
func (certificate *ApplicationGatewayTrustedRootCertificate) Initialize_From_ApplicationGatewayTrustedRootCertificate_STATUS(source *ApplicationGatewayTrustedRootCertificate_STATUS) error {

	// No error
	return nil
}

// Trusted Root certificates of an application gateway.
type ApplicationGatewayTrustedRootCertificate_STATUS struct {
	// Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &ApplicationGatewayTrustedRootCertificate_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (certificate *ApplicationGatewayTrustedRootCertificate_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApplicationGatewayTrustedRootCertificate_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (certificate *ApplicationGatewayTrustedRootCertificate_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApplicationGatewayTrustedRootCertificate_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApplicationGatewayTrustedRootCertificate_STATUS, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		certificate.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_ApplicationGatewayTrustedRootCertificate_STATUS populates our ApplicationGatewayTrustedRootCertificate_STATUS from the provided source ApplicationGatewayTrustedRootCertificate_STATUS
func (certificate *ApplicationGatewayTrustedRootCertificate_STATUS) AssignProperties_From_ApplicationGatewayTrustedRootCertificate_STATUS(source *storage.ApplicationGatewayTrustedRootCertificate_STATUS) error {

	// Id
	certificate.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_ApplicationGatewayTrustedRootCertificate_STATUS populates the provided destination ApplicationGatewayTrustedRootCertificate_STATUS from our ApplicationGatewayTrustedRootCertificate_STATUS
func (certificate *ApplicationGatewayTrustedRootCertificate_STATUS) AssignProperties_To_ApplicationGatewayTrustedRootCertificate_STATUS(destination *storage.ApplicationGatewayTrustedRootCertificate_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(certificate.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// UrlPathMaps give a url path to the backend mapping information for PathBasedRouting.
type ApplicationGatewayUrlPathMap struct {
	// DefaultBackendAddressPool: Default backend address pool resource of URL path map.
	DefaultBackendAddressPool *SubResource `json:"defaultBackendAddressPool,omitempty"`

	// DefaultBackendHttpSettings: Default backend http settings resource of URL path map.
	DefaultBackendHttpSettings *SubResource `json:"defaultBackendHttpSettings,omitempty"`

	// DefaultLoadDistributionPolicy: Default Load Distribution Policy resource of URL path map.
	DefaultLoadDistributionPolicy *SubResource `json:"defaultLoadDistributionPolicy,omitempty"`

	// DefaultRedirectConfiguration: Default redirect configuration resource of URL path map.
	DefaultRedirectConfiguration *SubResource `json:"defaultRedirectConfiguration,omitempty"`

	// DefaultRewriteRuleSet: Default Rewrite rule set resource of URL path map.
	DefaultRewriteRuleSet *SubResource `json:"defaultRewriteRuleSet,omitempty"`

	// Name: Name of the URL path map that is unique within an Application Gateway.
	Name *string `json:"name,omitempty"`

	// PathRules: Path rule of URL path map resource.
	PathRules []ApplicationGatewayPathRule `json:"pathRules,omitempty"`
}

var _ genruntime.ARMTransformer = &ApplicationGatewayUrlPathMap{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (pathMap *ApplicationGatewayUrlPathMap) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if pathMap == nil {
		return nil, nil
	}
	result := &arm.ApplicationGatewayUrlPathMap{}

	// Set property "Name":
	if pathMap.Name != nil {
		name := *pathMap.Name
		result.Name = &name
	}

	// Set property "Properties":
	if pathMap.DefaultBackendAddressPool != nil ||
		pathMap.DefaultBackendHttpSettings != nil ||
		pathMap.DefaultLoadDistributionPolicy != nil ||
		pathMap.DefaultRedirectConfiguration != nil ||
		pathMap.DefaultRewriteRuleSet != nil ||
		pathMap.PathRules != nil {
		result.Properties = &arm.ApplicationGatewayUrlPathMapPropertiesFormat{}
	}
	if pathMap.DefaultBackendAddressPool != nil {
		defaultBackendAddressPool_ARM, err := (*pathMap.DefaultBackendAddressPool).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		defaultBackendAddressPool := *defaultBackendAddressPool_ARM.(*arm.SubResource)
		result.Properties.DefaultBackendAddressPool = &defaultBackendAddressPool
	}
	if pathMap.DefaultBackendHttpSettings != nil {
		defaultBackendHttpSettings_ARM, err := (*pathMap.DefaultBackendHttpSettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		defaultBackendHttpSettings := *defaultBackendHttpSettings_ARM.(*arm.SubResource)
		result.Properties.DefaultBackendHttpSettings = &defaultBackendHttpSettings
	}
	if pathMap.DefaultLoadDistributionPolicy != nil {
		defaultLoadDistributionPolicy_ARM, err := (*pathMap.DefaultLoadDistributionPolicy).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		defaultLoadDistributionPolicy := *defaultLoadDistributionPolicy_ARM.(*arm.SubResource)
		result.Properties.DefaultLoadDistributionPolicy = &defaultLoadDistributionPolicy
	}
	if pathMap.DefaultRedirectConfiguration != nil {
		defaultRedirectConfiguration_ARM, err := (*pathMap.DefaultRedirectConfiguration).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		defaultRedirectConfiguration := *defaultRedirectConfiguration_ARM.(*arm.SubResource)
		result.Properties.DefaultRedirectConfiguration = &defaultRedirectConfiguration
	}
	if pathMap.DefaultRewriteRuleSet != nil {
		defaultRewriteRuleSet_ARM, err := (*pathMap.DefaultRewriteRuleSet).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		defaultRewriteRuleSet := *defaultRewriteRuleSet_ARM.(*arm.SubResource)
		result.Properties.DefaultRewriteRuleSet = &defaultRewriteRuleSet
	}
	for _, item := range pathMap.PathRules {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.PathRules = append(result.Properties.PathRules, *item_ARM.(*arm.ApplicationGatewayPathRule))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (pathMap *ApplicationGatewayUrlPathMap) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApplicationGatewayUrlPathMap{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (pathMap *ApplicationGatewayUrlPathMap) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApplicationGatewayUrlPathMap)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApplicationGatewayUrlPathMap, got %T", armInput)
	}

	// Set property "DefaultBackendAddressPool":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DefaultBackendAddressPool != nil {
			var defaultBackendAddressPool1 SubResource
			err := defaultBackendAddressPool1.PopulateFromARM(owner, *typedInput.Properties.DefaultBackendAddressPool)
			if err != nil {
				return err
			}
			defaultBackendAddressPool := defaultBackendAddressPool1
			pathMap.DefaultBackendAddressPool = &defaultBackendAddressPool
		}
	}

	// Set property "DefaultBackendHttpSettings":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DefaultBackendHttpSettings != nil {
			var defaultBackendHttpSettings1 SubResource
			err := defaultBackendHttpSettings1.PopulateFromARM(owner, *typedInput.Properties.DefaultBackendHttpSettings)
			if err != nil {
				return err
			}
			defaultBackendHttpSettings := defaultBackendHttpSettings1
			pathMap.DefaultBackendHttpSettings = &defaultBackendHttpSettings
		}
	}

	// Set property "DefaultLoadDistributionPolicy":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DefaultLoadDistributionPolicy != nil {
			var defaultLoadDistributionPolicy1 SubResource
			err := defaultLoadDistributionPolicy1.PopulateFromARM(owner, *typedInput.Properties.DefaultLoadDistributionPolicy)
			if err != nil {
				return err
			}
			defaultLoadDistributionPolicy := defaultLoadDistributionPolicy1
			pathMap.DefaultLoadDistributionPolicy = &defaultLoadDistributionPolicy
		}
	}

	// Set property "DefaultRedirectConfiguration":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DefaultRedirectConfiguration != nil {
			var defaultRedirectConfiguration1 SubResource
			err := defaultRedirectConfiguration1.PopulateFromARM(owner, *typedInput.Properties.DefaultRedirectConfiguration)
			if err != nil {
				return err
			}
			defaultRedirectConfiguration := defaultRedirectConfiguration1
			pathMap.DefaultRedirectConfiguration = &defaultRedirectConfiguration
		}
	}

	// Set property "DefaultRewriteRuleSet":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DefaultRewriteRuleSet != nil {
			var defaultRewriteRuleSet1 SubResource
			err := defaultRewriteRuleSet1.PopulateFromARM(owner, *typedInput.Properties.DefaultRewriteRuleSet)
			if err != nil {
				return err
			}
			defaultRewriteRuleSet := defaultRewriteRuleSet1
			pathMap.DefaultRewriteRuleSet = &defaultRewriteRuleSet
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		pathMap.Name = &name
	}

	// Set property "PathRules":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.PathRules {
			var item1 ApplicationGatewayPathRule
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			pathMap.PathRules = append(pathMap.PathRules, item1)
		}
	}

	// No error
	return nil
}

// AssignProperties_From_ApplicationGatewayUrlPathMap populates our ApplicationGatewayUrlPathMap from the provided source ApplicationGatewayUrlPathMap
func (pathMap *ApplicationGatewayUrlPathMap) AssignProperties_From_ApplicationGatewayUrlPathMap(source *storage.ApplicationGatewayUrlPathMap) error {

	// DefaultBackendAddressPool
	if source.DefaultBackendAddressPool != nil {
		var defaultBackendAddressPool SubResource
		err := defaultBackendAddressPool.AssignProperties_From_SubResource(source.DefaultBackendAddressPool)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field DefaultBackendAddressPool")
		}
		pathMap.DefaultBackendAddressPool = &defaultBackendAddressPool
	} else {
		pathMap.DefaultBackendAddressPool = nil
	}

	// DefaultBackendHttpSettings
	if source.DefaultBackendHttpSettings != nil {
		var defaultBackendHttpSetting SubResource
		err := defaultBackendHttpSetting.AssignProperties_From_SubResource(source.DefaultBackendHttpSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field DefaultBackendHttpSettings")
		}
		pathMap.DefaultBackendHttpSettings = &defaultBackendHttpSetting
	} else {
		pathMap.DefaultBackendHttpSettings = nil
	}

	// DefaultLoadDistributionPolicy
	if source.DefaultLoadDistributionPolicy != nil {
		var defaultLoadDistributionPolicy SubResource
		err := defaultLoadDistributionPolicy.AssignProperties_From_SubResource(source.DefaultLoadDistributionPolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field DefaultLoadDistributionPolicy")
		}
		pathMap.DefaultLoadDistributionPolicy = &defaultLoadDistributionPolicy
	} else {
		pathMap.DefaultLoadDistributionPolicy = nil
	}

	// DefaultRedirectConfiguration
	if source.DefaultRedirectConfiguration != nil {
		var defaultRedirectConfiguration SubResource
		err := defaultRedirectConfiguration.AssignProperties_From_SubResource(source.DefaultRedirectConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field DefaultRedirectConfiguration")
		}
		pathMap.DefaultRedirectConfiguration = &defaultRedirectConfiguration
	} else {
		pathMap.DefaultRedirectConfiguration = nil
	}

	// DefaultRewriteRuleSet
	if source.DefaultRewriteRuleSet != nil {
		var defaultRewriteRuleSet SubResource
		err := defaultRewriteRuleSet.AssignProperties_From_SubResource(source.DefaultRewriteRuleSet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field DefaultRewriteRuleSet")
		}
		pathMap.DefaultRewriteRuleSet = &defaultRewriteRuleSet
	} else {
		pathMap.DefaultRewriteRuleSet = nil
	}

	// Name
	pathMap.Name = genruntime.ClonePointerToString(source.Name)

	// PathRules
	if source.PathRules != nil {
		pathRuleList := make([]ApplicationGatewayPathRule, len(source.PathRules))
		for pathRuleIndex, pathRuleItem := range source.PathRules {
			// Shadow the loop variable to avoid aliasing
			pathRuleItem := pathRuleItem
			var pathRule ApplicationGatewayPathRule
			err := pathRule.AssignProperties_From_ApplicationGatewayPathRule(&pathRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ApplicationGatewayPathRule() to populate field PathRules")
			}
			pathRuleList[pathRuleIndex] = pathRule
		}
		pathMap.PathRules = pathRuleList
	} else {
		pathMap.PathRules = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ApplicationGatewayUrlPathMap populates the provided destination ApplicationGatewayUrlPathMap from our ApplicationGatewayUrlPathMap
func (pathMap *ApplicationGatewayUrlPathMap) AssignProperties_To_ApplicationGatewayUrlPathMap(destination *storage.ApplicationGatewayUrlPathMap) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DefaultBackendAddressPool
	if pathMap.DefaultBackendAddressPool != nil {
		var defaultBackendAddressPool storage.SubResource
		err := pathMap.DefaultBackendAddressPool.AssignProperties_To_SubResource(&defaultBackendAddressPool)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field DefaultBackendAddressPool")
		}
		destination.DefaultBackendAddressPool = &defaultBackendAddressPool
	} else {
		destination.DefaultBackendAddressPool = nil
	}

	// DefaultBackendHttpSettings
	if pathMap.DefaultBackendHttpSettings != nil {
		var defaultBackendHttpSetting storage.SubResource
		err := pathMap.DefaultBackendHttpSettings.AssignProperties_To_SubResource(&defaultBackendHttpSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field DefaultBackendHttpSettings")
		}
		destination.DefaultBackendHttpSettings = &defaultBackendHttpSetting
	} else {
		destination.DefaultBackendHttpSettings = nil
	}

	// DefaultLoadDistributionPolicy
	if pathMap.DefaultLoadDistributionPolicy != nil {
		var defaultLoadDistributionPolicy storage.SubResource
		err := pathMap.DefaultLoadDistributionPolicy.AssignProperties_To_SubResource(&defaultLoadDistributionPolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field DefaultLoadDistributionPolicy")
		}
		destination.DefaultLoadDistributionPolicy = &defaultLoadDistributionPolicy
	} else {
		destination.DefaultLoadDistributionPolicy = nil
	}

	// DefaultRedirectConfiguration
	if pathMap.DefaultRedirectConfiguration != nil {
		var defaultRedirectConfiguration storage.SubResource
		err := pathMap.DefaultRedirectConfiguration.AssignProperties_To_SubResource(&defaultRedirectConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field DefaultRedirectConfiguration")
		}
		destination.DefaultRedirectConfiguration = &defaultRedirectConfiguration
	} else {
		destination.DefaultRedirectConfiguration = nil
	}

	// DefaultRewriteRuleSet
	if pathMap.DefaultRewriteRuleSet != nil {
		var defaultRewriteRuleSet storage.SubResource
		err := pathMap.DefaultRewriteRuleSet.AssignProperties_To_SubResource(&defaultRewriteRuleSet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field DefaultRewriteRuleSet")
		}
		destination.DefaultRewriteRuleSet = &defaultRewriteRuleSet
	} else {
		destination.DefaultRewriteRuleSet = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(pathMap.Name)

	// PathRules
	if pathMap.PathRules != nil {
		pathRuleList := make([]storage.ApplicationGatewayPathRule, len(pathMap.PathRules))
		for pathRuleIndex, pathRuleItem := range pathMap.PathRules {
			// Shadow the loop variable to avoid aliasing
			pathRuleItem := pathRuleItem
			var pathRule storage.ApplicationGatewayPathRule
			err := pathRuleItem.AssignProperties_To_ApplicationGatewayPathRule(&pathRule)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ApplicationGatewayPathRule() to populate field PathRules")
			}
			pathRuleList[pathRuleIndex] = pathRule
		}
		destination.PathRules = pathRuleList
	} else {
		destination.PathRules = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ApplicationGatewayUrlPathMap_STATUS populates our ApplicationGatewayUrlPathMap from the provided source ApplicationGatewayUrlPathMap_STATUS
func (pathMap *ApplicationGatewayUrlPathMap) Initialize_From_ApplicationGatewayUrlPathMap_STATUS(source *ApplicationGatewayUrlPathMap_STATUS) error {

	// No error
	return nil
}

// UrlPathMaps give a url path to the backend mapping information for PathBasedRouting.
type ApplicationGatewayUrlPathMap_STATUS struct {
	// Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &ApplicationGatewayUrlPathMap_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (pathMap *ApplicationGatewayUrlPathMap_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApplicationGatewayUrlPathMap_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (pathMap *ApplicationGatewayUrlPathMap_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApplicationGatewayUrlPathMap_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApplicationGatewayUrlPathMap_STATUS, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		pathMap.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_ApplicationGatewayUrlPathMap_STATUS populates our ApplicationGatewayUrlPathMap_STATUS from the provided source ApplicationGatewayUrlPathMap_STATUS
func (pathMap *ApplicationGatewayUrlPathMap_STATUS) AssignProperties_From_ApplicationGatewayUrlPathMap_STATUS(source *storage.ApplicationGatewayUrlPathMap_STATUS) error {

	// Id
	pathMap.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_ApplicationGatewayUrlPathMap_STATUS populates the provided destination ApplicationGatewayUrlPathMap_STATUS from our ApplicationGatewayUrlPathMap_STATUS
func (pathMap *ApplicationGatewayUrlPathMap_STATUS) AssignProperties_To_ApplicationGatewayUrlPathMap_STATUS(destination *storage.ApplicationGatewayUrlPathMap_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(pathMap.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Application gateway web application firewall configuration.
type ApplicationGatewayWebApplicationFirewallConfiguration struct {
	// DisabledRuleGroups: The disabled rule groups.
	DisabledRuleGroups []ApplicationGatewayFirewallDisabledRuleGroup `json:"disabledRuleGroups,omitempty"`

	// +kubebuilder:validation:Required
	// Enabled: Whether the web application firewall is enabled or not.
	Enabled *bool `json:"enabled,omitempty"`

	// Exclusions: The exclusion list.
	Exclusions []ApplicationGatewayFirewallExclusion `json:"exclusions,omitempty"`

	// +kubebuilder:validation:Minimum=0
	// FileUploadLimitInMb: Maximum file upload size in Mb for WAF.
	FileUploadLimitInMb *int `json:"fileUploadLimitInMb,omitempty"`

	// +kubebuilder:validation:Required
	// FirewallMode: Web application firewall mode.
	FirewallMode *ApplicationGatewayWebApplicationFirewallConfiguration_FirewallMode `json:"firewallMode,omitempty"`

	// +kubebuilder:validation:Maximum=128
	// +kubebuilder:validation:Minimum=8
	// MaxRequestBodySize: Maximum request body size for WAF.
	MaxRequestBodySize *int `json:"maxRequestBodySize,omitempty"`

	// +kubebuilder:validation:Maximum=128
	// +kubebuilder:validation:Minimum=8
	// MaxRequestBodySizeInKb: Maximum request body size in Kb for WAF.
	MaxRequestBodySizeInKb *int `json:"maxRequestBodySizeInKb,omitempty"`

	// RequestBodyCheck: Whether allow WAF to check request Body.
	RequestBodyCheck *bool `json:"requestBodyCheck,omitempty"`

	// +kubebuilder:validation:Required
	// RuleSetType: The type of the web application firewall rule set. Possible values are: 'OWASP'.
	RuleSetType *string `json:"ruleSetType,omitempty"`

	// +kubebuilder:validation:Required
	// RuleSetVersion: The version of the rule set type.
	RuleSetVersion *string `json:"ruleSetVersion,omitempty"`
}

var _ genruntime.ARMTransformer = &ApplicationGatewayWebApplicationFirewallConfiguration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (configuration *ApplicationGatewayWebApplicationFirewallConfiguration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if configuration == nil {
		return nil, nil
	}
	result := &arm.ApplicationGatewayWebApplicationFirewallConfiguration{}

	// Set property "DisabledRuleGroups":
	for _, item := range configuration.DisabledRuleGroups {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.DisabledRuleGroups = append(result.DisabledRuleGroups, *item_ARM.(*arm.ApplicationGatewayFirewallDisabledRuleGroup))
	}

	// Set property "Enabled":
	if configuration.Enabled != nil {
		enabled := *configuration.Enabled
		result.Enabled = &enabled
	}

	// Set property "Exclusions":
	for _, item := range configuration.Exclusions {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Exclusions = append(result.Exclusions, *item_ARM.(*arm.ApplicationGatewayFirewallExclusion))
	}

	// Set property "FileUploadLimitInMb":
	if configuration.FileUploadLimitInMb != nil {
		fileUploadLimitInMb := *configuration.FileUploadLimitInMb
		result.FileUploadLimitInMb = &fileUploadLimitInMb
	}

	// Set property "FirewallMode":
	if configuration.FirewallMode != nil {
		var temp string
		temp = string(*configuration.FirewallMode)
		firewallMode := arm.ApplicationGatewayWebApplicationFirewallConfiguration_FirewallMode(temp)
		result.FirewallMode = &firewallMode
	}

	// Set property "MaxRequestBodySize":
	if configuration.MaxRequestBodySize != nil {
		maxRequestBodySize := *configuration.MaxRequestBodySize
		result.MaxRequestBodySize = &maxRequestBodySize
	}

	// Set property "MaxRequestBodySizeInKb":
	if configuration.MaxRequestBodySizeInKb != nil {
		maxRequestBodySizeInKb := *configuration.MaxRequestBodySizeInKb
		result.MaxRequestBodySizeInKb = &maxRequestBodySizeInKb
	}

	// Set property "RequestBodyCheck":
	if configuration.RequestBodyCheck != nil {
		requestBodyCheck := *configuration.RequestBodyCheck
		result.RequestBodyCheck = &requestBodyCheck
	}

	// Set property "RuleSetType":
	if configuration.RuleSetType != nil {
		ruleSetType := *configuration.RuleSetType
		result.RuleSetType = &ruleSetType
	}

	// Set property "RuleSetVersion":
	if configuration.RuleSetVersion != nil {
		ruleSetVersion := *configuration.RuleSetVersion
		result.RuleSetVersion = &ruleSetVersion
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *ApplicationGatewayWebApplicationFirewallConfiguration) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApplicationGatewayWebApplicationFirewallConfiguration{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *ApplicationGatewayWebApplicationFirewallConfiguration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApplicationGatewayWebApplicationFirewallConfiguration)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApplicationGatewayWebApplicationFirewallConfiguration, got %T", armInput)
	}

	// Set property "DisabledRuleGroups":
	for _, item := range typedInput.DisabledRuleGroups {
		var item1 ApplicationGatewayFirewallDisabledRuleGroup
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		configuration.DisabledRuleGroups = append(configuration.DisabledRuleGroups, item1)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		configuration.Enabled = &enabled
	}

	// Set property "Exclusions":
	for _, item := range typedInput.Exclusions {
		var item1 ApplicationGatewayFirewallExclusion
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		configuration.Exclusions = append(configuration.Exclusions, item1)
	}

	// Set property "FileUploadLimitInMb":
	if typedInput.FileUploadLimitInMb != nil {
		fileUploadLimitInMb := *typedInput.FileUploadLimitInMb
		configuration.FileUploadLimitInMb = &fileUploadLimitInMb
	}

	// Set property "FirewallMode":
	if typedInput.FirewallMode != nil {
		var temp string
		temp = string(*typedInput.FirewallMode)
		firewallMode := ApplicationGatewayWebApplicationFirewallConfiguration_FirewallMode(temp)
		configuration.FirewallMode = &firewallMode
	}

	// Set property "MaxRequestBodySize":
	if typedInput.MaxRequestBodySize != nil {
		maxRequestBodySize := *typedInput.MaxRequestBodySize
		configuration.MaxRequestBodySize = &maxRequestBodySize
	}

	// Set property "MaxRequestBodySizeInKb":
	if typedInput.MaxRequestBodySizeInKb != nil {
		maxRequestBodySizeInKb := *typedInput.MaxRequestBodySizeInKb
		configuration.MaxRequestBodySizeInKb = &maxRequestBodySizeInKb
	}

	// Set property "RequestBodyCheck":
	if typedInput.RequestBodyCheck != nil {
		requestBodyCheck := *typedInput.RequestBodyCheck
		configuration.RequestBodyCheck = &requestBodyCheck
	}

	// Set property "RuleSetType":
	if typedInput.RuleSetType != nil {
		ruleSetType := *typedInput.RuleSetType
		configuration.RuleSetType = &ruleSetType
	}

	// Set property "RuleSetVersion":
	if typedInput.RuleSetVersion != nil {
		ruleSetVersion := *typedInput.RuleSetVersion
		configuration.RuleSetVersion = &ruleSetVersion
	}

	// No error
	return nil
}

// AssignProperties_From_ApplicationGatewayWebApplicationFirewallConfiguration populates our ApplicationGatewayWebApplicationFirewallConfiguration from the provided source ApplicationGatewayWebApplicationFirewallConfiguration
func (configuration *ApplicationGatewayWebApplicationFirewallConfiguration) AssignProperties_From_ApplicationGatewayWebApplicationFirewallConfiguration(source *storage.ApplicationGatewayWebApplicationFirewallConfiguration) error {

	// DisabledRuleGroups
	if source.DisabledRuleGroups != nil {
		disabledRuleGroupList := make([]ApplicationGatewayFirewallDisabledRuleGroup, len(source.DisabledRuleGroups))
		for disabledRuleGroupIndex, disabledRuleGroupItem := range source.DisabledRuleGroups {
			// Shadow the loop variable to avoid aliasing
			disabledRuleGroupItem := disabledRuleGroupItem
			var disabledRuleGroup ApplicationGatewayFirewallDisabledRuleGroup
			err := disabledRuleGroup.AssignProperties_From_ApplicationGatewayFirewallDisabledRuleGroup(&disabledRuleGroupItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ApplicationGatewayFirewallDisabledRuleGroup() to populate field DisabledRuleGroups")
			}
			disabledRuleGroupList[disabledRuleGroupIndex] = disabledRuleGroup
		}
		configuration.DisabledRuleGroups = disabledRuleGroupList
	} else {
		configuration.DisabledRuleGroups = nil
	}

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		configuration.Enabled = &enabled
	} else {
		configuration.Enabled = nil
	}

	// Exclusions
	if source.Exclusions != nil {
		exclusionList := make([]ApplicationGatewayFirewallExclusion, len(source.Exclusions))
		for exclusionIndex, exclusionItem := range source.Exclusions {
			// Shadow the loop variable to avoid aliasing
			exclusionItem := exclusionItem
			var exclusion ApplicationGatewayFirewallExclusion
			err := exclusion.AssignProperties_From_ApplicationGatewayFirewallExclusion(&exclusionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ApplicationGatewayFirewallExclusion() to populate field Exclusions")
			}
			exclusionList[exclusionIndex] = exclusion
		}
		configuration.Exclusions = exclusionList
	} else {
		configuration.Exclusions = nil
	}

	// FileUploadLimitInMb
	if source.FileUploadLimitInMb != nil {
		fileUploadLimitInMb := *source.FileUploadLimitInMb
		configuration.FileUploadLimitInMb = &fileUploadLimitInMb
	} else {
		configuration.FileUploadLimitInMb = nil
	}

	// FirewallMode
	if source.FirewallMode != nil {
		firewallMode := *source.FirewallMode
		firewallModeTemp := genruntime.ToEnum(firewallMode, applicationGatewayWebApplicationFirewallConfiguration_FirewallMode_Values)
		configuration.FirewallMode = &firewallModeTemp
	} else {
		configuration.FirewallMode = nil
	}

	// MaxRequestBodySize
	if source.MaxRequestBodySize != nil {
		maxRequestBodySize := *source.MaxRequestBodySize
		configuration.MaxRequestBodySize = &maxRequestBodySize
	} else {
		configuration.MaxRequestBodySize = nil
	}

	// MaxRequestBodySizeInKb
	if source.MaxRequestBodySizeInKb != nil {
		maxRequestBodySizeInKb := *source.MaxRequestBodySizeInKb
		configuration.MaxRequestBodySizeInKb = &maxRequestBodySizeInKb
	} else {
		configuration.MaxRequestBodySizeInKb = nil
	}

	// RequestBodyCheck
	if source.RequestBodyCheck != nil {
		requestBodyCheck := *source.RequestBodyCheck
		configuration.RequestBodyCheck = &requestBodyCheck
	} else {
		configuration.RequestBodyCheck = nil
	}

	// RuleSetType
	configuration.RuleSetType = genruntime.ClonePointerToString(source.RuleSetType)

	// RuleSetVersion
	configuration.RuleSetVersion = genruntime.ClonePointerToString(source.RuleSetVersion)

	// No error
	return nil
}

// AssignProperties_To_ApplicationGatewayWebApplicationFirewallConfiguration populates the provided destination ApplicationGatewayWebApplicationFirewallConfiguration from our ApplicationGatewayWebApplicationFirewallConfiguration
func (configuration *ApplicationGatewayWebApplicationFirewallConfiguration) AssignProperties_To_ApplicationGatewayWebApplicationFirewallConfiguration(destination *storage.ApplicationGatewayWebApplicationFirewallConfiguration) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DisabledRuleGroups
	if configuration.DisabledRuleGroups != nil {
		disabledRuleGroupList := make([]storage.ApplicationGatewayFirewallDisabledRuleGroup, len(configuration.DisabledRuleGroups))
		for disabledRuleGroupIndex, disabledRuleGroupItem := range configuration.DisabledRuleGroups {
			// Shadow the loop variable to avoid aliasing
			disabledRuleGroupItem := disabledRuleGroupItem
			var disabledRuleGroup storage.ApplicationGatewayFirewallDisabledRuleGroup
			err := disabledRuleGroupItem.AssignProperties_To_ApplicationGatewayFirewallDisabledRuleGroup(&disabledRuleGroup)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ApplicationGatewayFirewallDisabledRuleGroup() to populate field DisabledRuleGroups")
			}
			disabledRuleGroupList[disabledRuleGroupIndex] = disabledRuleGroup
		}
		destination.DisabledRuleGroups = disabledRuleGroupList
	} else {
		destination.DisabledRuleGroups = nil
	}

	// Enabled
	if configuration.Enabled != nil {
		enabled := *configuration.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Exclusions
	if configuration.Exclusions != nil {
		exclusionList := make([]storage.ApplicationGatewayFirewallExclusion, len(configuration.Exclusions))
		for exclusionIndex, exclusionItem := range configuration.Exclusions {
			// Shadow the loop variable to avoid aliasing
			exclusionItem := exclusionItem
			var exclusion storage.ApplicationGatewayFirewallExclusion
			err := exclusionItem.AssignProperties_To_ApplicationGatewayFirewallExclusion(&exclusion)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ApplicationGatewayFirewallExclusion() to populate field Exclusions")
			}
			exclusionList[exclusionIndex] = exclusion
		}
		destination.Exclusions = exclusionList
	} else {
		destination.Exclusions = nil
	}

	// FileUploadLimitInMb
	if configuration.FileUploadLimitInMb != nil {
		fileUploadLimitInMb := *configuration.FileUploadLimitInMb
		destination.FileUploadLimitInMb = &fileUploadLimitInMb
	} else {
		destination.FileUploadLimitInMb = nil
	}

	// FirewallMode
	if configuration.FirewallMode != nil {
		firewallMode := string(*configuration.FirewallMode)
		destination.FirewallMode = &firewallMode
	} else {
		destination.FirewallMode = nil
	}

	// MaxRequestBodySize
	if configuration.MaxRequestBodySize != nil {
		maxRequestBodySize := *configuration.MaxRequestBodySize
		destination.MaxRequestBodySize = &maxRequestBodySize
	} else {
		destination.MaxRequestBodySize = nil
	}

	// MaxRequestBodySizeInKb
	if configuration.MaxRequestBodySizeInKb != nil {
		maxRequestBodySizeInKb := *configuration.MaxRequestBodySizeInKb
		destination.MaxRequestBodySizeInKb = &maxRequestBodySizeInKb
	} else {
		destination.MaxRequestBodySizeInKb = nil
	}

	// RequestBodyCheck
	if configuration.RequestBodyCheck != nil {
		requestBodyCheck := *configuration.RequestBodyCheck
		destination.RequestBodyCheck = &requestBodyCheck
	} else {
		destination.RequestBodyCheck = nil
	}

	// RuleSetType
	destination.RuleSetType = genruntime.ClonePointerToString(configuration.RuleSetType)

	// RuleSetVersion
	destination.RuleSetVersion = genruntime.ClonePointerToString(configuration.RuleSetVersion)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ApplicationGatewayWebApplicationFirewallConfiguration_STATUS populates our ApplicationGatewayWebApplicationFirewallConfiguration from the provided source ApplicationGatewayWebApplicationFirewallConfiguration_STATUS
func (configuration *ApplicationGatewayWebApplicationFirewallConfiguration) Initialize_From_ApplicationGatewayWebApplicationFirewallConfiguration_STATUS(source *ApplicationGatewayWebApplicationFirewallConfiguration_STATUS) error {

	// DisabledRuleGroups
	if source.DisabledRuleGroups != nil {
		disabledRuleGroupList := make([]ApplicationGatewayFirewallDisabledRuleGroup, len(source.DisabledRuleGroups))
		for disabledRuleGroupIndex, disabledRuleGroupItem := range source.DisabledRuleGroups {
			// Shadow the loop variable to avoid aliasing
			disabledRuleGroupItem := disabledRuleGroupItem
			var disabledRuleGroup ApplicationGatewayFirewallDisabledRuleGroup
			err := disabledRuleGroup.Initialize_From_ApplicationGatewayFirewallDisabledRuleGroup_STATUS(&disabledRuleGroupItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_ApplicationGatewayFirewallDisabledRuleGroup_STATUS() to populate field DisabledRuleGroups")
			}
			disabledRuleGroupList[disabledRuleGroupIndex] = disabledRuleGroup
		}
		configuration.DisabledRuleGroups = disabledRuleGroupList
	} else {
		configuration.DisabledRuleGroups = nil
	}

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		configuration.Enabled = &enabled
	} else {
		configuration.Enabled = nil
	}

	// Exclusions
	if source.Exclusions != nil {
		exclusionList := make([]ApplicationGatewayFirewallExclusion, len(source.Exclusions))
		for exclusionIndex, exclusionItem := range source.Exclusions {
			// Shadow the loop variable to avoid aliasing
			exclusionItem := exclusionItem
			var exclusion ApplicationGatewayFirewallExclusion
			err := exclusion.Initialize_From_ApplicationGatewayFirewallExclusion_STATUS(&exclusionItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_ApplicationGatewayFirewallExclusion_STATUS() to populate field Exclusions")
			}
			exclusionList[exclusionIndex] = exclusion
		}
		configuration.Exclusions = exclusionList
	} else {
		configuration.Exclusions = nil
	}

	// FileUploadLimitInMb
	if source.FileUploadLimitInMb != nil {
		fileUploadLimitInMb := *source.FileUploadLimitInMb
		configuration.FileUploadLimitInMb = &fileUploadLimitInMb
	} else {
		configuration.FileUploadLimitInMb = nil
	}

	// FirewallMode
	if source.FirewallMode != nil {
		firewallMode := genruntime.ToEnum(string(*source.FirewallMode), applicationGatewayWebApplicationFirewallConfiguration_FirewallMode_Values)
		configuration.FirewallMode = &firewallMode
	} else {
		configuration.FirewallMode = nil
	}

	// MaxRequestBodySize
	if source.MaxRequestBodySize != nil {
		maxRequestBodySize := *source.MaxRequestBodySize
		configuration.MaxRequestBodySize = &maxRequestBodySize
	} else {
		configuration.MaxRequestBodySize = nil
	}

	// MaxRequestBodySizeInKb
	if source.MaxRequestBodySizeInKb != nil {
		maxRequestBodySizeInKb := *source.MaxRequestBodySizeInKb
		configuration.MaxRequestBodySizeInKb = &maxRequestBodySizeInKb
	} else {
		configuration.MaxRequestBodySizeInKb = nil
	}

	// RequestBodyCheck
	if source.RequestBodyCheck != nil {
		requestBodyCheck := *source.RequestBodyCheck
		configuration.RequestBodyCheck = &requestBodyCheck
	} else {
		configuration.RequestBodyCheck = nil
	}

	// RuleSetType
	configuration.RuleSetType = genruntime.ClonePointerToString(source.RuleSetType)

	// RuleSetVersion
	configuration.RuleSetVersion = genruntime.ClonePointerToString(source.RuleSetVersion)

	// No error
	return nil
}

// Application gateway web application firewall configuration.
type ApplicationGatewayWebApplicationFirewallConfiguration_STATUS struct {
	// DisabledRuleGroups: The disabled rule groups.
	DisabledRuleGroups []ApplicationGatewayFirewallDisabledRuleGroup_STATUS `json:"disabledRuleGroups,omitempty"`

	// Enabled: Whether the web application firewall is enabled or not.
	Enabled *bool `json:"enabled,omitempty"`

	// Exclusions: The exclusion list.
	Exclusions []ApplicationGatewayFirewallExclusion_STATUS `json:"exclusions,omitempty"`

	// FileUploadLimitInMb: Maximum file upload size in Mb for WAF.
	FileUploadLimitInMb *int `json:"fileUploadLimitInMb,omitempty"`

	// FirewallMode: Web application firewall mode.
	FirewallMode *ApplicationGatewayWebApplicationFirewallConfiguration_FirewallMode_STATUS `json:"firewallMode,omitempty"`

	// MaxRequestBodySize: Maximum request body size for WAF.
	MaxRequestBodySize *int `json:"maxRequestBodySize,omitempty"`

	// MaxRequestBodySizeInKb: Maximum request body size in Kb for WAF.
	MaxRequestBodySizeInKb *int `json:"maxRequestBodySizeInKb,omitempty"`

	// RequestBodyCheck: Whether allow WAF to check request Body.
	RequestBodyCheck *bool `json:"requestBodyCheck,omitempty"`

	// RuleSetType: The type of the web application firewall rule set. Possible values are: 'OWASP'.
	RuleSetType *string `json:"ruleSetType,omitempty"`

	// RuleSetVersion: The version of the rule set type.
	RuleSetVersion *string `json:"ruleSetVersion,omitempty"`
}

var _ genruntime.FromARMConverter = &ApplicationGatewayWebApplicationFirewallConfiguration_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *ApplicationGatewayWebApplicationFirewallConfiguration_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApplicationGatewayWebApplicationFirewallConfiguration_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *ApplicationGatewayWebApplicationFirewallConfiguration_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApplicationGatewayWebApplicationFirewallConfiguration_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApplicationGatewayWebApplicationFirewallConfiguration_STATUS, got %T", armInput)
	}

	// Set property "DisabledRuleGroups":
	for _, item := range typedInput.DisabledRuleGroups {
		var item1 ApplicationGatewayFirewallDisabledRuleGroup_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		configuration.DisabledRuleGroups = append(configuration.DisabledRuleGroups, item1)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		configuration.Enabled = &enabled
	}

	// Set property "Exclusions":
	for _, item := range typedInput.Exclusions {
		var item1 ApplicationGatewayFirewallExclusion_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		configuration.Exclusions = append(configuration.Exclusions, item1)
	}

	// Set property "FileUploadLimitInMb":
	if typedInput.FileUploadLimitInMb != nil {
		fileUploadLimitInMb := *typedInput.FileUploadLimitInMb
		configuration.FileUploadLimitInMb = &fileUploadLimitInMb
	}

	// Set property "FirewallMode":
	if typedInput.FirewallMode != nil {
		var temp string
		temp = string(*typedInput.FirewallMode)
		firewallMode := ApplicationGatewayWebApplicationFirewallConfiguration_FirewallMode_STATUS(temp)
		configuration.FirewallMode = &firewallMode
	}

	// Set property "MaxRequestBodySize":
	if typedInput.MaxRequestBodySize != nil {
		maxRequestBodySize := *typedInput.MaxRequestBodySize
		configuration.MaxRequestBodySize = &maxRequestBodySize
	}

	// Set property "MaxRequestBodySizeInKb":
	if typedInput.MaxRequestBodySizeInKb != nil {
		maxRequestBodySizeInKb := *typedInput.MaxRequestBodySizeInKb
		configuration.MaxRequestBodySizeInKb = &maxRequestBodySizeInKb
	}

	// Set property "RequestBodyCheck":
	if typedInput.RequestBodyCheck != nil {
		requestBodyCheck := *typedInput.RequestBodyCheck
		configuration.RequestBodyCheck = &requestBodyCheck
	}

	// Set property "RuleSetType":
	if typedInput.RuleSetType != nil {
		ruleSetType := *typedInput.RuleSetType
		configuration.RuleSetType = &ruleSetType
	}

	// Set property "RuleSetVersion":
	if typedInput.RuleSetVersion != nil {
		ruleSetVersion := *typedInput.RuleSetVersion
		configuration.RuleSetVersion = &ruleSetVersion
	}

	// No error
	return nil
}

// AssignProperties_From_ApplicationGatewayWebApplicationFirewallConfiguration_STATUS populates our ApplicationGatewayWebApplicationFirewallConfiguration_STATUS from the provided source ApplicationGatewayWebApplicationFirewallConfiguration_STATUS
func (configuration *ApplicationGatewayWebApplicationFirewallConfiguration_STATUS) AssignProperties_From_ApplicationGatewayWebApplicationFirewallConfiguration_STATUS(source *storage.ApplicationGatewayWebApplicationFirewallConfiguration_STATUS) error {

	// DisabledRuleGroups
	if source.DisabledRuleGroups != nil {
		disabledRuleGroupList := make([]ApplicationGatewayFirewallDisabledRuleGroup_STATUS, len(source.DisabledRuleGroups))
		for disabledRuleGroupIndex, disabledRuleGroupItem := range source.DisabledRuleGroups {
			// Shadow the loop variable to avoid aliasing
			disabledRuleGroupItem := disabledRuleGroupItem
			var disabledRuleGroup ApplicationGatewayFirewallDisabledRuleGroup_STATUS
			err := disabledRuleGroup.AssignProperties_From_ApplicationGatewayFirewallDisabledRuleGroup_STATUS(&disabledRuleGroupItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ApplicationGatewayFirewallDisabledRuleGroup_STATUS() to populate field DisabledRuleGroups")
			}
			disabledRuleGroupList[disabledRuleGroupIndex] = disabledRuleGroup
		}
		configuration.DisabledRuleGroups = disabledRuleGroupList
	} else {
		configuration.DisabledRuleGroups = nil
	}

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		configuration.Enabled = &enabled
	} else {
		configuration.Enabled = nil
	}

	// Exclusions
	if source.Exclusions != nil {
		exclusionList := make([]ApplicationGatewayFirewallExclusion_STATUS, len(source.Exclusions))
		for exclusionIndex, exclusionItem := range source.Exclusions {
			// Shadow the loop variable to avoid aliasing
			exclusionItem := exclusionItem
			var exclusion ApplicationGatewayFirewallExclusion_STATUS
			err := exclusion.AssignProperties_From_ApplicationGatewayFirewallExclusion_STATUS(&exclusionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ApplicationGatewayFirewallExclusion_STATUS() to populate field Exclusions")
			}
			exclusionList[exclusionIndex] = exclusion
		}
		configuration.Exclusions = exclusionList
	} else {
		configuration.Exclusions = nil
	}

	// FileUploadLimitInMb
	configuration.FileUploadLimitInMb = genruntime.ClonePointerToInt(source.FileUploadLimitInMb)

	// FirewallMode
	if source.FirewallMode != nil {
		firewallMode := *source.FirewallMode
		firewallModeTemp := genruntime.ToEnum(firewallMode, applicationGatewayWebApplicationFirewallConfiguration_FirewallMode_STATUS_Values)
		configuration.FirewallMode = &firewallModeTemp
	} else {
		configuration.FirewallMode = nil
	}

	// MaxRequestBodySize
	configuration.MaxRequestBodySize = genruntime.ClonePointerToInt(source.MaxRequestBodySize)

	// MaxRequestBodySizeInKb
	configuration.MaxRequestBodySizeInKb = genruntime.ClonePointerToInt(source.MaxRequestBodySizeInKb)

	// RequestBodyCheck
	if source.RequestBodyCheck != nil {
		requestBodyCheck := *source.RequestBodyCheck
		configuration.RequestBodyCheck = &requestBodyCheck
	} else {
		configuration.RequestBodyCheck = nil
	}

	// RuleSetType
	configuration.RuleSetType = genruntime.ClonePointerToString(source.RuleSetType)

	// RuleSetVersion
	configuration.RuleSetVersion = genruntime.ClonePointerToString(source.RuleSetVersion)

	// No error
	return nil
}

// AssignProperties_To_ApplicationGatewayWebApplicationFirewallConfiguration_STATUS populates the provided destination ApplicationGatewayWebApplicationFirewallConfiguration_STATUS from our ApplicationGatewayWebApplicationFirewallConfiguration_STATUS
func (configuration *ApplicationGatewayWebApplicationFirewallConfiguration_STATUS) AssignProperties_To_ApplicationGatewayWebApplicationFirewallConfiguration_STATUS(destination *storage.ApplicationGatewayWebApplicationFirewallConfiguration_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DisabledRuleGroups
	if configuration.DisabledRuleGroups != nil {
		disabledRuleGroupList := make([]storage.ApplicationGatewayFirewallDisabledRuleGroup_STATUS, len(configuration.DisabledRuleGroups))
		for disabledRuleGroupIndex, disabledRuleGroupItem := range configuration.DisabledRuleGroups {
			// Shadow the loop variable to avoid aliasing
			disabledRuleGroupItem := disabledRuleGroupItem
			var disabledRuleGroup storage.ApplicationGatewayFirewallDisabledRuleGroup_STATUS
			err := disabledRuleGroupItem.AssignProperties_To_ApplicationGatewayFirewallDisabledRuleGroup_STATUS(&disabledRuleGroup)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ApplicationGatewayFirewallDisabledRuleGroup_STATUS() to populate field DisabledRuleGroups")
			}
			disabledRuleGroupList[disabledRuleGroupIndex] = disabledRuleGroup
		}
		destination.DisabledRuleGroups = disabledRuleGroupList
	} else {
		destination.DisabledRuleGroups = nil
	}

	// Enabled
	if configuration.Enabled != nil {
		enabled := *configuration.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Exclusions
	if configuration.Exclusions != nil {
		exclusionList := make([]storage.ApplicationGatewayFirewallExclusion_STATUS, len(configuration.Exclusions))
		for exclusionIndex, exclusionItem := range configuration.Exclusions {
			// Shadow the loop variable to avoid aliasing
			exclusionItem := exclusionItem
			var exclusion storage.ApplicationGatewayFirewallExclusion_STATUS
			err := exclusionItem.AssignProperties_To_ApplicationGatewayFirewallExclusion_STATUS(&exclusion)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ApplicationGatewayFirewallExclusion_STATUS() to populate field Exclusions")
			}
			exclusionList[exclusionIndex] = exclusion
		}
		destination.Exclusions = exclusionList
	} else {
		destination.Exclusions = nil
	}

	// FileUploadLimitInMb
	destination.FileUploadLimitInMb = genruntime.ClonePointerToInt(configuration.FileUploadLimitInMb)

	// FirewallMode
	if configuration.FirewallMode != nil {
		firewallMode := string(*configuration.FirewallMode)
		destination.FirewallMode = &firewallMode
	} else {
		destination.FirewallMode = nil
	}

	// MaxRequestBodySize
	destination.MaxRequestBodySize = genruntime.ClonePointerToInt(configuration.MaxRequestBodySize)

	// MaxRequestBodySizeInKb
	destination.MaxRequestBodySizeInKb = genruntime.ClonePointerToInt(configuration.MaxRequestBodySizeInKb)

	// RequestBodyCheck
	if configuration.RequestBodyCheck != nil {
		requestBodyCheck := *configuration.RequestBodyCheck
		destination.RequestBodyCheck = &requestBodyCheck
	} else {
		destination.RequestBodyCheck = nil
	}

	// RuleSetType
	destination.RuleSetType = genruntime.ClonePointerToString(configuration.RuleSetType)

	// RuleSetVersion
	destination.RuleSetVersion = genruntime.ClonePointerToString(configuration.RuleSetVersion)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Identity for the resource.
type ManagedServiceIdentity struct {
	// Type: The type of identity used for the resource. The type 'SystemAssigned, UserAssigned' includes both an implicitly
	// created identity and a set of user assigned identities. The type 'None' will remove any identities from the virtual
	// machine.
	Type *ManagedServiceIdentity_Type `json:"type,omitempty"`

	// UserAssignedIdentities: The list of user identities associated with resource. The user identity dictionary key
	// references will be ARM resource ids in the form:
	// '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
	UserAssignedIdentities []UserAssignedIdentityDetails `json:"userAssignedIdentities,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedServiceIdentity{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (identity *ManagedServiceIdentity) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if identity == nil {
		return nil, nil
	}
	result := &arm.ManagedServiceIdentity{}

	// Set property "Type":
	if identity.Type != nil {
		var temp string
		temp = string(*identity.Type)
		typeVar := arm.ManagedServiceIdentity_Type(temp)
		result.Type = &typeVar
	}

	// Set property "UserAssignedIdentities":
	result.UserAssignedIdentities = make(map[string]arm.UserAssignedIdentityDetails, len(identity.UserAssignedIdentities))
	for _, ident := range identity.UserAssignedIdentities {
		identARMID, err := resolved.ResolvedReferences.Lookup(ident.Reference)
		if err != nil {
			return nil, err
		}
		key := identARMID
		result.UserAssignedIdentities[key] = arm.UserAssignedIdentityDetails{}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *ManagedServiceIdentity) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedServiceIdentity{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *ManagedServiceIdentity) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedServiceIdentity)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedServiceIdentity, got %T", armInput)
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := ManagedServiceIdentity_Type(temp)
		identity.Type = &typeVar
	}

	// no assignment for property "UserAssignedIdentities"

	// No error
	return nil
}

// AssignProperties_From_ManagedServiceIdentity populates our ManagedServiceIdentity from the provided source ManagedServiceIdentity
func (identity *ManagedServiceIdentity) AssignProperties_From_ManagedServiceIdentity(source *storage.ManagedServiceIdentity) error {

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, managedServiceIdentity_Type_Values)
		identity.Type = &typeTemp
	} else {
		identity.Type = nil
	}

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]UserAssignedIdentityDetails, len(source.UserAssignedIdentities))
		for userAssignedIdentityIndex, userAssignedIdentityItem := range source.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityItem := userAssignedIdentityItem
			var userAssignedIdentity UserAssignedIdentityDetails
			err := userAssignedIdentity.AssignProperties_From_UserAssignedIdentityDetails(&userAssignedIdentityItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_UserAssignedIdentityDetails() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityList[userAssignedIdentityIndex] = userAssignedIdentity
		}
		identity.UserAssignedIdentities = userAssignedIdentityList
	} else {
		identity.UserAssignedIdentities = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedServiceIdentity populates the provided destination ManagedServiceIdentity from our ManagedServiceIdentity
func (identity *ManagedServiceIdentity) AssignProperties_To_ManagedServiceIdentity(destination *storage.ManagedServiceIdentity) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Type
	if identity.Type != nil {
		typeVar := string(*identity.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// UserAssignedIdentities
	if identity.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]storage.UserAssignedIdentityDetails, len(identity.UserAssignedIdentities))
		for userAssignedIdentityIndex, userAssignedIdentityItem := range identity.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityItem := userAssignedIdentityItem
			var userAssignedIdentity storage.UserAssignedIdentityDetails
			err := userAssignedIdentityItem.AssignProperties_To_UserAssignedIdentityDetails(&userAssignedIdentity)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_UserAssignedIdentityDetails() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityList[userAssignedIdentityIndex] = userAssignedIdentity
		}
		destination.UserAssignedIdentities = userAssignedIdentityList
	} else {
		destination.UserAssignedIdentities = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ManagedServiceIdentity_STATUS populates our ManagedServiceIdentity from the provided source ManagedServiceIdentity_STATUS
func (identity *ManagedServiceIdentity) Initialize_From_ManagedServiceIdentity_STATUS(source *ManagedServiceIdentity_STATUS) error {

	// Type
	if source.Type != nil {
		typeVar := genruntime.ToEnum(string(*source.Type), managedServiceIdentity_Type_Values)
		identity.Type = &typeVar
	} else {
		identity.Type = nil
	}

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]UserAssignedIdentityDetails, 0, len(source.UserAssignedIdentities))
		for userAssignedIdentitiesKey := range source.UserAssignedIdentities {
			userAssignedIdentitiesRef := genruntime.CreateResourceReferenceFromARMID(userAssignedIdentitiesKey)
			userAssignedIdentityList = append(userAssignedIdentityList, UserAssignedIdentityDetails{Reference: userAssignedIdentitiesRef})
		}
		identity.UserAssignedIdentities = userAssignedIdentityList
	} else {
		identity.UserAssignedIdentities = nil
	}

	// No error
	return nil
}

// Identity for the resource.
type ManagedServiceIdentity_STATUS struct {
	// PrincipalId: The principal id of the system assigned identity. This property will only be provided for a system assigned
	// identity.
	PrincipalId *string `json:"principalId,omitempty"`

	// TenantId: The tenant id of the system assigned identity. This property will only be provided for a system assigned
	// identity.
	TenantId *string `json:"tenantId,omitempty"`

	// Type: The type of identity used for the resource. The type 'SystemAssigned, UserAssigned' includes both an implicitly
	// created identity and a set of user assigned identities. The type 'None' will remove any identities from the virtual
	// machine.
	Type *ManagedServiceIdentity_Type_STATUS `json:"type,omitempty"`

	// UserAssignedIdentities: The list of user identities associated with resource. The user identity dictionary key
	// references will be ARM resource ids in the form:
	// '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
	UserAssignedIdentities map[string]ManagedServiceIdentity_UserAssignedIdentities_STATUS `json:"userAssignedIdentities,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedServiceIdentity_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *ManagedServiceIdentity_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedServiceIdentity_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *ManagedServiceIdentity_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedServiceIdentity_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedServiceIdentity_STATUS, got %T", armInput)
	}

	// Set property "PrincipalId":
	if typedInput.PrincipalId != nil {
		principalId := *typedInput.PrincipalId
		identity.PrincipalId = &principalId
	}

	// Set property "TenantId":
	if typedInput.TenantId != nil {
		tenantId := *typedInput.TenantId
		identity.TenantId = &tenantId
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := ManagedServiceIdentity_Type_STATUS(temp)
		identity.Type = &typeVar
	}

	// Set property "UserAssignedIdentities":
	if typedInput.UserAssignedIdentities != nil {
		identity.UserAssignedIdentities = make(map[string]ManagedServiceIdentity_UserAssignedIdentities_STATUS, len(typedInput.UserAssignedIdentities))
		for key, value := range typedInput.UserAssignedIdentities {
			var value1 ManagedServiceIdentity_UserAssignedIdentities_STATUS
			err := value1.PopulateFromARM(owner, value)
			if err != nil {
				return err
			}
			identity.UserAssignedIdentities[key] = value1
		}
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedServiceIdentity_STATUS populates our ManagedServiceIdentity_STATUS from the provided source ManagedServiceIdentity_STATUS
func (identity *ManagedServiceIdentity_STATUS) AssignProperties_From_ManagedServiceIdentity_STATUS(source *storage.ManagedServiceIdentity_STATUS) error {

	// PrincipalId
	identity.PrincipalId = genruntime.ClonePointerToString(source.PrincipalId)

	// TenantId
	identity.TenantId = genruntime.ClonePointerToString(source.TenantId)

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, managedServiceIdentity_Type_STATUS_Values)
		identity.Type = &typeTemp
	} else {
		identity.Type = nil
	}

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityMap := make(map[string]ManagedServiceIdentity_UserAssignedIdentities_STATUS, len(source.UserAssignedIdentities))
		for userAssignedIdentityKey, userAssignedIdentityValue := range source.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityValue := userAssignedIdentityValue
			var userAssignedIdentity ManagedServiceIdentity_UserAssignedIdentities_STATUS
			err := userAssignedIdentity.AssignProperties_From_ManagedServiceIdentity_UserAssignedIdentities_STATUS(&userAssignedIdentityValue)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ManagedServiceIdentity_UserAssignedIdentities_STATUS() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityMap[userAssignedIdentityKey] = userAssignedIdentity
		}
		identity.UserAssignedIdentities = userAssignedIdentityMap
	} else {
		identity.UserAssignedIdentities = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedServiceIdentity_STATUS populates the provided destination ManagedServiceIdentity_STATUS from our ManagedServiceIdentity_STATUS
func (identity *ManagedServiceIdentity_STATUS) AssignProperties_To_ManagedServiceIdentity_STATUS(destination *storage.ManagedServiceIdentity_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PrincipalId
	destination.PrincipalId = genruntime.ClonePointerToString(identity.PrincipalId)

	// TenantId
	destination.TenantId = genruntime.ClonePointerToString(identity.TenantId)

	// Type
	if identity.Type != nil {
		typeVar := string(*identity.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// UserAssignedIdentities
	if identity.UserAssignedIdentities != nil {
		userAssignedIdentityMap := make(map[string]storage.ManagedServiceIdentity_UserAssignedIdentities_STATUS, len(identity.UserAssignedIdentities))
		for userAssignedIdentityKey, userAssignedIdentityValue := range identity.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityValue := userAssignedIdentityValue
			var userAssignedIdentity storage.ManagedServiceIdentity_UserAssignedIdentities_STATUS
			err := userAssignedIdentityValue.AssignProperties_To_ManagedServiceIdentity_UserAssignedIdentities_STATUS(&userAssignedIdentity)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ManagedServiceIdentity_UserAssignedIdentities_STATUS() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityMap[userAssignedIdentityKey] = userAssignedIdentity
		}
		destination.UserAssignedIdentities = userAssignedIdentityMap
	} else {
		destination.UserAssignedIdentities = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Reference to another ARM resource.
type SubResource struct {
	// Reference: Resource ID.
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

var _ genruntime.ARMTransformer = &SubResource{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (resource *SubResource) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if resource == nil {
		return nil, nil
	}
	result := &arm.SubResource{}

	// Set property "Id":
	if resource.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.Lookup(*resource.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (resource *SubResource) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SubResource{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (resource *SubResource) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	_, ok := armInput.(arm.SubResource)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SubResource, got %T", armInput)
	}

	// no assignment for property "Reference"

	// No error
	return nil
}

// AssignProperties_From_SubResource populates our SubResource from the provided source SubResource
func (resource *SubResource) AssignProperties_From_SubResource(source *storage.SubResource) error {

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		resource.Reference = &reference
	} else {
		resource.Reference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_SubResource populates the provided destination SubResource from our SubResource
func (resource *SubResource) AssignProperties_To_SubResource(destination *storage.SubResource) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Reference
	if resource.Reference != nil {
		reference := resource.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_SubResource_STATUS populates our SubResource from the provided source SubResource_STATUS
func (resource *SubResource) Initialize_From_SubResource_STATUS(source *SubResource_STATUS) error {

	// Reference
	if source.Id != nil {
		reference := genruntime.CreateResourceReferenceFromARMID(*source.Id)
		resource.Reference = &reference
	} else {
		resource.Reference = nil
	}

	// No error
	return nil
}

// Reference to another ARM resource.
type SubResource_STATUS struct {
	// Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &SubResource_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (resource *SubResource_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SubResource_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (resource *SubResource_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SubResource_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SubResource_STATUS, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		resource.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_SubResource_STATUS populates our SubResource_STATUS from the provided source SubResource_STATUS
func (resource *SubResource_STATUS) AssignProperties_From_SubResource_STATUS(source *storage.SubResource_STATUS) error {

	// Id
	resource.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_SubResource_STATUS populates the provided destination SubResource_STATUS from our SubResource_STATUS
func (resource *SubResource_STATUS) AssignProperties_To_SubResource_STATUS(destination *storage.SubResource_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(resource.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Backend address of an application gateway.
type ApplicationGatewayBackendAddress struct {
	// Fqdn: Fully qualified domain name (FQDN).
	Fqdn *string `json:"fqdn,omitempty"`

	// IpAddress: IP address.
	IpAddress *string `json:"ipAddress,omitempty"`
}

var _ genruntime.ARMTransformer = &ApplicationGatewayBackendAddress{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (address *ApplicationGatewayBackendAddress) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if address == nil {
		return nil, nil
	}
	result := &arm.ApplicationGatewayBackendAddress{}

	// Set property "Fqdn":
	if address.Fqdn != nil {
		fqdn := *address.Fqdn
		result.Fqdn = &fqdn
	}

	// Set property "IpAddress":
	if address.IpAddress != nil {
		ipAddress := *address.IpAddress
		result.IpAddress = &ipAddress
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (address *ApplicationGatewayBackendAddress) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApplicationGatewayBackendAddress{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (address *ApplicationGatewayBackendAddress) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApplicationGatewayBackendAddress)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApplicationGatewayBackendAddress, got %T", armInput)
	}

	// Set property "Fqdn":
	if typedInput.Fqdn != nil {
		fqdn := *typedInput.Fqdn
		address.Fqdn = &fqdn
	}

	// Set property "IpAddress":
	if typedInput.IpAddress != nil {
		ipAddress := *typedInput.IpAddress
		address.IpAddress = &ipAddress
	}

	// No error
	return nil
}

// AssignProperties_From_ApplicationGatewayBackendAddress populates our ApplicationGatewayBackendAddress from the provided source ApplicationGatewayBackendAddress
func (address *ApplicationGatewayBackendAddress) AssignProperties_From_ApplicationGatewayBackendAddress(source *storage.ApplicationGatewayBackendAddress) error {

	// Fqdn
	address.Fqdn = genruntime.ClonePointerToString(source.Fqdn)

	// IpAddress
	address.IpAddress = genruntime.ClonePointerToString(source.IpAddress)

	// No error
	return nil
}

// AssignProperties_To_ApplicationGatewayBackendAddress populates the provided destination ApplicationGatewayBackendAddress from our ApplicationGatewayBackendAddress
func (address *ApplicationGatewayBackendAddress) AssignProperties_To_ApplicationGatewayBackendAddress(destination *storage.ApplicationGatewayBackendAddress) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Fqdn
	destination.Fqdn = genruntime.ClonePointerToString(address.Fqdn)

	// IpAddress
	destination.IpAddress = genruntime.ClonePointerToString(address.IpAddress)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Disabled","Enabled"}
type ApplicationGatewayBackendHttpSettingsPropertiesFormat_CookieBasedAffinity string

const (
	ApplicationGatewayBackendHttpSettingsPropertiesFormat_CookieBasedAffinity_Disabled = ApplicationGatewayBackendHttpSettingsPropertiesFormat_CookieBasedAffinity("Disabled")
	ApplicationGatewayBackendHttpSettingsPropertiesFormat_CookieBasedAffinity_Enabled  = ApplicationGatewayBackendHttpSettingsPropertiesFormat_CookieBasedAffinity("Enabled")
)

// Mapping from string to ApplicationGatewayBackendHttpSettingsPropertiesFormat_CookieBasedAffinity
var applicationGatewayBackendHttpSettingsPropertiesFormat_CookieBasedAffinity_Values = map[string]ApplicationGatewayBackendHttpSettingsPropertiesFormat_CookieBasedAffinity{
	"disabled": ApplicationGatewayBackendHttpSettingsPropertiesFormat_CookieBasedAffinity_Disabled,
	"enabled":  ApplicationGatewayBackendHttpSettingsPropertiesFormat_CookieBasedAffinity_Enabled,
}

// Application gateway client authentication configuration.
type ApplicationGatewayClientAuthConfiguration struct {
	// VerifyClientCertIssuerDN: Verify client certificate issuer name on the application gateway.
	VerifyClientCertIssuerDN *bool `json:"verifyClientCertIssuerDN,omitempty"`

	// VerifyClientRevocation: Verify client certificate revocation status.
	VerifyClientRevocation *ApplicationGatewayClientAuthConfiguration_VerifyClientRevocation `json:"verifyClientRevocation,omitempty"`
}

var _ genruntime.ARMTransformer = &ApplicationGatewayClientAuthConfiguration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (configuration *ApplicationGatewayClientAuthConfiguration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if configuration == nil {
		return nil, nil
	}
	result := &arm.ApplicationGatewayClientAuthConfiguration{}

	// Set property "VerifyClientCertIssuerDN":
	if configuration.VerifyClientCertIssuerDN != nil {
		verifyClientCertIssuerDN := *configuration.VerifyClientCertIssuerDN
		result.VerifyClientCertIssuerDN = &verifyClientCertIssuerDN
	}

	// Set property "VerifyClientRevocation":
	if configuration.VerifyClientRevocation != nil {
		var temp string
		temp = string(*configuration.VerifyClientRevocation)
		verifyClientRevocation := arm.ApplicationGatewayClientAuthConfiguration_VerifyClientRevocation(temp)
		result.VerifyClientRevocation = &verifyClientRevocation
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *ApplicationGatewayClientAuthConfiguration) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApplicationGatewayClientAuthConfiguration{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *ApplicationGatewayClientAuthConfiguration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApplicationGatewayClientAuthConfiguration)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApplicationGatewayClientAuthConfiguration, got %T", armInput)
	}

	// Set property "VerifyClientCertIssuerDN":
	if typedInput.VerifyClientCertIssuerDN != nil {
		verifyClientCertIssuerDN := *typedInput.VerifyClientCertIssuerDN
		configuration.VerifyClientCertIssuerDN = &verifyClientCertIssuerDN
	}

	// Set property "VerifyClientRevocation":
	if typedInput.VerifyClientRevocation != nil {
		var temp string
		temp = string(*typedInput.VerifyClientRevocation)
		verifyClientRevocation := ApplicationGatewayClientAuthConfiguration_VerifyClientRevocation(temp)
		configuration.VerifyClientRevocation = &verifyClientRevocation
	}

	// No error
	return nil
}

// AssignProperties_From_ApplicationGatewayClientAuthConfiguration populates our ApplicationGatewayClientAuthConfiguration from the provided source ApplicationGatewayClientAuthConfiguration
func (configuration *ApplicationGatewayClientAuthConfiguration) AssignProperties_From_ApplicationGatewayClientAuthConfiguration(source *storage.ApplicationGatewayClientAuthConfiguration) error {

	// VerifyClientCertIssuerDN
	if source.VerifyClientCertIssuerDN != nil {
		verifyClientCertIssuerDN := *source.VerifyClientCertIssuerDN
		configuration.VerifyClientCertIssuerDN = &verifyClientCertIssuerDN
	} else {
		configuration.VerifyClientCertIssuerDN = nil
	}

	// VerifyClientRevocation
	if source.VerifyClientRevocation != nil {
		verifyClientRevocation := *source.VerifyClientRevocation
		verifyClientRevocationTemp := genruntime.ToEnum(verifyClientRevocation, applicationGatewayClientAuthConfiguration_VerifyClientRevocation_Values)
		configuration.VerifyClientRevocation = &verifyClientRevocationTemp
	} else {
		configuration.VerifyClientRevocation = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ApplicationGatewayClientAuthConfiguration populates the provided destination ApplicationGatewayClientAuthConfiguration from our ApplicationGatewayClientAuthConfiguration
func (configuration *ApplicationGatewayClientAuthConfiguration) AssignProperties_To_ApplicationGatewayClientAuthConfiguration(destination *storage.ApplicationGatewayClientAuthConfiguration) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// VerifyClientCertIssuerDN
	if configuration.VerifyClientCertIssuerDN != nil {
		verifyClientCertIssuerDN := *configuration.VerifyClientCertIssuerDN
		destination.VerifyClientCertIssuerDN = &verifyClientCertIssuerDN
	} else {
		destination.VerifyClientCertIssuerDN = nil
	}

	// VerifyClientRevocation
	if configuration.VerifyClientRevocation != nil {
		verifyClientRevocation := string(*configuration.VerifyClientRevocation)
		destination.VerifyClientRevocation = &verifyClientRevocation
	} else {
		destination.VerifyClientRevocation = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Connection draining allows open connections to a backend server to be active for a specified time after the backend
// server got removed from the configuration.
type ApplicationGatewayConnectionDraining struct {
	// +kubebuilder:validation:Required
	// +kubebuilder:validation:Maximum=3600
	// +kubebuilder:validation:Minimum=1
	// DrainTimeoutInSec: The number of seconds connection draining is active. Acceptable values are from 1 second to 3600
	// seconds.
	DrainTimeoutInSec *int `json:"drainTimeoutInSec,omitempty"`

	// +kubebuilder:validation:Required
	// Enabled: Whether connection draining is enabled or not.
	Enabled *bool `json:"enabled,omitempty"`
}

var _ genruntime.ARMTransformer = &ApplicationGatewayConnectionDraining{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (draining *ApplicationGatewayConnectionDraining) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if draining == nil {
		return nil, nil
	}
	result := &arm.ApplicationGatewayConnectionDraining{}

	// Set property "DrainTimeoutInSec":
	if draining.DrainTimeoutInSec != nil {
		drainTimeoutInSec := *draining.DrainTimeoutInSec
		result.DrainTimeoutInSec = &drainTimeoutInSec
	}

	// Set property "Enabled":
	if draining.Enabled != nil {
		enabled := *draining.Enabled
		result.Enabled = &enabled
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (draining *ApplicationGatewayConnectionDraining) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApplicationGatewayConnectionDraining{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (draining *ApplicationGatewayConnectionDraining) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApplicationGatewayConnectionDraining)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApplicationGatewayConnectionDraining, got %T", armInput)
	}

	// Set property "DrainTimeoutInSec":
	if typedInput.DrainTimeoutInSec != nil {
		drainTimeoutInSec := *typedInput.DrainTimeoutInSec
		draining.DrainTimeoutInSec = &drainTimeoutInSec
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		draining.Enabled = &enabled
	}

	// No error
	return nil
}

// AssignProperties_From_ApplicationGatewayConnectionDraining populates our ApplicationGatewayConnectionDraining from the provided source ApplicationGatewayConnectionDraining
func (draining *ApplicationGatewayConnectionDraining) AssignProperties_From_ApplicationGatewayConnectionDraining(source *storage.ApplicationGatewayConnectionDraining) error {

	// DrainTimeoutInSec
	if source.DrainTimeoutInSec != nil {
		drainTimeoutInSec := *source.DrainTimeoutInSec
		draining.DrainTimeoutInSec = &drainTimeoutInSec
	} else {
		draining.DrainTimeoutInSec = nil
	}

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		draining.Enabled = &enabled
	} else {
		draining.Enabled = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ApplicationGatewayConnectionDraining populates the provided destination ApplicationGatewayConnectionDraining from our ApplicationGatewayConnectionDraining
func (draining *ApplicationGatewayConnectionDraining) AssignProperties_To_ApplicationGatewayConnectionDraining(destination *storage.ApplicationGatewayConnectionDraining) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DrainTimeoutInSec
	if draining.DrainTimeoutInSec != nil {
		drainTimeoutInSec := *draining.DrainTimeoutInSec
		destination.DrainTimeoutInSec = &drainTimeoutInSec
	} else {
		destination.DrainTimeoutInSec = nil
	}

	// Enabled
	if draining.Enabled != nil {
		enabled := *draining.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"HttpStatus403","HttpStatus502"}
type ApplicationGatewayCustomError_StatusCode string

const (
	ApplicationGatewayCustomError_StatusCode_HttpStatus403 = ApplicationGatewayCustomError_StatusCode("HttpStatus403")
	ApplicationGatewayCustomError_StatusCode_HttpStatus502 = ApplicationGatewayCustomError_StatusCode("HttpStatus502")
)

// Mapping from string to ApplicationGatewayCustomError_StatusCode
var applicationGatewayCustomError_StatusCode_Values = map[string]ApplicationGatewayCustomError_StatusCode{
	"httpstatus403": ApplicationGatewayCustomError_StatusCode_HttpStatus403,
	"httpstatus502": ApplicationGatewayCustomError_StatusCode_HttpStatus502,
}

type ApplicationGatewayCustomError_StatusCode_STATUS string

const (
	ApplicationGatewayCustomError_StatusCode_STATUS_HttpStatus403 = ApplicationGatewayCustomError_StatusCode_STATUS("HttpStatus403")
	ApplicationGatewayCustomError_StatusCode_STATUS_HttpStatus502 = ApplicationGatewayCustomError_StatusCode_STATUS("HttpStatus502")
)

// Mapping from string to ApplicationGatewayCustomError_StatusCode_STATUS
var applicationGatewayCustomError_StatusCode_STATUS_Values = map[string]ApplicationGatewayCustomError_StatusCode_STATUS{
	"httpstatus403": ApplicationGatewayCustomError_StatusCode_STATUS_HttpStatus403,
	"httpstatus502": ApplicationGatewayCustomError_StatusCode_STATUS_HttpStatus502,
}

// Allows to disable rules within a rule group or an entire rule group.
type ApplicationGatewayFirewallDisabledRuleGroup struct {
	// +kubebuilder:validation:Required
	// RuleGroupName: The name of the rule group that will be disabled.
	RuleGroupName *string `json:"ruleGroupName,omitempty"`

	// Rules: The list of rules that will be disabled. If null, all rules of the rule group will be disabled.
	Rules []int `json:"rules,omitempty"`
}

var _ genruntime.ARMTransformer = &ApplicationGatewayFirewallDisabledRuleGroup{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (group *ApplicationGatewayFirewallDisabledRuleGroup) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if group == nil {
		return nil, nil
	}
	result := &arm.ApplicationGatewayFirewallDisabledRuleGroup{}

	// Set property "RuleGroupName":
	if group.RuleGroupName != nil {
		ruleGroupName := *group.RuleGroupName
		result.RuleGroupName = &ruleGroupName
	}

	// Set property "Rules":
	for _, item := range group.Rules {
		result.Rules = append(result.Rules, item)
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (group *ApplicationGatewayFirewallDisabledRuleGroup) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApplicationGatewayFirewallDisabledRuleGroup{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (group *ApplicationGatewayFirewallDisabledRuleGroup) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApplicationGatewayFirewallDisabledRuleGroup)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApplicationGatewayFirewallDisabledRuleGroup, got %T", armInput)
	}

	// Set property "RuleGroupName":
	if typedInput.RuleGroupName != nil {
		ruleGroupName := *typedInput.RuleGroupName
		group.RuleGroupName = &ruleGroupName
	}

	// Set property "Rules":
	for _, item := range typedInput.Rules {
		group.Rules = append(group.Rules, item)
	}

	// No error
	return nil
}

// AssignProperties_From_ApplicationGatewayFirewallDisabledRuleGroup populates our ApplicationGatewayFirewallDisabledRuleGroup from the provided source ApplicationGatewayFirewallDisabledRuleGroup
func (group *ApplicationGatewayFirewallDisabledRuleGroup) AssignProperties_From_ApplicationGatewayFirewallDisabledRuleGroup(source *storage.ApplicationGatewayFirewallDisabledRuleGroup) error {

	// RuleGroupName
	group.RuleGroupName = genruntime.ClonePointerToString(source.RuleGroupName)

	// Rules
	if source.Rules != nil {
		ruleList := make([]int, len(source.Rules))
		for ruleIndex, ruleItem := range source.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			ruleList[ruleIndex] = ruleItem
		}
		group.Rules = ruleList
	} else {
		group.Rules = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ApplicationGatewayFirewallDisabledRuleGroup populates the provided destination ApplicationGatewayFirewallDisabledRuleGroup from our ApplicationGatewayFirewallDisabledRuleGroup
func (group *ApplicationGatewayFirewallDisabledRuleGroup) AssignProperties_To_ApplicationGatewayFirewallDisabledRuleGroup(destination *storage.ApplicationGatewayFirewallDisabledRuleGroup) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// RuleGroupName
	destination.RuleGroupName = genruntime.ClonePointerToString(group.RuleGroupName)

	// Rules
	if group.Rules != nil {
		ruleList := make([]int, len(group.Rules))
		for ruleIndex, ruleItem := range group.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			ruleList[ruleIndex] = ruleItem
		}
		destination.Rules = ruleList
	} else {
		destination.Rules = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ApplicationGatewayFirewallDisabledRuleGroup_STATUS populates our ApplicationGatewayFirewallDisabledRuleGroup from the provided source ApplicationGatewayFirewallDisabledRuleGroup_STATUS
func (group *ApplicationGatewayFirewallDisabledRuleGroup) Initialize_From_ApplicationGatewayFirewallDisabledRuleGroup_STATUS(source *ApplicationGatewayFirewallDisabledRuleGroup_STATUS) error {

	// RuleGroupName
	group.RuleGroupName = genruntime.ClonePointerToString(source.RuleGroupName)

	// Rules
	if source.Rules != nil {
		ruleList := make([]int, len(source.Rules))
		for ruleIndex, ruleItem := range source.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			ruleList[ruleIndex] = ruleItem
		}
		group.Rules = ruleList
	} else {
		group.Rules = nil
	}

	// No error
	return nil
}

// Allows to disable rules within a rule group or an entire rule group.
type ApplicationGatewayFirewallDisabledRuleGroup_STATUS struct {
	// RuleGroupName: The name of the rule group that will be disabled.
	RuleGroupName *string `json:"ruleGroupName,omitempty"`

	// Rules: The list of rules that will be disabled. If null, all rules of the rule group will be disabled.
	Rules []int `json:"rules,omitempty"`
}

var _ genruntime.FromARMConverter = &ApplicationGatewayFirewallDisabledRuleGroup_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (group *ApplicationGatewayFirewallDisabledRuleGroup_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApplicationGatewayFirewallDisabledRuleGroup_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (group *ApplicationGatewayFirewallDisabledRuleGroup_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApplicationGatewayFirewallDisabledRuleGroup_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApplicationGatewayFirewallDisabledRuleGroup_STATUS, got %T", armInput)
	}

	// Set property "RuleGroupName":
	if typedInput.RuleGroupName != nil {
		ruleGroupName := *typedInput.RuleGroupName
		group.RuleGroupName = &ruleGroupName
	}

	// Set property "Rules":
	for _, item := range typedInput.Rules {
		group.Rules = append(group.Rules, item)
	}

	// No error
	return nil
}

// AssignProperties_From_ApplicationGatewayFirewallDisabledRuleGroup_STATUS populates our ApplicationGatewayFirewallDisabledRuleGroup_STATUS from the provided source ApplicationGatewayFirewallDisabledRuleGroup_STATUS
func (group *ApplicationGatewayFirewallDisabledRuleGroup_STATUS) AssignProperties_From_ApplicationGatewayFirewallDisabledRuleGroup_STATUS(source *storage.ApplicationGatewayFirewallDisabledRuleGroup_STATUS) error {

	// RuleGroupName
	group.RuleGroupName = genruntime.ClonePointerToString(source.RuleGroupName)

	// Rules
	if source.Rules != nil {
		ruleList := make([]int, len(source.Rules))
		for ruleIndex, ruleItem := range source.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			ruleList[ruleIndex] = ruleItem
		}
		group.Rules = ruleList
	} else {
		group.Rules = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ApplicationGatewayFirewallDisabledRuleGroup_STATUS populates the provided destination ApplicationGatewayFirewallDisabledRuleGroup_STATUS from our ApplicationGatewayFirewallDisabledRuleGroup_STATUS
func (group *ApplicationGatewayFirewallDisabledRuleGroup_STATUS) AssignProperties_To_ApplicationGatewayFirewallDisabledRuleGroup_STATUS(destination *storage.ApplicationGatewayFirewallDisabledRuleGroup_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// RuleGroupName
	destination.RuleGroupName = genruntime.ClonePointerToString(group.RuleGroupName)

	// Rules
	if group.Rules != nil {
		ruleList := make([]int, len(group.Rules))
		for ruleIndex, ruleItem := range group.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			ruleList[ruleIndex] = ruleItem
		}
		destination.Rules = ruleList
	} else {
		destination.Rules = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Allow to exclude some variable satisfy the condition for the WAF check.
type ApplicationGatewayFirewallExclusion struct {
	// +kubebuilder:validation:Required
	// MatchVariable: The variable to be excluded.
	MatchVariable *string `json:"matchVariable,omitempty"`

	// +kubebuilder:validation:Required
	// Selector: When matchVariable is a collection, operator used to specify which elements in the collection this exclusion
	// applies to.
	Selector *string `json:"selector,omitempty"`

	// +kubebuilder:validation:Required
	// SelectorMatchOperator: When matchVariable is a collection, operate on the selector to specify which elements in the
	// collection this exclusion applies to.
	SelectorMatchOperator *string `json:"selectorMatchOperator,omitempty"`
}

var _ genruntime.ARMTransformer = &ApplicationGatewayFirewallExclusion{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (exclusion *ApplicationGatewayFirewallExclusion) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if exclusion == nil {
		return nil, nil
	}
	result := &arm.ApplicationGatewayFirewallExclusion{}

	// Set property "MatchVariable":
	if exclusion.MatchVariable != nil {
		matchVariable := *exclusion.MatchVariable
		result.MatchVariable = &matchVariable
	}

	// Set property "Selector":
	if exclusion.Selector != nil {
		selector := *exclusion.Selector
		result.Selector = &selector
	}

	// Set property "SelectorMatchOperator":
	if exclusion.SelectorMatchOperator != nil {
		selectorMatchOperator := *exclusion.SelectorMatchOperator
		result.SelectorMatchOperator = &selectorMatchOperator
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (exclusion *ApplicationGatewayFirewallExclusion) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApplicationGatewayFirewallExclusion{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (exclusion *ApplicationGatewayFirewallExclusion) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApplicationGatewayFirewallExclusion)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApplicationGatewayFirewallExclusion, got %T", armInput)
	}

	// Set property "MatchVariable":
	if typedInput.MatchVariable != nil {
		matchVariable := *typedInput.MatchVariable
		exclusion.MatchVariable = &matchVariable
	}

	// Set property "Selector":
	if typedInput.Selector != nil {
		selector := *typedInput.Selector
		exclusion.Selector = &selector
	}

	// Set property "SelectorMatchOperator":
	if typedInput.SelectorMatchOperator != nil {
		selectorMatchOperator := *typedInput.SelectorMatchOperator
		exclusion.SelectorMatchOperator = &selectorMatchOperator
	}

	// No error
	return nil
}

// AssignProperties_From_ApplicationGatewayFirewallExclusion populates our ApplicationGatewayFirewallExclusion from the provided source ApplicationGatewayFirewallExclusion
func (exclusion *ApplicationGatewayFirewallExclusion) AssignProperties_From_ApplicationGatewayFirewallExclusion(source *storage.ApplicationGatewayFirewallExclusion) error {

	// MatchVariable
	exclusion.MatchVariable = genruntime.ClonePointerToString(source.MatchVariable)

	// Selector
	exclusion.Selector = genruntime.ClonePointerToString(source.Selector)

	// SelectorMatchOperator
	exclusion.SelectorMatchOperator = genruntime.ClonePointerToString(source.SelectorMatchOperator)

	// No error
	return nil
}

// AssignProperties_To_ApplicationGatewayFirewallExclusion populates the provided destination ApplicationGatewayFirewallExclusion from our ApplicationGatewayFirewallExclusion
func (exclusion *ApplicationGatewayFirewallExclusion) AssignProperties_To_ApplicationGatewayFirewallExclusion(destination *storage.ApplicationGatewayFirewallExclusion) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchVariable
	destination.MatchVariable = genruntime.ClonePointerToString(exclusion.MatchVariable)

	// Selector
	destination.Selector = genruntime.ClonePointerToString(exclusion.Selector)

	// SelectorMatchOperator
	destination.SelectorMatchOperator = genruntime.ClonePointerToString(exclusion.SelectorMatchOperator)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ApplicationGatewayFirewallExclusion_STATUS populates our ApplicationGatewayFirewallExclusion from the provided source ApplicationGatewayFirewallExclusion_STATUS
func (exclusion *ApplicationGatewayFirewallExclusion) Initialize_From_ApplicationGatewayFirewallExclusion_STATUS(source *ApplicationGatewayFirewallExclusion_STATUS) error {

	// MatchVariable
	exclusion.MatchVariable = genruntime.ClonePointerToString(source.MatchVariable)

	// Selector
	exclusion.Selector = genruntime.ClonePointerToString(source.Selector)

	// SelectorMatchOperator
	exclusion.SelectorMatchOperator = genruntime.ClonePointerToString(source.SelectorMatchOperator)

	// No error
	return nil
}

// Allow to exclude some variable satisfy the condition for the WAF check.
type ApplicationGatewayFirewallExclusion_STATUS struct {
	// MatchVariable: The variable to be excluded.
	MatchVariable *string `json:"matchVariable,omitempty"`

	// Selector: When matchVariable is a collection, operator used to specify which elements in the collection this exclusion
	// applies to.
	Selector *string `json:"selector,omitempty"`

	// SelectorMatchOperator: When matchVariable is a collection, operate on the selector to specify which elements in the
	// collection this exclusion applies to.
	SelectorMatchOperator *string `json:"selectorMatchOperator,omitempty"`
}

var _ genruntime.FromARMConverter = &ApplicationGatewayFirewallExclusion_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (exclusion *ApplicationGatewayFirewallExclusion_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApplicationGatewayFirewallExclusion_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (exclusion *ApplicationGatewayFirewallExclusion_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApplicationGatewayFirewallExclusion_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApplicationGatewayFirewallExclusion_STATUS, got %T", armInput)
	}

	// Set property "MatchVariable":
	if typedInput.MatchVariable != nil {
		matchVariable := *typedInput.MatchVariable
		exclusion.MatchVariable = &matchVariable
	}

	// Set property "Selector":
	if typedInput.Selector != nil {
		selector := *typedInput.Selector
		exclusion.Selector = &selector
	}

	// Set property "SelectorMatchOperator":
	if typedInput.SelectorMatchOperator != nil {
		selectorMatchOperator := *typedInput.SelectorMatchOperator
		exclusion.SelectorMatchOperator = &selectorMatchOperator
	}

	// No error
	return nil
}

// AssignProperties_From_ApplicationGatewayFirewallExclusion_STATUS populates our ApplicationGatewayFirewallExclusion_STATUS from the provided source ApplicationGatewayFirewallExclusion_STATUS
func (exclusion *ApplicationGatewayFirewallExclusion_STATUS) AssignProperties_From_ApplicationGatewayFirewallExclusion_STATUS(source *storage.ApplicationGatewayFirewallExclusion_STATUS) error {

	// MatchVariable
	exclusion.MatchVariable = genruntime.ClonePointerToString(source.MatchVariable)

	// Selector
	exclusion.Selector = genruntime.ClonePointerToString(source.Selector)

	// SelectorMatchOperator
	exclusion.SelectorMatchOperator = genruntime.ClonePointerToString(source.SelectorMatchOperator)

	// No error
	return nil
}

// AssignProperties_To_ApplicationGatewayFirewallExclusion_STATUS populates the provided destination ApplicationGatewayFirewallExclusion_STATUS from our ApplicationGatewayFirewallExclusion_STATUS
func (exclusion *ApplicationGatewayFirewallExclusion_STATUS) AssignProperties_To_ApplicationGatewayFirewallExclusion_STATUS(destination *storage.ApplicationGatewayFirewallExclusion_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchVariable
	destination.MatchVariable = genruntime.ClonePointerToString(exclusion.MatchVariable)

	// Selector
	destination.Selector = genruntime.ClonePointerToString(exclusion.Selector)

	// SelectorMatchOperator
	destination.SelectorMatchOperator = genruntime.ClonePointerToString(exclusion.SelectorMatchOperator)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Load Distribution Algorithm enums.
// +kubebuilder:validation:Enum={"IpHash","LeastConnections","RoundRobin"}
type ApplicationGatewayLoadDistributionAlgorithmEnum string

const (
	ApplicationGatewayLoadDistributionAlgorithmEnum_IpHash           = ApplicationGatewayLoadDistributionAlgorithmEnum("IpHash")
	ApplicationGatewayLoadDistributionAlgorithmEnum_LeastConnections = ApplicationGatewayLoadDistributionAlgorithmEnum("LeastConnections")
	ApplicationGatewayLoadDistributionAlgorithmEnum_RoundRobin       = ApplicationGatewayLoadDistributionAlgorithmEnum("RoundRobin")
)

// Mapping from string to ApplicationGatewayLoadDistributionAlgorithmEnum
var applicationGatewayLoadDistributionAlgorithmEnum_Values = map[string]ApplicationGatewayLoadDistributionAlgorithmEnum{
	"iphash":           ApplicationGatewayLoadDistributionAlgorithmEnum_IpHash,
	"leastconnections": ApplicationGatewayLoadDistributionAlgorithmEnum_LeastConnections,
	"roundrobin":       ApplicationGatewayLoadDistributionAlgorithmEnum_RoundRobin,
}

// Load Distribution Target of an application gateway.
type ApplicationGatewayLoadDistributionTarget struct {
	// Reference: Resource ID.
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

var _ genruntime.ARMTransformer = &ApplicationGatewayLoadDistributionTarget{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (target *ApplicationGatewayLoadDistributionTarget) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if target == nil {
		return nil, nil
	}
	result := &arm.ApplicationGatewayLoadDistributionTarget{}

	// Set property "Id":
	if target.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.Lookup(*target.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (target *ApplicationGatewayLoadDistributionTarget) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApplicationGatewayLoadDistributionTarget{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (target *ApplicationGatewayLoadDistributionTarget) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	_, ok := armInput.(arm.ApplicationGatewayLoadDistributionTarget)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApplicationGatewayLoadDistributionTarget, got %T", armInput)
	}

	// no assignment for property "Reference"

	// No error
	return nil
}

// AssignProperties_From_ApplicationGatewayLoadDistributionTarget populates our ApplicationGatewayLoadDistributionTarget from the provided source ApplicationGatewayLoadDistributionTarget
func (target *ApplicationGatewayLoadDistributionTarget) AssignProperties_From_ApplicationGatewayLoadDistributionTarget(source *storage.ApplicationGatewayLoadDistributionTarget) error {

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		target.Reference = &reference
	} else {
		target.Reference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ApplicationGatewayLoadDistributionTarget populates the provided destination ApplicationGatewayLoadDistributionTarget from our ApplicationGatewayLoadDistributionTarget
func (target *ApplicationGatewayLoadDistributionTarget) AssignProperties_To_ApplicationGatewayLoadDistributionTarget(destination *storage.ApplicationGatewayLoadDistributionTarget) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Reference
	if target.Reference != nil {
		reference := target.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Path rule of URL path map of an application gateway.
type ApplicationGatewayPathRule struct {
	// Reference: Resource ID.
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

var _ genruntime.ARMTransformer = &ApplicationGatewayPathRule{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (rule *ApplicationGatewayPathRule) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if rule == nil {
		return nil, nil
	}
	result := &arm.ApplicationGatewayPathRule{}

	// Set property "Id":
	if rule.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.Lookup(*rule.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *ApplicationGatewayPathRule) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApplicationGatewayPathRule{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *ApplicationGatewayPathRule) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	_, ok := armInput.(arm.ApplicationGatewayPathRule)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApplicationGatewayPathRule, got %T", armInput)
	}

	// no assignment for property "Reference"

	// No error
	return nil
}

// AssignProperties_From_ApplicationGatewayPathRule populates our ApplicationGatewayPathRule from the provided source ApplicationGatewayPathRule
func (rule *ApplicationGatewayPathRule) AssignProperties_From_ApplicationGatewayPathRule(source *storage.ApplicationGatewayPathRule) error {

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		rule.Reference = &reference
	} else {
		rule.Reference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ApplicationGatewayPathRule populates the provided destination ApplicationGatewayPathRule from our ApplicationGatewayPathRule
func (rule *ApplicationGatewayPathRule) AssignProperties_To_ApplicationGatewayPathRule(destination *storage.ApplicationGatewayPathRule) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Reference
	if rule.Reference != nil {
		reference := rule.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The application gateway private link ip configuration.
type ApplicationGatewayPrivateLinkIpConfiguration struct {
	// Reference: Resource ID.
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

var _ genruntime.ARMTransformer = &ApplicationGatewayPrivateLinkIpConfiguration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (configuration *ApplicationGatewayPrivateLinkIpConfiguration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if configuration == nil {
		return nil, nil
	}
	result := &arm.ApplicationGatewayPrivateLinkIpConfiguration{}

	// Set property "Id":
	if configuration.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.Lookup(*configuration.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *ApplicationGatewayPrivateLinkIpConfiguration) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApplicationGatewayPrivateLinkIpConfiguration{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *ApplicationGatewayPrivateLinkIpConfiguration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	_, ok := armInput.(arm.ApplicationGatewayPrivateLinkIpConfiguration)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApplicationGatewayPrivateLinkIpConfiguration, got %T", armInput)
	}

	// no assignment for property "Reference"

	// No error
	return nil
}

// AssignProperties_From_ApplicationGatewayPrivateLinkIpConfiguration populates our ApplicationGatewayPrivateLinkIpConfiguration from the provided source ApplicationGatewayPrivateLinkIpConfiguration
func (configuration *ApplicationGatewayPrivateLinkIpConfiguration) AssignProperties_From_ApplicationGatewayPrivateLinkIpConfiguration(source *storage.ApplicationGatewayPrivateLinkIpConfiguration) error {

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		configuration.Reference = &reference
	} else {
		configuration.Reference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ApplicationGatewayPrivateLinkIpConfiguration populates the provided destination ApplicationGatewayPrivateLinkIpConfiguration from our ApplicationGatewayPrivateLinkIpConfiguration
func (configuration *ApplicationGatewayPrivateLinkIpConfiguration) AssignProperties_To_ApplicationGatewayPrivateLinkIpConfiguration(destination *storage.ApplicationGatewayPrivateLinkIpConfiguration) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Reference
	if configuration.Reference != nil {
		reference := configuration.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Application gateway probe health response match.
type ApplicationGatewayProbeHealthResponseMatch struct {
	// Body: Body that must be contained in the health response. Default value is empty.
	Body *string `json:"body,omitempty"`

	// StatusCodes: Allowed ranges of healthy status codes. Default range of healthy status codes is 200-399.
	StatusCodes []string `json:"statusCodes,omitempty"`
}

var _ genruntime.ARMTransformer = &ApplicationGatewayProbeHealthResponseMatch{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (match *ApplicationGatewayProbeHealthResponseMatch) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if match == nil {
		return nil, nil
	}
	result := &arm.ApplicationGatewayProbeHealthResponseMatch{}

	// Set property "Body":
	if match.Body != nil {
		body := *match.Body
		result.Body = &body
	}

	// Set property "StatusCodes":
	for _, item := range match.StatusCodes {
		result.StatusCodes = append(result.StatusCodes, item)
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (match *ApplicationGatewayProbeHealthResponseMatch) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApplicationGatewayProbeHealthResponseMatch{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (match *ApplicationGatewayProbeHealthResponseMatch) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApplicationGatewayProbeHealthResponseMatch)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApplicationGatewayProbeHealthResponseMatch, got %T", armInput)
	}

	// Set property "Body":
	if typedInput.Body != nil {
		body := *typedInput.Body
		match.Body = &body
	}

	// Set property "StatusCodes":
	for _, item := range typedInput.StatusCodes {
		match.StatusCodes = append(match.StatusCodes, item)
	}

	// No error
	return nil
}

// AssignProperties_From_ApplicationGatewayProbeHealthResponseMatch populates our ApplicationGatewayProbeHealthResponseMatch from the provided source ApplicationGatewayProbeHealthResponseMatch
func (match *ApplicationGatewayProbeHealthResponseMatch) AssignProperties_From_ApplicationGatewayProbeHealthResponseMatch(source *storage.ApplicationGatewayProbeHealthResponseMatch) error {

	// Body
	match.Body = genruntime.ClonePointerToString(source.Body)

	// StatusCodes
	match.StatusCodes = genruntime.CloneSliceOfString(source.StatusCodes)

	// No error
	return nil
}

// AssignProperties_To_ApplicationGatewayProbeHealthResponseMatch populates the provided destination ApplicationGatewayProbeHealthResponseMatch from our ApplicationGatewayProbeHealthResponseMatch
func (match *ApplicationGatewayProbeHealthResponseMatch) AssignProperties_To_ApplicationGatewayProbeHealthResponseMatch(destination *storage.ApplicationGatewayProbeHealthResponseMatch) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Body
	destination.Body = genruntime.ClonePointerToString(match.Body)

	// StatusCodes
	destination.StatusCodes = genruntime.CloneSliceOfString(match.StatusCodes)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Application Gateway protocol.
// +kubebuilder:validation:Enum={"Http","Https","Tcp","Tls"}
type ApplicationGatewayProtocol string

const (
	ApplicationGatewayProtocol_Http  = ApplicationGatewayProtocol("Http")
	ApplicationGatewayProtocol_Https = ApplicationGatewayProtocol("Https")
	ApplicationGatewayProtocol_Tcp   = ApplicationGatewayProtocol("Tcp")
	ApplicationGatewayProtocol_Tls   = ApplicationGatewayProtocol("Tls")
)

// Mapping from string to ApplicationGatewayProtocol
var applicationGatewayProtocol_Values = map[string]ApplicationGatewayProtocol{
	"http":  ApplicationGatewayProtocol_Http,
	"https": ApplicationGatewayProtocol_Https,
	"tcp":   ApplicationGatewayProtocol_Tcp,
	"tls":   ApplicationGatewayProtocol_Tls,
}

// +kubebuilder:validation:Enum={"Basic","PathBasedRouting"}
type ApplicationGatewayRequestRoutingRulePropertiesFormat_RuleType string

const (
	ApplicationGatewayRequestRoutingRulePropertiesFormat_RuleType_Basic            = ApplicationGatewayRequestRoutingRulePropertiesFormat_RuleType("Basic")
	ApplicationGatewayRequestRoutingRulePropertiesFormat_RuleType_PathBasedRouting = ApplicationGatewayRequestRoutingRulePropertiesFormat_RuleType("PathBasedRouting")
)

// Mapping from string to ApplicationGatewayRequestRoutingRulePropertiesFormat_RuleType
var applicationGatewayRequestRoutingRulePropertiesFormat_RuleType_Values = map[string]ApplicationGatewayRequestRoutingRulePropertiesFormat_RuleType{
	"basic":            ApplicationGatewayRequestRoutingRulePropertiesFormat_RuleType_Basic,
	"pathbasedrouting": ApplicationGatewayRequestRoutingRulePropertiesFormat_RuleType_PathBasedRouting,
}

// Rewrite rule of an application gateway.
type ApplicationGatewayRewriteRule struct {
	// ActionSet: Set of actions to be done as part of the rewrite Rule.
	ActionSet *ApplicationGatewayRewriteRuleActionSet `json:"actionSet,omitempty"`

	// Conditions: Conditions based on which the action set execution will be evaluated.
	Conditions []ApplicationGatewayRewriteRuleCondition `json:"conditions,omitempty"`

	// Name: Name of the rewrite rule that is unique within an Application Gateway.
	Name *string `json:"name,omitempty"`

	// RuleSequence: Rule Sequence of the rewrite rule that determines the order of execution of a particular rule in a
	// RewriteRuleSet.
	RuleSequence *int `json:"ruleSequence,omitempty"`
}

var _ genruntime.ARMTransformer = &ApplicationGatewayRewriteRule{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (rule *ApplicationGatewayRewriteRule) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if rule == nil {
		return nil, nil
	}
	result := &arm.ApplicationGatewayRewriteRule{}

	// Set property "ActionSet":
	if rule.ActionSet != nil {
		actionSet_ARM, err := (*rule.ActionSet).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		actionSet := *actionSet_ARM.(*arm.ApplicationGatewayRewriteRuleActionSet)
		result.ActionSet = &actionSet
	}

	// Set property "Conditions":
	for _, item := range rule.Conditions {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Conditions = append(result.Conditions, *item_ARM.(*arm.ApplicationGatewayRewriteRuleCondition))
	}

	// Set property "Name":
	if rule.Name != nil {
		name := *rule.Name
		result.Name = &name
	}

	// Set property "RuleSequence":
	if rule.RuleSequence != nil {
		ruleSequence := *rule.RuleSequence
		result.RuleSequence = &ruleSequence
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *ApplicationGatewayRewriteRule) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApplicationGatewayRewriteRule{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *ApplicationGatewayRewriteRule) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApplicationGatewayRewriteRule)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApplicationGatewayRewriteRule, got %T", armInput)
	}

	// Set property "ActionSet":
	if typedInput.ActionSet != nil {
		var actionSet1 ApplicationGatewayRewriteRuleActionSet
		err := actionSet1.PopulateFromARM(owner, *typedInput.ActionSet)
		if err != nil {
			return err
		}
		actionSet := actionSet1
		rule.ActionSet = &actionSet
	}

	// Set property "Conditions":
	for _, item := range typedInput.Conditions {
		var item1 ApplicationGatewayRewriteRuleCondition
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		rule.Conditions = append(rule.Conditions, item1)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		rule.Name = &name
	}

	// Set property "RuleSequence":
	if typedInput.RuleSequence != nil {
		ruleSequence := *typedInput.RuleSequence
		rule.RuleSequence = &ruleSequence
	}

	// No error
	return nil
}

// AssignProperties_From_ApplicationGatewayRewriteRule populates our ApplicationGatewayRewriteRule from the provided source ApplicationGatewayRewriteRule
func (rule *ApplicationGatewayRewriteRule) AssignProperties_From_ApplicationGatewayRewriteRule(source *storage.ApplicationGatewayRewriteRule) error {

	// ActionSet
	if source.ActionSet != nil {
		var actionSet ApplicationGatewayRewriteRuleActionSet
		err := actionSet.AssignProperties_From_ApplicationGatewayRewriteRuleActionSet(source.ActionSet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ApplicationGatewayRewriteRuleActionSet() to populate field ActionSet")
		}
		rule.ActionSet = &actionSet
	} else {
		rule.ActionSet = nil
	}

	// Conditions
	if source.Conditions != nil {
		conditionList := make([]ApplicationGatewayRewriteRuleCondition, len(source.Conditions))
		for conditionIndex, conditionItem := range source.Conditions {
			// Shadow the loop variable to avoid aliasing
			conditionItem := conditionItem
			var condition ApplicationGatewayRewriteRuleCondition
			err := condition.AssignProperties_From_ApplicationGatewayRewriteRuleCondition(&conditionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ApplicationGatewayRewriteRuleCondition() to populate field Conditions")
			}
			conditionList[conditionIndex] = condition
		}
		rule.Conditions = conditionList
	} else {
		rule.Conditions = nil
	}

	// Name
	rule.Name = genruntime.ClonePointerToString(source.Name)

	// RuleSequence
	rule.RuleSequence = genruntime.ClonePointerToInt(source.RuleSequence)

	// No error
	return nil
}

// AssignProperties_To_ApplicationGatewayRewriteRule populates the provided destination ApplicationGatewayRewriteRule from our ApplicationGatewayRewriteRule
func (rule *ApplicationGatewayRewriteRule) AssignProperties_To_ApplicationGatewayRewriteRule(destination *storage.ApplicationGatewayRewriteRule) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ActionSet
	if rule.ActionSet != nil {
		var actionSet storage.ApplicationGatewayRewriteRuleActionSet
		err := rule.ActionSet.AssignProperties_To_ApplicationGatewayRewriteRuleActionSet(&actionSet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ApplicationGatewayRewriteRuleActionSet() to populate field ActionSet")
		}
		destination.ActionSet = &actionSet
	} else {
		destination.ActionSet = nil
	}

	// Conditions
	if rule.Conditions != nil {
		conditionList := make([]storage.ApplicationGatewayRewriteRuleCondition, len(rule.Conditions))
		for conditionIndex, conditionItem := range rule.Conditions {
			// Shadow the loop variable to avoid aliasing
			conditionItem := conditionItem
			var condition storage.ApplicationGatewayRewriteRuleCondition
			err := conditionItem.AssignProperties_To_ApplicationGatewayRewriteRuleCondition(&condition)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ApplicationGatewayRewriteRuleCondition() to populate field Conditions")
			}
			conditionList[conditionIndex] = condition
		}
		destination.Conditions = conditionList
	} else {
		destination.Conditions = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(rule.Name)

	// RuleSequence
	destination.RuleSequence = genruntime.ClonePointerToInt(rule.RuleSequence)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Basic","PathBasedRouting"}
type ApplicationGatewayRoutingRulePropertiesFormat_RuleType string

const (
	ApplicationGatewayRoutingRulePropertiesFormat_RuleType_Basic            = ApplicationGatewayRoutingRulePropertiesFormat_RuleType("Basic")
	ApplicationGatewayRoutingRulePropertiesFormat_RuleType_PathBasedRouting = ApplicationGatewayRoutingRulePropertiesFormat_RuleType("PathBasedRouting")
)

// Mapping from string to ApplicationGatewayRoutingRulePropertiesFormat_RuleType
var applicationGatewayRoutingRulePropertiesFormat_RuleType_Values = map[string]ApplicationGatewayRoutingRulePropertiesFormat_RuleType{
	"basic":            ApplicationGatewayRoutingRulePropertiesFormat_RuleType_Basic,
	"pathbasedrouting": ApplicationGatewayRoutingRulePropertiesFormat_RuleType_PathBasedRouting,
}

// +kubebuilder:validation:Enum={"Standard_Large","Standard_Medium","Standard_Small","Standard_v2","WAF_Large","WAF_Medium","WAF_v2"}
type ApplicationGatewaySku_Name string

const (
	ApplicationGatewaySku_Name_Standard_Large  = ApplicationGatewaySku_Name("Standard_Large")
	ApplicationGatewaySku_Name_Standard_Medium = ApplicationGatewaySku_Name("Standard_Medium")
	ApplicationGatewaySku_Name_Standard_Small  = ApplicationGatewaySku_Name("Standard_Small")
	ApplicationGatewaySku_Name_Standard_V2     = ApplicationGatewaySku_Name("Standard_v2")
	ApplicationGatewaySku_Name_WAF_Large       = ApplicationGatewaySku_Name("WAF_Large")
	ApplicationGatewaySku_Name_WAF_Medium      = ApplicationGatewaySku_Name("WAF_Medium")
	ApplicationGatewaySku_Name_WAF_V2          = ApplicationGatewaySku_Name("WAF_v2")
)

// Mapping from string to ApplicationGatewaySku_Name
var applicationGatewaySku_Name_Values = map[string]ApplicationGatewaySku_Name{
	"standard_large":  ApplicationGatewaySku_Name_Standard_Large,
	"standard_medium": ApplicationGatewaySku_Name_Standard_Medium,
	"standard_small":  ApplicationGatewaySku_Name_Standard_Small,
	"standard_v2":     ApplicationGatewaySku_Name_Standard_V2,
	"waf_large":       ApplicationGatewaySku_Name_WAF_Large,
	"waf_medium":      ApplicationGatewaySku_Name_WAF_Medium,
	"waf_v2":          ApplicationGatewaySku_Name_WAF_V2,
}

type ApplicationGatewaySku_Name_STATUS string

const (
	ApplicationGatewaySku_Name_STATUS_Standard_Large  = ApplicationGatewaySku_Name_STATUS("Standard_Large")
	ApplicationGatewaySku_Name_STATUS_Standard_Medium = ApplicationGatewaySku_Name_STATUS("Standard_Medium")
	ApplicationGatewaySku_Name_STATUS_Standard_Small  = ApplicationGatewaySku_Name_STATUS("Standard_Small")
	ApplicationGatewaySku_Name_STATUS_Standard_V2     = ApplicationGatewaySku_Name_STATUS("Standard_v2")
	ApplicationGatewaySku_Name_STATUS_WAF_Large       = ApplicationGatewaySku_Name_STATUS("WAF_Large")
	ApplicationGatewaySku_Name_STATUS_WAF_Medium      = ApplicationGatewaySku_Name_STATUS("WAF_Medium")
	ApplicationGatewaySku_Name_STATUS_WAF_V2          = ApplicationGatewaySku_Name_STATUS("WAF_v2")
)

// Mapping from string to ApplicationGatewaySku_Name_STATUS
var applicationGatewaySku_Name_STATUS_Values = map[string]ApplicationGatewaySku_Name_STATUS{
	"standard_large":  ApplicationGatewaySku_Name_STATUS_Standard_Large,
	"standard_medium": ApplicationGatewaySku_Name_STATUS_Standard_Medium,
	"standard_small":  ApplicationGatewaySku_Name_STATUS_Standard_Small,
	"standard_v2":     ApplicationGatewaySku_Name_STATUS_Standard_V2,
	"waf_large":       ApplicationGatewaySku_Name_STATUS_WAF_Large,
	"waf_medium":      ApplicationGatewaySku_Name_STATUS_WAF_Medium,
	"waf_v2":          ApplicationGatewaySku_Name_STATUS_WAF_V2,
}

// +kubebuilder:validation:Enum={"Standard","Standard_v2","WAF","WAF_v2"}
type ApplicationGatewaySku_Tier string

const (
	ApplicationGatewaySku_Tier_Standard    = ApplicationGatewaySku_Tier("Standard")
	ApplicationGatewaySku_Tier_Standard_V2 = ApplicationGatewaySku_Tier("Standard_v2")
	ApplicationGatewaySku_Tier_WAF         = ApplicationGatewaySku_Tier("WAF")
	ApplicationGatewaySku_Tier_WAF_V2      = ApplicationGatewaySku_Tier("WAF_v2")
)

// Mapping from string to ApplicationGatewaySku_Tier
var applicationGatewaySku_Tier_Values = map[string]ApplicationGatewaySku_Tier{
	"standard":    ApplicationGatewaySku_Tier_Standard,
	"standard_v2": ApplicationGatewaySku_Tier_Standard_V2,
	"waf":         ApplicationGatewaySku_Tier_WAF,
	"waf_v2":      ApplicationGatewaySku_Tier_WAF_V2,
}

type ApplicationGatewaySku_Tier_STATUS string

const (
	ApplicationGatewaySku_Tier_STATUS_Standard    = ApplicationGatewaySku_Tier_STATUS("Standard")
	ApplicationGatewaySku_Tier_STATUS_Standard_V2 = ApplicationGatewaySku_Tier_STATUS("Standard_v2")
	ApplicationGatewaySku_Tier_STATUS_WAF         = ApplicationGatewaySku_Tier_STATUS("WAF")
	ApplicationGatewaySku_Tier_STATUS_WAF_V2      = ApplicationGatewaySku_Tier_STATUS("WAF_v2")
)

// Mapping from string to ApplicationGatewaySku_Tier_STATUS
var applicationGatewaySku_Tier_STATUS_Values = map[string]ApplicationGatewaySku_Tier_STATUS{
	"standard":    ApplicationGatewaySku_Tier_STATUS_Standard,
	"standard_v2": ApplicationGatewaySku_Tier_STATUS_Standard_V2,
	"waf":         ApplicationGatewaySku_Tier_STATUS_WAF,
	"waf_v2":      ApplicationGatewaySku_Tier_STATUS_WAF_V2,
}

// +kubebuilder:validation:Enum={"Custom","CustomV2","Predefined"}
type ApplicationGatewaySslPolicy_PolicyType string

const (
	ApplicationGatewaySslPolicy_PolicyType_Custom     = ApplicationGatewaySslPolicy_PolicyType("Custom")
	ApplicationGatewaySslPolicy_PolicyType_CustomV2   = ApplicationGatewaySslPolicy_PolicyType("CustomV2")
	ApplicationGatewaySslPolicy_PolicyType_Predefined = ApplicationGatewaySslPolicy_PolicyType("Predefined")
)

// Mapping from string to ApplicationGatewaySslPolicy_PolicyType
var applicationGatewaySslPolicy_PolicyType_Values = map[string]ApplicationGatewaySslPolicy_PolicyType{
	"custom":     ApplicationGatewaySslPolicy_PolicyType_Custom,
	"customv2":   ApplicationGatewaySslPolicy_PolicyType_CustomV2,
	"predefined": ApplicationGatewaySslPolicy_PolicyType_Predefined,
}

type ApplicationGatewaySslPolicy_PolicyType_STATUS string

const (
	ApplicationGatewaySslPolicy_PolicyType_STATUS_Custom     = ApplicationGatewaySslPolicy_PolicyType_STATUS("Custom")
	ApplicationGatewaySslPolicy_PolicyType_STATUS_CustomV2   = ApplicationGatewaySslPolicy_PolicyType_STATUS("CustomV2")
	ApplicationGatewaySslPolicy_PolicyType_STATUS_Predefined = ApplicationGatewaySslPolicy_PolicyType_STATUS("Predefined")
)

// Mapping from string to ApplicationGatewaySslPolicy_PolicyType_STATUS
var applicationGatewaySslPolicy_PolicyType_STATUS_Values = map[string]ApplicationGatewaySslPolicy_PolicyType_STATUS{
	"custom":     ApplicationGatewaySslPolicy_PolicyType_STATUS_Custom,
	"customv2":   ApplicationGatewaySslPolicy_PolicyType_STATUS_CustomV2,
	"predefined": ApplicationGatewaySslPolicy_PolicyType_STATUS_Predefined,
}

// +kubebuilder:validation:Enum={"Detection","Prevention"}
type ApplicationGatewayWebApplicationFirewallConfiguration_FirewallMode string

const (
	ApplicationGatewayWebApplicationFirewallConfiguration_FirewallMode_Detection  = ApplicationGatewayWebApplicationFirewallConfiguration_FirewallMode("Detection")
	ApplicationGatewayWebApplicationFirewallConfiguration_FirewallMode_Prevention = ApplicationGatewayWebApplicationFirewallConfiguration_FirewallMode("Prevention")
)

// Mapping from string to ApplicationGatewayWebApplicationFirewallConfiguration_FirewallMode
var applicationGatewayWebApplicationFirewallConfiguration_FirewallMode_Values = map[string]ApplicationGatewayWebApplicationFirewallConfiguration_FirewallMode{
	"detection":  ApplicationGatewayWebApplicationFirewallConfiguration_FirewallMode_Detection,
	"prevention": ApplicationGatewayWebApplicationFirewallConfiguration_FirewallMode_Prevention,
}

type ApplicationGatewayWebApplicationFirewallConfiguration_FirewallMode_STATUS string

const (
	ApplicationGatewayWebApplicationFirewallConfiguration_FirewallMode_STATUS_Detection  = ApplicationGatewayWebApplicationFirewallConfiguration_FirewallMode_STATUS("Detection")
	ApplicationGatewayWebApplicationFirewallConfiguration_FirewallMode_STATUS_Prevention = ApplicationGatewayWebApplicationFirewallConfiguration_FirewallMode_STATUS("Prevention")
)

// Mapping from string to ApplicationGatewayWebApplicationFirewallConfiguration_FirewallMode_STATUS
var applicationGatewayWebApplicationFirewallConfiguration_FirewallMode_STATUS_Values = map[string]ApplicationGatewayWebApplicationFirewallConfiguration_FirewallMode_STATUS{
	"detection":  ApplicationGatewayWebApplicationFirewallConfiguration_FirewallMode_STATUS_Detection,
	"prevention": ApplicationGatewayWebApplicationFirewallConfiguration_FirewallMode_STATUS_Prevention,
}

// Ssl cipher suites enums.
// +kubebuilder:validation:Enum={"TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA","TLS_DHE_DSS_WITH_AES_128_CBC_SHA","TLS_DHE_DSS_WITH_AES_128_CBC_SHA256","TLS_DHE_DSS_WITH_AES_256_CBC_SHA","TLS_DHE_DSS_WITH_AES_256_CBC_SHA256","TLS_DHE_RSA_WITH_AES_128_CBC_SHA","TLS_DHE_RSA_WITH_AES_128_GCM_SHA256","TLS_DHE_RSA_WITH_AES_256_CBC_SHA","TLS_DHE_RSA_WITH_AES_256_GCM_SHA384","TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA","TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256","TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256","TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA","TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384","TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384","TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA","TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256","TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256","TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA","TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384","TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384","TLS_RSA_WITH_3DES_EDE_CBC_SHA","TLS_RSA_WITH_AES_128_CBC_SHA","TLS_RSA_WITH_AES_128_CBC_SHA256","TLS_RSA_WITH_AES_128_GCM_SHA256","TLS_RSA_WITH_AES_256_CBC_SHA","TLS_RSA_WITH_AES_256_CBC_SHA256","TLS_RSA_WITH_AES_256_GCM_SHA384"}
type CipherSuitesEnum string

const (
	CipherSuitesEnum_TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA       = CipherSuitesEnum("TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA")
	CipherSuitesEnum_TLS_DHE_DSS_WITH_AES_128_CBC_SHA        = CipherSuitesEnum("TLS_DHE_DSS_WITH_AES_128_CBC_SHA")
	CipherSuitesEnum_TLS_DHE_DSS_WITH_AES_128_CBC_SHA256     = CipherSuitesEnum("TLS_DHE_DSS_WITH_AES_128_CBC_SHA256")
	CipherSuitesEnum_TLS_DHE_DSS_WITH_AES_256_CBC_SHA        = CipherSuitesEnum("TLS_DHE_DSS_WITH_AES_256_CBC_SHA")
	CipherSuitesEnum_TLS_DHE_DSS_WITH_AES_256_CBC_SHA256     = CipherSuitesEnum("TLS_DHE_DSS_WITH_AES_256_CBC_SHA256")
	CipherSuitesEnum_TLS_DHE_RSA_WITH_AES_128_CBC_SHA        = CipherSuitesEnum("TLS_DHE_RSA_WITH_AES_128_CBC_SHA")
	CipherSuitesEnum_TLS_DHE_RSA_WITH_AES_128_GCM_SHA256     = CipherSuitesEnum("TLS_DHE_RSA_WITH_AES_128_GCM_SHA256")
	CipherSuitesEnum_TLS_DHE_RSA_WITH_AES_256_CBC_SHA        = CipherSuitesEnum("TLS_DHE_RSA_WITH_AES_256_CBC_SHA")
	CipherSuitesEnum_TLS_DHE_RSA_WITH_AES_256_GCM_SHA384     = CipherSuitesEnum("TLS_DHE_RSA_WITH_AES_256_GCM_SHA384")
	CipherSuitesEnum_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA    = CipherSuitesEnum("TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA")
	CipherSuitesEnum_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 = CipherSuitesEnum("TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256")
	CipherSuitesEnum_TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 = CipherSuitesEnum("TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256")
	CipherSuitesEnum_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA    = CipherSuitesEnum("TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA")
	CipherSuitesEnum_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384 = CipherSuitesEnum("TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384")
	CipherSuitesEnum_TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 = CipherSuitesEnum("TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384")
	CipherSuitesEnum_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA      = CipherSuitesEnum("TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA")
	CipherSuitesEnum_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256   = CipherSuitesEnum("TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256")
	CipherSuitesEnum_TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256   = CipherSuitesEnum("TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256")
	CipherSuitesEnum_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA      = CipherSuitesEnum("TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA")
	CipherSuitesEnum_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384   = CipherSuitesEnum("TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384")
	CipherSuitesEnum_TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384   = CipherSuitesEnum("TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384")
	CipherSuitesEnum_TLS_RSA_WITH_3DES_EDE_CBC_SHA           = CipherSuitesEnum("TLS_RSA_WITH_3DES_EDE_CBC_SHA")
	CipherSuitesEnum_TLS_RSA_WITH_AES_128_CBC_SHA            = CipherSuitesEnum("TLS_RSA_WITH_AES_128_CBC_SHA")
	CipherSuitesEnum_TLS_RSA_WITH_AES_128_CBC_SHA256         = CipherSuitesEnum("TLS_RSA_WITH_AES_128_CBC_SHA256")
	CipherSuitesEnum_TLS_RSA_WITH_AES_128_GCM_SHA256         = CipherSuitesEnum("TLS_RSA_WITH_AES_128_GCM_SHA256")
	CipherSuitesEnum_TLS_RSA_WITH_AES_256_CBC_SHA            = CipherSuitesEnum("TLS_RSA_WITH_AES_256_CBC_SHA")
	CipherSuitesEnum_TLS_RSA_WITH_AES_256_CBC_SHA256         = CipherSuitesEnum("TLS_RSA_WITH_AES_256_CBC_SHA256")
	CipherSuitesEnum_TLS_RSA_WITH_AES_256_GCM_SHA384         = CipherSuitesEnum("TLS_RSA_WITH_AES_256_GCM_SHA384")
)

// Mapping from string to CipherSuitesEnum
var cipherSuitesEnum_Values = map[string]CipherSuitesEnum{
	"tls_dhe_dss_with_3des_ede_cbc_sha":       CipherSuitesEnum_TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA,
	"tls_dhe_dss_with_aes_128_cbc_sha":        CipherSuitesEnum_TLS_DHE_DSS_WITH_AES_128_CBC_SHA,
	"tls_dhe_dss_with_aes_128_cbc_sha256":     CipherSuitesEnum_TLS_DHE_DSS_WITH_AES_128_CBC_SHA256,
	"tls_dhe_dss_with_aes_256_cbc_sha":        CipherSuitesEnum_TLS_DHE_DSS_WITH_AES_256_CBC_SHA,
	"tls_dhe_dss_with_aes_256_cbc_sha256":     CipherSuitesEnum_TLS_DHE_DSS_WITH_AES_256_CBC_SHA256,
	"tls_dhe_rsa_with_aes_128_cbc_sha":        CipherSuitesEnum_TLS_DHE_RSA_WITH_AES_128_CBC_SHA,
	"tls_dhe_rsa_with_aes_128_gcm_sha256":     CipherSuitesEnum_TLS_DHE_RSA_WITH_AES_128_GCM_SHA256,
	"tls_dhe_rsa_with_aes_256_cbc_sha":        CipherSuitesEnum_TLS_DHE_RSA_WITH_AES_256_CBC_SHA,
	"tls_dhe_rsa_with_aes_256_gcm_sha384":     CipherSuitesEnum_TLS_DHE_RSA_WITH_AES_256_GCM_SHA384,
	"tls_ecdhe_ecdsa_with_aes_128_cbc_sha":    CipherSuitesEnum_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,
	"tls_ecdhe_ecdsa_with_aes_128_cbc_sha256": CipherSuitesEnum_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256,
	"tls_ecdhe_ecdsa_with_aes_128_gcm_sha256": CipherSuitesEnum_TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
	"tls_ecdhe_ecdsa_with_aes_256_cbc_sha":    CipherSuitesEnum_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA,
	"tls_ecdhe_ecdsa_with_aes_256_cbc_sha384": CipherSuitesEnum_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384,
	"tls_ecdhe_ecdsa_with_aes_256_gcm_sha384": CipherSuitesEnum_TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
	"tls_ecdhe_rsa_with_aes_128_cbc_sha":      CipherSuitesEnum_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,
	"tls_ecdhe_rsa_with_aes_128_cbc_sha256":   CipherSuitesEnum_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256,
	"tls_ecdhe_rsa_with_aes_128_gcm_sha256":   CipherSuitesEnum_TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
	"tls_ecdhe_rsa_with_aes_256_cbc_sha":      CipherSuitesEnum_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,
	"tls_ecdhe_rsa_with_aes_256_cbc_sha384":   CipherSuitesEnum_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384,
	"tls_ecdhe_rsa_with_aes_256_gcm_sha384":   CipherSuitesEnum_TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
	"tls_rsa_with_3des_ede_cbc_sha":           CipherSuitesEnum_TLS_RSA_WITH_3DES_EDE_CBC_SHA,
	"tls_rsa_with_aes_128_cbc_sha":            CipherSuitesEnum_TLS_RSA_WITH_AES_128_CBC_SHA,
	"tls_rsa_with_aes_128_cbc_sha256":         CipherSuitesEnum_TLS_RSA_WITH_AES_128_CBC_SHA256,
	"tls_rsa_with_aes_128_gcm_sha256":         CipherSuitesEnum_TLS_RSA_WITH_AES_128_GCM_SHA256,
	"tls_rsa_with_aes_256_cbc_sha":            CipherSuitesEnum_TLS_RSA_WITH_AES_256_CBC_SHA,
	"tls_rsa_with_aes_256_cbc_sha256":         CipherSuitesEnum_TLS_RSA_WITH_AES_256_CBC_SHA256,
	"tls_rsa_with_aes_256_gcm_sha384":         CipherSuitesEnum_TLS_RSA_WITH_AES_256_GCM_SHA384,
}

// Ssl cipher suites enums.
type CipherSuitesEnum_STATUS string

const (
	CipherSuitesEnum_STATUS_TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA       = CipherSuitesEnum_STATUS("TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA")
	CipherSuitesEnum_STATUS_TLS_DHE_DSS_WITH_AES_128_CBC_SHA        = CipherSuitesEnum_STATUS("TLS_DHE_DSS_WITH_AES_128_CBC_SHA")
	CipherSuitesEnum_STATUS_TLS_DHE_DSS_WITH_AES_128_CBC_SHA256     = CipherSuitesEnum_STATUS("TLS_DHE_DSS_WITH_AES_128_CBC_SHA256")
	CipherSuitesEnum_STATUS_TLS_DHE_DSS_WITH_AES_256_CBC_SHA        = CipherSuitesEnum_STATUS("TLS_DHE_DSS_WITH_AES_256_CBC_SHA")
	CipherSuitesEnum_STATUS_TLS_DHE_DSS_WITH_AES_256_CBC_SHA256     = CipherSuitesEnum_STATUS("TLS_DHE_DSS_WITH_AES_256_CBC_SHA256")
	CipherSuitesEnum_STATUS_TLS_DHE_RSA_WITH_AES_128_CBC_SHA        = CipherSuitesEnum_STATUS("TLS_DHE_RSA_WITH_AES_128_CBC_SHA")
	CipherSuitesEnum_STATUS_TLS_DHE_RSA_WITH_AES_128_GCM_SHA256     = CipherSuitesEnum_STATUS("TLS_DHE_RSA_WITH_AES_128_GCM_SHA256")
	CipherSuitesEnum_STATUS_TLS_DHE_RSA_WITH_AES_256_CBC_SHA        = CipherSuitesEnum_STATUS("TLS_DHE_RSA_WITH_AES_256_CBC_SHA")
	CipherSuitesEnum_STATUS_TLS_DHE_RSA_WITH_AES_256_GCM_SHA384     = CipherSuitesEnum_STATUS("TLS_DHE_RSA_WITH_AES_256_GCM_SHA384")
	CipherSuitesEnum_STATUS_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA    = CipherSuitesEnum_STATUS("TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA")
	CipherSuitesEnum_STATUS_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 = CipherSuitesEnum_STATUS("TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256")
	CipherSuitesEnum_STATUS_TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 = CipherSuitesEnum_STATUS("TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256")
	CipherSuitesEnum_STATUS_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA    = CipherSuitesEnum_STATUS("TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA")
	CipherSuitesEnum_STATUS_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384 = CipherSuitesEnum_STATUS("TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384")
	CipherSuitesEnum_STATUS_TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 = CipherSuitesEnum_STATUS("TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384")
	CipherSuitesEnum_STATUS_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA      = CipherSuitesEnum_STATUS("TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA")
	CipherSuitesEnum_STATUS_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256   = CipherSuitesEnum_STATUS("TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256")
	CipherSuitesEnum_STATUS_TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256   = CipherSuitesEnum_STATUS("TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256")
	CipherSuitesEnum_STATUS_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA      = CipherSuitesEnum_STATUS("TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA")
	CipherSuitesEnum_STATUS_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384   = CipherSuitesEnum_STATUS("TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384")
	CipherSuitesEnum_STATUS_TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384   = CipherSuitesEnum_STATUS("TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384")
	CipherSuitesEnum_STATUS_TLS_RSA_WITH_3DES_EDE_CBC_SHA           = CipherSuitesEnum_STATUS("TLS_RSA_WITH_3DES_EDE_CBC_SHA")
	CipherSuitesEnum_STATUS_TLS_RSA_WITH_AES_128_CBC_SHA            = CipherSuitesEnum_STATUS("TLS_RSA_WITH_AES_128_CBC_SHA")
	CipherSuitesEnum_STATUS_TLS_RSA_WITH_AES_128_CBC_SHA256         = CipherSuitesEnum_STATUS("TLS_RSA_WITH_AES_128_CBC_SHA256")
	CipherSuitesEnum_STATUS_TLS_RSA_WITH_AES_128_GCM_SHA256         = CipherSuitesEnum_STATUS("TLS_RSA_WITH_AES_128_GCM_SHA256")
	CipherSuitesEnum_STATUS_TLS_RSA_WITH_AES_256_CBC_SHA            = CipherSuitesEnum_STATUS("TLS_RSA_WITH_AES_256_CBC_SHA")
	CipherSuitesEnum_STATUS_TLS_RSA_WITH_AES_256_CBC_SHA256         = CipherSuitesEnum_STATUS("TLS_RSA_WITH_AES_256_CBC_SHA256")
	CipherSuitesEnum_STATUS_TLS_RSA_WITH_AES_256_GCM_SHA384         = CipherSuitesEnum_STATUS("TLS_RSA_WITH_AES_256_GCM_SHA384")
)

// Mapping from string to CipherSuitesEnum_STATUS
var cipherSuitesEnum_STATUS_Values = map[string]CipherSuitesEnum_STATUS{
	"tls_dhe_dss_with_3des_ede_cbc_sha":       CipherSuitesEnum_STATUS_TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA,
	"tls_dhe_dss_with_aes_128_cbc_sha":        CipherSuitesEnum_STATUS_TLS_DHE_DSS_WITH_AES_128_CBC_SHA,
	"tls_dhe_dss_with_aes_128_cbc_sha256":     CipherSuitesEnum_STATUS_TLS_DHE_DSS_WITH_AES_128_CBC_SHA256,
	"tls_dhe_dss_with_aes_256_cbc_sha":        CipherSuitesEnum_STATUS_TLS_DHE_DSS_WITH_AES_256_CBC_SHA,
	"tls_dhe_dss_with_aes_256_cbc_sha256":     CipherSuitesEnum_STATUS_TLS_DHE_DSS_WITH_AES_256_CBC_SHA256,
	"tls_dhe_rsa_with_aes_128_cbc_sha":        CipherSuitesEnum_STATUS_TLS_DHE_RSA_WITH_AES_128_CBC_SHA,
	"tls_dhe_rsa_with_aes_128_gcm_sha256":     CipherSuitesEnum_STATUS_TLS_DHE_RSA_WITH_AES_128_GCM_SHA256,
	"tls_dhe_rsa_with_aes_256_cbc_sha":        CipherSuitesEnum_STATUS_TLS_DHE_RSA_WITH_AES_256_CBC_SHA,
	"tls_dhe_rsa_with_aes_256_gcm_sha384":     CipherSuitesEnum_STATUS_TLS_DHE_RSA_WITH_AES_256_GCM_SHA384,
	"tls_ecdhe_ecdsa_with_aes_128_cbc_sha":    CipherSuitesEnum_STATUS_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,
	"tls_ecdhe_ecdsa_with_aes_128_cbc_sha256": CipherSuitesEnum_STATUS_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256,
	"tls_ecdhe_ecdsa_with_aes_128_gcm_sha256": CipherSuitesEnum_STATUS_TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
	"tls_ecdhe_ecdsa_with_aes_256_cbc_sha":    CipherSuitesEnum_STATUS_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA,
	"tls_ecdhe_ecdsa_with_aes_256_cbc_sha384": CipherSuitesEnum_STATUS_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384,
	"tls_ecdhe_ecdsa_with_aes_256_gcm_sha384": CipherSuitesEnum_STATUS_TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
	"tls_ecdhe_rsa_with_aes_128_cbc_sha":      CipherSuitesEnum_STATUS_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,
	"tls_ecdhe_rsa_with_aes_128_cbc_sha256":   CipherSuitesEnum_STATUS_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256,
	"tls_ecdhe_rsa_with_aes_128_gcm_sha256":   CipherSuitesEnum_STATUS_TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
	"tls_ecdhe_rsa_with_aes_256_cbc_sha":      CipherSuitesEnum_STATUS_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,
	"tls_ecdhe_rsa_with_aes_256_cbc_sha384":   CipherSuitesEnum_STATUS_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384,
	"tls_ecdhe_rsa_with_aes_256_gcm_sha384":   CipherSuitesEnum_STATUS_TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
	"tls_rsa_with_3des_ede_cbc_sha":           CipherSuitesEnum_STATUS_TLS_RSA_WITH_3DES_EDE_CBC_SHA,
	"tls_rsa_with_aes_128_cbc_sha":            CipherSuitesEnum_STATUS_TLS_RSA_WITH_AES_128_CBC_SHA,
	"tls_rsa_with_aes_128_cbc_sha256":         CipherSuitesEnum_STATUS_TLS_RSA_WITH_AES_128_CBC_SHA256,
	"tls_rsa_with_aes_128_gcm_sha256":         CipherSuitesEnum_STATUS_TLS_RSA_WITH_AES_128_GCM_SHA256,
	"tls_rsa_with_aes_256_cbc_sha":            CipherSuitesEnum_STATUS_TLS_RSA_WITH_AES_256_CBC_SHA,
	"tls_rsa_with_aes_256_cbc_sha256":         CipherSuitesEnum_STATUS_TLS_RSA_WITH_AES_256_CBC_SHA256,
	"tls_rsa_with_aes_256_gcm_sha384":         CipherSuitesEnum_STATUS_TLS_RSA_WITH_AES_256_GCM_SHA384,
}

// IP address allocation method.
// +kubebuilder:validation:Enum={"Dynamic","Static"}
type IPAllocationMethod string

const (
	IPAllocationMethod_Dynamic = IPAllocationMethod("Dynamic")
	IPAllocationMethod_Static  = IPAllocationMethod("Static")
)

// Mapping from string to IPAllocationMethod
var iPAllocationMethod_Values = map[string]IPAllocationMethod{
	"dynamic": IPAllocationMethod_Dynamic,
	"static":  IPAllocationMethod_Static,
}

// +kubebuilder:validation:Enum={"None","SystemAssigned","SystemAssigned, UserAssigned","UserAssigned"}
type ManagedServiceIdentity_Type string

const (
	ManagedServiceIdentity_Type_None                       = ManagedServiceIdentity_Type("None")
	ManagedServiceIdentity_Type_SystemAssigned             = ManagedServiceIdentity_Type("SystemAssigned")
	ManagedServiceIdentity_Type_SystemAssignedUserAssigned = ManagedServiceIdentity_Type("SystemAssigned, UserAssigned")
	ManagedServiceIdentity_Type_UserAssigned               = ManagedServiceIdentity_Type("UserAssigned")
)

// Mapping from string to ManagedServiceIdentity_Type
var managedServiceIdentity_Type_Values = map[string]ManagedServiceIdentity_Type{
	"none":                         ManagedServiceIdentity_Type_None,
	"systemassigned":               ManagedServiceIdentity_Type_SystemAssigned,
	"systemassigned, userassigned": ManagedServiceIdentity_Type_SystemAssignedUserAssigned,
	"userassigned":                 ManagedServiceIdentity_Type_UserAssigned,
}

type ManagedServiceIdentity_Type_STATUS string

const (
	ManagedServiceIdentity_Type_STATUS_None                       = ManagedServiceIdentity_Type_STATUS("None")
	ManagedServiceIdentity_Type_STATUS_SystemAssigned             = ManagedServiceIdentity_Type_STATUS("SystemAssigned")
	ManagedServiceIdentity_Type_STATUS_SystemAssignedUserAssigned = ManagedServiceIdentity_Type_STATUS("SystemAssigned, UserAssigned")
	ManagedServiceIdentity_Type_STATUS_UserAssigned               = ManagedServiceIdentity_Type_STATUS("UserAssigned")
)

// Mapping from string to ManagedServiceIdentity_Type_STATUS
var managedServiceIdentity_Type_STATUS_Values = map[string]ManagedServiceIdentity_Type_STATUS{
	"none":                         ManagedServiceIdentity_Type_STATUS_None,
	"systemassigned":               ManagedServiceIdentity_Type_STATUS_SystemAssigned,
	"systemassigned, userassigned": ManagedServiceIdentity_Type_STATUS_SystemAssignedUserAssigned,
	"userassigned":                 ManagedServiceIdentity_Type_STATUS_UserAssigned,
}

type ManagedServiceIdentity_UserAssignedIdentities_STATUS struct {
	// ClientId: The client id of user assigned identity.
	ClientId *string `json:"clientId,omitempty"`

	// PrincipalId: The principal id of user assigned identity.
	PrincipalId *string `json:"principalId,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedServiceIdentity_UserAssignedIdentities_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identities *ManagedServiceIdentity_UserAssignedIdentities_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedServiceIdentity_UserAssignedIdentities_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identities *ManagedServiceIdentity_UserAssignedIdentities_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedServiceIdentity_UserAssignedIdentities_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedServiceIdentity_UserAssignedIdentities_STATUS, got %T", armInput)
	}

	// Set property "ClientId":
	if typedInput.ClientId != nil {
		clientId := *typedInput.ClientId
		identities.ClientId = &clientId
	}

	// Set property "PrincipalId":
	if typedInput.PrincipalId != nil {
		principalId := *typedInput.PrincipalId
		identities.PrincipalId = &principalId
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedServiceIdentity_UserAssignedIdentities_STATUS populates our ManagedServiceIdentity_UserAssignedIdentities_STATUS from the provided source ManagedServiceIdentity_UserAssignedIdentities_STATUS
func (identities *ManagedServiceIdentity_UserAssignedIdentities_STATUS) AssignProperties_From_ManagedServiceIdentity_UserAssignedIdentities_STATUS(source *storage.ManagedServiceIdentity_UserAssignedIdentities_STATUS) error {

	// ClientId
	identities.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// PrincipalId
	identities.PrincipalId = genruntime.ClonePointerToString(source.PrincipalId)

	// No error
	return nil
}

// AssignProperties_To_ManagedServiceIdentity_UserAssignedIdentities_STATUS populates the provided destination ManagedServiceIdentity_UserAssignedIdentities_STATUS from our ManagedServiceIdentity_UserAssignedIdentities_STATUS
func (identities *ManagedServiceIdentity_UserAssignedIdentities_STATUS) AssignProperties_To_ManagedServiceIdentity_UserAssignedIdentities_STATUS(destination *storage.ManagedServiceIdentity_UserAssignedIdentities_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(identities.ClientId)

	// PrincipalId
	destination.PrincipalId = genruntime.ClonePointerToString(identities.PrincipalId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Ssl predefined policy name enums.
// +kubebuilder:validation:Enum={"AppGwSslPolicy20150501","AppGwSslPolicy20170401","AppGwSslPolicy20170401S","AppGwSslPolicy20220101","AppGwSslPolicy20220101S"}
type PolicyNameEnum string

const (
	PolicyNameEnum_AppGwSslPolicy20150501  = PolicyNameEnum("AppGwSslPolicy20150501")
	PolicyNameEnum_AppGwSslPolicy20170401  = PolicyNameEnum("AppGwSslPolicy20170401")
	PolicyNameEnum_AppGwSslPolicy20170401S = PolicyNameEnum("AppGwSslPolicy20170401S")
	PolicyNameEnum_AppGwSslPolicy20220101  = PolicyNameEnum("AppGwSslPolicy20220101")
	PolicyNameEnum_AppGwSslPolicy20220101S = PolicyNameEnum("AppGwSslPolicy20220101S")
)

// Mapping from string to PolicyNameEnum
var policyNameEnum_Values = map[string]PolicyNameEnum{
	"appgwsslpolicy20150501":  PolicyNameEnum_AppGwSslPolicy20150501,
	"appgwsslpolicy20170401":  PolicyNameEnum_AppGwSslPolicy20170401,
	"appgwsslpolicy20170401s": PolicyNameEnum_AppGwSslPolicy20170401S,
	"appgwsslpolicy20220101":  PolicyNameEnum_AppGwSslPolicy20220101,
	"appgwsslpolicy20220101s": PolicyNameEnum_AppGwSslPolicy20220101S,
}

// Ssl predefined policy name enums.
type PolicyNameEnum_STATUS string

const (
	PolicyNameEnum_STATUS_AppGwSslPolicy20150501  = PolicyNameEnum_STATUS("AppGwSslPolicy20150501")
	PolicyNameEnum_STATUS_AppGwSslPolicy20170401  = PolicyNameEnum_STATUS("AppGwSslPolicy20170401")
	PolicyNameEnum_STATUS_AppGwSslPolicy20170401S = PolicyNameEnum_STATUS("AppGwSslPolicy20170401S")
	PolicyNameEnum_STATUS_AppGwSslPolicy20220101  = PolicyNameEnum_STATUS("AppGwSslPolicy20220101")
	PolicyNameEnum_STATUS_AppGwSslPolicy20220101S = PolicyNameEnum_STATUS("AppGwSslPolicy20220101S")
)

// Mapping from string to PolicyNameEnum_STATUS
var policyNameEnum_STATUS_Values = map[string]PolicyNameEnum_STATUS{
	"appgwsslpolicy20150501":  PolicyNameEnum_STATUS_AppGwSslPolicy20150501,
	"appgwsslpolicy20170401":  PolicyNameEnum_STATUS_AppGwSslPolicy20170401,
	"appgwsslpolicy20170401s": PolicyNameEnum_STATUS_AppGwSslPolicy20170401S,
	"appgwsslpolicy20220101":  PolicyNameEnum_STATUS_AppGwSslPolicy20220101,
	"appgwsslpolicy20220101s": PolicyNameEnum_STATUS_AppGwSslPolicy20220101S,
}

// Ssl protocol enums.
// +kubebuilder:validation:Enum={"TLSv1_0","TLSv1_1","TLSv1_2","TLSv1_3"}
type ProtocolsEnum string

const (
	ProtocolsEnum_TLSv1_0 = ProtocolsEnum("TLSv1_0")
	ProtocolsEnum_TLSv1_1 = ProtocolsEnum("TLSv1_1")
	ProtocolsEnum_TLSv1_2 = ProtocolsEnum("TLSv1_2")
	ProtocolsEnum_TLSv1_3 = ProtocolsEnum("TLSv1_3")
)

// Mapping from string to ProtocolsEnum
var protocolsEnum_Values = map[string]ProtocolsEnum{
	"tlsv1_0": ProtocolsEnum_TLSv1_0,
	"tlsv1_1": ProtocolsEnum_TLSv1_1,
	"tlsv1_2": ProtocolsEnum_TLSv1_2,
	"tlsv1_3": ProtocolsEnum_TLSv1_3,
}

// Ssl protocol enums.
type ProtocolsEnum_STATUS string

const (
	ProtocolsEnum_STATUS_TLSv1_0 = ProtocolsEnum_STATUS("TLSv1_0")
	ProtocolsEnum_STATUS_TLSv1_1 = ProtocolsEnum_STATUS("TLSv1_1")
	ProtocolsEnum_STATUS_TLSv1_2 = ProtocolsEnum_STATUS("TLSv1_2")
	ProtocolsEnum_STATUS_TLSv1_3 = ProtocolsEnum_STATUS("TLSv1_3")
)

// Mapping from string to ProtocolsEnum_STATUS
var protocolsEnum_STATUS_Values = map[string]ProtocolsEnum_STATUS{
	"tlsv1_0": ProtocolsEnum_STATUS_TLSv1_0,
	"tlsv1_1": ProtocolsEnum_STATUS_TLSv1_1,
	"tlsv1_2": ProtocolsEnum_STATUS_TLSv1_2,
	"tlsv1_3": ProtocolsEnum_STATUS_TLSv1_3,
}

// Redirect type enum.
// +kubebuilder:validation:Enum={"Found","Permanent","SeeOther","Temporary"}
type RedirectTypeEnum string

const (
	RedirectTypeEnum_Found     = RedirectTypeEnum("Found")
	RedirectTypeEnum_Permanent = RedirectTypeEnum("Permanent")
	RedirectTypeEnum_SeeOther  = RedirectTypeEnum("SeeOther")
	RedirectTypeEnum_Temporary = RedirectTypeEnum("Temporary")
)

// Mapping from string to RedirectTypeEnum
var redirectTypeEnum_Values = map[string]RedirectTypeEnum{
	"found":     RedirectTypeEnum_Found,
	"permanent": RedirectTypeEnum_Permanent,
	"seeother":  RedirectTypeEnum_SeeOther,
	"temporary": RedirectTypeEnum_Temporary,
}

// Information about the user assigned identity for the resource
type UserAssignedIdentityDetails struct {
	Reference genruntime.ResourceReference `armReference:"Reference" json:"reference,omitempty"`
}

// AssignProperties_From_UserAssignedIdentityDetails populates our UserAssignedIdentityDetails from the provided source UserAssignedIdentityDetails
func (details *UserAssignedIdentityDetails) AssignProperties_From_UserAssignedIdentityDetails(source *storage.UserAssignedIdentityDetails) error {

	// Reference
	details.Reference = source.Reference.Copy()

	// No error
	return nil
}

// AssignProperties_To_UserAssignedIdentityDetails populates the provided destination UserAssignedIdentityDetails from our UserAssignedIdentityDetails
func (details *UserAssignedIdentityDetails) AssignProperties_To_UserAssignedIdentityDetails(destination *storage.UserAssignedIdentityDetails) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Reference
	destination.Reference = details.Reference.Copy()

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"None","OCSP"}
type ApplicationGatewayClientAuthConfiguration_VerifyClientRevocation string

const (
	ApplicationGatewayClientAuthConfiguration_VerifyClientRevocation_None = ApplicationGatewayClientAuthConfiguration_VerifyClientRevocation("None")
	ApplicationGatewayClientAuthConfiguration_VerifyClientRevocation_OCSP = ApplicationGatewayClientAuthConfiguration_VerifyClientRevocation("OCSP")
)

// Mapping from string to ApplicationGatewayClientAuthConfiguration_VerifyClientRevocation
var applicationGatewayClientAuthConfiguration_VerifyClientRevocation_Values = map[string]ApplicationGatewayClientAuthConfiguration_VerifyClientRevocation{
	"none": ApplicationGatewayClientAuthConfiguration_VerifyClientRevocation_None,
	"ocsp": ApplicationGatewayClientAuthConfiguration_VerifyClientRevocation_OCSP,
}

// Set of actions in the Rewrite Rule in Application Gateway.
type ApplicationGatewayRewriteRuleActionSet struct {
	// RequestHeaderConfigurations: Request Header Actions in the Action Set.
	RequestHeaderConfigurations []ApplicationGatewayHeaderConfiguration `json:"requestHeaderConfigurations,omitempty"`

	// ResponseHeaderConfigurations: Response Header Actions in the Action Set.
	ResponseHeaderConfigurations []ApplicationGatewayHeaderConfiguration `json:"responseHeaderConfigurations,omitempty"`

	// UrlConfiguration: Url Configuration Action in the Action Set.
	UrlConfiguration *ApplicationGatewayUrlConfiguration `json:"urlConfiguration,omitempty"`
}

var _ genruntime.ARMTransformer = &ApplicationGatewayRewriteRuleActionSet{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (actionSet *ApplicationGatewayRewriteRuleActionSet) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if actionSet == nil {
		return nil, nil
	}
	result := &arm.ApplicationGatewayRewriteRuleActionSet{}

	// Set property "RequestHeaderConfigurations":
	for _, item := range actionSet.RequestHeaderConfigurations {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.RequestHeaderConfigurations = append(result.RequestHeaderConfigurations, *item_ARM.(*arm.ApplicationGatewayHeaderConfiguration))
	}

	// Set property "ResponseHeaderConfigurations":
	for _, item := range actionSet.ResponseHeaderConfigurations {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.ResponseHeaderConfigurations = append(result.ResponseHeaderConfigurations, *item_ARM.(*arm.ApplicationGatewayHeaderConfiguration))
	}

	// Set property "UrlConfiguration":
	if actionSet.UrlConfiguration != nil {
		urlConfiguration_ARM, err := (*actionSet.UrlConfiguration).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		urlConfiguration := *urlConfiguration_ARM.(*arm.ApplicationGatewayUrlConfiguration)
		result.UrlConfiguration = &urlConfiguration
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (actionSet *ApplicationGatewayRewriteRuleActionSet) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApplicationGatewayRewriteRuleActionSet{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (actionSet *ApplicationGatewayRewriteRuleActionSet) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApplicationGatewayRewriteRuleActionSet)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApplicationGatewayRewriteRuleActionSet, got %T", armInput)
	}

	// Set property "RequestHeaderConfigurations":
	for _, item := range typedInput.RequestHeaderConfigurations {
		var item1 ApplicationGatewayHeaderConfiguration
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		actionSet.RequestHeaderConfigurations = append(actionSet.RequestHeaderConfigurations, item1)
	}

	// Set property "ResponseHeaderConfigurations":
	for _, item := range typedInput.ResponseHeaderConfigurations {
		var item1 ApplicationGatewayHeaderConfiguration
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		actionSet.ResponseHeaderConfigurations = append(actionSet.ResponseHeaderConfigurations, item1)
	}

	// Set property "UrlConfiguration":
	if typedInput.UrlConfiguration != nil {
		var urlConfiguration1 ApplicationGatewayUrlConfiguration
		err := urlConfiguration1.PopulateFromARM(owner, *typedInput.UrlConfiguration)
		if err != nil {
			return err
		}
		urlConfiguration := urlConfiguration1
		actionSet.UrlConfiguration = &urlConfiguration
	}

	// No error
	return nil
}

// AssignProperties_From_ApplicationGatewayRewriteRuleActionSet populates our ApplicationGatewayRewriteRuleActionSet from the provided source ApplicationGatewayRewriteRuleActionSet
func (actionSet *ApplicationGatewayRewriteRuleActionSet) AssignProperties_From_ApplicationGatewayRewriteRuleActionSet(source *storage.ApplicationGatewayRewriteRuleActionSet) error {

	// RequestHeaderConfigurations
	if source.RequestHeaderConfigurations != nil {
		requestHeaderConfigurationList := make([]ApplicationGatewayHeaderConfiguration, len(source.RequestHeaderConfigurations))
		for requestHeaderConfigurationIndex, requestHeaderConfigurationItem := range source.RequestHeaderConfigurations {
			// Shadow the loop variable to avoid aliasing
			requestHeaderConfigurationItem := requestHeaderConfigurationItem
			var requestHeaderConfiguration ApplicationGatewayHeaderConfiguration
			err := requestHeaderConfiguration.AssignProperties_From_ApplicationGatewayHeaderConfiguration(&requestHeaderConfigurationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ApplicationGatewayHeaderConfiguration() to populate field RequestHeaderConfigurations")
			}
			requestHeaderConfigurationList[requestHeaderConfigurationIndex] = requestHeaderConfiguration
		}
		actionSet.RequestHeaderConfigurations = requestHeaderConfigurationList
	} else {
		actionSet.RequestHeaderConfigurations = nil
	}

	// ResponseHeaderConfigurations
	if source.ResponseHeaderConfigurations != nil {
		responseHeaderConfigurationList := make([]ApplicationGatewayHeaderConfiguration, len(source.ResponseHeaderConfigurations))
		for responseHeaderConfigurationIndex, responseHeaderConfigurationItem := range source.ResponseHeaderConfigurations {
			// Shadow the loop variable to avoid aliasing
			responseHeaderConfigurationItem := responseHeaderConfigurationItem
			var responseHeaderConfiguration ApplicationGatewayHeaderConfiguration
			err := responseHeaderConfiguration.AssignProperties_From_ApplicationGatewayHeaderConfiguration(&responseHeaderConfigurationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ApplicationGatewayHeaderConfiguration() to populate field ResponseHeaderConfigurations")
			}
			responseHeaderConfigurationList[responseHeaderConfigurationIndex] = responseHeaderConfiguration
		}
		actionSet.ResponseHeaderConfigurations = responseHeaderConfigurationList
	} else {
		actionSet.ResponseHeaderConfigurations = nil
	}

	// UrlConfiguration
	if source.UrlConfiguration != nil {
		var urlConfiguration ApplicationGatewayUrlConfiguration
		err := urlConfiguration.AssignProperties_From_ApplicationGatewayUrlConfiguration(source.UrlConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ApplicationGatewayUrlConfiguration() to populate field UrlConfiguration")
		}
		actionSet.UrlConfiguration = &urlConfiguration
	} else {
		actionSet.UrlConfiguration = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ApplicationGatewayRewriteRuleActionSet populates the provided destination ApplicationGatewayRewriteRuleActionSet from our ApplicationGatewayRewriteRuleActionSet
func (actionSet *ApplicationGatewayRewriteRuleActionSet) AssignProperties_To_ApplicationGatewayRewriteRuleActionSet(destination *storage.ApplicationGatewayRewriteRuleActionSet) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// RequestHeaderConfigurations
	if actionSet.RequestHeaderConfigurations != nil {
		requestHeaderConfigurationList := make([]storage.ApplicationGatewayHeaderConfiguration, len(actionSet.RequestHeaderConfigurations))
		for requestHeaderConfigurationIndex, requestHeaderConfigurationItem := range actionSet.RequestHeaderConfigurations {
			// Shadow the loop variable to avoid aliasing
			requestHeaderConfigurationItem := requestHeaderConfigurationItem
			var requestHeaderConfiguration storage.ApplicationGatewayHeaderConfiguration
			err := requestHeaderConfigurationItem.AssignProperties_To_ApplicationGatewayHeaderConfiguration(&requestHeaderConfiguration)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ApplicationGatewayHeaderConfiguration() to populate field RequestHeaderConfigurations")
			}
			requestHeaderConfigurationList[requestHeaderConfigurationIndex] = requestHeaderConfiguration
		}
		destination.RequestHeaderConfigurations = requestHeaderConfigurationList
	} else {
		destination.RequestHeaderConfigurations = nil
	}

	// ResponseHeaderConfigurations
	if actionSet.ResponseHeaderConfigurations != nil {
		responseHeaderConfigurationList := make([]storage.ApplicationGatewayHeaderConfiguration, len(actionSet.ResponseHeaderConfigurations))
		for responseHeaderConfigurationIndex, responseHeaderConfigurationItem := range actionSet.ResponseHeaderConfigurations {
			// Shadow the loop variable to avoid aliasing
			responseHeaderConfigurationItem := responseHeaderConfigurationItem
			var responseHeaderConfiguration storage.ApplicationGatewayHeaderConfiguration
			err := responseHeaderConfigurationItem.AssignProperties_To_ApplicationGatewayHeaderConfiguration(&responseHeaderConfiguration)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ApplicationGatewayHeaderConfiguration() to populate field ResponseHeaderConfigurations")
			}
			responseHeaderConfigurationList[responseHeaderConfigurationIndex] = responseHeaderConfiguration
		}
		destination.ResponseHeaderConfigurations = responseHeaderConfigurationList
	} else {
		destination.ResponseHeaderConfigurations = nil
	}

	// UrlConfiguration
	if actionSet.UrlConfiguration != nil {
		var urlConfiguration storage.ApplicationGatewayUrlConfiguration
		err := actionSet.UrlConfiguration.AssignProperties_To_ApplicationGatewayUrlConfiguration(&urlConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ApplicationGatewayUrlConfiguration() to populate field UrlConfiguration")
		}
		destination.UrlConfiguration = &urlConfiguration
	} else {
		destination.UrlConfiguration = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Set of conditions in the Rewrite Rule in Application Gateway.
type ApplicationGatewayRewriteRuleCondition struct {
	// IgnoreCase: Setting this parameter to truth value with force the pattern to do a case in-sensitive comparison.
	IgnoreCase *bool `json:"ignoreCase,omitempty"`

	// Negate: Setting this value as truth will force to check the negation of the condition given by the user.
	Negate *bool `json:"negate,omitempty"`

	// Pattern: The pattern, either fixed string or regular expression, that evaluates the truthfulness of the condition.
	Pattern *string `json:"pattern,omitempty"`

	// Variable: The condition parameter of the RewriteRuleCondition.
	Variable *string `json:"variable,omitempty"`
}

var _ genruntime.ARMTransformer = &ApplicationGatewayRewriteRuleCondition{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (condition *ApplicationGatewayRewriteRuleCondition) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if condition == nil {
		return nil, nil
	}
	result := &arm.ApplicationGatewayRewriteRuleCondition{}

	// Set property "IgnoreCase":
	if condition.IgnoreCase != nil {
		ignoreCase := *condition.IgnoreCase
		result.IgnoreCase = &ignoreCase
	}

	// Set property "Negate":
	if condition.Negate != nil {
		negate := *condition.Negate
		result.Negate = &negate
	}

	// Set property "Pattern":
	if condition.Pattern != nil {
		pattern := *condition.Pattern
		result.Pattern = &pattern
	}

	// Set property "Variable":
	if condition.Variable != nil {
		variable := *condition.Variable
		result.Variable = &variable
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *ApplicationGatewayRewriteRuleCondition) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApplicationGatewayRewriteRuleCondition{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *ApplicationGatewayRewriteRuleCondition) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApplicationGatewayRewriteRuleCondition)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApplicationGatewayRewriteRuleCondition, got %T", armInput)
	}

	// Set property "IgnoreCase":
	if typedInput.IgnoreCase != nil {
		ignoreCase := *typedInput.IgnoreCase
		condition.IgnoreCase = &ignoreCase
	}

	// Set property "Negate":
	if typedInput.Negate != nil {
		negate := *typedInput.Negate
		condition.Negate = &negate
	}

	// Set property "Pattern":
	if typedInput.Pattern != nil {
		pattern := *typedInput.Pattern
		condition.Pattern = &pattern
	}

	// Set property "Variable":
	if typedInput.Variable != nil {
		variable := *typedInput.Variable
		condition.Variable = &variable
	}

	// No error
	return nil
}

// AssignProperties_From_ApplicationGatewayRewriteRuleCondition populates our ApplicationGatewayRewriteRuleCondition from the provided source ApplicationGatewayRewriteRuleCondition
func (condition *ApplicationGatewayRewriteRuleCondition) AssignProperties_From_ApplicationGatewayRewriteRuleCondition(source *storage.ApplicationGatewayRewriteRuleCondition) error {

	// IgnoreCase
	if source.IgnoreCase != nil {
		ignoreCase := *source.IgnoreCase
		condition.IgnoreCase = &ignoreCase
	} else {
		condition.IgnoreCase = nil
	}

	// Negate
	if source.Negate != nil {
		negate := *source.Negate
		condition.Negate = &negate
	} else {
		condition.Negate = nil
	}

	// Pattern
	condition.Pattern = genruntime.ClonePointerToString(source.Pattern)

	// Variable
	condition.Variable = genruntime.ClonePointerToString(source.Variable)

	// No error
	return nil
}

// AssignProperties_To_ApplicationGatewayRewriteRuleCondition populates the provided destination ApplicationGatewayRewriteRuleCondition from our ApplicationGatewayRewriteRuleCondition
func (condition *ApplicationGatewayRewriteRuleCondition) AssignProperties_To_ApplicationGatewayRewriteRuleCondition(destination *storage.ApplicationGatewayRewriteRuleCondition) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// IgnoreCase
	if condition.IgnoreCase != nil {
		ignoreCase := *condition.IgnoreCase
		destination.IgnoreCase = &ignoreCase
	} else {
		destination.IgnoreCase = nil
	}

	// Negate
	if condition.Negate != nil {
		negate := *condition.Negate
		destination.Negate = &negate
	} else {
		destination.Negate = nil
	}

	// Pattern
	destination.Pattern = genruntime.ClonePointerToString(condition.Pattern)

	// Variable
	destination.Variable = genruntime.ClonePointerToString(condition.Variable)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Header configuration of the Actions set in Application Gateway.
type ApplicationGatewayHeaderConfiguration struct {
	// HeaderName: Header name of the header configuration.
	HeaderName *string `json:"headerName,omitempty"`

	// HeaderValue: Header value of the header configuration.
	HeaderValue *string `json:"headerValue,omitempty"`
}

var _ genruntime.ARMTransformer = &ApplicationGatewayHeaderConfiguration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (configuration *ApplicationGatewayHeaderConfiguration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if configuration == nil {
		return nil, nil
	}
	result := &arm.ApplicationGatewayHeaderConfiguration{}

	// Set property "HeaderName":
	if configuration.HeaderName != nil {
		headerName := *configuration.HeaderName
		result.HeaderName = &headerName
	}

	// Set property "HeaderValue":
	if configuration.HeaderValue != nil {
		headerValue := *configuration.HeaderValue
		result.HeaderValue = &headerValue
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *ApplicationGatewayHeaderConfiguration) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApplicationGatewayHeaderConfiguration{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *ApplicationGatewayHeaderConfiguration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApplicationGatewayHeaderConfiguration)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApplicationGatewayHeaderConfiguration, got %T", armInput)
	}

	// Set property "HeaderName":
	if typedInput.HeaderName != nil {
		headerName := *typedInput.HeaderName
		configuration.HeaderName = &headerName
	}

	// Set property "HeaderValue":
	if typedInput.HeaderValue != nil {
		headerValue := *typedInput.HeaderValue
		configuration.HeaderValue = &headerValue
	}

	// No error
	return nil
}

// AssignProperties_From_ApplicationGatewayHeaderConfiguration populates our ApplicationGatewayHeaderConfiguration from the provided source ApplicationGatewayHeaderConfiguration
func (configuration *ApplicationGatewayHeaderConfiguration) AssignProperties_From_ApplicationGatewayHeaderConfiguration(source *storage.ApplicationGatewayHeaderConfiguration) error {

	// HeaderName
	configuration.HeaderName = genruntime.ClonePointerToString(source.HeaderName)

	// HeaderValue
	configuration.HeaderValue = genruntime.ClonePointerToString(source.HeaderValue)

	// No error
	return nil
}

// AssignProperties_To_ApplicationGatewayHeaderConfiguration populates the provided destination ApplicationGatewayHeaderConfiguration from our ApplicationGatewayHeaderConfiguration
func (configuration *ApplicationGatewayHeaderConfiguration) AssignProperties_To_ApplicationGatewayHeaderConfiguration(destination *storage.ApplicationGatewayHeaderConfiguration) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// HeaderName
	destination.HeaderName = genruntime.ClonePointerToString(configuration.HeaderName)

	// HeaderValue
	destination.HeaderValue = genruntime.ClonePointerToString(configuration.HeaderValue)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Url configuration of the Actions set in Application Gateway.
type ApplicationGatewayUrlConfiguration struct {
	// ModifiedPath: Url path which user has provided for url rewrite. Null means no path will be updated. Default value is
	// null.
	ModifiedPath *string `json:"modifiedPath,omitempty"`

	// ModifiedQueryString: Query string which user has provided for url rewrite. Null means no query string will be updated.
	// Default value is null.
	ModifiedQueryString *string `json:"modifiedQueryString,omitempty"`

	// Reroute: If set as true, it will re-evaluate the url path map provided in path based request routing rules using
	// modified path. Default value is false.
	Reroute *bool `json:"reroute,omitempty"`
}

var _ genruntime.ARMTransformer = &ApplicationGatewayUrlConfiguration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (configuration *ApplicationGatewayUrlConfiguration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if configuration == nil {
		return nil, nil
	}
	result := &arm.ApplicationGatewayUrlConfiguration{}

	// Set property "ModifiedPath":
	if configuration.ModifiedPath != nil {
		modifiedPath := *configuration.ModifiedPath
		result.ModifiedPath = &modifiedPath
	}

	// Set property "ModifiedQueryString":
	if configuration.ModifiedQueryString != nil {
		modifiedQueryString := *configuration.ModifiedQueryString
		result.ModifiedQueryString = &modifiedQueryString
	}

	// Set property "Reroute":
	if configuration.Reroute != nil {
		reroute := *configuration.Reroute
		result.Reroute = &reroute
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *ApplicationGatewayUrlConfiguration) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApplicationGatewayUrlConfiguration{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *ApplicationGatewayUrlConfiguration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApplicationGatewayUrlConfiguration)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApplicationGatewayUrlConfiguration, got %T", armInput)
	}

	// Set property "ModifiedPath":
	if typedInput.ModifiedPath != nil {
		modifiedPath := *typedInput.ModifiedPath
		configuration.ModifiedPath = &modifiedPath
	}

	// Set property "ModifiedQueryString":
	if typedInput.ModifiedQueryString != nil {
		modifiedQueryString := *typedInput.ModifiedQueryString
		configuration.ModifiedQueryString = &modifiedQueryString
	}

	// Set property "Reroute":
	if typedInput.Reroute != nil {
		reroute := *typedInput.Reroute
		configuration.Reroute = &reroute
	}

	// No error
	return nil
}

// AssignProperties_From_ApplicationGatewayUrlConfiguration populates our ApplicationGatewayUrlConfiguration from the provided source ApplicationGatewayUrlConfiguration
func (configuration *ApplicationGatewayUrlConfiguration) AssignProperties_From_ApplicationGatewayUrlConfiguration(source *storage.ApplicationGatewayUrlConfiguration) error {

	// ModifiedPath
	configuration.ModifiedPath = genruntime.ClonePointerToString(source.ModifiedPath)

	// ModifiedQueryString
	configuration.ModifiedQueryString = genruntime.ClonePointerToString(source.ModifiedQueryString)

	// Reroute
	if source.Reroute != nil {
		reroute := *source.Reroute
		configuration.Reroute = &reroute
	} else {
		configuration.Reroute = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ApplicationGatewayUrlConfiguration populates the provided destination ApplicationGatewayUrlConfiguration from our ApplicationGatewayUrlConfiguration
func (configuration *ApplicationGatewayUrlConfiguration) AssignProperties_To_ApplicationGatewayUrlConfiguration(destination *storage.ApplicationGatewayUrlConfiguration) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ModifiedPath
	destination.ModifiedPath = genruntime.ClonePointerToString(configuration.ModifiedPath)

	// ModifiedQueryString
	destination.ModifiedQueryString = genruntime.ClonePointerToString(configuration.ModifiedQueryString)

	// Reroute
	if configuration.Reroute != nil {
		reroute := *configuration.Reroute
		destination.Reroute = &reroute
	} else {
		destination.Reroute = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

func init() {
	SchemeBuilder.Register(&ApplicationGateway{}, &ApplicationGatewayList{})
}
