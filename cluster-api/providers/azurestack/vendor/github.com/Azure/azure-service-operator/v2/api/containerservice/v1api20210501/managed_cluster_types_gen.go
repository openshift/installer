// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20210501

import (
	"fmt"
	arm "github.com/Azure/azure-service-operator/v2/api/containerservice/v1api20210501/arm"
	storage "github.com/Azure/azure-service-operator/v2/api/containerservice/v1api20210501/storage"
	"github.com/Azure/azure-service-operator/v2/internal/reflecthelpers"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/configmaps"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/core"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/secrets"
	"github.com/pkg/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
	"sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
type ManagedCluster struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ManagedCluster_Spec   `json:"spec,omitempty"`
	Status            ManagedCluster_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &ManagedCluster{}

// GetConditions returns the conditions of the resource
func (cluster *ManagedCluster) GetConditions() conditions.Conditions {
	return cluster.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (cluster *ManagedCluster) SetConditions(conditions conditions.Conditions) {
	cluster.Status.Conditions = conditions
}

var _ conversion.Convertible = &ManagedCluster{}

// ConvertFrom populates our ManagedCluster from the provided hub ManagedCluster
func (cluster *ManagedCluster) ConvertFrom(hub conversion.Hub) error {
	// intermediate variable for conversion
	var source storage.ManagedCluster

	err := source.ConvertFrom(hub)
	if err != nil {
		return errors.Wrap(err, "converting from hub to source")
	}

	err = cluster.AssignProperties_From_ManagedCluster(&source)
	if err != nil {
		return errors.Wrap(err, "converting from source to cluster")
	}

	return nil
}

// ConvertTo populates the provided hub ManagedCluster from our ManagedCluster
func (cluster *ManagedCluster) ConvertTo(hub conversion.Hub) error {
	// intermediate variable for conversion
	var destination storage.ManagedCluster
	err := cluster.AssignProperties_To_ManagedCluster(&destination)
	if err != nil {
		return errors.Wrap(err, "converting to destination from cluster")
	}
	err = destination.ConvertTo(hub)
	if err != nil {
		return errors.Wrap(err, "converting from destination to hub")
	}

	return nil
}

// +kubebuilder:webhook:path=/mutate-containerservice-azure-com-v1api20210501-managedcluster,mutating=true,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=containerservice.azure.com,resources=managedclusters,verbs=create;update,versions=v1api20210501,name=default.v1api20210501.managedclusters.containerservice.azure.com,admissionReviewVersions=v1

var _ admission.Defaulter = &ManagedCluster{}

// Default applies defaults to the ManagedCluster resource
func (cluster *ManagedCluster) Default() {
	cluster.defaultImpl()
	var temp any = cluster
	if runtimeDefaulter, ok := temp.(genruntime.Defaulter); ok {
		runtimeDefaulter.CustomDefault()
	}
}

// defaultAzureName defaults the Azure name of the resource to the Kubernetes name
func (cluster *ManagedCluster) defaultAzureName() {
	if cluster.Spec.AzureName == "" {
		cluster.Spec.AzureName = cluster.Name
	}
}

// defaultImpl applies the code generated defaults to the ManagedCluster resource
func (cluster *ManagedCluster) defaultImpl() { cluster.defaultAzureName() }

var _ configmaps.Exporter = &ManagedCluster{}

// ConfigMapDestinationExpressions returns the Spec.OperatorSpec.ConfigMapExpressions property
func (cluster *ManagedCluster) ConfigMapDestinationExpressions() []*core.DestinationExpression {
	if cluster.Spec.OperatorSpec == nil {
		return nil
	}
	return cluster.Spec.OperatorSpec.ConfigMapExpressions
}

var _ secrets.Exporter = &ManagedCluster{}

// SecretDestinationExpressions returns the Spec.OperatorSpec.SecretExpressions property
func (cluster *ManagedCluster) SecretDestinationExpressions() []*core.DestinationExpression {
	if cluster.Spec.OperatorSpec == nil {
		return nil
	}
	return cluster.Spec.OperatorSpec.SecretExpressions
}

var _ genruntime.KubernetesResource = &ManagedCluster{}

// AzureName returns the Azure name of the resource
func (cluster *ManagedCluster) AzureName() string {
	return cluster.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2021-05-01"
func (cluster ManagedCluster) GetAPIVersion() string {
	return "2021-05-01"
}

// GetResourceScope returns the scope of the resource
func (cluster *ManagedCluster) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (cluster *ManagedCluster) GetSpec() genruntime.ConvertibleSpec {
	return &cluster.Spec
}

// GetStatus returns the status of this resource
func (cluster *ManagedCluster) GetStatus() genruntime.ConvertibleStatus {
	return &cluster.Status
}

// GetSupportedOperations returns the operations supported by the resource
func (cluster *ManagedCluster) GetSupportedOperations() []genruntime.ResourceOperation {
	return []genruntime.ResourceOperation{
		genruntime.ResourceOperationDelete,
		genruntime.ResourceOperationGet,
		genruntime.ResourceOperationPut,
	}
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.ContainerService/managedClusters"
func (cluster *ManagedCluster) GetType() string {
	return "Microsoft.ContainerService/managedClusters"
}

// NewEmptyStatus returns a new empty (blank) status
func (cluster *ManagedCluster) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &ManagedCluster_STATUS{}
}

// Owner returns the ResourceReference of the owner
func (cluster *ManagedCluster) Owner() *genruntime.ResourceReference {
	group, kind := genruntime.LookupOwnerGroupKind(cluster.Spec)
	return cluster.Spec.Owner.AsResourceReference(group, kind)
}

// SetStatus sets the status of this resource
func (cluster *ManagedCluster) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*ManagedCluster_STATUS); ok {
		cluster.Status = *st
		return nil
	}

	// Convert status to required version
	var st ManagedCluster_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return errors.Wrap(err, "failed to convert status")
	}

	cluster.Status = st
	return nil
}

// +kubebuilder:webhook:path=/validate-containerservice-azure-com-v1api20210501-managedcluster,mutating=false,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=containerservice.azure.com,resources=managedclusters,verbs=create;update,versions=v1api20210501,name=validate.v1api20210501.managedclusters.containerservice.azure.com,admissionReviewVersions=v1

var _ admission.Validator = &ManagedCluster{}

// ValidateCreate validates the creation of the resource
func (cluster *ManagedCluster) ValidateCreate() (admission.Warnings, error) {
	validations := cluster.createValidations()
	var temp any = cluster
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.CreateValidations()...)
	}
	return genruntime.ValidateCreate(validations)
}

// ValidateDelete validates the deletion of the resource
func (cluster *ManagedCluster) ValidateDelete() (admission.Warnings, error) {
	validations := cluster.deleteValidations()
	var temp any = cluster
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.DeleteValidations()...)
	}
	return genruntime.ValidateDelete(validations)
}

// ValidateUpdate validates an update of the resource
func (cluster *ManagedCluster) ValidateUpdate(old runtime.Object) (admission.Warnings, error) {
	validations := cluster.updateValidations()
	var temp any = cluster
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.UpdateValidations()...)
	}
	return genruntime.ValidateUpdate(old, validations)
}

// createValidations validates the creation of the resource
func (cluster *ManagedCluster) createValidations() []func() (admission.Warnings, error) {
	return []func() (admission.Warnings, error){cluster.validateResourceReferences, cluster.validateOwnerReference, cluster.validateSecretDestinations, cluster.validateConfigMapDestinations}
}

// deleteValidations validates the deletion of the resource
func (cluster *ManagedCluster) deleteValidations() []func() (admission.Warnings, error) {
	return nil
}

// updateValidations validates the update of the resource
func (cluster *ManagedCluster) updateValidations() []func(old runtime.Object) (admission.Warnings, error) {
	return []func(old runtime.Object) (admission.Warnings, error){
		func(old runtime.Object) (admission.Warnings, error) {
			return cluster.validateResourceReferences()
		},
		cluster.validateWriteOnceProperties,
		func(old runtime.Object) (admission.Warnings, error) {
			return cluster.validateOwnerReference()
		},
		func(old runtime.Object) (admission.Warnings, error) {
			return cluster.validateSecretDestinations()
		},
		func(old runtime.Object) (admission.Warnings, error) {
			return cluster.validateConfigMapDestinations()
		},
	}
}

// validateConfigMapDestinations validates there are no colliding genruntime.ConfigMapDestinations
func (cluster *ManagedCluster) validateConfigMapDestinations() (admission.Warnings, error) {
	if cluster.Spec.OperatorSpec == nil {
		return nil, nil
	}
	return configmaps.ValidateDestinations(cluster, nil, cluster.Spec.OperatorSpec.ConfigMapExpressions)
}

// validateOwnerReference validates the owner field
func (cluster *ManagedCluster) validateOwnerReference() (admission.Warnings, error) {
	return genruntime.ValidateOwner(cluster)
}

// validateResourceReferences validates all resource references
func (cluster *ManagedCluster) validateResourceReferences() (admission.Warnings, error) {
	refs, err := reflecthelpers.FindResourceReferences(&cluster.Spec)
	if err != nil {
		return nil, err
	}
	return genruntime.ValidateResourceReferences(refs)
}

// validateSecretDestinations validates there are no colliding genruntime.SecretDestination's
func (cluster *ManagedCluster) validateSecretDestinations() (admission.Warnings, error) {
	if cluster.Spec.OperatorSpec == nil {
		return nil, nil
	}
	var toValidate []*genruntime.SecretDestination
	if cluster.Spec.OperatorSpec.Secrets != nil {
		toValidate = []*genruntime.SecretDestination{
			cluster.Spec.OperatorSpec.Secrets.AdminCredentials,
			cluster.Spec.OperatorSpec.Secrets.UserCredentials,
		}
	}
	return secrets.ValidateDestinations(cluster, toValidate, cluster.Spec.OperatorSpec.SecretExpressions)
}

// validateWriteOnceProperties validates all WriteOnce properties
func (cluster *ManagedCluster) validateWriteOnceProperties(old runtime.Object) (admission.Warnings, error) {
	oldObj, ok := old.(*ManagedCluster)
	if !ok {
		return nil, nil
	}

	return genruntime.ValidateWriteOnceProperties(oldObj, cluster)
}

// AssignProperties_From_ManagedCluster populates our ManagedCluster from the provided source ManagedCluster
func (cluster *ManagedCluster) AssignProperties_From_ManagedCluster(source *storage.ManagedCluster) error {

	// ObjectMeta
	cluster.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec ManagedCluster_Spec
	err := spec.AssignProperties_From_ManagedCluster_Spec(&source.Spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_ManagedCluster_Spec() to populate field Spec")
	}
	cluster.Spec = spec

	// Status
	var status ManagedCluster_STATUS
	err = status.AssignProperties_From_ManagedCluster_STATUS(&source.Status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_ManagedCluster_STATUS() to populate field Status")
	}
	cluster.Status = status

	// No error
	return nil
}

// AssignProperties_To_ManagedCluster populates the provided destination ManagedCluster from our ManagedCluster
func (cluster *ManagedCluster) AssignProperties_To_ManagedCluster(destination *storage.ManagedCluster) error {

	// ObjectMeta
	destination.ObjectMeta = *cluster.ObjectMeta.DeepCopy()

	// Spec
	var spec storage.ManagedCluster_Spec
	err := cluster.Spec.AssignProperties_To_ManagedCluster_Spec(&spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_ManagedCluster_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status storage.ManagedCluster_STATUS
	err = cluster.Status.AssignProperties_To_ManagedCluster_STATUS(&status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_ManagedCluster_STATUS() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (cluster *ManagedCluster) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: cluster.Spec.OriginalVersion(),
		Kind:    "ManagedCluster",
	}
}

// +kubebuilder:object:root=true
type ManagedClusterList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ManagedCluster `json:"items"`
}

// +kubebuilder:validation:Enum={"2021-05-01"}
type APIVersion string

const APIVersion_Value = APIVersion("2021-05-01")

type ManagedCluster_Spec struct {
	AadProfile             *ManagedClusterAADProfile                   `json:"aadProfile,omitempty"`
	AddonProfiles          map[string]ManagedClusterAddonProfile       `json:"addonProfiles,omitempty"`
	AgentPoolProfiles      []ManagedClusterAgentPoolProfile            `json:"agentPoolProfiles,omitempty"`
	ApiServerAccessProfile *ManagedClusterAPIServerAccessProfile       `json:"apiServerAccessProfile,omitempty"`
	AutoScalerProfile      *ManagedClusterProperties_AutoScalerProfile `json:"autoScalerProfile,omitempty"`
	AutoUpgradeProfile     *ManagedClusterAutoUpgradeProfile           `json:"autoUpgradeProfile,omitempty"`

	// +kubebuilder:validation:MaxLength=63
	// +kubebuilder:validation:MinLength=1
	// +kubebuilder:validation:Pattern="^[a-zA-Z0-9]$|^[a-zA-Z0-9][-_a-zA-Z0-9]{0,61}[a-zA-Z0-9]$"
	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName                    string                          `json:"azureName,omitempty"`
	DisableLocalAccounts         *bool                           `json:"disableLocalAccounts,omitempty"`
	DiskEncryptionSetIDReference *genruntime.ResourceReference   `armReference:"DiskEncryptionSetID" json:"diskEncryptionSetIDReference,omitempty"`
	DnsPrefix                    *string                         `json:"dnsPrefix,omitempty"`
	EnablePodSecurityPolicy      *bool                           `json:"enablePodSecurityPolicy,omitempty"`
	EnableRBAC                   *bool                           `json:"enableRBAC,omitempty"`
	ExtendedLocation             *ExtendedLocation               `json:"extendedLocation,omitempty"`
	FqdnSubdomain                *string                         `json:"fqdnSubdomain,omitempty"`
	HttpProxyConfig              *ManagedClusterHTTPProxyConfig  `json:"httpProxyConfig,omitempty"`
	Identity                     *ManagedClusterIdentity         `json:"identity,omitempty"`
	IdentityProfile              map[string]UserAssignedIdentity `json:"identityProfile,omitempty"`
	KubernetesVersion            *string                         `json:"kubernetesVersion,omitempty"`
	LinuxProfile                 *ContainerServiceLinuxProfile   `json:"linuxProfile,omitempty"`

	// +kubebuilder:validation:Required
	Location          *string                         `json:"location,omitempty"`
	NetworkProfile    *ContainerServiceNetworkProfile `json:"networkProfile,omitempty"`
	NodeResourceGroup *string                         `json:"nodeResourceGroup,omitempty"`

	// OperatorSpec: The specification for configuring operator behavior. This field is interpreted by the operator and not
	// passed directly to Azure
	OperatorSpec *ManagedClusterOperatorSpec `json:"operatorSpec,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a resources.azure.com/ResourceGroup resource
	Owner                   *genruntime.KnownResourceReference     `group:"resources.azure.com" json:"owner,omitempty" kind:"ResourceGroup"`
	PodIdentityProfile      *ManagedClusterPodIdentityProfile      `json:"podIdentityProfile,omitempty"`
	PrivateLinkResources    []PrivateLinkResource                  `json:"privateLinkResources,omitempty"`
	ServicePrincipalProfile *ManagedClusterServicePrincipalProfile `json:"servicePrincipalProfile,omitempty"`
	Sku                     *ManagedClusterSKU                     `json:"sku,omitempty"`
	Tags                    map[string]string                      `json:"tags,omitempty" serializationType:"explicitEmptyCollection"`
	WindowsProfile          *ManagedClusterWindowsProfile          `json:"windowsProfile,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedCluster_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (cluster *ManagedCluster_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if cluster == nil {
		return nil, nil
	}
	result := &arm.ManagedCluster_Spec{}

	// Set property "ExtendedLocation":
	if cluster.ExtendedLocation != nil {
		extendedLocation_ARM, err := (*cluster.ExtendedLocation).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		extendedLocation := *extendedLocation_ARM.(*arm.ExtendedLocation)
		result.ExtendedLocation = &extendedLocation
	}

	// Set property "Identity":
	if cluster.Identity != nil {
		identity_ARM, err := (*cluster.Identity).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		identity := *identity_ARM.(*arm.ManagedClusterIdentity)
		result.Identity = &identity
	}

	// Set property "Location":
	if cluster.Location != nil {
		location := *cluster.Location
		result.Location = &location
	}

	// Set property "Name":
	result.Name = resolved.Name

	// Set property "Properties":
	if cluster.AadProfile != nil ||
		cluster.AddonProfiles != nil ||
		cluster.AgentPoolProfiles != nil ||
		cluster.ApiServerAccessProfile != nil ||
		cluster.AutoScalerProfile != nil ||
		cluster.AutoUpgradeProfile != nil ||
		cluster.DisableLocalAccounts != nil ||
		cluster.DiskEncryptionSetIDReference != nil ||
		cluster.DnsPrefix != nil ||
		cluster.EnablePodSecurityPolicy != nil ||
		cluster.EnableRBAC != nil ||
		cluster.FqdnSubdomain != nil ||
		cluster.HttpProxyConfig != nil ||
		cluster.IdentityProfile != nil ||
		cluster.KubernetesVersion != nil ||
		cluster.LinuxProfile != nil ||
		cluster.NetworkProfile != nil ||
		cluster.NodeResourceGroup != nil ||
		cluster.PodIdentityProfile != nil ||
		cluster.PrivateLinkResources != nil ||
		cluster.ServicePrincipalProfile != nil ||
		cluster.WindowsProfile != nil {
		result.Properties = &arm.ManagedClusterProperties{}
	}
	if cluster.AadProfile != nil {
		aadProfile_ARM, err := (*cluster.AadProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		aadProfile := *aadProfile_ARM.(*arm.ManagedClusterAADProfile)
		result.Properties.AadProfile = &aadProfile
	}
	if cluster.AddonProfiles != nil {
		result.Properties.AddonProfiles = make(map[string]arm.ManagedClusterAddonProfile, len(cluster.AddonProfiles))
		for key, value := range cluster.AddonProfiles {
			value_ARM, err := value.ConvertToARM(resolved)
			if err != nil {
				return nil, err
			}
			result.Properties.AddonProfiles[key] = *value_ARM.(*arm.ManagedClusterAddonProfile)
		}
	}
	for _, item := range cluster.AgentPoolProfiles {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.AgentPoolProfiles = append(result.Properties.AgentPoolProfiles, *item_ARM.(*arm.ManagedClusterAgentPoolProfile))
	}
	if cluster.ApiServerAccessProfile != nil {
		apiServerAccessProfile_ARM, err := (*cluster.ApiServerAccessProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		apiServerAccessProfile := *apiServerAccessProfile_ARM.(*arm.ManagedClusterAPIServerAccessProfile)
		result.Properties.ApiServerAccessProfile = &apiServerAccessProfile
	}
	if cluster.AutoScalerProfile != nil {
		autoScalerProfile_ARM, err := (*cluster.AutoScalerProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		autoScalerProfile := *autoScalerProfile_ARM.(*arm.ManagedClusterProperties_AutoScalerProfile)
		result.Properties.AutoScalerProfile = &autoScalerProfile
	}
	if cluster.AutoUpgradeProfile != nil {
		autoUpgradeProfile_ARM, err := (*cluster.AutoUpgradeProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		autoUpgradeProfile := *autoUpgradeProfile_ARM.(*arm.ManagedClusterAutoUpgradeProfile)
		result.Properties.AutoUpgradeProfile = &autoUpgradeProfile
	}
	if cluster.DisableLocalAccounts != nil {
		disableLocalAccounts := *cluster.DisableLocalAccounts
		result.Properties.DisableLocalAccounts = &disableLocalAccounts
	}
	if cluster.DiskEncryptionSetIDReference != nil {
		diskEncryptionSetIDARMID, err := resolved.ResolvedReferences.Lookup(*cluster.DiskEncryptionSetIDReference)
		if err != nil {
			return nil, err
		}
		diskEncryptionSetID := diskEncryptionSetIDARMID
		result.Properties.DiskEncryptionSetID = &diskEncryptionSetID
	}
	if cluster.DnsPrefix != nil {
		dnsPrefix := *cluster.DnsPrefix
		result.Properties.DnsPrefix = &dnsPrefix
	}
	if cluster.EnablePodSecurityPolicy != nil {
		enablePodSecurityPolicy := *cluster.EnablePodSecurityPolicy
		result.Properties.EnablePodSecurityPolicy = &enablePodSecurityPolicy
	}
	if cluster.EnableRBAC != nil {
		enableRBAC := *cluster.EnableRBAC
		result.Properties.EnableRBAC = &enableRBAC
	}
	if cluster.FqdnSubdomain != nil {
		fqdnSubdomain := *cluster.FqdnSubdomain
		result.Properties.FqdnSubdomain = &fqdnSubdomain
	}
	if cluster.HttpProxyConfig != nil {
		httpProxyConfig_ARM, err := (*cluster.HttpProxyConfig).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		httpProxyConfig := *httpProxyConfig_ARM.(*arm.ManagedClusterHTTPProxyConfig)
		result.Properties.HttpProxyConfig = &httpProxyConfig
	}
	if cluster.IdentityProfile != nil {
		result.Properties.IdentityProfile = make(map[string]arm.UserAssignedIdentity, len(cluster.IdentityProfile))
		for key, value := range cluster.IdentityProfile {
			value_ARM, err := value.ConvertToARM(resolved)
			if err != nil {
				return nil, err
			}
			result.Properties.IdentityProfile[key] = *value_ARM.(*arm.UserAssignedIdentity)
		}
	}
	if cluster.KubernetesVersion != nil {
		kubernetesVersion := *cluster.KubernetesVersion
		result.Properties.KubernetesVersion = &kubernetesVersion
	}
	if cluster.LinuxProfile != nil {
		linuxProfile_ARM, err := (*cluster.LinuxProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		linuxProfile := *linuxProfile_ARM.(*arm.ContainerServiceLinuxProfile)
		result.Properties.LinuxProfile = &linuxProfile
	}
	if cluster.NetworkProfile != nil {
		networkProfile_ARM, err := (*cluster.NetworkProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		networkProfile := *networkProfile_ARM.(*arm.ContainerServiceNetworkProfile)
		result.Properties.NetworkProfile = &networkProfile
	}
	if cluster.NodeResourceGroup != nil {
		nodeResourceGroup := *cluster.NodeResourceGroup
		result.Properties.NodeResourceGroup = &nodeResourceGroup
	}
	if cluster.PodIdentityProfile != nil {
		podIdentityProfile_ARM, err := (*cluster.PodIdentityProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		podIdentityProfile := *podIdentityProfile_ARM.(*arm.ManagedClusterPodIdentityProfile)
		result.Properties.PodIdentityProfile = &podIdentityProfile
	}
	for _, item := range cluster.PrivateLinkResources {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.PrivateLinkResources = append(result.Properties.PrivateLinkResources, *item_ARM.(*arm.PrivateLinkResource))
	}
	if cluster.ServicePrincipalProfile != nil {
		servicePrincipalProfile_ARM, err := (*cluster.ServicePrincipalProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		servicePrincipalProfile := *servicePrincipalProfile_ARM.(*arm.ManagedClusterServicePrincipalProfile)
		result.Properties.ServicePrincipalProfile = &servicePrincipalProfile
	}
	if cluster.WindowsProfile != nil {
		windowsProfile_ARM, err := (*cluster.WindowsProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		windowsProfile := *windowsProfile_ARM.(*arm.ManagedClusterWindowsProfile)
		result.Properties.WindowsProfile = &windowsProfile
	}

	// Set property "Sku":
	if cluster.Sku != nil {
		sku_ARM, err := (*cluster.Sku).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		sku := *sku_ARM.(*arm.ManagedClusterSKU)
		result.Sku = &sku
	}

	// Set property "Tags":
	if cluster.Tags != nil {
		result.Tags = make(map[string]string, len(cluster.Tags))
		for key, value := range cluster.Tags {
			result.Tags[key] = value
		}
	} else {
		// Set property to empty map, as this resource is set to serialize all collections explicitly
		result.Tags = make(map[string]string)
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (cluster *ManagedCluster_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedCluster_Spec{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (cluster *ManagedCluster_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedCluster_Spec)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedCluster_Spec, got %T", armInput)
	}

	// Set property "AadProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AadProfile != nil {
			var aadProfile1 ManagedClusterAADProfile
			err := aadProfile1.PopulateFromARM(owner, *typedInput.Properties.AadProfile)
			if err != nil {
				return err
			}
			aadProfile := aadProfile1
			cluster.AadProfile = &aadProfile
		}
	}

	// Set property "AddonProfiles":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AddonProfiles != nil {
			cluster.AddonProfiles = make(map[string]ManagedClusterAddonProfile, len(typedInput.Properties.AddonProfiles))
			for key, value := range typedInput.Properties.AddonProfiles {
				var value1 ManagedClusterAddonProfile
				err := value1.PopulateFromARM(owner, value)
				if err != nil {
					return err
				}
				cluster.AddonProfiles[key] = value1
			}
		}
	}

	// Set property "AgentPoolProfiles":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.AgentPoolProfiles {
			var item1 ManagedClusterAgentPoolProfile
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			cluster.AgentPoolProfiles = append(cluster.AgentPoolProfiles, item1)
		}
	}

	// Set property "ApiServerAccessProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ApiServerAccessProfile != nil {
			var apiServerAccessProfile1 ManagedClusterAPIServerAccessProfile
			err := apiServerAccessProfile1.PopulateFromARM(owner, *typedInput.Properties.ApiServerAccessProfile)
			if err != nil {
				return err
			}
			apiServerAccessProfile := apiServerAccessProfile1
			cluster.ApiServerAccessProfile = &apiServerAccessProfile
		}
	}

	// Set property "AutoScalerProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AutoScalerProfile != nil {
			var autoScalerProfile1 ManagedClusterProperties_AutoScalerProfile
			err := autoScalerProfile1.PopulateFromARM(owner, *typedInput.Properties.AutoScalerProfile)
			if err != nil {
				return err
			}
			autoScalerProfile := autoScalerProfile1
			cluster.AutoScalerProfile = &autoScalerProfile
		}
	}

	// Set property "AutoUpgradeProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AutoUpgradeProfile != nil {
			var autoUpgradeProfile1 ManagedClusterAutoUpgradeProfile
			err := autoUpgradeProfile1.PopulateFromARM(owner, *typedInput.Properties.AutoUpgradeProfile)
			if err != nil {
				return err
			}
			autoUpgradeProfile := autoUpgradeProfile1
			cluster.AutoUpgradeProfile = &autoUpgradeProfile
		}
	}

	// Set property "AzureName":
	cluster.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property "DisableLocalAccounts":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DisableLocalAccounts != nil {
			disableLocalAccounts := *typedInput.Properties.DisableLocalAccounts
			cluster.DisableLocalAccounts = &disableLocalAccounts
		}
	}

	// no assignment for property "DiskEncryptionSetIDReference"

	// Set property "DnsPrefix":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DnsPrefix != nil {
			dnsPrefix := *typedInput.Properties.DnsPrefix
			cluster.DnsPrefix = &dnsPrefix
		}
	}

	// Set property "EnablePodSecurityPolicy":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnablePodSecurityPolicy != nil {
			enablePodSecurityPolicy := *typedInput.Properties.EnablePodSecurityPolicy
			cluster.EnablePodSecurityPolicy = &enablePodSecurityPolicy
		}
	}

	// Set property "EnableRBAC":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableRBAC != nil {
			enableRBAC := *typedInput.Properties.EnableRBAC
			cluster.EnableRBAC = &enableRBAC
		}
	}

	// Set property "ExtendedLocation":
	if typedInput.ExtendedLocation != nil {
		var extendedLocation1 ExtendedLocation
		err := extendedLocation1.PopulateFromARM(owner, *typedInput.ExtendedLocation)
		if err != nil {
			return err
		}
		extendedLocation := extendedLocation1
		cluster.ExtendedLocation = &extendedLocation
	}

	// Set property "FqdnSubdomain":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.FqdnSubdomain != nil {
			fqdnSubdomain := *typedInput.Properties.FqdnSubdomain
			cluster.FqdnSubdomain = &fqdnSubdomain
		}
	}

	// Set property "HttpProxyConfig":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HttpProxyConfig != nil {
			var httpProxyConfig1 ManagedClusterHTTPProxyConfig
			err := httpProxyConfig1.PopulateFromARM(owner, *typedInput.Properties.HttpProxyConfig)
			if err != nil {
				return err
			}
			httpProxyConfig := httpProxyConfig1
			cluster.HttpProxyConfig = &httpProxyConfig
		}
	}

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 ManagedClusterIdentity
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		cluster.Identity = &identity
	}

	// Set property "IdentityProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IdentityProfile != nil {
			cluster.IdentityProfile = make(map[string]UserAssignedIdentity, len(typedInput.Properties.IdentityProfile))
			for key, value := range typedInput.Properties.IdentityProfile {
				var value1 UserAssignedIdentity
				err := value1.PopulateFromARM(owner, value)
				if err != nil {
					return err
				}
				cluster.IdentityProfile[key] = value1
			}
		}
	}

	// Set property "KubernetesVersion":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.KubernetesVersion != nil {
			kubernetesVersion := *typedInput.Properties.KubernetesVersion
			cluster.KubernetesVersion = &kubernetesVersion
		}
	}

	// Set property "LinuxProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.LinuxProfile != nil {
			var linuxProfile1 ContainerServiceLinuxProfile
			err := linuxProfile1.PopulateFromARM(owner, *typedInput.Properties.LinuxProfile)
			if err != nil {
				return err
			}
			linuxProfile := linuxProfile1
			cluster.LinuxProfile = &linuxProfile
		}
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		cluster.Location = &location
	}

	// Set property "NetworkProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.NetworkProfile != nil {
			var networkProfile1 ContainerServiceNetworkProfile
			err := networkProfile1.PopulateFromARM(owner, *typedInput.Properties.NetworkProfile)
			if err != nil {
				return err
			}
			networkProfile := networkProfile1
			cluster.NetworkProfile = &networkProfile
		}
	}

	// Set property "NodeResourceGroup":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.NodeResourceGroup != nil {
			nodeResourceGroup := *typedInput.Properties.NodeResourceGroup
			cluster.NodeResourceGroup = &nodeResourceGroup
		}
	}

	// no assignment for property "OperatorSpec"

	// Set property "Owner":
	cluster.Owner = &genruntime.KnownResourceReference{
		Name:  owner.Name,
		ARMID: owner.ARMID,
	}

	// Set property "PodIdentityProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PodIdentityProfile != nil {
			var podIdentityProfile1 ManagedClusterPodIdentityProfile
			err := podIdentityProfile1.PopulateFromARM(owner, *typedInput.Properties.PodIdentityProfile)
			if err != nil {
				return err
			}
			podIdentityProfile := podIdentityProfile1
			cluster.PodIdentityProfile = &podIdentityProfile
		}
	}

	// Set property "PrivateLinkResources":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.PrivateLinkResources {
			var item1 PrivateLinkResource
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			cluster.PrivateLinkResources = append(cluster.PrivateLinkResources, item1)
		}
	}

	// Set property "ServicePrincipalProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ServicePrincipalProfile != nil {
			var servicePrincipalProfile1 ManagedClusterServicePrincipalProfile
			err := servicePrincipalProfile1.PopulateFromARM(owner, *typedInput.Properties.ServicePrincipalProfile)
			if err != nil {
				return err
			}
			servicePrincipalProfile := servicePrincipalProfile1
			cluster.ServicePrincipalProfile = &servicePrincipalProfile
		}
	}

	// Set property "Sku":
	if typedInput.Sku != nil {
		var sku1 ManagedClusterSKU
		err := sku1.PopulateFromARM(owner, *typedInput.Sku)
		if err != nil {
			return err
		}
		sku := sku1
		cluster.Sku = &sku
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		cluster.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			cluster.Tags[key] = value
		}
	} else {
		// Set property to empty map, as this resource is set to serialize all collections explicitly
		cluster.Tags = make(map[string]string)
	}

	// Set property "WindowsProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.WindowsProfile != nil {
			var windowsProfile1 ManagedClusterWindowsProfile
			err := windowsProfile1.PopulateFromARM(owner, *typedInput.Properties.WindowsProfile)
			if err != nil {
				return err
			}
			windowsProfile := windowsProfile1
			cluster.WindowsProfile = &windowsProfile
		}
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &ManagedCluster_Spec{}

// ConvertSpecFrom populates our ManagedCluster_Spec from the provided source
func (cluster *ManagedCluster_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*storage.ManagedCluster_Spec)
	if ok {
		// Populate our instance from source
		return cluster.AssignProperties_From_ManagedCluster_Spec(src)
	}

	// Convert to an intermediate form
	src = &storage.ManagedCluster_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = cluster.AssignProperties_From_ManagedCluster_Spec(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our ManagedCluster_Spec
func (cluster *ManagedCluster_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*storage.ManagedCluster_Spec)
	if ok {
		// Populate destination from our instance
		return cluster.AssignProperties_To_ManagedCluster_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &storage.ManagedCluster_Spec{}
	err := cluster.AssignProperties_To_ManagedCluster_Spec(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignProperties_From_ManagedCluster_Spec populates our ManagedCluster_Spec from the provided source ManagedCluster_Spec
func (cluster *ManagedCluster_Spec) AssignProperties_From_ManagedCluster_Spec(source *storage.ManagedCluster_Spec) error {

	// AadProfile
	if source.AadProfile != nil {
		var aadProfile ManagedClusterAADProfile
		err := aadProfile.AssignProperties_From_ManagedClusterAADProfile(source.AadProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterAADProfile() to populate field AadProfile")
		}
		cluster.AadProfile = &aadProfile
	} else {
		cluster.AadProfile = nil
	}

	// AddonProfiles
	if source.AddonProfiles != nil {
		addonProfileMap := make(map[string]ManagedClusterAddonProfile, len(source.AddonProfiles))
		for addonProfileKey, addonProfileValue := range source.AddonProfiles {
			// Shadow the loop variable to avoid aliasing
			addonProfileValue := addonProfileValue
			var addonProfile ManagedClusterAddonProfile
			err := addonProfile.AssignProperties_From_ManagedClusterAddonProfile(&addonProfileValue)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterAddonProfile() to populate field AddonProfiles")
			}
			addonProfileMap[addonProfileKey] = addonProfile
		}
		cluster.AddonProfiles = addonProfileMap
	} else {
		cluster.AddonProfiles = nil
	}

	// AgentPoolProfiles
	if source.AgentPoolProfiles != nil {
		agentPoolProfileList := make([]ManagedClusterAgentPoolProfile, len(source.AgentPoolProfiles))
		for agentPoolProfileIndex, agentPoolProfileItem := range source.AgentPoolProfiles {
			// Shadow the loop variable to avoid aliasing
			agentPoolProfileItem := agentPoolProfileItem
			var agentPoolProfile ManagedClusterAgentPoolProfile
			err := agentPoolProfile.AssignProperties_From_ManagedClusterAgentPoolProfile(&agentPoolProfileItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterAgentPoolProfile() to populate field AgentPoolProfiles")
			}
			agentPoolProfileList[agentPoolProfileIndex] = agentPoolProfile
		}
		cluster.AgentPoolProfiles = agentPoolProfileList
	} else {
		cluster.AgentPoolProfiles = nil
	}

	// ApiServerAccessProfile
	if source.ApiServerAccessProfile != nil {
		var apiServerAccessProfile ManagedClusterAPIServerAccessProfile
		err := apiServerAccessProfile.AssignProperties_From_ManagedClusterAPIServerAccessProfile(source.ApiServerAccessProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterAPIServerAccessProfile() to populate field ApiServerAccessProfile")
		}
		cluster.ApiServerAccessProfile = &apiServerAccessProfile
	} else {
		cluster.ApiServerAccessProfile = nil
	}

	// AutoScalerProfile
	if source.AutoScalerProfile != nil {
		var autoScalerProfile ManagedClusterProperties_AutoScalerProfile
		err := autoScalerProfile.AssignProperties_From_ManagedClusterProperties_AutoScalerProfile(source.AutoScalerProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterProperties_AutoScalerProfile() to populate field AutoScalerProfile")
		}
		cluster.AutoScalerProfile = &autoScalerProfile
	} else {
		cluster.AutoScalerProfile = nil
	}

	// AutoUpgradeProfile
	if source.AutoUpgradeProfile != nil {
		var autoUpgradeProfile ManagedClusterAutoUpgradeProfile
		err := autoUpgradeProfile.AssignProperties_From_ManagedClusterAutoUpgradeProfile(source.AutoUpgradeProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterAutoUpgradeProfile() to populate field AutoUpgradeProfile")
		}
		cluster.AutoUpgradeProfile = &autoUpgradeProfile
	} else {
		cluster.AutoUpgradeProfile = nil
	}

	// AzureName
	cluster.AzureName = source.AzureName

	// DisableLocalAccounts
	if source.DisableLocalAccounts != nil {
		disableLocalAccount := *source.DisableLocalAccounts
		cluster.DisableLocalAccounts = &disableLocalAccount
	} else {
		cluster.DisableLocalAccounts = nil
	}

	// DiskEncryptionSetIDReference
	if source.DiskEncryptionSetIDReference != nil {
		diskEncryptionSetIDReference := source.DiskEncryptionSetIDReference.Copy()
		cluster.DiskEncryptionSetIDReference = &diskEncryptionSetIDReference
	} else {
		cluster.DiskEncryptionSetIDReference = nil
	}

	// DnsPrefix
	cluster.DnsPrefix = genruntime.ClonePointerToString(source.DnsPrefix)

	// EnablePodSecurityPolicy
	if source.EnablePodSecurityPolicy != nil {
		enablePodSecurityPolicy := *source.EnablePodSecurityPolicy
		cluster.EnablePodSecurityPolicy = &enablePodSecurityPolicy
	} else {
		cluster.EnablePodSecurityPolicy = nil
	}

	// EnableRBAC
	if source.EnableRBAC != nil {
		enableRBAC := *source.EnableRBAC
		cluster.EnableRBAC = &enableRBAC
	} else {
		cluster.EnableRBAC = nil
	}

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocation ExtendedLocation
		err := extendedLocation.AssignProperties_From_ExtendedLocation(source.ExtendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ExtendedLocation() to populate field ExtendedLocation")
		}
		cluster.ExtendedLocation = &extendedLocation
	} else {
		cluster.ExtendedLocation = nil
	}

	// FqdnSubdomain
	cluster.FqdnSubdomain = genruntime.ClonePointerToString(source.FqdnSubdomain)

	// HttpProxyConfig
	if source.HttpProxyConfig != nil {
		var httpProxyConfig ManagedClusterHTTPProxyConfig
		err := httpProxyConfig.AssignProperties_From_ManagedClusterHTTPProxyConfig(source.HttpProxyConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterHTTPProxyConfig() to populate field HttpProxyConfig")
		}
		cluster.HttpProxyConfig = &httpProxyConfig
	} else {
		cluster.HttpProxyConfig = nil
	}

	// Identity
	if source.Identity != nil {
		var identity ManagedClusterIdentity
		err := identity.AssignProperties_From_ManagedClusterIdentity(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterIdentity() to populate field Identity")
		}
		cluster.Identity = &identity
	} else {
		cluster.Identity = nil
	}

	// IdentityProfile
	if source.IdentityProfile != nil {
		identityProfileMap := make(map[string]UserAssignedIdentity, len(source.IdentityProfile))
		for identityProfileKey, identityProfileValue := range source.IdentityProfile {
			// Shadow the loop variable to avoid aliasing
			identityProfileValue := identityProfileValue
			var identityProfile UserAssignedIdentity
			err := identityProfile.AssignProperties_From_UserAssignedIdentity(&identityProfileValue)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_UserAssignedIdentity() to populate field IdentityProfile")
			}
			identityProfileMap[identityProfileKey] = identityProfile
		}
		cluster.IdentityProfile = identityProfileMap
	} else {
		cluster.IdentityProfile = nil
	}

	// KubernetesVersion
	cluster.KubernetesVersion = genruntime.ClonePointerToString(source.KubernetesVersion)

	// LinuxProfile
	if source.LinuxProfile != nil {
		var linuxProfile ContainerServiceLinuxProfile
		err := linuxProfile.AssignProperties_From_ContainerServiceLinuxProfile(source.LinuxProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ContainerServiceLinuxProfile() to populate field LinuxProfile")
		}
		cluster.LinuxProfile = &linuxProfile
	} else {
		cluster.LinuxProfile = nil
	}

	// Location
	cluster.Location = genruntime.ClonePointerToString(source.Location)

	// NetworkProfile
	if source.NetworkProfile != nil {
		var networkProfile ContainerServiceNetworkProfile
		err := networkProfile.AssignProperties_From_ContainerServiceNetworkProfile(source.NetworkProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ContainerServiceNetworkProfile() to populate field NetworkProfile")
		}
		cluster.NetworkProfile = &networkProfile
	} else {
		cluster.NetworkProfile = nil
	}

	// NodeResourceGroup
	cluster.NodeResourceGroup = genruntime.ClonePointerToString(source.NodeResourceGroup)

	// OperatorSpec
	if source.OperatorSpec != nil {
		var operatorSpec ManagedClusterOperatorSpec
		err := operatorSpec.AssignProperties_From_ManagedClusterOperatorSpec(source.OperatorSpec)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterOperatorSpec() to populate field OperatorSpec")
		}
		cluster.OperatorSpec = &operatorSpec
	} else {
		cluster.OperatorSpec = nil
	}

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		cluster.Owner = &owner
	} else {
		cluster.Owner = nil
	}

	// PodIdentityProfile
	if source.PodIdentityProfile != nil {
		var podIdentityProfile ManagedClusterPodIdentityProfile
		err := podIdentityProfile.AssignProperties_From_ManagedClusterPodIdentityProfile(source.PodIdentityProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterPodIdentityProfile() to populate field PodIdentityProfile")
		}
		cluster.PodIdentityProfile = &podIdentityProfile
	} else {
		cluster.PodIdentityProfile = nil
	}

	// PrivateLinkResources
	if source.PrivateLinkResources != nil {
		privateLinkResourceList := make([]PrivateLinkResource, len(source.PrivateLinkResources))
		for privateLinkResourceIndex, privateLinkResourceItem := range source.PrivateLinkResources {
			// Shadow the loop variable to avoid aliasing
			privateLinkResourceItem := privateLinkResourceItem
			var privateLinkResource PrivateLinkResource
			err := privateLinkResource.AssignProperties_From_PrivateLinkResource(&privateLinkResourceItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_PrivateLinkResource() to populate field PrivateLinkResources")
			}
			privateLinkResourceList[privateLinkResourceIndex] = privateLinkResource
		}
		cluster.PrivateLinkResources = privateLinkResourceList
	} else {
		cluster.PrivateLinkResources = nil
	}

	// ServicePrincipalProfile
	if source.ServicePrincipalProfile != nil {
		var servicePrincipalProfile ManagedClusterServicePrincipalProfile
		err := servicePrincipalProfile.AssignProperties_From_ManagedClusterServicePrincipalProfile(source.ServicePrincipalProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterServicePrincipalProfile() to populate field ServicePrincipalProfile")
		}
		cluster.ServicePrincipalProfile = &servicePrincipalProfile
	} else {
		cluster.ServicePrincipalProfile = nil
	}

	// Sku
	if source.Sku != nil {
		var sku ManagedClusterSKU
		err := sku.AssignProperties_From_ManagedClusterSKU(source.Sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterSKU() to populate field Sku")
		}
		cluster.Sku = &sku
	} else {
		cluster.Sku = nil
	}

	// Tags
	cluster.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// WindowsProfile
	if source.WindowsProfile != nil {
		var windowsProfile ManagedClusterWindowsProfile
		err := windowsProfile.AssignProperties_From_ManagedClusterWindowsProfile(source.WindowsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterWindowsProfile() to populate field WindowsProfile")
		}
		cluster.WindowsProfile = &windowsProfile
	} else {
		cluster.WindowsProfile = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedCluster_Spec populates the provided destination ManagedCluster_Spec from our ManagedCluster_Spec
func (cluster *ManagedCluster_Spec) AssignProperties_To_ManagedCluster_Spec(destination *storage.ManagedCluster_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AadProfile
	if cluster.AadProfile != nil {
		var aadProfile storage.ManagedClusterAADProfile
		err := cluster.AadProfile.AssignProperties_To_ManagedClusterAADProfile(&aadProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterAADProfile() to populate field AadProfile")
		}
		destination.AadProfile = &aadProfile
	} else {
		destination.AadProfile = nil
	}

	// AddonProfiles
	if cluster.AddonProfiles != nil {
		addonProfileMap := make(map[string]storage.ManagedClusterAddonProfile, len(cluster.AddonProfiles))
		for addonProfileKey, addonProfileValue := range cluster.AddonProfiles {
			// Shadow the loop variable to avoid aliasing
			addonProfileValue := addonProfileValue
			var addonProfile storage.ManagedClusterAddonProfile
			err := addonProfileValue.AssignProperties_To_ManagedClusterAddonProfile(&addonProfile)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterAddonProfile() to populate field AddonProfiles")
			}
			addonProfileMap[addonProfileKey] = addonProfile
		}
		destination.AddonProfiles = addonProfileMap
	} else {
		destination.AddonProfiles = nil
	}

	// AgentPoolProfiles
	if cluster.AgentPoolProfiles != nil {
		agentPoolProfileList := make([]storage.ManagedClusterAgentPoolProfile, len(cluster.AgentPoolProfiles))
		for agentPoolProfileIndex, agentPoolProfileItem := range cluster.AgentPoolProfiles {
			// Shadow the loop variable to avoid aliasing
			agentPoolProfileItem := agentPoolProfileItem
			var agentPoolProfile storage.ManagedClusterAgentPoolProfile
			err := agentPoolProfileItem.AssignProperties_To_ManagedClusterAgentPoolProfile(&agentPoolProfile)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterAgentPoolProfile() to populate field AgentPoolProfiles")
			}
			agentPoolProfileList[agentPoolProfileIndex] = agentPoolProfile
		}
		destination.AgentPoolProfiles = agentPoolProfileList
	} else {
		destination.AgentPoolProfiles = nil
	}

	// ApiServerAccessProfile
	if cluster.ApiServerAccessProfile != nil {
		var apiServerAccessProfile storage.ManagedClusterAPIServerAccessProfile
		err := cluster.ApiServerAccessProfile.AssignProperties_To_ManagedClusterAPIServerAccessProfile(&apiServerAccessProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterAPIServerAccessProfile() to populate field ApiServerAccessProfile")
		}
		destination.ApiServerAccessProfile = &apiServerAccessProfile
	} else {
		destination.ApiServerAccessProfile = nil
	}

	// AutoScalerProfile
	if cluster.AutoScalerProfile != nil {
		var autoScalerProfile storage.ManagedClusterProperties_AutoScalerProfile
		err := cluster.AutoScalerProfile.AssignProperties_To_ManagedClusterProperties_AutoScalerProfile(&autoScalerProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterProperties_AutoScalerProfile() to populate field AutoScalerProfile")
		}
		destination.AutoScalerProfile = &autoScalerProfile
	} else {
		destination.AutoScalerProfile = nil
	}

	// AutoUpgradeProfile
	if cluster.AutoUpgradeProfile != nil {
		var autoUpgradeProfile storage.ManagedClusterAutoUpgradeProfile
		err := cluster.AutoUpgradeProfile.AssignProperties_To_ManagedClusterAutoUpgradeProfile(&autoUpgradeProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterAutoUpgradeProfile() to populate field AutoUpgradeProfile")
		}
		destination.AutoUpgradeProfile = &autoUpgradeProfile
	} else {
		destination.AutoUpgradeProfile = nil
	}

	// AzureName
	destination.AzureName = cluster.AzureName

	// DisableLocalAccounts
	if cluster.DisableLocalAccounts != nil {
		disableLocalAccount := *cluster.DisableLocalAccounts
		destination.DisableLocalAccounts = &disableLocalAccount
	} else {
		destination.DisableLocalAccounts = nil
	}

	// DiskEncryptionSetIDReference
	if cluster.DiskEncryptionSetIDReference != nil {
		diskEncryptionSetIDReference := cluster.DiskEncryptionSetIDReference.Copy()
		destination.DiskEncryptionSetIDReference = &diskEncryptionSetIDReference
	} else {
		destination.DiskEncryptionSetIDReference = nil
	}

	// DnsPrefix
	destination.DnsPrefix = genruntime.ClonePointerToString(cluster.DnsPrefix)

	// EnablePodSecurityPolicy
	if cluster.EnablePodSecurityPolicy != nil {
		enablePodSecurityPolicy := *cluster.EnablePodSecurityPolicy
		destination.EnablePodSecurityPolicy = &enablePodSecurityPolicy
	} else {
		destination.EnablePodSecurityPolicy = nil
	}

	// EnableRBAC
	if cluster.EnableRBAC != nil {
		enableRBAC := *cluster.EnableRBAC
		destination.EnableRBAC = &enableRBAC
	} else {
		destination.EnableRBAC = nil
	}

	// ExtendedLocation
	if cluster.ExtendedLocation != nil {
		var extendedLocation storage.ExtendedLocation
		err := cluster.ExtendedLocation.AssignProperties_To_ExtendedLocation(&extendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ExtendedLocation() to populate field ExtendedLocation")
		}
		destination.ExtendedLocation = &extendedLocation
	} else {
		destination.ExtendedLocation = nil
	}

	// FqdnSubdomain
	destination.FqdnSubdomain = genruntime.ClonePointerToString(cluster.FqdnSubdomain)

	// HttpProxyConfig
	if cluster.HttpProxyConfig != nil {
		var httpProxyConfig storage.ManagedClusterHTTPProxyConfig
		err := cluster.HttpProxyConfig.AssignProperties_To_ManagedClusterHTTPProxyConfig(&httpProxyConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterHTTPProxyConfig() to populate field HttpProxyConfig")
		}
		destination.HttpProxyConfig = &httpProxyConfig
	} else {
		destination.HttpProxyConfig = nil
	}

	// Identity
	if cluster.Identity != nil {
		var identity storage.ManagedClusterIdentity
		err := cluster.Identity.AssignProperties_To_ManagedClusterIdentity(&identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterIdentity() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// IdentityProfile
	if cluster.IdentityProfile != nil {
		identityProfileMap := make(map[string]storage.UserAssignedIdentity, len(cluster.IdentityProfile))
		for identityProfileKey, identityProfileValue := range cluster.IdentityProfile {
			// Shadow the loop variable to avoid aliasing
			identityProfileValue := identityProfileValue
			var identityProfile storage.UserAssignedIdentity
			err := identityProfileValue.AssignProperties_To_UserAssignedIdentity(&identityProfile)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_UserAssignedIdentity() to populate field IdentityProfile")
			}
			identityProfileMap[identityProfileKey] = identityProfile
		}
		destination.IdentityProfile = identityProfileMap
	} else {
		destination.IdentityProfile = nil
	}

	// KubernetesVersion
	destination.KubernetesVersion = genruntime.ClonePointerToString(cluster.KubernetesVersion)

	// LinuxProfile
	if cluster.LinuxProfile != nil {
		var linuxProfile storage.ContainerServiceLinuxProfile
		err := cluster.LinuxProfile.AssignProperties_To_ContainerServiceLinuxProfile(&linuxProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ContainerServiceLinuxProfile() to populate field LinuxProfile")
		}
		destination.LinuxProfile = &linuxProfile
	} else {
		destination.LinuxProfile = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(cluster.Location)

	// NetworkProfile
	if cluster.NetworkProfile != nil {
		var networkProfile storage.ContainerServiceNetworkProfile
		err := cluster.NetworkProfile.AssignProperties_To_ContainerServiceNetworkProfile(&networkProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ContainerServiceNetworkProfile() to populate field NetworkProfile")
		}
		destination.NetworkProfile = &networkProfile
	} else {
		destination.NetworkProfile = nil
	}

	// NodeResourceGroup
	destination.NodeResourceGroup = genruntime.ClonePointerToString(cluster.NodeResourceGroup)

	// OperatorSpec
	if cluster.OperatorSpec != nil {
		var operatorSpec storage.ManagedClusterOperatorSpec
		err := cluster.OperatorSpec.AssignProperties_To_ManagedClusterOperatorSpec(&operatorSpec)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterOperatorSpec() to populate field OperatorSpec")
		}
		destination.OperatorSpec = &operatorSpec
	} else {
		destination.OperatorSpec = nil
	}

	// OriginalVersion
	destination.OriginalVersion = cluster.OriginalVersion()

	// Owner
	if cluster.Owner != nil {
		owner := cluster.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// PodIdentityProfile
	if cluster.PodIdentityProfile != nil {
		var podIdentityProfile storage.ManagedClusterPodIdentityProfile
		err := cluster.PodIdentityProfile.AssignProperties_To_ManagedClusterPodIdentityProfile(&podIdentityProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterPodIdentityProfile() to populate field PodIdentityProfile")
		}
		destination.PodIdentityProfile = &podIdentityProfile
	} else {
		destination.PodIdentityProfile = nil
	}

	// PrivateLinkResources
	if cluster.PrivateLinkResources != nil {
		privateLinkResourceList := make([]storage.PrivateLinkResource, len(cluster.PrivateLinkResources))
		for privateLinkResourceIndex, privateLinkResourceItem := range cluster.PrivateLinkResources {
			// Shadow the loop variable to avoid aliasing
			privateLinkResourceItem := privateLinkResourceItem
			var privateLinkResource storage.PrivateLinkResource
			err := privateLinkResourceItem.AssignProperties_To_PrivateLinkResource(&privateLinkResource)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_PrivateLinkResource() to populate field PrivateLinkResources")
			}
			privateLinkResourceList[privateLinkResourceIndex] = privateLinkResource
		}
		destination.PrivateLinkResources = privateLinkResourceList
	} else {
		destination.PrivateLinkResources = nil
	}

	// ServicePrincipalProfile
	if cluster.ServicePrincipalProfile != nil {
		var servicePrincipalProfile storage.ManagedClusterServicePrincipalProfile
		err := cluster.ServicePrincipalProfile.AssignProperties_To_ManagedClusterServicePrincipalProfile(&servicePrincipalProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterServicePrincipalProfile() to populate field ServicePrincipalProfile")
		}
		destination.ServicePrincipalProfile = &servicePrincipalProfile
	} else {
		destination.ServicePrincipalProfile = nil
	}

	// Sku
	if cluster.Sku != nil {
		var sku storage.ManagedClusterSKU
		err := cluster.Sku.AssignProperties_To_ManagedClusterSKU(&sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterSKU() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(cluster.Tags)

	// WindowsProfile
	if cluster.WindowsProfile != nil {
		var windowsProfile storage.ManagedClusterWindowsProfile
		err := cluster.WindowsProfile.AssignProperties_To_ManagedClusterWindowsProfile(&windowsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterWindowsProfile() to populate field WindowsProfile")
		}
		destination.WindowsProfile = &windowsProfile
	} else {
		destination.WindowsProfile = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (cluster *ManagedCluster_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (cluster *ManagedCluster_Spec) SetAzureName(azureName string) { cluster.AzureName = azureName }

type ManagedCluster_STATUS struct {
	AadProfile             *ManagedClusterAADProfile_STATUS                   `json:"aadProfile,omitempty"`
	AddonProfiles          map[string]ManagedClusterAddonProfile_STATUS       `json:"addonProfiles,omitempty"`
	AgentPoolProfiles      []ManagedClusterAgentPoolProfile_STATUS            `json:"agentPoolProfiles,omitempty"`
	ApiServerAccessProfile *ManagedClusterAPIServerAccessProfile_STATUS       `json:"apiServerAccessProfile,omitempty"`
	AutoScalerProfile      *ManagedClusterProperties_AutoScalerProfile_STATUS `json:"autoScalerProfile,omitempty"`
	AutoUpgradeProfile     *ManagedClusterAutoUpgradeProfile_STATUS           `json:"autoUpgradeProfile,omitempty"`
	AzurePortalFQDN        *string                                            `json:"azurePortalFQDN,omitempty"`

	// Conditions: The observed state of the resource
	Conditions              []conditions.Condition                        `json:"conditions,omitempty"`
	DisableLocalAccounts    *bool                                         `json:"disableLocalAccounts,omitempty"`
	DiskEncryptionSetID     *string                                       `json:"diskEncryptionSetID,omitempty"`
	DnsPrefix               *string                                       `json:"dnsPrefix,omitempty"`
	EnablePodSecurityPolicy *bool                                         `json:"enablePodSecurityPolicy,omitempty"`
	EnableRBAC              *bool                                         `json:"enableRBAC,omitempty"`
	ExtendedLocation        *ExtendedLocation_STATUS                      `json:"extendedLocation,omitempty"`
	Fqdn                    *string                                       `json:"fqdn,omitempty"`
	FqdnSubdomain           *string                                       `json:"fqdnSubdomain,omitempty"`
	HttpProxyConfig         *ManagedClusterHTTPProxyConfig_STATUS         `json:"httpProxyConfig,omitempty"`
	Id                      *string                                       `json:"id,omitempty"`
	Identity                *ManagedClusterIdentity_STATUS                `json:"identity,omitempty"`
	IdentityProfile         map[string]UserAssignedIdentity_STATUS        `json:"identityProfile,omitempty"`
	KubernetesVersion       *string                                       `json:"kubernetesVersion,omitempty"`
	LinuxProfile            *ContainerServiceLinuxProfile_STATUS          `json:"linuxProfile,omitempty"`
	Location                *string                                       `json:"location,omitempty"`
	MaxAgentPools           *int                                          `json:"maxAgentPools,omitempty"`
	Name                    *string                                       `json:"name,omitempty"`
	NetworkProfile          *ContainerServiceNetworkProfile_STATUS        `json:"networkProfile,omitempty"`
	NodeResourceGroup       *string                                       `json:"nodeResourceGroup,omitempty"`
	PodIdentityProfile      *ManagedClusterPodIdentityProfile_STATUS      `json:"podIdentityProfile,omitempty"`
	PowerState              *PowerState_STATUS                            `json:"powerState,omitempty"`
	PrivateFQDN             *string                                       `json:"privateFQDN,omitempty"`
	PrivateLinkResources    []PrivateLinkResource_STATUS                  `json:"privateLinkResources,omitempty"`
	ProvisioningState       *string                                       `json:"provisioningState,omitempty"`
	ServicePrincipalProfile *ManagedClusterServicePrincipalProfile_STATUS `json:"servicePrincipalProfile,omitempty"`
	Sku                     *ManagedClusterSKU_STATUS                     `json:"sku,omitempty"`
	Tags                    map[string]string                             `json:"tags,omitempty"`
	Type                    *string                                       `json:"type,omitempty"`
	WindowsProfile          *ManagedClusterWindowsProfile_STATUS          `json:"windowsProfile,omitempty"`
}

var _ genruntime.ConvertibleStatus = &ManagedCluster_STATUS{}

// ConvertStatusFrom populates our ManagedCluster_STATUS from the provided source
func (cluster *ManagedCluster_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*storage.ManagedCluster_STATUS)
	if ok {
		// Populate our instance from source
		return cluster.AssignProperties_From_ManagedCluster_STATUS(src)
	}

	// Convert to an intermediate form
	src = &storage.ManagedCluster_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = cluster.AssignProperties_From_ManagedCluster_STATUS(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our ManagedCluster_STATUS
func (cluster *ManagedCluster_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*storage.ManagedCluster_STATUS)
	if ok {
		// Populate destination from our instance
		return cluster.AssignProperties_To_ManagedCluster_STATUS(dst)
	}

	// Convert to an intermediate form
	dst = &storage.ManagedCluster_STATUS{}
	err := cluster.AssignProperties_To_ManagedCluster_STATUS(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &ManagedCluster_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (cluster *ManagedCluster_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedCluster_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (cluster *ManagedCluster_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedCluster_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedCluster_STATUS, got %T", armInput)
	}

	// Set property "AadProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AadProfile != nil {
			var aadProfile1 ManagedClusterAADProfile_STATUS
			err := aadProfile1.PopulateFromARM(owner, *typedInput.Properties.AadProfile)
			if err != nil {
				return err
			}
			aadProfile := aadProfile1
			cluster.AadProfile = &aadProfile
		}
	}

	// Set property "AddonProfiles":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AddonProfiles != nil {
			cluster.AddonProfiles = make(map[string]ManagedClusterAddonProfile_STATUS, len(typedInput.Properties.AddonProfiles))
			for key, value := range typedInput.Properties.AddonProfiles {
				var value1 ManagedClusterAddonProfile_STATUS
				err := value1.PopulateFromARM(owner, value)
				if err != nil {
					return err
				}
				cluster.AddonProfiles[key] = value1
			}
		}
	}

	// Set property "AgentPoolProfiles":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.AgentPoolProfiles {
			var item1 ManagedClusterAgentPoolProfile_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			cluster.AgentPoolProfiles = append(cluster.AgentPoolProfiles, item1)
		}
	}

	// Set property "ApiServerAccessProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ApiServerAccessProfile != nil {
			var apiServerAccessProfile1 ManagedClusterAPIServerAccessProfile_STATUS
			err := apiServerAccessProfile1.PopulateFromARM(owner, *typedInput.Properties.ApiServerAccessProfile)
			if err != nil {
				return err
			}
			apiServerAccessProfile := apiServerAccessProfile1
			cluster.ApiServerAccessProfile = &apiServerAccessProfile
		}
	}

	// Set property "AutoScalerProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AutoScalerProfile != nil {
			var autoScalerProfile1 ManagedClusterProperties_AutoScalerProfile_STATUS
			err := autoScalerProfile1.PopulateFromARM(owner, *typedInput.Properties.AutoScalerProfile)
			if err != nil {
				return err
			}
			autoScalerProfile := autoScalerProfile1
			cluster.AutoScalerProfile = &autoScalerProfile
		}
	}

	// Set property "AutoUpgradeProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AutoUpgradeProfile != nil {
			var autoUpgradeProfile1 ManagedClusterAutoUpgradeProfile_STATUS
			err := autoUpgradeProfile1.PopulateFromARM(owner, *typedInput.Properties.AutoUpgradeProfile)
			if err != nil {
				return err
			}
			autoUpgradeProfile := autoUpgradeProfile1
			cluster.AutoUpgradeProfile = &autoUpgradeProfile
		}
	}

	// Set property "AzurePortalFQDN":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AzurePortalFQDN != nil {
			azurePortalFQDN := *typedInput.Properties.AzurePortalFQDN
			cluster.AzurePortalFQDN = &azurePortalFQDN
		}
	}

	// no assignment for property "Conditions"

	// Set property "DisableLocalAccounts":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DisableLocalAccounts != nil {
			disableLocalAccounts := *typedInput.Properties.DisableLocalAccounts
			cluster.DisableLocalAccounts = &disableLocalAccounts
		}
	}

	// Set property "DiskEncryptionSetID":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DiskEncryptionSetID != nil {
			diskEncryptionSetID := *typedInput.Properties.DiskEncryptionSetID
			cluster.DiskEncryptionSetID = &diskEncryptionSetID
		}
	}

	// Set property "DnsPrefix":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DnsPrefix != nil {
			dnsPrefix := *typedInput.Properties.DnsPrefix
			cluster.DnsPrefix = &dnsPrefix
		}
	}

	// Set property "EnablePodSecurityPolicy":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnablePodSecurityPolicy != nil {
			enablePodSecurityPolicy := *typedInput.Properties.EnablePodSecurityPolicy
			cluster.EnablePodSecurityPolicy = &enablePodSecurityPolicy
		}
	}

	// Set property "EnableRBAC":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableRBAC != nil {
			enableRBAC := *typedInput.Properties.EnableRBAC
			cluster.EnableRBAC = &enableRBAC
		}
	}

	// Set property "ExtendedLocation":
	if typedInput.ExtendedLocation != nil {
		var extendedLocation1 ExtendedLocation_STATUS
		err := extendedLocation1.PopulateFromARM(owner, *typedInput.ExtendedLocation)
		if err != nil {
			return err
		}
		extendedLocation := extendedLocation1
		cluster.ExtendedLocation = &extendedLocation
	}

	// Set property "Fqdn":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Fqdn != nil {
			fqdn := *typedInput.Properties.Fqdn
			cluster.Fqdn = &fqdn
		}
	}

	// Set property "FqdnSubdomain":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.FqdnSubdomain != nil {
			fqdnSubdomain := *typedInput.Properties.FqdnSubdomain
			cluster.FqdnSubdomain = &fqdnSubdomain
		}
	}

	// Set property "HttpProxyConfig":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HttpProxyConfig != nil {
			var httpProxyConfig1 ManagedClusterHTTPProxyConfig_STATUS
			err := httpProxyConfig1.PopulateFromARM(owner, *typedInput.Properties.HttpProxyConfig)
			if err != nil {
				return err
			}
			httpProxyConfig := httpProxyConfig1
			cluster.HttpProxyConfig = &httpProxyConfig
		}
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		cluster.Id = &id
	}

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 ManagedClusterIdentity_STATUS
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		cluster.Identity = &identity
	}

	// Set property "IdentityProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IdentityProfile != nil {
			cluster.IdentityProfile = make(map[string]UserAssignedIdentity_STATUS, len(typedInput.Properties.IdentityProfile))
			for key, value := range typedInput.Properties.IdentityProfile {
				var value1 UserAssignedIdentity_STATUS
				err := value1.PopulateFromARM(owner, value)
				if err != nil {
					return err
				}
				cluster.IdentityProfile[key] = value1
			}
		}
	}

	// Set property "KubernetesVersion":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.KubernetesVersion != nil {
			kubernetesVersion := *typedInput.Properties.KubernetesVersion
			cluster.KubernetesVersion = &kubernetesVersion
		}
	}

	// Set property "LinuxProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.LinuxProfile != nil {
			var linuxProfile1 ContainerServiceLinuxProfile_STATUS
			err := linuxProfile1.PopulateFromARM(owner, *typedInput.Properties.LinuxProfile)
			if err != nil {
				return err
			}
			linuxProfile := linuxProfile1
			cluster.LinuxProfile = &linuxProfile
		}
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		cluster.Location = &location
	}

	// Set property "MaxAgentPools":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MaxAgentPools != nil {
			maxAgentPools := *typedInput.Properties.MaxAgentPools
			cluster.MaxAgentPools = &maxAgentPools
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		cluster.Name = &name
	}

	// Set property "NetworkProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.NetworkProfile != nil {
			var networkProfile1 ContainerServiceNetworkProfile_STATUS
			err := networkProfile1.PopulateFromARM(owner, *typedInput.Properties.NetworkProfile)
			if err != nil {
				return err
			}
			networkProfile := networkProfile1
			cluster.NetworkProfile = &networkProfile
		}
	}

	// Set property "NodeResourceGroup":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.NodeResourceGroup != nil {
			nodeResourceGroup := *typedInput.Properties.NodeResourceGroup
			cluster.NodeResourceGroup = &nodeResourceGroup
		}
	}

	// Set property "PodIdentityProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PodIdentityProfile != nil {
			var podIdentityProfile1 ManagedClusterPodIdentityProfile_STATUS
			err := podIdentityProfile1.PopulateFromARM(owner, *typedInput.Properties.PodIdentityProfile)
			if err != nil {
				return err
			}
			podIdentityProfile := podIdentityProfile1
			cluster.PodIdentityProfile = &podIdentityProfile
		}
	}

	// Set property "PowerState":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PowerState != nil {
			var powerState1 PowerState_STATUS
			err := powerState1.PopulateFromARM(owner, *typedInput.Properties.PowerState)
			if err != nil {
				return err
			}
			powerState := powerState1
			cluster.PowerState = &powerState
		}
	}

	// Set property "PrivateFQDN":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateFQDN != nil {
			privateFQDN := *typedInput.Properties.PrivateFQDN
			cluster.PrivateFQDN = &privateFQDN
		}
	}

	// Set property "PrivateLinkResources":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.PrivateLinkResources {
			var item1 PrivateLinkResource_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			cluster.PrivateLinkResources = append(cluster.PrivateLinkResources, item1)
		}
	}

	// Set property "ProvisioningState":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			provisioningState := *typedInput.Properties.ProvisioningState
			cluster.ProvisioningState = &provisioningState
		}
	}

	// Set property "ServicePrincipalProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ServicePrincipalProfile != nil {
			var servicePrincipalProfile1 ManagedClusterServicePrincipalProfile_STATUS
			err := servicePrincipalProfile1.PopulateFromARM(owner, *typedInput.Properties.ServicePrincipalProfile)
			if err != nil {
				return err
			}
			servicePrincipalProfile := servicePrincipalProfile1
			cluster.ServicePrincipalProfile = &servicePrincipalProfile
		}
	}

	// Set property "Sku":
	if typedInput.Sku != nil {
		var sku1 ManagedClusterSKU_STATUS
		err := sku1.PopulateFromARM(owner, *typedInput.Sku)
		if err != nil {
			return err
		}
		sku := sku1
		cluster.Sku = &sku
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		cluster.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			cluster.Tags[key] = value
		}
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		cluster.Type = &typeVar
	}

	// Set property "WindowsProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.WindowsProfile != nil {
			var windowsProfile1 ManagedClusterWindowsProfile_STATUS
			err := windowsProfile1.PopulateFromARM(owner, *typedInput.Properties.WindowsProfile)
			if err != nil {
				return err
			}
			windowsProfile := windowsProfile1
			cluster.WindowsProfile = &windowsProfile
		}
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedCluster_STATUS populates our ManagedCluster_STATUS from the provided source ManagedCluster_STATUS
func (cluster *ManagedCluster_STATUS) AssignProperties_From_ManagedCluster_STATUS(source *storage.ManagedCluster_STATUS) error {

	// AadProfile
	if source.AadProfile != nil {
		var aadProfile ManagedClusterAADProfile_STATUS
		err := aadProfile.AssignProperties_From_ManagedClusterAADProfile_STATUS(source.AadProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterAADProfile_STATUS() to populate field AadProfile")
		}
		cluster.AadProfile = &aadProfile
	} else {
		cluster.AadProfile = nil
	}

	// AddonProfiles
	if source.AddonProfiles != nil {
		addonProfileMap := make(map[string]ManagedClusterAddonProfile_STATUS, len(source.AddonProfiles))
		for addonProfileKey, addonProfileValue := range source.AddonProfiles {
			// Shadow the loop variable to avoid aliasing
			addonProfileValue := addonProfileValue
			var addonProfile ManagedClusterAddonProfile_STATUS
			err := addonProfile.AssignProperties_From_ManagedClusterAddonProfile_STATUS(&addonProfileValue)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterAddonProfile_STATUS() to populate field AddonProfiles")
			}
			addonProfileMap[addonProfileKey] = addonProfile
		}
		cluster.AddonProfiles = addonProfileMap
	} else {
		cluster.AddonProfiles = nil
	}

	// AgentPoolProfiles
	if source.AgentPoolProfiles != nil {
		agentPoolProfileList := make([]ManagedClusterAgentPoolProfile_STATUS, len(source.AgentPoolProfiles))
		for agentPoolProfileIndex, agentPoolProfileItem := range source.AgentPoolProfiles {
			// Shadow the loop variable to avoid aliasing
			agentPoolProfileItem := agentPoolProfileItem
			var agentPoolProfile ManagedClusterAgentPoolProfile_STATUS
			err := agentPoolProfile.AssignProperties_From_ManagedClusterAgentPoolProfile_STATUS(&agentPoolProfileItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterAgentPoolProfile_STATUS() to populate field AgentPoolProfiles")
			}
			agentPoolProfileList[agentPoolProfileIndex] = agentPoolProfile
		}
		cluster.AgentPoolProfiles = agentPoolProfileList
	} else {
		cluster.AgentPoolProfiles = nil
	}

	// ApiServerAccessProfile
	if source.ApiServerAccessProfile != nil {
		var apiServerAccessProfile ManagedClusterAPIServerAccessProfile_STATUS
		err := apiServerAccessProfile.AssignProperties_From_ManagedClusterAPIServerAccessProfile_STATUS(source.ApiServerAccessProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterAPIServerAccessProfile_STATUS() to populate field ApiServerAccessProfile")
		}
		cluster.ApiServerAccessProfile = &apiServerAccessProfile
	} else {
		cluster.ApiServerAccessProfile = nil
	}

	// AutoScalerProfile
	if source.AutoScalerProfile != nil {
		var autoScalerProfile ManagedClusterProperties_AutoScalerProfile_STATUS
		err := autoScalerProfile.AssignProperties_From_ManagedClusterProperties_AutoScalerProfile_STATUS(source.AutoScalerProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterProperties_AutoScalerProfile_STATUS() to populate field AutoScalerProfile")
		}
		cluster.AutoScalerProfile = &autoScalerProfile
	} else {
		cluster.AutoScalerProfile = nil
	}

	// AutoUpgradeProfile
	if source.AutoUpgradeProfile != nil {
		var autoUpgradeProfile ManagedClusterAutoUpgradeProfile_STATUS
		err := autoUpgradeProfile.AssignProperties_From_ManagedClusterAutoUpgradeProfile_STATUS(source.AutoUpgradeProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterAutoUpgradeProfile_STATUS() to populate field AutoUpgradeProfile")
		}
		cluster.AutoUpgradeProfile = &autoUpgradeProfile
	} else {
		cluster.AutoUpgradeProfile = nil
	}

	// AzurePortalFQDN
	cluster.AzurePortalFQDN = genruntime.ClonePointerToString(source.AzurePortalFQDN)

	// Conditions
	cluster.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// DisableLocalAccounts
	if source.DisableLocalAccounts != nil {
		disableLocalAccount := *source.DisableLocalAccounts
		cluster.DisableLocalAccounts = &disableLocalAccount
	} else {
		cluster.DisableLocalAccounts = nil
	}

	// DiskEncryptionSetID
	cluster.DiskEncryptionSetID = genruntime.ClonePointerToString(source.DiskEncryptionSetID)

	// DnsPrefix
	cluster.DnsPrefix = genruntime.ClonePointerToString(source.DnsPrefix)

	// EnablePodSecurityPolicy
	if source.EnablePodSecurityPolicy != nil {
		enablePodSecurityPolicy := *source.EnablePodSecurityPolicy
		cluster.EnablePodSecurityPolicy = &enablePodSecurityPolicy
	} else {
		cluster.EnablePodSecurityPolicy = nil
	}

	// EnableRBAC
	if source.EnableRBAC != nil {
		enableRBAC := *source.EnableRBAC
		cluster.EnableRBAC = &enableRBAC
	} else {
		cluster.EnableRBAC = nil
	}

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocation ExtendedLocation_STATUS
		err := extendedLocation.AssignProperties_From_ExtendedLocation_STATUS(source.ExtendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ExtendedLocation_STATUS() to populate field ExtendedLocation")
		}
		cluster.ExtendedLocation = &extendedLocation
	} else {
		cluster.ExtendedLocation = nil
	}

	// Fqdn
	cluster.Fqdn = genruntime.ClonePointerToString(source.Fqdn)

	// FqdnSubdomain
	cluster.FqdnSubdomain = genruntime.ClonePointerToString(source.FqdnSubdomain)

	// HttpProxyConfig
	if source.HttpProxyConfig != nil {
		var httpProxyConfig ManagedClusterHTTPProxyConfig_STATUS
		err := httpProxyConfig.AssignProperties_From_ManagedClusterHTTPProxyConfig_STATUS(source.HttpProxyConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterHTTPProxyConfig_STATUS() to populate field HttpProxyConfig")
		}
		cluster.HttpProxyConfig = &httpProxyConfig
	} else {
		cluster.HttpProxyConfig = nil
	}

	// Id
	cluster.Id = genruntime.ClonePointerToString(source.Id)

	// Identity
	if source.Identity != nil {
		var identity ManagedClusterIdentity_STATUS
		err := identity.AssignProperties_From_ManagedClusterIdentity_STATUS(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterIdentity_STATUS() to populate field Identity")
		}
		cluster.Identity = &identity
	} else {
		cluster.Identity = nil
	}

	// IdentityProfile
	if source.IdentityProfile != nil {
		identityProfileMap := make(map[string]UserAssignedIdentity_STATUS, len(source.IdentityProfile))
		for identityProfileKey, identityProfileValue := range source.IdentityProfile {
			// Shadow the loop variable to avoid aliasing
			identityProfileValue := identityProfileValue
			var identityProfile UserAssignedIdentity_STATUS
			err := identityProfile.AssignProperties_From_UserAssignedIdentity_STATUS(&identityProfileValue)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_UserAssignedIdentity_STATUS() to populate field IdentityProfile")
			}
			identityProfileMap[identityProfileKey] = identityProfile
		}
		cluster.IdentityProfile = identityProfileMap
	} else {
		cluster.IdentityProfile = nil
	}

	// KubernetesVersion
	cluster.KubernetesVersion = genruntime.ClonePointerToString(source.KubernetesVersion)

	// LinuxProfile
	if source.LinuxProfile != nil {
		var linuxProfile ContainerServiceLinuxProfile_STATUS
		err := linuxProfile.AssignProperties_From_ContainerServiceLinuxProfile_STATUS(source.LinuxProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ContainerServiceLinuxProfile_STATUS() to populate field LinuxProfile")
		}
		cluster.LinuxProfile = &linuxProfile
	} else {
		cluster.LinuxProfile = nil
	}

	// Location
	cluster.Location = genruntime.ClonePointerToString(source.Location)

	// MaxAgentPools
	cluster.MaxAgentPools = genruntime.ClonePointerToInt(source.MaxAgentPools)

	// Name
	cluster.Name = genruntime.ClonePointerToString(source.Name)

	// NetworkProfile
	if source.NetworkProfile != nil {
		var networkProfile ContainerServiceNetworkProfile_STATUS
		err := networkProfile.AssignProperties_From_ContainerServiceNetworkProfile_STATUS(source.NetworkProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ContainerServiceNetworkProfile_STATUS() to populate field NetworkProfile")
		}
		cluster.NetworkProfile = &networkProfile
	} else {
		cluster.NetworkProfile = nil
	}

	// NodeResourceGroup
	cluster.NodeResourceGroup = genruntime.ClonePointerToString(source.NodeResourceGroup)

	// PodIdentityProfile
	if source.PodIdentityProfile != nil {
		var podIdentityProfile ManagedClusterPodIdentityProfile_STATUS
		err := podIdentityProfile.AssignProperties_From_ManagedClusterPodIdentityProfile_STATUS(source.PodIdentityProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterPodIdentityProfile_STATUS() to populate field PodIdentityProfile")
		}
		cluster.PodIdentityProfile = &podIdentityProfile
	} else {
		cluster.PodIdentityProfile = nil
	}

	// PowerState
	if source.PowerState != nil {
		var powerState PowerState_STATUS
		err := powerState.AssignProperties_From_PowerState_STATUS(source.PowerState)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_PowerState_STATUS() to populate field PowerState")
		}
		cluster.PowerState = &powerState
	} else {
		cluster.PowerState = nil
	}

	// PrivateFQDN
	cluster.PrivateFQDN = genruntime.ClonePointerToString(source.PrivateFQDN)

	// PrivateLinkResources
	if source.PrivateLinkResources != nil {
		privateLinkResourceList := make([]PrivateLinkResource_STATUS, len(source.PrivateLinkResources))
		for privateLinkResourceIndex, privateLinkResourceItem := range source.PrivateLinkResources {
			// Shadow the loop variable to avoid aliasing
			privateLinkResourceItem := privateLinkResourceItem
			var privateLinkResource PrivateLinkResource_STATUS
			err := privateLinkResource.AssignProperties_From_PrivateLinkResource_STATUS(&privateLinkResourceItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_PrivateLinkResource_STATUS() to populate field PrivateLinkResources")
			}
			privateLinkResourceList[privateLinkResourceIndex] = privateLinkResource
		}
		cluster.PrivateLinkResources = privateLinkResourceList
	} else {
		cluster.PrivateLinkResources = nil
	}

	// ProvisioningState
	cluster.ProvisioningState = genruntime.ClonePointerToString(source.ProvisioningState)

	// ServicePrincipalProfile
	if source.ServicePrincipalProfile != nil {
		var servicePrincipalProfile ManagedClusterServicePrincipalProfile_STATUS
		err := servicePrincipalProfile.AssignProperties_From_ManagedClusterServicePrincipalProfile_STATUS(source.ServicePrincipalProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterServicePrincipalProfile_STATUS() to populate field ServicePrincipalProfile")
		}
		cluster.ServicePrincipalProfile = &servicePrincipalProfile
	} else {
		cluster.ServicePrincipalProfile = nil
	}

	// Sku
	if source.Sku != nil {
		var sku ManagedClusterSKU_STATUS
		err := sku.AssignProperties_From_ManagedClusterSKU_STATUS(source.Sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterSKU_STATUS() to populate field Sku")
		}
		cluster.Sku = &sku
	} else {
		cluster.Sku = nil
	}

	// Tags
	cluster.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Type
	cluster.Type = genruntime.ClonePointerToString(source.Type)

	// WindowsProfile
	if source.WindowsProfile != nil {
		var windowsProfile ManagedClusterWindowsProfile_STATUS
		err := windowsProfile.AssignProperties_From_ManagedClusterWindowsProfile_STATUS(source.WindowsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterWindowsProfile_STATUS() to populate field WindowsProfile")
		}
		cluster.WindowsProfile = &windowsProfile
	} else {
		cluster.WindowsProfile = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedCluster_STATUS populates the provided destination ManagedCluster_STATUS from our ManagedCluster_STATUS
func (cluster *ManagedCluster_STATUS) AssignProperties_To_ManagedCluster_STATUS(destination *storage.ManagedCluster_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AadProfile
	if cluster.AadProfile != nil {
		var aadProfile storage.ManagedClusterAADProfile_STATUS
		err := cluster.AadProfile.AssignProperties_To_ManagedClusterAADProfile_STATUS(&aadProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterAADProfile_STATUS() to populate field AadProfile")
		}
		destination.AadProfile = &aadProfile
	} else {
		destination.AadProfile = nil
	}

	// AddonProfiles
	if cluster.AddonProfiles != nil {
		addonProfileMap := make(map[string]storage.ManagedClusterAddonProfile_STATUS, len(cluster.AddonProfiles))
		for addonProfileKey, addonProfileValue := range cluster.AddonProfiles {
			// Shadow the loop variable to avoid aliasing
			addonProfileValue := addonProfileValue
			var addonProfile storage.ManagedClusterAddonProfile_STATUS
			err := addonProfileValue.AssignProperties_To_ManagedClusterAddonProfile_STATUS(&addonProfile)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterAddonProfile_STATUS() to populate field AddonProfiles")
			}
			addonProfileMap[addonProfileKey] = addonProfile
		}
		destination.AddonProfiles = addonProfileMap
	} else {
		destination.AddonProfiles = nil
	}

	// AgentPoolProfiles
	if cluster.AgentPoolProfiles != nil {
		agentPoolProfileList := make([]storage.ManagedClusterAgentPoolProfile_STATUS, len(cluster.AgentPoolProfiles))
		for agentPoolProfileIndex, agentPoolProfileItem := range cluster.AgentPoolProfiles {
			// Shadow the loop variable to avoid aliasing
			agentPoolProfileItem := agentPoolProfileItem
			var agentPoolProfile storage.ManagedClusterAgentPoolProfile_STATUS
			err := agentPoolProfileItem.AssignProperties_To_ManagedClusterAgentPoolProfile_STATUS(&agentPoolProfile)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterAgentPoolProfile_STATUS() to populate field AgentPoolProfiles")
			}
			agentPoolProfileList[agentPoolProfileIndex] = agentPoolProfile
		}
		destination.AgentPoolProfiles = agentPoolProfileList
	} else {
		destination.AgentPoolProfiles = nil
	}

	// ApiServerAccessProfile
	if cluster.ApiServerAccessProfile != nil {
		var apiServerAccessProfile storage.ManagedClusterAPIServerAccessProfile_STATUS
		err := cluster.ApiServerAccessProfile.AssignProperties_To_ManagedClusterAPIServerAccessProfile_STATUS(&apiServerAccessProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterAPIServerAccessProfile_STATUS() to populate field ApiServerAccessProfile")
		}
		destination.ApiServerAccessProfile = &apiServerAccessProfile
	} else {
		destination.ApiServerAccessProfile = nil
	}

	// AutoScalerProfile
	if cluster.AutoScalerProfile != nil {
		var autoScalerProfile storage.ManagedClusterProperties_AutoScalerProfile_STATUS
		err := cluster.AutoScalerProfile.AssignProperties_To_ManagedClusterProperties_AutoScalerProfile_STATUS(&autoScalerProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterProperties_AutoScalerProfile_STATUS() to populate field AutoScalerProfile")
		}
		destination.AutoScalerProfile = &autoScalerProfile
	} else {
		destination.AutoScalerProfile = nil
	}

	// AutoUpgradeProfile
	if cluster.AutoUpgradeProfile != nil {
		var autoUpgradeProfile storage.ManagedClusterAutoUpgradeProfile_STATUS
		err := cluster.AutoUpgradeProfile.AssignProperties_To_ManagedClusterAutoUpgradeProfile_STATUS(&autoUpgradeProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterAutoUpgradeProfile_STATUS() to populate field AutoUpgradeProfile")
		}
		destination.AutoUpgradeProfile = &autoUpgradeProfile
	} else {
		destination.AutoUpgradeProfile = nil
	}

	// AzurePortalFQDN
	destination.AzurePortalFQDN = genruntime.ClonePointerToString(cluster.AzurePortalFQDN)

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(cluster.Conditions)

	// DisableLocalAccounts
	if cluster.DisableLocalAccounts != nil {
		disableLocalAccount := *cluster.DisableLocalAccounts
		destination.DisableLocalAccounts = &disableLocalAccount
	} else {
		destination.DisableLocalAccounts = nil
	}

	// DiskEncryptionSetID
	destination.DiskEncryptionSetID = genruntime.ClonePointerToString(cluster.DiskEncryptionSetID)

	// DnsPrefix
	destination.DnsPrefix = genruntime.ClonePointerToString(cluster.DnsPrefix)

	// EnablePodSecurityPolicy
	if cluster.EnablePodSecurityPolicy != nil {
		enablePodSecurityPolicy := *cluster.EnablePodSecurityPolicy
		destination.EnablePodSecurityPolicy = &enablePodSecurityPolicy
	} else {
		destination.EnablePodSecurityPolicy = nil
	}

	// EnableRBAC
	if cluster.EnableRBAC != nil {
		enableRBAC := *cluster.EnableRBAC
		destination.EnableRBAC = &enableRBAC
	} else {
		destination.EnableRBAC = nil
	}

	// ExtendedLocation
	if cluster.ExtendedLocation != nil {
		var extendedLocation storage.ExtendedLocation_STATUS
		err := cluster.ExtendedLocation.AssignProperties_To_ExtendedLocation_STATUS(&extendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ExtendedLocation_STATUS() to populate field ExtendedLocation")
		}
		destination.ExtendedLocation = &extendedLocation
	} else {
		destination.ExtendedLocation = nil
	}

	// Fqdn
	destination.Fqdn = genruntime.ClonePointerToString(cluster.Fqdn)

	// FqdnSubdomain
	destination.FqdnSubdomain = genruntime.ClonePointerToString(cluster.FqdnSubdomain)

	// HttpProxyConfig
	if cluster.HttpProxyConfig != nil {
		var httpProxyConfig storage.ManagedClusterHTTPProxyConfig_STATUS
		err := cluster.HttpProxyConfig.AssignProperties_To_ManagedClusterHTTPProxyConfig_STATUS(&httpProxyConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterHTTPProxyConfig_STATUS() to populate field HttpProxyConfig")
		}
		destination.HttpProxyConfig = &httpProxyConfig
	} else {
		destination.HttpProxyConfig = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(cluster.Id)

	// Identity
	if cluster.Identity != nil {
		var identity storage.ManagedClusterIdentity_STATUS
		err := cluster.Identity.AssignProperties_To_ManagedClusterIdentity_STATUS(&identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterIdentity_STATUS() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// IdentityProfile
	if cluster.IdentityProfile != nil {
		identityProfileMap := make(map[string]storage.UserAssignedIdentity_STATUS, len(cluster.IdentityProfile))
		for identityProfileKey, identityProfileValue := range cluster.IdentityProfile {
			// Shadow the loop variable to avoid aliasing
			identityProfileValue := identityProfileValue
			var identityProfile storage.UserAssignedIdentity_STATUS
			err := identityProfileValue.AssignProperties_To_UserAssignedIdentity_STATUS(&identityProfile)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_UserAssignedIdentity_STATUS() to populate field IdentityProfile")
			}
			identityProfileMap[identityProfileKey] = identityProfile
		}
		destination.IdentityProfile = identityProfileMap
	} else {
		destination.IdentityProfile = nil
	}

	// KubernetesVersion
	destination.KubernetesVersion = genruntime.ClonePointerToString(cluster.KubernetesVersion)

	// LinuxProfile
	if cluster.LinuxProfile != nil {
		var linuxProfile storage.ContainerServiceLinuxProfile_STATUS
		err := cluster.LinuxProfile.AssignProperties_To_ContainerServiceLinuxProfile_STATUS(&linuxProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ContainerServiceLinuxProfile_STATUS() to populate field LinuxProfile")
		}
		destination.LinuxProfile = &linuxProfile
	} else {
		destination.LinuxProfile = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(cluster.Location)

	// MaxAgentPools
	destination.MaxAgentPools = genruntime.ClonePointerToInt(cluster.MaxAgentPools)

	// Name
	destination.Name = genruntime.ClonePointerToString(cluster.Name)

	// NetworkProfile
	if cluster.NetworkProfile != nil {
		var networkProfile storage.ContainerServiceNetworkProfile_STATUS
		err := cluster.NetworkProfile.AssignProperties_To_ContainerServiceNetworkProfile_STATUS(&networkProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ContainerServiceNetworkProfile_STATUS() to populate field NetworkProfile")
		}
		destination.NetworkProfile = &networkProfile
	} else {
		destination.NetworkProfile = nil
	}

	// NodeResourceGroup
	destination.NodeResourceGroup = genruntime.ClonePointerToString(cluster.NodeResourceGroup)

	// PodIdentityProfile
	if cluster.PodIdentityProfile != nil {
		var podIdentityProfile storage.ManagedClusterPodIdentityProfile_STATUS
		err := cluster.PodIdentityProfile.AssignProperties_To_ManagedClusterPodIdentityProfile_STATUS(&podIdentityProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterPodIdentityProfile_STATUS() to populate field PodIdentityProfile")
		}
		destination.PodIdentityProfile = &podIdentityProfile
	} else {
		destination.PodIdentityProfile = nil
	}

	// PowerState
	if cluster.PowerState != nil {
		var powerState storage.PowerState_STATUS
		err := cluster.PowerState.AssignProperties_To_PowerState_STATUS(&powerState)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_PowerState_STATUS() to populate field PowerState")
		}
		destination.PowerState = &powerState
	} else {
		destination.PowerState = nil
	}

	// PrivateFQDN
	destination.PrivateFQDN = genruntime.ClonePointerToString(cluster.PrivateFQDN)

	// PrivateLinkResources
	if cluster.PrivateLinkResources != nil {
		privateLinkResourceList := make([]storage.PrivateLinkResource_STATUS, len(cluster.PrivateLinkResources))
		for privateLinkResourceIndex, privateLinkResourceItem := range cluster.PrivateLinkResources {
			// Shadow the loop variable to avoid aliasing
			privateLinkResourceItem := privateLinkResourceItem
			var privateLinkResource storage.PrivateLinkResource_STATUS
			err := privateLinkResourceItem.AssignProperties_To_PrivateLinkResource_STATUS(&privateLinkResource)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_PrivateLinkResource_STATUS() to populate field PrivateLinkResources")
			}
			privateLinkResourceList[privateLinkResourceIndex] = privateLinkResource
		}
		destination.PrivateLinkResources = privateLinkResourceList
	} else {
		destination.PrivateLinkResources = nil
	}

	// ProvisioningState
	destination.ProvisioningState = genruntime.ClonePointerToString(cluster.ProvisioningState)

	// ServicePrincipalProfile
	if cluster.ServicePrincipalProfile != nil {
		var servicePrincipalProfile storage.ManagedClusterServicePrincipalProfile_STATUS
		err := cluster.ServicePrincipalProfile.AssignProperties_To_ManagedClusterServicePrincipalProfile_STATUS(&servicePrincipalProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterServicePrincipalProfile_STATUS() to populate field ServicePrincipalProfile")
		}
		destination.ServicePrincipalProfile = &servicePrincipalProfile
	} else {
		destination.ServicePrincipalProfile = nil
	}

	// Sku
	if cluster.Sku != nil {
		var sku storage.ManagedClusterSKU_STATUS
		err := cluster.Sku.AssignProperties_To_ManagedClusterSKU_STATUS(&sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterSKU_STATUS() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(cluster.Tags)

	// Type
	destination.Type = genruntime.ClonePointerToString(cluster.Type)

	// WindowsProfile
	if cluster.WindowsProfile != nil {
		var windowsProfile storage.ManagedClusterWindowsProfile_STATUS
		err := cluster.WindowsProfile.AssignProperties_To_ManagedClusterWindowsProfile_STATUS(&windowsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterWindowsProfile_STATUS() to populate field WindowsProfile")
		}
		destination.WindowsProfile = &windowsProfile
	} else {
		destination.WindowsProfile = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ContainerServiceLinuxProfile struct {
	// +kubebuilder:validation:Required
	// +kubebuilder:validation:Pattern="^[A-Za-z][-A-Za-z0-9_]*$"
	AdminUsername *string `json:"adminUsername,omitempty"`

	// +kubebuilder:validation:Required
	Ssh *ContainerServiceSshConfiguration `json:"ssh,omitempty"`
}

var _ genruntime.ARMTransformer = &ContainerServiceLinuxProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *ContainerServiceLinuxProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.ContainerServiceLinuxProfile{}

	// Set property "AdminUsername":
	if profile.AdminUsername != nil {
		adminUsername := *profile.AdminUsername
		result.AdminUsername = &adminUsername
	}

	// Set property "Ssh":
	if profile.Ssh != nil {
		ssh_ARM, err := (*profile.Ssh).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		ssh := *ssh_ARM.(*arm.ContainerServiceSshConfiguration)
		result.Ssh = &ssh
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ContainerServiceLinuxProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ContainerServiceLinuxProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ContainerServiceLinuxProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ContainerServiceLinuxProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ContainerServiceLinuxProfile, got %T", armInput)
	}

	// Set property "AdminUsername":
	if typedInput.AdminUsername != nil {
		adminUsername := *typedInput.AdminUsername
		profile.AdminUsername = &adminUsername
	}

	// Set property "Ssh":
	if typedInput.Ssh != nil {
		var ssh1 ContainerServiceSshConfiguration
		err := ssh1.PopulateFromARM(owner, *typedInput.Ssh)
		if err != nil {
			return err
		}
		ssh := ssh1
		profile.Ssh = &ssh
	}

	// No error
	return nil
}

// AssignProperties_From_ContainerServiceLinuxProfile populates our ContainerServiceLinuxProfile from the provided source ContainerServiceLinuxProfile
func (profile *ContainerServiceLinuxProfile) AssignProperties_From_ContainerServiceLinuxProfile(source *storage.ContainerServiceLinuxProfile) error {

	// AdminUsername
	if source.AdminUsername != nil {
		adminUsername := *source.AdminUsername
		profile.AdminUsername = &adminUsername
	} else {
		profile.AdminUsername = nil
	}

	// Ssh
	if source.Ssh != nil {
		var ssh ContainerServiceSshConfiguration
		err := ssh.AssignProperties_From_ContainerServiceSshConfiguration(source.Ssh)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ContainerServiceSshConfiguration() to populate field Ssh")
		}
		profile.Ssh = &ssh
	} else {
		profile.Ssh = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ContainerServiceLinuxProfile populates the provided destination ContainerServiceLinuxProfile from our ContainerServiceLinuxProfile
func (profile *ContainerServiceLinuxProfile) AssignProperties_To_ContainerServiceLinuxProfile(destination *storage.ContainerServiceLinuxProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdminUsername
	if profile.AdminUsername != nil {
		adminUsername := *profile.AdminUsername
		destination.AdminUsername = &adminUsername
	} else {
		destination.AdminUsername = nil
	}

	// Ssh
	if profile.Ssh != nil {
		var ssh storage.ContainerServiceSshConfiguration
		err := profile.Ssh.AssignProperties_To_ContainerServiceSshConfiguration(&ssh)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ContainerServiceSshConfiguration() to populate field Ssh")
		}
		destination.Ssh = &ssh
	} else {
		destination.Ssh = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ContainerServiceLinuxProfile_STATUS struct {
	AdminUsername *string                                  `json:"adminUsername,omitempty"`
	Ssh           *ContainerServiceSshConfiguration_STATUS `json:"ssh,omitempty"`
}

var _ genruntime.FromARMConverter = &ContainerServiceLinuxProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ContainerServiceLinuxProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ContainerServiceLinuxProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ContainerServiceLinuxProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ContainerServiceLinuxProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ContainerServiceLinuxProfile_STATUS, got %T", armInput)
	}

	// Set property "AdminUsername":
	if typedInput.AdminUsername != nil {
		adminUsername := *typedInput.AdminUsername
		profile.AdminUsername = &adminUsername
	}

	// Set property "Ssh":
	if typedInput.Ssh != nil {
		var ssh1 ContainerServiceSshConfiguration_STATUS
		err := ssh1.PopulateFromARM(owner, *typedInput.Ssh)
		if err != nil {
			return err
		}
		ssh := ssh1
		profile.Ssh = &ssh
	}

	// No error
	return nil
}

// AssignProperties_From_ContainerServiceLinuxProfile_STATUS populates our ContainerServiceLinuxProfile_STATUS from the provided source ContainerServiceLinuxProfile_STATUS
func (profile *ContainerServiceLinuxProfile_STATUS) AssignProperties_From_ContainerServiceLinuxProfile_STATUS(source *storage.ContainerServiceLinuxProfile_STATUS) error {

	// AdminUsername
	profile.AdminUsername = genruntime.ClonePointerToString(source.AdminUsername)

	// Ssh
	if source.Ssh != nil {
		var ssh ContainerServiceSshConfiguration_STATUS
		err := ssh.AssignProperties_From_ContainerServiceSshConfiguration_STATUS(source.Ssh)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ContainerServiceSshConfiguration_STATUS() to populate field Ssh")
		}
		profile.Ssh = &ssh
	} else {
		profile.Ssh = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ContainerServiceLinuxProfile_STATUS populates the provided destination ContainerServiceLinuxProfile_STATUS from our ContainerServiceLinuxProfile_STATUS
func (profile *ContainerServiceLinuxProfile_STATUS) AssignProperties_To_ContainerServiceLinuxProfile_STATUS(destination *storage.ContainerServiceLinuxProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdminUsername
	destination.AdminUsername = genruntime.ClonePointerToString(profile.AdminUsername)

	// Ssh
	if profile.Ssh != nil {
		var ssh storage.ContainerServiceSshConfiguration_STATUS
		err := profile.Ssh.AssignProperties_To_ContainerServiceSshConfiguration_STATUS(&ssh)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ContainerServiceSshConfiguration_STATUS() to populate field Ssh")
		}
		destination.Ssh = &ssh
	} else {
		destination.Ssh = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ContainerServiceNetworkProfile struct {
	// +kubebuilder:validation:Pattern="^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$"
	DnsServiceIP *string `json:"dnsServiceIP,omitempty"`

	// +kubebuilder:validation:Pattern="^([0-9]{1,3}\\.){3}[0-9]{1,3}(\\/([0-9]|[1-2][0-9]|3[0-2]))?$"
	DockerBridgeCidr    *string                                         `json:"dockerBridgeCidr,omitempty"`
	LoadBalancerProfile *ManagedClusterLoadBalancerProfile              `json:"loadBalancerProfile,omitempty"`
	LoadBalancerSku     *ContainerServiceNetworkProfile_LoadBalancerSku `json:"loadBalancerSku,omitempty"`
	NetworkMode         *ContainerServiceNetworkProfile_NetworkMode     `json:"networkMode,omitempty"`
	NetworkPlugin       *ContainerServiceNetworkProfile_NetworkPlugin   `json:"networkPlugin,omitempty"`
	NetworkPolicy       *ContainerServiceNetworkProfile_NetworkPolicy   `json:"networkPolicy,omitempty"`
	OutboundType        *ContainerServiceNetworkProfile_OutboundType    `json:"outboundType,omitempty"`

	// +kubebuilder:validation:Pattern="^([0-9]{1,3}\\.){3}[0-9]{1,3}(\\/([0-9]|[1-2][0-9]|3[0-2]))?$"
	PodCidr *string `json:"podCidr,omitempty"`

	// +kubebuilder:validation:Pattern="^([0-9]{1,3}\\.){3}[0-9]{1,3}(\\/([0-9]|[1-2][0-9]|3[0-2]))?$"
	ServiceCidr *string `json:"serviceCidr,omitempty"`
}

var _ genruntime.ARMTransformer = &ContainerServiceNetworkProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *ContainerServiceNetworkProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.ContainerServiceNetworkProfile{}

	// Set property "DnsServiceIP":
	if profile.DnsServiceIP != nil {
		dnsServiceIP := *profile.DnsServiceIP
		result.DnsServiceIP = &dnsServiceIP
	}

	// Set property "DockerBridgeCidr":
	if profile.DockerBridgeCidr != nil {
		dockerBridgeCidr := *profile.DockerBridgeCidr
		result.DockerBridgeCidr = &dockerBridgeCidr
	}

	// Set property "LoadBalancerProfile":
	if profile.LoadBalancerProfile != nil {
		loadBalancerProfile_ARM, err := (*profile.LoadBalancerProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		loadBalancerProfile := *loadBalancerProfile_ARM.(*arm.ManagedClusterLoadBalancerProfile)
		result.LoadBalancerProfile = &loadBalancerProfile
	}

	// Set property "LoadBalancerSku":
	if profile.LoadBalancerSku != nil {
		var temp string
		temp = string(*profile.LoadBalancerSku)
		loadBalancerSku := arm.ContainerServiceNetworkProfile_LoadBalancerSku(temp)
		result.LoadBalancerSku = &loadBalancerSku
	}

	// Set property "NetworkMode":
	if profile.NetworkMode != nil {
		var temp string
		temp = string(*profile.NetworkMode)
		networkMode := arm.ContainerServiceNetworkProfile_NetworkMode(temp)
		result.NetworkMode = &networkMode
	}

	// Set property "NetworkPlugin":
	if profile.NetworkPlugin != nil {
		var temp string
		temp = string(*profile.NetworkPlugin)
		networkPlugin := arm.ContainerServiceNetworkProfile_NetworkPlugin(temp)
		result.NetworkPlugin = &networkPlugin
	}

	// Set property "NetworkPolicy":
	if profile.NetworkPolicy != nil {
		var temp string
		temp = string(*profile.NetworkPolicy)
		networkPolicy := arm.ContainerServiceNetworkProfile_NetworkPolicy(temp)
		result.NetworkPolicy = &networkPolicy
	}

	// Set property "OutboundType":
	if profile.OutboundType != nil {
		var temp string
		temp = string(*profile.OutboundType)
		outboundType := arm.ContainerServiceNetworkProfile_OutboundType(temp)
		result.OutboundType = &outboundType
	}

	// Set property "PodCidr":
	if profile.PodCidr != nil {
		podCidr := *profile.PodCidr
		result.PodCidr = &podCidr
	}

	// Set property "ServiceCidr":
	if profile.ServiceCidr != nil {
		serviceCidr := *profile.ServiceCidr
		result.ServiceCidr = &serviceCidr
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ContainerServiceNetworkProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ContainerServiceNetworkProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ContainerServiceNetworkProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ContainerServiceNetworkProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ContainerServiceNetworkProfile, got %T", armInput)
	}

	// Set property "DnsServiceIP":
	if typedInput.DnsServiceIP != nil {
		dnsServiceIP := *typedInput.DnsServiceIP
		profile.DnsServiceIP = &dnsServiceIP
	}

	// Set property "DockerBridgeCidr":
	if typedInput.DockerBridgeCidr != nil {
		dockerBridgeCidr := *typedInput.DockerBridgeCidr
		profile.DockerBridgeCidr = &dockerBridgeCidr
	}

	// Set property "LoadBalancerProfile":
	if typedInput.LoadBalancerProfile != nil {
		var loadBalancerProfile1 ManagedClusterLoadBalancerProfile
		err := loadBalancerProfile1.PopulateFromARM(owner, *typedInput.LoadBalancerProfile)
		if err != nil {
			return err
		}
		loadBalancerProfile := loadBalancerProfile1
		profile.LoadBalancerProfile = &loadBalancerProfile
	}

	// Set property "LoadBalancerSku":
	if typedInput.LoadBalancerSku != nil {
		var temp string
		temp = string(*typedInput.LoadBalancerSku)
		loadBalancerSku := ContainerServiceNetworkProfile_LoadBalancerSku(temp)
		profile.LoadBalancerSku = &loadBalancerSku
	}

	// Set property "NetworkMode":
	if typedInput.NetworkMode != nil {
		var temp string
		temp = string(*typedInput.NetworkMode)
		networkMode := ContainerServiceNetworkProfile_NetworkMode(temp)
		profile.NetworkMode = &networkMode
	}

	// Set property "NetworkPlugin":
	if typedInput.NetworkPlugin != nil {
		var temp string
		temp = string(*typedInput.NetworkPlugin)
		networkPlugin := ContainerServiceNetworkProfile_NetworkPlugin(temp)
		profile.NetworkPlugin = &networkPlugin
	}

	// Set property "NetworkPolicy":
	if typedInput.NetworkPolicy != nil {
		var temp string
		temp = string(*typedInput.NetworkPolicy)
		networkPolicy := ContainerServiceNetworkProfile_NetworkPolicy(temp)
		profile.NetworkPolicy = &networkPolicy
	}

	// Set property "OutboundType":
	if typedInput.OutboundType != nil {
		var temp string
		temp = string(*typedInput.OutboundType)
		outboundType := ContainerServiceNetworkProfile_OutboundType(temp)
		profile.OutboundType = &outboundType
	}

	// Set property "PodCidr":
	if typedInput.PodCidr != nil {
		podCidr := *typedInput.PodCidr
		profile.PodCidr = &podCidr
	}

	// Set property "ServiceCidr":
	if typedInput.ServiceCidr != nil {
		serviceCidr := *typedInput.ServiceCidr
		profile.ServiceCidr = &serviceCidr
	}

	// No error
	return nil
}

// AssignProperties_From_ContainerServiceNetworkProfile populates our ContainerServiceNetworkProfile from the provided source ContainerServiceNetworkProfile
func (profile *ContainerServiceNetworkProfile) AssignProperties_From_ContainerServiceNetworkProfile(source *storage.ContainerServiceNetworkProfile) error {

	// DnsServiceIP
	if source.DnsServiceIP != nil {
		dnsServiceIP := *source.DnsServiceIP
		profile.DnsServiceIP = &dnsServiceIP
	} else {
		profile.DnsServiceIP = nil
	}

	// DockerBridgeCidr
	if source.DockerBridgeCidr != nil {
		dockerBridgeCidr := *source.DockerBridgeCidr
		profile.DockerBridgeCidr = &dockerBridgeCidr
	} else {
		profile.DockerBridgeCidr = nil
	}

	// LoadBalancerProfile
	if source.LoadBalancerProfile != nil {
		var loadBalancerProfile ManagedClusterLoadBalancerProfile
		err := loadBalancerProfile.AssignProperties_From_ManagedClusterLoadBalancerProfile(source.LoadBalancerProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterLoadBalancerProfile() to populate field LoadBalancerProfile")
		}
		profile.LoadBalancerProfile = &loadBalancerProfile
	} else {
		profile.LoadBalancerProfile = nil
	}

	// LoadBalancerSku
	if source.LoadBalancerSku != nil {
		loadBalancerSku := *source.LoadBalancerSku
		loadBalancerSkuTemp := genruntime.ToEnum(loadBalancerSku, containerServiceNetworkProfile_LoadBalancerSku_Values)
		profile.LoadBalancerSku = &loadBalancerSkuTemp
	} else {
		profile.LoadBalancerSku = nil
	}

	// NetworkMode
	if source.NetworkMode != nil {
		networkMode := *source.NetworkMode
		networkModeTemp := genruntime.ToEnum(networkMode, containerServiceNetworkProfile_NetworkMode_Values)
		profile.NetworkMode = &networkModeTemp
	} else {
		profile.NetworkMode = nil
	}

	// NetworkPlugin
	if source.NetworkPlugin != nil {
		networkPlugin := *source.NetworkPlugin
		networkPluginTemp := genruntime.ToEnum(networkPlugin, containerServiceNetworkProfile_NetworkPlugin_Values)
		profile.NetworkPlugin = &networkPluginTemp
	} else {
		profile.NetworkPlugin = nil
	}

	// NetworkPolicy
	if source.NetworkPolicy != nil {
		networkPolicy := *source.NetworkPolicy
		networkPolicyTemp := genruntime.ToEnum(networkPolicy, containerServiceNetworkProfile_NetworkPolicy_Values)
		profile.NetworkPolicy = &networkPolicyTemp
	} else {
		profile.NetworkPolicy = nil
	}

	// OutboundType
	if source.OutboundType != nil {
		outboundType := *source.OutboundType
		outboundTypeTemp := genruntime.ToEnum(outboundType, containerServiceNetworkProfile_OutboundType_Values)
		profile.OutboundType = &outboundTypeTemp
	} else {
		profile.OutboundType = nil
	}

	// PodCidr
	if source.PodCidr != nil {
		podCidr := *source.PodCidr
		profile.PodCidr = &podCidr
	} else {
		profile.PodCidr = nil
	}

	// ServiceCidr
	if source.ServiceCidr != nil {
		serviceCidr := *source.ServiceCidr
		profile.ServiceCidr = &serviceCidr
	} else {
		profile.ServiceCidr = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ContainerServiceNetworkProfile populates the provided destination ContainerServiceNetworkProfile from our ContainerServiceNetworkProfile
func (profile *ContainerServiceNetworkProfile) AssignProperties_To_ContainerServiceNetworkProfile(destination *storage.ContainerServiceNetworkProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DnsServiceIP
	if profile.DnsServiceIP != nil {
		dnsServiceIP := *profile.DnsServiceIP
		destination.DnsServiceIP = &dnsServiceIP
	} else {
		destination.DnsServiceIP = nil
	}

	// DockerBridgeCidr
	if profile.DockerBridgeCidr != nil {
		dockerBridgeCidr := *profile.DockerBridgeCidr
		destination.DockerBridgeCidr = &dockerBridgeCidr
	} else {
		destination.DockerBridgeCidr = nil
	}

	// LoadBalancerProfile
	if profile.LoadBalancerProfile != nil {
		var loadBalancerProfile storage.ManagedClusterLoadBalancerProfile
		err := profile.LoadBalancerProfile.AssignProperties_To_ManagedClusterLoadBalancerProfile(&loadBalancerProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterLoadBalancerProfile() to populate field LoadBalancerProfile")
		}
		destination.LoadBalancerProfile = &loadBalancerProfile
	} else {
		destination.LoadBalancerProfile = nil
	}

	// LoadBalancerSku
	if profile.LoadBalancerSku != nil {
		loadBalancerSku := string(*profile.LoadBalancerSku)
		destination.LoadBalancerSku = &loadBalancerSku
	} else {
		destination.LoadBalancerSku = nil
	}

	// NetworkMode
	if profile.NetworkMode != nil {
		networkMode := string(*profile.NetworkMode)
		destination.NetworkMode = &networkMode
	} else {
		destination.NetworkMode = nil
	}

	// NetworkPlugin
	if profile.NetworkPlugin != nil {
		networkPlugin := string(*profile.NetworkPlugin)
		destination.NetworkPlugin = &networkPlugin
	} else {
		destination.NetworkPlugin = nil
	}

	// NetworkPolicy
	if profile.NetworkPolicy != nil {
		networkPolicy := string(*profile.NetworkPolicy)
		destination.NetworkPolicy = &networkPolicy
	} else {
		destination.NetworkPolicy = nil
	}

	// OutboundType
	if profile.OutboundType != nil {
		outboundType := string(*profile.OutboundType)
		destination.OutboundType = &outboundType
	} else {
		destination.OutboundType = nil
	}

	// PodCidr
	if profile.PodCidr != nil {
		podCidr := *profile.PodCidr
		destination.PodCidr = &podCidr
	} else {
		destination.PodCidr = nil
	}

	// ServiceCidr
	if profile.ServiceCidr != nil {
		serviceCidr := *profile.ServiceCidr
		destination.ServiceCidr = &serviceCidr
	} else {
		destination.ServiceCidr = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ContainerServiceNetworkProfile_STATUS struct {
	DnsServiceIP        *string                                                `json:"dnsServiceIP,omitempty"`
	DockerBridgeCidr    *string                                                `json:"dockerBridgeCidr,omitempty"`
	LoadBalancerProfile *ManagedClusterLoadBalancerProfile_STATUS              `json:"loadBalancerProfile,omitempty"`
	LoadBalancerSku     *ContainerServiceNetworkProfile_LoadBalancerSku_STATUS `json:"loadBalancerSku,omitempty"`
	NetworkMode         *ContainerServiceNetworkProfile_NetworkMode_STATUS     `json:"networkMode,omitempty"`
	NetworkPlugin       *ContainerServiceNetworkProfile_NetworkPlugin_STATUS   `json:"networkPlugin,omitempty"`
	NetworkPolicy       *ContainerServiceNetworkProfile_NetworkPolicy_STATUS   `json:"networkPolicy,omitempty"`
	OutboundType        *ContainerServiceNetworkProfile_OutboundType_STATUS    `json:"outboundType,omitempty"`
	PodCidr             *string                                                `json:"podCidr,omitempty"`
	ServiceCidr         *string                                                `json:"serviceCidr,omitempty"`
}

var _ genruntime.FromARMConverter = &ContainerServiceNetworkProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ContainerServiceNetworkProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ContainerServiceNetworkProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ContainerServiceNetworkProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ContainerServiceNetworkProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ContainerServiceNetworkProfile_STATUS, got %T", armInput)
	}

	// Set property "DnsServiceIP":
	if typedInput.DnsServiceIP != nil {
		dnsServiceIP := *typedInput.DnsServiceIP
		profile.DnsServiceIP = &dnsServiceIP
	}

	// Set property "DockerBridgeCidr":
	if typedInput.DockerBridgeCidr != nil {
		dockerBridgeCidr := *typedInput.DockerBridgeCidr
		profile.DockerBridgeCidr = &dockerBridgeCidr
	}

	// Set property "LoadBalancerProfile":
	if typedInput.LoadBalancerProfile != nil {
		var loadBalancerProfile1 ManagedClusterLoadBalancerProfile_STATUS
		err := loadBalancerProfile1.PopulateFromARM(owner, *typedInput.LoadBalancerProfile)
		if err != nil {
			return err
		}
		loadBalancerProfile := loadBalancerProfile1
		profile.LoadBalancerProfile = &loadBalancerProfile
	}

	// Set property "LoadBalancerSku":
	if typedInput.LoadBalancerSku != nil {
		var temp string
		temp = string(*typedInput.LoadBalancerSku)
		loadBalancerSku := ContainerServiceNetworkProfile_LoadBalancerSku_STATUS(temp)
		profile.LoadBalancerSku = &loadBalancerSku
	}

	// Set property "NetworkMode":
	if typedInput.NetworkMode != nil {
		var temp string
		temp = string(*typedInput.NetworkMode)
		networkMode := ContainerServiceNetworkProfile_NetworkMode_STATUS(temp)
		profile.NetworkMode = &networkMode
	}

	// Set property "NetworkPlugin":
	if typedInput.NetworkPlugin != nil {
		var temp string
		temp = string(*typedInput.NetworkPlugin)
		networkPlugin := ContainerServiceNetworkProfile_NetworkPlugin_STATUS(temp)
		profile.NetworkPlugin = &networkPlugin
	}

	// Set property "NetworkPolicy":
	if typedInput.NetworkPolicy != nil {
		var temp string
		temp = string(*typedInput.NetworkPolicy)
		networkPolicy := ContainerServiceNetworkProfile_NetworkPolicy_STATUS(temp)
		profile.NetworkPolicy = &networkPolicy
	}

	// Set property "OutboundType":
	if typedInput.OutboundType != nil {
		var temp string
		temp = string(*typedInput.OutboundType)
		outboundType := ContainerServiceNetworkProfile_OutboundType_STATUS(temp)
		profile.OutboundType = &outboundType
	}

	// Set property "PodCidr":
	if typedInput.PodCidr != nil {
		podCidr := *typedInput.PodCidr
		profile.PodCidr = &podCidr
	}

	// Set property "ServiceCidr":
	if typedInput.ServiceCidr != nil {
		serviceCidr := *typedInput.ServiceCidr
		profile.ServiceCidr = &serviceCidr
	}

	// No error
	return nil
}

// AssignProperties_From_ContainerServiceNetworkProfile_STATUS populates our ContainerServiceNetworkProfile_STATUS from the provided source ContainerServiceNetworkProfile_STATUS
func (profile *ContainerServiceNetworkProfile_STATUS) AssignProperties_From_ContainerServiceNetworkProfile_STATUS(source *storage.ContainerServiceNetworkProfile_STATUS) error {

	// DnsServiceIP
	profile.DnsServiceIP = genruntime.ClonePointerToString(source.DnsServiceIP)

	// DockerBridgeCidr
	profile.DockerBridgeCidr = genruntime.ClonePointerToString(source.DockerBridgeCidr)

	// LoadBalancerProfile
	if source.LoadBalancerProfile != nil {
		var loadBalancerProfile ManagedClusterLoadBalancerProfile_STATUS
		err := loadBalancerProfile.AssignProperties_From_ManagedClusterLoadBalancerProfile_STATUS(source.LoadBalancerProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterLoadBalancerProfile_STATUS() to populate field LoadBalancerProfile")
		}
		profile.LoadBalancerProfile = &loadBalancerProfile
	} else {
		profile.LoadBalancerProfile = nil
	}

	// LoadBalancerSku
	if source.LoadBalancerSku != nil {
		loadBalancerSku := *source.LoadBalancerSku
		loadBalancerSkuTemp := genruntime.ToEnum(loadBalancerSku, containerServiceNetworkProfile_LoadBalancerSku_STATUS_Values)
		profile.LoadBalancerSku = &loadBalancerSkuTemp
	} else {
		profile.LoadBalancerSku = nil
	}

	// NetworkMode
	if source.NetworkMode != nil {
		networkMode := *source.NetworkMode
		networkModeTemp := genruntime.ToEnum(networkMode, containerServiceNetworkProfile_NetworkMode_STATUS_Values)
		profile.NetworkMode = &networkModeTemp
	} else {
		profile.NetworkMode = nil
	}

	// NetworkPlugin
	if source.NetworkPlugin != nil {
		networkPlugin := *source.NetworkPlugin
		networkPluginTemp := genruntime.ToEnum(networkPlugin, containerServiceNetworkProfile_NetworkPlugin_STATUS_Values)
		profile.NetworkPlugin = &networkPluginTemp
	} else {
		profile.NetworkPlugin = nil
	}

	// NetworkPolicy
	if source.NetworkPolicy != nil {
		networkPolicy := *source.NetworkPolicy
		networkPolicyTemp := genruntime.ToEnum(networkPolicy, containerServiceNetworkProfile_NetworkPolicy_STATUS_Values)
		profile.NetworkPolicy = &networkPolicyTemp
	} else {
		profile.NetworkPolicy = nil
	}

	// OutboundType
	if source.OutboundType != nil {
		outboundType := *source.OutboundType
		outboundTypeTemp := genruntime.ToEnum(outboundType, containerServiceNetworkProfile_OutboundType_STATUS_Values)
		profile.OutboundType = &outboundTypeTemp
	} else {
		profile.OutboundType = nil
	}

	// PodCidr
	profile.PodCidr = genruntime.ClonePointerToString(source.PodCidr)

	// ServiceCidr
	profile.ServiceCidr = genruntime.ClonePointerToString(source.ServiceCidr)

	// No error
	return nil
}

// AssignProperties_To_ContainerServiceNetworkProfile_STATUS populates the provided destination ContainerServiceNetworkProfile_STATUS from our ContainerServiceNetworkProfile_STATUS
func (profile *ContainerServiceNetworkProfile_STATUS) AssignProperties_To_ContainerServiceNetworkProfile_STATUS(destination *storage.ContainerServiceNetworkProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DnsServiceIP
	destination.DnsServiceIP = genruntime.ClonePointerToString(profile.DnsServiceIP)

	// DockerBridgeCidr
	destination.DockerBridgeCidr = genruntime.ClonePointerToString(profile.DockerBridgeCidr)

	// LoadBalancerProfile
	if profile.LoadBalancerProfile != nil {
		var loadBalancerProfile storage.ManagedClusterLoadBalancerProfile_STATUS
		err := profile.LoadBalancerProfile.AssignProperties_To_ManagedClusterLoadBalancerProfile_STATUS(&loadBalancerProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterLoadBalancerProfile_STATUS() to populate field LoadBalancerProfile")
		}
		destination.LoadBalancerProfile = &loadBalancerProfile
	} else {
		destination.LoadBalancerProfile = nil
	}

	// LoadBalancerSku
	if profile.LoadBalancerSku != nil {
		loadBalancerSku := string(*profile.LoadBalancerSku)
		destination.LoadBalancerSku = &loadBalancerSku
	} else {
		destination.LoadBalancerSku = nil
	}

	// NetworkMode
	if profile.NetworkMode != nil {
		networkMode := string(*profile.NetworkMode)
		destination.NetworkMode = &networkMode
	} else {
		destination.NetworkMode = nil
	}

	// NetworkPlugin
	if profile.NetworkPlugin != nil {
		networkPlugin := string(*profile.NetworkPlugin)
		destination.NetworkPlugin = &networkPlugin
	} else {
		destination.NetworkPlugin = nil
	}

	// NetworkPolicy
	if profile.NetworkPolicy != nil {
		networkPolicy := string(*profile.NetworkPolicy)
		destination.NetworkPolicy = &networkPolicy
	} else {
		destination.NetworkPolicy = nil
	}

	// OutboundType
	if profile.OutboundType != nil {
		outboundType := string(*profile.OutboundType)
		destination.OutboundType = &outboundType
	} else {
		destination.OutboundType = nil
	}

	// PodCidr
	destination.PodCidr = genruntime.ClonePointerToString(profile.PodCidr)

	// ServiceCidr
	destination.ServiceCidr = genruntime.ClonePointerToString(profile.ServiceCidr)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ExtendedLocation struct {
	Name *string               `json:"name,omitempty"`
	Type *ExtendedLocationType `json:"type,omitempty"`
}

var _ genruntime.ARMTransformer = &ExtendedLocation{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (location *ExtendedLocation) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if location == nil {
		return nil, nil
	}
	result := &arm.ExtendedLocation{}

	// Set property "Name":
	if location.Name != nil {
		name := *location.Name
		result.Name = &name
	}

	// Set property "Type":
	if location.Type != nil {
		var temp string
		temp = string(*location.Type)
		typeVar := arm.ExtendedLocationType(temp)
		result.Type = &typeVar
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (location *ExtendedLocation) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ExtendedLocation{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (location *ExtendedLocation) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ExtendedLocation)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ExtendedLocation, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		location.Name = &name
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := ExtendedLocationType(temp)
		location.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_ExtendedLocation populates our ExtendedLocation from the provided source ExtendedLocation
func (location *ExtendedLocation) AssignProperties_From_ExtendedLocation(source *storage.ExtendedLocation) error {

	// Name
	location.Name = genruntime.ClonePointerToString(source.Name)

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, extendedLocationType_Values)
		location.Type = &typeTemp
	} else {
		location.Type = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ExtendedLocation populates the provided destination ExtendedLocation from our ExtendedLocation
func (location *ExtendedLocation) AssignProperties_To_ExtendedLocation(destination *storage.ExtendedLocation) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(location.Name)

	// Type
	if location.Type != nil {
		typeVar := string(*location.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ExtendedLocation_STATUS struct {
	Name *string                      `json:"name,omitempty"`
	Type *ExtendedLocationType_STATUS `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &ExtendedLocation_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (location *ExtendedLocation_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ExtendedLocation_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (location *ExtendedLocation_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ExtendedLocation_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ExtendedLocation_STATUS, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		location.Name = &name
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := ExtendedLocationType_STATUS(temp)
		location.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_ExtendedLocation_STATUS populates our ExtendedLocation_STATUS from the provided source ExtendedLocation_STATUS
func (location *ExtendedLocation_STATUS) AssignProperties_From_ExtendedLocation_STATUS(source *storage.ExtendedLocation_STATUS) error {

	// Name
	location.Name = genruntime.ClonePointerToString(source.Name)

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, extendedLocationType_STATUS_Values)
		location.Type = &typeTemp
	} else {
		location.Type = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ExtendedLocation_STATUS populates the provided destination ExtendedLocation_STATUS from our ExtendedLocation_STATUS
func (location *ExtendedLocation_STATUS) AssignProperties_To_ExtendedLocation_STATUS(destination *storage.ExtendedLocation_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(location.Name)

	// Type
	if location.Type != nil {
		typeVar := string(*location.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterAADProfile struct {
	AdminGroupObjectIDs []string `json:"adminGroupObjectIDs,omitempty"`
	ClientAppID         *string  `json:"clientAppID,omitempty"`
	EnableAzureRBAC     *bool    `json:"enableAzureRBAC,omitempty"`
	Managed             *bool    `json:"managed,omitempty"`
	ServerAppID         *string  `json:"serverAppID,omitempty"`
	ServerAppSecret     *string  `json:"serverAppSecret,omitempty"`
	TenantID            *string  `json:"tenantID,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterAADProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *ManagedClusterAADProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.ManagedClusterAADProfile{}

	// Set property "AdminGroupObjectIDs":
	for _, item := range profile.AdminGroupObjectIDs {
		result.AdminGroupObjectIDs = append(result.AdminGroupObjectIDs, item)
	}

	// Set property "ClientAppID":
	if profile.ClientAppID != nil {
		clientAppID := *profile.ClientAppID
		result.ClientAppID = &clientAppID
	}

	// Set property "EnableAzureRBAC":
	if profile.EnableAzureRBAC != nil {
		enableAzureRBAC := *profile.EnableAzureRBAC
		result.EnableAzureRBAC = &enableAzureRBAC
	}

	// Set property "Managed":
	if profile.Managed != nil {
		managed := *profile.Managed
		result.Managed = &managed
	}

	// Set property "ServerAppID":
	if profile.ServerAppID != nil {
		serverAppID := *profile.ServerAppID
		result.ServerAppID = &serverAppID
	}

	// Set property "ServerAppSecret":
	if profile.ServerAppSecret != nil {
		serverAppSecret := *profile.ServerAppSecret
		result.ServerAppSecret = &serverAppSecret
	}

	// Set property "TenantID":
	if profile.TenantID != nil {
		tenantID := *profile.TenantID
		result.TenantID = &tenantID
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterAADProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterAADProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterAADProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterAADProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterAADProfile, got %T", armInput)
	}

	// Set property "AdminGroupObjectIDs":
	for _, item := range typedInput.AdminGroupObjectIDs {
		profile.AdminGroupObjectIDs = append(profile.AdminGroupObjectIDs, item)
	}

	// Set property "ClientAppID":
	if typedInput.ClientAppID != nil {
		clientAppID := *typedInput.ClientAppID
		profile.ClientAppID = &clientAppID
	}

	// Set property "EnableAzureRBAC":
	if typedInput.EnableAzureRBAC != nil {
		enableAzureRBAC := *typedInput.EnableAzureRBAC
		profile.EnableAzureRBAC = &enableAzureRBAC
	}

	// Set property "Managed":
	if typedInput.Managed != nil {
		managed := *typedInput.Managed
		profile.Managed = &managed
	}

	// Set property "ServerAppID":
	if typedInput.ServerAppID != nil {
		serverAppID := *typedInput.ServerAppID
		profile.ServerAppID = &serverAppID
	}

	// Set property "ServerAppSecret":
	if typedInput.ServerAppSecret != nil {
		serverAppSecret := *typedInput.ServerAppSecret
		profile.ServerAppSecret = &serverAppSecret
	}

	// Set property "TenantID":
	if typedInput.TenantID != nil {
		tenantID := *typedInput.TenantID
		profile.TenantID = &tenantID
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterAADProfile populates our ManagedClusterAADProfile from the provided source ManagedClusterAADProfile
func (profile *ManagedClusterAADProfile) AssignProperties_From_ManagedClusterAADProfile(source *storage.ManagedClusterAADProfile) error {

	// AdminGroupObjectIDs
	profile.AdminGroupObjectIDs = genruntime.CloneSliceOfString(source.AdminGroupObjectIDs)

	// ClientAppID
	profile.ClientAppID = genruntime.ClonePointerToString(source.ClientAppID)

	// EnableAzureRBAC
	if source.EnableAzureRBAC != nil {
		enableAzureRBAC := *source.EnableAzureRBAC
		profile.EnableAzureRBAC = &enableAzureRBAC
	} else {
		profile.EnableAzureRBAC = nil
	}

	// Managed
	if source.Managed != nil {
		managed := *source.Managed
		profile.Managed = &managed
	} else {
		profile.Managed = nil
	}

	// ServerAppID
	profile.ServerAppID = genruntime.ClonePointerToString(source.ServerAppID)

	// ServerAppSecret
	profile.ServerAppSecret = genruntime.ClonePointerToString(source.ServerAppSecret)

	// TenantID
	profile.TenantID = genruntime.ClonePointerToString(source.TenantID)

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterAADProfile populates the provided destination ManagedClusterAADProfile from our ManagedClusterAADProfile
func (profile *ManagedClusterAADProfile) AssignProperties_To_ManagedClusterAADProfile(destination *storage.ManagedClusterAADProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdminGroupObjectIDs
	destination.AdminGroupObjectIDs = genruntime.CloneSliceOfString(profile.AdminGroupObjectIDs)

	// ClientAppID
	destination.ClientAppID = genruntime.ClonePointerToString(profile.ClientAppID)

	// EnableAzureRBAC
	if profile.EnableAzureRBAC != nil {
		enableAzureRBAC := *profile.EnableAzureRBAC
		destination.EnableAzureRBAC = &enableAzureRBAC
	} else {
		destination.EnableAzureRBAC = nil
	}

	// Managed
	if profile.Managed != nil {
		managed := *profile.Managed
		destination.Managed = &managed
	} else {
		destination.Managed = nil
	}

	// ServerAppID
	destination.ServerAppID = genruntime.ClonePointerToString(profile.ServerAppID)

	// ServerAppSecret
	destination.ServerAppSecret = genruntime.ClonePointerToString(profile.ServerAppSecret)

	// TenantID
	destination.TenantID = genruntime.ClonePointerToString(profile.TenantID)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterAADProfile_STATUS struct {
	AdminGroupObjectIDs []string `json:"adminGroupObjectIDs,omitempty"`
	ClientAppID         *string  `json:"clientAppID,omitempty"`
	EnableAzureRBAC     *bool    `json:"enableAzureRBAC,omitempty"`
	Managed             *bool    `json:"managed,omitempty"`
	ServerAppID         *string  `json:"serverAppID,omitempty"`
	ServerAppSecret     *string  `json:"serverAppSecret,omitempty"`
	TenantID            *string  `json:"tenantID,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterAADProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterAADProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterAADProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterAADProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterAADProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterAADProfile_STATUS, got %T", armInput)
	}

	// Set property "AdminGroupObjectIDs":
	for _, item := range typedInput.AdminGroupObjectIDs {
		profile.AdminGroupObjectIDs = append(profile.AdminGroupObjectIDs, item)
	}

	// Set property "ClientAppID":
	if typedInput.ClientAppID != nil {
		clientAppID := *typedInput.ClientAppID
		profile.ClientAppID = &clientAppID
	}

	// Set property "EnableAzureRBAC":
	if typedInput.EnableAzureRBAC != nil {
		enableAzureRBAC := *typedInput.EnableAzureRBAC
		profile.EnableAzureRBAC = &enableAzureRBAC
	}

	// Set property "Managed":
	if typedInput.Managed != nil {
		managed := *typedInput.Managed
		profile.Managed = &managed
	}

	// Set property "ServerAppID":
	if typedInput.ServerAppID != nil {
		serverAppID := *typedInput.ServerAppID
		profile.ServerAppID = &serverAppID
	}

	// Set property "ServerAppSecret":
	if typedInput.ServerAppSecret != nil {
		serverAppSecret := *typedInput.ServerAppSecret
		profile.ServerAppSecret = &serverAppSecret
	}

	// Set property "TenantID":
	if typedInput.TenantID != nil {
		tenantID := *typedInput.TenantID
		profile.TenantID = &tenantID
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterAADProfile_STATUS populates our ManagedClusterAADProfile_STATUS from the provided source ManagedClusterAADProfile_STATUS
func (profile *ManagedClusterAADProfile_STATUS) AssignProperties_From_ManagedClusterAADProfile_STATUS(source *storage.ManagedClusterAADProfile_STATUS) error {

	// AdminGroupObjectIDs
	profile.AdminGroupObjectIDs = genruntime.CloneSliceOfString(source.AdminGroupObjectIDs)

	// ClientAppID
	profile.ClientAppID = genruntime.ClonePointerToString(source.ClientAppID)

	// EnableAzureRBAC
	if source.EnableAzureRBAC != nil {
		enableAzureRBAC := *source.EnableAzureRBAC
		profile.EnableAzureRBAC = &enableAzureRBAC
	} else {
		profile.EnableAzureRBAC = nil
	}

	// Managed
	if source.Managed != nil {
		managed := *source.Managed
		profile.Managed = &managed
	} else {
		profile.Managed = nil
	}

	// ServerAppID
	profile.ServerAppID = genruntime.ClonePointerToString(source.ServerAppID)

	// ServerAppSecret
	profile.ServerAppSecret = genruntime.ClonePointerToString(source.ServerAppSecret)

	// TenantID
	profile.TenantID = genruntime.ClonePointerToString(source.TenantID)

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterAADProfile_STATUS populates the provided destination ManagedClusterAADProfile_STATUS from our ManagedClusterAADProfile_STATUS
func (profile *ManagedClusterAADProfile_STATUS) AssignProperties_To_ManagedClusterAADProfile_STATUS(destination *storage.ManagedClusterAADProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdminGroupObjectIDs
	destination.AdminGroupObjectIDs = genruntime.CloneSliceOfString(profile.AdminGroupObjectIDs)

	// ClientAppID
	destination.ClientAppID = genruntime.ClonePointerToString(profile.ClientAppID)

	// EnableAzureRBAC
	if profile.EnableAzureRBAC != nil {
		enableAzureRBAC := *profile.EnableAzureRBAC
		destination.EnableAzureRBAC = &enableAzureRBAC
	} else {
		destination.EnableAzureRBAC = nil
	}

	// Managed
	if profile.Managed != nil {
		managed := *profile.Managed
		destination.Managed = &managed
	} else {
		destination.Managed = nil
	}

	// ServerAppID
	destination.ServerAppID = genruntime.ClonePointerToString(profile.ServerAppID)

	// ServerAppSecret
	destination.ServerAppSecret = genruntime.ClonePointerToString(profile.ServerAppSecret)

	// TenantID
	destination.TenantID = genruntime.ClonePointerToString(profile.TenantID)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterAddonProfile struct {
	Config map[string]string `json:"config,omitempty"`

	// +kubebuilder:validation:Required
	Enabled *bool `json:"enabled,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterAddonProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *ManagedClusterAddonProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.ManagedClusterAddonProfile{}

	// Set property "Config":
	if profile.Config != nil {
		result.Config = make(map[string]string, len(profile.Config))
		for key, value := range profile.Config {
			result.Config[key] = value
		}
	}

	// Set property "Enabled":
	if profile.Enabled != nil {
		enabled := *profile.Enabled
		result.Enabled = &enabled
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterAddonProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterAddonProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterAddonProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterAddonProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterAddonProfile, got %T", armInput)
	}

	// Set property "Config":
	if typedInput.Config != nil {
		profile.Config = make(map[string]string, len(typedInput.Config))
		for key, value := range typedInput.Config {
			profile.Config[key] = value
		}
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		profile.Enabled = &enabled
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterAddonProfile populates our ManagedClusterAddonProfile from the provided source ManagedClusterAddonProfile
func (profile *ManagedClusterAddonProfile) AssignProperties_From_ManagedClusterAddonProfile(source *storage.ManagedClusterAddonProfile) error {

	// Config
	profile.Config = genruntime.CloneMapOfStringToString(source.Config)

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		profile.Enabled = &enabled
	} else {
		profile.Enabled = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterAddonProfile populates the provided destination ManagedClusterAddonProfile from our ManagedClusterAddonProfile
func (profile *ManagedClusterAddonProfile) AssignProperties_To_ManagedClusterAddonProfile(destination *storage.ManagedClusterAddonProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Config
	destination.Config = genruntime.CloneMapOfStringToString(profile.Config)

	// Enabled
	if profile.Enabled != nil {
		enabled := *profile.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterAddonProfile_STATUS struct {
	Config   map[string]string            `json:"config,omitempty"`
	Enabled  *bool                        `json:"enabled,omitempty"`
	Identity *UserAssignedIdentity_STATUS `json:"identity,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterAddonProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterAddonProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterAddonProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterAddonProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterAddonProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterAddonProfile_STATUS, got %T", armInput)
	}

	// Set property "Config":
	if typedInput.Config != nil {
		profile.Config = make(map[string]string, len(typedInput.Config))
		for key, value := range typedInput.Config {
			profile.Config[key] = value
		}
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		profile.Enabled = &enabled
	}

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 UserAssignedIdentity_STATUS
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		profile.Identity = &identity
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterAddonProfile_STATUS populates our ManagedClusterAddonProfile_STATUS from the provided source ManagedClusterAddonProfile_STATUS
func (profile *ManagedClusterAddonProfile_STATUS) AssignProperties_From_ManagedClusterAddonProfile_STATUS(source *storage.ManagedClusterAddonProfile_STATUS) error {

	// Config
	profile.Config = genruntime.CloneMapOfStringToString(source.Config)

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		profile.Enabled = &enabled
	} else {
		profile.Enabled = nil
	}

	// Identity
	if source.Identity != nil {
		var identity UserAssignedIdentity_STATUS
		err := identity.AssignProperties_From_UserAssignedIdentity_STATUS(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UserAssignedIdentity_STATUS() to populate field Identity")
		}
		profile.Identity = &identity
	} else {
		profile.Identity = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterAddonProfile_STATUS populates the provided destination ManagedClusterAddonProfile_STATUS from our ManagedClusterAddonProfile_STATUS
func (profile *ManagedClusterAddonProfile_STATUS) AssignProperties_To_ManagedClusterAddonProfile_STATUS(destination *storage.ManagedClusterAddonProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Config
	destination.Config = genruntime.CloneMapOfStringToString(profile.Config)

	// Enabled
	if profile.Enabled != nil {
		enabled := *profile.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Identity
	if profile.Identity != nil {
		var identity storage.UserAssignedIdentity_STATUS
		err := profile.Identity.AssignProperties_To_UserAssignedIdentity_STATUS(&identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UserAssignedIdentity_STATUS() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterAgentPoolProfile struct {
	AvailabilityZones      []string            `json:"availabilityZones,omitempty"`
	Count                  *int                `json:"count,omitempty"`
	EnableAutoScaling      *bool               `json:"enableAutoScaling,omitempty"`
	EnableEncryptionAtHost *bool               `json:"enableEncryptionAtHost,omitempty"`
	EnableFIPS             *bool               `json:"enableFIPS,omitempty"`
	EnableNodePublicIP     *bool               `json:"enableNodePublicIP,omitempty"`
	EnableUltraSSD         *bool               `json:"enableUltraSSD,omitempty"`
	GpuInstanceProfile     *GPUInstanceProfile `json:"gpuInstanceProfile,omitempty"`
	KubeletConfig          *KubeletConfig      `json:"kubeletConfig,omitempty"`
	KubeletDiskType        *KubeletDiskType    `json:"kubeletDiskType,omitempty"`
	LinuxOSConfig          *LinuxOSConfig      `json:"linuxOSConfig,omitempty"`
	MaxCount               *int                `json:"maxCount,omitempty"`
	MaxPods                *int                `json:"maxPods,omitempty"`
	MinCount               *int                `json:"minCount,omitempty"`
	Mode                   *AgentPoolMode      `json:"mode,omitempty"`

	// +kubebuilder:validation:Pattern="^[a-z][a-z0-9]{0,11}$"
	Name                          *string                       `json:"name,omitempty"`
	NodeLabels                    map[string]string             `json:"nodeLabels,omitempty" serializationType:"explicitEmptyCollection"`
	NodePublicIPPrefixIDReference *genruntime.ResourceReference `armReference:"NodePublicIPPrefixID" json:"nodePublicIPPrefixIDReference,omitempty"`
	NodeTaints                    []string                      `json:"nodeTaints,omitempty" serializationType:"explicitEmptyCollection"`
	OrchestratorVersion           *string                       `json:"orchestratorVersion,omitempty"`
	OsDiskSizeGB                  *ContainerServiceOSDisk       `json:"osDiskSizeGB,omitempty"`
	OsDiskType                    *OSDiskType                   `json:"osDiskType,omitempty"`
	OsSKU                         *OSSKU                        `json:"osSKU,omitempty"`
	OsType                        *OSType                       `json:"osType,omitempty"`
	PodSubnetIDReference          *genruntime.ResourceReference `armReference:"PodSubnetID" json:"podSubnetIDReference,omitempty"`
	ProximityPlacementGroupID     *string                       `json:"proximityPlacementGroupID,omitempty"`
	ScaleSetEvictionPolicy        *ScaleSetEvictionPolicy       `json:"scaleSetEvictionPolicy,omitempty"`
	ScaleSetPriority              *ScaleSetPriority             `json:"scaleSetPriority,omitempty"`
	SpotMaxPrice                  *float64                      `json:"spotMaxPrice,omitempty"`
	Tags                          map[string]string             `json:"tags,omitempty" serializationType:"explicitEmptyCollection"`
	Type                          *AgentPoolType                `json:"type,omitempty"`
	UpgradeSettings               *AgentPoolUpgradeSettings     `json:"upgradeSettings,omitempty"`
	VmSize                        *string                       `json:"vmSize,omitempty"`
	VnetSubnetIDReference         *genruntime.ResourceReference `armReference:"VnetSubnetID" json:"vnetSubnetIDReference,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterAgentPoolProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *ManagedClusterAgentPoolProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.ManagedClusterAgentPoolProfile{}

	// Set property "AvailabilityZones":
	for _, item := range profile.AvailabilityZones {
		result.AvailabilityZones = append(result.AvailabilityZones, item)
	}

	// Set property "Count":
	if profile.Count != nil {
		count := *profile.Count
		result.Count = &count
	}

	// Set property "EnableAutoScaling":
	if profile.EnableAutoScaling != nil {
		enableAutoScaling := *profile.EnableAutoScaling
		result.EnableAutoScaling = &enableAutoScaling
	}

	// Set property "EnableEncryptionAtHost":
	if profile.EnableEncryptionAtHost != nil {
		enableEncryptionAtHost := *profile.EnableEncryptionAtHost
		result.EnableEncryptionAtHost = &enableEncryptionAtHost
	}

	// Set property "EnableFIPS":
	if profile.EnableFIPS != nil {
		enableFIPS := *profile.EnableFIPS
		result.EnableFIPS = &enableFIPS
	}

	// Set property "EnableNodePublicIP":
	if profile.EnableNodePublicIP != nil {
		enableNodePublicIP := *profile.EnableNodePublicIP
		result.EnableNodePublicIP = &enableNodePublicIP
	}

	// Set property "EnableUltraSSD":
	if profile.EnableUltraSSD != nil {
		enableUltraSSD := *profile.EnableUltraSSD
		result.EnableUltraSSD = &enableUltraSSD
	}

	// Set property "GpuInstanceProfile":
	if profile.GpuInstanceProfile != nil {
		var temp string
		temp = string(*profile.GpuInstanceProfile)
		gpuInstanceProfile := arm.GPUInstanceProfile(temp)
		result.GpuInstanceProfile = &gpuInstanceProfile
	}

	// Set property "KubeletConfig":
	if profile.KubeletConfig != nil {
		kubeletConfig_ARM, err := (*profile.KubeletConfig).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		kubeletConfig := *kubeletConfig_ARM.(*arm.KubeletConfig)
		result.KubeletConfig = &kubeletConfig
	}

	// Set property "KubeletDiskType":
	if profile.KubeletDiskType != nil {
		var temp string
		temp = string(*profile.KubeletDiskType)
		kubeletDiskType := arm.KubeletDiskType(temp)
		result.KubeletDiskType = &kubeletDiskType
	}

	// Set property "LinuxOSConfig":
	if profile.LinuxOSConfig != nil {
		linuxOSConfig_ARM, err := (*profile.LinuxOSConfig).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		linuxOSConfig := *linuxOSConfig_ARM.(*arm.LinuxOSConfig)
		result.LinuxOSConfig = &linuxOSConfig
	}

	// Set property "MaxCount":
	if profile.MaxCount != nil {
		maxCount := *profile.MaxCount
		result.MaxCount = &maxCount
	}

	// Set property "MaxPods":
	if profile.MaxPods != nil {
		maxPods := *profile.MaxPods
		result.MaxPods = &maxPods
	}

	// Set property "MinCount":
	if profile.MinCount != nil {
		minCount := *profile.MinCount
		result.MinCount = &minCount
	}

	// Set property "Mode":
	if profile.Mode != nil {
		var temp string
		temp = string(*profile.Mode)
		mode := arm.AgentPoolMode(temp)
		result.Mode = &mode
	}

	// Set property "Name":
	if profile.Name != nil {
		name := *profile.Name
		result.Name = &name
	}

	// Set property "NodeLabels":
	if profile.NodeLabels != nil {
		result.NodeLabels = make(map[string]string, len(profile.NodeLabels))
		for key, value := range profile.NodeLabels {
			result.NodeLabels[key] = value
		}
	} else {
		// Set property to empty map, as this resource is set to serialize all collections explicitly
		result.NodeLabels = make(map[string]string)
	}

	// Set property "NodePublicIPPrefixID":
	if profile.NodePublicIPPrefixIDReference != nil {
		nodePublicIPPrefixIDReferenceARMID, err := resolved.ResolvedReferences.Lookup(*profile.NodePublicIPPrefixIDReference)
		if err != nil {
			return nil, err
		}
		nodePublicIPPrefixIDReference := nodePublicIPPrefixIDReferenceARMID
		result.NodePublicIPPrefixID = &nodePublicIPPrefixIDReference
	}

	// Set property "NodeTaints":
	for _, item := range profile.NodeTaints {
		result.NodeTaints = append(result.NodeTaints, item)
	}
	if result.NodeTaints == nil {
		// Set property to empty map, as this resource is set to serialize all collections explicitly
		result.NodeTaints = []string{}
	}

	// Set property "OrchestratorVersion":
	if profile.OrchestratorVersion != nil {
		orchestratorVersion := *profile.OrchestratorVersion
		result.OrchestratorVersion = &orchestratorVersion
	}

	// Set property "OsDiskSizeGB":
	if profile.OsDiskSizeGB != nil {
		osDiskSizeGB := int(*profile.OsDiskSizeGB)
		result.OsDiskSizeGB = &osDiskSizeGB
	}

	// Set property "OsDiskType":
	if profile.OsDiskType != nil {
		var temp string
		temp = string(*profile.OsDiskType)
		osDiskType := arm.OSDiskType(temp)
		result.OsDiskType = &osDiskType
	}

	// Set property "OsSKU":
	if profile.OsSKU != nil {
		var temp string
		temp = string(*profile.OsSKU)
		osSKU := arm.OSSKU(temp)
		result.OsSKU = &osSKU
	}

	// Set property "OsType":
	if profile.OsType != nil {
		var temp string
		temp = string(*profile.OsType)
		osType := arm.OSType(temp)
		result.OsType = &osType
	}

	// Set property "PodSubnetID":
	if profile.PodSubnetIDReference != nil {
		podSubnetIDReferenceARMID, err := resolved.ResolvedReferences.Lookup(*profile.PodSubnetIDReference)
		if err != nil {
			return nil, err
		}
		podSubnetIDReference := podSubnetIDReferenceARMID
		result.PodSubnetID = &podSubnetIDReference
	}

	// Set property "ProximityPlacementGroupID":
	if profile.ProximityPlacementGroupID != nil {
		proximityPlacementGroupID := *profile.ProximityPlacementGroupID
		result.ProximityPlacementGroupID = &proximityPlacementGroupID
	}

	// Set property "ScaleSetEvictionPolicy":
	if profile.ScaleSetEvictionPolicy != nil {
		var temp string
		temp = string(*profile.ScaleSetEvictionPolicy)
		scaleSetEvictionPolicy := arm.ScaleSetEvictionPolicy(temp)
		result.ScaleSetEvictionPolicy = &scaleSetEvictionPolicy
	}

	// Set property "ScaleSetPriority":
	if profile.ScaleSetPriority != nil {
		var temp string
		temp = string(*profile.ScaleSetPriority)
		scaleSetPriority := arm.ScaleSetPriority(temp)
		result.ScaleSetPriority = &scaleSetPriority
	}

	// Set property "SpotMaxPrice":
	if profile.SpotMaxPrice != nil {
		spotMaxPrice := *profile.SpotMaxPrice
		result.SpotMaxPrice = &spotMaxPrice
	}

	// Set property "Tags":
	if profile.Tags != nil {
		result.Tags = make(map[string]string, len(profile.Tags))
		for key, value := range profile.Tags {
			result.Tags[key] = value
		}
	} else {
		// Set property to empty map, as this resource is set to serialize all collections explicitly
		result.Tags = make(map[string]string)
	}

	// Set property "Type":
	if profile.Type != nil {
		var temp string
		temp = string(*profile.Type)
		typeVar := arm.AgentPoolType(temp)
		result.Type = &typeVar
	}

	// Set property "UpgradeSettings":
	if profile.UpgradeSettings != nil {
		upgradeSettings_ARM, err := (*profile.UpgradeSettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		upgradeSettings := *upgradeSettings_ARM.(*arm.AgentPoolUpgradeSettings)
		result.UpgradeSettings = &upgradeSettings
	}

	// Set property "VmSize":
	if profile.VmSize != nil {
		vmSize := *profile.VmSize
		result.VmSize = &vmSize
	}

	// Set property "VnetSubnetID":
	if profile.VnetSubnetIDReference != nil {
		vnetSubnetIDReferenceARMID, err := resolved.ResolvedReferences.Lookup(*profile.VnetSubnetIDReference)
		if err != nil {
			return nil, err
		}
		vnetSubnetIDReference := vnetSubnetIDReferenceARMID
		result.VnetSubnetID = &vnetSubnetIDReference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterAgentPoolProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterAgentPoolProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterAgentPoolProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterAgentPoolProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterAgentPoolProfile, got %T", armInput)
	}

	// Set property "AvailabilityZones":
	for _, item := range typedInput.AvailabilityZones {
		profile.AvailabilityZones = append(profile.AvailabilityZones, item)
	}

	// Set property "Count":
	if typedInput.Count != nil {
		count := *typedInput.Count
		profile.Count = &count
	}

	// Set property "EnableAutoScaling":
	if typedInput.EnableAutoScaling != nil {
		enableAutoScaling := *typedInput.EnableAutoScaling
		profile.EnableAutoScaling = &enableAutoScaling
	}

	// Set property "EnableEncryptionAtHost":
	if typedInput.EnableEncryptionAtHost != nil {
		enableEncryptionAtHost := *typedInput.EnableEncryptionAtHost
		profile.EnableEncryptionAtHost = &enableEncryptionAtHost
	}

	// Set property "EnableFIPS":
	if typedInput.EnableFIPS != nil {
		enableFIPS := *typedInput.EnableFIPS
		profile.EnableFIPS = &enableFIPS
	}

	// Set property "EnableNodePublicIP":
	if typedInput.EnableNodePublicIP != nil {
		enableNodePublicIP := *typedInput.EnableNodePublicIP
		profile.EnableNodePublicIP = &enableNodePublicIP
	}

	// Set property "EnableUltraSSD":
	if typedInput.EnableUltraSSD != nil {
		enableUltraSSD := *typedInput.EnableUltraSSD
		profile.EnableUltraSSD = &enableUltraSSD
	}

	// Set property "GpuInstanceProfile":
	if typedInput.GpuInstanceProfile != nil {
		var temp string
		temp = string(*typedInput.GpuInstanceProfile)
		gpuInstanceProfile := GPUInstanceProfile(temp)
		profile.GpuInstanceProfile = &gpuInstanceProfile
	}

	// Set property "KubeletConfig":
	if typedInput.KubeletConfig != nil {
		var kubeletConfig1 KubeletConfig
		err := kubeletConfig1.PopulateFromARM(owner, *typedInput.KubeletConfig)
		if err != nil {
			return err
		}
		kubeletConfig := kubeletConfig1
		profile.KubeletConfig = &kubeletConfig
	}

	// Set property "KubeletDiskType":
	if typedInput.KubeletDiskType != nil {
		var temp string
		temp = string(*typedInput.KubeletDiskType)
		kubeletDiskType := KubeletDiskType(temp)
		profile.KubeletDiskType = &kubeletDiskType
	}

	// Set property "LinuxOSConfig":
	if typedInput.LinuxOSConfig != nil {
		var linuxOSConfig1 LinuxOSConfig
		err := linuxOSConfig1.PopulateFromARM(owner, *typedInput.LinuxOSConfig)
		if err != nil {
			return err
		}
		linuxOSConfig := linuxOSConfig1
		profile.LinuxOSConfig = &linuxOSConfig
	}

	// Set property "MaxCount":
	if typedInput.MaxCount != nil {
		maxCount := *typedInput.MaxCount
		profile.MaxCount = &maxCount
	}

	// Set property "MaxPods":
	if typedInput.MaxPods != nil {
		maxPods := *typedInput.MaxPods
		profile.MaxPods = &maxPods
	}

	// Set property "MinCount":
	if typedInput.MinCount != nil {
		minCount := *typedInput.MinCount
		profile.MinCount = &minCount
	}

	// Set property "Mode":
	if typedInput.Mode != nil {
		var temp string
		temp = string(*typedInput.Mode)
		mode := AgentPoolMode(temp)
		profile.Mode = &mode
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		profile.Name = &name
	}

	// Set property "NodeLabels":
	if typedInput.NodeLabels != nil {
		profile.NodeLabels = make(map[string]string, len(typedInput.NodeLabels))
		for key, value := range typedInput.NodeLabels {
			profile.NodeLabels[key] = value
		}
	} else {
		// Set property to empty map, as this resource is set to serialize all collections explicitly
		profile.NodeLabels = make(map[string]string)
	}

	// no assignment for property "NodePublicIPPrefixIDReference"

	// Set property "NodeTaints":
	for _, item := range typedInput.NodeTaints {
		profile.NodeTaints = append(profile.NodeTaints, item)
	}
	if profile.NodeTaints == nil {
		// Set property to empty map, as this resource is set to serialize all collections explicitly
		profile.NodeTaints = []string{}
	}

	// Set property "OrchestratorVersion":
	if typedInput.OrchestratorVersion != nil {
		orchestratorVersion := *typedInput.OrchestratorVersion
		profile.OrchestratorVersion = &orchestratorVersion
	}

	// Set property "OsDiskSizeGB":
	if typedInput.OsDiskSizeGB != nil {
		osDiskSizeGB := ContainerServiceOSDisk(*typedInput.OsDiskSizeGB)
		profile.OsDiskSizeGB = &osDiskSizeGB
	}

	// Set property "OsDiskType":
	if typedInput.OsDiskType != nil {
		var temp string
		temp = string(*typedInput.OsDiskType)
		osDiskType := OSDiskType(temp)
		profile.OsDiskType = &osDiskType
	}

	// Set property "OsSKU":
	if typedInput.OsSKU != nil {
		var temp string
		temp = string(*typedInput.OsSKU)
		osSKU := OSSKU(temp)
		profile.OsSKU = &osSKU
	}

	// Set property "OsType":
	if typedInput.OsType != nil {
		var temp string
		temp = string(*typedInput.OsType)
		osType := OSType(temp)
		profile.OsType = &osType
	}

	// no assignment for property "PodSubnetIDReference"

	// Set property "ProximityPlacementGroupID":
	if typedInput.ProximityPlacementGroupID != nil {
		proximityPlacementGroupID := *typedInput.ProximityPlacementGroupID
		profile.ProximityPlacementGroupID = &proximityPlacementGroupID
	}

	// Set property "ScaleSetEvictionPolicy":
	if typedInput.ScaleSetEvictionPolicy != nil {
		var temp string
		temp = string(*typedInput.ScaleSetEvictionPolicy)
		scaleSetEvictionPolicy := ScaleSetEvictionPolicy(temp)
		profile.ScaleSetEvictionPolicy = &scaleSetEvictionPolicy
	}

	// Set property "ScaleSetPriority":
	if typedInput.ScaleSetPriority != nil {
		var temp string
		temp = string(*typedInput.ScaleSetPriority)
		scaleSetPriority := ScaleSetPriority(temp)
		profile.ScaleSetPriority = &scaleSetPriority
	}

	// Set property "SpotMaxPrice":
	if typedInput.SpotMaxPrice != nil {
		spotMaxPrice := *typedInput.SpotMaxPrice
		profile.SpotMaxPrice = &spotMaxPrice
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		profile.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			profile.Tags[key] = value
		}
	} else {
		// Set property to empty map, as this resource is set to serialize all collections explicitly
		profile.Tags = make(map[string]string)
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := AgentPoolType(temp)
		profile.Type = &typeVar
	}

	// Set property "UpgradeSettings":
	if typedInput.UpgradeSettings != nil {
		var upgradeSettings1 AgentPoolUpgradeSettings
		err := upgradeSettings1.PopulateFromARM(owner, *typedInput.UpgradeSettings)
		if err != nil {
			return err
		}
		upgradeSettings := upgradeSettings1
		profile.UpgradeSettings = &upgradeSettings
	}

	// Set property "VmSize":
	if typedInput.VmSize != nil {
		vmSize := *typedInput.VmSize
		profile.VmSize = &vmSize
	}

	// no assignment for property "VnetSubnetIDReference"

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterAgentPoolProfile populates our ManagedClusterAgentPoolProfile from the provided source ManagedClusterAgentPoolProfile
func (profile *ManagedClusterAgentPoolProfile) AssignProperties_From_ManagedClusterAgentPoolProfile(source *storage.ManagedClusterAgentPoolProfile) error {

	// AvailabilityZones
	profile.AvailabilityZones = genruntime.CloneSliceOfString(source.AvailabilityZones)

	// Count
	profile.Count = genruntime.ClonePointerToInt(source.Count)

	// EnableAutoScaling
	if source.EnableAutoScaling != nil {
		enableAutoScaling := *source.EnableAutoScaling
		profile.EnableAutoScaling = &enableAutoScaling
	} else {
		profile.EnableAutoScaling = nil
	}

	// EnableEncryptionAtHost
	if source.EnableEncryptionAtHost != nil {
		enableEncryptionAtHost := *source.EnableEncryptionAtHost
		profile.EnableEncryptionAtHost = &enableEncryptionAtHost
	} else {
		profile.EnableEncryptionAtHost = nil
	}

	// EnableFIPS
	if source.EnableFIPS != nil {
		enableFIPS := *source.EnableFIPS
		profile.EnableFIPS = &enableFIPS
	} else {
		profile.EnableFIPS = nil
	}

	// EnableNodePublicIP
	if source.EnableNodePublicIP != nil {
		enableNodePublicIP := *source.EnableNodePublicIP
		profile.EnableNodePublicIP = &enableNodePublicIP
	} else {
		profile.EnableNodePublicIP = nil
	}

	// EnableUltraSSD
	if source.EnableUltraSSD != nil {
		enableUltraSSD := *source.EnableUltraSSD
		profile.EnableUltraSSD = &enableUltraSSD
	} else {
		profile.EnableUltraSSD = nil
	}

	// GpuInstanceProfile
	if source.GpuInstanceProfile != nil {
		gpuInstanceProfile := *source.GpuInstanceProfile
		gpuInstanceProfileTemp := genruntime.ToEnum(gpuInstanceProfile, gPUInstanceProfile_Values)
		profile.GpuInstanceProfile = &gpuInstanceProfileTemp
	} else {
		profile.GpuInstanceProfile = nil
	}

	// KubeletConfig
	if source.KubeletConfig != nil {
		var kubeletConfig KubeletConfig
		err := kubeletConfig.AssignProperties_From_KubeletConfig(source.KubeletConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_KubeletConfig() to populate field KubeletConfig")
		}
		profile.KubeletConfig = &kubeletConfig
	} else {
		profile.KubeletConfig = nil
	}

	// KubeletDiskType
	if source.KubeletDiskType != nil {
		kubeletDiskType := *source.KubeletDiskType
		kubeletDiskTypeTemp := genruntime.ToEnum(kubeletDiskType, kubeletDiskType_Values)
		profile.KubeletDiskType = &kubeletDiskTypeTemp
	} else {
		profile.KubeletDiskType = nil
	}

	// LinuxOSConfig
	if source.LinuxOSConfig != nil {
		var linuxOSConfig LinuxOSConfig
		err := linuxOSConfig.AssignProperties_From_LinuxOSConfig(source.LinuxOSConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_LinuxOSConfig() to populate field LinuxOSConfig")
		}
		profile.LinuxOSConfig = &linuxOSConfig
	} else {
		profile.LinuxOSConfig = nil
	}

	// MaxCount
	profile.MaxCount = genruntime.ClonePointerToInt(source.MaxCount)

	// MaxPods
	profile.MaxPods = genruntime.ClonePointerToInt(source.MaxPods)

	// MinCount
	profile.MinCount = genruntime.ClonePointerToInt(source.MinCount)

	// Mode
	if source.Mode != nil {
		mode := *source.Mode
		modeTemp := genruntime.ToEnum(mode, agentPoolMode_Values)
		profile.Mode = &modeTemp
	} else {
		profile.Mode = nil
	}

	// Name
	if source.Name != nil {
		name := *source.Name
		profile.Name = &name
	} else {
		profile.Name = nil
	}

	// NodeLabels
	profile.NodeLabels = genruntime.CloneMapOfStringToString(source.NodeLabels)

	// NodePublicIPPrefixIDReference
	if source.NodePublicIPPrefixIDReference != nil {
		nodePublicIPPrefixIDReference := source.NodePublicIPPrefixIDReference.Copy()
		profile.NodePublicIPPrefixIDReference = &nodePublicIPPrefixIDReference
	} else {
		profile.NodePublicIPPrefixIDReference = nil
	}

	// NodeTaints
	profile.NodeTaints = genruntime.CloneSliceOfString(source.NodeTaints)

	// OrchestratorVersion
	profile.OrchestratorVersion = genruntime.ClonePointerToString(source.OrchestratorVersion)

	// OsDiskSizeGB
	if source.OsDiskSizeGB != nil {
		osDiskSizeGB := ContainerServiceOSDisk(*source.OsDiskSizeGB)
		profile.OsDiskSizeGB = &osDiskSizeGB
	} else {
		profile.OsDiskSizeGB = nil
	}

	// OsDiskType
	if source.OsDiskType != nil {
		osDiskType := *source.OsDiskType
		osDiskTypeTemp := genruntime.ToEnum(osDiskType, oSDiskType_Values)
		profile.OsDiskType = &osDiskTypeTemp
	} else {
		profile.OsDiskType = nil
	}

	// OsSKU
	if source.OsSKU != nil {
		osSKU := *source.OsSKU
		osSKUTemp := genruntime.ToEnum(osSKU, oSSKU_Values)
		profile.OsSKU = &osSKUTemp
	} else {
		profile.OsSKU = nil
	}

	// OsType
	if source.OsType != nil {
		osType := *source.OsType
		osTypeTemp := genruntime.ToEnum(osType, oSType_Values)
		profile.OsType = &osTypeTemp
	} else {
		profile.OsType = nil
	}

	// PodSubnetIDReference
	if source.PodSubnetIDReference != nil {
		podSubnetIDReference := source.PodSubnetIDReference.Copy()
		profile.PodSubnetIDReference = &podSubnetIDReference
	} else {
		profile.PodSubnetIDReference = nil
	}

	// ProximityPlacementGroupID
	profile.ProximityPlacementGroupID = genruntime.ClonePointerToString(source.ProximityPlacementGroupID)

	// ScaleSetEvictionPolicy
	if source.ScaleSetEvictionPolicy != nil {
		scaleSetEvictionPolicy := *source.ScaleSetEvictionPolicy
		scaleSetEvictionPolicyTemp := genruntime.ToEnum(scaleSetEvictionPolicy, scaleSetEvictionPolicy_Values)
		profile.ScaleSetEvictionPolicy = &scaleSetEvictionPolicyTemp
	} else {
		profile.ScaleSetEvictionPolicy = nil
	}

	// ScaleSetPriority
	if source.ScaleSetPriority != nil {
		scaleSetPriority := *source.ScaleSetPriority
		scaleSetPriorityTemp := genruntime.ToEnum(scaleSetPriority, scaleSetPriority_Values)
		profile.ScaleSetPriority = &scaleSetPriorityTemp
	} else {
		profile.ScaleSetPriority = nil
	}

	// SpotMaxPrice
	if source.SpotMaxPrice != nil {
		spotMaxPrice := *source.SpotMaxPrice
		profile.SpotMaxPrice = &spotMaxPrice
	} else {
		profile.SpotMaxPrice = nil
	}

	// Tags
	profile.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, agentPoolType_Values)
		profile.Type = &typeTemp
	} else {
		profile.Type = nil
	}

	// UpgradeSettings
	if source.UpgradeSettings != nil {
		var upgradeSetting AgentPoolUpgradeSettings
		err := upgradeSetting.AssignProperties_From_AgentPoolUpgradeSettings(source.UpgradeSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AgentPoolUpgradeSettings() to populate field UpgradeSettings")
		}
		profile.UpgradeSettings = &upgradeSetting
	} else {
		profile.UpgradeSettings = nil
	}

	// VmSize
	profile.VmSize = genruntime.ClonePointerToString(source.VmSize)

	// VnetSubnetIDReference
	if source.VnetSubnetIDReference != nil {
		vnetSubnetIDReference := source.VnetSubnetIDReference.Copy()
		profile.VnetSubnetIDReference = &vnetSubnetIDReference
	} else {
		profile.VnetSubnetIDReference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterAgentPoolProfile populates the provided destination ManagedClusterAgentPoolProfile from our ManagedClusterAgentPoolProfile
func (profile *ManagedClusterAgentPoolProfile) AssignProperties_To_ManagedClusterAgentPoolProfile(destination *storage.ManagedClusterAgentPoolProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AvailabilityZones
	destination.AvailabilityZones = genruntime.CloneSliceOfString(profile.AvailabilityZones)

	// Count
	destination.Count = genruntime.ClonePointerToInt(profile.Count)

	// EnableAutoScaling
	if profile.EnableAutoScaling != nil {
		enableAutoScaling := *profile.EnableAutoScaling
		destination.EnableAutoScaling = &enableAutoScaling
	} else {
		destination.EnableAutoScaling = nil
	}

	// EnableEncryptionAtHost
	if profile.EnableEncryptionAtHost != nil {
		enableEncryptionAtHost := *profile.EnableEncryptionAtHost
		destination.EnableEncryptionAtHost = &enableEncryptionAtHost
	} else {
		destination.EnableEncryptionAtHost = nil
	}

	// EnableFIPS
	if profile.EnableFIPS != nil {
		enableFIPS := *profile.EnableFIPS
		destination.EnableFIPS = &enableFIPS
	} else {
		destination.EnableFIPS = nil
	}

	// EnableNodePublicIP
	if profile.EnableNodePublicIP != nil {
		enableNodePublicIP := *profile.EnableNodePublicIP
		destination.EnableNodePublicIP = &enableNodePublicIP
	} else {
		destination.EnableNodePublicIP = nil
	}

	// EnableUltraSSD
	if profile.EnableUltraSSD != nil {
		enableUltraSSD := *profile.EnableUltraSSD
		destination.EnableUltraSSD = &enableUltraSSD
	} else {
		destination.EnableUltraSSD = nil
	}

	// GpuInstanceProfile
	if profile.GpuInstanceProfile != nil {
		gpuInstanceProfile := string(*profile.GpuInstanceProfile)
		destination.GpuInstanceProfile = &gpuInstanceProfile
	} else {
		destination.GpuInstanceProfile = nil
	}

	// KubeletConfig
	if profile.KubeletConfig != nil {
		var kubeletConfig storage.KubeletConfig
		err := profile.KubeletConfig.AssignProperties_To_KubeletConfig(&kubeletConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_KubeletConfig() to populate field KubeletConfig")
		}
		destination.KubeletConfig = &kubeletConfig
	} else {
		destination.KubeletConfig = nil
	}

	// KubeletDiskType
	if profile.KubeletDiskType != nil {
		kubeletDiskType := string(*profile.KubeletDiskType)
		destination.KubeletDiskType = &kubeletDiskType
	} else {
		destination.KubeletDiskType = nil
	}

	// LinuxOSConfig
	if profile.LinuxOSConfig != nil {
		var linuxOSConfig storage.LinuxOSConfig
		err := profile.LinuxOSConfig.AssignProperties_To_LinuxOSConfig(&linuxOSConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_LinuxOSConfig() to populate field LinuxOSConfig")
		}
		destination.LinuxOSConfig = &linuxOSConfig
	} else {
		destination.LinuxOSConfig = nil
	}

	// MaxCount
	destination.MaxCount = genruntime.ClonePointerToInt(profile.MaxCount)

	// MaxPods
	destination.MaxPods = genruntime.ClonePointerToInt(profile.MaxPods)

	// MinCount
	destination.MinCount = genruntime.ClonePointerToInt(profile.MinCount)

	// Mode
	if profile.Mode != nil {
		mode := string(*profile.Mode)
		destination.Mode = &mode
	} else {
		destination.Mode = nil
	}

	// Name
	if profile.Name != nil {
		name := *profile.Name
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// NodeLabels
	destination.NodeLabels = genruntime.CloneMapOfStringToString(profile.NodeLabels)

	// NodePublicIPPrefixIDReference
	if profile.NodePublicIPPrefixIDReference != nil {
		nodePublicIPPrefixIDReference := profile.NodePublicIPPrefixIDReference.Copy()
		destination.NodePublicIPPrefixIDReference = &nodePublicIPPrefixIDReference
	} else {
		destination.NodePublicIPPrefixIDReference = nil
	}

	// NodeTaints
	destination.NodeTaints = genruntime.CloneSliceOfString(profile.NodeTaints)

	// OrchestratorVersion
	destination.OrchestratorVersion = genruntime.ClonePointerToString(profile.OrchestratorVersion)

	// OsDiskSizeGB
	if profile.OsDiskSizeGB != nil {
		osDiskSizeGB := int(*profile.OsDiskSizeGB)
		destination.OsDiskSizeGB = &osDiskSizeGB
	} else {
		destination.OsDiskSizeGB = nil
	}

	// OsDiskType
	if profile.OsDiskType != nil {
		osDiskType := string(*profile.OsDiskType)
		destination.OsDiskType = &osDiskType
	} else {
		destination.OsDiskType = nil
	}

	// OsSKU
	if profile.OsSKU != nil {
		osSKU := string(*profile.OsSKU)
		destination.OsSKU = &osSKU
	} else {
		destination.OsSKU = nil
	}

	// OsType
	if profile.OsType != nil {
		osType := string(*profile.OsType)
		destination.OsType = &osType
	} else {
		destination.OsType = nil
	}

	// PodSubnetIDReference
	if profile.PodSubnetIDReference != nil {
		podSubnetIDReference := profile.PodSubnetIDReference.Copy()
		destination.PodSubnetIDReference = &podSubnetIDReference
	} else {
		destination.PodSubnetIDReference = nil
	}

	// ProximityPlacementGroupID
	destination.ProximityPlacementGroupID = genruntime.ClonePointerToString(profile.ProximityPlacementGroupID)

	// ScaleSetEvictionPolicy
	if profile.ScaleSetEvictionPolicy != nil {
		scaleSetEvictionPolicy := string(*profile.ScaleSetEvictionPolicy)
		destination.ScaleSetEvictionPolicy = &scaleSetEvictionPolicy
	} else {
		destination.ScaleSetEvictionPolicy = nil
	}

	// ScaleSetPriority
	if profile.ScaleSetPriority != nil {
		scaleSetPriority := string(*profile.ScaleSetPriority)
		destination.ScaleSetPriority = &scaleSetPriority
	} else {
		destination.ScaleSetPriority = nil
	}

	// SpotMaxPrice
	if profile.SpotMaxPrice != nil {
		spotMaxPrice := *profile.SpotMaxPrice
		destination.SpotMaxPrice = &spotMaxPrice
	} else {
		destination.SpotMaxPrice = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(profile.Tags)

	// Type
	if profile.Type != nil {
		typeVar := string(*profile.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// UpgradeSettings
	if profile.UpgradeSettings != nil {
		var upgradeSetting storage.AgentPoolUpgradeSettings
		err := profile.UpgradeSettings.AssignProperties_To_AgentPoolUpgradeSettings(&upgradeSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AgentPoolUpgradeSettings() to populate field UpgradeSettings")
		}
		destination.UpgradeSettings = &upgradeSetting
	} else {
		destination.UpgradeSettings = nil
	}

	// VmSize
	destination.VmSize = genruntime.ClonePointerToString(profile.VmSize)

	// VnetSubnetIDReference
	if profile.VnetSubnetIDReference != nil {
		vnetSubnetIDReference := profile.VnetSubnetIDReference.Copy()
		destination.VnetSubnetIDReference = &vnetSubnetIDReference
	} else {
		destination.VnetSubnetIDReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterAgentPoolProfile_STATUS struct {
	AvailabilityZones         []string                         `json:"availabilityZones,omitempty"`
	Count                     *int                             `json:"count,omitempty"`
	EnableAutoScaling         *bool                            `json:"enableAutoScaling,omitempty"`
	EnableEncryptionAtHost    *bool                            `json:"enableEncryptionAtHost,omitempty"`
	EnableFIPS                *bool                            `json:"enableFIPS,omitempty"`
	EnableNodePublicIP        *bool                            `json:"enableNodePublicIP,omitempty"`
	EnableUltraSSD            *bool                            `json:"enableUltraSSD,omitempty"`
	GpuInstanceProfile        *GPUInstanceProfile_STATUS       `json:"gpuInstanceProfile,omitempty"`
	KubeletConfig             *KubeletConfig_STATUS            `json:"kubeletConfig,omitempty"`
	KubeletDiskType           *KubeletDiskType_STATUS          `json:"kubeletDiskType,omitempty"`
	LinuxOSConfig             *LinuxOSConfig_STATUS            `json:"linuxOSConfig,omitempty"`
	MaxCount                  *int                             `json:"maxCount,omitempty"`
	MaxPods                   *int                             `json:"maxPods,omitempty"`
	MinCount                  *int                             `json:"minCount,omitempty"`
	Mode                      *AgentPoolMode_STATUS            `json:"mode,omitempty"`
	Name                      *string                          `json:"name,omitempty"`
	NodeImageVersion          *string                          `json:"nodeImageVersion,omitempty"`
	NodeLabels                map[string]string                `json:"nodeLabels,omitempty"`
	NodePublicIPPrefixID      *string                          `json:"nodePublicIPPrefixID,omitempty"`
	NodeTaints                []string                         `json:"nodeTaints,omitempty"`
	OrchestratorVersion       *string                          `json:"orchestratorVersion,omitempty"`
	OsDiskSizeGB              *int                             `json:"osDiskSizeGB,omitempty"`
	OsDiskType                *OSDiskType_STATUS               `json:"osDiskType,omitempty"`
	OsSKU                     *OSSKU_STATUS                    `json:"osSKU,omitempty"`
	OsType                    *OSType_STATUS                   `json:"osType,omitempty"`
	PodSubnetID               *string                          `json:"podSubnetID,omitempty"`
	PowerState                *PowerState_STATUS               `json:"powerState,omitempty"`
	ProvisioningState         *string                          `json:"provisioningState,omitempty"`
	ProximityPlacementGroupID *string                          `json:"proximityPlacementGroupID,omitempty"`
	ScaleSetEvictionPolicy    *ScaleSetEvictionPolicy_STATUS   `json:"scaleSetEvictionPolicy,omitempty"`
	ScaleSetPriority          *ScaleSetPriority_STATUS         `json:"scaleSetPriority,omitempty"`
	SpotMaxPrice              *float64                         `json:"spotMaxPrice,omitempty"`
	Tags                      map[string]string                `json:"tags,omitempty"`
	Type                      *AgentPoolType_STATUS            `json:"type,omitempty"`
	UpgradeSettings           *AgentPoolUpgradeSettings_STATUS `json:"upgradeSettings,omitempty"`
	VmSize                    *string                          `json:"vmSize,omitempty"`
	VnetSubnetID              *string                          `json:"vnetSubnetID,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterAgentPoolProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterAgentPoolProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterAgentPoolProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterAgentPoolProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterAgentPoolProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterAgentPoolProfile_STATUS, got %T", armInput)
	}

	// Set property "AvailabilityZones":
	for _, item := range typedInput.AvailabilityZones {
		profile.AvailabilityZones = append(profile.AvailabilityZones, item)
	}

	// Set property "Count":
	if typedInput.Count != nil {
		count := *typedInput.Count
		profile.Count = &count
	}

	// Set property "EnableAutoScaling":
	if typedInput.EnableAutoScaling != nil {
		enableAutoScaling := *typedInput.EnableAutoScaling
		profile.EnableAutoScaling = &enableAutoScaling
	}

	// Set property "EnableEncryptionAtHost":
	if typedInput.EnableEncryptionAtHost != nil {
		enableEncryptionAtHost := *typedInput.EnableEncryptionAtHost
		profile.EnableEncryptionAtHost = &enableEncryptionAtHost
	}

	// Set property "EnableFIPS":
	if typedInput.EnableFIPS != nil {
		enableFIPS := *typedInput.EnableFIPS
		profile.EnableFIPS = &enableFIPS
	}

	// Set property "EnableNodePublicIP":
	if typedInput.EnableNodePublicIP != nil {
		enableNodePublicIP := *typedInput.EnableNodePublicIP
		profile.EnableNodePublicIP = &enableNodePublicIP
	}

	// Set property "EnableUltraSSD":
	if typedInput.EnableUltraSSD != nil {
		enableUltraSSD := *typedInput.EnableUltraSSD
		profile.EnableUltraSSD = &enableUltraSSD
	}

	// Set property "GpuInstanceProfile":
	if typedInput.GpuInstanceProfile != nil {
		var temp string
		temp = string(*typedInput.GpuInstanceProfile)
		gpuInstanceProfile := GPUInstanceProfile_STATUS(temp)
		profile.GpuInstanceProfile = &gpuInstanceProfile
	}

	// Set property "KubeletConfig":
	if typedInput.KubeletConfig != nil {
		var kubeletConfig1 KubeletConfig_STATUS
		err := kubeletConfig1.PopulateFromARM(owner, *typedInput.KubeletConfig)
		if err != nil {
			return err
		}
		kubeletConfig := kubeletConfig1
		profile.KubeletConfig = &kubeletConfig
	}

	// Set property "KubeletDiskType":
	if typedInput.KubeletDiskType != nil {
		var temp string
		temp = string(*typedInput.KubeletDiskType)
		kubeletDiskType := KubeletDiskType_STATUS(temp)
		profile.KubeletDiskType = &kubeletDiskType
	}

	// Set property "LinuxOSConfig":
	if typedInput.LinuxOSConfig != nil {
		var linuxOSConfig1 LinuxOSConfig_STATUS
		err := linuxOSConfig1.PopulateFromARM(owner, *typedInput.LinuxOSConfig)
		if err != nil {
			return err
		}
		linuxOSConfig := linuxOSConfig1
		profile.LinuxOSConfig = &linuxOSConfig
	}

	// Set property "MaxCount":
	if typedInput.MaxCount != nil {
		maxCount := *typedInput.MaxCount
		profile.MaxCount = &maxCount
	}

	// Set property "MaxPods":
	if typedInput.MaxPods != nil {
		maxPods := *typedInput.MaxPods
		profile.MaxPods = &maxPods
	}

	// Set property "MinCount":
	if typedInput.MinCount != nil {
		minCount := *typedInput.MinCount
		profile.MinCount = &minCount
	}

	// Set property "Mode":
	if typedInput.Mode != nil {
		var temp string
		temp = string(*typedInput.Mode)
		mode := AgentPoolMode_STATUS(temp)
		profile.Mode = &mode
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		profile.Name = &name
	}

	// Set property "NodeImageVersion":
	if typedInput.NodeImageVersion != nil {
		nodeImageVersion := *typedInput.NodeImageVersion
		profile.NodeImageVersion = &nodeImageVersion
	}

	// Set property "NodeLabels":
	if typedInput.NodeLabels != nil {
		profile.NodeLabels = make(map[string]string, len(typedInput.NodeLabels))
		for key, value := range typedInput.NodeLabels {
			profile.NodeLabels[key] = value
		}
	}

	// Set property "NodePublicIPPrefixID":
	if typedInput.NodePublicIPPrefixID != nil {
		nodePublicIPPrefixID := *typedInput.NodePublicIPPrefixID
		profile.NodePublicIPPrefixID = &nodePublicIPPrefixID
	}

	// Set property "NodeTaints":
	for _, item := range typedInput.NodeTaints {
		profile.NodeTaints = append(profile.NodeTaints, item)
	}

	// Set property "OrchestratorVersion":
	if typedInput.OrchestratorVersion != nil {
		orchestratorVersion := *typedInput.OrchestratorVersion
		profile.OrchestratorVersion = &orchestratorVersion
	}

	// Set property "OsDiskSizeGB":
	if typedInput.OsDiskSizeGB != nil {
		osDiskSizeGB := *typedInput.OsDiskSizeGB
		profile.OsDiskSizeGB = &osDiskSizeGB
	}

	// Set property "OsDiskType":
	if typedInput.OsDiskType != nil {
		var temp string
		temp = string(*typedInput.OsDiskType)
		osDiskType := OSDiskType_STATUS(temp)
		profile.OsDiskType = &osDiskType
	}

	// Set property "OsSKU":
	if typedInput.OsSKU != nil {
		var temp string
		temp = string(*typedInput.OsSKU)
		osSKU := OSSKU_STATUS(temp)
		profile.OsSKU = &osSKU
	}

	// Set property "OsType":
	if typedInput.OsType != nil {
		var temp string
		temp = string(*typedInput.OsType)
		osType := OSType_STATUS(temp)
		profile.OsType = &osType
	}

	// Set property "PodSubnetID":
	if typedInput.PodSubnetID != nil {
		podSubnetID := *typedInput.PodSubnetID
		profile.PodSubnetID = &podSubnetID
	}

	// Set property "PowerState":
	if typedInput.PowerState != nil {
		var powerState1 PowerState_STATUS
		err := powerState1.PopulateFromARM(owner, *typedInput.PowerState)
		if err != nil {
			return err
		}
		powerState := powerState1
		profile.PowerState = &powerState
	}

	// Set property "ProvisioningState":
	if typedInput.ProvisioningState != nil {
		provisioningState := *typedInput.ProvisioningState
		profile.ProvisioningState = &provisioningState
	}

	// Set property "ProximityPlacementGroupID":
	if typedInput.ProximityPlacementGroupID != nil {
		proximityPlacementGroupID := *typedInput.ProximityPlacementGroupID
		profile.ProximityPlacementGroupID = &proximityPlacementGroupID
	}

	// Set property "ScaleSetEvictionPolicy":
	if typedInput.ScaleSetEvictionPolicy != nil {
		var temp string
		temp = string(*typedInput.ScaleSetEvictionPolicy)
		scaleSetEvictionPolicy := ScaleSetEvictionPolicy_STATUS(temp)
		profile.ScaleSetEvictionPolicy = &scaleSetEvictionPolicy
	}

	// Set property "ScaleSetPriority":
	if typedInput.ScaleSetPriority != nil {
		var temp string
		temp = string(*typedInput.ScaleSetPriority)
		scaleSetPriority := ScaleSetPriority_STATUS(temp)
		profile.ScaleSetPriority = &scaleSetPriority
	}

	// Set property "SpotMaxPrice":
	if typedInput.SpotMaxPrice != nil {
		spotMaxPrice := *typedInput.SpotMaxPrice
		profile.SpotMaxPrice = &spotMaxPrice
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		profile.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			profile.Tags[key] = value
		}
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := AgentPoolType_STATUS(temp)
		profile.Type = &typeVar
	}

	// Set property "UpgradeSettings":
	if typedInput.UpgradeSettings != nil {
		var upgradeSettings1 AgentPoolUpgradeSettings_STATUS
		err := upgradeSettings1.PopulateFromARM(owner, *typedInput.UpgradeSettings)
		if err != nil {
			return err
		}
		upgradeSettings := upgradeSettings1
		profile.UpgradeSettings = &upgradeSettings
	}

	// Set property "VmSize":
	if typedInput.VmSize != nil {
		vmSize := *typedInput.VmSize
		profile.VmSize = &vmSize
	}

	// Set property "VnetSubnetID":
	if typedInput.VnetSubnetID != nil {
		vnetSubnetID := *typedInput.VnetSubnetID
		profile.VnetSubnetID = &vnetSubnetID
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterAgentPoolProfile_STATUS populates our ManagedClusterAgentPoolProfile_STATUS from the provided source ManagedClusterAgentPoolProfile_STATUS
func (profile *ManagedClusterAgentPoolProfile_STATUS) AssignProperties_From_ManagedClusterAgentPoolProfile_STATUS(source *storage.ManagedClusterAgentPoolProfile_STATUS) error {

	// AvailabilityZones
	profile.AvailabilityZones = genruntime.CloneSliceOfString(source.AvailabilityZones)

	// Count
	profile.Count = genruntime.ClonePointerToInt(source.Count)

	// EnableAutoScaling
	if source.EnableAutoScaling != nil {
		enableAutoScaling := *source.EnableAutoScaling
		profile.EnableAutoScaling = &enableAutoScaling
	} else {
		profile.EnableAutoScaling = nil
	}

	// EnableEncryptionAtHost
	if source.EnableEncryptionAtHost != nil {
		enableEncryptionAtHost := *source.EnableEncryptionAtHost
		profile.EnableEncryptionAtHost = &enableEncryptionAtHost
	} else {
		profile.EnableEncryptionAtHost = nil
	}

	// EnableFIPS
	if source.EnableFIPS != nil {
		enableFIPS := *source.EnableFIPS
		profile.EnableFIPS = &enableFIPS
	} else {
		profile.EnableFIPS = nil
	}

	// EnableNodePublicIP
	if source.EnableNodePublicIP != nil {
		enableNodePublicIP := *source.EnableNodePublicIP
		profile.EnableNodePublicIP = &enableNodePublicIP
	} else {
		profile.EnableNodePublicIP = nil
	}

	// EnableUltraSSD
	if source.EnableUltraSSD != nil {
		enableUltraSSD := *source.EnableUltraSSD
		profile.EnableUltraSSD = &enableUltraSSD
	} else {
		profile.EnableUltraSSD = nil
	}

	// GpuInstanceProfile
	if source.GpuInstanceProfile != nil {
		gpuInstanceProfile := *source.GpuInstanceProfile
		gpuInstanceProfileTemp := genruntime.ToEnum(gpuInstanceProfile, gPUInstanceProfile_STATUS_Values)
		profile.GpuInstanceProfile = &gpuInstanceProfileTemp
	} else {
		profile.GpuInstanceProfile = nil
	}

	// KubeletConfig
	if source.KubeletConfig != nil {
		var kubeletConfig KubeletConfig_STATUS
		err := kubeletConfig.AssignProperties_From_KubeletConfig_STATUS(source.KubeletConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_KubeletConfig_STATUS() to populate field KubeletConfig")
		}
		profile.KubeletConfig = &kubeletConfig
	} else {
		profile.KubeletConfig = nil
	}

	// KubeletDiskType
	if source.KubeletDiskType != nil {
		kubeletDiskType := *source.KubeletDiskType
		kubeletDiskTypeTemp := genruntime.ToEnum(kubeletDiskType, kubeletDiskType_STATUS_Values)
		profile.KubeletDiskType = &kubeletDiskTypeTemp
	} else {
		profile.KubeletDiskType = nil
	}

	// LinuxOSConfig
	if source.LinuxOSConfig != nil {
		var linuxOSConfig LinuxOSConfig_STATUS
		err := linuxOSConfig.AssignProperties_From_LinuxOSConfig_STATUS(source.LinuxOSConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_LinuxOSConfig_STATUS() to populate field LinuxOSConfig")
		}
		profile.LinuxOSConfig = &linuxOSConfig
	} else {
		profile.LinuxOSConfig = nil
	}

	// MaxCount
	profile.MaxCount = genruntime.ClonePointerToInt(source.MaxCount)

	// MaxPods
	profile.MaxPods = genruntime.ClonePointerToInt(source.MaxPods)

	// MinCount
	profile.MinCount = genruntime.ClonePointerToInt(source.MinCount)

	// Mode
	if source.Mode != nil {
		mode := *source.Mode
		modeTemp := genruntime.ToEnum(mode, agentPoolMode_STATUS_Values)
		profile.Mode = &modeTemp
	} else {
		profile.Mode = nil
	}

	// Name
	profile.Name = genruntime.ClonePointerToString(source.Name)

	// NodeImageVersion
	profile.NodeImageVersion = genruntime.ClonePointerToString(source.NodeImageVersion)

	// NodeLabels
	profile.NodeLabels = genruntime.CloneMapOfStringToString(source.NodeLabels)

	// NodePublicIPPrefixID
	profile.NodePublicIPPrefixID = genruntime.ClonePointerToString(source.NodePublicIPPrefixID)

	// NodeTaints
	profile.NodeTaints = genruntime.CloneSliceOfString(source.NodeTaints)

	// OrchestratorVersion
	profile.OrchestratorVersion = genruntime.ClonePointerToString(source.OrchestratorVersion)

	// OsDiskSizeGB
	profile.OsDiskSizeGB = genruntime.ClonePointerToInt(source.OsDiskSizeGB)

	// OsDiskType
	if source.OsDiskType != nil {
		osDiskType := *source.OsDiskType
		osDiskTypeTemp := genruntime.ToEnum(osDiskType, oSDiskType_STATUS_Values)
		profile.OsDiskType = &osDiskTypeTemp
	} else {
		profile.OsDiskType = nil
	}

	// OsSKU
	if source.OsSKU != nil {
		osSKU := *source.OsSKU
		osSKUTemp := genruntime.ToEnum(osSKU, oSSKU_STATUS_Values)
		profile.OsSKU = &osSKUTemp
	} else {
		profile.OsSKU = nil
	}

	// OsType
	if source.OsType != nil {
		osType := *source.OsType
		osTypeTemp := genruntime.ToEnum(osType, oSType_STATUS_Values)
		profile.OsType = &osTypeTemp
	} else {
		profile.OsType = nil
	}

	// PodSubnetID
	profile.PodSubnetID = genruntime.ClonePointerToString(source.PodSubnetID)

	// PowerState
	if source.PowerState != nil {
		var powerState PowerState_STATUS
		err := powerState.AssignProperties_From_PowerState_STATUS(source.PowerState)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_PowerState_STATUS() to populate field PowerState")
		}
		profile.PowerState = &powerState
	} else {
		profile.PowerState = nil
	}

	// ProvisioningState
	profile.ProvisioningState = genruntime.ClonePointerToString(source.ProvisioningState)

	// ProximityPlacementGroupID
	profile.ProximityPlacementGroupID = genruntime.ClonePointerToString(source.ProximityPlacementGroupID)

	// ScaleSetEvictionPolicy
	if source.ScaleSetEvictionPolicy != nil {
		scaleSetEvictionPolicy := *source.ScaleSetEvictionPolicy
		scaleSetEvictionPolicyTemp := genruntime.ToEnum(scaleSetEvictionPolicy, scaleSetEvictionPolicy_STATUS_Values)
		profile.ScaleSetEvictionPolicy = &scaleSetEvictionPolicyTemp
	} else {
		profile.ScaleSetEvictionPolicy = nil
	}

	// ScaleSetPriority
	if source.ScaleSetPriority != nil {
		scaleSetPriority := *source.ScaleSetPriority
		scaleSetPriorityTemp := genruntime.ToEnum(scaleSetPriority, scaleSetPriority_STATUS_Values)
		profile.ScaleSetPriority = &scaleSetPriorityTemp
	} else {
		profile.ScaleSetPriority = nil
	}

	// SpotMaxPrice
	if source.SpotMaxPrice != nil {
		spotMaxPrice := *source.SpotMaxPrice
		profile.SpotMaxPrice = &spotMaxPrice
	} else {
		profile.SpotMaxPrice = nil
	}

	// Tags
	profile.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, agentPoolType_STATUS_Values)
		profile.Type = &typeTemp
	} else {
		profile.Type = nil
	}

	// UpgradeSettings
	if source.UpgradeSettings != nil {
		var upgradeSetting AgentPoolUpgradeSettings_STATUS
		err := upgradeSetting.AssignProperties_From_AgentPoolUpgradeSettings_STATUS(source.UpgradeSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AgentPoolUpgradeSettings_STATUS() to populate field UpgradeSettings")
		}
		profile.UpgradeSettings = &upgradeSetting
	} else {
		profile.UpgradeSettings = nil
	}

	// VmSize
	profile.VmSize = genruntime.ClonePointerToString(source.VmSize)

	// VnetSubnetID
	profile.VnetSubnetID = genruntime.ClonePointerToString(source.VnetSubnetID)

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterAgentPoolProfile_STATUS populates the provided destination ManagedClusterAgentPoolProfile_STATUS from our ManagedClusterAgentPoolProfile_STATUS
func (profile *ManagedClusterAgentPoolProfile_STATUS) AssignProperties_To_ManagedClusterAgentPoolProfile_STATUS(destination *storage.ManagedClusterAgentPoolProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AvailabilityZones
	destination.AvailabilityZones = genruntime.CloneSliceOfString(profile.AvailabilityZones)

	// Count
	destination.Count = genruntime.ClonePointerToInt(profile.Count)

	// EnableAutoScaling
	if profile.EnableAutoScaling != nil {
		enableAutoScaling := *profile.EnableAutoScaling
		destination.EnableAutoScaling = &enableAutoScaling
	} else {
		destination.EnableAutoScaling = nil
	}

	// EnableEncryptionAtHost
	if profile.EnableEncryptionAtHost != nil {
		enableEncryptionAtHost := *profile.EnableEncryptionAtHost
		destination.EnableEncryptionAtHost = &enableEncryptionAtHost
	} else {
		destination.EnableEncryptionAtHost = nil
	}

	// EnableFIPS
	if profile.EnableFIPS != nil {
		enableFIPS := *profile.EnableFIPS
		destination.EnableFIPS = &enableFIPS
	} else {
		destination.EnableFIPS = nil
	}

	// EnableNodePublicIP
	if profile.EnableNodePublicIP != nil {
		enableNodePublicIP := *profile.EnableNodePublicIP
		destination.EnableNodePublicIP = &enableNodePublicIP
	} else {
		destination.EnableNodePublicIP = nil
	}

	// EnableUltraSSD
	if profile.EnableUltraSSD != nil {
		enableUltraSSD := *profile.EnableUltraSSD
		destination.EnableUltraSSD = &enableUltraSSD
	} else {
		destination.EnableUltraSSD = nil
	}

	// GpuInstanceProfile
	if profile.GpuInstanceProfile != nil {
		gpuInstanceProfile := string(*profile.GpuInstanceProfile)
		destination.GpuInstanceProfile = &gpuInstanceProfile
	} else {
		destination.GpuInstanceProfile = nil
	}

	// KubeletConfig
	if profile.KubeletConfig != nil {
		var kubeletConfig storage.KubeletConfig_STATUS
		err := profile.KubeletConfig.AssignProperties_To_KubeletConfig_STATUS(&kubeletConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_KubeletConfig_STATUS() to populate field KubeletConfig")
		}
		destination.KubeletConfig = &kubeletConfig
	} else {
		destination.KubeletConfig = nil
	}

	// KubeletDiskType
	if profile.KubeletDiskType != nil {
		kubeletDiskType := string(*profile.KubeletDiskType)
		destination.KubeletDiskType = &kubeletDiskType
	} else {
		destination.KubeletDiskType = nil
	}

	// LinuxOSConfig
	if profile.LinuxOSConfig != nil {
		var linuxOSConfig storage.LinuxOSConfig_STATUS
		err := profile.LinuxOSConfig.AssignProperties_To_LinuxOSConfig_STATUS(&linuxOSConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_LinuxOSConfig_STATUS() to populate field LinuxOSConfig")
		}
		destination.LinuxOSConfig = &linuxOSConfig
	} else {
		destination.LinuxOSConfig = nil
	}

	// MaxCount
	destination.MaxCount = genruntime.ClonePointerToInt(profile.MaxCount)

	// MaxPods
	destination.MaxPods = genruntime.ClonePointerToInt(profile.MaxPods)

	// MinCount
	destination.MinCount = genruntime.ClonePointerToInt(profile.MinCount)

	// Mode
	if profile.Mode != nil {
		mode := string(*profile.Mode)
		destination.Mode = &mode
	} else {
		destination.Mode = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(profile.Name)

	// NodeImageVersion
	destination.NodeImageVersion = genruntime.ClonePointerToString(profile.NodeImageVersion)

	// NodeLabels
	destination.NodeLabels = genruntime.CloneMapOfStringToString(profile.NodeLabels)

	// NodePublicIPPrefixID
	destination.NodePublicIPPrefixID = genruntime.ClonePointerToString(profile.NodePublicIPPrefixID)

	// NodeTaints
	destination.NodeTaints = genruntime.CloneSliceOfString(profile.NodeTaints)

	// OrchestratorVersion
	destination.OrchestratorVersion = genruntime.ClonePointerToString(profile.OrchestratorVersion)

	// OsDiskSizeGB
	destination.OsDiskSizeGB = genruntime.ClonePointerToInt(profile.OsDiskSizeGB)

	// OsDiskType
	if profile.OsDiskType != nil {
		osDiskType := string(*profile.OsDiskType)
		destination.OsDiskType = &osDiskType
	} else {
		destination.OsDiskType = nil
	}

	// OsSKU
	if profile.OsSKU != nil {
		osSKU := string(*profile.OsSKU)
		destination.OsSKU = &osSKU
	} else {
		destination.OsSKU = nil
	}

	// OsType
	if profile.OsType != nil {
		osType := string(*profile.OsType)
		destination.OsType = &osType
	} else {
		destination.OsType = nil
	}

	// PodSubnetID
	destination.PodSubnetID = genruntime.ClonePointerToString(profile.PodSubnetID)

	// PowerState
	if profile.PowerState != nil {
		var powerState storage.PowerState_STATUS
		err := profile.PowerState.AssignProperties_To_PowerState_STATUS(&powerState)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_PowerState_STATUS() to populate field PowerState")
		}
		destination.PowerState = &powerState
	} else {
		destination.PowerState = nil
	}

	// ProvisioningState
	destination.ProvisioningState = genruntime.ClonePointerToString(profile.ProvisioningState)

	// ProximityPlacementGroupID
	destination.ProximityPlacementGroupID = genruntime.ClonePointerToString(profile.ProximityPlacementGroupID)

	// ScaleSetEvictionPolicy
	if profile.ScaleSetEvictionPolicy != nil {
		scaleSetEvictionPolicy := string(*profile.ScaleSetEvictionPolicy)
		destination.ScaleSetEvictionPolicy = &scaleSetEvictionPolicy
	} else {
		destination.ScaleSetEvictionPolicy = nil
	}

	// ScaleSetPriority
	if profile.ScaleSetPriority != nil {
		scaleSetPriority := string(*profile.ScaleSetPriority)
		destination.ScaleSetPriority = &scaleSetPriority
	} else {
		destination.ScaleSetPriority = nil
	}

	// SpotMaxPrice
	if profile.SpotMaxPrice != nil {
		spotMaxPrice := *profile.SpotMaxPrice
		destination.SpotMaxPrice = &spotMaxPrice
	} else {
		destination.SpotMaxPrice = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(profile.Tags)

	// Type
	if profile.Type != nil {
		typeVar := string(*profile.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// UpgradeSettings
	if profile.UpgradeSettings != nil {
		var upgradeSetting storage.AgentPoolUpgradeSettings_STATUS
		err := profile.UpgradeSettings.AssignProperties_To_AgentPoolUpgradeSettings_STATUS(&upgradeSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AgentPoolUpgradeSettings_STATUS() to populate field UpgradeSettings")
		}
		destination.UpgradeSettings = &upgradeSetting
	} else {
		destination.UpgradeSettings = nil
	}

	// VmSize
	destination.VmSize = genruntime.ClonePointerToString(profile.VmSize)

	// VnetSubnetID
	destination.VnetSubnetID = genruntime.ClonePointerToString(profile.VnetSubnetID)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterAPIServerAccessProfile struct {
	AuthorizedIPRanges             []string `json:"authorizedIPRanges,omitempty"`
	EnablePrivateCluster           *bool    `json:"enablePrivateCluster,omitempty"`
	EnablePrivateClusterPublicFQDN *bool    `json:"enablePrivateClusterPublicFQDN,omitempty"`
	PrivateDNSZone                 *string  `json:"privateDNSZone,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterAPIServerAccessProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *ManagedClusterAPIServerAccessProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.ManagedClusterAPIServerAccessProfile{}

	// Set property "AuthorizedIPRanges":
	for _, item := range profile.AuthorizedIPRanges {
		result.AuthorizedIPRanges = append(result.AuthorizedIPRanges, item)
	}

	// Set property "EnablePrivateCluster":
	if profile.EnablePrivateCluster != nil {
		enablePrivateCluster := *profile.EnablePrivateCluster
		result.EnablePrivateCluster = &enablePrivateCluster
	}

	// Set property "EnablePrivateClusterPublicFQDN":
	if profile.EnablePrivateClusterPublicFQDN != nil {
		enablePrivateClusterPublicFQDN := *profile.EnablePrivateClusterPublicFQDN
		result.EnablePrivateClusterPublicFQDN = &enablePrivateClusterPublicFQDN
	}

	// Set property "PrivateDNSZone":
	if profile.PrivateDNSZone != nil {
		privateDNSZone := *profile.PrivateDNSZone
		result.PrivateDNSZone = &privateDNSZone
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterAPIServerAccessProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterAPIServerAccessProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterAPIServerAccessProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterAPIServerAccessProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterAPIServerAccessProfile, got %T", armInput)
	}

	// Set property "AuthorizedIPRanges":
	for _, item := range typedInput.AuthorizedIPRanges {
		profile.AuthorizedIPRanges = append(profile.AuthorizedIPRanges, item)
	}

	// Set property "EnablePrivateCluster":
	if typedInput.EnablePrivateCluster != nil {
		enablePrivateCluster := *typedInput.EnablePrivateCluster
		profile.EnablePrivateCluster = &enablePrivateCluster
	}

	// Set property "EnablePrivateClusterPublicFQDN":
	if typedInput.EnablePrivateClusterPublicFQDN != nil {
		enablePrivateClusterPublicFQDN := *typedInput.EnablePrivateClusterPublicFQDN
		profile.EnablePrivateClusterPublicFQDN = &enablePrivateClusterPublicFQDN
	}

	// Set property "PrivateDNSZone":
	if typedInput.PrivateDNSZone != nil {
		privateDNSZone := *typedInput.PrivateDNSZone
		profile.PrivateDNSZone = &privateDNSZone
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterAPIServerAccessProfile populates our ManagedClusterAPIServerAccessProfile from the provided source ManagedClusterAPIServerAccessProfile
func (profile *ManagedClusterAPIServerAccessProfile) AssignProperties_From_ManagedClusterAPIServerAccessProfile(source *storage.ManagedClusterAPIServerAccessProfile) error {

	// AuthorizedIPRanges
	profile.AuthorizedIPRanges = genruntime.CloneSliceOfString(source.AuthorizedIPRanges)

	// EnablePrivateCluster
	if source.EnablePrivateCluster != nil {
		enablePrivateCluster := *source.EnablePrivateCluster
		profile.EnablePrivateCluster = &enablePrivateCluster
	} else {
		profile.EnablePrivateCluster = nil
	}

	// EnablePrivateClusterPublicFQDN
	if source.EnablePrivateClusterPublicFQDN != nil {
		enablePrivateClusterPublicFQDN := *source.EnablePrivateClusterPublicFQDN
		profile.EnablePrivateClusterPublicFQDN = &enablePrivateClusterPublicFQDN
	} else {
		profile.EnablePrivateClusterPublicFQDN = nil
	}

	// PrivateDNSZone
	profile.PrivateDNSZone = genruntime.ClonePointerToString(source.PrivateDNSZone)

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterAPIServerAccessProfile populates the provided destination ManagedClusterAPIServerAccessProfile from our ManagedClusterAPIServerAccessProfile
func (profile *ManagedClusterAPIServerAccessProfile) AssignProperties_To_ManagedClusterAPIServerAccessProfile(destination *storage.ManagedClusterAPIServerAccessProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AuthorizedIPRanges
	destination.AuthorizedIPRanges = genruntime.CloneSliceOfString(profile.AuthorizedIPRanges)

	// EnablePrivateCluster
	if profile.EnablePrivateCluster != nil {
		enablePrivateCluster := *profile.EnablePrivateCluster
		destination.EnablePrivateCluster = &enablePrivateCluster
	} else {
		destination.EnablePrivateCluster = nil
	}

	// EnablePrivateClusterPublicFQDN
	if profile.EnablePrivateClusterPublicFQDN != nil {
		enablePrivateClusterPublicFQDN := *profile.EnablePrivateClusterPublicFQDN
		destination.EnablePrivateClusterPublicFQDN = &enablePrivateClusterPublicFQDN
	} else {
		destination.EnablePrivateClusterPublicFQDN = nil
	}

	// PrivateDNSZone
	destination.PrivateDNSZone = genruntime.ClonePointerToString(profile.PrivateDNSZone)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterAPIServerAccessProfile_STATUS struct {
	AuthorizedIPRanges             []string `json:"authorizedIPRanges,omitempty"`
	EnablePrivateCluster           *bool    `json:"enablePrivateCluster,omitempty"`
	EnablePrivateClusterPublicFQDN *bool    `json:"enablePrivateClusterPublicFQDN,omitempty"`
	PrivateDNSZone                 *string  `json:"privateDNSZone,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterAPIServerAccessProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterAPIServerAccessProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterAPIServerAccessProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterAPIServerAccessProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterAPIServerAccessProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterAPIServerAccessProfile_STATUS, got %T", armInput)
	}

	// Set property "AuthorizedIPRanges":
	for _, item := range typedInput.AuthorizedIPRanges {
		profile.AuthorizedIPRanges = append(profile.AuthorizedIPRanges, item)
	}

	// Set property "EnablePrivateCluster":
	if typedInput.EnablePrivateCluster != nil {
		enablePrivateCluster := *typedInput.EnablePrivateCluster
		profile.EnablePrivateCluster = &enablePrivateCluster
	}

	// Set property "EnablePrivateClusterPublicFQDN":
	if typedInput.EnablePrivateClusterPublicFQDN != nil {
		enablePrivateClusterPublicFQDN := *typedInput.EnablePrivateClusterPublicFQDN
		profile.EnablePrivateClusterPublicFQDN = &enablePrivateClusterPublicFQDN
	}

	// Set property "PrivateDNSZone":
	if typedInput.PrivateDNSZone != nil {
		privateDNSZone := *typedInput.PrivateDNSZone
		profile.PrivateDNSZone = &privateDNSZone
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterAPIServerAccessProfile_STATUS populates our ManagedClusterAPIServerAccessProfile_STATUS from the provided source ManagedClusterAPIServerAccessProfile_STATUS
func (profile *ManagedClusterAPIServerAccessProfile_STATUS) AssignProperties_From_ManagedClusterAPIServerAccessProfile_STATUS(source *storage.ManagedClusterAPIServerAccessProfile_STATUS) error {

	// AuthorizedIPRanges
	profile.AuthorizedIPRanges = genruntime.CloneSliceOfString(source.AuthorizedIPRanges)

	// EnablePrivateCluster
	if source.EnablePrivateCluster != nil {
		enablePrivateCluster := *source.EnablePrivateCluster
		profile.EnablePrivateCluster = &enablePrivateCluster
	} else {
		profile.EnablePrivateCluster = nil
	}

	// EnablePrivateClusterPublicFQDN
	if source.EnablePrivateClusterPublicFQDN != nil {
		enablePrivateClusterPublicFQDN := *source.EnablePrivateClusterPublicFQDN
		profile.EnablePrivateClusterPublicFQDN = &enablePrivateClusterPublicFQDN
	} else {
		profile.EnablePrivateClusterPublicFQDN = nil
	}

	// PrivateDNSZone
	profile.PrivateDNSZone = genruntime.ClonePointerToString(source.PrivateDNSZone)

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterAPIServerAccessProfile_STATUS populates the provided destination ManagedClusterAPIServerAccessProfile_STATUS from our ManagedClusterAPIServerAccessProfile_STATUS
func (profile *ManagedClusterAPIServerAccessProfile_STATUS) AssignProperties_To_ManagedClusterAPIServerAccessProfile_STATUS(destination *storage.ManagedClusterAPIServerAccessProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AuthorizedIPRanges
	destination.AuthorizedIPRanges = genruntime.CloneSliceOfString(profile.AuthorizedIPRanges)

	// EnablePrivateCluster
	if profile.EnablePrivateCluster != nil {
		enablePrivateCluster := *profile.EnablePrivateCluster
		destination.EnablePrivateCluster = &enablePrivateCluster
	} else {
		destination.EnablePrivateCluster = nil
	}

	// EnablePrivateClusterPublicFQDN
	if profile.EnablePrivateClusterPublicFQDN != nil {
		enablePrivateClusterPublicFQDN := *profile.EnablePrivateClusterPublicFQDN
		destination.EnablePrivateClusterPublicFQDN = &enablePrivateClusterPublicFQDN
	} else {
		destination.EnablePrivateClusterPublicFQDN = nil
	}

	// PrivateDNSZone
	destination.PrivateDNSZone = genruntime.ClonePointerToString(profile.PrivateDNSZone)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterAutoUpgradeProfile struct {
	UpgradeChannel *ManagedClusterAutoUpgradeProfile_UpgradeChannel `json:"upgradeChannel,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterAutoUpgradeProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *ManagedClusterAutoUpgradeProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.ManagedClusterAutoUpgradeProfile{}

	// Set property "UpgradeChannel":
	if profile.UpgradeChannel != nil {
		var temp string
		temp = string(*profile.UpgradeChannel)
		upgradeChannel := arm.ManagedClusterAutoUpgradeProfile_UpgradeChannel(temp)
		result.UpgradeChannel = &upgradeChannel
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterAutoUpgradeProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterAutoUpgradeProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterAutoUpgradeProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterAutoUpgradeProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterAutoUpgradeProfile, got %T", armInput)
	}

	// Set property "UpgradeChannel":
	if typedInput.UpgradeChannel != nil {
		var temp string
		temp = string(*typedInput.UpgradeChannel)
		upgradeChannel := ManagedClusterAutoUpgradeProfile_UpgradeChannel(temp)
		profile.UpgradeChannel = &upgradeChannel
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterAutoUpgradeProfile populates our ManagedClusterAutoUpgradeProfile from the provided source ManagedClusterAutoUpgradeProfile
func (profile *ManagedClusterAutoUpgradeProfile) AssignProperties_From_ManagedClusterAutoUpgradeProfile(source *storage.ManagedClusterAutoUpgradeProfile) error {

	// UpgradeChannel
	if source.UpgradeChannel != nil {
		upgradeChannel := *source.UpgradeChannel
		upgradeChannelTemp := genruntime.ToEnum(upgradeChannel, managedClusterAutoUpgradeProfile_UpgradeChannel_Values)
		profile.UpgradeChannel = &upgradeChannelTemp
	} else {
		profile.UpgradeChannel = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterAutoUpgradeProfile populates the provided destination ManagedClusterAutoUpgradeProfile from our ManagedClusterAutoUpgradeProfile
func (profile *ManagedClusterAutoUpgradeProfile) AssignProperties_To_ManagedClusterAutoUpgradeProfile(destination *storage.ManagedClusterAutoUpgradeProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// UpgradeChannel
	if profile.UpgradeChannel != nil {
		upgradeChannel := string(*profile.UpgradeChannel)
		destination.UpgradeChannel = &upgradeChannel
	} else {
		destination.UpgradeChannel = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterAutoUpgradeProfile_STATUS struct {
	UpgradeChannel *ManagedClusterAutoUpgradeProfile_UpgradeChannel_STATUS `json:"upgradeChannel,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterAutoUpgradeProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterAutoUpgradeProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterAutoUpgradeProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterAutoUpgradeProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterAutoUpgradeProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterAutoUpgradeProfile_STATUS, got %T", armInput)
	}

	// Set property "UpgradeChannel":
	if typedInput.UpgradeChannel != nil {
		var temp string
		temp = string(*typedInput.UpgradeChannel)
		upgradeChannel := ManagedClusterAutoUpgradeProfile_UpgradeChannel_STATUS(temp)
		profile.UpgradeChannel = &upgradeChannel
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterAutoUpgradeProfile_STATUS populates our ManagedClusterAutoUpgradeProfile_STATUS from the provided source ManagedClusterAutoUpgradeProfile_STATUS
func (profile *ManagedClusterAutoUpgradeProfile_STATUS) AssignProperties_From_ManagedClusterAutoUpgradeProfile_STATUS(source *storage.ManagedClusterAutoUpgradeProfile_STATUS) error {

	// UpgradeChannel
	if source.UpgradeChannel != nil {
		upgradeChannel := *source.UpgradeChannel
		upgradeChannelTemp := genruntime.ToEnum(upgradeChannel, managedClusterAutoUpgradeProfile_UpgradeChannel_STATUS_Values)
		profile.UpgradeChannel = &upgradeChannelTemp
	} else {
		profile.UpgradeChannel = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterAutoUpgradeProfile_STATUS populates the provided destination ManagedClusterAutoUpgradeProfile_STATUS from our ManagedClusterAutoUpgradeProfile_STATUS
func (profile *ManagedClusterAutoUpgradeProfile_STATUS) AssignProperties_To_ManagedClusterAutoUpgradeProfile_STATUS(destination *storage.ManagedClusterAutoUpgradeProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// UpgradeChannel
	if profile.UpgradeChannel != nil {
		upgradeChannel := string(*profile.UpgradeChannel)
		destination.UpgradeChannel = &upgradeChannel
	} else {
		destination.UpgradeChannel = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterHTTPProxyConfig struct {
	HttpProxy  *string  `json:"httpProxy,omitempty"`
	HttpsProxy *string  `json:"httpsProxy,omitempty"`
	NoProxy    []string `json:"noProxy,omitempty"`
	TrustedCa  *string  `json:"trustedCa,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterHTTPProxyConfig{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (config *ManagedClusterHTTPProxyConfig) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if config == nil {
		return nil, nil
	}
	result := &arm.ManagedClusterHTTPProxyConfig{}

	// Set property "HttpProxy":
	if config.HttpProxy != nil {
		httpProxy := *config.HttpProxy
		result.HttpProxy = &httpProxy
	}

	// Set property "HttpsProxy":
	if config.HttpsProxy != nil {
		httpsProxy := *config.HttpsProxy
		result.HttpsProxy = &httpsProxy
	}

	// Set property "NoProxy":
	for _, item := range config.NoProxy {
		result.NoProxy = append(result.NoProxy, item)
	}

	// Set property "TrustedCa":
	if config.TrustedCa != nil {
		trustedCa := *config.TrustedCa
		result.TrustedCa = &trustedCa
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (config *ManagedClusterHTTPProxyConfig) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterHTTPProxyConfig{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (config *ManagedClusterHTTPProxyConfig) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterHTTPProxyConfig)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterHTTPProxyConfig, got %T", armInput)
	}

	// Set property "HttpProxy":
	if typedInput.HttpProxy != nil {
		httpProxy := *typedInput.HttpProxy
		config.HttpProxy = &httpProxy
	}

	// Set property "HttpsProxy":
	if typedInput.HttpsProxy != nil {
		httpsProxy := *typedInput.HttpsProxy
		config.HttpsProxy = &httpsProxy
	}

	// Set property "NoProxy":
	for _, item := range typedInput.NoProxy {
		config.NoProxy = append(config.NoProxy, item)
	}

	// Set property "TrustedCa":
	if typedInput.TrustedCa != nil {
		trustedCa := *typedInput.TrustedCa
		config.TrustedCa = &trustedCa
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterHTTPProxyConfig populates our ManagedClusterHTTPProxyConfig from the provided source ManagedClusterHTTPProxyConfig
func (config *ManagedClusterHTTPProxyConfig) AssignProperties_From_ManagedClusterHTTPProxyConfig(source *storage.ManagedClusterHTTPProxyConfig) error {

	// HttpProxy
	config.HttpProxy = genruntime.ClonePointerToString(source.HttpProxy)

	// HttpsProxy
	config.HttpsProxy = genruntime.ClonePointerToString(source.HttpsProxy)

	// NoProxy
	config.NoProxy = genruntime.CloneSliceOfString(source.NoProxy)

	// TrustedCa
	config.TrustedCa = genruntime.ClonePointerToString(source.TrustedCa)

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterHTTPProxyConfig populates the provided destination ManagedClusterHTTPProxyConfig from our ManagedClusterHTTPProxyConfig
func (config *ManagedClusterHTTPProxyConfig) AssignProperties_To_ManagedClusterHTTPProxyConfig(destination *storage.ManagedClusterHTTPProxyConfig) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// HttpProxy
	destination.HttpProxy = genruntime.ClonePointerToString(config.HttpProxy)

	// HttpsProxy
	destination.HttpsProxy = genruntime.ClonePointerToString(config.HttpsProxy)

	// NoProxy
	destination.NoProxy = genruntime.CloneSliceOfString(config.NoProxy)

	// TrustedCa
	destination.TrustedCa = genruntime.ClonePointerToString(config.TrustedCa)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterHTTPProxyConfig_STATUS struct {
	HttpProxy  *string  `json:"httpProxy,omitempty"`
	HttpsProxy *string  `json:"httpsProxy,omitempty"`
	NoProxy    []string `json:"noProxy,omitempty"`
	TrustedCa  *string  `json:"trustedCa,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterHTTPProxyConfig_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (config *ManagedClusterHTTPProxyConfig_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterHTTPProxyConfig_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (config *ManagedClusterHTTPProxyConfig_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterHTTPProxyConfig_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterHTTPProxyConfig_STATUS, got %T", armInput)
	}

	// Set property "HttpProxy":
	if typedInput.HttpProxy != nil {
		httpProxy := *typedInput.HttpProxy
		config.HttpProxy = &httpProxy
	}

	// Set property "HttpsProxy":
	if typedInput.HttpsProxy != nil {
		httpsProxy := *typedInput.HttpsProxy
		config.HttpsProxy = &httpsProxy
	}

	// Set property "NoProxy":
	for _, item := range typedInput.NoProxy {
		config.NoProxy = append(config.NoProxy, item)
	}

	// Set property "TrustedCa":
	if typedInput.TrustedCa != nil {
		trustedCa := *typedInput.TrustedCa
		config.TrustedCa = &trustedCa
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterHTTPProxyConfig_STATUS populates our ManagedClusterHTTPProxyConfig_STATUS from the provided source ManagedClusterHTTPProxyConfig_STATUS
func (config *ManagedClusterHTTPProxyConfig_STATUS) AssignProperties_From_ManagedClusterHTTPProxyConfig_STATUS(source *storage.ManagedClusterHTTPProxyConfig_STATUS) error {

	// HttpProxy
	config.HttpProxy = genruntime.ClonePointerToString(source.HttpProxy)

	// HttpsProxy
	config.HttpsProxy = genruntime.ClonePointerToString(source.HttpsProxy)

	// NoProxy
	config.NoProxy = genruntime.CloneSliceOfString(source.NoProxy)

	// TrustedCa
	config.TrustedCa = genruntime.ClonePointerToString(source.TrustedCa)

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterHTTPProxyConfig_STATUS populates the provided destination ManagedClusterHTTPProxyConfig_STATUS from our ManagedClusterHTTPProxyConfig_STATUS
func (config *ManagedClusterHTTPProxyConfig_STATUS) AssignProperties_To_ManagedClusterHTTPProxyConfig_STATUS(destination *storage.ManagedClusterHTTPProxyConfig_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// HttpProxy
	destination.HttpProxy = genruntime.ClonePointerToString(config.HttpProxy)

	// HttpsProxy
	destination.HttpsProxy = genruntime.ClonePointerToString(config.HttpsProxy)

	// NoProxy
	destination.NoProxy = genruntime.CloneSliceOfString(config.NoProxy)

	// TrustedCa
	destination.TrustedCa = genruntime.ClonePointerToString(config.TrustedCa)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterIdentity struct {
	Type                   *ManagedClusterIdentity_Type  `json:"type,omitempty"`
	UserAssignedIdentities []UserAssignedIdentityDetails `json:"userAssignedIdentities,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterIdentity{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (identity *ManagedClusterIdentity) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if identity == nil {
		return nil, nil
	}
	result := &arm.ManagedClusterIdentity{}

	// Set property "Type":
	if identity.Type != nil {
		var temp string
		temp = string(*identity.Type)
		typeVar := arm.ManagedClusterIdentity_Type(temp)
		result.Type = &typeVar
	}

	// Set property "UserAssignedIdentities":
	result.UserAssignedIdentities = make(map[string]arm.UserAssignedIdentityDetails, len(identity.UserAssignedIdentities))
	for _, ident := range identity.UserAssignedIdentities {
		identARMID, err := resolved.ResolvedReferences.Lookup(ident.Reference)
		if err != nil {
			return nil, err
		}
		key := identARMID
		result.UserAssignedIdentities[key] = arm.UserAssignedIdentityDetails{}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *ManagedClusterIdentity) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterIdentity{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *ManagedClusterIdentity) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterIdentity)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterIdentity, got %T", armInput)
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := ManagedClusterIdentity_Type(temp)
		identity.Type = &typeVar
	}

	// no assignment for property "UserAssignedIdentities"

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterIdentity populates our ManagedClusterIdentity from the provided source ManagedClusterIdentity
func (identity *ManagedClusterIdentity) AssignProperties_From_ManagedClusterIdentity(source *storage.ManagedClusterIdentity) error {

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, managedClusterIdentity_Type_Values)
		identity.Type = &typeTemp
	} else {
		identity.Type = nil
	}

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]UserAssignedIdentityDetails, len(source.UserAssignedIdentities))
		for userAssignedIdentityIndex, userAssignedIdentityItem := range source.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityItem := userAssignedIdentityItem
			var userAssignedIdentity UserAssignedIdentityDetails
			err := userAssignedIdentity.AssignProperties_From_UserAssignedIdentityDetails(&userAssignedIdentityItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_UserAssignedIdentityDetails() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityList[userAssignedIdentityIndex] = userAssignedIdentity
		}
		identity.UserAssignedIdentities = userAssignedIdentityList
	} else {
		identity.UserAssignedIdentities = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterIdentity populates the provided destination ManagedClusterIdentity from our ManagedClusterIdentity
func (identity *ManagedClusterIdentity) AssignProperties_To_ManagedClusterIdentity(destination *storage.ManagedClusterIdentity) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Type
	if identity.Type != nil {
		typeVar := string(*identity.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// UserAssignedIdentities
	if identity.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]storage.UserAssignedIdentityDetails, len(identity.UserAssignedIdentities))
		for userAssignedIdentityIndex, userAssignedIdentityItem := range identity.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityItem := userAssignedIdentityItem
			var userAssignedIdentity storage.UserAssignedIdentityDetails
			err := userAssignedIdentityItem.AssignProperties_To_UserAssignedIdentityDetails(&userAssignedIdentity)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_UserAssignedIdentityDetails() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityList[userAssignedIdentityIndex] = userAssignedIdentity
		}
		destination.UserAssignedIdentities = userAssignedIdentityList
	} else {
		destination.UserAssignedIdentities = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterIdentity_STATUS struct {
	PrincipalId            *string                                                         `json:"principalId,omitempty"`
	TenantId               *string                                                         `json:"tenantId,omitempty"`
	Type                   *ManagedClusterIdentity_Type_STATUS                             `json:"type,omitempty"`
	UserAssignedIdentities map[string]ManagedClusterIdentity_UserAssignedIdentities_STATUS `json:"userAssignedIdentities,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterIdentity_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *ManagedClusterIdentity_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterIdentity_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *ManagedClusterIdentity_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterIdentity_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterIdentity_STATUS, got %T", armInput)
	}

	// Set property "PrincipalId":
	if typedInput.PrincipalId != nil {
		principalId := *typedInput.PrincipalId
		identity.PrincipalId = &principalId
	}

	// Set property "TenantId":
	if typedInput.TenantId != nil {
		tenantId := *typedInput.TenantId
		identity.TenantId = &tenantId
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := ManagedClusterIdentity_Type_STATUS(temp)
		identity.Type = &typeVar
	}

	// Set property "UserAssignedIdentities":
	if typedInput.UserAssignedIdentities != nil {
		identity.UserAssignedIdentities = make(map[string]ManagedClusterIdentity_UserAssignedIdentities_STATUS, len(typedInput.UserAssignedIdentities))
		for key, value := range typedInput.UserAssignedIdentities {
			var value1 ManagedClusterIdentity_UserAssignedIdentities_STATUS
			err := value1.PopulateFromARM(owner, value)
			if err != nil {
				return err
			}
			identity.UserAssignedIdentities[key] = value1
		}
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterIdentity_STATUS populates our ManagedClusterIdentity_STATUS from the provided source ManagedClusterIdentity_STATUS
func (identity *ManagedClusterIdentity_STATUS) AssignProperties_From_ManagedClusterIdentity_STATUS(source *storage.ManagedClusterIdentity_STATUS) error {

	// PrincipalId
	identity.PrincipalId = genruntime.ClonePointerToString(source.PrincipalId)

	// TenantId
	identity.TenantId = genruntime.ClonePointerToString(source.TenantId)

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, managedClusterIdentity_Type_STATUS_Values)
		identity.Type = &typeTemp
	} else {
		identity.Type = nil
	}

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityMap := make(map[string]ManagedClusterIdentity_UserAssignedIdentities_STATUS, len(source.UserAssignedIdentities))
		for userAssignedIdentityKey, userAssignedIdentityValue := range source.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityValue := userAssignedIdentityValue
			var userAssignedIdentity ManagedClusterIdentity_UserAssignedIdentities_STATUS
			err := userAssignedIdentity.AssignProperties_From_ManagedClusterIdentity_UserAssignedIdentities_STATUS(&userAssignedIdentityValue)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterIdentity_UserAssignedIdentities_STATUS() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityMap[userAssignedIdentityKey] = userAssignedIdentity
		}
		identity.UserAssignedIdentities = userAssignedIdentityMap
	} else {
		identity.UserAssignedIdentities = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterIdentity_STATUS populates the provided destination ManagedClusterIdentity_STATUS from our ManagedClusterIdentity_STATUS
func (identity *ManagedClusterIdentity_STATUS) AssignProperties_To_ManagedClusterIdentity_STATUS(destination *storage.ManagedClusterIdentity_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PrincipalId
	destination.PrincipalId = genruntime.ClonePointerToString(identity.PrincipalId)

	// TenantId
	destination.TenantId = genruntime.ClonePointerToString(identity.TenantId)

	// Type
	if identity.Type != nil {
		typeVar := string(*identity.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// UserAssignedIdentities
	if identity.UserAssignedIdentities != nil {
		userAssignedIdentityMap := make(map[string]storage.ManagedClusterIdentity_UserAssignedIdentities_STATUS, len(identity.UserAssignedIdentities))
		for userAssignedIdentityKey, userAssignedIdentityValue := range identity.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityValue := userAssignedIdentityValue
			var userAssignedIdentity storage.ManagedClusterIdentity_UserAssignedIdentities_STATUS
			err := userAssignedIdentityValue.AssignProperties_To_ManagedClusterIdentity_UserAssignedIdentities_STATUS(&userAssignedIdentity)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterIdentity_UserAssignedIdentities_STATUS() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityMap[userAssignedIdentityKey] = userAssignedIdentity
		}
		destination.UserAssignedIdentities = userAssignedIdentityMap
	} else {
		destination.UserAssignedIdentities = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Details for configuring operator behavior. Fields in this struct are interpreted by the operator directly rather than being passed to Azure
type ManagedClusterOperatorSpec struct {
	// ConfigMapExpressions: configures where to place operator written dynamic ConfigMaps (created with CEL expressions).
	ConfigMapExpressions []*core.DestinationExpression `json:"configMapExpressions,omitempty"`

	// SecretExpressions: configures where to place operator written dynamic secrets (created with CEL expressions).
	SecretExpressions []*core.DestinationExpression `json:"secretExpressions,omitempty"`

	// Secrets: configures where to place Azure generated secrets.
	Secrets *ManagedClusterOperatorSecrets `json:"secrets,omitempty"`
}

// AssignProperties_From_ManagedClusterOperatorSpec populates our ManagedClusterOperatorSpec from the provided source ManagedClusterOperatorSpec
func (operator *ManagedClusterOperatorSpec) AssignProperties_From_ManagedClusterOperatorSpec(source *storage.ManagedClusterOperatorSpec) error {

	// ConfigMapExpressions
	if source.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(source.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range source.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		operator.ConfigMapExpressions = configMapExpressionList
	} else {
		operator.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if source.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(source.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range source.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		operator.SecretExpressions = secretExpressionList
	} else {
		operator.SecretExpressions = nil
	}

	// Secrets
	if source.Secrets != nil {
		var secret ManagedClusterOperatorSecrets
		err := secret.AssignProperties_From_ManagedClusterOperatorSecrets(source.Secrets)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterOperatorSecrets() to populate field Secrets")
		}
		operator.Secrets = &secret
	} else {
		operator.Secrets = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterOperatorSpec populates the provided destination ManagedClusterOperatorSpec from our ManagedClusterOperatorSpec
func (operator *ManagedClusterOperatorSpec) AssignProperties_To_ManagedClusterOperatorSpec(destination *storage.ManagedClusterOperatorSpec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ConfigMapExpressions
	if operator.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(operator.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range operator.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		destination.ConfigMapExpressions = configMapExpressionList
	} else {
		destination.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if operator.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(operator.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range operator.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		destination.SecretExpressions = secretExpressionList
	} else {
		destination.SecretExpressions = nil
	}

	// Secrets
	if operator.Secrets != nil {
		var secret storage.ManagedClusterOperatorSecrets
		err := operator.Secrets.AssignProperties_To_ManagedClusterOperatorSecrets(&secret)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterOperatorSecrets() to populate field Secrets")
		}
		destination.Secrets = &secret
	} else {
		destination.Secrets = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterPodIdentityProfile struct {
	AllowNetworkPluginKubenet      *bool                                `json:"allowNetworkPluginKubenet,omitempty"`
	Enabled                        *bool                                `json:"enabled,omitempty"`
	UserAssignedIdentities         []ManagedClusterPodIdentity          `json:"userAssignedIdentities,omitempty"`
	UserAssignedIdentityExceptions []ManagedClusterPodIdentityException `json:"userAssignedIdentityExceptions,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterPodIdentityProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *ManagedClusterPodIdentityProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.ManagedClusterPodIdentityProfile{}

	// Set property "AllowNetworkPluginKubenet":
	if profile.AllowNetworkPluginKubenet != nil {
		allowNetworkPluginKubenet := *profile.AllowNetworkPluginKubenet
		result.AllowNetworkPluginKubenet = &allowNetworkPluginKubenet
	}

	// Set property "Enabled":
	if profile.Enabled != nil {
		enabled := *profile.Enabled
		result.Enabled = &enabled
	}

	// Set property "UserAssignedIdentities":
	for _, item := range profile.UserAssignedIdentities {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.UserAssignedIdentities = append(result.UserAssignedIdentities, *item_ARM.(*arm.ManagedClusterPodIdentity))
	}

	// Set property "UserAssignedIdentityExceptions":
	for _, item := range profile.UserAssignedIdentityExceptions {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.UserAssignedIdentityExceptions = append(result.UserAssignedIdentityExceptions, *item_ARM.(*arm.ManagedClusterPodIdentityException))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterPodIdentityProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterPodIdentityProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterPodIdentityProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterPodIdentityProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterPodIdentityProfile, got %T", armInput)
	}

	// Set property "AllowNetworkPluginKubenet":
	if typedInput.AllowNetworkPluginKubenet != nil {
		allowNetworkPluginKubenet := *typedInput.AllowNetworkPluginKubenet
		profile.AllowNetworkPluginKubenet = &allowNetworkPluginKubenet
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		profile.Enabled = &enabled
	}

	// Set property "UserAssignedIdentities":
	for _, item := range typedInput.UserAssignedIdentities {
		var item1 ManagedClusterPodIdentity
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		profile.UserAssignedIdentities = append(profile.UserAssignedIdentities, item1)
	}

	// Set property "UserAssignedIdentityExceptions":
	for _, item := range typedInput.UserAssignedIdentityExceptions {
		var item1 ManagedClusterPodIdentityException
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		profile.UserAssignedIdentityExceptions = append(profile.UserAssignedIdentityExceptions, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterPodIdentityProfile populates our ManagedClusterPodIdentityProfile from the provided source ManagedClusterPodIdentityProfile
func (profile *ManagedClusterPodIdentityProfile) AssignProperties_From_ManagedClusterPodIdentityProfile(source *storage.ManagedClusterPodIdentityProfile) error {

	// AllowNetworkPluginKubenet
	if source.AllowNetworkPluginKubenet != nil {
		allowNetworkPluginKubenet := *source.AllowNetworkPluginKubenet
		profile.AllowNetworkPluginKubenet = &allowNetworkPluginKubenet
	} else {
		profile.AllowNetworkPluginKubenet = nil
	}

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		profile.Enabled = &enabled
	} else {
		profile.Enabled = nil
	}

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]ManagedClusterPodIdentity, len(source.UserAssignedIdentities))
		for userAssignedIdentityIndex, userAssignedIdentityItem := range source.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityItem := userAssignedIdentityItem
			var userAssignedIdentity ManagedClusterPodIdentity
			err := userAssignedIdentity.AssignProperties_From_ManagedClusterPodIdentity(&userAssignedIdentityItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterPodIdentity() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityList[userAssignedIdentityIndex] = userAssignedIdentity
		}
		profile.UserAssignedIdentities = userAssignedIdentityList
	} else {
		profile.UserAssignedIdentities = nil
	}

	// UserAssignedIdentityExceptions
	if source.UserAssignedIdentityExceptions != nil {
		userAssignedIdentityExceptionList := make([]ManagedClusterPodIdentityException, len(source.UserAssignedIdentityExceptions))
		for userAssignedIdentityExceptionIndex, userAssignedIdentityExceptionItem := range source.UserAssignedIdentityExceptions {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityExceptionItem := userAssignedIdentityExceptionItem
			var userAssignedIdentityException ManagedClusterPodIdentityException
			err := userAssignedIdentityException.AssignProperties_From_ManagedClusterPodIdentityException(&userAssignedIdentityExceptionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterPodIdentityException() to populate field UserAssignedIdentityExceptions")
			}
			userAssignedIdentityExceptionList[userAssignedIdentityExceptionIndex] = userAssignedIdentityException
		}
		profile.UserAssignedIdentityExceptions = userAssignedIdentityExceptionList
	} else {
		profile.UserAssignedIdentityExceptions = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterPodIdentityProfile populates the provided destination ManagedClusterPodIdentityProfile from our ManagedClusterPodIdentityProfile
func (profile *ManagedClusterPodIdentityProfile) AssignProperties_To_ManagedClusterPodIdentityProfile(destination *storage.ManagedClusterPodIdentityProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AllowNetworkPluginKubenet
	if profile.AllowNetworkPluginKubenet != nil {
		allowNetworkPluginKubenet := *profile.AllowNetworkPluginKubenet
		destination.AllowNetworkPluginKubenet = &allowNetworkPluginKubenet
	} else {
		destination.AllowNetworkPluginKubenet = nil
	}

	// Enabled
	if profile.Enabled != nil {
		enabled := *profile.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// UserAssignedIdentities
	if profile.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]storage.ManagedClusterPodIdentity, len(profile.UserAssignedIdentities))
		for userAssignedIdentityIndex, userAssignedIdentityItem := range profile.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityItem := userAssignedIdentityItem
			var userAssignedIdentity storage.ManagedClusterPodIdentity
			err := userAssignedIdentityItem.AssignProperties_To_ManagedClusterPodIdentity(&userAssignedIdentity)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterPodIdentity() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityList[userAssignedIdentityIndex] = userAssignedIdentity
		}
		destination.UserAssignedIdentities = userAssignedIdentityList
	} else {
		destination.UserAssignedIdentities = nil
	}

	// UserAssignedIdentityExceptions
	if profile.UserAssignedIdentityExceptions != nil {
		userAssignedIdentityExceptionList := make([]storage.ManagedClusterPodIdentityException, len(profile.UserAssignedIdentityExceptions))
		for userAssignedIdentityExceptionIndex, userAssignedIdentityExceptionItem := range profile.UserAssignedIdentityExceptions {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityExceptionItem := userAssignedIdentityExceptionItem
			var userAssignedIdentityException storage.ManagedClusterPodIdentityException
			err := userAssignedIdentityExceptionItem.AssignProperties_To_ManagedClusterPodIdentityException(&userAssignedIdentityException)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterPodIdentityException() to populate field UserAssignedIdentityExceptions")
			}
			userAssignedIdentityExceptionList[userAssignedIdentityExceptionIndex] = userAssignedIdentityException
		}
		destination.UserAssignedIdentityExceptions = userAssignedIdentityExceptionList
	} else {
		destination.UserAssignedIdentityExceptions = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterPodIdentityProfile_STATUS struct {
	AllowNetworkPluginKubenet      *bool                                       `json:"allowNetworkPluginKubenet,omitempty"`
	Enabled                        *bool                                       `json:"enabled,omitempty"`
	UserAssignedIdentities         []ManagedClusterPodIdentity_STATUS          `json:"userAssignedIdentities,omitempty"`
	UserAssignedIdentityExceptions []ManagedClusterPodIdentityException_STATUS `json:"userAssignedIdentityExceptions,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterPodIdentityProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterPodIdentityProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterPodIdentityProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterPodIdentityProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterPodIdentityProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterPodIdentityProfile_STATUS, got %T", armInput)
	}

	// Set property "AllowNetworkPluginKubenet":
	if typedInput.AllowNetworkPluginKubenet != nil {
		allowNetworkPluginKubenet := *typedInput.AllowNetworkPluginKubenet
		profile.AllowNetworkPluginKubenet = &allowNetworkPluginKubenet
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		profile.Enabled = &enabled
	}

	// Set property "UserAssignedIdentities":
	for _, item := range typedInput.UserAssignedIdentities {
		var item1 ManagedClusterPodIdentity_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		profile.UserAssignedIdentities = append(profile.UserAssignedIdentities, item1)
	}

	// Set property "UserAssignedIdentityExceptions":
	for _, item := range typedInput.UserAssignedIdentityExceptions {
		var item1 ManagedClusterPodIdentityException_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		profile.UserAssignedIdentityExceptions = append(profile.UserAssignedIdentityExceptions, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterPodIdentityProfile_STATUS populates our ManagedClusterPodIdentityProfile_STATUS from the provided source ManagedClusterPodIdentityProfile_STATUS
func (profile *ManagedClusterPodIdentityProfile_STATUS) AssignProperties_From_ManagedClusterPodIdentityProfile_STATUS(source *storage.ManagedClusterPodIdentityProfile_STATUS) error {

	// AllowNetworkPluginKubenet
	if source.AllowNetworkPluginKubenet != nil {
		allowNetworkPluginKubenet := *source.AllowNetworkPluginKubenet
		profile.AllowNetworkPluginKubenet = &allowNetworkPluginKubenet
	} else {
		profile.AllowNetworkPluginKubenet = nil
	}

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		profile.Enabled = &enabled
	} else {
		profile.Enabled = nil
	}

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]ManagedClusterPodIdentity_STATUS, len(source.UserAssignedIdentities))
		for userAssignedIdentityIndex, userAssignedIdentityItem := range source.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityItem := userAssignedIdentityItem
			var userAssignedIdentity ManagedClusterPodIdentity_STATUS
			err := userAssignedIdentity.AssignProperties_From_ManagedClusterPodIdentity_STATUS(&userAssignedIdentityItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterPodIdentity_STATUS() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityList[userAssignedIdentityIndex] = userAssignedIdentity
		}
		profile.UserAssignedIdentities = userAssignedIdentityList
	} else {
		profile.UserAssignedIdentities = nil
	}

	// UserAssignedIdentityExceptions
	if source.UserAssignedIdentityExceptions != nil {
		userAssignedIdentityExceptionList := make([]ManagedClusterPodIdentityException_STATUS, len(source.UserAssignedIdentityExceptions))
		for userAssignedIdentityExceptionIndex, userAssignedIdentityExceptionItem := range source.UserAssignedIdentityExceptions {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityExceptionItem := userAssignedIdentityExceptionItem
			var userAssignedIdentityException ManagedClusterPodIdentityException_STATUS
			err := userAssignedIdentityException.AssignProperties_From_ManagedClusterPodIdentityException_STATUS(&userAssignedIdentityExceptionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterPodIdentityException_STATUS() to populate field UserAssignedIdentityExceptions")
			}
			userAssignedIdentityExceptionList[userAssignedIdentityExceptionIndex] = userAssignedIdentityException
		}
		profile.UserAssignedIdentityExceptions = userAssignedIdentityExceptionList
	} else {
		profile.UserAssignedIdentityExceptions = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterPodIdentityProfile_STATUS populates the provided destination ManagedClusterPodIdentityProfile_STATUS from our ManagedClusterPodIdentityProfile_STATUS
func (profile *ManagedClusterPodIdentityProfile_STATUS) AssignProperties_To_ManagedClusterPodIdentityProfile_STATUS(destination *storage.ManagedClusterPodIdentityProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AllowNetworkPluginKubenet
	if profile.AllowNetworkPluginKubenet != nil {
		allowNetworkPluginKubenet := *profile.AllowNetworkPluginKubenet
		destination.AllowNetworkPluginKubenet = &allowNetworkPluginKubenet
	} else {
		destination.AllowNetworkPluginKubenet = nil
	}

	// Enabled
	if profile.Enabled != nil {
		enabled := *profile.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// UserAssignedIdentities
	if profile.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]storage.ManagedClusterPodIdentity_STATUS, len(profile.UserAssignedIdentities))
		for userAssignedIdentityIndex, userAssignedIdentityItem := range profile.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityItem := userAssignedIdentityItem
			var userAssignedIdentity storage.ManagedClusterPodIdentity_STATUS
			err := userAssignedIdentityItem.AssignProperties_To_ManagedClusterPodIdentity_STATUS(&userAssignedIdentity)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterPodIdentity_STATUS() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityList[userAssignedIdentityIndex] = userAssignedIdentity
		}
		destination.UserAssignedIdentities = userAssignedIdentityList
	} else {
		destination.UserAssignedIdentities = nil
	}

	// UserAssignedIdentityExceptions
	if profile.UserAssignedIdentityExceptions != nil {
		userAssignedIdentityExceptionList := make([]storage.ManagedClusterPodIdentityException_STATUS, len(profile.UserAssignedIdentityExceptions))
		for userAssignedIdentityExceptionIndex, userAssignedIdentityExceptionItem := range profile.UserAssignedIdentityExceptions {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityExceptionItem := userAssignedIdentityExceptionItem
			var userAssignedIdentityException storage.ManagedClusterPodIdentityException_STATUS
			err := userAssignedIdentityExceptionItem.AssignProperties_To_ManagedClusterPodIdentityException_STATUS(&userAssignedIdentityException)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterPodIdentityException_STATUS() to populate field UserAssignedIdentityExceptions")
			}
			userAssignedIdentityExceptionList[userAssignedIdentityExceptionIndex] = userAssignedIdentityException
		}
		destination.UserAssignedIdentityExceptions = userAssignedIdentityExceptionList
	} else {
		destination.UserAssignedIdentityExceptions = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterProperties_AutoScalerProfile struct {
	BalanceSimilarNodeGroups      *string                                              `json:"balance-similar-node-groups,omitempty"`
	Expander                      *ManagedClusterProperties_AutoScalerProfile_Expander `json:"expander,omitempty"`
	MaxEmptyBulkDelete            *string                                              `json:"max-empty-bulk-delete,omitempty"`
	MaxGracefulTerminationSec     *string                                              `json:"max-graceful-termination-sec,omitempty"`
	MaxNodeProvisionTime          *string                                              `json:"max-node-provision-time,omitempty"`
	MaxTotalUnreadyPercentage     *string                                              `json:"max-total-unready-percentage,omitempty"`
	NewPodScaleUpDelay            *string                                              `json:"new-pod-scale-up-delay,omitempty"`
	OkTotalUnreadyCount           *string                                              `json:"ok-total-unready-count,omitempty"`
	ScaleDownDelayAfterAdd        *string                                              `json:"scale-down-delay-after-add,omitempty"`
	ScaleDownDelayAfterDelete     *string                                              `json:"scale-down-delay-after-delete,omitempty"`
	ScaleDownDelayAfterFailure    *string                                              `json:"scale-down-delay-after-failure,omitempty"`
	ScaleDownUnneededTime         *string                                              `json:"scale-down-unneeded-time,omitempty"`
	ScaleDownUnreadyTime          *string                                              `json:"scale-down-unready-time,omitempty"`
	ScaleDownUtilizationThreshold *string                                              `json:"scale-down-utilization-threshold,omitempty"`
	ScanInterval                  *string                                              `json:"scan-interval,omitempty"`
	SkipNodesWithLocalStorage     *string                                              `json:"skip-nodes-with-local-storage,omitempty"`
	SkipNodesWithSystemPods       *string                                              `json:"skip-nodes-with-system-pods,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterProperties_AutoScalerProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *ManagedClusterProperties_AutoScalerProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.ManagedClusterProperties_AutoScalerProfile{}

	// Set property "BalanceSimilarNodeGroups":
	if profile.BalanceSimilarNodeGroups != nil {
		balanceSimilarNodeGroups := *profile.BalanceSimilarNodeGroups
		result.BalanceSimilarNodeGroups = &balanceSimilarNodeGroups
	}

	// Set property "Expander":
	if profile.Expander != nil {
		var temp string
		temp = string(*profile.Expander)
		expander := arm.ManagedClusterProperties_AutoScalerProfile_Expander(temp)
		result.Expander = &expander
	}

	// Set property "MaxEmptyBulkDelete":
	if profile.MaxEmptyBulkDelete != nil {
		maxEmptyBulkDelete := *profile.MaxEmptyBulkDelete
		result.MaxEmptyBulkDelete = &maxEmptyBulkDelete
	}

	// Set property "MaxGracefulTerminationSec":
	if profile.MaxGracefulTerminationSec != nil {
		maxGracefulTerminationSec := *profile.MaxGracefulTerminationSec
		result.MaxGracefulTerminationSec = &maxGracefulTerminationSec
	}

	// Set property "MaxNodeProvisionTime":
	if profile.MaxNodeProvisionTime != nil {
		maxNodeProvisionTime := *profile.MaxNodeProvisionTime
		result.MaxNodeProvisionTime = &maxNodeProvisionTime
	}

	// Set property "MaxTotalUnreadyPercentage":
	if profile.MaxTotalUnreadyPercentage != nil {
		maxTotalUnreadyPercentage := *profile.MaxTotalUnreadyPercentage
		result.MaxTotalUnreadyPercentage = &maxTotalUnreadyPercentage
	}

	// Set property "NewPodScaleUpDelay":
	if profile.NewPodScaleUpDelay != nil {
		newPodScaleUpDelay := *profile.NewPodScaleUpDelay
		result.NewPodScaleUpDelay = &newPodScaleUpDelay
	}

	// Set property "OkTotalUnreadyCount":
	if profile.OkTotalUnreadyCount != nil {
		okTotalUnreadyCount := *profile.OkTotalUnreadyCount
		result.OkTotalUnreadyCount = &okTotalUnreadyCount
	}

	// Set property "ScaleDownDelayAfterAdd":
	if profile.ScaleDownDelayAfterAdd != nil {
		scaleDownDelayAfterAdd := *profile.ScaleDownDelayAfterAdd
		result.ScaleDownDelayAfterAdd = &scaleDownDelayAfterAdd
	}

	// Set property "ScaleDownDelayAfterDelete":
	if profile.ScaleDownDelayAfterDelete != nil {
		scaleDownDelayAfterDelete := *profile.ScaleDownDelayAfterDelete
		result.ScaleDownDelayAfterDelete = &scaleDownDelayAfterDelete
	}

	// Set property "ScaleDownDelayAfterFailure":
	if profile.ScaleDownDelayAfterFailure != nil {
		scaleDownDelayAfterFailure := *profile.ScaleDownDelayAfterFailure
		result.ScaleDownDelayAfterFailure = &scaleDownDelayAfterFailure
	}

	// Set property "ScaleDownUnneededTime":
	if profile.ScaleDownUnneededTime != nil {
		scaleDownUnneededTime := *profile.ScaleDownUnneededTime
		result.ScaleDownUnneededTime = &scaleDownUnneededTime
	}

	// Set property "ScaleDownUnreadyTime":
	if profile.ScaleDownUnreadyTime != nil {
		scaleDownUnreadyTime := *profile.ScaleDownUnreadyTime
		result.ScaleDownUnreadyTime = &scaleDownUnreadyTime
	}

	// Set property "ScaleDownUtilizationThreshold":
	if profile.ScaleDownUtilizationThreshold != nil {
		scaleDownUtilizationThreshold := *profile.ScaleDownUtilizationThreshold
		result.ScaleDownUtilizationThreshold = &scaleDownUtilizationThreshold
	}

	// Set property "ScanInterval":
	if profile.ScanInterval != nil {
		scanInterval := *profile.ScanInterval
		result.ScanInterval = &scanInterval
	}

	// Set property "SkipNodesWithLocalStorage":
	if profile.SkipNodesWithLocalStorage != nil {
		skipNodesWithLocalStorage := *profile.SkipNodesWithLocalStorage
		result.SkipNodesWithLocalStorage = &skipNodesWithLocalStorage
	}

	// Set property "SkipNodesWithSystemPods":
	if profile.SkipNodesWithSystemPods != nil {
		skipNodesWithSystemPods := *profile.SkipNodesWithSystemPods
		result.SkipNodesWithSystemPods = &skipNodesWithSystemPods
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterProperties_AutoScalerProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterProperties_AutoScalerProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterProperties_AutoScalerProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterProperties_AutoScalerProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterProperties_AutoScalerProfile, got %T", armInput)
	}

	// Set property "BalanceSimilarNodeGroups":
	if typedInput.BalanceSimilarNodeGroups != nil {
		balanceSimilarNodeGroups := *typedInput.BalanceSimilarNodeGroups
		profile.BalanceSimilarNodeGroups = &balanceSimilarNodeGroups
	}

	// Set property "Expander":
	if typedInput.Expander != nil {
		var temp string
		temp = string(*typedInput.Expander)
		expander := ManagedClusterProperties_AutoScalerProfile_Expander(temp)
		profile.Expander = &expander
	}

	// Set property "MaxEmptyBulkDelete":
	if typedInput.MaxEmptyBulkDelete != nil {
		maxEmptyBulkDelete := *typedInput.MaxEmptyBulkDelete
		profile.MaxEmptyBulkDelete = &maxEmptyBulkDelete
	}

	// Set property "MaxGracefulTerminationSec":
	if typedInput.MaxGracefulTerminationSec != nil {
		maxGracefulTerminationSec := *typedInput.MaxGracefulTerminationSec
		profile.MaxGracefulTerminationSec = &maxGracefulTerminationSec
	}

	// Set property "MaxNodeProvisionTime":
	if typedInput.MaxNodeProvisionTime != nil {
		maxNodeProvisionTime := *typedInput.MaxNodeProvisionTime
		profile.MaxNodeProvisionTime = &maxNodeProvisionTime
	}

	// Set property "MaxTotalUnreadyPercentage":
	if typedInput.MaxTotalUnreadyPercentage != nil {
		maxTotalUnreadyPercentage := *typedInput.MaxTotalUnreadyPercentage
		profile.MaxTotalUnreadyPercentage = &maxTotalUnreadyPercentage
	}

	// Set property "NewPodScaleUpDelay":
	if typedInput.NewPodScaleUpDelay != nil {
		newPodScaleUpDelay := *typedInput.NewPodScaleUpDelay
		profile.NewPodScaleUpDelay = &newPodScaleUpDelay
	}

	// Set property "OkTotalUnreadyCount":
	if typedInput.OkTotalUnreadyCount != nil {
		okTotalUnreadyCount := *typedInput.OkTotalUnreadyCount
		profile.OkTotalUnreadyCount = &okTotalUnreadyCount
	}

	// Set property "ScaleDownDelayAfterAdd":
	if typedInput.ScaleDownDelayAfterAdd != nil {
		scaleDownDelayAfterAdd := *typedInput.ScaleDownDelayAfterAdd
		profile.ScaleDownDelayAfterAdd = &scaleDownDelayAfterAdd
	}

	// Set property "ScaleDownDelayAfterDelete":
	if typedInput.ScaleDownDelayAfterDelete != nil {
		scaleDownDelayAfterDelete := *typedInput.ScaleDownDelayAfterDelete
		profile.ScaleDownDelayAfterDelete = &scaleDownDelayAfterDelete
	}

	// Set property "ScaleDownDelayAfterFailure":
	if typedInput.ScaleDownDelayAfterFailure != nil {
		scaleDownDelayAfterFailure := *typedInput.ScaleDownDelayAfterFailure
		profile.ScaleDownDelayAfterFailure = &scaleDownDelayAfterFailure
	}

	// Set property "ScaleDownUnneededTime":
	if typedInput.ScaleDownUnneededTime != nil {
		scaleDownUnneededTime := *typedInput.ScaleDownUnneededTime
		profile.ScaleDownUnneededTime = &scaleDownUnneededTime
	}

	// Set property "ScaleDownUnreadyTime":
	if typedInput.ScaleDownUnreadyTime != nil {
		scaleDownUnreadyTime := *typedInput.ScaleDownUnreadyTime
		profile.ScaleDownUnreadyTime = &scaleDownUnreadyTime
	}

	// Set property "ScaleDownUtilizationThreshold":
	if typedInput.ScaleDownUtilizationThreshold != nil {
		scaleDownUtilizationThreshold := *typedInput.ScaleDownUtilizationThreshold
		profile.ScaleDownUtilizationThreshold = &scaleDownUtilizationThreshold
	}

	// Set property "ScanInterval":
	if typedInput.ScanInterval != nil {
		scanInterval := *typedInput.ScanInterval
		profile.ScanInterval = &scanInterval
	}

	// Set property "SkipNodesWithLocalStorage":
	if typedInput.SkipNodesWithLocalStorage != nil {
		skipNodesWithLocalStorage := *typedInput.SkipNodesWithLocalStorage
		profile.SkipNodesWithLocalStorage = &skipNodesWithLocalStorage
	}

	// Set property "SkipNodesWithSystemPods":
	if typedInput.SkipNodesWithSystemPods != nil {
		skipNodesWithSystemPods := *typedInput.SkipNodesWithSystemPods
		profile.SkipNodesWithSystemPods = &skipNodesWithSystemPods
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterProperties_AutoScalerProfile populates our ManagedClusterProperties_AutoScalerProfile from the provided source ManagedClusterProperties_AutoScalerProfile
func (profile *ManagedClusterProperties_AutoScalerProfile) AssignProperties_From_ManagedClusterProperties_AutoScalerProfile(source *storage.ManagedClusterProperties_AutoScalerProfile) error {

	// BalanceSimilarNodeGroups
	profile.BalanceSimilarNodeGroups = genruntime.ClonePointerToString(source.BalanceSimilarNodeGroups)

	// Expander
	if source.Expander != nil {
		expander := *source.Expander
		expanderTemp := genruntime.ToEnum(expander, managedClusterProperties_AutoScalerProfile_Expander_Values)
		profile.Expander = &expanderTemp
	} else {
		profile.Expander = nil
	}

	// MaxEmptyBulkDelete
	profile.MaxEmptyBulkDelete = genruntime.ClonePointerToString(source.MaxEmptyBulkDelete)

	// MaxGracefulTerminationSec
	profile.MaxGracefulTerminationSec = genruntime.ClonePointerToString(source.MaxGracefulTerminationSec)

	// MaxNodeProvisionTime
	profile.MaxNodeProvisionTime = genruntime.ClonePointerToString(source.MaxNodeProvisionTime)

	// MaxTotalUnreadyPercentage
	profile.MaxTotalUnreadyPercentage = genruntime.ClonePointerToString(source.MaxTotalUnreadyPercentage)

	// NewPodScaleUpDelay
	profile.NewPodScaleUpDelay = genruntime.ClonePointerToString(source.NewPodScaleUpDelay)

	// OkTotalUnreadyCount
	profile.OkTotalUnreadyCount = genruntime.ClonePointerToString(source.OkTotalUnreadyCount)

	// ScaleDownDelayAfterAdd
	profile.ScaleDownDelayAfterAdd = genruntime.ClonePointerToString(source.ScaleDownDelayAfterAdd)

	// ScaleDownDelayAfterDelete
	profile.ScaleDownDelayAfterDelete = genruntime.ClonePointerToString(source.ScaleDownDelayAfterDelete)

	// ScaleDownDelayAfterFailure
	profile.ScaleDownDelayAfterFailure = genruntime.ClonePointerToString(source.ScaleDownDelayAfterFailure)

	// ScaleDownUnneededTime
	profile.ScaleDownUnneededTime = genruntime.ClonePointerToString(source.ScaleDownUnneededTime)

	// ScaleDownUnreadyTime
	profile.ScaleDownUnreadyTime = genruntime.ClonePointerToString(source.ScaleDownUnreadyTime)

	// ScaleDownUtilizationThreshold
	profile.ScaleDownUtilizationThreshold = genruntime.ClonePointerToString(source.ScaleDownUtilizationThreshold)

	// ScanInterval
	profile.ScanInterval = genruntime.ClonePointerToString(source.ScanInterval)

	// SkipNodesWithLocalStorage
	profile.SkipNodesWithLocalStorage = genruntime.ClonePointerToString(source.SkipNodesWithLocalStorage)

	// SkipNodesWithSystemPods
	profile.SkipNodesWithSystemPods = genruntime.ClonePointerToString(source.SkipNodesWithSystemPods)

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterProperties_AutoScalerProfile populates the provided destination ManagedClusterProperties_AutoScalerProfile from our ManagedClusterProperties_AutoScalerProfile
func (profile *ManagedClusterProperties_AutoScalerProfile) AssignProperties_To_ManagedClusterProperties_AutoScalerProfile(destination *storage.ManagedClusterProperties_AutoScalerProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BalanceSimilarNodeGroups
	destination.BalanceSimilarNodeGroups = genruntime.ClonePointerToString(profile.BalanceSimilarNodeGroups)

	// Expander
	if profile.Expander != nil {
		expander := string(*profile.Expander)
		destination.Expander = &expander
	} else {
		destination.Expander = nil
	}

	// MaxEmptyBulkDelete
	destination.MaxEmptyBulkDelete = genruntime.ClonePointerToString(profile.MaxEmptyBulkDelete)

	// MaxGracefulTerminationSec
	destination.MaxGracefulTerminationSec = genruntime.ClonePointerToString(profile.MaxGracefulTerminationSec)

	// MaxNodeProvisionTime
	destination.MaxNodeProvisionTime = genruntime.ClonePointerToString(profile.MaxNodeProvisionTime)

	// MaxTotalUnreadyPercentage
	destination.MaxTotalUnreadyPercentage = genruntime.ClonePointerToString(profile.MaxTotalUnreadyPercentage)

	// NewPodScaleUpDelay
	destination.NewPodScaleUpDelay = genruntime.ClonePointerToString(profile.NewPodScaleUpDelay)

	// OkTotalUnreadyCount
	destination.OkTotalUnreadyCount = genruntime.ClonePointerToString(profile.OkTotalUnreadyCount)

	// ScaleDownDelayAfterAdd
	destination.ScaleDownDelayAfterAdd = genruntime.ClonePointerToString(profile.ScaleDownDelayAfterAdd)

	// ScaleDownDelayAfterDelete
	destination.ScaleDownDelayAfterDelete = genruntime.ClonePointerToString(profile.ScaleDownDelayAfterDelete)

	// ScaleDownDelayAfterFailure
	destination.ScaleDownDelayAfterFailure = genruntime.ClonePointerToString(profile.ScaleDownDelayAfterFailure)

	// ScaleDownUnneededTime
	destination.ScaleDownUnneededTime = genruntime.ClonePointerToString(profile.ScaleDownUnneededTime)

	// ScaleDownUnreadyTime
	destination.ScaleDownUnreadyTime = genruntime.ClonePointerToString(profile.ScaleDownUnreadyTime)

	// ScaleDownUtilizationThreshold
	destination.ScaleDownUtilizationThreshold = genruntime.ClonePointerToString(profile.ScaleDownUtilizationThreshold)

	// ScanInterval
	destination.ScanInterval = genruntime.ClonePointerToString(profile.ScanInterval)

	// SkipNodesWithLocalStorage
	destination.SkipNodesWithLocalStorage = genruntime.ClonePointerToString(profile.SkipNodesWithLocalStorage)

	// SkipNodesWithSystemPods
	destination.SkipNodesWithSystemPods = genruntime.ClonePointerToString(profile.SkipNodesWithSystemPods)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterProperties_AutoScalerProfile_STATUS struct {
	BalanceSimilarNodeGroups      *string                                                     `json:"balance-similar-node-groups,omitempty"`
	Expander                      *ManagedClusterProperties_AutoScalerProfile_Expander_STATUS `json:"expander,omitempty"`
	MaxEmptyBulkDelete            *string                                                     `json:"max-empty-bulk-delete,omitempty"`
	MaxGracefulTerminationSec     *string                                                     `json:"max-graceful-termination-sec,omitempty"`
	MaxNodeProvisionTime          *string                                                     `json:"max-node-provision-time,omitempty"`
	MaxTotalUnreadyPercentage     *string                                                     `json:"max-total-unready-percentage,omitempty"`
	NewPodScaleUpDelay            *string                                                     `json:"new-pod-scale-up-delay,omitempty"`
	OkTotalUnreadyCount           *string                                                     `json:"ok-total-unready-count,omitempty"`
	ScaleDownDelayAfterAdd        *string                                                     `json:"scale-down-delay-after-add,omitempty"`
	ScaleDownDelayAfterDelete     *string                                                     `json:"scale-down-delay-after-delete,omitempty"`
	ScaleDownDelayAfterFailure    *string                                                     `json:"scale-down-delay-after-failure,omitempty"`
	ScaleDownUnneededTime         *string                                                     `json:"scale-down-unneeded-time,omitempty"`
	ScaleDownUnreadyTime          *string                                                     `json:"scale-down-unready-time,omitempty"`
	ScaleDownUtilizationThreshold *string                                                     `json:"scale-down-utilization-threshold,omitempty"`
	ScanInterval                  *string                                                     `json:"scan-interval,omitempty"`
	SkipNodesWithLocalStorage     *string                                                     `json:"skip-nodes-with-local-storage,omitempty"`
	SkipNodesWithSystemPods       *string                                                     `json:"skip-nodes-with-system-pods,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterProperties_AutoScalerProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterProperties_AutoScalerProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterProperties_AutoScalerProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterProperties_AutoScalerProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterProperties_AutoScalerProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterProperties_AutoScalerProfile_STATUS, got %T", armInput)
	}

	// Set property "BalanceSimilarNodeGroups":
	if typedInput.BalanceSimilarNodeGroups != nil {
		balanceSimilarNodeGroups := *typedInput.BalanceSimilarNodeGroups
		profile.BalanceSimilarNodeGroups = &balanceSimilarNodeGroups
	}

	// Set property "Expander":
	if typedInput.Expander != nil {
		var temp string
		temp = string(*typedInput.Expander)
		expander := ManagedClusterProperties_AutoScalerProfile_Expander_STATUS(temp)
		profile.Expander = &expander
	}

	// Set property "MaxEmptyBulkDelete":
	if typedInput.MaxEmptyBulkDelete != nil {
		maxEmptyBulkDelete := *typedInput.MaxEmptyBulkDelete
		profile.MaxEmptyBulkDelete = &maxEmptyBulkDelete
	}

	// Set property "MaxGracefulTerminationSec":
	if typedInput.MaxGracefulTerminationSec != nil {
		maxGracefulTerminationSec := *typedInput.MaxGracefulTerminationSec
		profile.MaxGracefulTerminationSec = &maxGracefulTerminationSec
	}

	// Set property "MaxNodeProvisionTime":
	if typedInput.MaxNodeProvisionTime != nil {
		maxNodeProvisionTime := *typedInput.MaxNodeProvisionTime
		profile.MaxNodeProvisionTime = &maxNodeProvisionTime
	}

	// Set property "MaxTotalUnreadyPercentage":
	if typedInput.MaxTotalUnreadyPercentage != nil {
		maxTotalUnreadyPercentage := *typedInput.MaxTotalUnreadyPercentage
		profile.MaxTotalUnreadyPercentage = &maxTotalUnreadyPercentage
	}

	// Set property "NewPodScaleUpDelay":
	if typedInput.NewPodScaleUpDelay != nil {
		newPodScaleUpDelay := *typedInput.NewPodScaleUpDelay
		profile.NewPodScaleUpDelay = &newPodScaleUpDelay
	}

	// Set property "OkTotalUnreadyCount":
	if typedInput.OkTotalUnreadyCount != nil {
		okTotalUnreadyCount := *typedInput.OkTotalUnreadyCount
		profile.OkTotalUnreadyCount = &okTotalUnreadyCount
	}

	// Set property "ScaleDownDelayAfterAdd":
	if typedInput.ScaleDownDelayAfterAdd != nil {
		scaleDownDelayAfterAdd := *typedInput.ScaleDownDelayAfterAdd
		profile.ScaleDownDelayAfterAdd = &scaleDownDelayAfterAdd
	}

	// Set property "ScaleDownDelayAfterDelete":
	if typedInput.ScaleDownDelayAfterDelete != nil {
		scaleDownDelayAfterDelete := *typedInput.ScaleDownDelayAfterDelete
		profile.ScaleDownDelayAfterDelete = &scaleDownDelayAfterDelete
	}

	// Set property "ScaleDownDelayAfterFailure":
	if typedInput.ScaleDownDelayAfterFailure != nil {
		scaleDownDelayAfterFailure := *typedInput.ScaleDownDelayAfterFailure
		profile.ScaleDownDelayAfterFailure = &scaleDownDelayAfterFailure
	}

	// Set property "ScaleDownUnneededTime":
	if typedInput.ScaleDownUnneededTime != nil {
		scaleDownUnneededTime := *typedInput.ScaleDownUnneededTime
		profile.ScaleDownUnneededTime = &scaleDownUnneededTime
	}

	// Set property "ScaleDownUnreadyTime":
	if typedInput.ScaleDownUnreadyTime != nil {
		scaleDownUnreadyTime := *typedInput.ScaleDownUnreadyTime
		profile.ScaleDownUnreadyTime = &scaleDownUnreadyTime
	}

	// Set property "ScaleDownUtilizationThreshold":
	if typedInput.ScaleDownUtilizationThreshold != nil {
		scaleDownUtilizationThreshold := *typedInput.ScaleDownUtilizationThreshold
		profile.ScaleDownUtilizationThreshold = &scaleDownUtilizationThreshold
	}

	// Set property "ScanInterval":
	if typedInput.ScanInterval != nil {
		scanInterval := *typedInput.ScanInterval
		profile.ScanInterval = &scanInterval
	}

	// Set property "SkipNodesWithLocalStorage":
	if typedInput.SkipNodesWithLocalStorage != nil {
		skipNodesWithLocalStorage := *typedInput.SkipNodesWithLocalStorage
		profile.SkipNodesWithLocalStorage = &skipNodesWithLocalStorage
	}

	// Set property "SkipNodesWithSystemPods":
	if typedInput.SkipNodesWithSystemPods != nil {
		skipNodesWithSystemPods := *typedInput.SkipNodesWithSystemPods
		profile.SkipNodesWithSystemPods = &skipNodesWithSystemPods
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterProperties_AutoScalerProfile_STATUS populates our ManagedClusterProperties_AutoScalerProfile_STATUS from the provided source ManagedClusterProperties_AutoScalerProfile_STATUS
func (profile *ManagedClusterProperties_AutoScalerProfile_STATUS) AssignProperties_From_ManagedClusterProperties_AutoScalerProfile_STATUS(source *storage.ManagedClusterProperties_AutoScalerProfile_STATUS) error {

	// BalanceSimilarNodeGroups
	profile.BalanceSimilarNodeGroups = genruntime.ClonePointerToString(source.BalanceSimilarNodeGroups)

	// Expander
	if source.Expander != nil {
		expander := *source.Expander
		expanderTemp := genruntime.ToEnum(expander, managedClusterProperties_AutoScalerProfile_Expander_STATUS_Values)
		profile.Expander = &expanderTemp
	} else {
		profile.Expander = nil
	}

	// MaxEmptyBulkDelete
	profile.MaxEmptyBulkDelete = genruntime.ClonePointerToString(source.MaxEmptyBulkDelete)

	// MaxGracefulTerminationSec
	profile.MaxGracefulTerminationSec = genruntime.ClonePointerToString(source.MaxGracefulTerminationSec)

	// MaxNodeProvisionTime
	profile.MaxNodeProvisionTime = genruntime.ClonePointerToString(source.MaxNodeProvisionTime)

	// MaxTotalUnreadyPercentage
	profile.MaxTotalUnreadyPercentage = genruntime.ClonePointerToString(source.MaxTotalUnreadyPercentage)

	// NewPodScaleUpDelay
	profile.NewPodScaleUpDelay = genruntime.ClonePointerToString(source.NewPodScaleUpDelay)

	// OkTotalUnreadyCount
	profile.OkTotalUnreadyCount = genruntime.ClonePointerToString(source.OkTotalUnreadyCount)

	// ScaleDownDelayAfterAdd
	profile.ScaleDownDelayAfterAdd = genruntime.ClonePointerToString(source.ScaleDownDelayAfterAdd)

	// ScaleDownDelayAfterDelete
	profile.ScaleDownDelayAfterDelete = genruntime.ClonePointerToString(source.ScaleDownDelayAfterDelete)

	// ScaleDownDelayAfterFailure
	profile.ScaleDownDelayAfterFailure = genruntime.ClonePointerToString(source.ScaleDownDelayAfterFailure)

	// ScaleDownUnneededTime
	profile.ScaleDownUnneededTime = genruntime.ClonePointerToString(source.ScaleDownUnneededTime)

	// ScaleDownUnreadyTime
	profile.ScaleDownUnreadyTime = genruntime.ClonePointerToString(source.ScaleDownUnreadyTime)

	// ScaleDownUtilizationThreshold
	profile.ScaleDownUtilizationThreshold = genruntime.ClonePointerToString(source.ScaleDownUtilizationThreshold)

	// ScanInterval
	profile.ScanInterval = genruntime.ClonePointerToString(source.ScanInterval)

	// SkipNodesWithLocalStorage
	profile.SkipNodesWithLocalStorage = genruntime.ClonePointerToString(source.SkipNodesWithLocalStorage)

	// SkipNodesWithSystemPods
	profile.SkipNodesWithSystemPods = genruntime.ClonePointerToString(source.SkipNodesWithSystemPods)

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterProperties_AutoScalerProfile_STATUS populates the provided destination ManagedClusterProperties_AutoScalerProfile_STATUS from our ManagedClusterProperties_AutoScalerProfile_STATUS
func (profile *ManagedClusterProperties_AutoScalerProfile_STATUS) AssignProperties_To_ManagedClusterProperties_AutoScalerProfile_STATUS(destination *storage.ManagedClusterProperties_AutoScalerProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BalanceSimilarNodeGroups
	destination.BalanceSimilarNodeGroups = genruntime.ClonePointerToString(profile.BalanceSimilarNodeGroups)

	// Expander
	if profile.Expander != nil {
		expander := string(*profile.Expander)
		destination.Expander = &expander
	} else {
		destination.Expander = nil
	}

	// MaxEmptyBulkDelete
	destination.MaxEmptyBulkDelete = genruntime.ClonePointerToString(profile.MaxEmptyBulkDelete)

	// MaxGracefulTerminationSec
	destination.MaxGracefulTerminationSec = genruntime.ClonePointerToString(profile.MaxGracefulTerminationSec)

	// MaxNodeProvisionTime
	destination.MaxNodeProvisionTime = genruntime.ClonePointerToString(profile.MaxNodeProvisionTime)

	// MaxTotalUnreadyPercentage
	destination.MaxTotalUnreadyPercentage = genruntime.ClonePointerToString(profile.MaxTotalUnreadyPercentage)

	// NewPodScaleUpDelay
	destination.NewPodScaleUpDelay = genruntime.ClonePointerToString(profile.NewPodScaleUpDelay)

	// OkTotalUnreadyCount
	destination.OkTotalUnreadyCount = genruntime.ClonePointerToString(profile.OkTotalUnreadyCount)

	// ScaleDownDelayAfterAdd
	destination.ScaleDownDelayAfterAdd = genruntime.ClonePointerToString(profile.ScaleDownDelayAfterAdd)

	// ScaleDownDelayAfterDelete
	destination.ScaleDownDelayAfterDelete = genruntime.ClonePointerToString(profile.ScaleDownDelayAfterDelete)

	// ScaleDownDelayAfterFailure
	destination.ScaleDownDelayAfterFailure = genruntime.ClonePointerToString(profile.ScaleDownDelayAfterFailure)

	// ScaleDownUnneededTime
	destination.ScaleDownUnneededTime = genruntime.ClonePointerToString(profile.ScaleDownUnneededTime)

	// ScaleDownUnreadyTime
	destination.ScaleDownUnreadyTime = genruntime.ClonePointerToString(profile.ScaleDownUnreadyTime)

	// ScaleDownUtilizationThreshold
	destination.ScaleDownUtilizationThreshold = genruntime.ClonePointerToString(profile.ScaleDownUtilizationThreshold)

	// ScanInterval
	destination.ScanInterval = genruntime.ClonePointerToString(profile.ScanInterval)

	// SkipNodesWithLocalStorage
	destination.SkipNodesWithLocalStorage = genruntime.ClonePointerToString(profile.SkipNodesWithLocalStorage)

	// SkipNodesWithSystemPods
	destination.SkipNodesWithSystemPods = genruntime.ClonePointerToString(profile.SkipNodesWithSystemPods)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterServicePrincipalProfile struct {
	// +kubebuilder:validation:Required
	ClientId *string                     `json:"clientId,omitempty"`
	Secret   *genruntime.SecretReference `json:"secret,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterServicePrincipalProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *ManagedClusterServicePrincipalProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.ManagedClusterServicePrincipalProfile{}

	// Set property "ClientId":
	if profile.ClientId != nil {
		clientId := *profile.ClientId
		result.ClientId = &clientId
	}

	// Set property "Secret":
	if profile.Secret != nil {
		secretSecret, err := resolved.ResolvedSecrets.Lookup(*profile.Secret)
		if err != nil {
			return nil, errors.Wrap(err, "looking up secret for property Secret")
		}
		secret := secretSecret
		result.Secret = &secret
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterServicePrincipalProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterServicePrincipalProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterServicePrincipalProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterServicePrincipalProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterServicePrincipalProfile, got %T", armInput)
	}

	// Set property "ClientId":
	if typedInput.ClientId != nil {
		clientId := *typedInput.ClientId
		profile.ClientId = &clientId
	}

	// no assignment for property "Secret"

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterServicePrincipalProfile populates our ManagedClusterServicePrincipalProfile from the provided source ManagedClusterServicePrincipalProfile
func (profile *ManagedClusterServicePrincipalProfile) AssignProperties_From_ManagedClusterServicePrincipalProfile(source *storage.ManagedClusterServicePrincipalProfile) error {

	// ClientId
	profile.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// Secret
	if source.Secret != nil {
		secret := source.Secret.Copy()
		profile.Secret = &secret
	} else {
		profile.Secret = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterServicePrincipalProfile populates the provided destination ManagedClusterServicePrincipalProfile from our ManagedClusterServicePrincipalProfile
func (profile *ManagedClusterServicePrincipalProfile) AssignProperties_To_ManagedClusterServicePrincipalProfile(destination *storage.ManagedClusterServicePrincipalProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(profile.ClientId)

	// Secret
	if profile.Secret != nil {
		secret := profile.Secret.Copy()
		destination.Secret = &secret
	} else {
		destination.Secret = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterServicePrincipalProfile_STATUS struct {
	ClientId *string `json:"clientId,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterServicePrincipalProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterServicePrincipalProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterServicePrincipalProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterServicePrincipalProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterServicePrincipalProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterServicePrincipalProfile_STATUS, got %T", armInput)
	}

	// Set property "ClientId":
	if typedInput.ClientId != nil {
		clientId := *typedInput.ClientId
		profile.ClientId = &clientId
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterServicePrincipalProfile_STATUS populates our ManagedClusterServicePrincipalProfile_STATUS from the provided source ManagedClusterServicePrincipalProfile_STATUS
func (profile *ManagedClusterServicePrincipalProfile_STATUS) AssignProperties_From_ManagedClusterServicePrincipalProfile_STATUS(source *storage.ManagedClusterServicePrincipalProfile_STATUS) error {

	// ClientId
	profile.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterServicePrincipalProfile_STATUS populates the provided destination ManagedClusterServicePrincipalProfile_STATUS from our ManagedClusterServicePrincipalProfile_STATUS
func (profile *ManagedClusterServicePrincipalProfile_STATUS) AssignProperties_To_ManagedClusterServicePrincipalProfile_STATUS(destination *storage.ManagedClusterServicePrincipalProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(profile.ClientId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterSKU struct {
	Name *ManagedClusterSKU_Name `json:"name,omitempty"`
	Tier *ManagedClusterSKU_Tier `json:"tier,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterSKU{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (clusterSKU *ManagedClusterSKU) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if clusterSKU == nil {
		return nil, nil
	}
	result := &arm.ManagedClusterSKU{}

	// Set property "Name":
	if clusterSKU.Name != nil {
		var temp string
		temp = string(*clusterSKU.Name)
		name := arm.ManagedClusterSKU_Name(temp)
		result.Name = &name
	}

	// Set property "Tier":
	if clusterSKU.Tier != nil {
		var temp string
		temp = string(*clusterSKU.Tier)
		tier := arm.ManagedClusterSKU_Tier(temp)
		result.Tier = &tier
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (clusterSKU *ManagedClusterSKU) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterSKU{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (clusterSKU *ManagedClusterSKU) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterSKU)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterSKU, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		var temp string
		temp = string(*typedInput.Name)
		name := ManagedClusterSKU_Name(temp)
		clusterSKU.Name = &name
	}

	// Set property "Tier":
	if typedInput.Tier != nil {
		var temp string
		temp = string(*typedInput.Tier)
		tier := ManagedClusterSKU_Tier(temp)
		clusterSKU.Tier = &tier
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterSKU populates our ManagedClusterSKU from the provided source ManagedClusterSKU
func (clusterSKU *ManagedClusterSKU) AssignProperties_From_ManagedClusterSKU(source *storage.ManagedClusterSKU) error {

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, managedClusterSKU_Name_Values)
		clusterSKU.Name = &nameTemp
	} else {
		clusterSKU.Name = nil
	}

	// Tier
	if source.Tier != nil {
		tier := *source.Tier
		tierTemp := genruntime.ToEnum(tier, managedClusterSKU_Tier_Values)
		clusterSKU.Tier = &tierTemp
	} else {
		clusterSKU.Tier = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterSKU populates the provided destination ManagedClusterSKU from our ManagedClusterSKU
func (clusterSKU *ManagedClusterSKU) AssignProperties_To_ManagedClusterSKU(destination *storage.ManagedClusterSKU) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if clusterSKU.Name != nil {
		name := string(*clusterSKU.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Tier
	if clusterSKU.Tier != nil {
		tier := string(*clusterSKU.Tier)
		destination.Tier = &tier
	} else {
		destination.Tier = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterSKU_STATUS struct {
	Name *ManagedClusterSKU_Name_STATUS `json:"name,omitempty"`
	Tier *ManagedClusterSKU_Tier_STATUS `json:"tier,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterSKU_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (clusterSKU *ManagedClusterSKU_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterSKU_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (clusterSKU *ManagedClusterSKU_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterSKU_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterSKU_STATUS, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		var temp string
		temp = string(*typedInput.Name)
		name := ManagedClusterSKU_Name_STATUS(temp)
		clusterSKU.Name = &name
	}

	// Set property "Tier":
	if typedInput.Tier != nil {
		var temp string
		temp = string(*typedInput.Tier)
		tier := ManagedClusterSKU_Tier_STATUS(temp)
		clusterSKU.Tier = &tier
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterSKU_STATUS populates our ManagedClusterSKU_STATUS from the provided source ManagedClusterSKU_STATUS
func (clusterSKU *ManagedClusterSKU_STATUS) AssignProperties_From_ManagedClusterSKU_STATUS(source *storage.ManagedClusterSKU_STATUS) error {

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, managedClusterSKU_Name_STATUS_Values)
		clusterSKU.Name = &nameTemp
	} else {
		clusterSKU.Name = nil
	}

	// Tier
	if source.Tier != nil {
		tier := *source.Tier
		tierTemp := genruntime.ToEnum(tier, managedClusterSKU_Tier_STATUS_Values)
		clusterSKU.Tier = &tierTemp
	} else {
		clusterSKU.Tier = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterSKU_STATUS populates the provided destination ManagedClusterSKU_STATUS from our ManagedClusterSKU_STATUS
func (clusterSKU *ManagedClusterSKU_STATUS) AssignProperties_To_ManagedClusterSKU_STATUS(destination *storage.ManagedClusterSKU_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if clusterSKU.Name != nil {
		name := string(*clusterSKU.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Tier
	if clusterSKU.Tier != nil {
		tier := string(*clusterSKU.Tier)
		destination.Tier = &tier
	} else {
		destination.Tier = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterWindowsProfile struct {
	AdminPassword *genruntime.SecretReference `json:"adminPassword,omitempty"`

	// +kubebuilder:validation:Required
	AdminUsername  *string                                   `json:"adminUsername,omitempty"`
	EnableCSIProxy *bool                                     `json:"enableCSIProxy,omitempty"`
	LicenseType    *ManagedClusterWindowsProfile_LicenseType `json:"licenseType,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterWindowsProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *ManagedClusterWindowsProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.ManagedClusterWindowsProfile{}

	// Set property "AdminPassword":
	if profile.AdminPassword != nil {
		adminPasswordSecret, err := resolved.ResolvedSecrets.Lookup(*profile.AdminPassword)
		if err != nil {
			return nil, errors.Wrap(err, "looking up secret for property AdminPassword")
		}
		adminPassword := adminPasswordSecret
		result.AdminPassword = &adminPassword
	}

	// Set property "AdminUsername":
	if profile.AdminUsername != nil {
		adminUsername := *profile.AdminUsername
		result.AdminUsername = &adminUsername
	}

	// Set property "EnableCSIProxy":
	if profile.EnableCSIProxy != nil {
		enableCSIProxy := *profile.EnableCSIProxy
		result.EnableCSIProxy = &enableCSIProxy
	}

	// Set property "LicenseType":
	if profile.LicenseType != nil {
		var temp string
		temp = string(*profile.LicenseType)
		licenseType := arm.ManagedClusterWindowsProfile_LicenseType(temp)
		result.LicenseType = &licenseType
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterWindowsProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterWindowsProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterWindowsProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterWindowsProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterWindowsProfile, got %T", armInput)
	}

	// no assignment for property "AdminPassword"

	// Set property "AdminUsername":
	if typedInput.AdminUsername != nil {
		adminUsername := *typedInput.AdminUsername
		profile.AdminUsername = &adminUsername
	}

	// Set property "EnableCSIProxy":
	if typedInput.EnableCSIProxy != nil {
		enableCSIProxy := *typedInput.EnableCSIProxy
		profile.EnableCSIProxy = &enableCSIProxy
	}

	// Set property "LicenseType":
	if typedInput.LicenseType != nil {
		var temp string
		temp = string(*typedInput.LicenseType)
		licenseType := ManagedClusterWindowsProfile_LicenseType(temp)
		profile.LicenseType = &licenseType
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterWindowsProfile populates our ManagedClusterWindowsProfile from the provided source ManagedClusterWindowsProfile
func (profile *ManagedClusterWindowsProfile) AssignProperties_From_ManagedClusterWindowsProfile(source *storage.ManagedClusterWindowsProfile) error {

	// AdminPassword
	if source.AdminPassword != nil {
		adminPassword := source.AdminPassword.Copy()
		profile.AdminPassword = &adminPassword
	} else {
		profile.AdminPassword = nil
	}

	// AdminUsername
	profile.AdminUsername = genruntime.ClonePointerToString(source.AdminUsername)

	// EnableCSIProxy
	if source.EnableCSIProxy != nil {
		enableCSIProxy := *source.EnableCSIProxy
		profile.EnableCSIProxy = &enableCSIProxy
	} else {
		profile.EnableCSIProxy = nil
	}

	// LicenseType
	if source.LicenseType != nil {
		licenseType := *source.LicenseType
		licenseTypeTemp := genruntime.ToEnum(licenseType, managedClusterWindowsProfile_LicenseType_Values)
		profile.LicenseType = &licenseTypeTemp
	} else {
		profile.LicenseType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterWindowsProfile populates the provided destination ManagedClusterWindowsProfile from our ManagedClusterWindowsProfile
func (profile *ManagedClusterWindowsProfile) AssignProperties_To_ManagedClusterWindowsProfile(destination *storage.ManagedClusterWindowsProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdminPassword
	if profile.AdminPassword != nil {
		adminPassword := profile.AdminPassword.Copy()
		destination.AdminPassword = &adminPassword
	} else {
		destination.AdminPassword = nil
	}

	// AdminUsername
	destination.AdminUsername = genruntime.ClonePointerToString(profile.AdminUsername)

	// EnableCSIProxy
	if profile.EnableCSIProxy != nil {
		enableCSIProxy := *profile.EnableCSIProxy
		destination.EnableCSIProxy = &enableCSIProxy
	} else {
		destination.EnableCSIProxy = nil
	}

	// LicenseType
	if profile.LicenseType != nil {
		licenseType := string(*profile.LicenseType)
		destination.LicenseType = &licenseType
	} else {
		destination.LicenseType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterWindowsProfile_STATUS struct {
	AdminUsername  *string                                          `json:"adminUsername,omitempty"`
	EnableCSIProxy *bool                                            `json:"enableCSIProxy,omitempty"`
	LicenseType    *ManagedClusterWindowsProfile_LicenseType_STATUS `json:"licenseType,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterWindowsProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterWindowsProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterWindowsProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterWindowsProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterWindowsProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterWindowsProfile_STATUS, got %T", armInput)
	}

	// Set property "AdminUsername":
	if typedInput.AdminUsername != nil {
		adminUsername := *typedInput.AdminUsername
		profile.AdminUsername = &adminUsername
	}

	// Set property "EnableCSIProxy":
	if typedInput.EnableCSIProxy != nil {
		enableCSIProxy := *typedInput.EnableCSIProxy
		profile.EnableCSIProxy = &enableCSIProxy
	}

	// Set property "LicenseType":
	if typedInput.LicenseType != nil {
		var temp string
		temp = string(*typedInput.LicenseType)
		licenseType := ManagedClusterWindowsProfile_LicenseType_STATUS(temp)
		profile.LicenseType = &licenseType
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterWindowsProfile_STATUS populates our ManagedClusterWindowsProfile_STATUS from the provided source ManagedClusterWindowsProfile_STATUS
func (profile *ManagedClusterWindowsProfile_STATUS) AssignProperties_From_ManagedClusterWindowsProfile_STATUS(source *storage.ManagedClusterWindowsProfile_STATUS) error {

	// AdminUsername
	profile.AdminUsername = genruntime.ClonePointerToString(source.AdminUsername)

	// EnableCSIProxy
	if source.EnableCSIProxy != nil {
		enableCSIProxy := *source.EnableCSIProxy
		profile.EnableCSIProxy = &enableCSIProxy
	} else {
		profile.EnableCSIProxy = nil
	}

	// LicenseType
	if source.LicenseType != nil {
		licenseType := *source.LicenseType
		licenseTypeTemp := genruntime.ToEnum(licenseType, managedClusterWindowsProfile_LicenseType_STATUS_Values)
		profile.LicenseType = &licenseTypeTemp
	} else {
		profile.LicenseType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterWindowsProfile_STATUS populates the provided destination ManagedClusterWindowsProfile_STATUS from our ManagedClusterWindowsProfile_STATUS
func (profile *ManagedClusterWindowsProfile_STATUS) AssignProperties_To_ManagedClusterWindowsProfile_STATUS(destination *storage.ManagedClusterWindowsProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdminUsername
	destination.AdminUsername = genruntime.ClonePointerToString(profile.AdminUsername)

	// EnableCSIProxy
	if profile.EnableCSIProxy != nil {
		enableCSIProxy := *profile.EnableCSIProxy
		destination.EnableCSIProxy = &enableCSIProxy
	} else {
		destination.EnableCSIProxy = nil
	}

	// LicenseType
	if profile.LicenseType != nil {
		licenseType := string(*profile.LicenseType)
		destination.LicenseType = &licenseType
	} else {
		destination.LicenseType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type PowerState_STATUS struct {
	Code *PowerState_Code_STATUS `json:"code,omitempty"`
}

var _ genruntime.FromARMConverter = &PowerState_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (state *PowerState_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.PowerState_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (state *PowerState_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.PowerState_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.PowerState_STATUS, got %T", armInput)
	}

	// Set property "Code":
	if typedInput.Code != nil {
		var temp string
		temp = string(*typedInput.Code)
		code := PowerState_Code_STATUS(temp)
		state.Code = &code
	}

	// No error
	return nil
}

// AssignProperties_From_PowerState_STATUS populates our PowerState_STATUS from the provided source PowerState_STATUS
func (state *PowerState_STATUS) AssignProperties_From_PowerState_STATUS(source *storage.PowerState_STATUS) error {

	// Code
	if source.Code != nil {
		code := *source.Code
		codeTemp := genruntime.ToEnum(code, powerState_Code_STATUS_Values)
		state.Code = &codeTemp
	} else {
		state.Code = nil
	}

	// No error
	return nil
}

// AssignProperties_To_PowerState_STATUS populates the provided destination PowerState_STATUS from our PowerState_STATUS
func (state *PowerState_STATUS) AssignProperties_To_PowerState_STATUS(destination *storage.PowerState_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Code
	if state.Code != nil {
		code := string(*state.Code)
		destination.Code = &code
	} else {
		destination.Code = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type PrivateLinkResource struct {
	GroupId         *string                       `json:"groupId,omitempty"`
	Name            *string                       `json:"name,omitempty"`
	Reference       *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
	RequiredMembers []string                      `json:"requiredMembers,omitempty"`
	Type            *string                       `json:"type,omitempty"`
}

var _ genruntime.ARMTransformer = &PrivateLinkResource{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (resource *PrivateLinkResource) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if resource == nil {
		return nil, nil
	}
	result := &arm.PrivateLinkResource{}

	// Set property "GroupId":
	if resource.GroupId != nil {
		groupId := *resource.GroupId
		result.GroupId = &groupId
	}

	// Set property "Id":
	if resource.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.Lookup(*resource.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}

	// Set property "Name":
	if resource.Name != nil {
		name := *resource.Name
		result.Name = &name
	}

	// Set property "RequiredMembers":
	for _, item := range resource.RequiredMembers {
		result.RequiredMembers = append(result.RequiredMembers, item)
	}

	// Set property "Type":
	if resource.Type != nil {
		typeVar := *resource.Type
		result.Type = &typeVar
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (resource *PrivateLinkResource) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.PrivateLinkResource{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (resource *PrivateLinkResource) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.PrivateLinkResource)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.PrivateLinkResource, got %T", armInput)
	}

	// Set property "GroupId":
	if typedInput.GroupId != nil {
		groupId := *typedInput.GroupId
		resource.GroupId = &groupId
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		resource.Name = &name
	}

	// no assignment for property "Reference"

	// Set property "RequiredMembers":
	for _, item := range typedInput.RequiredMembers {
		resource.RequiredMembers = append(resource.RequiredMembers, item)
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		resource.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_PrivateLinkResource populates our PrivateLinkResource from the provided source PrivateLinkResource
func (resource *PrivateLinkResource) AssignProperties_From_PrivateLinkResource(source *storage.PrivateLinkResource) error {

	// GroupId
	resource.GroupId = genruntime.ClonePointerToString(source.GroupId)

	// Name
	resource.Name = genruntime.ClonePointerToString(source.Name)

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		resource.Reference = &reference
	} else {
		resource.Reference = nil
	}

	// RequiredMembers
	resource.RequiredMembers = genruntime.CloneSliceOfString(source.RequiredMembers)

	// Type
	resource.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignProperties_To_PrivateLinkResource populates the provided destination PrivateLinkResource from our PrivateLinkResource
func (resource *PrivateLinkResource) AssignProperties_To_PrivateLinkResource(destination *storage.PrivateLinkResource) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// GroupId
	destination.GroupId = genruntime.ClonePointerToString(resource.GroupId)

	// Name
	destination.Name = genruntime.ClonePointerToString(resource.Name)

	// Reference
	if resource.Reference != nil {
		reference := resource.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// RequiredMembers
	destination.RequiredMembers = genruntime.CloneSliceOfString(resource.RequiredMembers)

	// Type
	destination.Type = genruntime.ClonePointerToString(resource.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type PrivateLinkResource_STATUS struct {
	GroupId              *string  `json:"groupId,omitempty"`
	Id                   *string  `json:"id,omitempty"`
	Name                 *string  `json:"name,omitempty"`
	PrivateLinkServiceID *string  `json:"privateLinkServiceID,omitempty"`
	RequiredMembers      []string `json:"requiredMembers,omitempty"`
	Type                 *string  `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &PrivateLinkResource_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (resource *PrivateLinkResource_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.PrivateLinkResource_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (resource *PrivateLinkResource_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.PrivateLinkResource_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.PrivateLinkResource_STATUS, got %T", armInput)
	}

	// Set property "GroupId":
	if typedInput.GroupId != nil {
		groupId := *typedInput.GroupId
		resource.GroupId = &groupId
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		resource.Id = &id
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		resource.Name = &name
	}

	// Set property "PrivateLinkServiceID":
	if typedInput.PrivateLinkServiceID != nil {
		privateLinkServiceID := *typedInput.PrivateLinkServiceID
		resource.PrivateLinkServiceID = &privateLinkServiceID
	}

	// Set property "RequiredMembers":
	for _, item := range typedInput.RequiredMembers {
		resource.RequiredMembers = append(resource.RequiredMembers, item)
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		resource.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_PrivateLinkResource_STATUS populates our PrivateLinkResource_STATUS from the provided source PrivateLinkResource_STATUS
func (resource *PrivateLinkResource_STATUS) AssignProperties_From_PrivateLinkResource_STATUS(source *storage.PrivateLinkResource_STATUS) error {

	// GroupId
	resource.GroupId = genruntime.ClonePointerToString(source.GroupId)

	// Id
	resource.Id = genruntime.ClonePointerToString(source.Id)

	// Name
	resource.Name = genruntime.ClonePointerToString(source.Name)

	// PrivateLinkServiceID
	resource.PrivateLinkServiceID = genruntime.ClonePointerToString(source.PrivateLinkServiceID)

	// RequiredMembers
	resource.RequiredMembers = genruntime.CloneSliceOfString(source.RequiredMembers)

	// Type
	resource.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignProperties_To_PrivateLinkResource_STATUS populates the provided destination PrivateLinkResource_STATUS from our PrivateLinkResource_STATUS
func (resource *PrivateLinkResource_STATUS) AssignProperties_To_PrivateLinkResource_STATUS(destination *storage.PrivateLinkResource_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// GroupId
	destination.GroupId = genruntime.ClonePointerToString(resource.GroupId)

	// Id
	destination.Id = genruntime.ClonePointerToString(resource.Id)

	// Name
	destination.Name = genruntime.ClonePointerToString(resource.Name)

	// PrivateLinkServiceID
	destination.PrivateLinkServiceID = genruntime.ClonePointerToString(resource.PrivateLinkServiceID)

	// RequiredMembers
	destination.RequiredMembers = genruntime.CloneSliceOfString(resource.RequiredMembers)

	// Type
	destination.Type = genruntime.ClonePointerToString(resource.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type UserAssignedIdentity struct {
	ClientId          *string                       `json:"clientId,omitempty"`
	ObjectId          *string                       `json:"objectId,omitempty"`
	ResourceReference *genruntime.ResourceReference `armReference:"ResourceId" json:"resourceReference,omitempty"`
}

var _ genruntime.ARMTransformer = &UserAssignedIdentity{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (identity *UserAssignedIdentity) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if identity == nil {
		return nil, nil
	}
	result := &arm.UserAssignedIdentity{}

	// Set property "ClientId":
	if identity.ClientId != nil {
		clientId := *identity.ClientId
		result.ClientId = &clientId
	}

	// Set property "ObjectId":
	if identity.ObjectId != nil {
		objectId := *identity.ObjectId
		result.ObjectId = &objectId
	}

	// Set property "ResourceId":
	if identity.ResourceReference != nil {
		resourceReferenceARMID, err := resolved.ResolvedReferences.Lookup(*identity.ResourceReference)
		if err != nil {
			return nil, err
		}
		resourceReference := resourceReferenceARMID
		result.ResourceId = &resourceReference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *UserAssignedIdentity) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.UserAssignedIdentity{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *UserAssignedIdentity) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.UserAssignedIdentity)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.UserAssignedIdentity, got %T", armInput)
	}

	// Set property "ClientId":
	if typedInput.ClientId != nil {
		clientId := *typedInput.ClientId
		identity.ClientId = &clientId
	}

	// Set property "ObjectId":
	if typedInput.ObjectId != nil {
		objectId := *typedInput.ObjectId
		identity.ObjectId = &objectId
	}

	// no assignment for property "ResourceReference"

	// No error
	return nil
}

// AssignProperties_From_UserAssignedIdentity populates our UserAssignedIdentity from the provided source UserAssignedIdentity
func (identity *UserAssignedIdentity) AssignProperties_From_UserAssignedIdentity(source *storage.UserAssignedIdentity) error {

	// ClientId
	identity.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// ObjectId
	identity.ObjectId = genruntime.ClonePointerToString(source.ObjectId)

	// ResourceReference
	if source.ResourceReference != nil {
		resourceReference := source.ResourceReference.Copy()
		identity.ResourceReference = &resourceReference
	} else {
		identity.ResourceReference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_UserAssignedIdentity populates the provided destination UserAssignedIdentity from our UserAssignedIdentity
func (identity *UserAssignedIdentity) AssignProperties_To_UserAssignedIdentity(destination *storage.UserAssignedIdentity) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(identity.ClientId)

	// ObjectId
	destination.ObjectId = genruntime.ClonePointerToString(identity.ObjectId)

	// ResourceReference
	if identity.ResourceReference != nil {
		resourceReference := identity.ResourceReference.Copy()
		destination.ResourceReference = &resourceReference
	} else {
		destination.ResourceReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type UserAssignedIdentity_STATUS struct {
	ClientId   *string `json:"clientId,omitempty"`
	ObjectId   *string `json:"objectId,omitempty"`
	ResourceId *string `json:"resourceId,omitempty"`
}

var _ genruntime.FromARMConverter = &UserAssignedIdentity_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *UserAssignedIdentity_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.UserAssignedIdentity_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *UserAssignedIdentity_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.UserAssignedIdentity_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.UserAssignedIdentity_STATUS, got %T", armInput)
	}

	// Set property "ClientId":
	if typedInput.ClientId != nil {
		clientId := *typedInput.ClientId
		identity.ClientId = &clientId
	}

	// Set property "ObjectId":
	if typedInput.ObjectId != nil {
		objectId := *typedInput.ObjectId
		identity.ObjectId = &objectId
	}

	// Set property "ResourceId":
	if typedInput.ResourceId != nil {
		resourceId := *typedInput.ResourceId
		identity.ResourceId = &resourceId
	}

	// No error
	return nil
}

// AssignProperties_From_UserAssignedIdentity_STATUS populates our UserAssignedIdentity_STATUS from the provided source UserAssignedIdentity_STATUS
func (identity *UserAssignedIdentity_STATUS) AssignProperties_From_UserAssignedIdentity_STATUS(source *storage.UserAssignedIdentity_STATUS) error {

	// ClientId
	identity.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// ObjectId
	identity.ObjectId = genruntime.ClonePointerToString(source.ObjectId)

	// ResourceId
	identity.ResourceId = genruntime.ClonePointerToString(source.ResourceId)

	// No error
	return nil
}

// AssignProperties_To_UserAssignedIdentity_STATUS populates the provided destination UserAssignedIdentity_STATUS from our UserAssignedIdentity_STATUS
func (identity *UserAssignedIdentity_STATUS) AssignProperties_To_UserAssignedIdentity_STATUS(destination *storage.UserAssignedIdentity_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(identity.ClientId)

	// ObjectId
	destination.ObjectId = genruntime.ClonePointerToString(identity.ObjectId)

	// ResourceId
	destination.ResourceId = genruntime.ClonePointerToString(identity.ResourceId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"basic","standard"}
type ContainerServiceNetworkProfile_LoadBalancerSku string

const (
	ContainerServiceNetworkProfile_LoadBalancerSku_Basic    = ContainerServiceNetworkProfile_LoadBalancerSku("basic")
	ContainerServiceNetworkProfile_LoadBalancerSku_Standard = ContainerServiceNetworkProfile_LoadBalancerSku("standard")
)

// Mapping from string to ContainerServiceNetworkProfile_LoadBalancerSku
var containerServiceNetworkProfile_LoadBalancerSku_Values = map[string]ContainerServiceNetworkProfile_LoadBalancerSku{
	"basic":    ContainerServiceNetworkProfile_LoadBalancerSku_Basic,
	"standard": ContainerServiceNetworkProfile_LoadBalancerSku_Standard,
}

type ContainerServiceNetworkProfile_LoadBalancerSku_STATUS string

const (
	ContainerServiceNetworkProfile_LoadBalancerSku_STATUS_Basic    = ContainerServiceNetworkProfile_LoadBalancerSku_STATUS("basic")
	ContainerServiceNetworkProfile_LoadBalancerSku_STATUS_Standard = ContainerServiceNetworkProfile_LoadBalancerSku_STATUS("standard")
)

// Mapping from string to ContainerServiceNetworkProfile_LoadBalancerSku_STATUS
var containerServiceNetworkProfile_LoadBalancerSku_STATUS_Values = map[string]ContainerServiceNetworkProfile_LoadBalancerSku_STATUS{
	"basic":    ContainerServiceNetworkProfile_LoadBalancerSku_STATUS_Basic,
	"standard": ContainerServiceNetworkProfile_LoadBalancerSku_STATUS_Standard,
}

// +kubebuilder:validation:Enum={"bridge","transparent"}
type ContainerServiceNetworkProfile_NetworkMode string

const (
	ContainerServiceNetworkProfile_NetworkMode_Bridge      = ContainerServiceNetworkProfile_NetworkMode("bridge")
	ContainerServiceNetworkProfile_NetworkMode_Transparent = ContainerServiceNetworkProfile_NetworkMode("transparent")
)

// Mapping from string to ContainerServiceNetworkProfile_NetworkMode
var containerServiceNetworkProfile_NetworkMode_Values = map[string]ContainerServiceNetworkProfile_NetworkMode{
	"bridge":      ContainerServiceNetworkProfile_NetworkMode_Bridge,
	"transparent": ContainerServiceNetworkProfile_NetworkMode_Transparent,
}

type ContainerServiceNetworkProfile_NetworkMode_STATUS string

const (
	ContainerServiceNetworkProfile_NetworkMode_STATUS_Bridge      = ContainerServiceNetworkProfile_NetworkMode_STATUS("bridge")
	ContainerServiceNetworkProfile_NetworkMode_STATUS_Transparent = ContainerServiceNetworkProfile_NetworkMode_STATUS("transparent")
)

// Mapping from string to ContainerServiceNetworkProfile_NetworkMode_STATUS
var containerServiceNetworkProfile_NetworkMode_STATUS_Values = map[string]ContainerServiceNetworkProfile_NetworkMode_STATUS{
	"bridge":      ContainerServiceNetworkProfile_NetworkMode_STATUS_Bridge,
	"transparent": ContainerServiceNetworkProfile_NetworkMode_STATUS_Transparent,
}

// +kubebuilder:validation:Enum={"azure","kubenet"}
type ContainerServiceNetworkProfile_NetworkPlugin string

const (
	ContainerServiceNetworkProfile_NetworkPlugin_Azure   = ContainerServiceNetworkProfile_NetworkPlugin("azure")
	ContainerServiceNetworkProfile_NetworkPlugin_Kubenet = ContainerServiceNetworkProfile_NetworkPlugin("kubenet")
)

// Mapping from string to ContainerServiceNetworkProfile_NetworkPlugin
var containerServiceNetworkProfile_NetworkPlugin_Values = map[string]ContainerServiceNetworkProfile_NetworkPlugin{
	"azure":   ContainerServiceNetworkProfile_NetworkPlugin_Azure,
	"kubenet": ContainerServiceNetworkProfile_NetworkPlugin_Kubenet,
}

type ContainerServiceNetworkProfile_NetworkPlugin_STATUS string

const (
	ContainerServiceNetworkProfile_NetworkPlugin_STATUS_Azure   = ContainerServiceNetworkProfile_NetworkPlugin_STATUS("azure")
	ContainerServiceNetworkProfile_NetworkPlugin_STATUS_Kubenet = ContainerServiceNetworkProfile_NetworkPlugin_STATUS("kubenet")
)

// Mapping from string to ContainerServiceNetworkProfile_NetworkPlugin_STATUS
var containerServiceNetworkProfile_NetworkPlugin_STATUS_Values = map[string]ContainerServiceNetworkProfile_NetworkPlugin_STATUS{
	"azure":   ContainerServiceNetworkProfile_NetworkPlugin_STATUS_Azure,
	"kubenet": ContainerServiceNetworkProfile_NetworkPlugin_STATUS_Kubenet,
}

// +kubebuilder:validation:Enum={"azure","calico"}
type ContainerServiceNetworkProfile_NetworkPolicy string

const (
	ContainerServiceNetworkProfile_NetworkPolicy_Azure  = ContainerServiceNetworkProfile_NetworkPolicy("azure")
	ContainerServiceNetworkProfile_NetworkPolicy_Calico = ContainerServiceNetworkProfile_NetworkPolicy("calico")
)

// Mapping from string to ContainerServiceNetworkProfile_NetworkPolicy
var containerServiceNetworkProfile_NetworkPolicy_Values = map[string]ContainerServiceNetworkProfile_NetworkPolicy{
	"azure":  ContainerServiceNetworkProfile_NetworkPolicy_Azure,
	"calico": ContainerServiceNetworkProfile_NetworkPolicy_Calico,
}

type ContainerServiceNetworkProfile_NetworkPolicy_STATUS string

const (
	ContainerServiceNetworkProfile_NetworkPolicy_STATUS_Azure  = ContainerServiceNetworkProfile_NetworkPolicy_STATUS("azure")
	ContainerServiceNetworkProfile_NetworkPolicy_STATUS_Calico = ContainerServiceNetworkProfile_NetworkPolicy_STATUS("calico")
)

// Mapping from string to ContainerServiceNetworkProfile_NetworkPolicy_STATUS
var containerServiceNetworkProfile_NetworkPolicy_STATUS_Values = map[string]ContainerServiceNetworkProfile_NetworkPolicy_STATUS{
	"azure":  ContainerServiceNetworkProfile_NetworkPolicy_STATUS_Azure,
	"calico": ContainerServiceNetworkProfile_NetworkPolicy_STATUS_Calico,
}

// +kubebuilder:validation:Enum={"loadBalancer","userDefinedRouting"}
type ContainerServiceNetworkProfile_OutboundType string

const (
	ContainerServiceNetworkProfile_OutboundType_LoadBalancer       = ContainerServiceNetworkProfile_OutboundType("loadBalancer")
	ContainerServiceNetworkProfile_OutboundType_UserDefinedRouting = ContainerServiceNetworkProfile_OutboundType("userDefinedRouting")
)

// Mapping from string to ContainerServiceNetworkProfile_OutboundType
var containerServiceNetworkProfile_OutboundType_Values = map[string]ContainerServiceNetworkProfile_OutboundType{
	"loadbalancer":       ContainerServiceNetworkProfile_OutboundType_LoadBalancer,
	"userdefinedrouting": ContainerServiceNetworkProfile_OutboundType_UserDefinedRouting,
}

type ContainerServiceNetworkProfile_OutboundType_STATUS string

const (
	ContainerServiceNetworkProfile_OutboundType_STATUS_LoadBalancer       = ContainerServiceNetworkProfile_OutboundType_STATUS("loadBalancer")
	ContainerServiceNetworkProfile_OutboundType_STATUS_UserDefinedRouting = ContainerServiceNetworkProfile_OutboundType_STATUS("userDefinedRouting")
)

// Mapping from string to ContainerServiceNetworkProfile_OutboundType_STATUS
var containerServiceNetworkProfile_OutboundType_STATUS_Values = map[string]ContainerServiceNetworkProfile_OutboundType_STATUS{
	"loadbalancer":       ContainerServiceNetworkProfile_OutboundType_STATUS_LoadBalancer,
	"userdefinedrouting": ContainerServiceNetworkProfile_OutboundType_STATUS_UserDefinedRouting,
}

type ContainerServiceSshConfiguration struct {
	// +kubebuilder:validation:Required
	PublicKeys []ContainerServiceSshPublicKey `json:"publicKeys,omitempty"`
}

var _ genruntime.ARMTransformer = &ContainerServiceSshConfiguration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (configuration *ContainerServiceSshConfiguration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if configuration == nil {
		return nil, nil
	}
	result := &arm.ContainerServiceSshConfiguration{}

	// Set property "PublicKeys":
	for _, item := range configuration.PublicKeys {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.PublicKeys = append(result.PublicKeys, *item_ARM.(*arm.ContainerServiceSshPublicKey))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *ContainerServiceSshConfiguration) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ContainerServiceSshConfiguration{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *ContainerServiceSshConfiguration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ContainerServiceSshConfiguration)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ContainerServiceSshConfiguration, got %T", armInput)
	}

	// Set property "PublicKeys":
	for _, item := range typedInput.PublicKeys {
		var item1 ContainerServiceSshPublicKey
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		configuration.PublicKeys = append(configuration.PublicKeys, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_ContainerServiceSshConfiguration populates our ContainerServiceSshConfiguration from the provided source ContainerServiceSshConfiguration
func (configuration *ContainerServiceSshConfiguration) AssignProperties_From_ContainerServiceSshConfiguration(source *storage.ContainerServiceSshConfiguration) error {

	// PublicKeys
	if source.PublicKeys != nil {
		publicKeyList := make([]ContainerServiceSshPublicKey, len(source.PublicKeys))
		for publicKeyIndex, publicKeyItem := range source.PublicKeys {
			// Shadow the loop variable to avoid aliasing
			publicKeyItem := publicKeyItem
			var publicKey ContainerServiceSshPublicKey
			err := publicKey.AssignProperties_From_ContainerServiceSshPublicKey(&publicKeyItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ContainerServiceSshPublicKey() to populate field PublicKeys")
			}
			publicKeyList[publicKeyIndex] = publicKey
		}
		configuration.PublicKeys = publicKeyList
	} else {
		configuration.PublicKeys = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ContainerServiceSshConfiguration populates the provided destination ContainerServiceSshConfiguration from our ContainerServiceSshConfiguration
func (configuration *ContainerServiceSshConfiguration) AssignProperties_To_ContainerServiceSshConfiguration(destination *storage.ContainerServiceSshConfiguration) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PublicKeys
	if configuration.PublicKeys != nil {
		publicKeyList := make([]storage.ContainerServiceSshPublicKey, len(configuration.PublicKeys))
		for publicKeyIndex, publicKeyItem := range configuration.PublicKeys {
			// Shadow the loop variable to avoid aliasing
			publicKeyItem := publicKeyItem
			var publicKey storage.ContainerServiceSshPublicKey
			err := publicKeyItem.AssignProperties_To_ContainerServiceSshPublicKey(&publicKey)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ContainerServiceSshPublicKey() to populate field PublicKeys")
			}
			publicKeyList[publicKeyIndex] = publicKey
		}
		destination.PublicKeys = publicKeyList
	} else {
		destination.PublicKeys = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ContainerServiceSshConfiguration_STATUS struct {
	PublicKeys []ContainerServiceSshPublicKey_STATUS `json:"publicKeys,omitempty"`
}

var _ genruntime.FromARMConverter = &ContainerServiceSshConfiguration_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *ContainerServiceSshConfiguration_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ContainerServiceSshConfiguration_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *ContainerServiceSshConfiguration_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ContainerServiceSshConfiguration_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ContainerServiceSshConfiguration_STATUS, got %T", armInput)
	}

	// Set property "PublicKeys":
	for _, item := range typedInput.PublicKeys {
		var item1 ContainerServiceSshPublicKey_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		configuration.PublicKeys = append(configuration.PublicKeys, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_ContainerServiceSshConfiguration_STATUS populates our ContainerServiceSshConfiguration_STATUS from the provided source ContainerServiceSshConfiguration_STATUS
func (configuration *ContainerServiceSshConfiguration_STATUS) AssignProperties_From_ContainerServiceSshConfiguration_STATUS(source *storage.ContainerServiceSshConfiguration_STATUS) error {

	// PublicKeys
	if source.PublicKeys != nil {
		publicKeyList := make([]ContainerServiceSshPublicKey_STATUS, len(source.PublicKeys))
		for publicKeyIndex, publicKeyItem := range source.PublicKeys {
			// Shadow the loop variable to avoid aliasing
			publicKeyItem := publicKeyItem
			var publicKey ContainerServiceSshPublicKey_STATUS
			err := publicKey.AssignProperties_From_ContainerServiceSshPublicKey_STATUS(&publicKeyItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ContainerServiceSshPublicKey_STATUS() to populate field PublicKeys")
			}
			publicKeyList[publicKeyIndex] = publicKey
		}
		configuration.PublicKeys = publicKeyList
	} else {
		configuration.PublicKeys = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ContainerServiceSshConfiguration_STATUS populates the provided destination ContainerServiceSshConfiguration_STATUS from our ContainerServiceSshConfiguration_STATUS
func (configuration *ContainerServiceSshConfiguration_STATUS) AssignProperties_To_ContainerServiceSshConfiguration_STATUS(destination *storage.ContainerServiceSshConfiguration_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PublicKeys
	if configuration.PublicKeys != nil {
		publicKeyList := make([]storage.ContainerServiceSshPublicKey_STATUS, len(configuration.PublicKeys))
		for publicKeyIndex, publicKeyItem := range configuration.PublicKeys {
			// Shadow the loop variable to avoid aliasing
			publicKeyItem := publicKeyItem
			var publicKey storage.ContainerServiceSshPublicKey_STATUS
			err := publicKeyItem.AssignProperties_To_ContainerServiceSshPublicKey_STATUS(&publicKey)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ContainerServiceSshPublicKey_STATUS() to populate field PublicKeys")
			}
			publicKeyList[publicKeyIndex] = publicKey
		}
		destination.PublicKeys = publicKeyList
	} else {
		destination.PublicKeys = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"EdgeZone"}
type ExtendedLocationType string

const ExtendedLocationType_EdgeZone = ExtendedLocationType("EdgeZone")

// Mapping from string to ExtendedLocationType
var extendedLocationType_Values = map[string]ExtendedLocationType{
	"edgezone": ExtendedLocationType_EdgeZone,
}

type ExtendedLocationType_STATUS string

const ExtendedLocationType_STATUS_EdgeZone = ExtendedLocationType_STATUS("EdgeZone")

// Mapping from string to ExtendedLocationType_STATUS
var extendedLocationType_STATUS_Values = map[string]ExtendedLocationType_STATUS{
	"edgezone": ExtendedLocationType_STATUS_EdgeZone,
}

// +kubebuilder:validation:Enum={"node-image","none","patch","rapid","stable"}
type ManagedClusterAutoUpgradeProfile_UpgradeChannel string

const (
	ManagedClusterAutoUpgradeProfile_UpgradeChannel_NodeImage = ManagedClusterAutoUpgradeProfile_UpgradeChannel("node-image")
	ManagedClusterAutoUpgradeProfile_UpgradeChannel_None      = ManagedClusterAutoUpgradeProfile_UpgradeChannel("none")
	ManagedClusterAutoUpgradeProfile_UpgradeChannel_Patch     = ManagedClusterAutoUpgradeProfile_UpgradeChannel("patch")
	ManagedClusterAutoUpgradeProfile_UpgradeChannel_Rapid     = ManagedClusterAutoUpgradeProfile_UpgradeChannel("rapid")
	ManagedClusterAutoUpgradeProfile_UpgradeChannel_Stable    = ManagedClusterAutoUpgradeProfile_UpgradeChannel("stable")
)

// Mapping from string to ManagedClusterAutoUpgradeProfile_UpgradeChannel
var managedClusterAutoUpgradeProfile_UpgradeChannel_Values = map[string]ManagedClusterAutoUpgradeProfile_UpgradeChannel{
	"node-image": ManagedClusterAutoUpgradeProfile_UpgradeChannel_NodeImage,
	"none":       ManagedClusterAutoUpgradeProfile_UpgradeChannel_None,
	"patch":      ManagedClusterAutoUpgradeProfile_UpgradeChannel_Patch,
	"rapid":      ManagedClusterAutoUpgradeProfile_UpgradeChannel_Rapid,
	"stable":     ManagedClusterAutoUpgradeProfile_UpgradeChannel_Stable,
}

type ManagedClusterAutoUpgradeProfile_UpgradeChannel_STATUS string

const (
	ManagedClusterAutoUpgradeProfile_UpgradeChannel_STATUS_NodeImage = ManagedClusterAutoUpgradeProfile_UpgradeChannel_STATUS("node-image")
	ManagedClusterAutoUpgradeProfile_UpgradeChannel_STATUS_None      = ManagedClusterAutoUpgradeProfile_UpgradeChannel_STATUS("none")
	ManagedClusterAutoUpgradeProfile_UpgradeChannel_STATUS_Patch     = ManagedClusterAutoUpgradeProfile_UpgradeChannel_STATUS("patch")
	ManagedClusterAutoUpgradeProfile_UpgradeChannel_STATUS_Rapid     = ManagedClusterAutoUpgradeProfile_UpgradeChannel_STATUS("rapid")
	ManagedClusterAutoUpgradeProfile_UpgradeChannel_STATUS_Stable    = ManagedClusterAutoUpgradeProfile_UpgradeChannel_STATUS("stable")
)

// Mapping from string to ManagedClusterAutoUpgradeProfile_UpgradeChannel_STATUS
var managedClusterAutoUpgradeProfile_UpgradeChannel_STATUS_Values = map[string]ManagedClusterAutoUpgradeProfile_UpgradeChannel_STATUS{
	"node-image": ManagedClusterAutoUpgradeProfile_UpgradeChannel_STATUS_NodeImage,
	"none":       ManagedClusterAutoUpgradeProfile_UpgradeChannel_STATUS_None,
	"patch":      ManagedClusterAutoUpgradeProfile_UpgradeChannel_STATUS_Patch,
	"rapid":      ManagedClusterAutoUpgradeProfile_UpgradeChannel_STATUS_Rapid,
	"stable":     ManagedClusterAutoUpgradeProfile_UpgradeChannel_STATUS_Stable,
}

// +kubebuilder:validation:Enum={"None","SystemAssigned","UserAssigned"}
type ManagedClusterIdentity_Type string

const (
	ManagedClusterIdentity_Type_None           = ManagedClusterIdentity_Type("None")
	ManagedClusterIdentity_Type_SystemAssigned = ManagedClusterIdentity_Type("SystemAssigned")
	ManagedClusterIdentity_Type_UserAssigned   = ManagedClusterIdentity_Type("UserAssigned")
)

// Mapping from string to ManagedClusterIdentity_Type
var managedClusterIdentity_Type_Values = map[string]ManagedClusterIdentity_Type{
	"none":           ManagedClusterIdentity_Type_None,
	"systemassigned": ManagedClusterIdentity_Type_SystemAssigned,
	"userassigned":   ManagedClusterIdentity_Type_UserAssigned,
}

type ManagedClusterIdentity_Type_STATUS string

const (
	ManagedClusterIdentity_Type_STATUS_None           = ManagedClusterIdentity_Type_STATUS("None")
	ManagedClusterIdentity_Type_STATUS_SystemAssigned = ManagedClusterIdentity_Type_STATUS("SystemAssigned")
	ManagedClusterIdentity_Type_STATUS_UserAssigned   = ManagedClusterIdentity_Type_STATUS("UserAssigned")
)

// Mapping from string to ManagedClusterIdentity_Type_STATUS
var managedClusterIdentity_Type_STATUS_Values = map[string]ManagedClusterIdentity_Type_STATUS{
	"none":           ManagedClusterIdentity_Type_STATUS_None,
	"systemassigned": ManagedClusterIdentity_Type_STATUS_SystemAssigned,
	"userassigned":   ManagedClusterIdentity_Type_STATUS_UserAssigned,
}

type ManagedClusterIdentity_UserAssignedIdentities_STATUS struct {
	ClientId    *string `json:"clientId,omitempty"`
	PrincipalId *string `json:"principalId,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterIdentity_UserAssignedIdentities_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identities *ManagedClusterIdentity_UserAssignedIdentities_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterIdentity_UserAssignedIdentities_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identities *ManagedClusterIdentity_UserAssignedIdentities_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterIdentity_UserAssignedIdentities_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterIdentity_UserAssignedIdentities_STATUS, got %T", armInput)
	}

	// Set property "ClientId":
	if typedInput.ClientId != nil {
		clientId := *typedInput.ClientId
		identities.ClientId = &clientId
	}

	// Set property "PrincipalId":
	if typedInput.PrincipalId != nil {
		principalId := *typedInput.PrincipalId
		identities.PrincipalId = &principalId
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterIdentity_UserAssignedIdentities_STATUS populates our ManagedClusterIdentity_UserAssignedIdentities_STATUS from the provided source ManagedClusterIdentity_UserAssignedIdentities_STATUS
func (identities *ManagedClusterIdentity_UserAssignedIdentities_STATUS) AssignProperties_From_ManagedClusterIdentity_UserAssignedIdentities_STATUS(source *storage.ManagedClusterIdentity_UserAssignedIdentities_STATUS) error {

	// ClientId
	identities.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// PrincipalId
	identities.PrincipalId = genruntime.ClonePointerToString(source.PrincipalId)

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterIdentity_UserAssignedIdentities_STATUS populates the provided destination ManagedClusterIdentity_UserAssignedIdentities_STATUS from our ManagedClusterIdentity_UserAssignedIdentities_STATUS
func (identities *ManagedClusterIdentity_UserAssignedIdentities_STATUS) AssignProperties_To_ManagedClusterIdentity_UserAssignedIdentities_STATUS(destination *storage.ManagedClusterIdentity_UserAssignedIdentities_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(identities.ClientId)

	// PrincipalId
	destination.PrincipalId = genruntime.ClonePointerToString(identities.PrincipalId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterLoadBalancerProfile struct {
	// +kubebuilder:validation:Maximum=64000
	// +kubebuilder:validation:Minimum=0
	AllocatedOutboundPorts *int                `json:"allocatedOutboundPorts,omitempty"`
	EffectiveOutboundIPs   []ResourceReference `json:"effectiveOutboundIPs,omitempty"`

	// +kubebuilder:validation:Maximum=120
	// +kubebuilder:validation:Minimum=4
	IdleTimeoutInMinutes *int                                                  `json:"idleTimeoutInMinutes,omitempty"`
	ManagedOutboundIPs   *ManagedClusterLoadBalancerProfile_ManagedOutboundIPs `json:"managedOutboundIPs,omitempty"`
	OutboundIPPrefixes   *ManagedClusterLoadBalancerProfile_OutboundIPPrefixes `json:"outboundIPPrefixes,omitempty"`
	OutboundIPs          *ManagedClusterLoadBalancerProfile_OutboundIPs        `json:"outboundIPs,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterLoadBalancerProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *ManagedClusterLoadBalancerProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.ManagedClusterLoadBalancerProfile{}

	// Set property "AllocatedOutboundPorts":
	if profile.AllocatedOutboundPorts != nil {
		allocatedOutboundPorts := *profile.AllocatedOutboundPorts
		result.AllocatedOutboundPorts = &allocatedOutboundPorts
	}

	// Set property "EffectiveOutboundIPs":
	for _, item := range profile.EffectiveOutboundIPs {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.EffectiveOutboundIPs = append(result.EffectiveOutboundIPs, *item_ARM.(*arm.ResourceReference))
	}

	// Set property "IdleTimeoutInMinutes":
	if profile.IdleTimeoutInMinutes != nil {
		idleTimeoutInMinutes := *profile.IdleTimeoutInMinutes
		result.IdleTimeoutInMinutes = &idleTimeoutInMinutes
	}

	// Set property "ManagedOutboundIPs":
	if profile.ManagedOutboundIPs != nil {
		managedOutboundIPs_ARM, err := (*profile.ManagedOutboundIPs).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		managedOutboundIPs := *managedOutboundIPs_ARM.(*arm.ManagedClusterLoadBalancerProfile_ManagedOutboundIPs)
		result.ManagedOutboundIPs = &managedOutboundIPs
	}

	// Set property "OutboundIPPrefixes":
	if profile.OutboundIPPrefixes != nil {
		outboundIPPrefixes_ARM, err := (*profile.OutboundIPPrefixes).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		outboundIPPrefixes := *outboundIPPrefixes_ARM.(*arm.ManagedClusterLoadBalancerProfile_OutboundIPPrefixes)
		result.OutboundIPPrefixes = &outboundIPPrefixes
	}

	// Set property "OutboundIPs":
	if profile.OutboundIPs != nil {
		outboundIPs_ARM, err := (*profile.OutboundIPs).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		outboundIPs := *outboundIPs_ARM.(*arm.ManagedClusterLoadBalancerProfile_OutboundIPs)
		result.OutboundIPs = &outboundIPs
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterLoadBalancerProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterLoadBalancerProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterLoadBalancerProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterLoadBalancerProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterLoadBalancerProfile, got %T", armInput)
	}

	// Set property "AllocatedOutboundPorts":
	if typedInput.AllocatedOutboundPorts != nil {
		allocatedOutboundPorts := *typedInput.AllocatedOutboundPorts
		profile.AllocatedOutboundPorts = &allocatedOutboundPorts
	}

	// Set property "EffectiveOutboundIPs":
	for _, item := range typedInput.EffectiveOutboundIPs {
		var item1 ResourceReference
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		profile.EffectiveOutboundIPs = append(profile.EffectiveOutboundIPs, item1)
	}

	// Set property "IdleTimeoutInMinutes":
	if typedInput.IdleTimeoutInMinutes != nil {
		idleTimeoutInMinutes := *typedInput.IdleTimeoutInMinutes
		profile.IdleTimeoutInMinutes = &idleTimeoutInMinutes
	}

	// Set property "ManagedOutboundIPs":
	if typedInput.ManagedOutboundIPs != nil {
		var managedOutboundIPs1 ManagedClusterLoadBalancerProfile_ManagedOutboundIPs
		err := managedOutboundIPs1.PopulateFromARM(owner, *typedInput.ManagedOutboundIPs)
		if err != nil {
			return err
		}
		managedOutboundIPs := managedOutboundIPs1
		profile.ManagedOutboundIPs = &managedOutboundIPs
	}

	// Set property "OutboundIPPrefixes":
	if typedInput.OutboundIPPrefixes != nil {
		var outboundIPPrefixes1 ManagedClusterLoadBalancerProfile_OutboundIPPrefixes
		err := outboundIPPrefixes1.PopulateFromARM(owner, *typedInput.OutboundIPPrefixes)
		if err != nil {
			return err
		}
		outboundIPPrefixes := outboundIPPrefixes1
		profile.OutboundIPPrefixes = &outboundIPPrefixes
	}

	// Set property "OutboundIPs":
	if typedInput.OutboundIPs != nil {
		var outboundIPs1 ManagedClusterLoadBalancerProfile_OutboundIPs
		err := outboundIPs1.PopulateFromARM(owner, *typedInput.OutboundIPs)
		if err != nil {
			return err
		}
		outboundIPs := outboundIPs1
		profile.OutboundIPs = &outboundIPs
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterLoadBalancerProfile populates our ManagedClusterLoadBalancerProfile from the provided source ManagedClusterLoadBalancerProfile
func (profile *ManagedClusterLoadBalancerProfile) AssignProperties_From_ManagedClusterLoadBalancerProfile(source *storage.ManagedClusterLoadBalancerProfile) error {

	// AllocatedOutboundPorts
	if source.AllocatedOutboundPorts != nil {
		allocatedOutboundPort := *source.AllocatedOutboundPorts
		profile.AllocatedOutboundPorts = &allocatedOutboundPort
	} else {
		profile.AllocatedOutboundPorts = nil
	}

	// EffectiveOutboundIPs
	if source.EffectiveOutboundIPs != nil {
		effectiveOutboundIPList := make([]ResourceReference, len(source.EffectiveOutboundIPs))
		for effectiveOutboundIPIndex, effectiveOutboundIPItem := range source.EffectiveOutboundIPs {
			// Shadow the loop variable to avoid aliasing
			effectiveOutboundIPItem := effectiveOutboundIPItem
			var effectiveOutboundIP ResourceReference
			err := effectiveOutboundIP.AssignProperties_From_ResourceReference(&effectiveOutboundIPItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ResourceReference() to populate field EffectiveOutboundIPs")
			}
			effectiveOutboundIPList[effectiveOutboundIPIndex] = effectiveOutboundIP
		}
		profile.EffectiveOutboundIPs = effectiveOutboundIPList
	} else {
		profile.EffectiveOutboundIPs = nil
	}

	// IdleTimeoutInMinutes
	if source.IdleTimeoutInMinutes != nil {
		idleTimeoutInMinute := *source.IdleTimeoutInMinutes
		profile.IdleTimeoutInMinutes = &idleTimeoutInMinute
	} else {
		profile.IdleTimeoutInMinutes = nil
	}

	// ManagedOutboundIPs
	if source.ManagedOutboundIPs != nil {
		var managedOutboundIP ManagedClusterLoadBalancerProfile_ManagedOutboundIPs
		err := managedOutboundIP.AssignProperties_From_ManagedClusterLoadBalancerProfile_ManagedOutboundIPs(source.ManagedOutboundIPs)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterLoadBalancerProfile_ManagedOutboundIPs() to populate field ManagedOutboundIPs")
		}
		profile.ManagedOutboundIPs = &managedOutboundIP
	} else {
		profile.ManagedOutboundIPs = nil
	}

	// OutboundIPPrefixes
	if source.OutboundIPPrefixes != nil {
		var outboundIPPrefix ManagedClusterLoadBalancerProfile_OutboundIPPrefixes
		err := outboundIPPrefix.AssignProperties_From_ManagedClusterLoadBalancerProfile_OutboundIPPrefixes(source.OutboundIPPrefixes)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterLoadBalancerProfile_OutboundIPPrefixes() to populate field OutboundIPPrefixes")
		}
		profile.OutboundIPPrefixes = &outboundIPPrefix
	} else {
		profile.OutboundIPPrefixes = nil
	}

	// OutboundIPs
	if source.OutboundIPs != nil {
		var outboundIP ManagedClusterLoadBalancerProfile_OutboundIPs
		err := outboundIP.AssignProperties_From_ManagedClusterLoadBalancerProfile_OutboundIPs(source.OutboundIPs)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterLoadBalancerProfile_OutboundIPs() to populate field OutboundIPs")
		}
		profile.OutboundIPs = &outboundIP
	} else {
		profile.OutboundIPs = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterLoadBalancerProfile populates the provided destination ManagedClusterLoadBalancerProfile from our ManagedClusterLoadBalancerProfile
func (profile *ManagedClusterLoadBalancerProfile) AssignProperties_To_ManagedClusterLoadBalancerProfile(destination *storage.ManagedClusterLoadBalancerProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AllocatedOutboundPorts
	if profile.AllocatedOutboundPorts != nil {
		allocatedOutboundPort := *profile.AllocatedOutboundPorts
		destination.AllocatedOutboundPorts = &allocatedOutboundPort
	} else {
		destination.AllocatedOutboundPorts = nil
	}

	// EffectiveOutboundIPs
	if profile.EffectiveOutboundIPs != nil {
		effectiveOutboundIPList := make([]storage.ResourceReference, len(profile.EffectiveOutboundIPs))
		for effectiveOutboundIPIndex, effectiveOutboundIPItem := range profile.EffectiveOutboundIPs {
			// Shadow the loop variable to avoid aliasing
			effectiveOutboundIPItem := effectiveOutboundIPItem
			var effectiveOutboundIP storage.ResourceReference
			err := effectiveOutboundIPItem.AssignProperties_To_ResourceReference(&effectiveOutboundIP)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ResourceReference() to populate field EffectiveOutboundIPs")
			}
			effectiveOutboundIPList[effectiveOutboundIPIndex] = effectiveOutboundIP
		}
		destination.EffectiveOutboundIPs = effectiveOutboundIPList
	} else {
		destination.EffectiveOutboundIPs = nil
	}

	// IdleTimeoutInMinutes
	if profile.IdleTimeoutInMinutes != nil {
		idleTimeoutInMinute := *profile.IdleTimeoutInMinutes
		destination.IdleTimeoutInMinutes = &idleTimeoutInMinute
	} else {
		destination.IdleTimeoutInMinutes = nil
	}

	// ManagedOutboundIPs
	if profile.ManagedOutboundIPs != nil {
		var managedOutboundIP storage.ManagedClusterLoadBalancerProfile_ManagedOutboundIPs
		err := profile.ManagedOutboundIPs.AssignProperties_To_ManagedClusterLoadBalancerProfile_ManagedOutboundIPs(&managedOutboundIP)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterLoadBalancerProfile_ManagedOutboundIPs() to populate field ManagedOutboundIPs")
		}
		destination.ManagedOutboundIPs = &managedOutboundIP
	} else {
		destination.ManagedOutboundIPs = nil
	}

	// OutboundIPPrefixes
	if profile.OutboundIPPrefixes != nil {
		var outboundIPPrefix storage.ManagedClusterLoadBalancerProfile_OutboundIPPrefixes
		err := profile.OutboundIPPrefixes.AssignProperties_To_ManagedClusterLoadBalancerProfile_OutboundIPPrefixes(&outboundIPPrefix)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterLoadBalancerProfile_OutboundIPPrefixes() to populate field OutboundIPPrefixes")
		}
		destination.OutboundIPPrefixes = &outboundIPPrefix
	} else {
		destination.OutboundIPPrefixes = nil
	}

	// OutboundIPs
	if profile.OutboundIPs != nil {
		var outboundIP storage.ManagedClusterLoadBalancerProfile_OutboundIPs
		err := profile.OutboundIPs.AssignProperties_To_ManagedClusterLoadBalancerProfile_OutboundIPs(&outboundIP)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterLoadBalancerProfile_OutboundIPs() to populate field OutboundIPs")
		}
		destination.OutboundIPs = &outboundIP
	} else {
		destination.OutboundIPs = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterLoadBalancerProfile_STATUS struct {
	AllocatedOutboundPorts *int                                                         `json:"allocatedOutboundPorts,omitempty"`
	EffectiveOutboundIPs   []ResourceReference_STATUS                                   `json:"effectiveOutboundIPs,omitempty"`
	IdleTimeoutInMinutes   *int                                                         `json:"idleTimeoutInMinutes,omitempty"`
	ManagedOutboundIPs     *ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_STATUS `json:"managedOutboundIPs,omitempty"`
	OutboundIPPrefixes     *ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_STATUS `json:"outboundIPPrefixes,omitempty"`
	OutboundIPs            *ManagedClusterLoadBalancerProfile_OutboundIPs_STATUS        `json:"outboundIPs,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterLoadBalancerProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterLoadBalancerProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterLoadBalancerProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterLoadBalancerProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterLoadBalancerProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterLoadBalancerProfile_STATUS, got %T", armInput)
	}

	// Set property "AllocatedOutboundPorts":
	if typedInput.AllocatedOutboundPorts != nil {
		allocatedOutboundPorts := *typedInput.AllocatedOutboundPorts
		profile.AllocatedOutboundPorts = &allocatedOutboundPorts
	}

	// Set property "EffectiveOutboundIPs":
	for _, item := range typedInput.EffectiveOutboundIPs {
		var item1 ResourceReference_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		profile.EffectiveOutboundIPs = append(profile.EffectiveOutboundIPs, item1)
	}

	// Set property "IdleTimeoutInMinutes":
	if typedInput.IdleTimeoutInMinutes != nil {
		idleTimeoutInMinutes := *typedInput.IdleTimeoutInMinutes
		profile.IdleTimeoutInMinutes = &idleTimeoutInMinutes
	}

	// Set property "ManagedOutboundIPs":
	if typedInput.ManagedOutboundIPs != nil {
		var managedOutboundIPs1 ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_STATUS
		err := managedOutboundIPs1.PopulateFromARM(owner, *typedInput.ManagedOutboundIPs)
		if err != nil {
			return err
		}
		managedOutboundIPs := managedOutboundIPs1
		profile.ManagedOutboundIPs = &managedOutboundIPs
	}

	// Set property "OutboundIPPrefixes":
	if typedInput.OutboundIPPrefixes != nil {
		var outboundIPPrefixes1 ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_STATUS
		err := outboundIPPrefixes1.PopulateFromARM(owner, *typedInput.OutboundIPPrefixes)
		if err != nil {
			return err
		}
		outboundIPPrefixes := outboundIPPrefixes1
		profile.OutboundIPPrefixes = &outboundIPPrefixes
	}

	// Set property "OutboundIPs":
	if typedInput.OutboundIPs != nil {
		var outboundIPs1 ManagedClusterLoadBalancerProfile_OutboundIPs_STATUS
		err := outboundIPs1.PopulateFromARM(owner, *typedInput.OutboundIPs)
		if err != nil {
			return err
		}
		outboundIPs := outboundIPs1
		profile.OutboundIPs = &outboundIPs
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterLoadBalancerProfile_STATUS populates our ManagedClusterLoadBalancerProfile_STATUS from the provided source ManagedClusterLoadBalancerProfile_STATUS
func (profile *ManagedClusterLoadBalancerProfile_STATUS) AssignProperties_From_ManagedClusterLoadBalancerProfile_STATUS(source *storage.ManagedClusterLoadBalancerProfile_STATUS) error {

	// AllocatedOutboundPorts
	profile.AllocatedOutboundPorts = genruntime.ClonePointerToInt(source.AllocatedOutboundPorts)

	// EffectiveOutboundIPs
	if source.EffectiveOutboundIPs != nil {
		effectiveOutboundIPList := make([]ResourceReference_STATUS, len(source.EffectiveOutboundIPs))
		for effectiveOutboundIPIndex, effectiveOutboundIPItem := range source.EffectiveOutboundIPs {
			// Shadow the loop variable to avoid aliasing
			effectiveOutboundIPItem := effectiveOutboundIPItem
			var effectiveOutboundIP ResourceReference_STATUS
			err := effectiveOutboundIP.AssignProperties_From_ResourceReference_STATUS(&effectiveOutboundIPItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ResourceReference_STATUS() to populate field EffectiveOutboundIPs")
			}
			effectiveOutboundIPList[effectiveOutboundIPIndex] = effectiveOutboundIP
		}
		profile.EffectiveOutboundIPs = effectiveOutboundIPList
	} else {
		profile.EffectiveOutboundIPs = nil
	}

	// IdleTimeoutInMinutes
	profile.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(source.IdleTimeoutInMinutes)

	// ManagedOutboundIPs
	if source.ManagedOutboundIPs != nil {
		var managedOutboundIP ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_STATUS
		err := managedOutboundIP.AssignProperties_From_ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_STATUS(source.ManagedOutboundIPs)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_STATUS() to populate field ManagedOutboundIPs")
		}
		profile.ManagedOutboundIPs = &managedOutboundIP
	} else {
		profile.ManagedOutboundIPs = nil
	}

	// OutboundIPPrefixes
	if source.OutboundIPPrefixes != nil {
		var outboundIPPrefix ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_STATUS
		err := outboundIPPrefix.AssignProperties_From_ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_STATUS(source.OutboundIPPrefixes)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_STATUS() to populate field OutboundIPPrefixes")
		}
		profile.OutboundIPPrefixes = &outboundIPPrefix
	} else {
		profile.OutboundIPPrefixes = nil
	}

	// OutboundIPs
	if source.OutboundIPs != nil {
		var outboundIP ManagedClusterLoadBalancerProfile_OutboundIPs_STATUS
		err := outboundIP.AssignProperties_From_ManagedClusterLoadBalancerProfile_OutboundIPs_STATUS(source.OutboundIPs)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterLoadBalancerProfile_OutboundIPs_STATUS() to populate field OutboundIPs")
		}
		profile.OutboundIPs = &outboundIP
	} else {
		profile.OutboundIPs = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterLoadBalancerProfile_STATUS populates the provided destination ManagedClusterLoadBalancerProfile_STATUS from our ManagedClusterLoadBalancerProfile_STATUS
func (profile *ManagedClusterLoadBalancerProfile_STATUS) AssignProperties_To_ManagedClusterLoadBalancerProfile_STATUS(destination *storage.ManagedClusterLoadBalancerProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AllocatedOutboundPorts
	destination.AllocatedOutboundPorts = genruntime.ClonePointerToInt(profile.AllocatedOutboundPorts)

	// EffectiveOutboundIPs
	if profile.EffectiveOutboundIPs != nil {
		effectiveOutboundIPList := make([]storage.ResourceReference_STATUS, len(profile.EffectiveOutboundIPs))
		for effectiveOutboundIPIndex, effectiveOutboundIPItem := range profile.EffectiveOutboundIPs {
			// Shadow the loop variable to avoid aliasing
			effectiveOutboundIPItem := effectiveOutboundIPItem
			var effectiveOutboundIP storage.ResourceReference_STATUS
			err := effectiveOutboundIPItem.AssignProperties_To_ResourceReference_STATUS(&effectiveOutboundIP)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ResourceReference_STATUS() to populate field EffectiveOutboundIPs")
			}
			effectiveOutboundIPList[effectiveOutboundIPIndex] = effectiveOutboundIP
		}
		destination.EffectiveOutboundIPs = effectiveOutboundIPList
	} else {
		destination.EffectiveOutboundIPs = nil
	}

	// IdleTimeoutInMinutes
	destination.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(profile.IdleTimeoutInMinutes)

	// ManagedOutboundIPs
	if profile.ManagedOutboundIPs != nil {
		var managedOutboundIP storage.ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_STATUS
		err := profile.ManagedOutboundIPs.AssignProperties_To_ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_STATUS(&managedOutboundIP)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_STATUS() to populate field ManagedOutboundIPs")
		}
		destination.ManagedOutboundIPs = &managedOutboundIP
	} else {
		destination.ManagedOutboundIPs = nil
	}

	// OutboundIPPrefixes
	if profile.OutboundIPPrefixes != nil {
		var outboundIPPrefix storage.ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_STATUS
		err := profile.OutboundIPPrefixes.AssignProperties_To_ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_STATUS(&outboundIPPrefix)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_STATUS() to populate field OutboundIPPrefixes")
		}
		destination.OutboundIPPrefixes = &outboundIPPrefix
	} else {
		destination.OutboundIPPrefixes = nil
	}

	// OutboundIPs
	if profile.OutboundIPs != nil {
		var outboundIP storage.ManagedClusterLoadBalancerProfile_OutboundIPs_STATUS
		err := profile.OutboundIPs.AssignProperties_To_ManagedClusterLoadBalancerProfile_OutboundIPs_STATUS(&outboundIP)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterLoadBalancerProfile_OutboundIPs_STATUS() to populate field OutboundIPs")
		}
		destination.OutboundIPs = &outboundIP
	} else {
		destination.OutboundIPs = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterOperatorSecrets struct {
	// AdminCredentials: indicates where the AdminCredentials secret should be placed. If omitted, the secret will not be
	// retrieved from Azure.
	AdminCredentials *genruntime.SecretDestination `json:"adminCredentials,omitempty"`

	// UserCredentials: indicates where the UserCredentials secret should be placed. If omitted, the secret will not be
	// retrieved from Azure.
	UserCredentials *genruntime.SecretDestination `json:"userCredentials,omitempty"`
}

// AssignProperties_From_ManagedClusterOperatorSecrets populates our ManagedClusterOperatorSecrets from the provided source ManagedClusterOperatorSecrets
func (secrets *ManagedClusterOperatorSecrets) AssignProperties_From_ManagedClusterOperatorSecrets(source *storage.ManagedClusterOperatorSecrets) error {

	// AdminCredentials
	if source.AdminCredentials != nil {
		adminCredential := source.AdminCredentials.Copy()
		secrets.AdminCredentials = &adminCredential
	} else {
		secrets.AdminCredentials = nil
	}

	// UserCredentials
	if source.UserCredentials != nil {
		userCredential := source.UserCredentials.Copy()
		secrets.UserCredentials = &userCredential
	} else {
		secrets.UserCredentials = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterOperatorSecrets populates the provided destination ManagedClusterOperatorSecrets from our ManagedClusterOperatorSecrets
func (secrets *ManagedClusterOperatorSecrets) AssignProperties_To_ManagedClusterOperatorSecrets(destination *storage.ManagedClusterOperatorSecrets) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdminCredentials
	if secrets.AdminCredentials != nil {
		adminCredential := secrets.AdminCredentials.Copy()
		destination.AdminCredentials = &adminCredential
	} else {
		destination.AdminCredentials = nil
	}

	// UserCredentials
	if secrets.UserCredentials != nil {
		userCredential := secrets.UserCredentials.Copy()
		destination.UserCredentials = &userCredential
	} else {
		destination.UserCredentials = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterPodIdentity struct {
	BindingSelector *string `json:"bindingSelector,omitempty"`

	// +kubebuilder:validation:Required
	Identity *UserAssignedIdentity `json:"identity,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	Namespace *string `json:"namespace,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterPodIdentity{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (identity *ManagedClusterPodIdentity) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if identity == nil {
		return nil, nil
	}
	result := &arm.ManagedClusterPodIdentity{}

	// Set property "BindingSelector":
	if identity.BindingSelector != nil {
		bindingSelector := *identity.BindingSelector
		result.BindingSelector = &bindingSelector
	}

	// Set property "Identity":
	if identity.Identity != nil {
		identity_ARM, err := (*identity.Identity).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		identity1 := *identity_ARM.(*arm.UserAssignedIdentity)
		result.Identity = &identity1
	}

	// Set property "Name":
	if identity.Name != nil {
		name := *identity.Name
		result.Name = &name
	}

	// Set property "Namespace":
	if identity.Namespace != nil {
		namespace := *identity.Namespace
		result.Namespace = &namespace
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *ManagedClusterPodIdentity) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterPodIdentity{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *ManagedClusterPodIdentity) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterPodIdentity)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterPodIdentity, got %T", armInput)
	}

	// Set property "BindingSelector":
	if typedInput.BindingSelector != nil {
		bindingSelector := *typedInput.BindingSelector
		identity.BindingSelector = &bindingSelector
	}

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity2 UserAssignedIdentity
		err := identity2.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity1 := identity2
		identity.Identity = &identity1
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		identity.Name = &name
	}

	// Set property "Namespace":
	if typedInput.Namespace != nil {
		namespace := *typedInput.Namespace
		identity.Namespace = &namespace
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterPodIdentity populates our ManagedClusterPodIdentity from the provided source ManagedClusterPodIdentity
func (identity *ManagedClusterPodIdentity) AssignProperties_From_ManagedClusterPodIdentity(source *storage.ManagedClusterPodIdentity) error {

	// BindingSelector
	identity.BindingSelector = genruntime.ClonePointerToString(source.BindingSelector)

	// Identity
	if source.Identity != nil {
		var identityLocal UserAssignedIdentity
		err := identityLocal.AssignProperties_From_UserAssignedIdentity(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UserAssignedIdentity() to populate field Identity")
		}
		identity.Identity = &identityLocal
	} else {
		identity.Identity = nil
	}

	// Name
	identity.Name = genruntime.ClonePointerToString(source.Name)

	// Namespace
	identity.Namespace = genruntime.ClonePointerToString(source.Namespace)

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterPodIdentity populates the provided destination ManagedClusterPodIdentity from our ManagedClusterPodIdentity
func (identity *ManagedClusterPodIdentity) AssignProperties_To_ManagedClusterPodIdentity(destination *storage.ManagedClusterPodIdentity) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BindingSelector
	destination.BindingSelector = genruntime.ClonePointerToString(identity.BindingSelector)

	// Identity
	if identity.Identity != nil {
		var identityLocal storage.UserAssignedIdentity
		err := identity.Identity.AssignProperties_To_UserAssignedIdentity(&identityLocal)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UserAssignedIdentity() to populate field Identity")
		}
		destination.Identity = &identityLocal
	} else {
		destination.Identity = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(identity.Name)

	// Namespace
	destination.Namespace = genruntime.ClonePointerToString(identity.Namespace)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterPodIdentity_STATUS struct {
	BindingSelector   *string                                             `json:"bindingSelector,omitempty"`
	Identity          *UserAssignedIdentity_STATUS                        `json:"identity,omitempty"`
	Name              *string                                             `json:"name,omitempty"`
	Namespace         *string                                             `json:"namespace,omitempty"`
	ProvisioningInfo  *ManagedClusterPodIdentity_ProvisioningInfo_STATUS  `json:"provisioningInfo,omitempty"`
	ProvisioningState *ManagedClusterPodIdentity_ProvisioningState_STATUS `json:"provisioningState,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterPodIdentity_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *ManagedClusterPodIdentity_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterPodIdentity_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *ManagedClusterPodIdentity_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterPodIdentity_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterPodIdentity_STATUS, got %T", armInput)
	}

	// Set property "BindingSelector":
	if typedInput.BindingSelector != nil {
		bindingSelector := *typedInput.BindingSelector
		identity.BindingSelector = &bindingSelector
	}

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity2 UserAssignedIdentity_STATUS
		err := identity2.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity1 := identity2
		identity.Identity = &identity1
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		identity.Name = &name
	}

	// Set property "Namespace":
	if typedInput.Namespace != nil {
		namespace := *typedInput.Namespace
		identity.Namespace = &namespace
	}

	// Set property "ProvisioningInfo":
	if typedInput.ProvisioningInfo != nil {
		var provisioningInfo1 ManagedClusterPodIdentity_ProvisioningInfo_STATUS
		err := provisioningInfo1.PopulateFromARM(owner, *typedInput.ProvisioningInfo)
		if err != nil {
			return err
		}
		provisioningInfo := provisioningInfo1
		identity.ProvisioningInfo = &provisioningInfo
	}

	// Set property "ProvisioningState":
	if typedInput.ProvisioningState != nil {
		var temp string
		temp = string(*typedInput.ProvisioningState)
		provisioningState := ManagedClusterPodIdentity_ProvisioningState_STATUS(temp)
		identity.ProvisioningState = &provisioningState
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterPodIdentity_STATUS populates our ManagedClusterPodIdentity_STATUS from the provided source ManagedClusterPodIdentity_STATUS
func (identity *ManagedClusterPodIdentity_STATUS) AssignProperties_From_ManagedClusterPodIdentity_STATUS(source *storage.ManagedClusterPodIdentity_STATUS) error {

	// BindingSelector
	identity.BindingSelector = genruntime.ClonePointerToString(source.BindingSelector)

	// Identity
	if source.Identity != nil {
		var identityLocal UserAssignedIdentity_STATUS
		err := identityLocal.AssignProperties_From_UserAssignedIdentity_STATUS(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UserAssignedIdentity_STATUS() to populate field Identity")
		}
		identity.Identity = &identityLocal
	} else {
		identity.Identity = nil
	}

	// Name
	identity.Name = genruntime.ClonePointerToString(source.Name)

	// Namespace
	identity.Namespace = genruntime.ClonePointerToString(source.Namespace)

	// ProvisioningInfo
	if source.ProvisioningInfo != nil {
		var provisioningInfo ManagedClusterPodIdentity_ProvisioningInfo_STATUS
		err := provisioningInfo.AssignProperties_From_ManagedClusterPodIdentity_ProvisioningInfo_STATUS(source.ProvisioningInfo)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterPodIdentity_ProvisioningInfo_STATUS() to populate field ProvisioningInfo")
		}
		identity.ProvisioningInfo = &provisioningInfo
	} else {
		identity.ProvisioningInfo = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := *source.ProvisioningState
		provisioningStateTemp := genruntime.ToEnum(provisioningState, managedClusterPodIdentity_ProvisioningState_STATUS_Values)
		identity.ProvisioningState = &provisioningStateTemp
	} else {
		identity.ProvisioningState = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterPodIdentity_STATUS populates the provided destination ManagedClusterPodIdentity_STATUS from our ManagedClusterPodIdentity_STATUS
func (identity *ManagedClusterPodIdentity_STATUS) AssignProperties_To_ManagedClusterPodIdentity_STATUS(destination *storage.ManagedClusterPodIdentity_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BindingSelector
	destination.BindingSelector = genruntime.ClonePointerToString(identity.BindingSelector)

	// Identity
	if identity.Identity != nil {
		var identityLocal storage.UserAssignedIdentity_STATUS
		err := identity.Identity.AssignProperties_To_UserAssignedIdentity_STATUS(&identityLocal)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UserAssignedIdentity_STATUS() to populate field Identity")
		}
		destination.Identity = &identityLocal
	} else {
		destination.Identity = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(identity.Name)

	// Namespace
	destination.Namespace = genruntime.ClonePointerToString(identity.Namespace)

	// ProvisioningInfo
	if identity.ProvisioningInfo != nil {
		var provisioningInfo storage.ManagedClusterPodIdentity_ProvisioningInfo_STATUS
		err := identity.ProvisioningInfo.AssignProperties_To_ManagedClusterPodIdentity_ProvisioningInfo_STATUS(&provisioningInfo)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterPodIdentity_ProvisioningInfo_STATUS() to populate field ProvisioningInfo")
		}
		destination.ProvisioningInfo = &provisioningInfo
	} else {
		destination.ProvisioningInfo = nil
	}

	// ProvisioningState
	if identity.ProvisioningState != nil {
		provisioningState := string(*identity.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterPodIdentityException struct {
	// +kubebuilder:validation:Required
	Name *string `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	Namespace *string `json:"namespace,omitempty"`

	// +kubebuilder:validation:Required
	PodLabels map[string]string `json:"podLabels,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterPodIdentityException{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (exception *ManagedClusterPodIdentityException) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if exception == nil {
		return nil, nil
	}
	result := &arm.ManagedClusterPodIdentityException{}

	// Set property "Name":
	if exception.Name != nil {
		name := *exception.Name
		result.Name = &name
	}

	// Set property "Namespace":
	if exception.Namespace != nil {
		namespace := *exception.Namespace
		result.Namespace = &namespace
	}

	// Set property "PodLabels":
	if exception.PodLabels != nil {
		result.PodLabels = make(map[string]string, len(exception.PodLabels))
		for key, value := range exception.PodLabels {
			result.PodLabels[key] = value
		}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (exception *ManagedClusterPodIdentityException) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterPodIdentityException{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (exception *ManagedClusterPodIdentityException) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterPodIdentityException)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterPodIdentityException, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		exception.Name = &name
	}

	// Set property "Namespace":
	if typedInput.Namespace != nil {
		namespace := *typedInput.Namespace
		exception.Namespace = &namespace
	}

	// Set property "PodLabels":
	if typedInput.PodLabels != nil {
		exception.PodLabels = make(map[string]string, len(typedInput.PodLabels))
		for key, value := range typedInput.PodLabels {
			exception.PodLabels[key] = value
		}
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterPodIdentityException populates our ManagedClusterPodIdentityException from the provided source ManagedClusterPodIdentityException
func (exception *ManagedClusterPodIdentityException) AssignProperties_From_ManagedClusterPodIdentityException(source *storage.ManagedClusterPodIdentityException) error {

	// Name
	exception.Name = genruntime.ClonePointerToString(source.Name)

	// Namespace
	exception.Namespace = genruntime.ClonePointerToString(source.Namespace)

	// PodLabels
	exception.PodLabels = genruntime.CloneMapOfStringToString(source.PodLabels)

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterPodIdentityException populates the provided destination ManagedClusterPodIdentityException from our ManagedClusterPodIdentityException
func (exception *ManagedClusterPodIdentityException) AssignProperties_To_ManagedClusterPodIdentityException(destination *storage.ManagedClusterPodIdentityException) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(exception.Name)

	// Namespace
	destination.Namespace = genruntime.ClonePointerToString(exception.Namespace)

	// PodLabels
	destination.PodLabels = genruntime.CloneMapOfStringToString(exception.PodLabels)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterPodIdentityException_STATUS struct {
	Name      *string           `json:"name,omitempty"`
	Namespace *string           `json:"namespace,omitempty"`
	PodLabels map[string]string `json:"podLabels,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterPodIdentityException_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (exception *ManagedClusterPodIdentityException_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterPodIdentityException_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (exception *ManagedClusterPodIdentityException_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterPodIdentityException_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterPodIdentityException_STATUS, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		exception.Name = &name
	}

	// Set property "Namespace":
	if typedInput.Namespace != nil {
		namespace := *typedInput.Namespace
		exception.Namespace = &namespace
	}

	// Set property "PodLabels":
	if typedInput.PodLabels != nil {
		exception.PodLabels = make(map[string]string, len(typedInput.PodLabels))
		for key, value := range typedInput.PodLabels {
			exception.PodLabels[key] = value
		}
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterPodIdentityException_STATUS populates our ManagedClusterPodIdentityException_STATUS from the provided source ManagedClusterPodIdentityException_STATUS
func (exception *ManagedClusterPodIdentityException_STATUS) AssignProperties_From_ManagedClusterPodIdentityException_STATUS(source *storage.ManagedClusterPodIdentityException_STATUS) error {

	// Name
	exception.Name = genruntime.ClonePointerToString(source.Name)

	// Namespace
	exception.Namespace = genruntime.ClonePointerToString(source.Namespace)

	// PodLabels
	exception.PodLabels = genruntime.CloneMapOfStringToString(source.PodLabels)

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterPodIdentityException_STATUS populates the provided destination ManagedClusterPodIdentityException_STATUS from our ManagedClusterPodIdentityException_STATUS
func (exception *ManagedClusterPodIdentityException_STATUS) AssignProperties_To_ManagedClusterPodIdentityException_STATUS(destination *storage.ManagedClusterPodIdentityException_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(exception.Name)

	// Namespace
	destination.Namespace = genruntime.ClonePointerToString(exception.Namespace)

	// PodLabels
	destination.PodLabels = genruntime.CloneMapOfStringToString(exception.PodLabels)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"least-waste","most-pods","priority","random"}
type ManagedClusterProperties_AutoScalerProfile_Expander string

const (
	ManagedClusterProperties_AutoScalerProfile_Expander_LeastWaste = ManagedClusterProperties_AutoScalerProfile_Expander("least-waste")
	ManagedClusterProperties_AutoScalerProfile_Expander_MostPods   = ManagedClusterProperties_AutoScalerProfile_Expander("most-pods")
	ManagedClusterProperties_AutoScalerProfile_Expander_Priority   = ManagedClusterProperties_AutoScalerProfile_Expander("priority")
	ManagedClusterProperties_AutoScalerProfile_Expander_Random     = ManagedClusterProperties_AutoScalerProfile_Expander("random")
)

// Mapping from string to ManagedClusterProperties_AutoScalerProfile_Expander
var managedClusterProperties_AutoScalerProfile_Expander_Values = map[string]ManagedClusterProperties_AutoScalerProfile_Expander{
	"least-waste": ManagedClusterProperties_AutoScalerProfile_Expander_LeastWaste,
	"most-pods":   ManagedClusterProperties_AutoScalerProfile_Expander_MostPods,
	"priority":    ManagedClusterProperties_AutoScalerProfile_Expander_Priority,
	"random":      ManagedClusterProperties_AutoScalerProfile_Expander_Random,
}

type ManagedClusterProperties_AutoScalerProfile_Expander_STATUS string

const (
	ManagedClusterProperties_AutoScalerProfile_Expander_STATUS_LeastWaste = ManagedClusterProperties_AutoScalerProfile_Expander_STATUS("least-waste")
	ManagedClusterProperties_AutoScalerProfile_Expander_STATUS_MostPods   = ManagedClusterProperties_AutoScalerProfile_Expander_STATUS("most-pods")
	ManagedClusterProperties_AutoScalerProfile_Expander_STATUS_Priority   = ManagedClusterProperties_AutoScalerProfile_Expander_STATUS("priority")
	ManagedClusterProperties_AutoScalerProfile_Expander_STATUS_Random     = ManagedClusterProperties_AutoScalerProfile_Expander_STATUS("random")
)

// Mapping from string to ManagedClusterProperties_AutoScalerProfile_Expander_STATUS
var managedClusterProperties_AutoScalerProfile_Expander_STATUS_Values = map[string]ManagedClusterProperties_AutoScalerProfile_Expander_STATUS{
	"least-waste": ManagedClusterProperties_AutoScalerProfile_Expander_STATUS_LeastWaste,
	"most-pods":   ManagedClusterProperties_AutoScalerProfile_Expander_STATUS_MostPods,
	"priority":    ManagedClusterProperties_AutoScalerProfile_Expander_STATUS_Priority,
	"random":      ManagedClusterProperties_AutoScalerProfile_Expander_STATUS_Random,
}

// +kubebuilder:validation:Enum={"Basic"}
type ManagedClusterSKU_Name string

const ManagedClusterSKU_Name_Basic = ManagedClusterSKU_Name("Basic")

// Mapping from string to ManagedClusterSKU_Name
var managedClusterSKU_Name_Values = map[string]ManagedClusterSKU_Name{
	"basic": ManagedClusterSKU_Name_Basic,
}

type ManagedClusterSKU_Name_STATUS string

const ManagedClusterSKU_Name_STATUS_Basic = ManagedClusterSKU_Name_STATUS("Basic")

// Mapping from string to ManagedClusterSKU_Name_STATUS
var managedClusterSKU_Name_STATUS_Values = map[string]ManagedClusterSKU_Name_STATUS{
	"basic": ManagedClusterSKU_Name_STATUS_Basic,
}

// +kubebuilder:validation:Enum={"Free","Paid"}
type ManagedClusterSKU_Tier string

const (
	ManagedClusterSKU_Tier_Free = ManagedClusterSKU_Tier("Free")
	ManagedClusterSKU_Tier_Paid = ManagedClusterSKU_Tier("Paid")
)

// Mapping from string to ManagedClusterSKU_Tier
var managedClusterSKU_Tier_Values = map[string]ManagedClusterSKU_Tier{
	"free": ManagedClusterSKU_Tier_Free,
	"paid": ManagedClusterSKU_Tier_Paid,
}

type ManagedClusterSKU_Tier_STATUS string

const (
	ManagedClusterSKU_Tier_STATUS_Free = ManagedClusterSKU_Tier_STATUS("Free")
	ManagedClusterSKU_Tier_STATUS_Paid = ManagedClusterSKU_Tier_STATUS("Paid")
)

// Mapping from string to ManagedClusterSKU_Tier_STATUS
var managedClusterSKU_Tier_STATUS_Values = map[string]ManagedClusterSKU_Tier_STATUS{
	"free": ManagedClusterSKU_Tier_STATUS_Free,
	"paid": ManagedClusterSKU_Tier_STATUS_Paid,
}

// +kubebuilder:validation:Enum={"None","Windows_Server"}
type ManagedClusterWindowsProfile_LicenseType string

const (
	ManagedClusterWindowsProfile_LicenseType_None           = ManagedClusterWindowsProfile_LicenseType("None")
	ManagedClusterWindowsProfile_LicenseType_Windows_Server = ManagedClusterWindowsProfile_LicenseType("Windows_Server")
)

// Mapping from string to ManagedClusterWindowsProfile_LicenseType
var managedClusterWindowsProfile_LicenseType_Values = map[string]ManagedClusterWindowsProfile_LicenseType{
	"none":           ManagedClusterWindowsProfile_LicenseType_None,
	"windows_server": ManagedClusterWindowsProfile_LicenseType_Windows_Server,
}

type ManagedClusterWindowsProfile_LicenseType_STATUS string

const (
	ManagedClusterWindowsProfile_LicenseType_STATUS_None           = ManagedClusterWindowsProfile_LicenseType_STATUS("None")
	ManagedClusterWindowsProfile_LicenseType_STATUS_Windows_Server = ManagedClusterWindowsProfile_LicenseType_STATUS("Windows_Server")
)

// Mapping from string to ManagedClusterWindowsProfile_LicenseType_STATUS
var managedClusterWindowsProfile_LicenseType_STATUS_Values = map[string]ManagedClusterWindowsProfile_LicenseType_STATUS{
	"none":           ManagedClusterWindowsProfile_LicenseType_STATUS_None,
	"windows_server": ManagedClusterWindowsProfile_LicenseType_STATUS_Windows_Server,
}

type PowerState_Code_STATUS string

const (
	PowerState_Code_STATUS_Running = PowerState_Code_STATUS("Running")
	PowerState_Code_STATUS_Stopped = PowerState_Code_STATUS("Stopped")
)

// Mapping from string to PowerState_Code_STATUS
var powerState_Code_STATUS_Values = map[string]PowerState_Code_STATUS{
	"running": PowerState_Code_STATUS_Running,
	"stopped": PowerState_Code_STATUS_Stopped,
}

type UserAssignedIdentityDetails struct {
	Reference genruntime.ResourceReference `armReference:"Reference" json:"reference,omitempty"`
}

// AssignProperties_From_UserAssignedIdentityDetails populates our UserAssignedIdentityDetails from the provided source UserAssignedIdentityDetails
func (details *UserAssignedIdentityDetails) AssignProperties_From_UserAssignedIdentityDetails(source *storage.UserAssignedIdentityDetails) error {

	// Reference
	details.Reference = source.Reference.Copy()

	// No error
	return nil
}

// AssignProperties_To_UserAssignedIdentityDetails populates the provided destination UserAssignedIdentityDetails from our UserAssignedIdentityDetails
func (details *UserAssignedIdentityDetails) AssignProperties_To_UserAssignedIdentityDetails(destination *storage.UserAssignedIdentityDetails) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Reference
	destination.Reference = details.Reference.Copy()

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ContainerServiceSshPublicKey struct {
	// +kubebuilder:validation:Required
	KeyData *string `json:"keyData,omitempty"`
}

var _ genruntime.ARMTransformer = &ContainerServiceSshPublicKey{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (publicKey *ContainerServiceSshPublicKey) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if publicKey == nil {
		return nil, nil
	}
	result := &arm.ContainerServiceSshPublicKey{}

	// Set property "KeyData":
	if publicKey.KeyData != nil {
		keyData := *publicKey.KeyData
		result.KeyData = &keyData
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (publicKey *ContainerServiceSshPublicKey) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ContainerServiceSshPublicKey{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (publicKey *ContainerServiceSshPublicKey) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ContainerServiceSshPublicKey)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ContainerServiceSshPublicKey, got %T", armInput)
	}

	// Set property "KeyData":
	if typedInput.KeyData != nil {
		keyData := *typedInput.KeyData
		publicKey.KeyData = &keyData
	}

	// No error
	return nil
}

// AssignProperties_From_ContainerServiceSshPublicKey populates our ContainerServiceSshPublicKey from the provided source ContainerServiceSshPublicKey
func (publicKey *ContainerServiceSshPublicKey) AssignProperties_From_ContainerServiceSshPublicKey(source *storage.ContainerServiceSshPublicKey) error {

	// KeyData
	publicKey.KeyData = genruntime.ClonePointerToString(source.KeyData)

	// No error
	return nil
}

// AssignProperties_To_ContainerServiceSshPublicKey populates the provided destination ContainerServiceSshPublicKey from our ContainerServiceSshPublicKey
func (publicKey *ContainerServiceSshPublicKey) AssignProperties_To_ContainerServiceSshPublicKey(destination *storage.ContainerServiceSshPublicKey) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// KeyData
	destination.KeyData = genruntime.ClonePointerToString(publicKey.KeyData)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ContainerServiceSshPublicKey_STATUS struct {
	KeyData *string `json:"keyData,omitempty"`
}

var _ genruntime.FromARMConverter = &ContainerServiceSshPublicKey_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (publicKey *ContainerServiceSshPublicKey_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ContainerServiceSshPublicKey_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (publicKey *ContainerServiceSshPublicKey_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ContainerServiceSshPublicKey_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ContainerServiceSshPublicKey_STATUS, got %T", armInput)
	}

	// Set property "KeyData":
	if typedInput.KeyData != nil {
		keyData := *typedInput.KeyData
		publicKey.KeyData = &keyData
	}

	// No error
	return nil
}

// AssignProperties_From_ContainerServiceSshPublicKey_STATUS populates our ContainerServiceSshPublicKey_STATUS from the provided source ContainerServiceSshPublicKey_STATUS
func (publicKey *ContainerServiceSshPublicKey_STATUS) AssignProperties_From_ContainerServiceSshPublicKey_STATUS(source *storage.ContainerServiceSshPublicKey_STATUS) error {

	// KeyData
	publicKey.KeyData = genruntime.ClonePointerToString(source.KeyData)

	// No error
	return nil
}

// AssignProperties_To_ContainerServiceSshPublicKey_STATUS populates the provided destination ContainerServiceSshPublicKey_STATUS from our ContainerServiceSshPublicKey_STATUS
func (publicKey *ContainerServiceSshPublicKey_STATUS) AssignProperties_To_ContainerServiceSshPublicKey_STATUS(destination *storage.ContainerServiceSshPublicKey_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// KeyData
	destination.KeyData = genruntime.ClonePointerToString(publicKey.KeyData)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterLoadBalancerProfile_ManagedOutboundIPs struct {
	// +kubebuilder:validation:Maximum=100
	// +kubebuilder:validation:Minimum=1
	Count *int `json:"count,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterLoadBalancerProfile_ManagedOutboundIPs{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (iPs *ManagedClusterLoadBalancerProfile_ManagedOutboundIPs) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if iPs == nil {
		return nil, nil
	}
	result := &arm.ManagedClusterLoadBalancerProfile_ManagedOutboundIPs{}

	// Set property "Count":
	if iPs.Count != nil {
		count := *iPs.Count
		result.Count = &count
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (iPs *ManagedClusterLoadBalancerProfile_ManagedOutboundIPs) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterLoadBalancerProfile_ManagedOutboundIPs{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (iPs *ManagedClusterLoadBalancerProfile_ManagedOutboundIPs) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterLoadBalancerProfile_ManagedOutboundIPs)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterLoadBalancerProfile_ManagedOutboundIPs, got %T", armInput)
	}

	// Set property "Count":
	if typedInput.Count != nil {
		count := *typedInput.Count
		iPs.Count = &count
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterLoadBalancerProfile_ManagedOutboundIPs populates our ManagedClusterLoadBalancerProfile_ManagedOutboundIPs from the provided source ManagedClusterLoadBalancerProfile_ManagedOutboundIPs
func (iPs *ManagedClusterLoadBalancerProfile_ManagedOutboundIPs) AssignProperties_From_ManagedClusterLoadBalancerProfile_ManagedOutboundIPs(source *storage.ManagedClusterLoadBalancerProfile_ManagedOutboundIPs) error {

	// Count
	if source.Count != nil {
		count := *source.Count
		iPs.Count = &count
	} else {
		iPs.Count = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterLoadBalancerProfile_ManagedOutboundIPs populates the provided destination ManagedClusterLoadBalancerProfile_ManagedOutboundIPs from our ManagedClusterLoadBalancerProfile_ManagedOutboundIPs
func (iPs *ManagedClusterLoadBalancerProfile_ManagedOutboundIPs) AssignProperties_To_ManagedClusterLoadBalancerProfile_ManagedOutboundIPs(destination *storage.ManagedClusterLoadBalancerProfile_ManagedOutboundIPs) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Count
	if iPs.Count != nil {
		count := *iPs.Count
		destination.Count = &count
	} else {
		destination.Count = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_STATUS struct {
	Count *int `json:"count,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (iPs *ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (iPs *ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_STATUS, got %T", armInput)
	}

	// Set property "Count":
	if typedInput.Count != nil {
		count := *typedInput.Count
		iPs.Count = &count
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_STATUS populates our ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_STATUS from the provided source ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_STATUS
func (iPs *ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_STATUS) AssignProperties_From_ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_STATUS(source *storage.ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_STATUS) error {

	// Count
	iPs.Count = genruntime.ClonePointerToInt(source.Count)

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_STATUS populates the provided destination ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_STATUS from our ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_STATUS
func (iPs *ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_STATUS) AssignProperties_To_ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_STATUS(destination *storage.ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Count
	destination.Count = genruntime.ClonePointerToInt(iPs.Count)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterLoadBalancerProfile_OutboundIPPrefixes struct {
	PublicIPPrefixes []ResourceReference `json:"publicIPPrefixes,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterLoadBalancerProfile_OutboundIPPrefixes{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (prefixes *ManagedClusterLoadBalancerProfile_OutboundIPPrefixes) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if prefixes == nil {
		return nil, nil
	}
	result := &arm.ManagedClusterLoadBalancerProfile_OutboundIPPrefixes{}

	// Set property "PublicIPPrefixes":
	for _, item := range prefixes.PublicIPPrefixes {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.PublicIPPrefixes = append(result.PublicIPPrefixes, *item_ARM.(*arm.ResourceReference))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (prefixes *ManagedClusterLoadBalancerProfile_OutboundIPPrefixes) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterLoadBalancerProfile_OutboundIPPrefixes{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (prefixes *ManagedClusterLoadBalancerProfile_OutboundIPPrefixes) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterLoadBalancerProfile_OutboundIPPrefixes)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterLoadBalancerProfile_OutboundIPPrefixes, got %T", armInput)
	}

	// Set property "PublicIPPrefixes":
	for _, item := range typedInput.PublicIPPrefixes {
		var item1 ResourceReference
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		prefixes.PublicIPPrefixes = append(prefixes.PublicIPPrefixes, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterLoadBalancerProfile_OutboundIPPrefixes populates our ManagedClusterLoadBalancerProfile_OutboundIPPrefixes from the provided source ManagedClusterLoadBalancerProfile_OutboundIPPrefixes
func (prefixes *ManagedClusterLoadBalancerProfile_OutboundIPPrefixes) AssignProperties_From_ManagedClusterLoadBalancerProfile_OutboundIPPrefixes(source *storage.ManagedClusterLoadBalancerProfile_OutboundIPPrefixes) error {

	// PublicIPPrefixes
	if source.PublicIPPrefixes != nil {
		publicIPPrefixList := make([]ResourceReference, len(source.PublicIPPrefixes))
		for publicIPPrefixIndex, publicIPPrefixItem := range source.PublicIPPrefixes {
			// Shadow the loop variable to avoid aliasing
			publicIPPrefixItem := publicIPPrefixItem
			var publicIPPrefix ResourceReference
			err := publicIPPrefix.AssignProperties_From_ResourceReference(&publicIPPrefixItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ResourceReference() to populate field PublicIPPrefixes")
			}
			publicIPPrefixList[publicIPPrefixIndex] = publicIPPrefix
		}
		prefixes.PublicIPPrefixes = publicIPPrefixList
	} else {
		prefixes.PublicIPPrefixes = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterLoadBalancerProfile_OutboundIPPrefixes populates the provided destination ManagedClusterLoadBalancerProfile_OutboundIPPrefixes from our ManagedClusterLoadBalancerProfile_OutboundIPPrefixes
func (prefixes *ManagedClusterLoadBalancerProfile_OutboundIPPrefixes) AssignProperties_To_ManagedClusterLoadBalancerProfile_OutboundIPPrefixes(destination *storage.ManagedClusterLoadBalancerProfile_OutboundIPPrefixes) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PublicIPPrefixes
	if prefixes.PublicIPPrefixes != nil {
		publicIPPrefixList := make([]storage.ResourceReference, len(prefixes.PublicIPPrefixes))
		for publicIPPrefixIndex, publicIPPrefixItem := range prefixes.PublicIPPrefixes {
			// Shadow the loop variable to avoid aliasing
			publicIPPrefixItem := publicIPPrefixItem
			var publicIPPrefix storage.ResourceReference
			err := publicIPPrefixItem.AssignProperties_To_ResourceReference(&publicIPPrefix)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ResourceReference() to populate field PublicIPPrefixes")
			}
			publicIPPrefixList[publicIPPrefixIndex] = publicIPPrefix
		}
		destination.PublicIPPrefixes = publicIPPrefixList
	} else {
		destination.PublicIPPrefixes = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_STATUS struct {
	PublicIPPrefixes []ResourceReference_STATUS `json:"publicIPPrefixes,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (prefixes *ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (prefixes *ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_STATUS, got %T", armInput)
	}

	// Set property "PublicIPPrefixes":
	for _, item := range typedInput.PublicIPPrefixes {
		var item1 ResourceReference_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		prefixes.PublicIPPrefixes = append(prefixes.PublicIPPrefixes, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_STATUS populates our ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_STATUS from the provided source ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_STATUS
func (prefixes *ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_STATUS) AssignProperties_From_ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_STATUS(source *storage.ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_STATUS) error {

	// PublicIPPrefixes
	if source.PublicIPPrefixes != nil {
		publicIPPrefixList := make([]ResourceReference_STATUS, len(source.PublicIPPrefixes))
		for publicIPPrefixIndex, publicIPPrefixItem := range source.PublicIPPrefixes {
			// Shadow the loop variable to avoid aliasing
			publicIPPrefixItem := publicIPPrefixItem
			var publicIPPrefix ResourceReference_STATUS
			err := publicIPPrefix.AssignProperties_From_ResourceReference_STATUS(&publicIPPrefixItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ResourceReference_STATUS() to populate field PublicIPPrefixes")
			}
			publicIPPrefixList[publicIPPrefixIndex] = publicIPPrefix
		}
		prefixes.PublicIPPrefixes = publicIPPrefixList
	} else {
		prefixes.PublicIPPrefixes = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_STATUS populates the provided destination ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_STATUS from our ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_STATUS
func (prefixes *ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_STATUS) AssignProperties_To_ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_STATUS(destination *storage.ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PublicIPPrefixes
	if prefixes.PublicIPPrefixes != nil {
		publicIPPrefixList := make([]storage.ResourceReference_STATUS, len(prefixes.PublicIPPrefixes))
		for publicIPPrefixIndex, publicIPPrefixItem := range prefixes.PublicIPPrefixes {
			// Shadow the loop variable to avoid aliasing
			publicIPPrefixItem := publicIPPrefixItem
			var publicIPPrefix storage.ResourceReference_STATUS
			err := publicIPPrefixItem.AssignProperties_To_ResourceReference_STATUS(&publicIPPrefix)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ResourceReference_STATUS() to populate field PublicIPPrefixes")
			}
			publicIPPrefixList[publicIPPrefixIndex] = publicIPPrefix
		}
		destination.PublicIPPrefixes = publicIPPrefixList
	} else {
		destination.PublicIPPrefixes = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterLoadBalancerProfile_OutboundIPs struct {
	PublicIPs []ResourceReference `json:"publicIPs,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterLoadBalancerProfile_OutboundIPs{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (iPs *ManagedClusterLoadBalancerProfile_OutboundIPs) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if iPs == nil {
		return nil, nil
	}
	result := &arm.ManagedClusterLoadBalancerProfile_OutboundIPs{}

	// Set property "PublicIPs":
	for _, item := range iPs.PublicIPs {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.PublicIPs = append(result.PublicIPs, *item_ARM.(*arm.ResourceReference))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (iPs *ManagedClusterLoadBalancerProfile_OutboundIPs) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterLoadBalancerProfile_OutboundIPs{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (iPs *ManagedClusterLoadBalancerProfile_OutboundIPs) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterLoadBalancerProfile_OutboundIPs)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterLoadBalancerProfile_OutboundIPs, got %T", armInput)
	}

	// Set property "PublicIPs":
	for _, item := range typedInput.PublicIPs {
		var item1 ResourceReference
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		iPs.PublicIPs = append(iPs.PublicIPs, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterLoadBalancerProfile_OutboundIPs populates our ManagedClusterLoadBalancerProfile_OutboundIPs from the provided source ManagedClusterLoadBalancerProfile_OutboundIPs
func (iPs *ManagedClusterLoadBalancerProfile_OutboundIPs) AssignProperties_From_ManagedClusterLoadBalancerProfile_OutboundIPs(source *storage.ManagedClusterLoadBalancerProfile_OutboundIPs) error {

	// PublicIPs
	if source.PublicIPs != nil {
		publicIPList := make([]ResourceReference, len(source.PublicIPs))
		for publicIPIndex, publicIPItem := range source.PublicIPs {
			// Shadow the loop variable to avoid aliasing
			publicIPItem := publicIPItem
			var publicIP ResourceReference
			err := publicIP.AssignProperties_From_ResourceReference(&publicIPItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ResourceReference() to populate field PublicIPs")
			}
			publicIPList[publicIPIndex] = publicIP
		}
		iPs.PublicIPs = publicIPList
	} else {
		iPs.PublicIPs = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterLoadBalancerProfile_OutboundIPs populates the provided destination ManagedClusterLoadBalancerProfile_OutboundIPs from our ManagedClusterLoadBalancerProfile_OutboundIPs
func (iPs *ManagedClusterLoadBalancerProfile_OutboundIPs) AssignProperties_To_ManagedClusterLoadBalancerProfile_OutboundIPs(destination *storage.ManagedClusterLoadBalancerProfile_OutboundIPs) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PublicIPs
	if iPs.PublicIPs != nil {
		publicIPList := make([]storage.ResourceReference, len(iPs.PublicIPs))
		for publicIPIndex, publicIPItem := range iPs.PublicIPs {
			// Shadow the loop variable to avoid aliasing
			publicIPItem := publicIPItem
			var publicIP storage.ResourceReference
			err := publicIPItem.AssignProperties_To_ResourceReference(&publicIP)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ResourceReference() to populate field PublicIPs")
			}
			publicIPList[publicIPIndex] = publicIP
		}
		destination.PublicIPs = publicIPList
	} else {
		destination.PublicIPs = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterLoadBalancerProfile_OutboundIPs_STATUS struct {
	PublicIPs []ResourceReference_STATUS `json:"publicIPs,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterLoadBalancerProfile_OutboundIPs_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (iPs *ManagedClusterLoadBalancerProfile_OutboundIPs_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterLoadBalancerProfile_OutboundIPs_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (iPs *ManagedClusterLoadBalancerProfile_OutboundIPs_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterLoadBalancerProfile_OutboundIPs_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterLoadBalancerProfile_OutboundIPs_STATUS, got %T", armInput)
	}

	// Set property "PublicIPs":
	for _, item := range typedInput.PublicIPs {
		var item1 ResourceReference_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		iPs.PublicIPs = append(iPs.PublicIPs, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterLoadBalancerProfile_OutboundIPs_STATUS populates our ManagedClusterLoadBalancerProfile_OutboundIPs_STATUS from the provided source ManagedClusterLoadBalancerProfile_OutboundIPs_STATUS
func (iPs *ManagedClusterLoadBalancerProfile_OutboundIPs_STATUS) AssignProperties_From_ManagedClusterLoadBalancerProfile_OutboundIPs_STATUS(source *storage.ManagedClusterLoadBalancerProfile_OutboundIPs_STATUS) error {

	// PublicIPs
	if source.PublicIPs != nil {
		publicIPList := make([]ResourceReference_STATUS, len(source.PublicIPs))
		for publicIPIndex, publicIPItem := range source.PublicIPs {
			// Shadow the loop variable to avoid aliasing
			publicIPItem := publicIPItem
			var publicIP ResourceReference_STATUS
			err := publicIP.AssignProperties_From_ResourceReference_STATUS(&publicIPItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ResourceReference_STATUS() to populate field PublicIPs")
			}
			publicIPList[publicIPIndex] = publicIP
		}
		iPs.PublicIPs = publicIPList
	} else {
		iPs.PublicIPs = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterLoadBalancerProfile_OutboundIPs_STATUS populates the provided destination ManagedClusterLoadBalancerProfile_OutboundIPs_STATUS from our ManagedClusterLoadBalancerProfile_OutboundIPs_STATUS
func (iPs *ManagedClusterLoadBalancerProfile_OutboundIPs_STATUS) AssignProperties_To_ManagedClusterLoadBalancerProfile_OutboundIPs_STATUS(destination *storage.ManagedClusterLoadBalancerProfile_OutboundIPs_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PublicIPs
	if iPs.PublicIPs != nil {
		publicIPList := make([]storage.ResourceReference_STATUS, len(iPs.PublicIPs))
		for publicIPIndex, publicIPItem := range iPs.PublicIPs {
			// Shadow the loop variable to avoid aliasing
			publicIPItem := publicIPItem
			var publicIP storage.ResourceReference_STATUS
			err := publicIPItem.AssignProperties_To_ResourceReference_STATUS(&publicIP)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ResourceReference_STATUS() to populate field PublicIPs")
			}
			publicIPList[publicIPIndex] = publicIP
		}
		destination.PublicIPs = publicIPList
	} else {
		destination.PublicIPs = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterPodIdentity_ProvisioningInfo_STATUS struct {
	Error *ManagedClusterPodIdentityProvisioningError_STATUS `json:"error,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterPodIdentity_ProvisioningInfo_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (info *ManagedClusterPodIdentity_ProvisioningInfo_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterPodIdentity_ProvisioningInfo_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (info *ManagedClusterPodIdentity_ProvisioningInfo_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterPodIdentity_ProvisioningInfo_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterPodIdentity_ProvisioningInfo_STATUS, got %T", armInput)
	}

	// Set property "Error":
	if typedInput.Error != nil {
		var error1 ManagedClusterPodIdentityProvisioningError_STATUS
		err := error1.PopulateFromARM(owner, *typedInput.Error)
		if err != nil {
			return err
		}
		error := error1
		info.Error = &error
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterPodIdentity_ProvisioningInfo_STATUS populates our ManagedClusterPodIdentity_ProvisioningInfo_STATUS from the provided source ManagedClusterPodIdentity_ProvisioningInfo_STATUS
func (info *ManagedClusterPodIdentity_ProvisioningInfo_STATUS) AssignProperties_From_ManagedClusterPodIdentity_ProvisioningInfo_STATUS(source *storage.ManagedClusterPodIdentity_ProvisioningInfo_STATUS) error {

	// Error
	if source.Error != nil {
		var error ManagedClusterPodIdentityProvisioningError_STATUS
		err := error.AssignProperties_From_ManagedClusterPodIdentityProvisioningError_STATUS(source.Error)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterPodIdentityProvisioningError_STATUS() to populate field Error")
		}
		info.Error = &error
	} else {
		info.Error = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterPodIdentity_ProvisioningInfo_STATUS populates the provided destination ManagedClusterPodIdentity_ProvisioningInfo_STATUS from our ManagedClusterPodIdentity_ProvisioningInfo_STATUS
func (info *ManagedClusterPodIdentity_ProvisioningInfo_STATUS) AssignProperties_To_ManagedClusterPodIdentity_ProvisioningInfo_STATUS(destination *storage.ManagedClusterPodIdentity_ProvisioningInfo_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Error
	if info.Error != nil {
		var error storage.ManagedClusterPodIdentityProvisioningError_STATUS
		err := info.Error.AssignProperties_To_ManagedClusterPodIdentityProvisioningError_STATUS(&error)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterPodIdentityProvisioningError_STATUS() to populate field Error")
		}
		destination.Error = &error
	} else {
		destination.Error = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterPodIdentity_ProvisioningState_STATUS string

const (
	ManagedClusterPodIdentity_ProvisioningState_STATUS_Assigned = ManagedClusterPodIdentity_ProvisioningState_STATUS("Assigned")
	ManagedClusterPodIdentity_ProvisioningState_STATUS_Deleting = ManagedClusterPodIdentity_ProvisioningState_STATUS("Deleting")
	ManagedClusterPodIdentity_ProvisioningState_STATUS_Failed   = ManagedClusterPodIdentity_ProvisioningState_STATUS("Failed")
	ManagedClusterPodIdentity_ProvisioningState_STATUS_Updating = ManagedClusterPodIdentity_ProvisioningState_STATUS("Updating")
)

// Mapping from string to ManagedClusterPodIdentity_ProvisioningState_STATUS
var managedClusterPodIdentity_ProvisioningState_STATUS_Values = map[string]ManagedClusterPodIdentity_ProvisioningState_STATUS{
	"assigned": ManagedClusterPodIdentity_ProvisioningState_STATUS_Assigned,
	"deleting": ManagedClusterPodIdentity_ProvisioningState_STATUS_Deleting,
	"failed":   ManagedClusterPodIdentity_ProvisioningState_STATUS_Failed,
	"updating": ManagedClusterPodIdentity_ProvisioningState_STATUS_Updating,
}

type ResourceReference struct {
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

var _ genruntime.ARMTransformer = &ResourceReference{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (reference *ResourceReference) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if reference == nil {
		return nil, nil
	}
	result := &arm.ResourceReference{}

	// Set property "Id":
	if reference.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.Lookup(*reference.Reference)
		if err != nil {
			return nil, err
		}
		reference1 := referenceARMID
		result.Id = &reference1
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (reference *ResourceReference) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ResourceReference{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (reference *ResourceReference) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	_, ok := armInput.(arm.ResourceReference)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ResourceReference, got %T", armInput)
	}

	// no assignment for property "Reference"

	// No error
	return nil
}

// AssignProperties_From_ResourceReference populates our ResourceReference from the provided source ResourceReference
func (reference *ResourceReference) AssignProperties_From_ResourceReference(source *storage.ResourceReference) error {

	// Reference
	if source.Reference != nil {
		referenceTemp := source.Reference.Copy()
		reference.Reference = &referenceTemp
	} else {
		reference.Reference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ResourceReference populates the provided destination ResourceReference from our ResourceReference
func (reference *ResourceReference) AssignProperties_To_ResourceReference(destination *storage.ResourceReference) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Reference
	if reference.Reference != nil {
		referenceTemp := reference.Reference.Copy()
		destination.Reference = &referenceTemp
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ResourceReference_STATUS struct {
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &ResourceReference_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (reference *ResourceReference_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ResourceReference_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (reference *ResourceReference_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ResourceReference_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ResourceReference_STATUS, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		reference.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_ResourceReference_STATUS populates our ResourceReference_STATUS from the provided source ResourceReference_STATUS
func (reference *ResourceReference_STATUS) AssignProperties_From_ResourceReference_STATUS(source *storage.ResourceReference_STATUS) error {

	// Id
	reference.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_ResourceReference_STATUS populates the provided destination ResourceReference_STATUS from our ResourceReference_STATUS
func (reference *ResourceReference_STATUS) AssignProperties_To_ResourceReference_STATUS(destination *storage.ResourceReference_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(reference.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterPodIdentityProvisioningError_STATUS struct {
	Error *ManagedClusterPodIdentityProvisioningErrorBody_STATUS `json:"error,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterPodIdentityProvisioningError_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (error *ManagedClusterPodIdentityProvisioningError_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterPodIdentityProvisioningError_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (error *ManagedClusterPodIdentityProvisioningError_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterPodIdentityProvisioningError_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterPodIdentityProvisioningError_STATUS, got %T", armInput)
	}

	// Set property "Error":
	if typedInput.Error != nil {
		var error2 ManagedClusterPodIdentityProvisioningErrorBody_STATUS
		err := error2.PopulateFromARM(owner, *typedInput.Error)
		if err != nil {
			return err
		}
		error1 := error2
		error.Error = &error1
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterPodIdentityProvisioningError_STATUS populates our ManagedClusterPodIdentityProvisioningError_STATUS from the provided source ManagedClusterPodIdentityProvisioningError_STATUS
func (error *ManagedClusterPodIdentityProvisioningError_STATUS) AssignProperties_From_ManagedClusterPodIdentityProvisioningError_STATUS(source *storage.ManagedClusterPodIdentityProvisioningError_STATUS) error {

	// Error
	if source.Error != nil {
		var errorLocal ManagedClusterPodIdentityProvisioningErrorBody_STATUS
		err := errorLocal.AssignProperties_From_ManagedClusterPodIdentityProvisioningErrorBody_STATUS(source.Error)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterPodIdentityProvisioningErrorBody_STATUS() to populate field Error")
		}
		error.Error = &errorLocal
	} else {
		error.Error = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterPodIdentityProvisioningError_STATUS populates the provided destination ManagedClusterPodIdentityProvisioningError_STATUS from our ManagedClusterPodIdentityProvisioningError_STATUS
func (error *ManagedClusterPodIdentityProvisioningError_STATUS) AssignProperties_To_ManagedClusterPodIdentityProvisioningError_STATUS(destination *storage.ManagedClusterPodIdentityProvisioningError_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Error
	if error.Error != nil {
		var errorLocal storage.ManagedClusterPodIdentityProvisioningErrorBody_STATUS
		err := error.Error.AssignProperties_To_ManagedClusterPodIdentityProvisioningErrorBody_STATUS(&errorLocal)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterPodIdentityProvisioningErrorBody_STATUS() to populate field Error")
		}
		destination.Error = &errorLocal
	} else {
		destination.Error = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterPodIdentityProvisioningErrorBody_STATUS struct {
	Code    *string                                                          `json:"code,omitempty"`
	Details []ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled `json:"details,omitempty"`
	Message *string                                                          `json:"message,omitempty"`
	Target  *string                                                          `json:"target,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterPodIdentityProvisioningErrorBody_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (body *ManagedClusterPodIdentityProvisioningErrorBody_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterPodIdentityProvisioningErrorBody_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (body *ManagedClusterPodIdentityProvisioningErrorBody_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterPodIdentityProvisioningErrorBody_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterPodIdentityProvisioningErrorBody_STATUS, got %T", armInput)
	}

	// Set property "Code":
	if typedInput.Code != nil {
		code := *typedInput.Code
		body.Code = &code
	}

	// Set property "Details":
	for _, item := range typedInput.Details {
		var item1 ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		body.Details = append(body.Details, item1)
	}

	// Set property "Message":
	if typedInput.Message != nil {
		message := *typedInput.Message
		body.Message = &message
	}

	// Set property "Target":
	if typedInput.Target != nil {
		target := *typedInput.Target
		body.Target = &target
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterPodIdentityProvisioningErrorBody_STATUS populates our ManagedClusterPodIdentityProvisioningErrorBody_STATUS from the provided source ManagedClusterPodIdentityProvisioningErrorBody_STATUS
func (body *ManagedClusterPodIdentityProvisioningErrorBody_STATUS) AssignProperties_From_ManagedClusterPodIdentityProvisioningErrorBody_STATUS(source *storage.ManagedClusterPodIdentityProvisioningErrorBody_STATUS) error {

	// Code
	body.Code = genruntime.ClonePointerToString(source.Code)

	// Details
	if source.Details != nil {
		detailList := make([]ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled, len(source.Details))
		for detailIndex, detailItem := range source.Details {
			// Shadow the loop variable to avoid aliasing
			detailItem := detailItem
			var detail ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled
			err := detail.AssignProperties_From_ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled(&detailItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled() to populate field Details")
			}
			detailList[detailIndex] = detail
		}
		body.Details = detailList
	} else {
		body.Details = nil
	}

	// Message
	body.Message = genruntime.ClonePointerToString(source.Message)

	// Target
	body.Target = genruntime.ClonePointerToString(source.Target)

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterPodIdentityProvisioningErrorBody_STATUS populates the provided destination ManagedClusterPodIdentityProvisioningErrorBody_STATUS from our ManagedClusterPodIdentityProvisioningErrorBody_STATUS
func (body *ManagedClusterPodIdentityProvisioningErrorBody_STATUS) AssignProperties_To_ManagedClusterPodIdentityProvisioningErrorBody_STATUS(destination *storage.ManagedClusterPodIdentityProvisioningErrorBody_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Code
	destination.Code = genruntime.ClonePointerToString(body.Code)

	// Details
	if body.Details != nil {
		detailList := make([]storage.ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled, len(body.Details))
		for detailIndex, detailItem := range body.Details {
			// Shadow the loop variable to avoid aliasing
			detailItem := detailItem
			var detail storage.ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled
			err := detailItem.AssignProperties_To_ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled(&detail)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled() to populate field Details")
			}
			detailList[detailIndex] = detail
		}
		destination.Details = detailList
	} else {
		destination.Details = nil
	}

	// Message
	destination.Message = genruntime.ClonePointerToString(body.Message)

	// Target
	destination.Target = genruntime.ClonePointerToString(body.Target)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled struct {
	Code    *string `json:"code,omitempty"`
	Message *string `json:"message,omitempty"`
	Target  *string `json:"target,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (unrolled *ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (unrolled *ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled, got %T", armInput)
	}

	// Set property "Code":
	if typedInput.Code != nil {
		code := *typedInput.Code
		unrolled.Code = &code
	}

	// Set property "Message":
	if typedInput.Message != nil {
		message := *typedInput.Message
		unrolled.Message = &message
	}

	// Set property "Target":
	if typedInput.Target != nil {
		target := *typedInput.Target
		unrolled.Target = &target
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled populates our ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled from the provided source ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled
func (unrolled *ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled) AssignProperties_From_ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled(source *storage.ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled) error {

	// Code
	unrolled.Code = genruntime.ClonePointerToString(source.Code)

	// Message
	unrolled.Message = genruntime.ClonePointerToString(source.Message)

	// Target
	unrolled.Target = genruntime.ClonePointerToString(source.Target)

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled populates the provided destination ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled from our ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled
func (unrolled *ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled) AssignProperties_To_ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled(destination *storage.ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Code
	destination.Code = genruntime.ClonePointerToString(unrolled.Code)

	// Message
	destination.Message = genruntime.ClonePointerToString(unrolled.Message)

	// Target
	destination.Target = genruntime.ClonePointerToString(unrolled.Target)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

func init() {
	SchemeBuilder.Register(&ManagedCluster{}, &ManagedClusterList{})
}
