// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20230501

import (
	"fmt"
	arm "github.com/Azure/azure-service-operator/v2/api/kubernetesconfiguration/v1api20230501/arm"
	storage "github.com/Azure/azure-service-operator/v2/api/kubernetesconfiguration/v1api20230501/storage"
	"github.com/Azure/azure-service-operator/v2/internal/reflecthelpers"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/configmaps"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/core"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/secrets"
	"github.com/pkg/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
	"sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Generator information:
// - Generated from: /kubernetesconfiguration/resource-manager/Microsoft.KubernetesConfiguration/stable/2023-05-01/fluxconfiguration.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{clusterRp}/{clusterResourceName}/{clusterName}/providers/Microsoft.KubernetesConfiguration/fluxConfigurations/{fluxConfigurationName}
type FluxConfiguration struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              FluxConfiguration_Spec   `json:"spec,omitempty"`
	Status            FluxConfiguration_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &FluxConfiguration{}

// GetConditions returns the conditions of the resource
func (configuration *FluxConfiguration) GetConditions() conditions.Conditions {
	return configuration.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (configuration *FluxConfiguration) SetConditions(conditions conditions.Conditions) {
	configuration.Status.Conditions = conditions
}

var _ conversion.Convertible = &FluxConfiguration{}

// ConvertFrom populates our FluxConfiguration from the provided hub FluxConfiguration
func (configuration *FluxConfiguration) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*storage.FluxConfiguration)
	if !ok {
		return fmt.Errorf("expected kubernetesconfiguration/v1api20230501/storage/FluxConfiguration but received %T instead", hub)
	}

	return configuration.AssignProperties_From_FluxConfiguration(source)
}

// ConvertTo populates the provided hub FluxConfiguration from our FluxConfiguration
func (configuration *FluxConfiguration) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*storage.FluxConfiguration)
	if !ok {
		return fmt.Errorf("expected kubernetesconfiguration/v1api20230501/storage/FluxConfiguration but received %T instead", hub)
	}

	return configuration.AssignProperties_To_FluxConfiguration(destination)
}

// +kubebuilder:webhook:path=/mutate-kubernetesconfiguration-azure-com-v1api20230501-fluxconfiguration,mutating=true,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=kubernetesconfiguration.azure.com,resources=fluxconfigurations,verbs=create;update,versions=v1api20230501,name=default.v1api20230501.fluxconfigurations.kubernetesconfiguration.azure.com,admissionReviewVersions=v1

var _ admission.Defaulter = &FluxConfiguration{}

// Default applies defaults to the FluxConfiguration resource
func (configuration *FluxConfiguration) Default() {
	configuration.defaultImpl()
	var temp any = configuration
	if runtimeDefaulter, ok := temp.(genruntime.Defaulter); ok {
		runtimeDefaulter.CustomDefault()
	}
}

// defaultAzureName defaults the Azure name of the resource to the Kubernetes name
func (configuration *FluxConfiguration) defaultAzureName() {
	if configuration.Spec.AzureName == "" {
		configuration.Spec.AzureName = configuration.Name
	}
}

// defaultImpl applies the code generated defaults to the FluxConfiguration resource
func (configuration *FluxConfiguration) defaultImpl() { configuration.defaultAzureName() }

var _ configmaps.Exporter = &FluxConfiguration{}

// ConfigMapDestinationExpressions returns the Spec.OperatorSpec.ConfigMapExpressions property
func (configuration *FluxConfiguration) ConfigMapDestinationExpressions() []*core.DestinationExpression {
	if configuration.Spec.OperatorSpec == nil {
		return nil
	}
	return configuration.Spec.OperatorSpec.ConfigMapExpressions
}

var _ secrets.Exporter = &FluxConfiguration{}

// SecretDestinationExpressions returns the Spec.OperatorSpec.SecretExpressions property
func (configuration *FluxConfiguration) SecretDestinationExpressions() []*core.DestinationExpression {
	if configuration.Spec.OperatorSpec == nil {
		return nil
	}
	return configuration.Spec.OperatorSpec.SecretExpressions
}

var _ genruntime.ImportableResource = &FluxConfiguration{}

// InitializeSpec initializes the spec for this resource from the given status
func (configuration *FluxConfiguration) InitializeSpec(status genruntime.ConvertibleStatus) error {
	if s, ok := status.(*FluxConfiguration_STATUS); ok {
		return configuration.Spec.Initialize_From_FluxConfiguration_STATUS(s)
	}

	return fmt.Errorf("expected Status of type FluxConfiguration_STATUS but received %T instead", status)
}

var _ genruntime.KubernetesResource = &FluxConfiguration{}

// AzureName returns the Azure name of the resource
func (configuration *FluxConfiguration) AzureName() string {
	return configuration.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2023-05-01"
func (configuration FluxConfiguration) GetAPIVersion() string {
	return "2023-05-01"
}

// GetResourceScope returns the scope of the resource
func (configuration *FluxConfiguration) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeExtension
}

// GetSpec returns the specification of this resource
func (configuration *FluxConfiguration) GetSpec() genruntime.ConvertibleSpec {
	return &configuration.Spec
}

// GetStatus returns the status of this resource
func (configuration *FluxConfiguration) GetStatus() genruntime.ConvertibleStatus {
	return &configuration.Status
}

// GetSupportedOperations returns the operations supported by the resource
func (configuration *FluxConfiguration) GetSupportedOperations() []genruntime.ResourceOperation {
	return []genruntime.ResourceOperation{
		genruntime.ResourceOperationDelete,
		genruntime.ResourceOperationGet,
		genruntime.ResourceOperationPut,
	}
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.KubernetesConfiguration/fluxConfigurations"
func (configuration *FluxConfiguration) GetType() string {
	return "Microsoft.KubernetesConfiguration/fluxConfigurations"
}

// NewEmptyStatus returns a new empty (blank) status
func (configuration *FluxConfiguration) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &FluxConfiguration_STATUS{}
}

// Owner returns the ResourceReference of the owner
func (configuration *FluxConfiguration) Owner() *genruntime.ResourceReference {
	return configuration.Spec.Owner.AsResourceReference()
}

// SetStatus sets the status of this resource
func (configuration *FluxConfiguration) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*FluxConfiguration_STATUS); ok {
		configuration.Status = *st
		return nil
	}

	// Convert status to required version
	var st FluxConfiguration_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return errors.Wrap(err, "failed to convert status")
	}

	configuration.Status = st
	return nil
}

// +kubebuilder:webhook:path=/validate-kubernetesconfiguration-azure-com-v1api20230501-fluxconfiguration,mutating=false,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=kubernetesconfiguration.azure.com,resources=fluxconfigurations,verbs=create;update,versions=v1api20230501,name=validate.v1api20230501.fluxconfigurations.kubernetesconfiguration.azure.com,admissionReviewVersions=v1

var _ admission.Validator = &FluxConfiguration{}

// ValidateCreate validates the creation of the resource
func (configuration *FluxConfiguration) ValidateCreate() (admission.Warnings, error) {
	validations := configuration.createValidations()
	var temp any = configuration
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.CreateValidations()...)
	}
	return genruntime.ValidateCreate(validations)
}

// ValidateDelete validates the deletion of the resource
func (configuration *FluxConfiguration) ValidateDelete() (admission.Warnings, error) {
	validations := configuration.deleteValidations()
	var temp any = configuration
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.DeleteValidations()...)
	}
	return genruntime.ValidateDelete(validations)
}

// ValidateUpdate validates an update of the resource
func (configuration *FluxConfiguration) ValidateUpdate(old runtime.Object) (admission.Warnings, error) {
	validations := configuration.updateValidations()
	var temp any = configuration
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.UpdateValidations()...)
	}
	return genruntime.ValidateUpdate(old, validations)
}

// createValidations validates the creation of the resource
func (configuration *FluxConfiguration) createValidations() []func() (admission.Warnings, error) {
	return []func() (admission.Warnings, error){configuration.validateResourceReferences, configuration.validateSecretDestinations, configuration.validateConfigMapDestinations, configuration.validateOptionalConfigMapReferences}
}

// deleteValidations validates the deletion of the resource
func (configuration *FluxConfiguration) deleteValidations() []func() (admission.Warnings, error) {
	return nil
}

// updateValidations validates the update of the resource
func (configuration *FluxConfiguration) updateValidations() []func(old runtime.Object) (admission.Warnings, error) {
	return []func(old runtime.Object) (admission.Warnings, error){
		func(old runtime.Object) (admission.Warnings, error) {
			return configuration.validateResourceReferences()
		},
		configuration.validateWriteOnceProperties,
		func(old runtime.Object) (admission.Warnings, error) {
			return configuration.validateSecretDestinations()
		},
		func(old runtime.Object) (admission.Warnings, error) {
			return configuration.validateConfigMapDestinations()
		},
		func(old runtime.Object) (admission.Warnings, error) {
			return configuration.validateOptionalConfigMapReferences()
		},
	}
}

// validateConfigMapDestinations validates there are no colliding genruntime.ConfigMapDestinations
func (configuration *FluxConfiguration) validateConfigMapDestinations() (admission.Warnings, error) {
	if configuration.Spec.OperatorSpec == nil {
		return nil, nil
	}
	return configmaps.ValidateDestinations(configuration, nil, configuration.Spec.OperatorSpec.ConfigMapExpressions)
}

// validateOptionalConfigMapReferences validates all optional configmap reference pairs to ensure that at most 1 is set
func (configuration *FluxConfiguration) validateOptionalConfigMapReferences() (admission.Warnings, error) {
	refs, err := reflecthelpers.FindOptionalConfigMapReferences(&configuration.Spec)
	if err != nil {
		return nil, err
	}
	return configmaps.ValidateOptionalReferences(refs)
}

// validateResourceReferences validates all resource references
func (configuration *FluxConfiguration) validateResourceReferences() (admission.Warnings, error) {
	refs, err := reflecthelpers.FindResourceReferences(&configuration.Spec)
	if err != nil {
		return nil, err
	}
	return genruntime.ValidateResourceReferences(refs)
}

// validateSecretDestinations validates there are no colliding genruntime.SecretDestination's
func (configuration *FluxConfiguration) validateSecretDestinations() (admission.Warnings, error) {
	if configuration.Spec.OperatorSpec == nil {
		return nil, nil
	}
	return secrets.ValidateDestinations(configuration, nil, configuration.Spec.OperatorSpec.SecretExpressions)
}

// validateWriteOnceProperties validates all WriteOnce properties
func (configuration *FluxConfiguration) validateWriteOnceProperties(old runtime.Object) (admission.Warnings, error) {
	oldObj, ok := old.(*FluxConfiguration)
	if !ok {
		return nil, nil
	}

	return genruntime.ValidateWriteOnceProperties(oldObj, configuration)
}

// AssignProperties_From_FluxConfiguration populates our FluxConfiguration from the provided source FluxConfiguration
func (configuration *FluxConfiguration) AssignProperties_From_FluxConfiguration(source *storage.FluxConfiguration) error {

	// ObjectMeta
	configuration.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec FluxConfiguration_Spec
	err := spec.AssignProperties_From_FluxConfiguration_Spec(&source.Spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_FluxConfiguration_Spec() to populate field Spec")
	}
	configuration.Spec = spec

	// Status
	var status FluxConfiguration_STATUS
	err = status.AssignProperties_From_FluxConfiguration_STATUS(&source.Status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_FluxConfiguration_STATUS() to populate field Status")
	}
	configuration.Status = status

	// No error
	return nil
}

// AssignProperties_To_FluxConfiguration populates the provided destination FluxConfiguration from our FluxConfiguration
func (configuration *FluxConfiguration) AssignProperties_To_FluxConfiguration(destination *storage.FluxConfiguration) error {

	// ObjectMeta
	destination.ObjectMeta = *configuration.ObjectMeta.DeepCopy()

	// Spec
	var spec storage.FluxConfiguration_Spec
	err := configuration.Spec.AssignProperties_To_FluxConfiguration_Spec(&spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_FluxConfiguration_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status storage.FluxConfiguration_STATUS
	err = configuration.Status.AssignProperties_To_FluxConfiguration_STATUS(&status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_FluxConfiguration_STATUS() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (configuration *FluxConfiguration) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: configuration.Spec.OriginalVersion(),
		Kind:    "FluxConfiguration",
	}
}

// +kubebuilder:object:root=true
// Generator information:
// - Generated from: /kubernetesconfiguration/resource-manager/Microsoft.KubernetesConfiguration/stable/2023-05-01/fluxconfiguration.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{clusterRp}/{clusterResourceName}/{clusterName}/providers/Microsoft.KubernetesConfiguration/fluxConfigurations/{fluxConfigurationName}
type FluxConfigurationList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []FluxConfiguration `json:"items"`
}

type FluxConfiguration_Spec struct {
	// AzureBlob: Parameters to reconcile to the AzureBlob source kind type.
	AzureBlob *AzureBlobDefinition `json:"azureBlob,omitempty"`

	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName string `json:"azureName,omitempty"`

	// Bucket: Parameters to reconcile to the Bucket source kind type.
	Bucket *BucketDefinition `json:"bucket,omitempty"`

	// ConfigurationProtectedSettings: Key-value pairs of protected configuration settings for the configuration
	ConfigurationProtectedSettings *genruntime.SecretMapReference `json:"configurationProtectedSettings,omitempty"`

	// GitRepository: Parameters to reconcile to the GitRepository source kind type.
	GitRepository *GitRepositoryDefinition `json:"gitRepository,omitempty"`

	// Kustomizations: Array of kustomizations used to reconcile the artifact pulled by the source type on the cluster.
	Kustomizations map[string]KustomizationDefinition `json:"kustomizations,omitempty"`

	// Namespace: The namespace to which this configuration is installed to. Maximum of 253 lower case alphanumeric characters,
	// hyphen and period only.
	Namespace *string `json:"namespace,omitempty"`

	// OperatorSpec: The specification for configuring operator behavior. This field is interpreted by the operator and not
	// passed directly to Azure
	OperatorSpec *FluxConfigurationOperatorSpec `json:"operatorSpec,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. This resource is an
	// extension resource, which means that any other Azure resource can be its owner.
	Owner *genruntime.ArbitraryOwnerReference `json:"owner,omitempty"`

	// ReconciliationWaitDuration: Maximum duration to wait for flux configuration reconciliation. E.g PT1H, PT5M, P1D
	ReconciliationWaitDuration *string `json:"reconciliationWaitDuration,omitempty"`

	// Scope: Scope at which the operator will be installed.
	Scope *ScopeDefinition `json:"scope,omitempty"`

	// SourceKind: Source Kind to pull the configuration data from.
	SourceKind *SourceKindDefinition `json:"sourceKind,omitempty"`

	// Suspend: Whether this configuration should suspend its reconciliation of its kustomizations and sources.
	Suspend *bool `json:"suspend,omitempty"`

	// WaitForReconciliation: Whether flux configuration deployment should wait for cluster to reconcile the kustomizations.
	WaitForReconciliation *bool `json:"waitForReconciliation,omitempty"`
}

var _ genruntime.ARMTransformer = &FluxConfiguration_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (configuration *FluxConfiguration_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if configuration == nil {
		return nil, nil
	}
	result := &arm.FluxConfiguration_Spec{}

	// Set property "Name":
	result.Name = resolved.Name

	// Set property "Properties":
	if configuration.AzureBlob != nil ||
		configuration.Bucket != nil ||
		configuration.ConfigurationProtectedSettings != nil ||
		configuration.GitRepository != nil ||
		configuration.Kustomizations != nil ||
		configuration.Namespace != nil ||
		configuration.ReconciliationWaitDuration != nil ||
		configuration.Scope != nil ||
		configuration.SourceKind != nil ||
		configuration.Suspend != nil ||
		configuration.WaitForReconciliation != nil {
		result.Properties = &arm.FluxConfiguration_Properties_Spec{}
	}
	if configuration.AzureBlob != nil {
		azureBlob_ARM, err := (*configuration.AzureBlob).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		azureBlob := *azureBlob_ARM.(*arm.AzureBlobDefinition)
		result.Properties.AzureBlob = &azureBlob
	}
	if configuration.Bucket != nil {
		bucket_ARM, err := (*configuration.Bucket).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		bucket := *bucket_ARM.(*arm.BucketDefinition)
		result.Properties.Bucket = &bucket
	}
	if configuration.ConfigurationProtectedSettings != nil {
		var temp map[string]string
		tempSecret, err := resolved.ResolvedSecretMaps.Lookup(*configuration.ConfigurationProtectedSettings)
		if err != nil {
			return nil, errors.Wrap(err, "looking up secret for property temp")
		}
		temp = tempSecret
		result.Properties.ConfigurationProtectedSettings = temp
	}
	if configuration.GitRepository != nil {
		gitRepository_ARM, err := (*configuration.GitRepository).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		gitRepository := *gitRepository_ARM.(*arm.GitRepositoryDefinition)
		result.Properties.GitRepository = &gitRepository
	}
	if configuration.Kustomizations != nil {
		result.Properties.Kustomizations = make(map[string]arm.KustomizationDefinition, len(configuration.Kustomizations))
		for key, value := range configuration.Kustomizations {
			value_ARM, err := value.ConvertToARM(resolved)
			if err != nil {
				return nil, err
			}
			result.Properties.Kustomizations[key] = *value_ARM.(*arm.KustomizationDefinition)
		}
	}
	if configuration.Namespace != nil {
		namespace := *configuration.Namespace
		result.Properties.Namespace = &namespace
	}
	if configuration.ReconciliationWaitDuration != nil {
		reconciliationWaitDuration := *configuration.ReconciliationWaitDuration
		result.Properties.ReconciliationWaitDuration = &reconciliationWaitDuration
	}
	if configuration.Scope != nil {
		var temp string
		temp = string(*configuration.Scope)
		scope := arm.ScopeDefinition(temp)
		result.Properties.Scope = &scope
	}
	if configuration.SourceKind != nil {
		var temp string
		temp = string(*configuration.SourceKind)
		sourceKind := arm.SourceKindDefinition(temp)
		result.Properties.SourceKind = &sourceKind
	}
	if configuration.Suspend != nil {
		suspend := *configuration.Suspend
		result.Properties.Suspend = &suspend
	}
	if configuration.WaitForReconciliation != nil {
		waitForReconciliation := *configuration.WaitForReconciliation
		result.Properties.WaitForReconciliation = &waitForReconciliation
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *FluxConfiguration_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.FluxConfiguration_Spec{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *FluxConfiguration_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.FluxConfiguration_Spec)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.FluxConfiguration_Spec, got %T", armInput)
	}

	// Set property "AzureBlob":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AzureBlob != nil {
			var azureBlob1 AzureBlobDefinition
			err := azureBlob1.PopulateFromARM(owner, *typedInput.Properties.AzureBlob)
			if err != nil {
				return err
			}
			azureBlob := azureBlob1
			configuration.AzureBlob = &azureBlob
		}
	}

	// Set property "AzureName":
	configuration.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property "Bucket":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Bucket != nil {
			var bucket1 BucketDefinition
			err := bucket1.PopulateFromARM(owner, *typedInput.Properties.Bucket)
			if err != nil {
				return err
			}
			bucket := bucket1
			configuration.Bucket = &bucket
		}
	}

	// no assignment for property "ConfigurationProtectedSettings"

	// Set property "GitRepository":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.GitRepository != nil {
			var gitRepository1 GitRepositoryDefinition
			err := gitRepository1.PopulateFromARM(owner, *typedInput.Properties.GitRepository)
			if err != nil {
				return err
			}
			gitRepository := gitRepository1
			configuration.GitRepository = &gitRepository
		}
	}

	// Set property "Kustomizations":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Kustomizations != nil {
			configuration.Kustomizations = make(map[string]KustomizationDefinition, len(typedInput.Properties.Kustomizations))
			for key, value := range typedInput.Properties.Kustomizations {
				var value1 KustomizationDefinition
				err := value1.PopulateFromARM(owner, value)
				if err != nil {
					return err
				}
				configuration.Kustomizations[key] = value1
			}
		}
	}

	// Set property "Namespace":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Namespace != nil {
			namespace := *typedInput.Properties.Namespace
			configuration.Namespace = &namespace
		}
	}

	// no assignment for property "OperatorSpec"

	// Set property "Owner":
	configuration.Owner = &owner

	// Set property "ReconciliationWaitDuration":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ReconciliationWaitDuration != nil {
			reconciliationWaitDuration := *typedInput.Properties.ReconciliationWaitDuration
			configuration.ReconciliationWaitDuration = &reconciliationWaitDuration
		}
	}

	// Set property "Scope":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Scope != nil {
			var temp string
			temp = string(*typedInput.Properties.Scope)
			scope := ScopeDefinition(temp)
			configuration.Scope = &scope
		}
	}

	// Set property "SourceKind":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.SourceKind != nil {
			var temp string
			temp = string(*typedInput.Properties.SourceKind)
			sourceKind := SourceKindDefinition(temp)
			configuration.SourceKind = &sourceKind
		}
	}

	// Set property "Suspend":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Suspend != nil {
			suspend := *typedInput.Properties.Suspend
			configuration.Suspend = &suspend
		}
	}

	// Set property "WaitForReconciliation":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.WaitForReconciliation != nil {
			waitForReconciliation := *typedInput.Properties.WaitForReconciliation
			configuration.WaitForReconciliation = &waitForReconciliation
		}
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &FluxConfiguration_Spec{}

// ConvertSpecFrom populates our FluxConfiguration_Spec from the provided source
func (configuration *FluxConfiguration_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*storage.FluxConfiguration_Spec)
	if ok {
		// Populate our instance from source
		return configuration.AssignProperties_From_FluxConfiguration_Spec(src)
	}

	// Convert to an intermediate form
	src = &storage.FluxConfiguration_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = configuration.AssignProperties_From_FluxConfiguration_Spec(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our FluxConfiguration_Spec
func (configuration *FluxConfiguration_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*storage.FluxConfiguration_Spec)
	if ok {
		// Populate destination from our instance
		return configuration.AssignProperties_To_FluxConfiguration_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &storage.FluxConfiguration_Spec{}
	err := configuration.AssignProperties_To_FluxConfiguration_Spec(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignProperties_From_FluxConfiguration_Spec populates our FluxConfiguration_Spec from the provided source FluxConfiguration_Spec
func (configuration *FluxConfiguration_Spec) AssignProperties_From_FluxConfiguration_Spec(source *storage.FluxConfiguration_Spec) error {

	// AzureBlob
	if source.AzureBlob != nil {
		var azureBlob AzureBlobDefinition
		err := azureBlob.AssignProperties_From_AzureBlobDefinition(source.AzureBlob)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AzureBlobDefinition() to populate field AzureBlob")
		}
		configuration.AzureBlob = &azureBlob
	} else {
		configuration.AzureBlob = nil
	}

	// AzureName
	configuration.AzureName = source.AzureName

	// Bucket
	if source.Bucket != nil {
		var bucket BucketDefinition
		err := bucket.AssignProperties_From_BucketDefinition(source.Bucket)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_BucketDefinition() to populate field Bucket")
		}
		configuration.Bucket = &bucket
	} else {
		configuration.Bucket = nil
	}

	// ConfigurationProtectedSettings
	if source.ConfigurationProtectedSettings != nil {
		configurationProtectedSetting := source.ConfigurationProtectedSettings.Copy()
		configuration.ConfigurationProtectedSettings = &configurationProtectedSetting
	} else {
		configuration.ConfigurationProtectedSettings = nil
	}

	// GitRepository
	if source.GitRepository != nil {
		var gitRepository GitRepositoryDefinition
		err := gitRepository.AssignProperties_From_GitRepositoryDefinition(source.GitRepository)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_GitRepositoryDefinition() to populate field GitRepository")
		}
		configuration.GitRepository = &gitRepository
	} else {
		configuration.GitRepository = nil
	}

	// Kustomizations
	if source.Kustomizations != nil {
		kustomizationMap := make(map[string]KustomizationDefinition, len(source.Kustomizations))
		for kustomizationKey, kustomizationValue := range source.Kustomizations {
			// Shadow the loop variable to avoid aliasing
			kustomizationValue := kustomizationValue
			var kustomization KustomizationDefinition
			err := kustomization.AssignProperties_From_KustomizationDefinition(&kustomizationValue)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_KustomizationDefinition() to populate field Kustomizations")
			}
			kustomizationMap[kustomizationKey] = kustomization
		}
		configuration.Kustomizations = kustomizationMap
	} else {
		configuration.Kustomizations = nil
	}

	// Namespace
	configuration.Namespace = genruntime.ClonePointerToString(source.Namespace)

	// OperatorSpec
	if source.OperatorSpec != nil {
		var operatorSpec FluxConfigurationOperatorSpec
		err := operatorSpec.AssignProperties_From_FluxConfigurationOperatorSpec(source.OperatorSpec)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_FluxConfigurationOperatorSpec() to populate field OperatorSpec")
		}
		configuration.OperatorSpec = &operatorSpec
	} else {
		configuration.OperatorSpec = nil
	}

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		configuration.Owner = &owner
	} else {
		configuration.Owner = nil
	}

	// ReconciliationWaitDuration
	configuration.ReconciliationWaitDuration = genruntime.ClonePointerToString(source.ReconciliationWaitDuration)

	// Scope
	if source.Scope != nil {
		scope := *source.Scope
		scopeTemp := genruntime.ToEnum(scope, scopeDefinition_Values)
		configuration.Scope = &scopeTemp
	} else {
		configuration.Scope = nil
	}

	// SourceKind
	if source.SourceKind != nil {
		sourceKind := *source.SourceKind
		sourceKindTemp := genruntime.ToEnum(sourceKind, sourceKindDefinition_Values)
		configuration.SourceKind = &sourceKindTemp
	} else {
		configuration.SourceKind = nil
	}

	// Suspend
	if source.Suspend != nil {
		suspend := *source.Suspend
		configuration.Suspend = &suspend
	} else {
		configuration.Suspend = nil
	}

	// WaitForReconciliation
	if source.WaitForReconciliation != nil {
		waitForReconciliation := *source.WaitForReconciliation
		configuration.WaitForReconciliation = &waitForReconciliation
	} else {
		configuration.WaitForReconciliation = nil
	}

	// No error
	return nil
}

// AssignProperties_To_FluxConfiguration_Spec populates the provided destination FluxConfiguration_Spec from our FluxConfiguration_Spec
func (configuration *FluxConfiguration_Spec) AssignProperties_To_FluxConfiguration_Spec(destination *storage.FluxConfiguration_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureBlob
	if configuration.AzureBlob != nil {
		var azureBlob storage.AzureBlobDefinition
		err := configuration.AzureBlob.AssignProperties_To_AzureBlobDefinition(&azureBlob)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AzureBlobDefinition() to populate field AzureBlob")
		}
		destination.AzureBlob = &azureBlob
	} else {
		destination.AzureBlob = nil
	}

	// AzureName
	destination.AzureName = configuration.AzureName

	// Bucket
	if configuration.Bucket != nil {
		var bucket storage.BucketDefinition
		err := configuration.Bucket.AssignProperties_To_BucketDefinition(&bucket)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_BucketDefinition() to populate field Bucket")
		}
		destination.Bucket = &bucket
	} else {
		destination.Bucket = nil
	}

	// ConfigurationProtectedSettings
	if configuration.ConfigurationProtectedSettings != nil {
		configurationProtectedSetting := configuration.ConfigurationProtectedSettings.Copy()
		destination.ConfigurationProtectedSettings = &configurationProtectedSetting
	} else {
		destination.ConfigurationProtectedSettings = nil
	}

	// GitRepository
	if configuration.GitRepository != nil {
		var gitRepository storage.GitRepositoryDefinition
		err := configuration.GitRepository.AssignProperties_To_GitRepositoryDefinition(&gitRepository)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_GitRepositoryDefinition() to populate field GitRepository")
		}
		destination.GitRepository = &gitRepository
	} else {
		destination.GitRepository = nil
	}

	// Kustomizations
	if configuration.Kustomizations != nil {
		kustomizationMap := make(map[string]storage.KustomizationDefinition, len(configuration.Kustomizations))
		for kustomizationKey, kustomizationValue := range configuration.Kustomizations {
			// Shadow the loop variable to avoid aliasing
			kustomizationValue := kustomizationValue
			var kustomization storage.KustomizationDefinition
			err := kustomizationValue.AssignProperties_To_KustomizationDefinition(&kustomization)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_KustomizationDefinition() to populate field Kustomizations")
			}
			kustomizationMap[kustomizationKey] = kustomization
		}
		destination.Kustomizations = kustomizationMap
	} else {
		destination.Kustomizations = nil
	}

	// Namespace
	destination.Namespace = genruntime.ClonePointerToString(configuration.Namespace)

	// OperatorSpec
	if configuration.OperatorSpec != nil {
		var operatorSpec storage.FluxConfigurationOperatorSpec
		err := configuration.OperatorSpec.AssignProperties_To_FluxConfigurationOperatorSpec(&operatorSpec)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_FluxConfigurationOperatorSpec() to populate field OperatorSpec")
		}
		destination.OperatorSpec = &operatorSpec
	} else {
		destination.OperatorSpec = nil
	}

	// OriginalVersion
	destination.OriginalVersion = configuration.OriginalVersion()

	// Owner
	if configuration.Owner != nil {
		owner := configuration.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// ReconciliationWaitDuration
	destination.ReconciliationWaitDuration = genruntime.ClonePointerToString(configuration.ReconciliationWaitDuration)

	// Scope
	if configuration.Scope != nil {
		scope := string(*configuration.Scope)
		destination.Scope = &scope
	} else {
		destination.Scope = nil
	}

	// SourceKind
	if configuration.SourceKind != nil {
		sourceKind := string(*configuration.SourceKind)
		destination.SourceKind = &sourceKind
	} else {
		destination.SourceKind = nil
	}

	// Suspend
	if configuration.Suspend != nil {
		suspend := *configuration.Suspend
		destination.Suspend = &suspend
	} else {
		destination.Suspend = nil
	}

	// WaitForReconciliation
	if configuration.WaitForReconciliation != nil {
		waitForReconciliation := *configuration.WaitForReconciliation
		destination.WaitForReconciliation = &waitForReconciliation
	} else {
		destination.WaitForReconciliation = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_FluxConfiguration_STATUS populates our FluxConfiguration_Spec from the provided source FluxConfiguration_STATUS
func (configuration *FluxConfiguration_Spec) Initialize_From_FluxConfiguration_STATUS(source *FluxConfiguration_STATUS) error {

	// AzureBlob
	if source.AzureBlob != nil {
		var azureBlob AzureBlobDefinition
		err := azureBlob.Initialize_From_AzureBlobDefinition_STATUS(source.AzureBlob)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_AzureBlobDefinition_STATUS() to populate field AzureBlob")
		}
		configuration.AzureBlob = &azureBlob
	} else {
		configuration.AzureBlob = nil
	}

	// Bucket
	if source.Bucket != nil {
		var bucket BucketDefinition
		err := bucket.Initialize_From_BucketDefinition_STATUS(source.Bucket)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_BucketDefinition_STATUS() to populate field Bucket")
		}
		configuration.Bucket = &bucket
	} else {
		configuration.Bucket = nil
	}

	// GitRepository
	if source.GitRepository != nil {
		var gitRepository GitRepositoryDefinition
		err := gitRepository.Initialize_From_GitRepositoryDefinition_STATUS(source.GitRepository)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_GitRepositoryDefinition_STATUS() to populate field GitRepository")
		}
		configuration.GitRepository = &gitRepository
	} else {
		configuration.GitRepository = nil
	}

	// Kustomizations
	if source.Kustomizations != nil {
		kustomizationMap := make(map[string]KustomizationDefinition, len(source.Kustomizations))
		for kustomizationKey, kustomizationValue := range source.Kustomizations {
			// Shadow the loop variable to avoid aliasing
			kustomizationValue := kustomizationValue
			var kustomization KustomizationDefinition
			err := kustomization.Initialize_From_KustomizationDefinition_STATUS(&kustomizationValue)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_KustomizationDefinition_STATUS() to populate field Kustomizations")
			}
			kustomizationMap[kustomizationKey] = kustomization
		}
		configuration.Kustomizations = kustomizationMap
	} else {
		configuration.Kustomizations = nil
	}

	// Namespace
	configuration.Namespace = genruntime.ClonePointerToString(source.Namespace)

	// ReconciliationWaitDuration
	configuration.ReconciliationWaitDuration = genruntime.ClonePointerToString(source.ReconciliationWaitDuration)

	// Scope
	if source.Scope != nil {
		scope := genruntime.ToEnum(string(*source.Scope), scopeDefinition_Values)
		configuration.Scope = &scope
	} else {
		configuration.Scope = nil
	}

	// SourceKind
	if source.SourceKind != nil {
		sourceKind := genruntime.ToEnum(string(*source.SourceKind), sourceKindDefinition_Values)
		configuration.SourceKind = &sourceKind
	} else {
		configuration.SourceKind = nil
	}

	// Suspend
	if source.Suspend != nil {
		suspend := *source.Suspend
		configuration.Suspend = &suspend
	} else {
		configuration.Suspend = nil
	}

	// WaitForReconciliation
	if source.WaitForReconciliation != nil {
		waitForReconciliation := *source.WaitForReconciliation
		configuration.WaitForReconciliation = &waitForReconciliation
	} else {
		configuration.WaitForReconciliation = nil
	}

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (configuration *FluxConfiguration_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (configuration *FluxConfiguration_Spec) SetAzureName(azureName string) {
	configuration.AzureName = azureName
}

// The Flux Configuration object returned in Get & Put response.
type FluxConfiguration_STATUS struct {
	// AzureBlob: Parameters to reconcile to the AzureBlob source kind type.
	AzureBlob *AzureBlobDefinition_STATUS `json:"azureBlob,omitempty"`

	// Bucket: Parameters to reconcile to the Bucket source kind type.
	Bucket *BucketDefinition_STATUS `json:"bucket,omitempty"`

	// ComplianceState: Combined status of the Flux Kubernetes resources created by the fluxConfiguration or created by the
	// managed objects.
	ComplianceState *FluxComplianceStateDefinition_STATUS `json:"complianceState,omitempty"`

	// Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	// ConfigurationProtectedSettings: Key-value pairs of protected configuration settings for the configuration
	ConfigurationProtectedSettings map[string]string `json:"configurationProtectedSettings,omitempty"`

	// ErrorMessage: Error message returned to the user in the case of provisioning failure.
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// GitRepository: Parameters to reconcile to the GitRepository source kind type.
	GitRepository *GitRepositoryDefinition_STATUS `json:"gitRepository,omitempty"`

	// Id: Fully qualified resource ID for the resource. Ex -
	// /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	Id *string `json:"id,omitempty"`

	// Kustomizations: Array of kustomizations used to reconcile the artifact pulled by the source type on the cluster.
	Kustomizations map[string]KustomizationDefinition_STATUS `json:"kustomizations,omitempty"`

	// Name: The name of the resource
	Name *string `json:"name,omitempty"`

	// Namespace: The namespace to which this configuration is installed to. Maximum of 253 lower case alphanumeric characters,
	// hyphen and period only.
	Namespace *string `json:"namespace,omitempty"`

	// ProvisioningState: Status of the creation of the fluxConfiguration.
	ProvisioningState *ProvisioningStateDefinition_STATUS `json:"provisioningState,omitempty"`

	// ReconciliationWaitDuration: Maximum duration to wait for flux configuration reconciliation. E.g PT1H, PT5M, P1D
	ReconciliationWaitDuration *string `json:"reconciliationWaitDuration,omitempty"`

	// RepositoryPublicKey: Public Key associated with this fluxConfiguration (either generated within the cluster or provided
	// by the user).
	RepositoryPublicKey *string `json:"repositoryPublicKey,omitempty"`

	// Scope: Scope at which the operator will be installed.
	Scope *ScopeDefinition_STATUS `json:"scope,omitempty"`

	// SourceKind: Source Kind to pull the configuration data from.
	SourceKind *SourceKindDefinition_STATUS `json:"sourceKind,omitempty"`

	// SourceSyncedCommitId: Branch and/or SHA of the source commit synced with the cluster.
	SourceSyncedCommitId *string `json:"sourceSyncedCommitId,omitempty"`

	// SourceUpdatedAt: Datetime the fluxConfiguration synced its source on the cluster.
	SourceUpdatedAt *string `json:"sourceUpdatedAt,omitempty"`

	// StatusUpdatedAt: Datetime the fluxConfiguration synced its status on the cluster with Azure.
	StatusUpdatedAt *string `json:"statusUpdatedAt,omitempty"`

	// Statuses: Statuses of the Flux Kubernetes resources created by the fluxConfiguration or created by the managed objects
	// provisioned by the fluxConfiguration.
	Statuses []ObjectStatusDefinition_STATUS `json:"statuses,omitempty"`

	// Suspend: Whether this configuration should suspend its reconciliation of its kustomizations and sources.
	Suspend *bool `json:"suspend,omitempty"`

	// Type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`

	// WaitForReconciliation: Whether flux configuration deployment should wait for cluster to reconcile the kustomizations.
	WaitForReconciliation *bool `json:"waitForReconciliation,omitempty"`
}

var _ genruntime.ConvertibleStatus = &FluxConfiguration_STATUS{}

// ConvertStatusFrom populates our FluxConfiguration_STATUS from the provided source
func (configuration *FluxConfiguration_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*storage.FluxConfiguration_STATUS)
	if ok {
		// Populate our instance from source
		return configuration.AssignProperties_From_FluxConfiguration_STATUS(src)
	}

	// Convert to an intermediate form
	src = &storage.FluxConfiguration_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = configuration.AssignProperties_From_FluxConfiguration_STATUS(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our FluxConfiguration_STATUS
func (configuration *FluxConfiguration_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*storage.FluxConfiguration_STATUS)
	if ok {
		// Populate destination from our instance
		return configuration.AssignProperties_To_FluxConfiguration_STATUS(dst)
	}

	// Convert to an intermediate form
	dst = &storage.FluxConfiguration_STATUS{}
	err := configuration.AssignProperties_To_FluxConfiguration_STATUS(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &FluxConfiguration_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *FluxConfiguration_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.FluxConfiguration_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *FluxConfiguration_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.FluxConfiguration_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.FluxConfiguration_STATUS, got %T", armInput)
	}

	// Set property "AzureBlob":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AzureBlob != nil {
			var azureBlob1 AzureBlobDefinition_STATUS
			err := azureBlob1.PopulateFromARM(owner, *typedInput.Properties.AzureBlob)
			if err != nil {
				return err
			}
			azureBlob := azureBlob1
			configuration.AzureBlob = &azureBlob
		}
	}

	// Set property "Bucket":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Bucket != nil {
			var bucket1 BucketDefinition_STATUS
			err := bucket1.PopulateFromARM(owner, *typedInput.Properties.Bucket)
			if err != nil {
				return err
			}
			bucket := bucket1
			configuration.Bucket = &bucket
		}
	}

	// Set property "ComplianceState":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ComplianceState != nil {
			var temp string
			temp = string(*typedInput.Properties.ComplianceState)
			complianceState := FluxComplianceStateDefinition_STATUS(temp)
			configuration.ComplianceState = &complianceState
		}
	}

	// no assignment for property "Conditions"

	// Set property "ConfigurationProtectedSettings":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ConfigurationProtectedSettings != nil {
			configuration.ConfigurationProtectedSettings = make(map[string]string, len(typedInput.Properties.ConfigurationProtectedSettings))
			for key, value := range typedInput.Properties.ConfigurationProtectedSettings {
				configuration.ConfigurationProtectedSettings[key] = value
			}
		}
	}

	// Set property "ErrorMessage":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ErrorMessage != nil {
			errorMessage := *typedInput.Properties.ErrorMessage
			configuration.ErrorMessage = &errorMessage
		}
	}

	// Set property "GitRepository":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.GitRepository != nil {
			var gitRepository1 GitRepositoryDefinition_STATUS
			err := gitRepository1.PopulateFromARM(owner, *typedInput.Properties.GitRepository)
			if err != nil {
				return err
			}
			gitRepository := gitRepository1
			configuration.GitRepository = &gitRepository
		}
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		configuration.Id = &id
	}

	// Set property "Kustomizations":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Kustomizations != nil {
			configuration.Kustomizations = make(map[string]KustomizationDefinition_STATUS, len(typedInput.Properties.Kustomizations))
			for key, value := range typedInput.Properties.Kustomizations {
				var value1 KustomizationDefinition_STATUS
				err := value1.PopulateFromARM(owner, value)
				if err != nil {
					return err
				}
				configuration.Kustomizations[key] = value1
			}
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		configuration.Name = &name
	}

	// Set property "Namespace":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Namespace != nil {
			namespace := *typedInput.Properties.Namespace
			configuration.Namespace = &namespace
		}
	}

	// Set property "ProvisioningState":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			var temp string
			temp = string(*typedInput.Properties.ProvisioningState)
			provisioningState := ProvisioningStateDefinition_STATUS(temp)
			configuration.ProvisioningState = &provisioningState
		}
	}

	// Set property "ReconciliationWaitDuration":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ReconciliationWaitDuration != nil {
			reconciliationWaitDuration := *typedInput.Properties.ReconciliationWaitDuration
			configuration.ReconciliationWaitDuration = &reconciliationWaitDuration
		}
	}

	// Set property "RepositoryPublicKey":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.RepositoryPublicKey != nil {
			repositoryPublicKey := *typedInput.Properties.RepositoryPublicKey
			configuration.RepositoryPublicKey = &repositoryPublicKey
		}
	}

	// Set property "Scope":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Scope != nil {
			var temp string
			temp = string(*typedInput.Properties.Scope)
			scope := ScopeDefinition_STATUS(temp)
			configuration.Scope = &scope
		}
	}

	// Set property "SourceKind":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.SourceKind != nil {
			var temp string
			temp = string(*typedInput.Properties.SourceKind)
			sourceKind := SourceKindDefinition_STATUS(temp)
			configuration.SourceKind = &sourceKind
		}
	}

	// Set property "SourceSyncedCommitId":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.SourceSyncedCommitId != nil {
			sourceSyncedCommitId := *typedInput.Properties.SourceSyncedCommitId
			configuration.SourceSyncedCommitId = &sourceSyncedCommitId
		}
	}

	// Set property "SourceUpdatedAt":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.SourceUpdatedAt != nil {
			sourceUpdatedAt := *typedInput.Properties.SourceUpdatedAt
			configuration.SourceUpdatedAt = &sourceUpdatedAt
		}
	}

	// Set property "StatusUpdatedAt":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.StatusUpdatedAt != nil {
			statusUpdatedAt := *typedInput.Properties.StatusUpdatedAt
			configuration.StatusUpdatedAt = &statusUpdatedAt
		}
	}

	// Set property "Statuses":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Statuses {
			var item1 ObjectStatusDefinition_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			configuration.Statuses = append(configuration.Statuses, item1)
		}
	}

	// Set property "Suspend":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Suspend != nil {
			suspend := *typedInput.Properties.Suspend
			configuration.Suspend = &suspend
		}
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		configuration.Type = &typeVar
	}

	// Set property "WaitForReconciliation":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.WaitForReconciliation != nil {
			waitForReconciliation := *typedInput.Properties.WaitForReconciliation
			configuration.WaitForReconciliation = &waitForReconciliation
		}
	}

	// No error
	return nil
}

// AssignProperties_From_FluxConfiguration_STATUS populates our FluxConfiguration_STATUS from the provided source FluxConfiguration_STATUS
func (configuration *FluxConfiguration_STATUS) AssignProperties_From_FluxConfiguration_STATUS(source *storage.FluxConfiguration_STATUS) error {

	// AzureBlob
	if source.AzureBlob != nil {
		var azureBlob AzureBlobDefinition_STATUS
		err := azureBlob.AssignProperties_From_AzureBlobDefinition_STATUS(source.AzureBlob)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AzureBlobDefinition_STATUS() to populate field AzureBlob")
		}
		configuration.AzureBlob = &azureBlob
	} else {
		configuration.AzureBlob = nil
	}

	// Bucket
	if source.Bucket != nil {
		var bucket BucketDefinition_STATUS
		err := bucket.AssignProperties_From_BucketDefinition_STATUS(source.Bucket)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_BucketDefinition_STATUS() to populate field Bucket")
		}
		configuration.Bucket = &bucket
	} else {
		configuration.Bucket = nil
	}

	// ComplianceState
	if source.ComplianceState != nil {
		complianceState := *source.ComplianceState
		complianceStateTemp := genruntime.ToEnum(complianceState, fluxComplianceStateDefinition_STATUS_Values)
		configuration.ComplianceState = &complianceStateTemp
	} else {
		configuration.ComplianceState = nil
	}

	// Conditions
	configuration.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// ConfigurationProtectedSettings
	configuration.ConfigurationProtectedSettings = genruntime.CloneMapOfStringToString(source.ConfigurationProtectedSettings)

	// ErrorMessage
	configuration.ErrorMessage = genruntime.ClonePointerToString(source.ErrorMessage)

	// GitRepository
	if source.GitRepository != nil {
		var gitRepository GitRepositoryDefinition_STATUS
		err := gitRepository.AssignProperties_From_GitRepositoryDefinition_STATUS(source.GitRepository)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_GitRepositoryDefinition_STATUS() to populate field GitRepository")
		}
		configuration.GitRepository = &gitRepository
	} else {
		configuration.GitRepository = nil
	}

	// Id
	configuration.Id = genruntime.ClonePointerToString(source.Id)

	// Kustomizations
	if source.Kustomizations != nil {
		kustomizationMap := make(map[string]KustomizationDefinition_STATUS, len(source.Kustomizations))
		for kustomizationKey, kustomizationValue := range source.Kustomizations {
			// Shadow the loop variable to avoid aliasing
			kustomizationValue := kustomizationValue
			var kustomization KustomizationDefinition_STATUS
			err := kustomization.AssignProperties_From_KustomizationDefinition_STATUS(&kustomizationValue)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_KustomizationDefinition_STATUS() to populate field Kustomizations")
			}
			kustomizationMap[kustomizationKey] = kustomization
		}
		configuration.Kustomizations = kustomizationMap
	} else {
		configuration.Kustomizations = nil
	}

	// Name
	configuration.Name = genruntime.ClonePointerToString(source.Name)

	// Namespace
	configuration.Namespace = genruntime.ClonePointerToString(source.Namespace)

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := *source.ProvisioningState
		provisioningStateTemp := genruntime.ToEnum(provisioningState, provisioningStateDefinition_STATUS_Values)
		configuration.ProvisioningState = &provisioningStateTemp
	} else {
		configuration.ProvisioningState = nil
	}

	// ReconciliationWaitDuration
	configuration.ReconciliationWaitDuration = genruntime.ClonePointerToString(source.ReconciliationWaitDuration)

	// RepositoryPublicKey
	configuration.RepositoryPublicKey = genruntime.ClonePointerToString(source.RepositoryPublicKey)

	// Scope
	if source.Scope != nil {
		scope := *source.Scope
		scopeTemp := genruntime.ToEnum(scope, scopeDefinition_STATUS_Values)
		configuration.Scope = &scopeTemp
	} else {
		configuration.Scope = nil
	}

	// SourceKind
	if source.SourceKind != nil {
		sourceKind := *source.SourceKind
		sourceKindTemp := genruntime.ToEnum(sourceKind, sourceKindDefinition_STATUS_Values)
		configuration.SourceKind = &sourceKindTemp
	} else {
		configuration.SourceKind = nil
	}

	// SourceSyncedCommitId
	configuration.SourceSyncedCommitId = genruntime.ClonePointerToString(source.SourceSyncedCommitId)

	// SourceUpdatedAt
	configuration.SourceUpdatedAt = genruntime.ClonePointerToString(source.SourceUpdatedAt)

	// StatusUpdatedAt
	configuration.StatusUpdatedAt = genruntime.ClonePointerToString(source.StatusUpdatedAt)

	// Statuses
	if source.Statuses != nil {
		statusList := make([]ObjectStatusDefinition_STATUS, len(source.Statuses))
		for statusIndex, statusItem := range source.Statuses {
			// Shadow the loop variable to avoid aliasing
			statusItem := statusItem
			var status ObjectStatusDefinition_STATUS
			err := status.AssignProperties_From_ObjectStatusDefinition_STATUS(&statusItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ObjectStatusDefinition_STATUS() to populate field Statuses")
			}
			statusList[statusIndex] = status
		}
		configuration.Statuses = statusList
	} else {
		configuration.Statuses = nil
	}

	// Suspend
	if source.Suspend != nil {
		suspend := *source.Suspend
		configuration.Suspend = &suspend
	} else {
		configuration.Suspend = nil
	}

	// Type
	configuration.Type = genruntime.ClonePointerToString(source.Type)

	// WaitForReconciliation
	if source.WaitForReconciliation != nil {
		waitForReconciliation := *source.WaitForReconciliation
		configuration.WaitForReconciliation = &waitForReconciliation
	} else {
		configuration.WaitForReconciliation = nil
	}

	// No error
	return nil
}

// AssignProperties_To_FluxConfiguration_STATUS populates the provided destination FluxConfiguration_STATUS from our FluxConfiguration_STATUS
func (configuration *FluxConfiguration_STATUS) AssignProperties_To_FluxConfiguration_STATUS(destination *storage.FluxConfiguration_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureBlob
	if configuration.AzureBlob != nil {
		var azureBlob storage.AzureBlobDefinition_STATUS
		err := configuration.AzureBlob.AssignProperties_To_AzureBlobDefinition_STATUS(&azureBlob)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AzureBlobDefinition_STATUS() to populate field AzureBlob")
		}
		destination.AzureBlob = &azureBlob
	} else {
		destination.AzureBlob = nil
	}

	// Bucket
	if configuration.Bucket != nil {
		var bucket storage.BucketDefinition_STATUS
		err := configuration.Bucket.AssignProperties_To_BucketDefinition_STATUS(&bucket)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_BucketDefinition_STATUS() to populate field Bucket")
		}
		destination.Bucket = &bucket
	} else {
		destination.Bucket = nil
	}

	// ComplianceState
	if configuration.ComplianceState != nil {
		complianceState := string(*configuration.ComplianceState)
		destination.ComplianceState = &complianceState
	} else {
		destination.ComplianceState = nil
	}

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(configuration.Conditions)

	// ConfigurationProtectedSettings
	destination.ConfigurationProtectedSettings = genruntime.CloneMapOfStringToString(configuration.ConfigurationProtectedSettings)

	// ErrorMessage
	destination.ErrorMessage = genruntime.ClonePointerToString(configuration.ErrorMessage)

	// GitRepository
	if configuration.GitRepository != nil {
		var gitRepository storage.GitRepositoryDefinition_STATUS
		err := configuration.GitRepository.AssignProperties_To_GitRepositoryDefinition_STATUS(&gitRepository)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_GitRepositoryDefinition_STATUS() to populate field GitRepository")
		}
		destination.GitRepository = &gitRepository
	} else {
		destination.GitRepository = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(configuration.Id)

	// Kustomizations
	if configuration.Kustomizations != nil {
		kustomizationMap := make(map[string]storage.KustomizationDefinition_STATUS, len(configuration.Kustomizations))
		for kustomizationKey, kustomizationValue := range configuration.Kustomizations {
			// Shadow the loop variable to avoid aliasing
			kustomizationValue := kustomizationValue
			var kustomization storage.KustomizationDefinition_STATUS
			err := kustomizationValue.AssignProperties_To_KustomizationDefinition_STATUS(&kustomization)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_KustomizationDefinition_STATUS() to populate field Kustomizations")
			}
			kustomizationMap[kustomizationKey] = kustomization
		}
		destination.Kustomizations = kustomizationMap
	} else {
		destination.Kustomizations = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(configuration.Name)

	// Namespace
	destination.Namespace = genruntime.ClonePointerToString(configuration.Namespace)

	// ProvisioningState
	if configuration.ProvisioningState != nil {
		provisioningState := string(*configuration.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// ReconciliationWaitDuration
	destination.ReconciliationWaitDuration = genruntime.ClonePointerToString(configuration.ReconciliationWaitDuration)

	// RepositoryPublicKey
	destination.RepositoryPublicKey = genruntime.ClonePointerToString(configuration.RepositoryPublicKey)

	// Scope
	if configuration.Scope != nil {
		scope := string(*configuration.Scope)
		destination.Scope = &scope
	} else {
		destination.Scope = nil
	}

	// SourceKind
	if configuration.SourceKind != nil {
		sourceKind := string(*configuration.SourceKind)
		destination.SourceKind = &sourceKind
	} else {
		destination.SourceKind = nil
	}

	// SourceSyncedCommitId
	destination.SourceSyncedCommitId = genruntime.ClonePointerToString(configuration.SourceSyncedCommitId)

	// SourceUpdatedAt
	destination.SourceUpdatedAt = genruntime.ClonePointerToString(configuration.SourceUpdatedAt)

	// StatusUpdatedAt
	destination.StatusUpdatedAt = genruntime.ClonePointerToString(configuration.StatusUpdatedAt)

	// Statuses
	if configuration.Statuses != nil {
		statusList := make([]storage.ObjectStatusDefinition_STATUS, len(configuration.Statuses))
		for statusIndex, statusItem := range configuration.Statuses {
			// Shadow the loop variable to avoid aliasing
			statusItem := statusItem
			var status storage.ObjectStatusDefinition_STATUS
			err := statusItem.AssignProperties_To_ObjectStatusDefinition_STATUS(&status)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ObjectStatusDefinition_STATUS() to populate field Statuses")
			}
			statusList[statusIndex] = status
		}
		destination.Statuses = statusList
	} else {
		destination.Statuses = nil
	}

	// Suspend
	if configuration.Suspend != nil {
		suspend := *configuration.Suspend
		destination.Suspend = &suspend
	} else {
		destination.Suspend = nil
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(configuration.Type)

	// WaitForReconciliation
	if configuration.WaitForReconciliation != nil {
		waitForReconciliation := *configuration.WaitForReconciliation
		destination.WaitForReconciliation = &waitForReconciliation
	} else {
		destination.WaitForReconciliation = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Parameters to reconcile to the AzureBlob source kind type.
type AzureBlobDefinition struct {
	// AccountKey: The account key (shared key) to access the storage account
	AccountKey *genruntime.SecretReference `json:"accountKey,omitempty"`

	// ContainerName: The Azure Blob container name to sync from the url endpoint for the flux configuration.
	ContainerName *string `json:"containerName,omitempty"`

	// LocalAuthRef: Name of a local secret on the Kubernetes cluster to use as the authentication secret rather than the
	// managed or user-provided configuration secrets.
	LocalAuthRef *string `json:"localAuthRef,omitempty"`

	// ManagedIdentity: Parameters to authenticate using a Managed Identity.
	ManagedIdentity *ManagedIdentityDefinition `json:"managedIdentity,omitempty"`

	// SasToken: The Shared Access token to access the storage container
	SasToken *genruntime.SecretReference `json:"sasToken,omitempty"`

	// ServicePrincipal: Parameters to authenticate using Service Principal.
	ServicePrincipal *ServicePrincipalDefinition `json:"servicePrincipal,omitempty"`

	// SyncIntervalInSeconds: The interval at which to re-reconcile the cluster Azure Blob source with the remote.
	SyncIntervalInSeconds *int `json:"syncIntervalInSeconds,omitempty"`

	// TimeoutInSeconds: The maximum time to attempt to reconcile the cluster Azure Blob source with the remote.
	TimeoutInSeconds *int `json:"timeoutInSeconds,omitempty"`

	// Url: The URL to sync for the flux configuration Azure Blob storage account.
	Url *string `json:"url,omitempty"`
}

var _ genruntime.ARMTransformer = &AzureBlobDefinition{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (definition *AzureBlobDefinition) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if definition == nil {
		return nil, nil
	}
	result := &arm.AzureBlobDefinition{}

	// Set property "AccountKey":
	if definition.AccountKey != nil {
		accountKeySecret, err := resolved.ResolvedSecrets.Lookup(*definition.AccountKey)
		if err != nil {
			return nil, errors.Wrap(err, "looking up secret for property AccountKey")
		}
		accountKey := accountKeySecret
		result.AccountKey = &accountKey
	}

	// Set property "ContainerName":
	if definition.ContainerName != nil {
		containerName := *definition.ContainerName
		result.ContainerName = &containerName
	}

	// Set property "LocalAuthRef":
	if definition.LocalAuthRef != nil {
		localAuthRef := *definition.LocalAuthRef
		result.LocalAuthRef = &localAuthRef
	}

	// Set property "ManagedIdentity":
	if definition.ManagedIdentity != nil {
		managedIdentity_ARM, err := (*definition.ManagedIdentity).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		managedIdentity := *managedIdentity_ARM.(*arm.ManagedIdentityDefinition)
		result.ManagedIdentity = &managedIdentity
	}

	// Set property "SasToken":
	if definition.SasToken != nil {
		sasTokenSecret, err := resolved.ResolvedSecrets.Lookup(*definition.SasToken)
		if err != nil {
			return nil, errors.Wrap(err, "looking up secret for property SasToken")
		}
		sasToken := sasTokenSecret
		result.SasToken = &sasToken
	}

	// Set property "ServicePrincipal":
	if definition.ServicePrincipal != nil {
		servicePrincipal_ARM, err := (*definition.ServicePrincipal).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		servicePrincipal := *servicePrincipal_ARM.(*arm.ServicePrincipalDefinition)
		result.ServicePrincipal = &servicePrincipal
	}

	// Set property "SyncIntervalInSeconds":
	if definition.SyncIntervalInSeconds != nil {
		syncIntervalInSeconds := *definition.SyncIntervalInSeconds
		result.SyncIntervalInSeconds = &syncIntervalInSeconds
	}

	// Set property "TimeoutInSeconds":
	if definition.TimeoutInSeconds != nil {
		timeoutInSeconds := *definition.TimeoutInSeconds
		result.TimeoutInSeconds = &timeoutInSeconds
	}

	// Set property "Url":
	if definition.Url != nil {
		url := *definition.Url
		result.Url = &url
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (definition *AzureBlobDefinition) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AzureBlobDefinition{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (definition *AzureBlobDefinition) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AzureBlobDefinition)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AzureBlobDefinition, got %T", armInput)
	}

	// no assignment for property "AccountKey"

	// Set property "ContainerName":
	if typedInput.ContainerName != nil {
		containerName := *typedInput.ContainerName
		definition.ContainerName = &containerName
	}

	// Set property "LocalAuthRef":
	if typedInput.LocalAuthRef != nil {
		localAuthRef := *typedInput.LocalAuthRef
		definition.LocalAuthRef = &localAuthRef
	}

	// Set property "ManagedIdentity":
	if typedInput.ManagedIdentity != nil {
		var managedIdentity1 ManagedIdentityDefinition
		err := managedIdentity1.PopulateFromARM(owner, *typedInput.ManagedIdentity)
		if err != nil {
			return err
		}
		managedIdentity := managedIdentity1
		definition.ManagedIdentity = &managedIdentity
	}

	// no assignment for property "SasToken"

	// Set property "ServicePrincipal":
	if typedInput.ServicePrincipal != nil {
		var servicePrincipal1 ServicePrincipalDefinition
		err := servicePrincipal1.PopulateFromARM(owner, *typedInput.ServicePrincipal)
		if err != nil {
			return err
		}
		servicePrincipal := servicePrincipal1
		definition.ServicePrincipal = &servicePrincipal
	}

	// Set property "SyncIntervalInSeconds":
	if typedInput.SyncIntervalInSeconds != nil {
		syncIntervalInSeconds := *typedInput.SyncIntervalInSeconds
		definition.SyncIntervalInSeconds = &syncIntervalInSeconds
	}

	// Set property "TimeoutInSeconds":
	if typedInput.TimeoutInSeconds != nil {
		timeoutInSeconds := *typedInput.TimeoutInSeconds
		definition.TimeoutInSeconds = &timeoutInSeconds
	}

	// Set property "Url":
	if typedInput.Url != nil {
		url := *typedInput.Url
		definition.Url = &url
	}

	// No error
	return nil
}

// AssignProperties_From_AzureBlobDefinition populates our AzureBlobDefinition from the provided source AzureBlobDefinition
func (definition *AzureBlobDefinition) AssignProperties_From_AzureBlobDefinition(source *storage.AzureBlobDefinition) error {

	// AccountKey
	if source.AccountKey != nil {
		accountKey := source.AccountKey.Copy()
		definition.AccountKey = &accountKey
	} else {
		definition.AccountKey = nil
	}

	// ContainerName
	definition.ContainerName = genruntime.ClonePointerToString(source.ContainerName)

	// LocalAuthRef
	definition.LocalAuthRef = genruntime.ClonePointerToString(source.LocalAuthRef)

	// ManagedIdentity
	if source.ManagedIdentity != nil {
		var managedIdentity ManagedIdentityDefinition
		err := managedIdentity.AssignProperties_From_ManagedIdentityDefinition(source.ManagedIdentity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedIdentityDefinition() to populate field ManagedIdentity")
		}
		definition.ManagedIdentity = &managedIdentity
	} else {
		definition.ManagedIdentity = nil
	}

	// SasToken
	if source.SasToken != nil {
		sasToken := source.SasToken.Copy()
		definition.SasToken = &sasToken
	} else {
		definition.SasToken = nil
	}

	// ServicePrincipal
	if source.ServicePrincipal != nil {
		var servicePrincipal ServicePrincipalDefinition
		err := servicePrincipal.AssignProperties_From_ServicePrincipalDefinition(source.ServicePrincipal)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ServicePrincipalDefinition() to populate field ServicePrincipal")
		}
		definition.ServicePrincipal = &servicePrincipal
	} else {
		definition.ServicePrincipal = nil
	}

	// SyncIntervalInSeconds
	definition.SyncIntervalInSeconds = genruntime.ClonePointerToInt(source.SyncIntervalInSeconds)

	// TimeoutInSeconds
	definition.TimeoutInSeconds = genruntime.ClonePointerToInt(source.TimeoutInSeconds)

	// Url
	definition.Url = genruntime.ClonePointerToString(source.Url)

	// No error
	return nil
}

// AssignProperties_To_AzureBlobDefinition populates the provided destination AzureBlobDefinition from our AzureBlobDefinition
func (definition *AzureBlobDefinition) AssignProperties_To_AzureBlobDefinition(destination *storage.AzureBlobDefinition) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AccountKey
	if definition.AccountKey != nil {
		accountKey := definition.AccountKey.Copy()
		destination.AccountKey = &accountKey
	} else {
		destination.AccountKey = nil
	}

	// ContainerName
	destination.ContainerName = genruntime.ClonePointerToString(definition.ContainerName)

	// LocalAuthRef
	destination.LocalAuthRef = genruntime.ClonePointerToString(definition.LocalAuthRef)

	// ManagedIdentity
	if definition.ManagedIdentity != nil {
		var managedIdentity storage.ManagedIdentityDefinition
		err := definition.ManagedIdentity.AssignProperties_To_ManagedIdentityDefinition(&managedIdentity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedIdentityDefinition() to populate field ManagedIdentity")
		}
		destination.ManagedIdentity = &managedIdentity
	} else {
		destination.ManagedIdentity = nil
	}

	// SasToken
	if definition.SasToken != nil {
		sasToken := definition.SasToken.Copy()
		destination.SasToken = &sasToken
	} else {
		destination.SasToken = nil
	}

	// ServicePrincipal
	if definition.ServicePrincipal != nil {
		var servicePrincipal storage.ServicePrincipalDefinition
		err := definition.ServicePrincipal.AssignProperties_To_ServicePrincipalDefinition(&servicePrincipal)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ServicePrincipalDefinition() to populate field ServicePrincipal")
		}
		destination.ServicePrincipal = &servicePrincipal
	} else {
		destination.ServicePrincipal = nil
	}

	// SyncIntervalInSeconds
	destination.SyncIntervalInSeconds = genruntime.ClonePointerToInt(definition.SyncIntervalInSeconds)

	// TimeoutInSeconds
	destination.TimeoutInSeconds = genruntime.ClonePointerToInt(definition.TimeoutInSeconds)

	// Url
	destination.Url = genruntime.ClonePointerToString(definition.Url)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_AzureBlobDefinition_STATUS populates our AzureBlobDefinition from the provided source AzureBlobDefinition_STATUS
func (definition *AzureBlobDefinition) Initialize_From_AzureBlobDefinition_STATUS(source *AzureBlobDefinition_STATUS) error {

	// ContainerName
	definition.ContainerName = genruntime.ClonePointerToString(source.ContainerName)

	// LocalAuthRef
	definition.LocalAuthRef = genruntime.ClonePointerToString(source.LocalAuthRef)

	// ManagedIdentity
	if source.ManagedIdentity != nil {
		var managedIdentity ManagedIdentityDefinition
		err := managedIdentity.Initialize_From_ManagedIdentityDefinition_STATUS(source.ManagedIdentity)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_ManagedIdentityDefinition_STATUS() to populate field ManagedIdentity")
		}
		definition.ManagedIdentity = &managedIdentity
	} else {
		definition.ManagedIdentity = nil
	}

	// ServicePrincipal
	if source.ServicePrincipal != nil {
		var servicePrincipal ServicePrincipalDefinition
		err := servicePrincipal.Initialize_From_ServicePrincipalDefinition_STATUS(source.ServicePrincipal)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_ServicePrincipalDefinition_STATUS() to populate field ServicePrincipal")
		}
		definition.ServicePrincipal = &servicePrincipal
	} else {
		definition.ServicePrincipal = nil
	}

	// SyncIntervalInSeconds
	definition.SyncIntervalInSeconds = genruntime.ClonePointerToInt(source.SyncIntervalInSeconds)

	// TimeoutInSeconds
	definition.TimeoutInSeconds = genruntime.ClonePointerToInt(source.TimeoutInSeconds)

	// Url
	definition.Url = genruntime.ClonePointerToString(source.Url)

	// No error
	return nil
}

// Parameters to reconcile to the AzureBlob source kind type.
type AzureBlobDefinition_STATUS struct {
	// ContainerName: The Azure Blob container name to sync from the url endpoint for the flux configuration.
	ContainerName *string `json:"containerName,omitempty"`

	// LocalAuthRef: Name of a local secret on the Kubernetes cluster to use as the authentication secret rather than the
	// managed or user-provided configuration secrets.
	LocalAuthRef *string `json:"localAuthRef,omitempty"`

	// ManagedIdentity: Parameters to authenticate using a Managed Identity.
	ManagedIdentity *ManagedIdentityDefinition_STATUS `json:"managedIdentity,omitempty"`

	// ServicePrincipal: Parameters to authenticate using Service Principal.
	ServicePrincipal *ServicePrincipalDefinition_STATUS `json:"servicePrincipal,omitempty"`

	// SyncIntervalInSeconds: The interval at which to re-reconcile the cluster Azure Blob source with the remote.
	SyncIntervalInSeconds *int `json:"syncIntervalInSeconds,omitempty"`

	// TimeoutInSeconds: The maximum time to attempt to reconcile the cluster Azure Blob source with the remote.
	TimeoutInSeconds *int `json:"timeoutInSeconds,omitempty"`

	// Url: The URL to sync for the flux configuration Azure Blob storage account.
	Url *string `json:"url,omitempty"`
}

var _ genruntime.FromARMConverter = &AzureBlobDefinition_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (definition *AzureBlobDefinition_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AzureBlobDefinition_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (definition *AzureBlobDefinition_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AzureBlobDefinition_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AzureBlobDefinition_STATUS, got %T", armInput)
	}

	// Set property "ContainerName":
	if typedInput.ContainerName != nil {
		containerName := *typedInput.ContainerName
		definition.ContainerName = &containerName
	}

	// Set property "LocalAuthRef":
	if typedInput.LocalAuthRef != nil {
		localAuthRef := *typedInput.LocalAuthRef
		definition.LocalAuthRef = &localAuthRef
	}

	// Set property "ManagedIdentity":
	if typedInput.ManagedIdentity != nil {
		var managedIdentity1 ManagedIdentityDefinition_STATUS
		err := managedIdentity1.PopulateFromARM(owner, *typedInput.ManagedIdentity)
		if err != nil {
			return err
		}
		managedIdentity := managedIdentity1
		definition.ManagedIdentity = &managedIdentity
	}

	// Set property "ServicePrincipal":
	if typedInput.ServicePrincipal != nil {
		var servicePrincipal1 ServicePrincipalDefinition_STATUS
		err := servicePrincipal1.PopulateFromARM(owner, *typedInput.ServicePrincipal)
		if err != nil {
			return err
		}
		servicePrincipal := servicePrincipal1
		definition.ServicePrincipal = &servicePrincipal
	}

	// Set property "SyncIntervalInSeconds":
	if typedInput.SyncIntervalInSeconds != nil {
		syncIntervalInSeconds := *typedInput.SyncIntervalInSeconds
		definition.SyncIntervalInSeconds = &syncIntervalInSeconds
	}

	// Set property "TimeoutInSeconds":
	if typedInput.TimeoutInSeconds != nil {
		timeoutInSeconds := *typedInput.TimeoutInSeconds
		definition.TimeoutInSeconds = &timeoutInSeconds
	}

	// Set property "Url":
	if typedInput.Url != nil {
		url := *typedInput.Url
		definition.Url = &url
	}

	// No error
	return nil
}

// AssignProperties_From_AzureBlobDefinition_STATUS populates our AzureBlobDefinition_STATUS from the provided source AzureBlobDefinition_STATUS
func (definition *AzureBlobDefinition_STATUS) AssignProperties_From_AzureBlobDefinition_STATUS(source *storage.AzureBlobDefinition_STATUS) error {

	// ContainerName
	definition.ContainerName = genruntime.ClonePointerToString(source.ContainerName)

	// LocalAuthRef
	definition.LocalAuthRef = genruntime.ClonePointerToString(source.LocalAuthRef)

	// ManagedIdentity
	if source.ManagedIdentity != nil {
		var managedIdentity ManagedIdentityDefinition_STATUS
		err := managedIdentity.AssignProperties_From_ManagedIdentityDefinition_STATUS(source.ManagedIdentity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedIdentityDefinition_STATUS() to populate field ManagedIdentity")
		}
		definition.ManagedIdentity = &managedIdentity
	} else {
		definition.ManagedIdentity = nil
	}

	// ServicePrincipal
	if source.ServicePrincipal != nil {
		var servicePrincipal ServicePrincipalDefinition_STATUS
		err := servicePrincipal.AssignProperties_From_ServicePrincipalDefinition_STATUS(source.ServicePrincipal)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ServicePrincipalDefinition_STATUS() to populate field ServicePrincipal")
		}
		definition.ServicePrincipal = &servicePrincipal
	} else {
		definition.ServicePrincipal = nil
	}

	// SyncIntervalInSeconds
	definition.SyncIntervalInSeconds = genruntime.ClonePointerToInt(source.SyncIntervalInSeconds)

	// TimeoutInSeconds
	definition.TimeoutInSeconds = genruntime.ClonePointerToInt(source.TimeoutInSeconds)

	// Url
	definition.Url = genruntime.ClonePointerToString(source.Url)

	// No error
	return nil
}

// AssignProperties_To_AzureBlobDefinition_STATUS populates the provided destination AzureBlobDefinition_STATUS from our AzureBlobDefinition_STATUS
func (definition *AzureBlobDefinition_STATUS) AssignProperties_To_AzureBlobDefinition_STATUS(destination *storage.AzureBlobDefinition_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ContainerName
	destination.ContainerName = genruntime.ClonePointerToString(definition.ContainerName)

	// LocalAuthRef
	destination.LocalAuthRef = genruntime.ClonePointerToString(definition.LocalAuthRef)

	// ManagedIdentity
	if definition.ManagedIdentity != nil {
		var managedIdentity storage.ManagedIdentityDefinition_STATUS
		err := definition.ManagedIdentity.AssignProperties_To_ManagedIdentityDefinition_STATUS(&managedIdentity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedIdentityDefinition_STATUS() to populate field ManagedIdentity")
		}
		destination.ManagedIdentity = &managedIdentity
	} else {
		destination.ManagedIdentity = nil
	}

	// ServicePrincipal
	if definition.ServicePrincipal != nil {
		var servicePrincipal storage.ServicePrincipalDefinition_STATUS
		err := definition.ServicePrincipal.AssignProperties_To_ServicePrincipalDefinition_STATUS(&servicePrincipal)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ServicePrincipalDefinition_STATUS() to populate field ServicePrincipal")
		}
		destination.ServicePrincipal = &servicePrincipal
	} else {
		destination.ServicePrincipal = nil
	}

	// SyncIntervalInSeconds
	destination.SyncIntervalInSeconds = genruntime.ClonePointerToInt(definition.SyncIntervalInSeconds)

	// TimeoutInSeconds
	destination.TimeoutInSeconds = genruntime.ClonePointerToInt(definition.TimeoutInSeconds)

	// Url
	destination.Url = genruntime.ClonePointerToString(definition.Url)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Parameters to reconcile to the Bucket source kind type.
type BucketDefinition struct {
	// AccessKey: Plaintext access key used to securely access the S3 bucket
	AccessKey *genruntime.SecretReference `json:"accessKey,omitempty"`

	// BucketName: The bucket name to sync from the url endpoint for the flux configuration.
	BucketName *string `json:"bucketName,omitempty"`

	// Insecure: Specify whether to use insecure communication when puling data from the S3 bucket.
	Insecure *bool `json:"insecure,omitempty"`

	// LocalAuthRef: Name of a local secret on the Kubernetes cluster to use as the authentication secret rather than the
	// managed or user-provided configuration secrets.
	LocalAuthRef *string `json:"localAuthRef,omitempty"`

	// SyncIntervalInSeconds: The interval at which to re-reconcile the cluster bucket source with the remote.
	SyncIntervalInSeconds *int `json:"syncIntervalInSeconds,omitempty"`

	// TimeoutInSeconds: The maximum time to attempt to reconcile the cluster bucket source with the remote.
	TimeoutInSeconds *int `json:"timeoutInSeconds,omitempty"`

	// Url: The URL to sync for the flux configuration S3 bucket.
	Url *string `json:"url,omitempty"`
}

var _ genruntime.ARMTransformer = &BucketDefinition{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (definition *BucketDefinition) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if definition == nil {
		return nil, nil
	}
	result := &arm.BucketDefinition{}

	// Set property "AccessKey":
	if definition.AccessKey != nil {
		accessKeySecret, err := resolved.ResolvedSecrets.Lookup(*definition.AccessKey)
		if err != nil {
			return nil, errors.Wrap(err, "looking up secret for property AccessKey")
		}
		accessKey := accessKeySecret
		result.AccessKey = &accessKey
	}

	// Set property "BucketName":
	if definition.BucketName != nil {
		bucketName := *definition.BucketName
		result.BucketName = &bucketName
	}

	// Set property "Insecure":
	if definition.Insecure != nil {
		insecure := *definition.Insecure
		result.Insecure = &insecure
	}

	// Set property "LocalAuthRef":
	if definition.LocalAuthRef != nil {
		localAuthRef := *definition.LocalAuthRef
		result.LocalAuthRef = &localAuthRef
	}

	// Set property "SyncIntervalInSeconds":
	if definition.SyncIntervalInSeconds != nil {
		syncIntervalInSeconds := *definition.SyncIntervalInSeconds
		result.SyncIntervalInSeconds = &syncIntervalInSeconds
	}

	// Set property "TimeoutInSeconds":
	if definition.TimeoutInSeconds != nil {
		timeoutInSeconds := *definition.TimeoutInSeconds
		result.TimeoutInSeconds = &timeoutInSeconds
	}

	// Set property "Url":
	if definition.Url != nil {
		url := *definition.Url
		result.Url = &url
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (definition *BucketDefinition) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.BucketDefinition{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (definition *BucketDefinition) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.BucketDefinition)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.BucketDefinition, got %T", armInput)
	}

	// no assignment for property "AccessKey"

	// Set property "BucketName":
	if typedInput.BucketName != nil {
		bucketName := *typedInput.BucketName
		definition.BucketName = &bucketName
	}

	// Set property "Insecure":
	if typedInput.Insecure != nil {
		insecure := *typedInput.Insecure
		definition.Insecure = &insecure
	}

	// Set property "LocalAuthRef":
	if typedInput.LocalAuthRef != nil {
		localAuthRef := *typedInput.LocalAuthRef
		definition.LocalAuthRef = &localAuthRef
	}

	// Set property "SyncIntervalInSeconds":
	if typedInput.SyncIntervalInSeconds != nil {
		syncIntervalInSeconds := *typedInput.SyncIntervalInSeconds
		definition.SyncIntervalInSeconds = &syncIntervalInSeconds
	}

	// Set property "TimeoutInSeconds":
	if typedInput.TimeoutInSeconds != nil {
		timeoutInSeconds := *typedInput.TimeoutInSeconds
		definition.TimeoutInSeconds = &timeoutInSeconds
	}

	// Set property "Url":
	if typedInput.Url != nil {
		url := *typedInput.Url
		definition.Url = &url
	}

	// No error
	return nil
}

// AssignProperties_From_BucketDefinition populates our BucketDefinition from the provided source BucketDefinition
func (definition *BucketDefinition) AssignProperties_From_BucketDefinition(source *storage.BucketDefinition) error {

	// AccessKey
	if source.AccessKey != nil {
		accessKey := source.AccessKey.Copy()
		definition.AccessKey = &accessKey
	} else {
		definition.AccessKey = nil
	}

	// BucketName
	definition.BucketName = genruntime.ClonePointerToString(source.BucketName)

	// Insecure
	if source.Insecure != nil {
		insecure := *source.Insecure
		definition.Insecure = &insecure
	} else {
		definition.Insecure = nil
	}

	// LocalAuthRef
	definition.LocalAuthRef = genruntime.ClonePointerToString(source.LocalAuthRef)

	// SyncIntervalInSeconds
	definition.SyncIntervalInSeconds = genruntime.ClonePointerToInt(source.SyncIntervalInSeconds)

	// TimeoutInSeconds
	definition.TimeoutInSeconds = genruntime.ClonePointerToInt(source.TimeoutInSeconds)

	// Url
	definition.Url = genruntime.ClonePointerToString(source.Url)

	// No error
	return nil
}

// AssignProperties_To_BucketDefinition populates the provided destination BucketDefinition from our BucketDefinition
func (definition *BucketDefinition) AssignProperties_To_BucketDefinition(destination *storage.BucketDefinition) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AccessKey
	if definition.AccessKey != nil {
		accessKey := definition.AccessKey.Copy()
		destination.AccessKey = &accessKey
	} else {
		destination.AccessKey = nil
	}

	// BucketName
	destination.BucketName = genruntime.ClonePointerToString(definition.BucketName)

	// Insecure
	if definition.Insecure != nil {
		insecure := *definition.Insecure
		destination.Insecure = &insecure
	} else {
		destination.Insecure = nil
	}

	// LocalAuthRef
	destination.LocalAuthRef = genruntime.ClonePointerToString(definition.LocalAuthRef)

	// SyncIntervalInSeconds
	destination.SyncIntervalInSeconds = genruntime.ClonePointerToInt(definition.SyncIntervalInSeconds)

	// TimeoutInSeconds
	destination.TimeoutInSeconds = genruntime.ClonePointerToInt(definition.TimeoutInSeconds)

	// Url
	destination.Url = genruntime.ClonePointerToString(definition.Url)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_BucketDefinition_STATUS populates our BucketDefinition from the provided source BucketDefinition_STATUS
func (definition *BucketDefinition) Initialize_From_BucketDefinition_STATUS(source *BucketDefinition_STATUS) error {

	// BucketName
	definition.BucketName = genruntime.ClonePointerToString(source.BucketName)

	// Insecure
	if source.Insecure != nil {
		insecure := *source.Insecure
		definition.Insecure = &insecure
	} else {
		definition.Insecure = nil
	}

	// LocalAuthRef
	definition.LocalAuthRef = genruntime.ClonePointerToString(source.LocalAuthRef)

	// SyncIntervalInSeconds
	definition.SyncIntervalInSeconds = genruntime.ClonePointerToInt(source.SyncIntervalInSeconds)

	// TimeoutInSeconds
	definition.TimeoutInSeconds = genruntime.ClonePointerToInt(source.TimeoutInSeconds)

	// Url
	definition.Url = genruntime.ClonePointerToString(source.Url)

	// No error
	return nil
}

// Parameters to reconcile to the Bucket source kind type.
type BucketDefinition_STATUS struct {
	// BucketName: The bucket name to sync from the url endpoint for the flux configuration.
	BucketName *string `json:"bucketName,omitempty"`

	// Insecure: Specify whether to use insecure communication when puling data from the S3 bucket.
	Insecure *bool `json:"insecure,omitempty"`

	// LocalAuthRef: Name of a local secret on the Kubernetes cluster to use as the authentication secret rather than the
	// managed or user-provided configuration secrets.
	LocalAuthRef *string `json:"localAuthRef,omitempty"`

	// SyncIntervalInSeconds: The interval at which to re-reconcile the cluster bucket source with the remote.
	SyncIntervalInSeconds *int `json:"syncIntervalInSeconds,omitempty"`

	// TimeoutInSeconds: The maximum time to attempt to reconcile the cluster bucket source with the remote.
	TimeoutInSeconds *int `json:"timeoutInSeconds,omitempty"`

	// Url: The URL to sync for the flux configuration S3 bucket.
	Url *string `json:"url,omitempty"`
}

var _ genruntime.FromARMConverter = &BucketDefinition_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (definition *BucketDefinition_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.BucketDefinition_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (definition *BucketDefinition_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.BucketDefinition_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.BucketDefinition_STATUS, got %T", armInput)
	}

	// Set property "BucketName":
	if typedInput.BucketName != nil {
		bucketName := *typedInput.BucketName
		definition.BucketName = &bucketName
	}

	// Set property "Insecure":
	if typedInput.Insecure != nil {
		insecure := *typedInput.Insecure
		definition.Insecure = &insecure
	}

	// Set property "LocalAuthRef":
	if typedInput.LocalAuthRef != nil {
		localAuthRef := *typedInput.LocalAuthRef
		definition.LocalAuthRef = &localAuthRef
	}

	// Set property "SyncIntervalInSeconds":
	if typedInput.SyncIntervalInSeconds != nil {
		syncIntervalInSeconds := *typedInput.SyncIntervalInSeconds
		definition.SyncIntervalInSeconds = &syncIntervalInSeconds
	}

	// Set property "TimeoutInSeconds":
	if typedInput.TimeoutInSeconds != nil {
		timeoutInSeconds := *typedInput.TimeoutInSeconds
		definition.TimeoutInSeconds = &timeoutInSeconds
	}

	// Set property "Url":
	if typedInput.Url != nil {
		url := *typedInput.Url
		definition.Url = &url
	}

	// No error
	return nil
}

// AssignProperties_From_BucketDefinition_STATUS populates our BucketDefinition_STATUS from the provided source BucketDefinition_STATUS
func (definition *BucketDefinition_STATUS) AssignProperties_From_BucketDefinition_STATUS(source *storage.BucketDefinition_STATUS) error {

	// BucketName
	definition.BucketName = genruntime.ClonePointerToString(source.BucketName)

	// Insecure
	if source.Insecure != nil {
		insecure := *source.Insecure
		definition.Insecure = &insecure
	} else {
		definition.Insecure = nil
	}

	// LocalAuthRef
	definition.LocalAuthRef = genruntime.ClonePointerToString(source.LocalAuthRef)

	// SyncIntervalInSeconds
	definition.SyncIntervalInSeconds = genruntime.ClonePointerToInt(source.SyncIntervalInSeconds)

	// TimeoutInSeconds
	definition.TimeoutInSeconds = genruntime.ClonePointerToInt(source.TimeoutInSeconds)

	// Url
	definition.Url = genruntime.ClonePointerToString(source.Url)

	// No error
	return nil
}

// AssignProperties_To_BucketDefinition_STATUS populates the provided destination BucketDefinition_STATUS from our BucketDefinition_STATUS
func (definition *BucketDefinition_STATUS) AssignProperties_To_BucketDefinition_STATUS(destination *storage.BucketDefinition_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BucketName
	destination.BucketName = genruntime.ClonePointerToString(definition.BucketName)

	// Insecure
	if definition.Insecure != nil {
		insecure := *definition.Insecure
		destination.Insecure = &insecure
	} else {
		destination.Insecure = nil
	}

	// LocalAuthRef
	destination.LocalAuthRef = genruntime.ClonePointerToString(definition.LocalAuthRef)

	// SyncIntervalInSeconds
	destination.SyncIntervalInSeconds = genruntime.ClonePointerToInt(definition.SyncIntervalInSeconds)

	// TimeoutInSeconds
	destination.TimeoutInSeconds = genruntime.ClonePointerToInt(definition.TimeoutInSeconds)

	// Url
	destination.Url = genruntime.ClonePointerToString(definition.Url)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Compliance state of the cluster object.
type FluxComplianceStateDefinition_STATUS string

const (
	FluxComplianceStateDefinition_STATUS_Compliant    = FluxComplianceStateDefinition_STATUS("Compliant")
	FluxComplianceStateDefinition_STATUS_NonCompliant = FluxComplianceStateDefinition_STATUS("Non-Compliant")
	FluxComplianceStateDefinition_STATUS_Pending      = FluxComplianceStateDefinition_STATUS("Pending")
	FluxComplianceStateDefinition_STATUS_Suspended    = FluxComplianceStateDefinition_STATUS("Suspended")
	FluxComplianceStateDefinition_STATUS_Unknown      = FluxComplianceStateDefinition_STATUS("Unknown")
)

// Mapping from string to FluxComplianceStateDefinition_STATUS
var fluxComplianceStateDefinition_STATUS_Values = map[string]FluxComplianceStateDefinition_STATUS{
	"compliant":     FluxComplianceStateDefinition_STATUS_Compliant,
	"non-compliant": FluxComplianceStateDefinition_STATUS_NonCompliant,
	"pending":       FluxComplianceStateDefinition_STATUS_Pending,
	"suspended":     FluxComplianceStateDefinition_STATUS_Suspended,
	"unknown":       FluxComplianceStateDefinition_STATUS_Unknown,
}

// Details for configuring operator behavior. Fields in this struct are interpreted by the operator directly rather than being passed to Azure
type FluxConfigurationOperatorSpec struct {
	// ConfigMapExpressions: configures where to place operator written dynamic ConfigMaps (created with CEL expressions).
	ConfigMapExpressions []*core.DestinationExpression `json:"configMapExpressions,omitempty"`

	// SecretExpressions: configures where to place operator written dynamic secrets (created with CEL expressions).
	SecretExpressions []*core.DestinationExpression `json:"secretExpressions,omitempty"`
}

// AssignProperties_From_FluxConfigurationOperatorSpec populates our FluxConfigurationOperatorSpec from the provided source FluxConfigurationOperatorSpec
func (operator *FluxConfigurationOperatorSpec) AssignProperties_From_FluxConfigurationOperatorSpec(source *storage.FluxConfigurationOperatorSpec) error {

	// ConfigMapExpressions
	if source.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(source.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range source.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		operator.ConfigMapExpressions = configMapExpressionList
	} else {
		operator.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if source.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(source.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range source.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		operator.SecretExpressions = secretExpressionList
	} else {
		operator.SecretExpressions = nil
	}

	// No error
	return nil
}

// AssignProperties_To_FluxConfigurationOperatorSpec populates the provided destination FluxConfigurationOperatorSpec from our FluxConfigurationOperatorSpec
func (operator *FluxConfigurationOperatorSpec) AssignProperties_To_FluxConfigurationOperatorSpec(destination *storage.FluxConfigurationOperatorSpec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ConfigMapExpressions
	if operator.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(operator.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range operator.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		destination.ConfigMapExpressions = configMapExpressionList
	} else {
		destination.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if operator.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(operator.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range operator.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		destination.SecretExpressions = secretExpressionList
	} else {
		destination.SecretExpressions = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Parameters to reconcile to the GitRepository source kind type.
type GitRepositoryDefinition struct {
	// HttpsCACert: Base64-encoded HTTPS certificate authority contents used to access git private git repositories over HTTPS
	HttpsCACert *genruntime.SecretReference `json:"httpsCACert,omitempty"`

	// HttpsUser: Plaintext HTTPS username used to access private git repositories over HTTPS
	HttpsUser *string `json:"httpsUser,omitempty"`

	// LocalAuthRef: Name of a local secret on the Kubernetes cluster to use as the authentication secret rather than the
	// managed or user-provided configuration secrets.
	LocalAuthRef *string `json:"localAuthRef,omitempty"`

	// RepositoryRef: The source reference for the GitRepository object.
	RepositoryRef *RepositoryRefDefinition `json:"repositoryRef,omitempty"`

	// SshKnownHosts: Base64-encoded known_hosts value containing public SSH keys required to access private git repositories
	// over SSH
	SshKnownHosts *string `json:"sshKnownHosts,omitempty"`

	// SyncIntervalInSeconds: The interval at which to re-reconcile the cluster git repository source with the remote.
	SyncIntervalInSeconds *int `json:"syncIntervalInSeconds,omitempty"`

	// TimeoutInSeconds: The maximum time to attempt to reconcile the cluster git repository source with the remote.
	TimeoutInSeconds *int `json:"timeoutInSeconds,omitempty"`

	// Url: The URL to sync for the flux configuration git repository.
	Url *string `json:"url,omitempty"`
}

var _ genruntime.ARMTransformer = &GitRepositoryDefinition{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (definition *GitRepositoryDefinition) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if definition == nil {
		return nil, nil
	}
	result := &arm.GitRepositoryDefinition{}

	// Set property "HttpsCACert":
	if definition.HttpsCACert != nil {
		httpsCACertSecret, err := resolved.ResolvedSecrets.Lookup(*definition.HttpsCACert)
		if err != nil {
			return nil, errors.Wrap(err, "looking up secret for property HttpsCACert")
		}
		httpsCACert := httpsCACertSecret
		result.HttpsCACert = &httpsCACert
	}

	// Set property "HttpsUser":
	if definition.HttpsUser != nil {
		httpsUser := *definition.HttpsUser
		result.HttpsUser = &httpsUser
	}

	// Set property "LocalAuthRef":
	if definition.LocalAuthRef != nil {
		localAuthRef := *definition.LocalAuthRef
		result.LocalAuthRef = &localAuthRef
	}

	// Set property "RepositoryRef":
	if definition.RepositoryRef != nil {
		repositoryRef_ARM, err := (*definition.RepositoryRef).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		repositoryRef := *repositoryRef_ARM.(*arm.RepositoryRefDefinition)
		result.RepositoryRef = &repositoryRef
	}

	// Set property "SshKnownHosts":
	if definition.SshKnownHosts != nil {
		sshKnownHosts := *definition.SshKnownHosts
		result.SshKnownHosts = &sshKnownHosts
	}

	// Set property "SyncIntervalInSeconds":
	if definition.SyncIntervalInSeconds != nil {
		syncIntervalInSeconds := *definition.SyncIntervalInSeconds
		result.SyncIntervalInSeconds = &syncIntervalInSeconds
	}

	// Set property "TimeoutInSeconds":
	if definition.TimeoutInSeconds != nil {
		timeoutInSeconds := *definition.TimeoutInSeconds
		result.TimeoutInSeconds = &timeoutInSeconds
	}

	// Set property "Url":
	if definition.Url != nil {
		url := *definition.Url
		result.Url = &url
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (definition *GitRepositoryDefinition) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.GitRepositoryDefinition{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (definition *GitRepositoryDefinition) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.GitRepositoryDefinition)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.GitRepositoryDefinition, got %T", armInput)
	}

	// no assignment for property "HttpsCACert"

	// Set property "HttpsUser":
	if typedInput.HttpsUser != nil {
		httpsUser := *typedInput.HttpsUser
		definition.HttpsUser = &httpsUser
	}

	// Set property "LocalAuthRef":
	if typedInput.LocalAuthRef != nil {
		localAuthRef := *typedInput.LocalAuthRef
		definition.LocalAuthRef = &localAuthRef
	}

	// Set property "RepositoryRef":
	if typedInput.RepositoryRef != nil {
		var repositoryRef1 RepositoryRefDefinition
		err := repositoryRef1.PopulateFromARM(owner, *typedInput.RepositoryRef)
		if err != nil {
			return err
		}
		repositoryRef := repositoryRef1
		definition.RepositoryRef = &repositoryRef
	}

	// Set property "SshKnownHosts":
	if typedInput.SshKnownHosts != nil {
		sshKnownHosts := *typedInput.SshKnownHosts
		definition.SshKnownHosts = &sshKnownHosts
	}

	// Set property "SyncIntervalInSeconds":
	if typedInput.SyncIntervalInSeconds != nil {
		syncIntervalInSeconds := *typedInput.SyncIntervalInSeconds
		definition.SyncIntervalInSeconds = &syncIntervalInSeconds
	}

	// Set property "TimeoutInSeconds":
	if typedInput.TimeoutInSeconds != nil {
		timeoutInSeconds := *typedInput.TimeoutInSeconds
		definition.TimeoutInSeconds = &timeoutInSeconds
	}

	// Set property "Url":
	if typedInput.Url != nil {
		url := *typedInput.Url
		definition.Url = &url
	}

	// No error
	return nil
}

// AssignProperties_From_GitRepositoryDefinition populates our GitRepositoryDefinition from the provided source GitRepositoryDefinition
func (definition *GitRepositoryDefinition) AssignProperties_From_GitRepositoryDefinition(source *storage.GitRepositoryDefinition) error {

	// HttpsCACert
	if source.HttpsCACert != nil {
		httpsCACert := source.HttpsCACert.Copy()
		definition.HttpsCACert = &httpsCACert
	} else {
		definition.HttpsCACert = nil
	}

	// HttpsUser
	definition.HttpsUser = genruntime.ClonePointerToString(source.HttpsUser)

	// LocalAuthRef
	definition.LocalAuthRef = genruntime.ClonePointerToString(source.LocalAuthRef)

	// RepositoryRef
	if source.RepositoryRef != nil {
		var repositoryRef RepositoryRefDefinition
		err := repositoryRef.AssignProperties_From_RepositoryRefDefinition(source.RepositoryRef)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_RepositoryRefDefinition() to populate field RepositoryRef")
		}
		definition.RepositoryRef = &repositoryRef
	} else {
		definition.RepositoryRef = nil
	}

	// SshKnownHosts
	definition.SshKnownHosts = genruntime.ClonePointerToString(source.SshKnownHosts)

	// SyncIntervalInSeconds
	definition.SyncIntervalInSeconds = genruntime.ClonePointerToInt(source.SyncIntervalInSeconds)

	// TimeoutInSeconds
	definition.TimeoutInSeconds = genruntime.ClonePointerToInt(source.TimeoutInSeconds)

	// Url
	definition.Url = genruntime.ClonePointerToString(source.Url)

	// No error
	return nil
}

// AssignProperties_To_GitRepositoryDefinition populates the provided destination GitRepositoryDefinition from our GitRepositoryDefinition
func (definition *GitRepositoryDefinition) AssignProperties_To_GitRepositoryDefinition(destination *storage.GitRepositoryDefinition) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// HttpsCACert
	if definition.HttpsCACert != nil {
		httpsCACert := definition.HttpsCACert.Copy()
		destination.HttpsCACert = &httpsCACert
	} else {
		destination.HttpsCACert = nil
	}

	// HttpsUser
	destination.HttpsUser = genruntime.ClonePointerToString(definition.HttpsUser)

	// LocalAuthRef
	destination.LocalAuthRef = genruntime.ClonePointerToString(definition.LocalAuthRef)

	// RepositoryRef
	if definition.RepositoryRef != nil {
		var repositoryRef storage.RepositoryRefDefinition
		err := definition.RepositoryRef.AssignProperties_To_RepositoryRefDefinition(&repositoryRef)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_RepositoryRefDefinition() to populate field RepositoryRef")
		}
		destination.RepositoryRef = &repositoryRef
	} else {
		destination.RepositoryRef = nil
	}

	// SshKnownHosts
	destination.SshKnownHosts = genruntime.ClonePointerToString(definition.SshKnownHosts)

	// SyncIntervalInSeconds
	destination.SyncIntervalInSeconds = genruntime.ClonePointerToInt(definition.SyncIntervalInSeconds)

	// TimeoutInSeconds
	destination.TimeoutInSeconds = genruntime.ClonePointerToInt(definition.TimeoutInSeconds)

	// Url
	destination.Url = genruntime.ClonePointerToString(definition.Url)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_GitRepositoryDefinition_STATUS populates our GitRepositoryDefinition from the provided source GitRepositoryDefinition_STATUS
func (definition *GitRepositoryDefinition) Initialize_From_GitRepositoryDefinition_STATUS(source *GitRepositoryDefinition_STATUS) error {

	// HttpsUser
	definition.HttpsUser = genruntime.ClonePointerToString(source.HttpsUser)

	// LocalAuthRef
	definition.LocalAuthRef = genruntime.ClonePointerToString(source.LocalAuthRef)

	// RepositoryRef
	if source.RepositoryRef != nil {
		var repositoryRef RepositoryRefDefinition
		err := repositoryRef.Initialize_From_RepositoryRefDefinition_STATUS(source.RepositoryRef)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_RepositoryRefDefinition_STATUS() to populate field RepositoryRef")
		}
		definition.RepositoryRef = &repositoryRef
	} else {
		definition.RepositoryRef = nil
	}

	// SshKnownHosts
	definition.SshKnownHosts = genruntime.ClonePointerToString(source.SshKnownHosts)

	// SyncIntervalInSeconds
	definition.SyncIntervalInSeconds = genruntime.ClonePointerToInt(source.SyncIntervalInSeconds)

	// TimeoutInSeconds
	definition.TimeoutInSeconds = genruntime.ClonePointerToInt(source.TimeoutInSeconds)

	// Url
	definition.Url = genruntime.ClonePointerToString(source.Url)

	// No error
	return nil
}

// Parameters to reconcile to the GitRepository source kind type.
type GitRepositoryDefinition_STATUS struct {
	// HttpsUser: Plaintext HTTPS username used to access private git repositories over HTTPS
	HttpsUser *string `json:"httpsUser,omitempty"`

	// LocalAuthRef: Name of a local secret on the Kubernetes cluster to use as the authentication secret rather than the
	// managed or user-provided configuration secrets.
	LocalAuthRef *string `json:"localAuthRef,omitempty"`

	// RepositoryRef: The source reference for the GitRepository object.
	RepositoryRef *RepositoryRefDefinition_STATUS `json:"repositoryRef,omitempty"`

	// SshKnownHosts: Base64-encoded known_hosts value containing public SSH keys required to access private git repositories
	// over SSH
	SshKnownHosts *string `json:"sshKnownHosts,omitempty"`

	// SyncIntervalInSeconds: The interval at which to re-reconcile the cluster git repository source with the remote.
	SyncIntervalInSeconds *int `json:"syncIntervalInSeconds,omitempty"`

	// TimeoutInSeconds: The maximum time to attempt to reconcile the cluster git repository source with the remote.
	TimeoutInSeconds *int `json:"timeoutInSeconds,omitempty"`

	// Url: The URL to sync for the flux configuration git repository.
	Url *string `json:"url,omitempty"`
}

var _ genruntime.FromARMConverter = &GitRepositoryDefinition_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (definition *GitRepositoryDefinition_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.GitRepositoryDefinition_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (definition *GitRepositoryDefinition_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.GitRepositoryDefinition_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.GitRepositoryDefinition_STATUS, got %T", armInput)
	}

	// Set property "HttpsUser":
	if typedInput.HttpsUser != nil {
		httpsUser := *typedInput.HttpsUser
		definition.HttpsUser = &httpsUser
	}

	// Set property "LocalAuthRef":
	if typedInput.LocalAuthRef != nil {
		localAuthRef := *typedInput.LocalAuthRef
		definition.LocalAuthRef = &localAuthRef
	}

	// Set property "RepositoryRef":
	if typedInput.RepositoryRef != nil {
		var repositoryRef1 RepositoryRefDefinition_STATUS
		err := repositoryRef1.PopulateFromARM(owner, *typedInput.RepositoryRef)
		if err != nil {
			return err
		}
		repositoryRef := repositoryRef1
		definition.RepositoryRef = &repositoryRef
	}

	// Set property "SshKnownHosts":
	if typedInput.SshKnownHosts != nil {
		sshKnownHosts := *typedInput.SshKnownHosts
		definition.SshKnownHosts = &sshKnownHosts
	}

	// Set property "SyncIntervalInSeconds":
	if typedInput.SyncIntervalInSeconds != nil {
		syncIntervalInSeconds := *typedInput.SyncIntervalInSeconds
		definition.SyncIntervalInSeconds = &syncIntervalInSeconds
	}

	// Set property "TimeoutInSeconds":
	if typedInput.TimeoutInSeconds != nil {
		timeoutInSeconds := *typedInput.TimeoutInSeconds
		definition.TimeoutInSeconds = &timeoutInSeconds
	}

	// Set property "Url":
	if typedInput.Url != nil {
		url := *typedInput.Url
		definition.Url = &url
	}

	// No error
	return nil
}

// AssignProperties_From_GitRepositoryDefinition_STATUS populates our GitRepositoryDefinition_STATUS from the provided source GitRepositoryDefinition_STATUS
func (definition *GitRepositoryDefinition_STATUS) AssignProperties_From_GitRepositoryDefinition_STATUS(source *storage.GitRepositoryDefinition_STATUS) error {

	// HttpsUser
	definition.HttpsUser = genruntime.ClonePointerToString(source.HttpsUser)

	// LocalAuthRef
	definition.LocalAuthRef = genruntime.ClonePointerToString(source.LocalAuthRef)

	// RepositoryRef
	if source.RepositoryRef != nil {
		var repositoryRef RepositoryRefDefinition_STATUS
		err := repositoryRef.AssignProperties_From_RepositoryRefDefinition_STATUS(source.RepositoryRef)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_RepositoryRefDefinition_STATUS() to populate field RepositoryRef")
		}
		definition.RepositoryRef = &repositoryRef
	} else {
		definition.RepositoryRef = nil
	}

	// SshKnownHosts
	definition.SshKnownHosts = genruntime.ClonePointerToString(source.SshKnownHosts)

	// SyncIntervalInSeconds
	definition.SyncIntervalInSeconds = genruntime.ClonePointerToInt(source.SyncIntervalInSeconds)

	// TimeoutInSeconds
	definition.TimeoutInSeconds = genruntime.ClonePointerToInt(source.TimeoutInSeconds)

	// Url
	definition.Url = genruntime.ClonePointerToString(source.Url)

	// No error
	return nil
}

// AssignProperties_To_GitRepositoryDefinition_STATUS populates the provided destination GitRepositoryDefinition_STATUS from our GitRepositoryDefinition_STATUS
func (definition *GitRepositoryDefinition_STATUS) AssignProperties_To_GitRepositoryDefinition_STATUS(destination *storage.GitRepositoryDefinition_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// HttpsUser
	destination.HttpsUser = genruntime.ClonePointerToString(definition.HttpsUser)

	// LocalAuthRef
	destination.LocalAuthRef = genruntime.ClonePointerToString(definition.LocalAuthRef)

	// RepositoryRef
	if definition.RepositoryRef != nil {
		var repositoryRef storage.RepositoryRefDefinition_STATUS
		err := definition.RepositoryRef.AssignProperties_To_RepositoryRefDefinition_STATUS(&repositoryRef)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_RepositoryRefDefinition_STATUS() to populate field RepositoryRef")
		}
		destination.RepositoryRef = &repositoryRef
	} else {
		destination.RepositoryRef = nil
	}

	// SshKnownHosts
	destination.SshKnownHosts = genruntime.ClonePointerToString(definition.SshKnownHosts)

	// SyncIntervalInSeconds
	destination.SyncIntervalInSeconds = genruntime.ClonePointerToInt(definition.SyncIntervalInSeconds)

	// TimeoutInSeconds
	destination.TimeoutInSeconds = genruntime.ClonePointerToInt(definition.TimeoutInSeconds)

	// Url
	destination.Url = genruntime.ClonePointerToString(definition.Url)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The Kustomization defining how to reconcile the artifact pulled by the source type on the cluster.
type KustomizationDefinition struct {
	// DependsOn: Specifies other Kustomizations that this Kustomization depends on. This Kustomization will not reconcile
	// until all dependencies have completed their reconciliation.
	DependsOn []string `json:"dependsOn,omitempty"`

	// Force: Enable/disable re-creating Kubernetes resources on the cluster when patching fails due to an immutable field
	// change.
	Force *bool `json:"force,omitempty"`

	// Path: The path in the source reference to reconcile on the cluster.
	Path *string `json:"path,omitempty"`

	// PostBuild: Used for variable substitution for this Kustomization after kustomize build.
	PostBuild *PostBuildDefinition `json:"postBuild,omitempty"`

	// Prune: Enable/disable garbage collections of Kubernetes objects created by this Kustomization.
	Prune *bool `json:"prune,omitempty"`

	// RetryIntervalInSeconds: The interval at which to re-reconcile the Kustomization on the cluster in the event of failure
	// on reconciliation.
	RetryIntervalInSeconds *int `json:"retryIntervalInSeconds,omitempty"`

	// SyncIntervalInSeconds: The interval at which to re-reconcile the Kustomization on the cluster.
	SyncIntervalInSeconds *int `json:"syncIntervalInSeconds,omitempty"`

	// TimeoutInSeconds: The maximum time to attempt to reconcile the Kustomization on the cluster.
	TimeoutInSeconds *int `json:"timeoutInSeconds,omitempty"`

	// Wait: Enable/disable health check for all Kubernetes objects created by this Kustomization.
	Wait *bool `json:"wait,omitempty"`
}

var _ genruntime.ARMTransformer = &KustomizationDefinition{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (definition *KustomizationDefinition) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if definition == nil {
		return nil, nil
	}
	result := &arm.KustomizationDefinition{}

	// Set property "DependsOn":
	for _, item := range definition.DependsOn {
		result.DependsOn = append(result.DependsOn, item)
	}

	// Set property "Force":
	if definition.Force != nil {
		force := *definition.Force
		result.Force = &force
	}

	// Set property "Path":
	if definition.Path != nil {
		path := *definition.Path
		result.Path = &path
	}

	// Set property "PostBuild":
	if definition.PostBuild != nil {
		postBuild_ARM, err := (*definition.PostBuild).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		postBuild := *postBuild_ARM.(*arm.PostBuildDefinition)
		result.PostBuild = &postBuild
	}

	// Set property "Prune":
	if definition.Prune != nil {
		prune := *definition.Prune
		result.Prune = &prune
	}

	// Set property "RetryIntervalInSeconds":
	if definition.RetryIntervalInSeconds != nil {
		retryIntervalInSeconds := *definition.RetryIntervalInSeconds
		result.RetryIntervalInSeconds = &retryIntervalInSeconds
	}

	// Set property "SyncIntervalInSeconds":
	if definition.SyncIntervalInSeconds != nil {
		syncIntervalInSeconds := *definition.SyncIntervalInSeconds
		result.SyncIntervalInSeconds = &syncIntervalInSeconds
	}

	// Set property "TimeoutInSeconds":
	if definition.TimeoutInSeconds != nil {
		timeoutInSeconds := *definition.TimeoutInSeconds
		result.TimeoutInSeconds = &timeoutInSeconds
	}

	// Set property "Wait":
	if definition.Wait != nil {
		wait := *definition.Wait
		result.Wait = &wait
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (definition *KustomizationDefinition) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.KustomizationDefinition{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (definition *KustomizationDefinition) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.KustomizationDefinition)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.KustomizationDefinition, got %T", armInput)
	}

	// Set property "DependsOn":
	for _, item := range typedInput.DependsOn {
		definition.DependsOn = append(definition.DependsOn, item)
	}

	// Set property "Force":
	if typedInput.Force != nil {
		force := *typedInput.Force
		definition.Force = &force
	}

	// Set property "Path":
	if typedInput.Path != nil {
		path := *typedInput.Path
		definition.Path = &path
	}

	// Set property "PostBuild":
	if typedInput.PostBuild != nil {
		var postBuild1 PostBuildDefinition
		err := postBuild1.PopulateFromARM(owner, *typedInput.PostBuild)
		if err != nil {
			return err
		}
		postBuild := postBuild1
		definition.PostBuild = &postBuild
	}

	// Set property "Prune":
	if typedInput.Prune != nil {
		prune := *typedInput.Prune
		definition.Prune = &prune
	}

	// Set property "RetryIntervalInSeconds":
	if typedInput.RetryIntervalInSeconds != nil {
		retryIntervalInSeconds := *typedInput.RetryIntervalInSeconds
		definition.RetryIntervalInSeconds = &retryIntervalInSeconds
	}

	// Set property "SyncIntervalInSeconds":
	if typedInput.SyncIntervalInSeconds != nil {
		syncIntervalInSeconds := *typedInput.SyncIntervalInSeconds
		definition.SyncIntervalInSeconds = &syncIntervalInSeconds
	}

	// Set property "TimeoutInSeconds":
	if typedInput.TimeoutInSeconds != nil {
		timeoutInSeconds := *typedInput.TimeoutInSeconds
		definition.TimeoutInSeconds = &timeoutInSeconds
	}

	// Set property "Wait":
	if typedInput.Wait != nil {
		wait := *typedInput.Wait
		definition.Wait = &wait
	}

	// No error
	return nil
}

// AssignProperties_From_KustomizationDefinition populates our KustomizationDefinition from the provided source KustomizationDefinition
func (definition *KustomizationDefinition) AssignProperties_From_KustomizationDefinition(source *storage.KustomizationDefinition) error {

	// DependsOn
	definition.DependsOn = genruntime.CloneSliceOfString(source.DependsOn)

	// Force
	if source.Force != nil {
		force := *source.Force
		definition.Force = &force
	} else {
		definition.Force = nil
	}

	// Path
	definition.Path = genruntime.ClonePointerToString(source.Path)

	// PostBuild
	if source.PostBuild != nil {
		var postBuild PostBuildDefinition
		err := postBuild.AssignProperties_From_PostBuildDefinition(source.PostBuild)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_PostBuildDefinition() to populate field PostBuild")
		}
		definition.PostBuild = &postBuild
	} else {
		definition.PostBuild = nil
	}

	// Prune
	if source.Prune != nil {
		prune := *source.Prune
		definition.Prune = &prune
	} else {
		definition.Prune = nil
	}

	// RetryIntervalInSeconds
	definition.RetryIntervalInSeconds = genruntime.ClonePointerToInt(source.RetryIntervalInSeconds)

	// SyncIntervalInSeconds
	definition.SyncIntervalInSeconds = genruntime.ClonePointerToInt(source.SyncIntervalInSeconds)

	// TimeoutInSeconds
	definition.TimeoutInSeconds = genruntime.ClonePointerToInt(source.TimeoutInSeconds)

	// Wait
	if source.Wait != nil {
		wait := *source.Wait
		definition.Wait = &wait
	} else {
		definition.Wait = nil
	}

	// No error
	return nil
}

// AssignProperties_To_KustomizationDefinition populates the provided destination KustomizationDefinition from our KustomizationDefinition
func (definition *KustomizationDefinition) AssignProperties_To_KustomizationDefinition(destination *storage.KustomizationDefinition) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DependsOn
	destination.DependsOn = genruntime.CloneSliceOfString(definition.DependsOn)

	// Force
	if definition.Force != nil {
		force := *definition.Force
		destination.Force = &force
	} else {
		destination.Force = nil
	}

	// Path
	destination.Path = genruntime.ClonePointerToString(definition.Path)

	// PostBuild
	if definition.PostBuild != nil {
		var postBuild storage.PostBuildDefinition
		err := definition.PostBuild.AssignProperties_To_PostBuildDefinition(&postBuild)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_PostBuildDefinition() to populate field PostBuild")
		}
		destination.PostBuild = &postBuild
	} else {
		destination.PostBuild = nil
	}

	// Prune
	if definition.Prune != nil {
		prune := *definition.Prune
		destination.Prune = &prune
	} else {
		destination.Prune = nil
	}

	// RetryIntervalInSeconds
	destination.RetryIntervalInSeconds = genruntime.ClonePointerToInt(definition.RetryIntervalInSeconds)

	// SyncIntervalInSeconds
	destination.SyncIntervalInSeconds = genruntime.ClonePointerToInt(definition.SyncIntervalInSeconds)

	// TimeoutInSeconds
	destination.TimeoutInSeconds = genruntime.ClonePointerToInt(definition.TimeoutInSeconds)

	// Wait
	if definition.Wait != nil {
		wait := *definition.Wait
		destination.Wait = &wait
	} else {
		destination.Wait = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_KustomizationDefinition_STATUS populates our KustomizationDefinition from the provided source KustomizationDefinition_STATUS
func (definition *KustomizationDefinition) Initialize_From_KustomizationDefinition_STATUS(source *KustomizationDefinition_STATUS) error {

	// DependsOn
	definition.DependsOn = genruntime.CloneSliceOfString(source.DependsOn)

	// Force
	if source.Force != nil {
		force := *source.Force
		definition.Force = &force
	} else {
		definition.Force = nil
	}

	// Path
	definition.Path = genruntime.ClonePointerToString(source.Path)

	// PostBuild
	if source.PostBuild != nil {
		var postBuild PostBuildDefinition
		err := postBuild.Initialize_From_PostBuildDefinition_STATUS(source.PostBuild)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_PostBuildDefinition_STATUS() to populate field PostBuild")
		}
		definition.PostBuild = &postBuild
	} else {
		definition.PostBuild = nil
	}

	// Prune
	if source.Prune != nil {
		prune := *source.Prune
		definition.Prune = &prune
	} else {
		definition.Prune = nil
	}

	// RetryIntervalInSeconds
	definition.RetryIntervalInSeconds = genruntime.ClonePointerToInt(source.RetryIntervalInSeconds)

	// SyncIntervalInSeconds
	definition.SyncIntervalInSeconds = genruntime.ClonePointerToInt(source.SyncIntervalInSeconds)

	// TimeoutInSeconds
	definition.TimeoutInSeconds = genruntime.ClonePointerToInt(source.TimeoutInSeconds)

	// Wait
	if source.Wait != nil {
		wait := *source.Wait
		definition.Wait = &wait
	} else {
		definition.Wait = nil
	}

	// No error
	return nil
}

// The Kustomization defining how to reconcile the artifact pulled by the source type on the cluster.
type KustomizationDefinition_STATUS struct {
	// DependsOn: Specifies other Kustomizations that this Kustomization depends on. This Kustomization will not reconcile
	// until all dependencies have completed their reconciliation.
	DependsOn []string `json:"dependsOn,omitempty"`

	// Force: Enable/disable re-creating Kubernetes resources on the cluster when patching fails due to an immutable field
	// change.
	Force *bool `json:"force,omitempty"`

	// Name: Name of the Kustomization, matching the key in the Kustomizations object map.
	Name *string `json:"name,omitempty"`

	// Path: The path in the source reference to reconcile on the cluster.
	Path *string `json:"path,omitempty"`

	// PostBuild: Used for variable substitution for this Kustomization after kustomize build.
	PostBuild *PostBuildDefinition_STATUS `json:"postBuild,omitempty"`

	// Prune: Enable/disable garbage collections of Kubernetes objects created by this Kustomization.
	Prune *bool `json:"prune,omitempty"`

	// RetryIntervalInSeconds: The interval at which to re-reconcile the Kustomization on the cluster in the event of failure
	// on reconciliation.
	RetryIntervalInSeconds *int `json:"retryIntervalInSeconds,omitempty"`

	// SyncIntervalInSeconds: The interval at which to re-reconcile the Kustomization on the cluster.
	SyncIntervalInSeconds *int `json:"syncIntervalInSeconds,omitempty"`

	// TimeoutInSeconds: The maximum time to attempt to reconcile the Kustomization on the cluster.
	TimeoutInSeconds *int `json:"timeoutInSeconds,omitempty"`

	// Wait: Enable/disable health check for all Kubernetes objects created by this Kustomization.
	Wait *bool `json:"wait,omitempty"`
}

var _ genruntime.FromARMConverter = &KustomizationDefinition_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (definition *KustomizationDefinition_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.KustomizationDefinition_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (definition *KustomizationDefinition_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.KustomizationDefinition_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.KustomizationDefinition_STATUS, got %T", armInput)
	}

	// Set property "DependsOn":
	for _, item := range typedInput.DependsOn {
		definition.DependsOn = append(definition.DependsOn, item)
	}

	// Set property "Force":
	if typedInput.Force != nil {
		force := *typedInput.Force
		definition.Force = &force
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		definition.Name = &name
	}

	// Set property "Path":
	if typedInput.Path != nil {
		path := *typedInput.Path
		definition.Path = &path
	}

	// Set property "PostBuild":
	if typedInput.PostBuild != nil {
		var postBuild1 PostBuildDefinition_STATUS
		err := postBuild1.PopulateFromARM(owner, *typedInput.PostBuild)
		if err != nil {
			return err
		}
		postBuild := postBuild1
		definition.PostBuild = &postBuild
	}

	// Set property "Prune":
	if typedInput.Prune != nil {
		prune := *typedInput.Prune
		definition.Prune = &prune
	}

	// Set property "RetryIntervalInSeconds":
	if typedInput.RetryIntervalInSeconds != nil {
		retryIntervalInSeconds := *typedInput.RetryIntervalInSeconds
		definition.RetryIntervalInSeconds = &retryIntervalInSeconds
	}

	// Set property "SyncIntervalInSeconds":
	if typedInput.SyncIntervalInSeconds != nil {
		syncIntervalInSeconds := *typedInput.SyncIntervalInSeconds
		definition.SyncIntervalInSeconds = &syncIntervalInSeconds
	}

	// Set property "TimeoutInSeconds":
	if typedInput.TimeoutInSeconds != nil {
		timeoutInSeconds := *typedInput.TimeoutInSeconds
		definition.TimeoutInSeconds = &timeoutInSeconds
	}

	// Set property "Wait":
	if typedInput.Wait != nil {
		wait := *typedInput.Wait
		definition.Wait = &wait
	}

	// No error
	return nil
}

// AssignProperties_From_KustomizationDefinition_STATUS populates our KustomizationDefinition_STATUS from the provided source KustomizationDefinition_STATUS
func (definition *KustomizationDefinition_STATUS) AssignProperties_From_KustomizationDefinition_STATUS(source *storage.KustomizationDefinition_STATUS) error {

	// DependsOn
	definition.DependsOn = genruntime.CloneSliceOfString(source.DependsOn)

	// Force
	if source.Force != nil {
		force := *source.Force
		definition.Force = &force
	} else {
		definition.Force = nil
	}

	// Name
	definition.Name = genruntime.ClonePointerToString(source.Name)

	// Path
	definition.Path = genruntime.ClonePointerToString(source.Path)

	// PostBuild
	if source.PostBuild != nil {
		var postBuild PostBuildDefinition_STATUS
		err := postBuild.AssignProperties_From_PostBuildDefinition_STATUS(source.PostBuild)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_PostBuildDefinition_STATUS() to populate field PostBuild")
		}
		definition.PostBuild = &postBuild
	} else {
		definition.PostBuild = nil
	}

	// Prune
	if source.Prune != nil {
		prune := *source.Prune
		definition.Prune = &prune
	} else {
		definition.Prune = nil
	}

	// RetryIntervalInSeconds
	definition.RetryIntervalInSeconds = genruntime.ClonePointerToInt(source.RetryIntervalInSeconds)

	// SyncIntervalInSeconds
	definition.SyncIntervalInSeconds = genruntime.ClonePointerToInt(source.SyncIntervalInSeconds)

	// TimeoutInSeconds
	definition.TimeoutInSeconds = genruntime.ClonePointerToInt(source.TimeoutInSeconds)

	// Wait
	if source.Wait != nil {
		wait := *source.Wait
		definition.Wait = &wait
	} else {
		definition.Wait = nil
	}

	// No error
	return nil
}

// AssignProperties_To_KustomizationDefinition_STATUS populates the provided destination KustomizationDefinition_STATUS from our KustomizationDefinition_STATUS
func (definition *KustomizationDefinition_STATUS) AssignProperties_To_KustomizationDefinition_STATUS(destination *storage.KustomizationDefinition_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DependsOn
	destination.DependsOn = genruntime.CloneSliceOfString(definition.DependsOn)

	// Force
	if definition.Force != nil {
		force := *definition.Force
		destination.Force = &force
	} else {
		destination.Force = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(definition.Name)

	// Path
	destination.Path = genruntime.ClonePointerToString(definition.Path)

	// PostBuild
	if definition.PostBuild != nil {
		var postBuild storage.PostBuildDefinition_STATUS
		err := definition.PostBuild.AssignProperties_To_PostBuildDefinition_STATUS(&postBuild)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_PostBuildDefinition_STATUS() to populate field PostBuild")
		}
		destination.PostBuild = &postBuild
	} else {
		destination.PostBuild = nil
	}

	// Prune
	if definition.Prune != nil {
		prune := *definition.Prune
		destination.Prune = &prune
	} else {
		destination.Prune = nil
	}

	// RetryIntervalInSeconds
	destination.RetryIntervalInSeconds = genruntime.ClonePointerToInt(definition.RetryIntervalInSeconds)

	// SyncIntervalInSeconds
	destination.SyncIntervalInSeconds = genruntime.ClonePointerToInt(definition.SyncIntervalInSeconds)

	// TimeoutInSeconds
	destination.TimeoutInSeconds = genruntime.ClonePointerToInt(definition.TimeoutInSeconds)

	// Wait
	if definition.Wait != nil {
		wait := *definition.Wait
		destination.Wait = &wait
	} else {
		destination.Wait = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Statuses of objects deployed by the user-specified kustomizations from the git repository.
type ObjectStatusDefinition_STATUS struct {
	// AppliedBy: Object reference to the Kustomization that applied this object
	AppliedBy *ObjectReferenceDefinition_STATUS `json:"appliedBy,omitempty"`

	// ComplianceState: Compliance state of the applied object showing whether the applied object has come into a ready state
	// on the cluster.
	ComplianceState *FluxComplianceStateDefinition_STATUS `json:"complianceState,omitempty"`

	// HelmReleaseProperties: Additional properties that are provided from objects of the HelmRelease kind
	HelmReleaseProperties *HelmReleasePropertiesDefinition_STATUS `json:"helmReleaseProperties,omitempty"`

	// Kind: Kind of the applied object
	Kind *string `json:"kind,omitempty"`

	// Name: Name of the applied object
	Name *string `json:"name,omitempty"`

	// Namespace: Namespace of the applied object
	Namespace *string `json:"namespace,omitempty"`

	// StatusConditions: List of Kubernetes object status conditions present on the cluster
	StatusConditions []ObjectStatusConditionDefinition_STATUS `json:"statusConditions,omitempty"`
}

var _ genruntime.FromARMConverter = &ObjectStatusDefinition_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (definition *ObjectStatusDefinition_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ObjectStatusDefinition_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (definition *ObjectStatusDefinition_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ObjectStatusDefinition_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ObjectStatusDefinition_STATUS, got %T", armInput)
	}

	// Set property "AppliedBy":
	if typedInput.AppliedBy != nil {
		var appliedBy1 ObjectReferenceDefinition_STATUS
		err := appliedBy1.PopulateFromARM(owner, *typedInput.AppliedBy)
		if err != nil {
			return err
		}
		appliedBy := appliedBy1
		definition.AppliedBy = &appliedBy
	}

	// Set property "ComplianceState":
	if typedInput.ComplianceState != nil {
		var temp string
		temp = string(*typedInput.ComplianceState)
		complianceState := FluxComplianceStateDefinition_STATUS(temp)
		definition.ComplianceState = &complianceState
	}

	// Set property "HelmReleaseProperties":
	if typedInput.HelmReleaseProperties != nil {
		var helmReleaseProperties1 HelmReleasePropertiesDefinition_STATUS
		err := helmReleaseProperties1.PopulateFromARM(owner, *typedInput.HelmReleaseProperties)
		if err != nil {
			return err
		}
		helmReleaseProperties := helmReleaseProperties1
		definition.HelmReleaseProperties = &helmReleaseProperties
	}

	// Set property "Kind":
	if typedInput.Kind != nil {
		kind := *typedInput.Kind
		definition.Kind = &kind
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		definition.Name = &name
	}

	// Set property "Namespace":
	if typedInput.Namespace != nil {
		namespace := *typedInput.Namespace
		definition.Namespace = &namespace
	}

	// Set property "StatusConditions":
	for _, item := range typedInput.StatusConditions {
		var item1 ObjectStatusConditionDefinition_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		definition.StatusConditions = append(definition.StatusConditions, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_ObjectStatusDefinition_STATUS populates our ObjectStatusDefinition_STATUS from the provided source ObjectStatusDefinition_STATUS
func (definition *ObjectStatusDefinition_STATUS) AssignProperties_From_ObjectStatusDefinition_STATUS(source *storage.ObjectStatusDefinition_STATUS) error {

	// AppliedBy
	if source.AppliedBy != nil {
		var appliedBy ObjectReferenceDefinition_STATUS
		err := appliedBy.AssignProperties_From_ObjectReferenceDefinition_STATUS(source.AppliedBy)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ObjectReferenceDefinition_STATUS() to populate field AppliedBy")
		}
		definition.AppliedBy = &appliedBy
	} else {
		definition.AppliedBy = nil
	}

	// ComplianceState
	if source.ComplianceState != nil {
		complianceState := *source.ComplianceState
		complianceStateTemp := genruntime.ToEnum(complianceState, fluxComplianceStateDefinition_STATUS_Values)
		definition.ComplianceState = &complianceStateTemp
	} else {
		definition.ComplianceState = nil
	}

	// HelmReleaseProperties
	if source.HelmReleaseProperties != nil {
		var helmReleaseProperty HelmReleasePropertiesDefinition_STATUS
		err := helmReleaseProperty.AssignProperties_From_HelmReleasePropertiesDefinition_STATUS(source.HelmReleaseProperties)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_HelmReleasePropertiesDefinition_STATUS() to populate field HelmReleaseProperties")
		}
		definition.HelmReleaseProperties = &helmReleaseProperty
	} else {
		definition.HelmReleaseProperties = nil
	}

	// Kind
	definition.Kind = genruntime.ClonePointerToString(source.Kind)

	// Name
	definition.Name = genruntime.ClonePointerToString(source.Name)

	// Namespace
	definition.Namespace = genruntime.ClonePointerToString(source.Namespace)

	// StatusConditions
	if source.StatusConditions != nil {
		statusConditionList := make([]ObjectStatusConditionDefinition_STATUS, len(source.StatusConditions))
		for statusConditionIndex, statusConditionItem := range source.StatusConditions {
			// Shadow the loop variable to avoid aliasing
			statusConditionItem := statusConditionItem
			var statusCondition ObjectStatusConditionDefinition_STATUS
			err := statusCondition.AssignProperties_From_ObjectStatusConditionDefinition_STATUS(&statusConditionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ObjectStatusConditionDefinition_STATUS() to populate field StatusConditions")
			}
			statusConditionList[statusConditionIndex] = statusCondition
		}
		definition.StatusConditions = statusConditionList
	} else {
		definition.StatusConditions = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ObjectStatusDefinition_STATUS populates the provided destination ObjectStatusDefinition_STATUS from our ObjectStatusDefinition_STATUS
func (definition *ObjectStatusDefinition_STATUS) AssignProperties_To_ObjectStatusDefinition_STATUS(destination *storage.ObjectStatusDefinition_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AppliedBy
	if definition.AppliedBy != nil {
		var appliedBy storage.ObjectReferenceDefinition_STATUS
		err := definition.AppliedBy.AssignProperties_To_ObjectReferenceDefinition_STATUS(&appliedBy)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ObjectReferenceDefinition_STATUS() to populate field AppliedBy")
		}
		destination.AppliedBy = &appliedBy
	} else {
		destination.AppliedBy = nil
	}

	// ComplianceState
	if definition.ComplianceState != nil {
		complianceState := string(*definition.ComplianceState)
		destination.ComplianceState = &complianceState
	} else {
		destination.ComplianceState = nil
	}

	// HelmReleaseProperties
	if definition.HelmReleaseProperties != nil {
		var helmReleaseProperty storage.HelmReleasePropertiesDefinition_STATUS
		err := definition.HelmReleaseProperties.AssignProperties_To_HelmReleasePropertiesDefinition_STATUS(&helmReleaseProperty)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_HelmReleasePropertiesDefinition_STATUS() to populate field HelmReleaseProperties")
		}
		destination.HelmReleaseProperties = &helmReleaseProperty
	} else {
		destination.HelmReleaseProperties = nil
	}

	// Kind
	destination.Kind = genruntime.ClonePointerToString(definition.Kind)

	// Name
	destination.Name = genruntime.ClonePointerToString(definition.Name)

	// Namespace
	destination.Namespace = genruntime.ClonePointerToString(definition.Namespace)

	// StatusConditions
	if definition.StatusConditions != nil {
		statusConditionList := make([]storage.ObjectStatusConditionDefinition_STATUS, len(definition.StatusConditions))
		for statusConditionIndex, statusConditionItem := range definition.StatusConditions {
			// Shadow the loop variable to avoid aliasing
			statusConditionItem := statusConditionItem
			var statusCondition storage.ObjectStatusConditionDefinition_STATUS
			err := statusConditionItem.AssignProperties_To_ObjectStatusConditionDefinition_STATUS(&statusCondition)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ObjectStatusConditionDefinition_STATUS() to populate field StatusConditions")
			}
			statusConditionList[statusConditionIndex] = statusCondition
		}
		destination.StatusConditions = statusConditionList
	} else {
		destination.StatusConditions = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Scope at which the configuration will be installed.
// +kubebuilder:validation:Enum={"cluster","namespace"}
type ScopeDefinition string

const (
	ScopeDefinition_Cluster   = ScopeDefinition("cluster")
	ScopeDefinition_Namespace = ScopeDefinition("namespace")
)

// Mapping from string to ScopeDefinition
var scopeDefinition_Values = map[string]ScopeDefinition{
	"cluster":   ScopeDefinition_Cluster,
	"namespace": ScopeDefinition_Namespace,
}

// Scope at which the configuration will be installed.
type ScopeDefinition_STATUS string

const (
	ScopeDefinition_STATUS_Cluster   = ScopeDefinition_STATUS("cluster")
	ScopeDefinition_STATUS_Namespace = ScopeDefinition_STATUS("namespace")
)

// Mapping from string to ScopeDefinition_STATUS
var scopeDefinition_STATUS_Values = map[string]ScopeDefinition_STATUS{
	"cluster":   ScopeDefinition_STATUS_Cluster,
	"namespace": ScopeDefinition_STATUS_Namespace,
}

// Source Kind to pull the configuration data from.
// +kubebuilder:validation:Enum={"AzureBlob","Bucket","GitRepository"}
type SourceKindDefinition string

const (
	SourceKindDefinition_AzureBlob     = SourceKindDefinition("AzureBlob")
	SourceKindDefinition_Bucket        = SourceKindDefinition("Bucket")
	SourceKindDefinition_GitRepository = SourceKindDefinition("GitRepository")
)

// Mapping from string to SourceKindDefinition
var sourceKindDefinition_Values = map[string]SourceKindDefinition{
	"azureblob":     SourceKindDefinition_AzureBlob,
	"bucket":        SourceKindDefinition_Bucket,
	"gitrepository": SourceKindDefinition_GitRepository,
}

// Source Kind to pull the configuration data from.
type SourceKindDefinition_STATUS string

const (
	SourceKindDefinition_STATUS_AzureBlob     = SourceKindDefinition_STATUS("AzureBlob")
	SourceKindDefinition_STATUS_Bucket        = SourceKindDefinition_STATUS("Bucket")
	SourceKindDefinition_STATUS_GitRepository = SourceKindDefinition_STATUS("GitRepository")
)

// Mapping from string to SourceKindDefinition_STATUS
var sourceKindDefinition_STATUS_Values = map[string]SourceKindDefinition_STATUS{
	"azureblob":     SourceKindDefinition_STATUS_AzureBlob,
	"bucket":        SourceKindDefinition_STATUS_Bucket,
	"gitrepository": SourceKindDefinition_STATUS_GitRepository,
}

// Properties for HelmRelease objects
type HelmReleasePropertiesDefinition_STATUS struct {
	// FailureCount: Total number of times that the HelmRelease failed to install or upgrade
	FailureCount *int `json:"failureCount,omitempty"`

	// HelmChartRef: The reference to the HelmChart object used as the source to this HelmRelease
	HelmChartRef *ObjectReferenceDefinition_STATUS `json:"helmChartRef,omitempty"`

	// InstallFailureCount: Number of times that the HelmRelease failed to install
	InstallFailureCount *int `json:"installFailureCount,omitempty"`

	// LastRevisionApplied: The revision number of the last released object change
	LastRevisionApplied *int `json:"lastRevisionApplied,omitempty"`

	// UpgradeFailureCount: Number of times that the HelmRelease failed to upgrade
	UpgradeFailureCount *int `json:"upgradeFailureCount,omitempty"`
}

var _ genruntime.FromARMConverter = &HelmReleasePropertiesDefinition_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (definition *HelmReleasePropertiesDefinition_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.HelmReleasePropertiesDefinition_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (definition *HelmReleasePropertiesDefinition_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.HelmReleasePropertiesDefinition_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.HelmReleasePropertiesDefinition_STATUS, got %T", armInput)
	}

	// Set property "FailureCount":
	if typedInput.FailureCount != nil {
		failureCount := *typedInput.FailureCount
		definition.FailureCount = &failureCount
	}

	// Set property "HelmChartRef":
	if typedInput.HelmChartRef != nil {
		var helmChartRef1 ObjectReferenceDefinition_STATUS
		err := helmChartRef1.PopulateFromARM(owner, *typedInput.HelmChartRef)
		if err != nil {
			return err
		}
		helmChartRef := helmChartRef1
		definition.HelmChartRef = &helmChartRef
	}

	// Set property "InstallFailureCount":
	if typedInput.InstallFailureCount != nil {
		installFailureCount := *typedInput.InstallFailureCount
		definition.InstallFailureCount = &installFailureCount
	}

	// Set property "LastRevisionApplied":
	if typedInput.LastRevisionApplied != nil {
		lastRevisionApplied := *typedInput.LastRevisionApplied
		definition.LastRevisionApplied = &lastRevisionApplied
	}

	// Set property "UpgradeFailureCount":
	if typedInput.UpgradeFailureCount != nil {
		upgradeFailureCount := *typedInput.UpgradeFailureCount
		definition.UpgradeFailureCount = &upgradeFailureCount
	}

	// No error
	return nil
}

// AssignProperties_From_HelmReleasePropertiesDefinition_STATUS populates our HelmReleasePropertiesDefinition_STATUS from the provided source HelmReleasePropertiesDefinition_STATUS
func (definition *HelmReleasePropertiesDefinition_STATUS) AssignProperties_From_HelmReleasePropertiesDefinition_STATUS(source *storage.HelmReleasePropertiesDefinition_STATUS) error {

	// FailureCount
	definition.FailureCount = genruntime.ClonePointerToInt(source.FailureCount)

	// HelmChartRef
	if source.HelmChartRef != nil {
		var helmChartRef ObjectReferenceDefinition_STATUS
		err := helmChartRef.AssignProperties_From_ObjectReferenceDefinition_STATUS(source.HelmChartRef)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ObjectReferenceDefinition_STATUS() to populate field HelmChartRef")
		}
		definition.HelmChartRef = &helmChartRef
	} else {
		definition.HelmChartRef = nil
	}

	// InstallFailureCount
	definition.InstallFailureCount = genruntime.ClonePointerToInt(source.InstallFailureCount)

	// LastRevisionApplied
	definition.LastRevisionApplied = genruntime.ClonePointerToInt(source.LastRevisionApplied)

	// UpgradeFailureCount
	definition.UpgradeFailureCount = genruntime.ClonePointerToInt(source.UpgradeFailureCount)

	// No error
	return nil
}

// AssignProperties_To_HelmReleasePropertiesDefinition_STATUS populates the provided destination HelmReleasePropertiesDefinition_STATUS from our HelmReleasePropertiesDefinition_STATUS
func (definition *HelmReleasePropertiesDefinition_STATUS) AssignProperties_To_HelmReleasePropertiesDefinition_STATUS(destination *storage.HelmReleasePropertiesDefinition_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// FailureCount
	destination.FailureCount = genruntime.ClonePointerToInt(definition.FailureCount)

	// HelmChartRef
	if definition.HelmChartRef != nil {
		var helmChartRef storage.ObjectReferenceDefinition_STATUS
		err := definition.HelmChartRef.AssignProperties_To_ObjectReferenceDefinition_STATUS(&helmChartRef)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ObjectReferenceDefinition_STATUS() to populate field HelmChartRef")
		}
		destination.HelmChartRef = &helmChartRef
	} else {
		destination.HelmChartRef = nil
	}

	// InstallFailureCount
	destination.InstallFailureCount = genruntime.ClonePointerToInt(definition.InstallFailureCount)

	// LastRevisionApplied
	destination.LastRevisionApplied = genruntime.ClonePointerToInt(definition.LastRevisionApplied)

	// UpgradeFailureCount
	destination.UpgradeFailureCount = genruntime.ClonePointerToInt(definition.UpgradeFailureCount)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Parameters to authenticate using a Managed Identity.
type ManagedIdentityDefinition struct {
	// ClientId: The client Id for authenticating a Managed Identity.
	ClientId *string `json:"clientId,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedIdentityDefinition{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (definition *ManagedIdentityDefinition) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if definition == nil {
		return nil, nil
	}
	result := &arm.ManagedIdentityDefinition{}

	// Set property "ClientId":
	if definition.ClientId != nil {
		clientId := *definition.ClientId
		result.ClientId = &clientId
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (definition *ManagedIdentityDefinition) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedIdentityDefinition{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (definition *ManagedIdentityDefinition) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedIdentityDefinition)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedIdentityDefinition, got %T", armInput)
	}

	// Set property "ClientId":
	if typedInput.ClientId != nil {
		clientId := *typedInput.ClientId
		definition.ClientId = &clientId
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedIdentityDefinition populates our ManagedIdentityDefinition from the provided source ManagedIdentityDefinition
func (definition *ManagedIdentityDefinition) AssignProperties_From_ManagedIdentityDefinition(source *storage.ManagedIdentityDefinition) error {

	// ClientId
	definition.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// No error
	return nil
}

// AssignProperties_To_ManagedIdentityDefinition populates the provided destination ManagedIdentityDefinition from our ManagedIdentityDefinition
func (definition *ManagedIdentityDefinition) AssignProperties_To_ManagedIdentityDefinition(destination *storage.ManagedIdentityDefinition) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(definition.ClientId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ManagedIdentityDefinition_STATUS populates our ManagedIdentityDefinition from the provided source ManagedIdentityDefinition_STATUS
func (definition *ManagedIdentityDefinition) Initialize_From_ManagedIdentityDefinition_STATUS(source *ManagedIdentityDefinition_STATUS) error {

	// ClientId
	definition.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// No error
	return nil
}

// Parameters to authenticate using a Managed Identity.
type ManagedIdentityDefinition_STATUS struct {
	// ClientId: The client Id for authenticating a Managed Identity.
	ClientId *string `json:"clientId,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedIdentityDefinition_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (definition *ManagedIdentityDefinition_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedIdentityDefinition_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (definition *ManagedIdentityDefinition_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedIdentityDefinition_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedIdentityDefinition_STATUS, got %T", armInput)
	}

	// Set property "ClientId":
	if typedInput.ClientId != nil {
		clientId := *typedInput.ClientId
		definition.ClientId = &clientId
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedIdentityDefinition_STATUS populates our ManagedIdentityDefinition_STATUS from the provided source ManagedIdentityDefinition_STATUS
func (definition *ManagedIdentityDefinition_STATUS) AssignProperties_From_ManagedIdentityDefinition_STATUS(source *storage.ManagedIdentityDefinition_STATUS) error {

	// ClientId
	definition.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// No error
	return nil
}

// AssignProperties_To_ManagedIdentityDefinition_STATUS populates the provided destination ManagedIdentityDefinition_STATUS from our ManagedIdentityDefinition_STATUS
func (definition *ManagedIdentityDefinition_STATUS) AssignProperties_To_ManagedIdentityDefinition_STATUS(destination *storage.ManagedIdentityDefinition_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(definition.ClientId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Object reference to a Kubernetes object on a cluster
type ObjectReferenceDefinition_STATUS struct {
	// Name: Name of the object
	Name *string `json:"name,omitempty"`

	// Namespace: Namespace of the object
	Namespace *string `json:"namespace,omitempty"`
}

var _ genruntime.FromARMConverter = &ObjectReferenceDefinition_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (definition *ObjectReferenceDefinition_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ObjectReferenceDefinition_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (definition *ObjectReferenceDefinition_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ObjectReferenceDefinition_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ObjectReferenceDefinition_STATUS, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		definition.Name = &name
	}

	// Set property "Namespace":
	if typedInput.Namespace != nil {
		namespace := *typedInput.Namespace
		definition.Namespace = &namespace
	}

	// No error
	return nil
}

// AssignProperties_From_ObjectReferenceDefinition_STATUS populates our ObjectReferenceDefinition_STATUS from the provided source ObjectReferenceDefinition_STATUS
func (definition *ObjectReferenceDefinition_STATUS) AssignProperties_From_ObjectReferenceDefinition_STATUS(source *storage.ObjectReferenceDefinition_STATUS) error {

	// Name
	definition.Name = genruntime.ClonePointerToString(source.Name)

	// Namespace
	definition.Namespace = genruntime.ClonePointerToString(source.Namespace)

	// No error
	return nil
}

// AssignProperties_To_ObjectReferenceDefinition_STATUS populates the provided destination ObjectReferenceDefinition_STATUS from our ObjectReferenceDefinition_STATUS
func (definition *ObjectReferenceDefinition_STATUS) AssignProperties_To_ObjectReferenceDefinition_STATUS(destination *storage.ObjectReferenceDefinition_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(definition.Name)

	// Namespace
	destination.Namespace = genruntime.ClonePointerToString(definition.Namespace)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Status condition of Kubernetes object
type ObjectStatusConditionDefinition_STATUS struct {
	// LastTransitionTime: Last time this status condition has changed
	LastTransitionTime *string `json:"lastTransitionTime,omitempty"`

	// Message: A more verbose description of the object status condition
	Message *string `json:"message,omitempty"`

	// Reason: Reason for the specified status condition type status
	Reason *string `json:"reason,omitempty"`

	// Status: Status of the Kubernetes object condition type
	Status *string `json:"status,omitempty"`

	// Type: Object status condition type for this object
	Type *string `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &ObjectStatusConditionDefinition_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (definition *ObjectStatusConditionDefinition_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ObjectStatusConditionDefinition_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (definition *ObjectStatusConditionDefinition_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ObjectStatusConditionDefinition_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ObjectStatusConditionDefinition_STATUS, got %T", armInput)
	}

	// Set property "LastTransitionTime":
	if typedInput.LastTransitionTime != nil {
		lastTransitionTime := *typedInput.LastTransitionTime
		definition.LastTransitionTime = &lastTransitionTime
	}

	// Set property "Message":
	if typedInput.Message != nil {
		message := *typedInput.Message
		definition.Message = &message
	}

	// Set property "Reason":
	if typedInput.Reason != nil {
		reason := *typedInput.Reason
		definition.Reason = &reason
	}

	// Set property "Status":
	if typedInput.Status != nil {
		status := *typedInput.Status
		definition.Status = &status
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		definition.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_ObjectStatusConditionDefinition_STATUS populates our ObjectStatusConditionDefinition_STATUS from the provided source ObjectStatusConditionDefinition_STATUS
func (definition *ObjectStatusConditionDefinition_STATUS) AssignProperties_From_ObjectStatusConditionDefinition_STATUS(source *storage.ObjectStatusConditionDefinition_STATUS) error {

	// LastTransitionTime
	definition.LastTransitionTime = genruntime.ClonePointerToString(source.LastTransitionTime)

	// Message
	definition.Message = genruntime.ClonePointerToString(source.Message)

	// Reason
	definition.Reason = genruntime.ClonePointerToString(source.Reason)

	// Status
	definition.Status = genruntime.ClonePointerToString(source.Status)

	// Type
	definition.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignProperties_To_ObjectStatusConditionDefinition_STATUS populates the provided destination ObjectStatusConditionDefinition_STATUS from our ObjectStatusConditionDefinition_STATUS
func (definition *ObjectStatusConditionDefinition_STATUS) AssignProperties_To_ObjectStatusConditionDefinition_STATUS(destination *storage.ObjectStatusConditionDefinition_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// LastTransitionTime
	destination.LastTransitionTime = genruntime.ClonePointerToString(definition.LastTransitionTime)

	// Message
	destination.Message = genruntime.ClonePointerToString(definition.Message)

	// Reason
	destination.Reason = genruntime.ClonePointerToString(definition.Reason)

	// Status
	destination.Status = genruntime.ClonePointerToString(definition.Status)

	// Type
	destination.Type = genruntime.ClonePointerToString(definition.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The postBuild definitions defining variable substitutions for this Kustomization after kustomize build.
type PostBuildDefinition struct {
	// Substitute: Key/value pairs holding the variables to be substituted in this Kustomization.
	Substitute map[string]string `json:"substitute,omitempty"`

	// SubstituteFrom: Array of ConfigMaps/Secrets from which the variables are substituted for this Kustomization.
	SubstituteFrom []SubstituteFromDefinition `json:"substituteFrom,omitempty"`
}

var _ genruntime.ARMTransformer = &PostBuildDefinition{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (definition *PostBuildDefinition) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if definition == nil {
		return nil, nil
	}
	result := &arm.PostBuildDefinition{}

	// Set property "Substitute":
	if definition.Substitute != nil {
		result.Substitute = make(map[string]string, len(definition.Substitute))
		for key, value := range definition.Substitute {
			result.Substitute[key] = value
		}
	}

	// Set property "SubstituteFrom":
	for _, item := range definition.SubstituteFrom {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.SubstituteFrom = append(result.SubstituteFrom, *item_ARM.(*arm.SubstituteFromDefinition))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (definition *PostBuildDefinition) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.PostBuildDefinition{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (definition *PostBuildDefinition) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.PostBuildDefinition)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.PostBuildDefinition, got %T", armInput)
	}

	// Set property "Substitute":
	if typedInput.Substitute != nil {
		definition.Substitute = make(map[string]string, len(typedInput.Substitute))
		for key, value := range typedInput.Substitute {
			definition.Substitute[key] = value
		}
	}

	// Set property "SubstituteFrom":
	for _, item := range typedInput.SubstituteFrom {
		var item1 SubstituteFromDefinition
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		definition.SubstituteFrom = append(definition.SubstituteFrom, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_PostBuildDefinition populates our PostBuildDefinition from the provided source PostBuildDefinition
func (definition *PostBuildDefinition) AssignProperties_From_PostBuildDefinition(source *storage.PostBuildDefinition) error {

	// Substitute
	definition.Substitute = genruntime.CloneMapOfStringToString(source.Substitute)

	// SubstituteFrom
	if source.SubstituteFrom != nil {
		substituteFromList := make([]SubstituteFromDefinition, len(source.SubstituteFrom))
		for substituteFromIndex, substituteFromItem := range source.SubstituteFrom {
			// Shadow the loop variable to avoid aliasing
			substituteFromItem := substituteFromItem
			var substituteFrom SubstituteFromDefinition
			err := substituteFrom.AssignProperties_From_SubstituteFromDefinition(&substituteFromItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubstituteFromDefinition() to populate field SubstituteFrom")
			}
			substituteFromList[substituteFromIndex] = substituteFrom
		}
		definition.SubstituteFrom = substituteFromList
	} else {
		definition.SubstituteFrom = nil
	}

	// No error
	return nil
}

// AssignProperties_To_PostBuildDefinition populates the provided destination PostBuildDefinition from our PostBuildDefinition
func (definition *PostBuildDefinition) AssignProperties_To_PostBuildDefinition(destination *storage.PostBuildDefinition) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Substitute
	destination.Substitute = genruntime.CloneMapOfStringToString(definition.Substitute)

	// SubstituteFrom
	if definition.SubstituteFrom != nil {
		substituteFromList := make([]storage.SubstituteFromDefinition, len(definition.SubstituteFrom))
		for substituteFromIndex, substituteFromItem := range definition.SubstituteFrom {
			// Shadow the loop variable to avoid aliasing
			substituteFromItem := substituteFromItem
			var substituteFrom storage.SubstituteFromDefinition
			err := substituteFromItem.AssignProperties_To_SubstituteFromDefinition(&substituteFrom)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubstituteFromDefinition() to populate field SubstituteFrom")
			}
			substituteFromList[substituteFromIndex] = substituteFrom
		}
		destination.SubstituteFrom = substituteFromList
	} else {
		destination.SubstituteFrom = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_PostBuildDefinition_STATUS populates our PostBuildDefinition from the provided source PostBuildDefinition_STATUS
func (definition *PostBuildDefinition) Initialize_From_PostBuildDefinition_STATUS(source *PostBuildDefinition_STATUS) error {

	// Substitute
	definition.Substitute = genruntime.CloneMapOfStringToString(source.Substitute)

	// SubstituteFrom
	if source.SubstituteFrom != nil {
		substituteFromList := make([]SubstituteFromDefinition, len(source.SubstituteFrom))
		for substituteFromIndex, substituteFromItem := range source.SubstituteFrom {
			// Shadow the loop variable to avoid aliasing
			substituteFromItem := substituteFromItem
			var substituteFrom SubstituteFromDefinition
			err := substituteFrom.Initialize_From_SubstituteFromDefinition_STATUS(&substituteFromItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_SubstituteFromDefinition_STATUS() to populate field SubstituteFrom")
			}
			substituteFromList[substituteFromIndex] = substituteFrom
		}
		definition.SubstituteFrom = substituteFromList
	} else {
		definition.SubstituteFrom = nil
	}

	// No error
	return nil
}

// The postBuild definitions defining variable substitutions for this Kustomization after kustomize build.
type PostBuildDefinition_STATUS struct {
	// Substitute: Key/value pairs holding the variables to be substituted in this Kustomization.
	Substitute map[string]string `json:"substitute,omitempty"`

	// SubstituteFrom: Array of ConfigMaps/Secrets from which the variables are substituted for this Kustomization.
	SubstituteFrom []SubstituteFromDefinition_STATUS `json:"substituteFrom,omitempty"`
}

var _ genruntime.FromARMConverter = &PostBuildDefinition_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (definition *PostBuildDefinition_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.PostBuildDefinition_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (definition *PostBuildDefinition_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.PostBuildDefinition_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.PostBuildDefinition_STATUS, got %T", armInput)
	}

	// Set property "Substitute":
	if typedInput.Substitute != nil {
		definition.Substitute = make(map[string]string, len(typedInput.Substitute))
		for key, value := range typedInput.Substitute {
			definition.Substitute[key] = value
		}
	}

	// Set property "SubstituteFrom":
	for _, item := range typedInput.SubstituteFrom {
		var item1 SubstituteFromDefinition_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		definition.SubstituteFrom = append(definition.SubstituteFrom, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_PostBuildDefinition_STATUS populates our PostBuildDefinition_STATUS from the provided source PostBuildDefinition_STATUS
func (definition *PostBuildDefinition_STATUS) AssignProperties_From_PostBuildDefinition_STATUS(source *storage.PostBuildDefinition_STATUS) error {

	// Substitute
	definition.Substitute = genruntime.CloneMapOfStringToString(source.Substitute)

	// SubstituteFrom
	if source.SubstituteFrom != nil {
		substituteFromList := make([]SubstituteFromDefinition_STATUS, len(source.SubstituteFrom))
		for substituteFromIndex, substituteFromItem := range source.SubstituteFrom {
			// Shadow the loop variable to avoid aliasing
			substituteFromItem := substituteFromItem
			var substituteFrom SubstituteFromDefinition_STATUS
			err := substituteFrom.AssignProperties_From_SubstituteFromDefinition_STATUS(&substituteFromItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubstituteFromDefinition_STATUS() to populate field SubstituteFrom")
			}
			substituteFromList[substituteFromIndex] = substituteFrom
		}
		definition.SubstituteFrom = substituteFromList
	} else {
		definition.SubstituteFrom = nil
	}

	// No error
	return nil
}

// AssignProperties_To_PostBuildDefinition_STATUS populates the provided destination PostBuildDefinition_STATUS from our PostBuildDefinition_STATUS
func (definition *PostBuildDefinition_STATUS) AssignProperties_To_PostBuildDefinition_STATUS(destination *storage.PostBuildDefinition_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Substitute
	destination.Substitute = genruntime.CloneMapOfStringToString(definition.Substitute)

	// SubstituteFrom
	if definition.SubstituteFrom != nil {
		substituteFromList := make([]storage.SubstituteFromDefinition_STATUS, len(definition.SubstituteFrom))
		for substituteFromIndex, substituteFromItem := range definition.SubstituteFrom {
			// Shadow the loop variable to avoid aliasing
			substituteFromItem := substituteFromItem
			var substituteFrom storage.SubstituteFromDefinition_STATUS
			err := substituteFromItem.AssignProperties_To_SubstituteFromDefinition_STATUS(&substituteFrom)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubstituteFromDefinition_STATUS() to populate field SubstituteFrom")
			}
			substituteFromList[substituteFromIndex] = substituteFrom
		}
		destination.SubstituteFrom = substituteFromList
	} else {
		destination.SubstituteFrom = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The source reference for the GitRepository object.
type RepositoryRefDefinition struct {
	// Branch: The git repository branch name to checkout.
	Branch *string `json:"branch,omitempty"`

	// Commit: The commit SHA to checkout. This value must be combined with the branch name to be valid. This takes precedence
	// over semver.
	Commit *string `json:"commit,omitempty"`

	// Semver: The semver range used to match against git repository tags. This takes precedence over tag.
	Semver *string `json:"semver,omitempty"`

	// Tag: The git repository tag name to checkout. This takes precedence over branch.
	Tag *string `json:"tag,omitempty"`
}

var _ genruntime.ARMTransformer = &RepositoryRefDefinition{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (definition *RepositoryRefDefinition) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if definition == nil {
		return nil, nil
	}
	result := &arm.RepositoryRefDefinition{}

	// Set property "Branch":
	if definition.Branch != nil {
		branch := *definition.Branch
		result.Branch = &branch
	}

	// Set property "Commit":
	if definition.Commit != nil {
		commit := *definition.Commit
		result.Commit = &commit
	}

	// Set property "Semver":
	if definition.Semver != nil {
		semver := *definition.Semver
		result.Semver = &semver
	}

	// Set property "Tag":
	if definition.Tag != nil {
		tag := *definition.Tag
		result.Tag = &tag
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (definition *RepositoryRefDefinition) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.RepositoryRefDefinition{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (definition *RepositoryRefDefinition) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.RepositoryRefDefinition)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.RepositoryRefDefinition, got %T", armInput)
	}

	// Set property "Branch":
	if typedInput.Branch != nil {
		branch := *typedInput.Branch
		definition.Branch = &branch
	}

	// Set property "Commit":
	if typedInput.Commit != nil {
		commit := *typedInput.Commit
		definition.Commit = &commit
	}

	// Set property "Semver":
	if typedInput.Semver != nil {
		semver := *typedInput.Semver
		definition.Semver = &semver
	}

	// Set property "Tag":
	if typedInput.Tag != nil {
		tag := *typedInput.Tag
		definition.Tag = &tag
	}

	// No error
	return nil
}

// AssignProperties_From_RepositoryRefDefinition populates our RepositoryRefDefinition from the provided source RepositoryRefDefinition
func (definition *RepositoryRefDefinition) AssignProperties_From_RepositoryRefDefinition(source *storage.RepositoryRefDefinition) error {

	// Branch
	definition.Branch = genruntime.ClonePointerToString(source.Branch)

	// Commit
	definition.Commit = genruntime.ClonePointerToString(source.Commit)

	// Semver
	definition.Semver = genruntime.ClonePointerToString(source.Semver)

	// Tag
	definition.Tag = genruntime.ClonePointerToString(source.Tag)

	// No error
	return nil
}

// AssignProperties_To_RepositoryRefDefinition populates the provided destination RepositoryRefDefinition from our RepositoryRefDefinition
func (definition *RepositoryRefDefinition) AssignProperties_To_RepositoryRefDefinition(destination *storage.RepositoryRefDefinition) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Branch
	destination.Branch = genruntime.ClonePointerToString(definition.Branch)

	// Commit
	destination.Commit = genruntime.ClonePointerToString(definition.Commit)

	// Semver
	destination.Semver = genruntime.ClonePointerToString(definition.Semver)

	// Tag
	destination.Tag = genruntime.ClonePointerToString(definition.Tag)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_RepositoryRefDefinition_STATUS populates our RepositoryRefDefinition from the provided source RepositoryRefDefinition_STATUS
func (definition *RepositoryRefDefinition) Initialize_From_RepositoryRefDefinition_STATUS(source *RepositoryRefDefinition_STATUS) error {

	// Branch
	definition.Branch = genruntime.ClonePointerToString(source.Branch)

	// Commit
	definition.Commit = genruntime.ClonePointerToString(source.Commit)

	// Semver
	definition.Semver = genruntime.ClonePointerToString(source.Semver)

	// Tag
	definition.Tag = genruntime.ClonePointerToString(source.Tag)

	// No error
	return nil
}

// The source reference for the GitRepository object.
type RepositoryRefDefinition_STATUS struct {
	// Branch: The git repository branch name to checkout.
	Branch *string `json:"branch,omitempty"`

	// Commit: The commit SHA to checkout. This value must be combined with the branch name to be valid. This takes precedence
	// over semver.
	Commit *string `json:"commit,omitempty"`

	// Semver: The semver range used to match against git repository tags. This takes precedence over tag.
	Semver *string `json:"semver,omitempty"`

	// Tag: The git repository tag name to checkout. This takes precedence over branch.
	Tag *string `json:"tag,omitempty"`
}

var _ genruntime.FromARMConverter = &RepositoryRefDefinition_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (definition *RepositoryRefDefinition_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.RepositoryRefDefinition_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (definition *RepositoryRefDefinition_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.RepositoryRefDefinition_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.RepositoryRefDefinition_STATUS, got %T", armInput)
	}

	// Set property "Branch":
	if typedInput.Branch != nil {
		branch := *typedInput.Branch
		definition.Branch = &branch
	}

	// Set property "Commit":
	if typedInput.Commit != nil {
		commit := *typedInput.Commit
		definition.Commit = &commit
	}

	// Set property "Semver":
	if typedInput.Semver != nil {
		semver := *typedInput.Semver
		definition.Semver = &semver
	}

	// Set property "Tag":
	if typedInput.Tag != nil {
		tag := *typedInput.Tag
		definition.Tag = &tag
	}

	// No error
	return nil
}

// AssignProperties_From_RepositoryRefDefinition_STATUS populates our RepositoryRefDefinition_STATUS from the provided source RepositoryRefDefinition_STATUS
func (definition *RepositoryRefDefinition_STATUS) AssignProperties_From_RepositoryRefDefinition_STATUS(source *storage.RepositoryRefDefinition_STATUS) error {

	// Branch
	definition.Branch = genruntime.ClonePointerToString(source.Branch)

	// Commit
	definition.Commit = genruntime.ClonePointerToString(source.Commit)

	// Semver
	definition.Semver = genruntime.ClonePointerToString(source.Semver)

	// Tag
	definition.Tag = genruntime.ClonePointerToString(source.Tag)

	// No error
	return nil
}

// AssignProperties_To_RepositoryRefDefinition_STATUS populates the provided destination RepositoryRefDefinition_STATUS from our RepositoryRefDefinition_STATUS
func (definition *RepositoryRefDefinition_STATUS) AssignProperties_To_RepositoryRefDefinition_STATUS(destination *storage.RepositoryRefDefinition_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Branch
	destination.Branch = genruntime.ClonePointerToString(definition.Branch)

	// Commit
	destination.Commit = genruntime.ClonePointerToString(definition.Commit)

	// Semver
	destination.Semver = genruntime.ClonePointerToString(definition.Semver)

	// Tag
	destination.Tag = genruntime.ClonePointerToString(definition.Tag)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Parameters to authenticate using Service Principal.
type ServicePrincipalDefinition struct {
	// ClientCertificate: Base64-encoded certificate used to authenticate a Service Principal
	ClientCertificate *genruntime.SecretReference `json:"clientCertificate,omitempty"`

	// ClientCertificatePassword: The password for the certificate used to authenticate a Service Principal
	ClientCertificatePassword *genruntime.SecretReference `json:"clientCertificatePassword,omitempty"`

	// ClientCertificateSendChain: Specifies whether to include x5c header in client claims when acquiring a token to enable
	// subject name / issuer based authentication for the Client Certificate
	ClientCertificateSendChain *bool `json:"clientCertificateSendChain,omitempty"`

	// ClientId: The client Id for authenticating a Service Principal.
	ClientId *string `json:"clientId,omitempty" optionalConfigMapPair:"ClientId"`

	// ClientIdFromConfig: The client Id for authenticating a Service Principal.
	ClientIdFromConfig *genruntime.ConfigMapReference `json:"clientIdFromConfig,omitempty" optionalConfigMapPair:"ClientId"`

	// ClientSecret: The client secret for authenticating a Service Principal
	ClientSecret *genruntime.SecretReference `json:"clientSecret,omitempty"`

	// TenantId: The tenant Id for authenticating a Service Principal
	TenantId *string `json:"tenantId,omitempty" optionalConfigMapPair:"TenantId"`

	// TenantIdFromConfig: The tenant Id for authenticating a Service Principal
	TenantIdFromConfig *genruntime.ConfigMapReference `json:"tenantIdFromConfig,omitempty" optionalConfigMapPair:"TenantId"`
}

var _ genruntime.ARMTransformer = &ServicePrincipalDefinition{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (definition *ServicePrincipalDefinition) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if definition == nil {
		return nil, nil
	}
	result := &arm.ServicePrincipalDefinition{}

	// Set property "ClientCertificate":
	if definition.ClientCertificate != nil {
		clientCertificateSecret, err := resolved.ResolvedSecrets.Lookup(*definition.ClientCertificate)
		if err != nil {
			return nil, errors.Wrap(err, "looking up secret for property ClientCertificate")
		}
		clientCertificate := clientCertificateSecret
		result.ClientCertificate = &clientCertificate
	}

	// Set property "ClientCertificatePassword":
	if definition.ClientCertificatePassword != nil {
		clientCertificatePasswordSecret, err := resolved.ResolvedSecrets.Lookup(*definition.ClientCertificatePassword)
		if err != nil {
			return nil, errors.Wrap(err, "looking up secret for property ClientCertificatePassword")
		}
		clientCertificatePassword := clientCertificatePasswordSecret
		result.ClientCertificatePassword = &clientCertificatePassword
	}

	// Set property "ClientCertificateSendChain":
	if definition.ClientCertificateSendChain != nil {
		clientCertificateSendChain := *definition.ClientCertificateSendChain
		result.ClientCertificateSendChain = &clientCertificateSendChain
	}

	// Set property "ClientId":
	if definition.ClientId != nil {
		clientId := *definition.ClientId
		result.ClientId = &clientId
	}
	if definition.ClientIdFromConfig != nil {
		clientIdValue, err := resolved.ResolvedConfigMaps.Lookup(*definition.ClientIdFromConfig)
		if err != nil {
			return nil, errors.Wrap(err, "looking up configmap for property ClientId")
		}
		clientId := clientIdValue
		result.ClientId = &clientId
	}

	// Set property "ClientSecret":
	if definition.ClientSecret != nil {
		clientSecretSecret, err := resolved.ResolvedSecrets.Lookup(*definition.ClientSecret)
		if err != nil {
			return nil, errors.Wrap(err, "looking up secret for property ClientSecret")
		}
		clientSecret := clientSecretSecret
		result.ClientSecret = &clientSecret
	}

	// Set property "TenantId":
	if definition.TenantId != nil {
		tenantId := *definition.TenantId
		result.TenantId = &tenantId
	}
	if definition.TenantIdFromConfig != nil {
		tenantIdValue, err := resolved.ResolvedConfigMaps.Lookup(*definition.TenantIdFromConfig)
		if err != nil {
			return nil, errors.Wrap(err, "looking up configmap for property TenantId")
		}
		tenantId := tenantIdValue
		result.TenantId = &tenantId
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (definition *ServicePrincipalDefinition) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ServicePrincipalDefinition{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (definition *ServicePrincipalDefinition) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ServicePrincipalDefinition)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ServicePrincipalDefinition, got %T", armInput)
	}

	// no assignment for property "ClientCertificate"

	// no assignment for property "ClientCertificatePassword"

	// Set property "ClientCertificateSendChain":
	if typedInput.ClientCertificateSendChain != nil {
		clientCertificateSendChain := *typedInput.ClientCertificateSendChain
		definition.ClientCertificateSendChain = &clientCertificateSendChain
	}

	// Set property "ClientId":
	if typedInput.ClientId != nil {
		clientId := *typedInput.ClientId
		definition.ClientId = &clientId
	}

	// no assignment for property "ClientIdFromConfig"

	// no assignment for property "ClientSecret"

	// Set property "TenantId":
	if typedInput.TenantId != nil {
		tenantId := *typedInput.TenantId
		definition.TenantId = &tenantId
	}

	// no assignment for property "TenantIdFromConfig"

	// No error
	return nil
}

// AssignProperties_From_ServicePrincipalDefinition populates our ServicePrincipalDefinition from the provided source ServicePrincipalDefinition
func (definition *ServicePrincipalDefinition) AssignProperties_From_ServicePrincipalDefinition(source *storage.ServicePrincipalDefinition) error {

	// ClientCertificate
	if source.ClientCertificate != nil {
		clientCertificate := source.ClientCertificate.Copy()
		definition.ClientCertificate = &clientCertificate
	} else {
		definition.ClientCertificate = nil
	}

	// ClientCertificatePassword
	if source.ClientCertificatePassword != nil {
		clientCertificatePassword := source.ClientCertificatePassword.Copy()
		definition.ClientCertificatePassword = &clientCertificatePassword
	} else {
		definition.ClientCertificatePassword = nil
	}

	// ClientCertificateSendChain
	if source.ClientCertificateSendChain != nil {
		clientCertificateSendChain := *source.ClientCertificateSendChain
		definition.ClientCertificateSendChain = &clientCertificateSendChain
	} else {
		definition.ClientCertificateSendChain = nil
	}

	// ClientId
	definition.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// ClientIdFromConfig
	if source.ClientIdFromConfig != nil {
		clientIdFromConfig := source.ClientIdFromConfig.Copy()
		definition.ClientIdFromConfig = &clientIdFromConfig
	} else {
		definition.ClientIdFromConfig = nil
	}

	// ClientSecret
	if source.ClientSecret != nil {
		clientSecret := source.ClientSecret.Copy()
		definition.ClientSecret = &clientSecret
	} else {
		definition.ClientSecret = nil
	}

	// TenantId
	definition.TenantId = genruntime.ClonePointerToString(source.TenantId)

	// TenantIdFromConfig
	if source.TenantIdFromConfig != nil {
		tenantIdFromConfig := source.TenantIdFromConfig.Copy()
		definition.TenantIdFromConfig = &tenantIdFromConfig
	} else {
		definition.TenantIdFromConfig = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ServicePrincipalDefinition populates the provided destination ServicePrincipalDefinition from our ServicePrincipalDefinition
func (definition *ServicePrincipalDefinition) AssignProperties_To_ServicePrincipalDefinition(destination *storage.ServicePrincipalDefinition) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ClientCertificate
	if definition.ClientCertificate != nil {
		clientCertificate := definition.ClientCertificate.Copy()
		destination.ClientCertificate = &clientCertificate
	} else {
		destination.ClientCertificate = nil
	}

	// ClientCertificatePassword
	if definition.ClientCertificatePassword != nil {
		clientCertificatePassword := definition.ClientCertificatePassword.Copy()
		destination.ClientCertificatePassword = &clientCertificatePassword
	} else {
		destination.ClientCertificatePassword = nil
	}

	// ClientCertificateSendChain
	if definition.ClientCertificateSendChain != nil {
		clientCertificateSendChain := *definition.ClientCertificateSendChain
		destination.ClientCertificateSendChain = &clientCertificateSendChain
	} else {
		destination.ClientCertificateSendChain = nil
	}

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(definition.ClientId)

	// ClientIdFromConfig
	if definition.ClientIdFromConfig != nil {
		clientIdFromConfig := definition.ClientIdFromConfig.Copy()
		destination.ClientIdFromConfig = &clientIdFromConfig
	} else {
		destination.ClientIdFromConfig = nil
	}

	// ClientSecret
	if definition.ClientSecret != nil {
		clientSecret := definition.ClientSecret.Copy()
		destination.ClientSecret = &clientSecret
	} else {
		destination.ClientSecret = nil
	}

	// TenantId
	destination.TenantId = genruntime.ClonePointerToString(definition.TenantId)

	// TenantIdFromConfig
	if definition.TenantIdFromConfig != nil {
		tenantIdFromConfig := definition.TenantIdFromConfig.Copy()
		destination.TenantIdFromConfig = &tenantIdFromConfig
	} else {
		destination.TenantIdFromConfig = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ServicePrincipalDefinition_STATUS populates our ServicePrincipalDefinition from the provided source ServicePrincipalDefinition_STATUS
func (definition *ServicePrincipalDefinition) Initialize_From_ServicePrincipalDefinition_STATUS(source *ServicePrincipalDefinition_STATUS) error {

	// ClientCertificateSendChain
	if source.ClientCertificateSendChain != nil {
		clientCertificateSendChain := *source.ClientCertificateSendChain
		definition.ClientCertificateSendChain = &clientCertificateSendChain
	} else {
		definition.ClientCertificateSendChain = nil
	}

	// ClientId
	definition.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// TenantId
	definition.TenantId = genruntime.ClonePointerToString(source.TenantId)

	// No error
	return nil
}

// Parameters to authenticate using Service Principal.
type ServicePrincipalDefinition_STATUS struct {
	// ClientCertificateSendChain: Specifies whether to include x5c header in client claims when acquiring a token to enable
	// subject name / issuer based authentication for the Client Certificate
	ClientCertificateSendChain *bool `json:"clientCertificateSendChain,omitempty"`

	// ClientId: The client Id for authenticating a Service Principal.
	ClientId *string `json:"clientId,omitempty"`

	// TenantId: The tenant Id for authenticating a Service Principal
	TenantId *string `json:"tenantId,omitempty"`
}

var _ genruntime.FromARMConverter = &ServicePrincipalDefinition_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (definition *ServicePrincipalDefinition_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ServicePrincipalDefinition_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (definition *ServicePrincipalDefinition_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ServicePrincipalDefinition_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ServicePrincipalDefinition_STATUS, got %T", armInput)
	}

	// Set property "ClientCertificateSendChain":
	if typedInput.ClientCertificateSendChain != nil {
		clientCertificateSendChain := *typedInput.ClientCertificateSendChain
		definition.ClientCertificateSendChain = &clientCertificateSendChain
	}

	// Set property "ClientId":
	if typedInput.ClientId != nil {
		clientId := *typedInput.ClientId
		definition.ClientId = &clientId
	}

	// Set property "TenantId":
	if typedInput.TenantId != nil {
		tenantId := *typedInput.TenantId
		definition.TenantId = &tenantId
	}

	// No error
	return nil
}

// AssignProperties_From_ServicePrincipalDefinition_STATUS populates our ServicePrincipalDefinition_STATUS from the provided source ServicePrincipalDefinition_STATUS
func (definition *ServicePrincipalDefinition_STATUS) AssignProperties_From_ServicePrincipalDefinition_STATUS(source *storage.ServicePrincipalDefinition_STATUS) error {

	// ClientCertificateSendChain
	if source.ClientCertificateSendChain != nil {
		clientCertificateSendChain := *source.ClientCertificateSendChain
		definition.ClientCertificateSendChain = &clientCertificateSendChain
	} else {
		definition.ClientCertificateSendChain = nil
	}

	// ClientId
	definition.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// TenantId
	definition.TenantId = genruntime.ClonePointerToString(source.TenantId)

	// No error
	return nil
}

// AssignProperties_To_ServicePrincipalDefinition_STATUS populates the provided destination ServicePrincipalDefinition_STATUS from our ServicePrincipalDefinition_STATUS
func (definition *ServicePrincipalDefinition_STATUS) AssignProperties_To_ServicePrincipalDefinition_STATUS(destination *storage.ServicePrincipalDefinition_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ClientCertificateSendChain
	if definition.ClientCertificateSendChain != nil {
		clientCertificateSendChain := *definition.ClientCertificateSendChain
		destination.ClientCertificateSendChain = &clientCertificateSendChain
	} else {
		destination.ClientCertificateSendChain = nil
	}

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(definition.ClientId)

	// TenantId
	destination.TenantId = genruntime.ClonePointerToString(definition.TenantId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Array of ConfigMaps/Secrets from which the variables are substituted for this Kustomization.
type SubstituteFromDefinition struct {
	// Kind: Define whether it is ConfigMap or Secret that holds the variables to be used in substitution.
	Kind *string `json:"kind,omitempty"`

	// Name: Name of the ConfigMap/Secret that holds the variables to be used in substitution.
	Name *string `json:"name,omitempty"`

	// Optional: Set to True to proceed without ConfigMap/Secret, if it is not present.
	Optional *bool `json:"optional,omitempty"`
}

var _ genruntime.ARMTransformer = &SubstituteFromDefinition{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (definition *SubstituteFromDefinition) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if definition == nil {
		return nil, nil
	}
	result := &arm.SubstituteFromDefinition{}

	// Set property "Kind":
	if definition.Kind != nil {
		kind := *definition.Kind
		result.Kind = &kind
	}

	// Set property "Name":
	if definition.Name != nil {
		name := *definition.Name
		result.Name = &name
	}

	// Set property "Optional":
	if definition.Optional != nil {
		optional := *definition.Optional
		result.Optional = &optional
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (definition *SubstituteFromDefinition) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SubstituteFromDefinition{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (definition *SubstituteFromDefinition) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SubstituteFromDefinition)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SubstituteFromDefinition, got %T", armInput)
	}

	// Set property "Kind":
	if typedInput.Kind != nil {
		kind := *typedInput.Kind
		definition.Kind = &kind
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		definition.Name = &name
	}

	// Set property "Optional":
	if typedInput.Optional != nil {
		optional := *typedInput.Optional
		definition.Optional = &optional
	}

	// No error
	return nil
}

// AssignProperties_From_SubstituteFromDefinition populates our SubstituteFromDefinition from the provided source SubstituteFromDefinition
func (definition *SubstituteFromDefinition) AssignProperties_From_SubstituteFromDefinition(source *storage.SubstituteFromDefinition) error {

	// Kind
	definition.Kind = genruntime.ClonePointerToString(source.Kind)

	// Name
	definition.Name = genruntime.ClonePointerToString(source.Name)

	// Optional
	if source.Optional != nil {
		optional := *source.Optional
		definition.Optional = &optional
	} else {
		definition.Optional = nil
	}

	// No error
	return nil
}

// AssignProperties_To_SubstituteFromDefinition populates the provided destination SubstituteFromDefinition from our SubstituteFromDefinition
func (definition *SubstituteFromDefinition) AssignProperties_To_SubstituteFromDefinition(destination *storage.SubstituteFromDefinition) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Kind
	destination.Kind = genruntime.ClonePointerToString(definition.Kind)

	// Name
	destination.Name = genruntime.ClonePointerToString(definition.Name)

	// Optional
	if definition.Optional != nil {
		optional := *definition.Optional
		destination.Optional = &optional
	} else {
		destination.Optional = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_SubstituteFromDefinition_STATUS populates our SubstituteFromDefinition from the provided source SubstituteFromDefinition_STATUS
func (definition *SubstituteFromDefinition) Initialize_From_SubstituteFromDefinition_STATUS(source *SubstituteFromDefinition_STATUS) error {

	// Kind
	definition.Kind = genruntime.ClonePointerToString(source.Kind)

	// Name
	definition.Name = genruntime.ClonePointerToString(source.Name)

	// Optional
	if source.Optional != nil {
		optional := *source.Optional
		definition.Optional = &optional
	} else {
		definition.Optional = nil
	}

	// No error
	return nil
}

// Array of ConfigMaps/Secrets from which the variables are substituted for this Kustomization.
type SubstituteFromDefinition_STATUS struct {
	// Kind: Define whether it is ConfigMap or Secret that holds the variables to be used in substitution.
	Kind *string `json:"kind,omitempty"`

	// Name: Name of the ConfigMap/Secret that holds the variables to be used in substitution.
	Name *string `json:"name,omitempty"`

	// Optional: Set to True to proceed without ConfigMap/Secret, if it is not present.
	Optional *bool `json:"optional,omitempty"`
}

var _ genruntime.FromARMConverter = &SubstituteFromDefinition_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (definition *SubstituteFromDefinition_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SubstituteFromDefinition_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (definition *SubstituteFromDefinition_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SubstituteFromDefinition_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SubstituteFromDefinition_STATUS, got %T", armInput)
	}

	// Set property "Kind":
	if typedInput.Kind != nil {
		kind := *typedInput.Kind
		definition.Kind = &kind
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		definition.Name = &name
	}

	// Set property "Optional":
	if typedInput.Optional != nil {
		optional := *typedInput.Optional
		definition.Optional = &optional
	}

	// No error
	return nil
}

// AssignProperties_From_SubstituteFromDefinition_STATUS populates our SubstituteFromDefinition_STATUS from the provided source SubstituteFromDefinition_STATUS
func (definition *SubstituteFromDefinition_STATUS) AssignProperties_From_SubstituteFromDefinition_STATUS(source *storage.SubstituteFromDefinition_STATUS) error {

	// Kind
	definition.Kind = genruntime.ClonePointerToString(source.Kind)

	// Name
	definition.Name = genruntime.ClonePointerToString(source.Name)

	// Optional
	if source.Optional != nil {
		optional := *source.Optional
		definition.Optional = &optional
	} else {
		definition.Optional = nil
	}

	// No error
	return nil
}

// AssignProperties_To_SubstituteFromDefinition_STATUS populates the provided destination SubstituteFromDefinition_STATUS from our SubstituteFromDefinition_STATUS
func (definition *SubstituteFromDefinition_STATUS) AssignProperties_To_SubstituteFromDefinition_STATUS(destination *storage.SubstituteFromDefinition_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Kind
	destination.Kind = genruntime.ClonePointerToString(definition.Kind)

	// Name
	destination.Name = genruntime.ClonePointerToString(definition.Name)

	// Optional
	if definition.Optional != nil {
		optional := *definition.Optional
		destination.Optional = &optional
	} else {
		destination.Optional = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

func init() {
	SchemeBuilder.Register(&FluxConfiguration{}, &FluxConfigurationList{})
}
