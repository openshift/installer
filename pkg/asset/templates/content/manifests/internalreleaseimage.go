package manifests

import (
	"context"
	"path/filepath"

	"github.com/pkg/errors"
	"github.com/sirupsen/logrus"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	"sigs.k8s.io/yaml"

	"github.com/openshift/installer/pkg/asset"
)

const (
	internalReleaseImageKind         = "InternalReleaseImage"
	internalReleaseImageInstanceName = "cluster"
	openshiftManifestDir             = "openshift"
)

// InternalReleaseImage simply checks for the presence of the related manifest.
type InternalReleaseImage struct {
	FileList []*asset.File
}

var (
	_ asset.WritableAsset = (*InternalReleaseImage)(nil)
)

// Name returns a human friendly name for the operator.
func (iri *InternalReleaseImage) Name() string {
	return "InternalReleaseImage manifest"
}

// Dependencies returns all of the dependencies required by the asset.
func (iri *InternalReleaseImage) Dependencies() []asset.Asset {
	return []asset.Asset{}
}

// Generate is not required for InternalReleaseImage.
func (iri *InternalReleaseImage) Generate(_ context.Context, dependencies asset.Parents) error {
	return nil
}

// Files returns the files generated by the asset.
func (iri *InternalReleaseImage) Files() []*asset.File {
	return iri.FileList
}

// Load reads the asset files from disk.
func (iri *InternalReleaseImage) Load(f asset.FileFetcher) (found bool, err error) {
	files := []*asset.File{}
	yamlFiles, err := f.FetchByPattern(filepath.Join(openshiftManifestDir, "*.yaml"))
	if err != nil {
		return false, errors.Wrap(err, "failed to load *.yaml files")
	}
	files = append(files, yamlFiles...)

	ymlFileList, err := f.FetchByPattern(filepath.Join(openshiftManifestDir, "*.yml"))
	if err != nil {
		return false, errors.Wrap(err, "failed to load *.yml files")
	}
	files = append(files, ymlFileList...)

	for _, f := range files {
		u := &unstructured.Unstructured{}
		if err := yaml.Unmarshal(f.Data, u); err != nil {
			logrus.Warnf("failed to unmarshal file %s: %v", f.Filename, err)
			continue
		}

		if u.GetKind() == internalReleaseImageKind && u.GetName() == internalReleaseImageInstanceName {
			iri.FileList = append(iri.FileList, f)
			break
		}
	}

	return len(iri.FileList) > 0, nil
}
