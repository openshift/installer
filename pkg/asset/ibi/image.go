package ibi

import (
	"fmt"
	"os"
	"path/filepath"

	"github.com/openshift-kni/lifecycle-agent/ib-cli/installationiso"
	"github.com/openshift-kni/lifecycle-agent/lca-cli/ops"
	"github.com/openshift/installer/pkg/asset"
	"github.com/sirupsen/logrus"
)

const (
	ibiISOFilename = "rhcos-ibi.iso"
)

// ImageBasedInstallImage is an asset that generates the bootable image used to install clusters.
type ImageBasedInstallImage struct {
	seedImage           string
	seedVersion         string
	authFile            string
	pullSecretFile      string
	sshPublicKeyFile    string
	lcaImage            string
	rhcosLiveISO        string
	installationDisk    string
	extraPartitionStart string
	precacheBestEffort  bool
	precacheDisabled    bool

	tmpPath string
}

var _ asset.WritableAsset = (*ImageBasedInstallImage)(nil)

// Dependencies returns the assets on which the Bootstrap asset depends.
func (i *ImageBasedInstallImage) Dependencies() []asset.Asset {
	return []asset.Asset{
		&ImageBasedInstallConfig{},
		&ImageBasedInstallArtifacts{},
	}
}

// Generate generates the image file for the ISO asset.
func (i *ImageBasedInstallImage) Generate(dependencies asset.Parents) error {
	ibiConfig := &ImageBasedInstallConfig{}
	ibiArtifacts := &ImageBasedInstallArtifacts{}
	dependencies.Get(ibiConfig, ibiArtifacts)

	i.seedImage = ibiConfig.Config.SeedImage
	i.seedVersion = ibiConfig.Config.SeedVersion
	i.authFile = ibiConfig.Config.AuthFile
	i.pullSecretFile = ibiConfig.Config.PullSecretFile
	i.sshPublicKeyFile = ibiConfig.Config.SSHPublicKeyFile
	i.lcaImage = ibiConfig.Config.LCAImage
	i.rhcosLiveISO = ibiConfig.Config.RHCOSLiveISO
	i.installationDisk = ibiConfig.Config.InstallationDisk
	i.extraPartitionStart = ibiConfig.Config.ExtraPartitionStart
	i.precacheBestEffort = ibiConfig.Config.PrecacheBestEffort
	i.precacheDisabled = ibiConfig.Config.PrecacheDisabled

	i.tmpPath = ibiArtifacts.TmpPath

	return nil
}

// PersistToFile writes the iso image in the assets folder.
func (i *ImageBasedInstallImage) PersistToFile(directory string) error {
	defer os.RemoveAll(i.tmpPath)

	ibiIsoFile := filepath.Join(directory, ibiISOFilename)

	// Remove symlink if it exists
	os.Remove(ibiIsoFile)

	hostCommandsExecutor := ops.NewRegularExecutor(logrus.StandardLogger(), true)
	op := ops.NewOps(logrus.StandardLogger(), hostCommandsExecutor)

	isoCreator := installationiso.NewInstallationIso(logrus.StandardLogger(), op, i.tmpPath)

	if err := isoCreator.Create(
		i.seedImage,
		i.seedVersion,
		i.authFile,
		i.pullSecretFile,
		i.sshPublicKeyFile,
		i.lcaImage,
		i.rhcosLiveISO,
		i.installationDisk,
		i.extraPartitionStart,
		i.precacheBestEffort,
		i.precacheDisabled); err != nil {
		return fmt.Errorf("failed to create installation ISO: %w", err)
	}
	logrus.Infof("Generated ISO at %s", ibiIsoFile)

	iso, err := os.ReadFile(filepath.Join(i.tmpPath, ibiISOFilename))
	if err != nil {
		return fmt.Errorf("failed to open installation ISO: %w", err)
	}

	err = os.WriteFile(ibiIsoFile, iso, 0o600)
	if err != nil {
		return fmt.Errorf("failed to create %s: %w", ibiIsoFile, err)
	}

	return nil
}

// Files returns the files generated by the asset.
func (i *ImageBasedInstallImage) Files() []*asset.File {
	// Return empty array because File will never be loaded.
	return []*asset.File{}
}

// Load returns the ISO from disk.
func (i *ImageBasedInstallImage) Load(f asset.FileFetcher) (bool, error) {
	// The ISO will not be needed by another asset so load is noop.
	// This is implemented because it is required by WritableAsset
	return false, nil
}

// Name returns the human-friendly name of the asset.
func (i *ImageBasedInstallImage) Name() string {
	return "Image-based Installer ISO"
}
