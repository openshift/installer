package permissions

import (
	"context"
	"encoding/json"
	"fmt"
	"strings"

	"golang.org/x/text/cases"
	"golang.org/x/text/language"
	iamv1 "sigs.k8s.io/cluster-api-provider-aws/v2/iam/api/v1beta1"

	"github.com/openshift/installer/pkg/asset"
	"github.com/openshift/installer/pkg/asset/installconfig"
	awsconfig "github.com/openshift/installer/pkg/asset/installconfig/aws"
	"github.com/openshift/installer/pkg/types"
	"github.com/openshift/installer/pkg/types/aws"
)

const awsPolicyFilename = "aws-permissions-policy-creds.json"

// Permissions has the permissions needed for a given cluster configuration.
type Permissions struct {
	FileList []*asset.File
}

var _ asset.WritableAsset = (*Permissions)(nil)

// Name returns a human friendly name for the asset.
func (o *Permissions) Name() string {
	return "Permissions"
}

// Dependencies returns all of the dependencies directly needed by the Permissions asset.
func (o *Permissions) Dependencies() []asset.Asset {
	return []asset.Asset{
		&installconfig.InstallConfig{},
	}
}

// Generate generates the respective operator config.yml files.
func (o *Permissions) Generate(ctx context.Context, dependencies asset.Parents) error {
	ic := &installconfig.InstallConfig{}
	dependencies.Get(ic)

	o.FileList = []*asset.File{}
	platform := ic.Config.Platform.Name()
	switch platform {
	case aws.Name:
		reqGroups := awsconfig.RequiredPermissionGroups(ic.Config)
		switch ic.Config.CredentialsMode {
		case types.ManualCredentialsMode:
			// Don't include any CCO perms, only the installer ones
		case types.PassthroughCredentialsMode:
			// Include permissions needed by CCO/cluster for passthrough creds mode
			reqGroups = append(reqGroups, awsconfig.PermissionPassthroughCreds)
		default:
			// Include permissions needed by CCO/cluster for mint creds mode
			reqGroups = append(reqGroups, awsconfig.PermissionMintCreds)
		}
		if err := o.writePolicy(reqGroups, awsPolicyFilename); err != nil {
			return fmt.Errorf("failed to generate credentials permissions: %w", err)
		}
	default:
		return fmt.Errorf("platform %q does not support fine-grained permissions", platform)
	}

	return nil
}

func (o *Permissions) writePolicy(groups []awsconfig.PermissionGroup, filename string) error {
	policy := iamv1.PolicyDocument{
		Version:   "2012-10-17",
		Statement: []iamv1.StatementEntry{},
	}

	caser := cases.Title(language.English)
	for _, group := range groups {
		groupPerms, err := awsconfig.Permissions(group)
		if err != nil {
			return err
		}
		// Sid must be alphanumeric
		sid := strings.ReplaceAll(caser.String(string(group)), "-", "")
		policy.Statement = append(policy.Statement, iamv1.StatementEntry{
			Effect:   "Allow",
			Action:   groupPerms,
			Resource: iamv1.Resources{"*"},
			Sid:      sid,
		})
	}

	policyBytes, err := json.Marshal(policy)
	if err != nil {
		return fmt.Errorf("failed to marshal permissions policy: %w", err)
	}

	o.FileList = append(o.FileList, &asset.File{
		Filename: filename,
		Data:     policyBytes,
	})

	return nil
}

// Files returns the files generated by the asset.
func (o *Permissions) Files() []*asset.File {
	return o.FileList
}

// Load returns the openshift asset from disk.
func (o *Permissions) Load(f asset.FileFetcher) (bool, error) {
	return false, nil
}
