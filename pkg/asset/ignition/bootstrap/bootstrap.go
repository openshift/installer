package bootstrap

import (
	"bytes"
	"encoding/json"
	"fmt"
	"os"
	"strings"
	"text/template"

	"github.com/coreos/ignition/config/util"
	igntypes "github.com/coreos/ignition/config/v2_2/types"
	"github.com/pkg/errors"
	log "github.com/sirupsen/logrus"

	"github.com/openshift/installer/pkg/asset"
	"github.com/openshift/installer/pkg/asset/ignition"
	"github.com/openshift/installer/pkg/asset/ignition/content"
	"github.com/openshift/installer/pkg/asset/installconfig"
	"github.com/openshift/installer/pkg/asset/kubeconfig"
	"github.com/openshift/installer/pkg/asset/manifests"
	"github.com/openshift/installer/pkg/asset/tls"
	"github.com/openshift/installer/pkg/types"
)

const (
	rootDir             = "/opt/tectonic"
	defaultReleaseImage = "registry.svc.ci.openshift.org/openshift/origin-release:v4.0"
)

// bootstrapTemplateData is the data to use to replace values in bootstrap
// template files.
type bootstrapTemplateData struct {
	BootkubeImage       string
	CloudProvider       string
	CloudProviderConfig string
	ClusterDNSIP        string
	DebugConfig         string
	EtcdCertSignerImage string
	EtcdCluster         string
	EtcdctlImage        string
	HyperkubeImage      string
	KubeCoreRenderImage string
	ReleaseImage        string
	FirstEtcdHost       string
}

// Bootstrap is an asset that generates the ignition config for bootstrap nodes.
type Bootstrap struct {
	config *igntypes.Config
	file   *asset.File
}

var _ asset.WritableAsset = (*Bootstrap)(nil)

// Dependencies returns the assets on which the Bootstrap asset depends.
func (a *Bootstrap) Dependencies() []asset.Asset {
	return []asset.Asset{
		&installconfig.InstallConfig{},
		&tls.RootCA{},
		&tls.EtcdCA{},
		&tls.IngressCertKey{},
		&tls.KubeCA{},
		&tls.AggregatorCA{},
		&tls.ServiceServingCA{},
		&tls.ClusterAPIServerCertKey{},
		&tls.EtcdClientCertKey{},
		&tls.APIServerCertKey{},
		&tls.OpenshiftAPIServerCertKey{},
		&tls.APIServerProxyCertKey{},
		&tls.AdminCertKey{},
		&tls.KubeletCertKey{},
		&tls.MCSCertKey{},
		&tls.ServiceAccountKeyPair{},
		&kubeconfig.Admin{},
		&kubeconfig.Kubelet{},
		&manifests.Manifests{},
		&manifests.Tectonic{},
		&manifests.KubeCoreOperator{},
	}
}

// Generate generates the ignition config for the Bootstrap asset.
func (a *Bootstrap) Generate(dependencies asset.Parents) error {
	installConfig := &installconfig.InstallConfig{}
	dependencies.Get(installConfig)

	templateData, err := a.getTemplateData(installConfig.Config)
	if err != nil {
		return errors.Wrap(err, "failed to get bootstrap templates")
	}

	a.config = &igntypes.Config{
		Ignition: igntypes.Ignition{
			Version: igntypes.MaxVersion.String(),
		},
	}

	a.addBootstrapFiles(dependencies)
	a.addBootkubeFiles(dependencies, templateData)
	a.addTectonicFiles(dependencies, templateData)
	a.addTLSCertFiles(dependencies)

	a.config.Systemd.Units = append(
		a.config.Systemd.Units,
		igntypes.Unit{Name: "bootkube.service", Contents: content.BootkubeSystemdContents},
		igntypes.Unit{Name: "tectonic.service", Contents: content.TectonicSystemdContents, Enabled: util.BoolToPtr(true)},
		igntypes.Unit{Name: "kubelet.service", Contents: applyTemplateData(content.KubeletSystemdTemplate, templateData), Enabled: util.BoolToPtr(true)},
	)

	a.config.Passwd.Users = append(
		a.config.Passwd.Users,
		igntypes.PasswdUser{Name: "core", SSHAuthorizedKeys: []igntypes.SSHAuthorizedKey{igntypes.SSHAuthorizedKey(installConfig.Config.Admin.SSHKey)}},
	)

	data, err := json.Marshal(a.config)
	if err != nil {
		return errors.Wrap(err, "failed to Marshal Ignition config")
	}
	a.file = &asset.File{
		Filename: "bootstrap.ign",
		Data:     data,
	}

	return nil
}

// Name returns the human-friendly name of the asset.
func (a *Bootstrap) Name() string {
	return "Bootstrap Ignition Config"
}

// Files returns the files generated by the asset.
func (a *Bootstrap) Files() []*asset.File {
	return []*asset.File{a.file}
}

// getTemplateData returns the data to use to execute bootstrap templates.
func (a *Bootstrap) getTemplateData(installConfig *types.InstallConfig) (*bootstrapTemplateData, error) {
	clusterDNSIP, err := installconfig.ClusterDNSIP(installConfig)
	if err != nil {
		return nil, errors.Wrap(err, "failed to get ClusterDNSIP from InstallConfig")
	}
	etcdEndpoints := make([]string, installConfig.MasterCount())
	for i := range etcdEndpoints {
		etcdEndpoints[i] = fmt.Sprintf("https://%s-etcd-%d.%s:2379", installConfig.ObjectMeta.Name, i, installConfig.BaseDomain)
	}

	releaseImage := defaultReleaseImage
	if ri, ok := os.LookupEnv("OPENSHIFT_INSTALL_RELEASE_IMAGE_OVERRIDE"); ok && ri != "" {
		log.Warn("Found override for ReleaseImage. Please be warned, this is not advised")
		releaseImage = ri
	}

	firstEtcdHost := ""
	if len(etcdEndpoints) > 0 {
		firstEtcdHost = etcdEndpoints[0]
	}

	return &bootstrapTemplateData{
		ClusterDNSIP:        clusterDNSIP,
		CloudProvider:       getCloudProvider(installConfig),
		CloudProviderConfig: getCloudProviderConfig(installConfig),
		DebugConfig:         "",
		KubeCoreRenderImage: "quay.io/coreos/kube-core-renderer-dev:375423a332f2c12b79438fc6a6da6e448e28ec0f",
		EtcdCertSignerImage: "quay.io/coreos/kube-etcd-signer-server:678cc8e6841e2121ebfdb6e2db568fce290b67d6",
		EtcdctlImage:        "quay.io/coreos/etcd:v3.2.14",
		BootkubeImage:       "quay.io/coreos/bootkube:v0.10.0",
		ReleaseImage:        releaseImage,
		HyperkubeImage:      "openshift/origin-node:latest",
		EtcdCluster:         strings.Join(etcdEndpoints, ","),
		FirstEtcdHost:       firstEtcdHost,
	}, nil
}

func (a *Bootstrap) addBootstrapFiles(dependencies asset.Parents) {
	kubeletKubeconfig := &kubeconfig.Kubelet{}
	kubeCoreOperator := &manifests.KubeCoreOperator{}
	dependencies.Get(kubeletKubeconfig, kubeCoreOperator)

	a.config.Storage.Files = append(
		a.config.Storage.Files,
		ignition.FileFromBytes("/etc/kubernetes/kubeconfig", 0600, kubeletKubeconfig.Files()[0].Data),
		ignition.FileFromBytes("/var/lib/kubelet/kubeconfig", 0600, kubeletKubeconfig.Files()[0].Data),
	)
	a.config.Storage.Files = append(
		a.config.Storage.Files,
		ignition.FilesFromAsset(rootDir, 0644, kubeCoreOperator)...,
	)
}

func (a *Bootstrap) addBootkubeFiles(dependencies asset.Parents, templateData *bootstrapTemplateData) {
	adminKubeconfig := &kubeconfig.Admin{}
	manifests := &manifests.Manifests{}
	dependencies.Get(adminKubeconfig, manifests)

	a.config.Storage.Files = append(
		a.config.Storage.Files,
		ignition.FileFromString("/opt/tectonic/bootkube.sh", 0555, applyTemplateData(content.BootkubeShFileTemplate, templateData)),
	)
	a.config.Storage.Files = append(
		a.config.Storage.Files,
		ignition.FilesFromAsset(rootDir, 0600, adminKubeconfig)...,
	)
	a.config.Storage.Files = append(
		a.config.Storage.Files,
		ignition.FilesFromAsset(rootDir, 0644, manifests)...,
	)
}

func (a *Bootstrap) addTectonicFiles(dependencies asset.Parents, templateData *bootstrapTemplateData) {
	tectonic := &manifests.Tectonic{}
	dependencies.Get(tectonic)

	a.config.Storage.Files = append(
		a.config.Storage.Files,
		ignition.FileFromString("/opt/tectonic/tectonic.sh", 0555, content.TectonicShFileContents),
	)
	a.config.Storage.Files = append(
		a.config.Storage.Files,
		ignition.FilesFromAsset(rootDir, 0644, tectonic)...,
	)
}

func (a *Bootstrap) addTLSCertFiles(dependencies asset.Parents) {
	for _, asset := range []asset.WritableAsset{
		&tls.RootCA{},
		&tls.KubeCA{},
		&tls.AggregatorCA{},
		&tls.ServiceServingCA{},
		&tls.EtcdCA{},
		&tls.ClusterAPIServerCertKey{},
		&tls.EtcdClientCertKey{},
		&tls.APIServerCertKey{},
		&tls.OpenshiftAPIServerCertKey{},
		&tls.APIServerProxyCertKey{},
		&tls.AdminCertKey{},
		&tls.KubeletCertKey{},
		&tls.MCSCertKey{},
		&tls.ServiceAccountKeyPair{},
	} {
		dependencies.Get(asset)
		a.config.Storage.Files = append(a.config.Storage.Files, ignition.FilesFromAsset(rootDir, 0600, asset)...)
	}

	etcdClientCertKey := &tls.EtcdClientCertKey{}
	dependencies.Get(etcdClientCertKey)
	a.config.Storage.Files = append(
		a.config.Storage.Files,
		ignition.FileFromBytes("/etc/ssl/etcd/ca.crt", 0600, etcdClientCertKey.Cert()),
	)
}

func getCloudProvider(installConfig *types.InstallConfig) string {
	if installConfig.AWS != nil {
		return "aws"
	}
	return ""
}

func getCloudProviderConfig(installConfig *types.InstallConfig) string {
	return ""
}

func applyTemplateData(template *template.Template, templateData interface{}) string {
	buf := &bytes.Buffer{}
	if err := template.Execute(buf, templateData); err != nil {
		panic(err)
	}
	return buf.String()
}
