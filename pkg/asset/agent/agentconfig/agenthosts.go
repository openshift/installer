package agentconfig

import (
	"context"
	"fmt"
	"path/filepath"
	"strings"

	"github.com/pkg/errors"
	"github.com/sirupsen/logrus"
	"k8s.io/apimachinery/pkg/util/validation/field"
	"sigs.k8s.io/yaml"

	aiv1beta1 "github.com/openshift/assisted-service/api/v1beta1"
	"github.com/openshift/installer/pkg/asset"
	agentAsset "github.com/openshift/installer/pkg/asset/agent"
	"github.com/openshift/installer/pkg/asset/agent/joiner"
	"github.com/openshift/installer/pkg/asset/agent/workflow"
	"github.com/openshift/installer/pkg/types/agent"
	"github.com/openshift/installer/pkg/types/baremetal/validation"
	"github.com/openshift/installer/pkg/validate"
)

var (
	_ asset.WritableAsset = (*AgentHosts)(nil)
)

const (
	masterRole string = "master"
	workerRole string = "worker"
)

type nmStateInterface struct {
	Interfaces []struct {
		MACAddress string `json:"mac-address,omitempty"`
		Name       string `json:"name,omitempty"`
	} `yaml:"interfaces,omitempty"`
}

// AgentHosts generates the hosts information from the AgentConfig and
// OptionalInstallConfig assets.
type AgentHosts struct {
	Hosts        []agent.Host
	rendezvousIP string
}

// Name returns a human friendly name.
func (a *AgentHosts) Name() string {
	return "Agent Hosts"
}

// Dependencies returns all of the dependencies directly needed the asset.
func (a *AgentHosts) Dependencies() []asset.Asset {
	return []asset.Asset{
		&workflow.AgentWorkflow{},
		&joiner.AddNodesConfig{},
		&agentAsset.OptionalInstallConfig{},
		&AgentConfig{},
	}
}

// Generate generates the Hosts data.
func (a *AgentHosts) Generate(_ context.Context, dependencies asset.Parents) error {
	agentWorkflow := &workflow.AgentWorkflow{}
	addNodesConfig := &joiner.AddNodesConfig{}
	agentConfig := &AgentConfig{}
	installConfig := &agentAsset.OptionalInstallConfig{}
	dependencies.Get(agentConfig, installConfig, agentWorkflow, addNodesConfig)

	switch agentWorkflow.Workflow {
	case workflow.AgentWorkflowTypeInstall:
		if agentConfig.Config != nil {
			a.rendezvousIP = agentConfig.Config.RendezvousIP
			a.Hosts = append(a.Hosts, agentConfig.Config.Hosts...)
			if len(a.Hosts) > 0 {
				// Hosts defined in agent-config take precedence
				logrus.Debugf("Using hosts from %s", agentConfigFilename)
			}
		}

		if installConfig != nil && installConfig.GetBaremetalHosts() != nil {
			// Only use hosts from install-config if they are not defined in agent-config
			if len(a.Hosts) == 0 {
				if err := a.getInstallConfigDefaults(installConfig); err != nil {
					return errors.Wrapf(err, "invalid host definition in %s", agentAsset.InstallConfigFilename)
				}
			} else {
				logrus.Warnf("hosts from %s are ignored", agentAsset.InstallConfigFilename)
			}
		}

	case workflow.AgentWorkflowTypeAddNodes:
		a.Hosts = append(a.Hosts, addNodesConfig.Config.Hosts...)

	default:
		return fmt.Errorf("AgentWorkflowType value not supported: %s", agentWorkflow.Workflow)
	}

	if err := a.validateAgentHosts().ToAggregate(); err != nil {
		return errors.Wrapf(err, "invalid Hosts configuration")
	}

	return nil
}

// Files returns the files generated by the asset.
func (a *AgentHosts) Files() []*asset.File {
	return nil
}

// Load currently does nothing.
func (a *AgentHosts) Load(f asset.FileFetcher) (bool, error) {
	return false, nil
}

func (a *AgentHosts) validateAgentHosts() field.ErrorList {
	allErrs := field.ErrorList{}

	macs := make(map[string]bool)
	for i, host := range a.Hosts {
		hostPath := field.NewPath("Hosts").Index(i)

		if err := a.validateHostInterfaces(hostPath, host, macs); err != nil {
			allErrs = append(allErrs, err...)
		}

		if err := a.validateHostRootDeviceHints(hostPath, host); err != nil {
			allErrs = append(allErrs, err...)
		}

		if err := a.validateRoles(hostPath, host); err != nil {
			allErrs = append(allErrs, err...)
		}
	}

	if err := a.validateRendezvousIPNotWorker(a.rendezvousIP, a.Hosts); err != nil {
		allErrs = append(allErrs, err...)
	}

	return allErrs
}

func (a *AgentHosts) validateHostInterfaces(hostPath *field.Path, host agent.Host, macs map[string]bool) field.ErrorList {
	var allErrs field.ErrorList

	interfacePath := hostPath.Child("Interfaces")
	if len(host.Interfaces) == 0 {
		allErrs = append(allErrs, field.Required(interfacePath, "at least one interface must be defined for each node"))
	}

	for j := range host.Interfaces {
		mac := host.Interfaces[j].MacAddress
		macAddressPath := interfacePath.Index(j).Child("macAddress")

		if mac == "" {
			allErrs = append(allErrs, field.Required(macAddressPath, "each interface must have a MAC address defined"))
			continue
		}

		if err := validate.MAC(mac); err != nil {
			allErrs = append(allErrs, field.Invalid(macAddressPath, mac, err.Error()))
		}

		if _, ok := macs[mac]; ok {
			allErrs = append(allErrs, field.Invalid(macAddressPath, mac, "duplicate MAC address found"))
		}
		macs[mac] = true
	}

	return allErrs
}

func (a *AgentHosts) validateHostRootDeviceHints(hostPath *field.Path, host agent.Host) field.ErrorList {
	rdhPath := hostPath.Child("rootDeviceHints")
	allErrs := validation.ValidateHostRootDeviceHints(&host.RootDeviceHints, rdhPath)

	if host.RootDeviceHints.WWNWithExtension != "" {
		allErrs = append(allErrs, field.Forbidden(
			rdhPath.Child("wwnWithExtension"), "WWN extensions are not supported in root device hints"))
	}

	if host.RootDeviceHints.WWNVendorExtension != "" {
		allErrs = append(allErrs, field.Forbidden(rdhPath.Child("wwnVendorExtension"), "WWN vendor extensions are not supported in root device hints"))
	}

	return allErrs
}

func (a *AgentHosts) validateRoles(hostPath *field.Path, host agent.Host) field.ErrorList {
	var allErrs field.ErrorList

	if len(host.Role) > 0 && host.Role != masterRole && host.Role != workerRole {
		allErrs = append(allErrs, field.Forbidden(hostPath.Child("Host"), "host role has incorrect value. Role must either be 'master' or 'worker'"))
	}

	return allErrs
}

func (a *AgentHosts) validateRendezvousIPNotWorker(rendezvousIP string, hosts []agent.Host) field.ErrorList {
	var allErrs field.ErrorList

	if rendezvousIP != "" {
		for i, host := range hosts {
			if host.Role != workerRole {
				continue
			}
			hostPath := field.NewPath("Hosts").Index(i)
			hostIPs, err := agentAsset.GetAllHostIPs(host.NetworkConfig)
			if err != nil {
				allErrs = append(allErrs, field.Invalid(hostPath, host.NetworkConfig, err.Error()))
				continue
			}
			_, found := hostIPs[rendezvousIP]
			if found {
				errMsg := "Host " + host.Hostname + " has role 'worker' and has the rendezvousIP assigned to it. The rendezvousIP must be assigned to a control plane host."
				allErrs = append(allErrs, field.Forbidden(hostPath.Child("Host"), errMsg))
			}
		}
	}
	return allErrs
}

// Add the baremetal hosts defined in install-config to the agent Hosts.
func (a *AgentHosts) getInstallConfigDefaults(installConfig *agentAsset.OptionalInstallConfig) error {
	for _, icHost := range installConfig.GetBaremetalHosts() {
		if icHost.BootMACAddress == "" {
			return errors.New("host bootMACAddress is required")
		}

		host := agent.Host{
			Hostname: icHost.Name,
			Role:     icHost.Role,
		}
		if icHost.RootDeviceHints != nil {
			host.RootDeviceHints = *icHost.RootDeviceHints
		}
		if icHost.NetworkConfig != nil {
			contents, err := yaml.JSONToYAML(icHost.NetworkConfig.Raw)
			if err != nil {
				return errors.Wrap(err, "failed to unmarshal networkConfig")
			}
			host.NetworkConfig.Raw = contents

			// Create interfaces table from NetworkConfig
			var netInterfaces nmStateInterface
			err = yaml.Unmarshal(contents, &netInterfaces)
			if err != nil {
				return fmt.Errorf("error unmarshalling NMStateConfig: %w", err)
			}

			var foundBootMac = false
			for _, intf := range netInterfaces.Interfaces {
				if intf.Name != "" && intf.MACAddress != "" {
					hostInterface := &aiv1beta1.Interface{
						Name:       intf.Name,
						MacAddress: intf.MACAddress,
					}
					host.Interfaces = append(host.Interfaces, hostInterface)
					if icHost.BootMACAddress == intf.MACAddress {
						foundBootMac = true
					}
				}
			}

			if !foundBootMac {
				logrus.Warnf("For host %s, BootMACAddress %s is not in NetworkConfig", icHost.Name, icHost.BootMACAddress)
			}
		}
		if len(host.Interfaces) == 0 {
			// Create interfaces table from BootMacAddress
			hostInterface := &aiv1beta1.Interface{
				Name:       "boot",
				MacAddress: icHost.BootMACAddress,
			}
			host.Interfaces = append(host.Interfaces, hostInterface)
		}

		// Add BMC configuration
		host.BMC = icHost.BMC

		logrus.Debugf("Using host %s from %s", host.Hostname, agentAsset.InstallConfigFilename)
		a.Hosts = append(a.Hosts, host)
	}
	return nil
}

// HostConfigFileMap is a map from a filepath ("<host>/<file>") to file content
// for hostconfig files.
type HostConfigFileMap map[string][]byte

// HostConfigFiles returns a map from filename to contents of the files used for
// host-specific configuration by the agent installer client.
func (a *AgentHosts) HostConfigFiles() (HostConfigFileMap, error) {
	if a == nil {
		return nil, nil
	}

	files := HostConfigFileMap{}
	for i, host := range a.Hosts {
		name := fmt.Sprintf("host-%d", i)
		if host.Hostname != "" {
			name = host.Hostname
		}

		macs := []string{}
		for _, iface := range host.Interfaces {
			macs = append(macs, strings.ToLower(iface.MacAddress)+"\n")
		}

		if len(macs) > 0 {
			files[filepath.Join(name, "mac_addresses")] = []byte(strings.Join(macs, ""))
		}

		rdh, err := yaml.Marshal(host.RootDeviceHints)
		if err != nil {
			return nil, err
		}
		if len(rdh) > 0 && string(rdh) != "{}\n" {
			files[filepath.Join(name, "root-device-hints.yaml")] = rdh
		}

		if len(host.Role) > 0 {
			files[filepath.Join(name, "role")] = []byte(host.Role)
		}
	}
	return files, nil
}
