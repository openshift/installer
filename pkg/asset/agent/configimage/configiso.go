package configimage

import (
	"context"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/pkg/errors"
	"github.com/sirupsen/logrus"
	"github.com/vincent-petithory/dataurl"

	"github.com/openshift/assisted-image-service/pkg/isoeditor"
	"github.com/openshift/installer/pkg/asset"
	"github.com/openshift/installer/pkg/asset/agent/image"
	"github.com/openshift/installer/pkg/asset/agent/workflow"
)

const (
	configImageFilename        = "agentconfig.noarch.iso"
	nodeAddConfigImageFilename = "node-config.noarch.iso"
	configImageLabel           = "agent_configimage"
	configCpioArchive          = "config.gz"
)

// ConfigImage is an asset that generates a configuration ISO that can be used configure hosts.
type ConfigImage struct {
	tmpPath  string
	filename string
}

var _ asset.WritableAsset = (*ConfigImage)(nil)

// Dependencies returns the assets on which the Config asset depends.
func (a *ConfigImage) Dependencies() []asset.Asset {
	return []asset.Asset{
		&image.Ignition{},
		&workflow.AgentWorkflow{},
	}
}

// Generate generates the configuration image file.
func (a *ConfigImage) Generate(_ context.Context, dependencies asset.Parents) error {
	ignition := &image.Ignition{}
	agentWorkflow := &workflow.AgentWorkflow{}

	dependencies.Get(ignition, agentWorkflow)

	switch agentWorkflow.Workflow {
	case workflow.AgentWorkflowTypeInstall:
		a.filename = configImageFilename
	case workflow.AgentWorkflowTypeAddNodes:
		a.filename = nodeAddConfigImageFilename
	default:
		return fmt.Errorf("AgentWorkflowType value not supported: %s", agentWorkflow.Workflow)
	}

	ca := image.NewCpioArchive()

	// Walk the list of ignition files.
	// For the ones to be included in the configimage add to cpio archive
	for _, file := range ignition.Config.Storage.Files {
		filename := file.Node.Path
		mode := *file.FileEmbedded1.Mode
		if includeFileInImage(filename) {
			logrus.Debugf("Including file %s", filename)
			contents := ""
			if file.FileEmbedded1.Contents.Source != nil {
				output, err := dataurl.DecodeString(*file.FileEmbedded1.Contents.Source)
				if err != nil {
					return errors.Wrapf(err, "decode string failed for %s", filename)
				}
				contents = string(output.Data)
			}

			err := ca.StoreBytes(filename, []byte(contents), mode)
			if err != nil {
				return errors.Wrapf(err, "failure storing file %s in cpio", filename)
			}
		}
	}

	// Save the cpi archive to a temp file
	tmpPath, err := os.MkdirTemp("", "agent")
	if err != nil {
		return err
	}
	a.tmpPath = tmpPath

	output := filepath.Join(tmpPath, configCpioArchive)

	err = ca.Save(output)
	if err != nil {
		return errors.Wrapf(err, "failure saving cpio file %s", configCpioArchive)
	}

	return nil
}

// PersistToFile writes the iso image in the assets folder.
func (a *ConfigImage) PersistToFile(directory string) error {
	defer os.RemoveAll(a.tmpPath)

	// If the tmpPath are not set then it means that either one of the Config
	// dependencies or the asset itself failed for some reason
	if a.tmpPath == "" {
		return errors.New("cannot generate Config image due to configuration errors")
	}

	configImageFile := filepath.Join(directory, a.filename)

	// Remove symlink if it exists
	os.Remove(configImageFile)

	err := isoeditor.Create(configImageFile, a.tmpPath, configImageLabel)
	if err != nil {
		return err
	}

	return nil
}

// Name returns the human-friendly name of the asset.
func (a *ConfigImage) Name() string {
	return "Agent Config ISO"
}

// Load returns the ISO from disk.
func (a *ConfigImage) Load(f asset.FileFetcher) (bool, error) {
	// The ISO will not be needed by another asset so load is noop.
	// This is implemented because it is required by WritableAsset
	return false, nil
}

// Files returns the files generated by the asset.
func (a *ConfigImage) Files() []*asset.File {
	// Return empty array because File will never be loaded.
	return []*asset.File{}
}

func includeFileInImage(f string) bool {
	fileFilters := image.GetConfigImageFiles()
	for _, filter := range fileFilters {
		if strings.Contains(f, filter) {
			return true
		}
	}
	return false
}
