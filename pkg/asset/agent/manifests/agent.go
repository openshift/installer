package manifests

import (
	"context"
	"fmt"
	"reflect"

	"github.com/pkg/errors"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/util/validation/field"

	hiveext "github.com/openshift/assisted-service/api/hiveextension/v1beta1"
	aiv1beta1 "github.com/openshift/assisted-service/api/v1beta1"
	"github.com/openshift/assisted-service/models"
	hivev1 "github.com/openshift/hive/apis/hive/v1"
	"github.com/openshift/installer/pkg/asset"
	"github.com/openshift/installer/pkg/asset/agent/workflow"
	workflowreport "github.com/openshift/installer/pkg/asset/agent/workflow/report"
)

const (
	// This could be change to "cluster-manifests" once all the agent code will be migrated to using
	// assets (and will stop reading from the hard-code "manifests" relative path)
	clusterManifestDir = "cluster-manifests"
)

var (
	_ asset.WritableAsset = (*AgentManifests)(nil)
)

// AgentManifests generates all the required manifests by the agent installer.
type AgentManifests struct {
	FileList []*asset.File

	PullSecret           *corev1.Secret
	InfraEnv             *aiv1beta1.InfraEnv
	StaticNetworkConfigs []*models.HostStaticNetworkConfig
	NMStateConfigs       []*aiv1beta1.NMStateConfig
	AgentClusterInstall  *hiveext.AgentClusterInstall
	ClusterDeployment    *hivev1.ClusterDeployment
	ClusterImageSet      *hivev1.ClusterImageSet
}

// Name returns a human friendly name.
func (m *AgentManifests) Name() string {
	return "Agent Manifests"
}

// Dependencies returns all of the dependencies directly needed the asset.
func (m *AgentManifests) Dependencies() []asset.Asset {
	return []asset.Asset{
		&AgentPullSecret{},
		&InfraEnv{},
		&NMStateConfig{},
		&AgentClusterInstall{},
		&ClusterDeployment{},
		&ClusterImageSet{},
	}
}

// Generate generates the respective manifest files.
func (m *AgentManifests) Generate(ctx context.Context, dependencies asset.Parents) error {
	if err := workflowreport.GetReport(ctx).Stage(workflow.StageCreateManifests); err != nil {
		return err
	}

	for _, a := range []asset.WritableAsset{
		&AgentPullSecret{},
		&InfraEnv{},
		&NMStateConfig{},
		&AgentClusterInstall{},
		&ClusterDeployment{},
		&ClusterImageSet{},
	} {
		dependencies.Get(a)

		switch v := a.(type) {
		case *AgentPullSecret:
			m.PullSecret = v.Config
		case *InfraEnv:
			m.InfraEnv = v.Config
		case *NMStateConfig:
			// continue if there are no configs defined to avoid
			// writing out a empty nmstateconfig.yaml file
			if len(v.Config) == 0 {
				continue
			}
			m.StaticNetworkConfigs = append(m.StaticNetworkConfigs, v.StaticNetworkConfig...)
			m.NMStateConfigs = append(m.NMStateConfigs, v.Config...)
		case *AgentClusterInstall:
			m.AgentClusterInstall = v.Config
		case *ClusterDeployment:
			m.ClusterDeployment = v.Config
		case *ClusterImageSet:
			m.ClusterImageSet = v.Config
		}

		m.FileList = append(m.FileList, a.Files()...)
	}

	asset.SortFiles(m.FileList)

	return m.finish()
}

// Files returns the files generated by the asset.
func (m *AgentManifests) Files() []*asset.File {
	return m.FileList
}

// Load currently does nothing
func (m *AgentManifests) Load(f asset.FileFetcher) (bool, error) {
	return false, nil
}

// GetPullSecretData returns the content of the pull secret
func (m *AgentManifests) GetPullSecretData() string {
	return m.PullSecret.StringData[".dockerconfigjson"]
}

func (m *AgentManifests) finish() error {
	if err := m.validateAgentManifests().ToAggregate(); err != nil {
		return errors.Wrapf(err, "invalid agent configuration")
	}

	return nil
}

func (m *AgentManifests) validateAgentManifests() field.ErrorList {
	allErrs := field.ErrorList{}

	if err := m.validateNMStateLabelSelector(); err != nil {
		allErrs = append(allErrs, err...)
	}

	return allErrs
}

func (m *AgentManifests) validateNMStateLabelSelector() field.ErrorList {

	var allErrs field.ErrorList

	fieldPath := field.NewPath("spec", "nmStateConfigLabelSelector", "matchLabels")

	for _, networkConfig := range m.NMStateConfigs {
		if !reflect.DeepEqual(m.InfraEnv.Spec.NMStateConfigLabelSelector.MatchLabels, networkConfig.ObjectMeta.Labels) {
			allErrs = append(allErrs, field.Required(fieldPath, fmt.Sprintf("infraEnv and %s NMState Config labels do not match. Expected: %s Found: %s",
				networkConfig.Name,
				m.InfraEnv.Spec.NMStateConfigLabelSelector.MatchLabels,
				networkConfig.ObjectMeta.Labels)))
		}

	}

	return allErrs
}
