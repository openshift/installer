package manifests

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	aiv1beta1 "github.com/openshift/assisted-service/api/v1beta1"
	"github.com/pkg/errors"
	"k8s.io/apimachinery/pkg/util/validation/field"
	"k8s.io/apimachinery/pkg/util/yaml"

	"github.com/openshift/installer/pkg/asset"
)

var (
	agentFilename = filepath.Join(clusterManifestDir, "agent.yaml")
)

// Agent reads the agent.yaml file.
type Agent struct {
	File   *asset.File
	Config []*aiv1beta1.Agent
}

var _ asset.WritableAsset = (*InfraEnv)(nil)

// Name returns a human friendly name for the asset.
func (*Agent) Name() string {
	return "Agent Config"
}

// Dependencies returns all of the dependencies directly needed to generate
// the asset.
func (*Agent) Dependencies() []asset.Asset {
	return []asset.Asset{}
}

// Generate generates the Agent manifest.
func (i *Agent) Generate(dependencies asset.Parents) error {
	return nil
}

// Files returns the files generated by the asset.
func (a *Agent) Files() []*asset.File {
	if a.File != nil {
		return []*asset.File{a.File}
	}
	return []*asset.File{}
}

type agentYamlDecoder int

func (d *agentYamlDecoder) NewDecodedYaml(yamlDecoder *yaml.YAMLToJSONDecoder) (interface{}, error) {
	decodedData := new(aiv1beta1.Agent)
	err := yamlDecoder.Decode(&decodedData)

	return decodedData, err
}

// Load returns agent asset from the disk.
func (a *Agent) Load(f asset.FileFetcher) (bool, error) {

	file, err := f.FetchByName(agentFilename)
	if err != nil {
		if os.IsNotExist(err) {
			return false, nil
		}
		return false, errors.Wrap(err, fmt.Sprintf("failed to load %s file", agentFilename))
	}

	// agent.yaml may contain multiple Agent CRs
	var decoder agentYamlDecoder
	yamlList, err := GetMultipleYamls(file.Data, &decoder)
	if err != nil {
		return false, errors.Wrapf(err, "could not decode YAML for %s", agentFilename)
	}

	var agents []*aiv1beta1.Agent
	for i := range yamlList {
		agents = append(agents, yamlList[i].(*aiv1beta1.Agent))
	}

	// config := &aiv1beta1.Agent{}
	// if err := yaml.UnmarshalStrict(file.Data, config); err != nil {
	// 	return false, errors.Wrapf(err, "failed to unmarshal %s", agentFilename)
	// }

	a.File, a.Config = file, agents
	if err = a.finish(); err != nil {
		return false, err
	}

	return true, nil
}

func (a *Agent) finish() error {
	if err := a.validateAgent().ToAggregate(); err != nil {
		return errors.Wrapf(err, "invalid Agent configuration")
	}

	return nil
}

func (a *Agent) validateAgent() field.ErrorList {
	allErrs := field.ErrorList{}

	if err := a.validateMACAddressAnnotationExists(); err != nil {
		allErrs = append(allErrs, err...)
	}

	return allErrs
}

func (a *Agent) validateMACAddressAnnotationExists() field.ErrorList {

	var allErrs field.ErrorList

	fieldPath := field.NewPath("metadata", "annotations", "macAddress")

	for _, agent := range a.Config {
		if _, ok := agent.Annotations["macAddress"]; !ok {
			allErrs = append(allErrs, field.Required(fieldPath, "macAddress annotation is missing"))
		}
	}

	return allErrs
}

// Returns a list of commands that apply the host-specific customizations.
// They are applied after the host have registered with assisted-service.
func (a *Agent) HostCustomizations() string {
	result := ""
	for _, agent := range a.Config {
		if (agent.Spec.Hostname != "") || (agent.Spec.IgnitionConfigOverrides != "") || (agent.Spec.InstallerArgs != "") {
			result += "export HOST_ID=$(curl -s -S ${SERVICE_BASE_URL}/api/assisted-install/v2/infra-envs/${INFRA_ENV_ID}/hosts/ | jq -c '.[] | select(.inventory | contains(\"" + agent.ObjectMeta.Annotations["macAddress"] + "\")).id') \n"
			result += "export HOST_ID=${HOST_ID:1:-1} \n"
			result += "echo HOST_ID=${HOST_ID} 1>&2\n"
			if agent.Spec.Hostname != "" {
				result += patchHostnameCommand(agent)
			}
			if agent.Spec.IgnitionConfigOverrides != "" {
				result += patchIgnitionConfigOverrideCommand(agent)
			}
		}
	}

	return result
}

func patchHostnameCommand(agent *aiv1beta1.Agent) string {
	return patchCommand("{\"host_name\": \""+agent.Spec.Hostname+"\"}", "${SERVICE_BASE_URL}api/assisted-install/v2/infra-envs/${INFRA_ENV_ID}/hosts/${HOST_ID}")
}

func patchIgnitionConfigOverrideCommand(agent *aiv1beta1.Agent) string {
	config := escapeDoubleQuotes(agent.Spec.IgnitionConfigOverrides)
	return patchCommand("{\"config\": \""+config+"\"}", "${SERVICE_BASE_URL}api/assisted-install/v2/infra-envs/${INFRA_ENV_ID}/hosts/${HOST_ID}/ignition")
}

func patchCommand(data string, url string) string {
	commands := "echo \"patching url: " + url + "\" 1>&2\n"
	commands += "curl -s -S --fail -X PATCH " + url + " -H \"Content-Type: application/json\" -d '" + data + "' \n"
	commands += "CURL_EXIT_CODE=$?\n"
	commands += "if [ $CURL_EXIT_CODE -ne 0 ]; then\n"
	commands += "    echo \"PATCH failed for url: " + url + "\" 1>&2\n"
	commands += "    exit $CURL_EXIT_CODE\n"
	commands += "fi\n"
	commands += "\n"
	return commands
}

func escapeDoubleQuotes(data string) string {
	return strings.ReplaceAll(data, `"`, `\"`)
}
