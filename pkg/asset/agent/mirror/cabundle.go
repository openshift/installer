package mirror

import (
	"context"
	"fmt"
	"os"
	"path/filepath"

	"github.com/pkg/errors"

	"github.com/openshift/installer/pkg/asset"
	"github.com/openshift/installer/pkg/asset/agent"
	"github.com/openshift/installer/pkg/asset/agent/joiner"
	"github.com/openshift/installer/pkg/asset/agent/workflow"
	"github.com/openshift/installer/pkg/asset/manifests"
)

var (
	// CaBundleFilename defines the name of the file on disk
	CaBundleFilename = filepath.Join(mirrorConfigDir, "ca-bundle.crt")
)

// CaBundle generates the cetificate file for disconnected mirrors.
type CaBundle struct {
	File *asset.File
}

var _ asset.WritableAsset = (*CaBundle)(nil)

// Name returns a human friendly name for the asset.
func (*CaBundle) Name() string {
	return "Mirror Registries Certificate File"
}

// Dependencies returns all of the dependencies directly needed to generate
// the asset.
func (*CaBundle) Dependencies() []asset.Asset {
	return []asset.Asset{
		&workflow.AgentWorkflow{},
		&joiner.ClusterInfo{},
		&agent.OptionalInstallConfig{},
	}
}

// Generate generates the Mirror Registries certificate file from install-config.
func (i *CaBundle) Generate(_ context.Context, dependencies asset.Parents) error {
	agentWorkflow := &workflow.AgentWorkflow{}
	clusterInfo := &joiner.ClusterInfo{}
	installConfig := &agent.OptionalInstallConfig{}
	dependencies.Get(installConfig, agentWorkflow, clusterInfo)

	var additionalTrustBundle string

	switch agentWorkflow.Workflow {
	case workflow.AgentWorkflowTypeInstall:
		if !installConfig.Supplied {
			return nil
		}
		additionalTrustBundle = installConfig.Config.AdditionalTrustBundle

	case workflow.AgentWorkflowTypeAddNodes:
		additionalTrustBundle = clusterInfo.UserCaBundle

	default:
		return fmt.Errorf("AgentWorkflowType value not supported: %s", agentWorkflow.Workflow)
	}

	if additionalTrustBundle == "" {
		i.File = &asset.File{
			Filename: CaBundleFilename,
			Data:     []byte{},
		}
		return nil
	}

	return i.parseCertificates(additionalTrustBundle)
}

func (i *CaBundle) parseCertificates(certs string) error {
	if len(certs) == 0 {
		return nil
	}

	data, err := manifests.ParseCertificates(certs)
	if err != nil {
		return err
	}

	for filename, content := range data {
		if filepath.Base(CaBundleFilename) == filename {
			i.File = &asset.File{
				Filename: CaBundleFilename,
				Data:     []byte(content),
			}
		} else {
			return fmt.Errorf("unexpected CA Bundle filename %s", filename)
		}
	}

	return nil
}

// Files returns the files generated by the asset.
func (i *CaBundle) Files() []*asset.File {
	if i.File != nil {
		return []*asset.File{i.File}
	}
	return []*asset.File{}
}

// Load returns the Mirror Registries certificate file from the disk.
func (i *CaBundle) Load(f asset.FileFetcher) (bool, error) {

	file, err := f.FetchByName(CaBundleFilename)
	if err != nil {
		if os.IsNotExist(err) {
			return false, nil
		}
		return false, errors.Wrap(err, fmt.Sprintf("failed to load %s file", CaBundleFilename))
	}

	return true, i.parseCertificates(string(file.Data))
}
