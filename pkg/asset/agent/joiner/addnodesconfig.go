package joiner

import (
	"context"
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"

	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/util/validation/field"
	"sigs.k8s.io/yaml"

	"github.com/openshift/installer/pkg/asset"
	"github.com/openshift/installer/pkg/types/agent"
	"github.com/openshift/installer/pkg/validate"
)

const (
	addNodesParamsFile  = ".addnodesparams"
	nodesConfigFilename = "nodes-config.yaml"
)

// AddNodesConfig is used to store the current configuration
// for the command.
type AddNodesConfig struct {
	Params Params
	Config Config
}

var _ asset.WritableAsset = (*AddNodesConfig)(nil)

// Config defines the configuration for the nodes-config.yaml file
// used by the add-nodes command.
type Config struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`

	CPUArchitecture      string       `json:"cpuArchitecture,omitempty"`
	SSHKey               string       `json:"sshKey,omitempty"`
	BootArtifactsBaseURL string       `json:"bootArtifactsBaseURL,omitempty"`
	Hosts                []agent.Host `json:"hosts,omitempty"`
}

// Params is used to store the command line parameters.
type Params struct {
	Kubeconfig string `json:"kubeconfig,omitempty"`
}

// Save stores the current parameters on disk.
func (p *Params) Save(assetsDir string) error {
	data, err := json.Marshal(p)
	if err != nil {
		return err
	}

	fileName := filepath.Join(assetsDir, addNodesParamsFile)
	return os.WriteFile(fileName, data, 0o600)
}

// Name returns the human-friendly name of the asset.
func (*AddNodesConfig) Name() string {
	return "AddNodes Config"
}

// Dependencies returns all of the dependencies directly needed to generate
// the asset.
func (*AddNodesConfig) Dependencies() []asset.Asset {
	return []asset.Asset{}
}

// Generate it's empty for this asset, always loaded from disk.
func (*AddNodesConfig) Generate(_ context.Context, dependencies asset.Parents) error {
	return nil
}

// Files returns the files generated by the asset.
func (*AddNodesConfig) Files() []*asset.File {
	return []*asset.File{}
}

// Load returns agent config asset from the disk.
func (a *AddNodesConfig) Load(f asset.FileFetcher) (bool, error) {
	// Load params file.
	file, err := f.FetchByName(addNodesParamsFile)
	if err != nil {
		if os.IsNotExist(err) {
			return false, nil
		}
		return false, fmt.Errorf("failed to load %s file: %w", addNodesParamsFile, err)
	}

	params := &Params{}
	if err = json.Unmarshal(file.Data, params); err != nil {
		return false, fmt.Errorf("failed to unmarshal %s: %w", addNodesParamsFile, err)
	}
	a.Params = *params

	// Load nodes-config.yaml file.
	file, err = f.FetchByName(nodesConfigFilename)
	if err != nil {
		return false, fmt.Errorf("failed to load %s file: %w", nodesConfigFilename, err)
	}

	config := Config{}
	if err = yaml.Unmarshal(file.Data, &config); err != nil {
		return false, fmt.Errorf("failed to unmarshal %s: %w", nodesConfigFilename, err)
	}
	a.Config = config

	err = a.finish()
	if err != nil {
		return false, err
	}
	return true, nil
}

func (a *AddNodesConfig) finish() error {
	allErrs := field.ErrorList{}

	if err := a.validateHosts(); err != nil {
		allErrs = append(allErrs, err...)
	}
	if err := a.validateSSHKey(); err != nil {
		allErrs = append(allErrs, err...)
	}

	return allErrs.ToAggregate()
}

func (a *AddNodesConfig) validateHosts() field.ErrorList {
	var allErrs field.ErrorList

	if len(a.Config.Hosts) == 0 {
		fieldPath := field.NewPath("hosts")
		allErrs = append(allErrs, field.Required(fieldPath, "at least one host must be defined"))
	}

	return allErrs
}

func (a *AddNodesConfig) validateSSHKey() field.ErrorList {
	var allErrs field.ErrorList

	if a.Config.SSHKey == "" {
		return nil
	}

	if err := validate.SSHPublicKey(a.Config.SSHKey); err != nil {
		allErrs = append(allErrs, field.Invalid(field.NewPath("sshKey"), a.Config.SSHKey, err.Error()))
	}
	return allErrs
}
