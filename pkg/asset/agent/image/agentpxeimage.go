package image

import (
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"os"
	"path/filepath"

	"github.com/diskfs/go-diskfs/filesystem"
	"github.com/sirupsen/logrus"

	"github.com/openshift/assisted-image-service/pkg/isoeditor"
	"github.com/openshift/installer/pkg/asset"
)

const (
	initrdimg = "initrd.img"
	rootfsimg = "rootfs.img"
	vmlinuz   = "vmlinuz"
	// pxeAssetsPath is the path where pxe files are created.
	pxeAssetsPath = "pxe"
)

// AgentPXEFiles is an asset that generates the bootable image used to install clusters.
type AgentPXEFiles struct {
	imageReader isoeditor.ImageReader
}

var _ asset.WritableAsset = (*AgentPXEFiles)(nil)

// Dependencies returns the assets on which the AgentPXEFiles asset depends.
func (a *AgentPXEFiles) Dependencies() []asset.Asset {
	return []asset.Asset{
		&Ignition{},
		&BaseIso{},
	}
}

// Generate generates the image files for PXE asset.
func (a *AgentPXEFiles) Generate(dependencies asset.Parents) error {
	ignition := &Ignition{}
	dependencies.Get(ignition)

	baseImage := &BaseIso{}
	dependencies.Get(baseImage)

	isoGetter := newGetIso(GetIsoPluggable)
	isoPath, err := isoGetter.getter()
	if err != nil {
		return err
	}

	tmpdir, err := os.MkdirTemp("", "pxe")
	if err != nil {
		return err
	}
	defer os.RemoveAll(tmpdir)

	os.RemoveAll(pxeAssetsPath)

	err = os.Mkdir(pxeAssetsPath, 0644)
	if err != nil {
		return err
	}

	srcfilename := fmt.Sprintf("images/pxeboot/%s", initrdimg)
	dstfilename := filepath.Join(tmpdir, initrdimg)
	err = a.extractPXEFileFromISO(isoPath, srcfilename, dstfilename)
	if err != nil {
		return err
	}

	srcfilename = fmt.Sprintf("images/pxeboot/%s", rootfsimg)
	dstfilename = filepath.Join(pxeAssetsPath, rootfsimg)
	err = a.extractPXEFileFromISO(isoPath, srcfilename, dstfilename)
	if err != nil {
		return err
	}

	srcfilename = fmt.Sprintf("images/pxeboot/%s", vmlinuz)
	dstfilename = filepath.Join(pxeAssetsPath, vmlinuz)
	err = a.extractPXEFileFromISO(isoPath, srcfilename, dstfilename)
	if err != nil {
		return err
	}

	ignitionByte, err := json.Marshal(ignition.Config)
	if err != nil {
		return err
	}

	ignitionContent := &isoeditor.IgnitionContent{Config: ignitionByte}

	fname := filepath.Join(tmpdir, initrdimg)
	custom, err := isoeditor.NewInitRamFSStreamReader(fname, ignitionContent)
	if err != nil {
		return err
	}

	a.imageReader = custom

	return nil
}

// PersistToFile writes the PXE assets in the assets folder named pxe
func (a *AgentPXEFiles) PersistToFile(directory string) error {
	// If the imageReader is not set then it means that either one of the AgentPXEFiles
	// dependencies or the asset itself failed for some reason
	if a.imageReader == nil {
		return errors.New("cannot generate PXE assets due to configuration errors")
	}

	defer a.imageReader.Close()

	agentInitrdFile := filepath.Join(pxeAssetsPath, fmt.Sprintf("agent-%s", initrdimg))
	output, err := os.Create(agentInitrdFile)
	if err != nil {
		return err
	}
	defer output.Close()

	_, err = io.Copy(output, a.imageReader)
	if err != nil {
		return err
	}

	logrus.Info("Created PXE files in pxe directory")

	return nil
}

// Name returns the human-friendly name of the asset.
func (a *AgentPXEFiles) Name() string {
	return "Agent Installer PXE Files"
}

// Load returns the PXE image from disk.
func (a *AgentPXEFiles) Load(f asset.FileFetcher) (bool, error) {
	// The PXE image will not be needed by another asset so load is noop.
	// This is implemented because it is required by WritableAsset
	return false, nil
}

// Files returns the files generated by the asset.
func (a *AgentPXEFiles) Files() []*asset.File {
	// Return empty array because File will never be loaded.
	return []*asset.File{}
}

func (a *AgentPXEFiles) extractPXEFileFromISO(isoPath string, srcfilename string, dstfilename string) error {

	fileReader, err := isoeditor.GetFileFromISO(isoPath, srcfilename)
	if err != nil {
		return err
	}
	defer fileReader.Close()

	err = a.copy(dstfilename, fileReader)
	if err != nil {
		return err
	}
	return nil

}

func (a *AgentPXEFiles) copy(filepath string, fileReader filesystem.File) error {
	output, err := os.Create(filepath)
	if err != nil {
		return err
	}
	defer output.Close()

	_, err = io.Copy(output, fileReader)
	if err != nil {
		return err
	}
	return nil
}
