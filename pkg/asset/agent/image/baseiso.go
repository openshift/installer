package image

import (
	"context"
	"fmt"
	"os"

	"github.com/coreos/stream-metadata-go/stream"
	"github.com/pkg/errors"
	"github.com/sirupsen/logrus"

	"github.com/openshift/installer/pkg/asset"
	"github.com/openshift/installer/pkg/asset/agent"
	"github.com/openshift/installer/pkg/asset/agent/joiner"
	"github.com/openshift/installer/pkg/asset/agent/manifests"
	"github.com/openshift/installer/pkg/asset/agent/mirror"
	"github.com/openshift/installer/pkg/asset/agent/workflow"
	"github.com/openshift/installer/pkg/asset/rhcos"
)

// BaseIso generates the base ISO file for the image
type BaseIso struct {
	File      *asset.File
	ocRelease rhcos.ReleasePayload
}

var (
	baseIsoFilename = ""
)

var _ asset.WritableAsset = (*BaseIso)(nil)

// Name returns the human-friendly name of the asset.
func (i *BaseIso) Name() string {
	return "Base ISO Image"
}

// Fetch RootFS URL using the rhcos.json.
func (i *BaseIso) getRootFSURL(ctx context.Context, archName string, agentWorkflow *workflow.AgentWorkflow, clusterInfo *joiner.ClusterInfo) (string, error) {
	metal, err := rhcos.GetMetalArtifact(
		ctx, archName, customStreamGetter(agentWorkflow, clusterInfo))
	if err != nil {
		return "", err
	}

	if format, ok := metal.Formats["pxe"]; ok {
		rootFSUrl := format.Rootfs.Location
		return rootFSUrl, nil
	}

	return "", fmt.Errorf("no RootFSURL found for %s", archName)
}

// Dependencies returns dependencies used by the asset.
func (i *BaseIso) Dependencies() []asset.Asset {
	return []asset.Asset{
		&workflow.AgentWorkflow{},
		&joiner.ClusterInfo{},
		&manifests.AgentManifests{},
		&agent.OptionalInstallConfig{},
		&mirror.RegistriesConf{},
	}
}

// Generate the baseIso
func (i *BaseIso) Generate(ctx context.Context, dependencies asset.Parents) error {
	agentManifests := &manifests.AgentManifests{}
	registriesConf := &mirror.RegistriesConf{}
	agentWorkflow := &workflow.AgentWorkflow{}
	clusterInfo := &joiner.ClusterInfo{}
	dependencies.Get(agentManifests, registriesConf, agentWorkflow, clusterInfo)

	baseIsoFileName, err := rhcos.NewBaseISOFetcher(
		i.getRelease(agentManifests, registriesConf),
		customStreamGetter(agentWorkflow, clusterInfo)).GetBaseISOFilename(ctx, agentManifests.InfraEnv.Spec.CpuArchitecture)

	if err == nil {
		logrus.Debugf("Using base ISO image %s", baseIsoFileName)
		i.File = &asset.File{Filename: baseIsoFileName}
		return nil
	}
	logrus.Debugf("Failed to download base ISO: %s", err)

	return errors.Wrap(err, "failed to get base ISO image")
}

func customStreamGetter(agentWorkflow *workflow.AgentWorkflow, clusterInfo *joiner.ClusterInfo) rhcos.CoreOSBuildFetcher {
	if agentWorkflow.Workflow == workflow.AgentWorkflowTypeAddNodes {
		return func(ctx context.Context) (*stream.Stream, error) {
			return clusterInfo.OSImage, nil
		}
	}
	return nil
}

func (i *BaseIso) getRelease(agentManifests *manifests.AgentManifests, registriesConf *mirror.RegistriesConf) rhcos.ReleasePayload {
	if i.ocRelease != nil {
		return i.ocRelease
	}

	if agentManifests.ClusterImageSet == nil {
		return nil
	}

	releaseImage := agentManifests.ClusterImageSet.Spec.ReleaseImage
	pullSecret := agentManifests.GetPullSecretData()

	i.ocRelease = rhcos.NewReleasePayload(
		rhcos.ExtractConfig{},
		releaseImage, pullSecret, registriesConf)

	return i.ocRelease
}

// Files returns the files generated by the asset.
func (i *BaseIso) Files() []*asset.File {

	if i.File != nil {
		return []*asset.File{i.File}
	}
	return []*asset.File{}
}

// Load returns the cached baseIso
func (i *BaseIso) Load(f asset.FileFetcher) (bool, error) {

	if baseIsoFilename == "" {
		return false, nil
	}

	baseIso, err := f.FetchByName(baseIsoFilename)
	if err != nil {
		if os.IsNotExist(err) {
			return false, nil
		}
		return false, errors.Wrap(err, fmt.Sprintf("failed to load %s file", baseIsoFilename))
	}

	i.File = baseIso
	return true, nil
}
