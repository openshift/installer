package configimage

import (
	"bytes"
	"context"
	"fmt"
	"os"
	"path/filepath"
	"text/template"
	_ "embed"

	"github.com/openshift/installer/pkg/asset"
)

//go:embed containerfile.template
var containerfileTemplate string

//go:embed tmpfiles.d/link-cluster-config.conf
var linkClusterConfig string

//go:embed tmpfiles.d/link-seed.conf
var linkSeed string

const (
	containerfileFilename = "Containerfile"
)

// Containerfile is an asset that generates a Containerfile that can be used to
// build the final bootable container image.
type Containerfile struct {
	clusterConfig        *ClusterConfiguration
	imageDigestMirrorSet *ImageDigestMirrorSet
	extraManifests       *ExtraManifests
	seedImage           string
}

var _ asset.WritableAsset = (*Containerfile)(nil)

// Dependencies returns the assets on which the Containerfile asset depends.
func (c *Containerfile) Dependencies() []asset.Asset {
	return []asset.Asset{
		&ClusterConfiguration{},
		&ImageDigestMirrorSet{},
		&ExtraManifests{},
	}
}

// Generate generates the Containerfile content.
func (c *Containerfile) Generate(_ context.Context, dependencies asset.Parents) error {
	// Get and store the dependencies for use in PersistToFile
	c.clusterConfig = &ClusterConfiguration{}
	dependencies.Get(c.clusterConfig)

	c.imageDigestMirrorSet = &ImageDigestMirrorSet{}
	dependencies.Get(c.imageDigestMirrorSet)

	c.extraManifests = &ExtraManifests{}
	dependencies.Get(c.extraManifests)

	return nil
}

// SetSeedImage sets the seed image to use in the Containerfile.
func (c *Containerfile) SetSeedImage(seedImage string) {
	c.seedImage = seedImage
}

// PersistToFile writes the Containerfile and all dependency files in the assets folder.
func (c *Containerfile) PersistToFile(directory string) error {
	if c.seedImage == "" {
		return fmt.Errorf("seed image must be specified")
	}

	// Create necessary directories in target directory
	dirs := []string{
		"cluster-configuration",
		"cluster-configuration/manifests",
		"extra-manifests",
		"tmpfiles.d",
	}
	for _, dir := range dirs {
		if err := os.MkdirAll(filepath.Join(directory, dir), 0755); err != nil {
			return fmt.Errorf("could not create %s directory: %w", dir, err)
		}
	}

	// Write all the files from dependencies to the target directory
	for _, file := range c.clusterConfig.Files() {
		if err := os.WriteFile(filepath.Join(directory, file.Filename), file.Data, 0644); err != nil {
			return fmt.Errorf("failed to write %s: %w", file.Filename, err)
		}
	}

	for _, file := range c.imageDigestMirrorSet.Files() {
		if err := os.WriteFile(filepath.Join(directory, file.Filename), file.Data, 0644); err != nil {
			return fmt.Errorf("failed to write %s: %w", file.Filename, err)
		}
	}

	for _, file := range c.extraManifests.Files() {
		if err := os.WriteFile(filepath.Join(directory, file.Filename), file.Data, 0644); err != nil {
			return fmt.Errorf("failed to write %s: %w", file.Filename, err)
		}
	}

	// Write tmpfiles.d configurations
	if err := os.WriteFile(filepath.Join(directory, "tmpfiles.d", "link-cluster-config.conf"), []byte(linkClusterConfig), 0644); err != nil {
		return fmt.Errorf("failed to write link-cluster-config.conf: %w", err)
	}
	if err := os.WriteFile(filepath.Join(directory, "tmpfiles.d", "link-seed.conf"), []byte(linkSeed), 0644); err != nil {
		return fmt.Errorf("failed to write link-seed.conf: %w", err)
	}

	// Parse and execute the template
	tmpl, err := template.New("containerfile").Parse(containerfileTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse containerfile template: %w", err)
	}

	var containerfileContent bytes.Buffer
	if err := tmpl.Execute(&containerfileContent, struct {
		SeedImage string
	}{
		SeedImage: c.seedImage,
	}); err != nil {
		return fmt.Errorf("failed to execute containerfile template: %w", err)
	}

	// Write the generated Containerfile
	containerfilePath := filepath.Join(directory, containerfileFilename)
	if err := os.WriteFile(containerfilePath, containerfileContent.Bytes(), 0644); err != nil {
		return fmt.Errorf("failed to write Containerfile: %w", err)
	}

	return nil
}

// Name returns the human-friendly name of the asset.
func (c *Containerfile) Name() string {
	return "Image-based Installer Containerfile"
}

// Load returns the Containerfile from disk.
func (c *Containerfile) Load(f asset.FileFetcher) (bool, error) {
	// The Containerfile will not be needed by another asset so load is noop.
	// This is implemented because it is required by WritableAsset
	return false, nil
}

// Files returns the files generated by the asset.
func (c *Containerfile) Files() []*asset.File {
	// Return empty array because File will never be loaded.
	return []*asset.File{}
}
