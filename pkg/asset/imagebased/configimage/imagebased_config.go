package configimage

import (
	"context"
	"fmt"
	"os"
	"path/filepath"

	"github.com/sirupsen/logrus"
	"k8s.io/apimachinery/pkg/util/validation/field"
	"sigs.k8s.io/yaml"

	"github.com/openshift/installer/pkg/asset"
	"github.com/openshift/installer/pkg/asset/agent/manifests/staticnetworkconfig"
	"github.com/openshift/installer/pkg/types/imagebased"
	"github.com/openshift/installer/pkg/validate"
)

const (
	imageBasedConfigFilename = "image-based-config.yaml"
)

// ImageBasedConfig reads the image-based-config.yaml file.
type ImageBasedConfig struct {
	File     *asset.File
	Config   *imagebased.Config
	Template string
}

var _ asset.WritableAsset = (*ImageBasedConfig)(nil)

// Name returns a human friendly name for the asset.
func (*ImageBasedConfig) Name() string {
	return "Image-based Config ISO configuration"
}

// Dependencies returns all of the dependencies directly needed to generate
// the asset.
func (*ImageBasedConfig) Dependencies() []asset.Asset {
	return []asset.Asset{}
}

// Generate generates the Image-based Config manifest.
func (i *ImageBasedConfig) Generate(_ context.Context, dependencies asset.Parents) error {
	imageBasedConfigTemplate := `#
# Note: This is a sample ImageBasedConfig file showing
# which fields are available to aid you in creating your
# own image-based-config.yaml file.
#
apiVersion: v1beta1
kind: ImageBasedConfig
metadata:
  name: example-image-based-config
additionalNTPSources:
  - 0.rhel.pool.ntp.org
  - 1.rhel.pool.ntp.org
hostname: change-to-hostname
releaseRegistry: quay.io
# networkConfig contains the network configuration for the host in NMState format.
# See https://nmstate.io/examples.html for examples.
networkConfig:
  interfaces:
    - name: eth0
      type: ethernet
      state: up
      mac-address: 00:00:00:00:00:00
      ipv4:
        enabled: true
        address:
          - ip: 192.168.122.2
            prefix-length: 23
        dhcp: false
`

	i.Template = imageBasedConfigTemplate

	// Set the File field correctly with the generated image-based install config YAML content
	i.File = &asset.File{
		Filename: imageBasedConfigFilename,
		Data:     []byte(i.Template),
	}

	return nil
}

// PersistToFile writes the image-based-config.yaml file to the assets folder.
func (i *ImageBasedConfig) PersistToFile(directory string) error {
	templatePath := filepath.Join(directory, imageBasedConfigFilename)
	templateByte := []byte(i.Template)

	err := os.WriteFile(templatePath, templateByte, 0o600)
	if err != nil {
		return err
	}

	return nil
}

// Files returns the files generated by the asset.
func (i *ImageBasedConfig) Files() []*asset.File {
	if i.File != nil {
		return []*asset.File{i.File}
	}
	return []*asset.File{}
}

// Load returns the image-based config asset from the disk.
func (i *ImageBasedConfig) Load(f asset.FileFetcher) (bool, error) {
	file, err := f.FetchByName(imageBasedConfigFilename)
	if err != nil {
		if os.IsNotExist(err) {
			return false, nil
		}
		return false, fmt.Errorf("failed to load %s file: %w", imageBasedConfigFilename, err)
	}

	config := &imagebased.Config{}
	if err := yaml.UnmarshalStrict(file.Data, config); err != nil {
		return false, fmt.Errorf("failed to unmarshal %s: %w", imageBasedConfigFilename, err)
	}

	i.File, i.Config = file, config

	if err = i.finish(); err != nil {
		return false, err
	}

	return true, nil
}

func (i *ImageBasedConfig) finish() error {
	if err := i.validateImageBasedConfig().ToAggregate(); err != nil {
		return fmt.Errorf("invalid Image-based Config configuration: %w", err)
	}
	return nil
}

func (i *ImageBasedConfig) validateImageBasedConfig() field.ErrorList {
	var allErrs field.ErrorList

	if err := i.validateAdditionalNTPSources(); err != nil {
		allErrs = append(allErrs, err...)
	}

	if err := i.validateNetworkConfig(); err != nil {
		allErrs = append(allErrs, err...)
	}

	return allErrs
}

func (i *ImageBasedConfig) validateNetworkConfig() field.ErrorList {
	var allErrs field.ErrorList

	// empty NetworkConfig is fine
	if i.Config.NetworkConfig.String() == "" {
		return nil
	}

	networkConfig := field.NewPath("networkConfig")

	staticNetworkConfigGenerator := staticnetworkconfig.New(logrus.StandardLogger(), staticnetworkconfig.Config{MaxConcurrentGenerations: 2})

	// Validate the network config using nmstatectl
	if err := staticNetworkConfigGenerator.ValidateNMStateYaml(context.Background(), i.Config.NetworkConfig.String()); err != nil {
		allErrs = append(allErrs, field.Invalid(networkConfig, i.Config.NetworkConfig, err.Error()))
	}

	return allErrs
}

func (i *ImageBasedConfig) validateAdditionalNTPSources() field.ErrorList {
	var allErrs field.ErrorList

	additionalNTPSourcesPath := field.NewPath("additionalNTPSources")

	for i, source := range i.Config.AdditionalNTPSources {
		if domainNameErr := validate.DomainName(source, true); domainNameErr != nil {
			if ipErr := validate.IP(source); ipErr != nil {
				allErrs = append(allErrs, field.Invalid(additionalNTPSourcesPath.Index(i), source, "NTP source is not a valid domain name nor a valid IP"))
			}
		}
	}

	return allErrs
}
