package configimage

import (
	"context"
	"fmt"
	"os"
	"path/filepath"

	"github.com/openshift/assisted-image-service/pkg/isoeditor"
	"github.com/openshift/installer/pkg/asset"
	"github.com/openshift/installer/pkg/asset/store"
	"github.com/openshift/installer/pkg/types/imagebased"
)

const (
	configImageFilename = "imagebasedconfig.iso"
	configImageLabel    = imagebased.BlockDeviceLabel

	clusterConfigurationDir = "cluster-configuration"
	extraManifestsDir       = "extra-manifests"
)

var (
	manifestsDir = filepath.Join(clusterConfigurationDir, "manifests")
)

// ConfigImage is an asset that generates a configuration ISO that can be used to
// configure image-based installer provisioned hosts.
type ConfigImage struct {
	tmpPath string
}

var _ asset.WritableAsset = (*ConfigImage)(nil)

// Dependencies returns the assets on which the Config asset depends.
func (ci *ConfigImage) Dependencies() []asset.Asset {
	return []asset.Asset{
		&ClusterConfiguration{},
		&ImageDigestSources{},
		&ExtraManifests{},
	}
}

func (ci *ConfigImage) createIsoContent(assetFunction func(asset asset.Asset) error) error {
	tmpPath, err := os.MkdirTemp("", "imagebased")
	if err != nil {
		return fmt.Errorf("could not create temp directory: %w", err)
	}

	ci.tmpPath = tmpPath
	if err := createDirs(tmpPath); err != nil {
		return err
	}

	createFile := func(file *asset.File) error {
		f, err := os.Create(filepath.Join(tmpPath, file.Filename))
		if err != nil {
			return fmt.Errorf("could not create %s: %w", file.Filename, err)
		}
		defer f.Close()

		if _, err := f.Write(file.Data); err != nil {
			return fmt.Errorf("could not write %s: %w", file.Filename, err)
		}
		return nil
	}

	for _, a := range []asset.WritableAsset{
		&ClusterConfiguration{},
		&ImageDigestSources{},
		&ExtraManifests{},
	} {
		if err := assetFunction(a); err != nil {
			return err
		}

		for _, file := range a.Files() {
			if err := createFile(file); err != nil {
				return err
			}
		}
	}
	return nil
}

// Generate generates the configuration image file.
func (ci *ConfigImage) Generate(_ context.Context, dependencies asset.Parents) error {
	assetFunc := func(asset asset.Asset) error {
		dependencies.Get(asset)
		return nil
	}
	if err := ci.createIsoContent(assetFunc); err != nil {
		return err
	}

	return nil
}

// PersistToFile writes the ISO image in the assets folder.
func (ci *ConfigImage) PersistToFile(directory string) error {
	defer os.RemoveAll(ci.tmpPath)

	// If the tmpPath is not set then possibly we started with clean folder that has only openshift state file
	// this case is part of IBFF flow, when we need to recreate iso from state file
	if ci.tmpPath == "" {
		astore, err := store.NewStore(directory)
		if err != nil {
			return err
		}

		assetFunc := func(asset asset.Asset) error {
			return astore.Fetch(context.TODO(), asset)
		}
		if err := ci.createIsoContent(assetFunc); err != nil {
			return err
		}
	}

	configImageFile := filepath.Join(directory, configImageFilename)

	// Remove symlink if it exists
	os.Remove(configImageFile)

	err := isoeditor.Create(configImageFile, ci.tmpPath, configImageLabel)
	if err != nil {
		return err
	}

	return nil
}

// Name returns the human-friendly name of the asset.
func (ci *ConfigImage) Name() string {
	return "Image-based Installer Config ISO"
}

// Load returns the ISO from disk.
func (ci *ConfigImage) Load(f asset.FileFetcher) (bool, error) {
	// The ISO will not be needed by another asset so load is noop.
	// This is implemented because it is required by WritableAsset
	return false, nil
}

// Files returns the files generated by the asset.
func (ci *ConfigImage) Files() []*asset.File {
	// Return empty array because File will never be loaded.
	return []*asset.File{}
}

func createDirs(tmpPath string) error {
	dirs := []string{
		clusterConfigurationDir,
		manifestsDir,
		extraManifestsDir,
	}
	for _, dir := range dirs {
		if err := os.MkdirAll(filepath.Join(tmpPath, dir), 0755); err != nil {
			return fmt.Errorf("could not create %s directory: %w", dir, err)
		}
	}
	return nil
}
