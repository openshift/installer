package image

import (
	"context"
	"fmt"
	"os"
	"time"

	"github.com/coreos/stream-metadata-go/arch"
	"github.com/coreos/stream-metadata-go/stream"
	"github.com/sirupsen/logrus"

	"github.com/openshift/installer/pkg/asset"
	"github.com/openshift/installer/pkg/rhcos"
	"github.com/openshift/installer/pkg/rhcos/cache"
	"github.com/openshift/installer/pkg/types"
)

var (
	defaultCoreOSStreamGetter = rhcos.FetchCoreOSBuild
)

// BaseIso generates the base ISO file for the image.
type BaseIso struct {
	File *asset.File

	streamGetter CoreOSBuildFetcher
}

// CoreOSBuildFetcher will be to used to switch the source of the coreos metadata.
type CoreOSBuildFetcher func(ctx context.Context) (*stream.Stream, error)

var _ asset.WritableAsset = (*BaseIso)(nil)

// Name returns the human-friendly name of the asset.
func (i *BaseIso) Name() string {
	return "BaseIso Image"
}

// Dependencies returns dependencies used by the asset.
func (i *BaseIso) Dependencies() []asset.Asset {
	return []asset.Asset{}
}

// Generate generates the base ISO.
func (i *BaseIso) Generate(_ context.Context, dependencies asset.Parents) error {
	var err error
	var baseIsoFileName string

	if urlOverride, ok := os.LookupEnv("OPENSHIFT_INSTALL_OS_IMAGE_OVERRIDE"); ok && urlOverride != "" {
		logrus.Warn("Found override for OS Image. Please be warned, this is not advised.")
		baseIsoFileName, err = cache.DownloadImageFile(urlOverride, cache.ImageBasedApplicationName)
	} else {
		if i.streamGetter == nil {
			i.streamGetter = defaultCoreOSStreamGetter
		}
		// default to the amd64 architecture because the lifecycle-agent CLI is built only for amd64.
		baseIsoFileName, err = i.downloadBaseIso(arch.RpmArch(types.ArchitectureAMD64))
	}

	if err == nil {
		logrus.Debugf("Using base ISO image %s", baseIsoFileName)
		i.File = &asset.File{Filename: baseIsoFileName}
		return nil
	}
	logrus.Debugf("Failed to download base ISO: %s", err)

	return fmt.Errorf("failed to get base ISO image: %w", err)
}

// Files returns the files generated by the asset.
func (i *BaseIso) Files() []*asset.File {
	if i.File != nil {
		return []*asset.File{i.File}
	}
	return []*asset.File{}
}

// Load is not needed, as Generate uses the rhcos/cache to
// either download the base ISO or return the one found in
// the cache directory.
func (i *BaseIso) Load(f asset.FileFetcher) (bool, error) {
	return false, nil
}

// Download the RHCOS base ISO via rhcos.json.
func (i *BaseIso) downloadBaseIso(archName string) (string, error) {
	metal, err := i.metalArtifact(archName)
	if err != nil {
		return "", err
	}

	format, ok := metal.Formats["iso"]
	if !ok {
		return "", fmt.Errorf("no ISO found to download for %s: %w", archName, err)
	}

	url := format.Disk.Location
	sha := format.Disk.Sha256
	cachedImage, err := cache.DownloadImageFileWithSha(url, cache.ImageBasedApplicationName, sha)
	if err != nil {
		return "", fmt.Errorf("failed to download base ISO image %s: %w", url, err)
	}

	return cachedImage, nil
}

func (i *BaseIso) metalArtifact(archName string) (stream.PlatformArtifacts, error) {
	ctx, cancel := context.WithTimeout(context.TODO(), 30*time.Second)
	defer cancel()

	st, err := i.streamGetter(ctx)
	if err != nil {
		return stream.PlatformArtifacts{}, err
	}

	streamArch, err := st.GetArchitecture(archName)
	if err != nil {
		return stream.PlatformArtifacts{}, err
	}

	metal, ok := streamArch.Artifacts["metal"]
	if !ok {
		return stream.PlatformArtifacts{}, fmt.Errorf("coreOs stream data not found for 'metal' artifact")
	}

	return metal, nil
}
