package image

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"os"
	"path/filepath"

	"github.com/sirupsen/logrus"

	"github.com/openshift/assisted-image-service/pkg/isoeditor"
	"github.com/openshift/installer/pkg/asset"
	"github.com/openshift/installer/pkg/types/imagebased"
)

const (
	isoFilename = "rhcos-ibi.iso"
)

// Image is an asset that generates the bootable image used to install clusters.
type Image struct {
	Config       *imagebased.InstallationConfig
	IgnitionByte []byte
	ISOPath      string

	tmpPath string
}

var _ asset.WritableAsset = (*Image)(nil)

// Dependencies returns the assets on which the image asset depends.
func (i *Image) Dependencies() []asset.Asset {
	return []asset.Asset{
		&ImageBasedInstallationConfig{},
		&Ignition{},
		&BaseIso{},
	}
}

// Generate generates the image file for the ISO asset.
func (i *Image) Generate(_ context.Context, dependencies asset.Parents) error {
	installationConfig := &ImageBasedInstallationConfig{}
	baseIso := &BaseIso{}
	ignition := &Ignition{}
	dependencies.Get(installationConfig, baseIso, ignition)

	ignitionByte, err := json.Marshal(ignition.Config)
	if err != nil {
		return err
	}

	i.Config = installationConfig.Config
	i.ISOPath = baseIso.File.Filename
	i.IgnitionByte = ignitionByte

	return nil
}

// PersistToFile writes the ISO image in the assets folder.
func (i *Image) PersistToFile(directory string) error {
	if i.Config == nil || len(i.IgnitionByte) == 0 {
		return fmt.Errorf("could not generate image because of configuration errors")
	}

	// Create a tmp folder to store all the pieces required to generate the image-based installer artifacts.
	tmpPath, err := os.MkdirTemp("", "imagebased")
	if err != nil {
		return err
	}
	i.tmpPath = tmpPath
	if err := os.MkdirAll(i.tmpPath, 0755); err != nil {
		return fmt.Errorf("failed to create temporary directory: %w", err)
	}
	defer os.RemoveAll(i.tmpPath)

	isoFile := filepath.Join(directory, isoFilename)

	// Remove symlink if it exists.
	os.Remove(isoFile)

	ignitionc := &isoeditor.IgnitionContent{}
	ignitionc.Config = i.IgnitionByte
	reader, err := isoeditor.NewRHCOSStreamReader(i.ISOPath, ignitionc, nil, nil)
	if err != nil {
		return fmt.Errorf("failed to create reader for RHCOS base ISO: %w", err)
	}
	logrus.Info("Creating Image-based Installation ISO with embedded ignition")

	file, err := os.Create(isoFile)
	if err != nil {
		return fmt.Errorf("failed to create Image-based Installation ISO file: %w", err)
	}
	defer file.Close()

	if _, err := io.Copy(file, reader); err != nil {
		return fmt.Errorf("failed to copy reader to file: %w", err)
	}

	if err := file.Sync(); err != nil {
		return fmt.Errorf("failed to sync file: %w", err)
	}

	return nil
}

// Files returns the files generated by the asset.
func (i *Image) Files() []*asset.File {
	// Return empty array because File will never be loaded.
	return []*asset.File{}
}

// Load returns the ISO from disk.
func (i *Image) Load(f asset.FileFetcher) (bool, error) {
	// The ISO will not be needed by another asset so load is noop.
	// This is implemented because it is required by WritableAsset
	return false, nil
}

// Name returns the human-friendly name of the asset.
func (i *Image) Name() string {
	return "Image-based Installation ISO"
}
