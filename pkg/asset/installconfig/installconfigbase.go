package installconfig

import (
	"encoding/json"
	"os"
	"strings"

	"github.com/pkg/errors"
	"github.com/sirupsen/logrus"
	"sigs.k8s.io/yaml"

	"github.com/openshift/installer/pkg/asset"
	"github.com/openshift/installer/pkg/types"
	"github.com/openshift/installer/pkg/types/conversion"
	"github.com/openshift/installer/pkg/types/defaults"
	"github.com/openshift/installer/pkg/types/powervc"
)

// AssetBase is the base structure for the separate InstallConfig assets used
// in the agent-based and IPI/UPI installation methods.
type AssetBase struct {
	Config *types.InstallConfig `json:"config"`
	File   *asset.File          `json:"file"`
}

// Files returns the files generated by the asset.
func (a *AssetBase) Files() []*asset.File {
	if a.File != nil {
		return []*asset.File{a.File}
	}
	return []*asset.File{}
}

// Name returns the human-friendly name of the asset.
func (a *AssetBase) Name() string {
	return "Install Config"
}

// try and unmarshal the install config strictly.
func unmarshalInstallConfig(data []byte, config *types.InstallConfig) (bool, error) {
	if err := yaml.UnmarshalStrict(data, config, yaml.DisallowUnknownFields); err != nil {
		err = errors.Wrapf(err, "failed to unmarshal %s", installConfigFilename)
		if !strings.Contains(err.Error(), "unknown field") {
			return false, errors.Wrap(err, asset.InstallConfigError)
		}
		err = errors.Wrapf(err, "failed to parse first occurrence of unknown field")
		logrus.Warnf("%s", err.Error())
		logrus.Info("Attempting to unmarshal while ignoring unknown keys because strict unmarshaling failed")
		if err = yaml.Unmarshal(data, config); err != nil {
			err = errors.Wrapf(err, "failed to unmarshal %s", installConfigFilename)
			return false, errors.Wrap(err, asset.InstallConfigError)
		}
	}

	return false, nil
}

// process an unmarshalled JSON array structure by finding every map element.
func replacePlatformArray(node []interface{}) error {
	for _, value := range node {
		if mapChild, ok := value.(map[string]any); ok {
			if err := replacePlatformMap(mapChild); err != nil {
				return err
			}
		}
	}

	return nil
}

// process an unmarshalled JSON map structure by finding every platform element, and replacing the powervc
// child element with an openstack element.
func replacePlatformMap(node map[string]any) error {
	for k, v := range node {
		switch value := v.(type) {
		case map[string]any:
			if k == "platform" {
				nodePowerVC, ok := value["powervc"]
				if ok {
					value["openstack"] = nodePowerVC
					delete(value, "powervc")
				} else {
					return errors.New("could not convert powervc in the json")
				}

				continue
			}

			if err := replacePlatformMap(value); err != nil {
				return err
			}
		case []interface{}:
			if err := replacePlatformArray(value); err != nil {
				return err
			}
		}
	}

	return nil
}

// LoadFromFile returns the installconfig from disk.
func (a *AssetBase) LoadFromFile(f asset.FileFetcher) (found bool, err error) {
	file, err := f.FetchByName(installConfigFilename)
	if err != nil {
		if os.IsNotExist(err) {
			return false, nil
		}
		return false, errors.Wrap(err, asset.InstallConfigError)
	}

	config := &types.InstallConfig{}
	if found, err := unmarshalInstallConfig(file.Data, config); err != nil {
		return found, err
	}
	a.Config = config

	if config.Platform.Name() == powervc.Name {
		var jsonInstallConfig map[string]any

		jsonOldData, err := yaml.YAMLToJSON(file.Data)
		if err != nil {
			return false, errors.Wrap(err, "could not convert yaml to json")
		}
		err = json.Unmarshal(jsonOldData, &jsonInstallConfig)
		if err != nil {
			return false, errors.Wrap(err, "could not unmarshal the json")
		}
		err = replacePlatformMap(jsonInstallConfig)
		if err != nil {
			return false, errors.Wrap(err, "could not replacePlatformMap the json")
		}
		jsonNewData, err := json.Marshal(jsonInstallConfig)
		if err != nil {
			return false, errors.Wrap(err, "could not marshal the json")
		}
		newFileData, err := yaml.JSONToYAML(jsonNewData)
		if err != nil {
			return false, errors.Wrap(err, "could not convert json to yaml")
		}
		newConfig := &types.InstallConfig{}
		if found, err = unmarshalInstallConfig(newFileData, newConfig); err != nil {
			return found, err
		}
		config.Platform.OpenStack = newConfig.Platform.OpenStack
		config.ControlPlane.Platform.OpenStack = newConfig.ControlPlane.Platform.OpenStack
		for idx := range config.Compute {
			config.Compute[idx].Platform.OpenStack = newConfig.Compute[idx].Platform.OpenStack
		}
		a.Config = config
	}

	// Upconvert any deprecated fields
	if err := conversion.ConvertInstallConfig(a.Config); err != nil {
		return false, errors.Wrap(errors.Wrap(err, "failed to upconvert install config"), asset.InstallConfigError)
	}

	defaults.SetInstallConfigDefaults(a.Config)

	return true, nil
}

// RecordFile generates the asset manifest file from the config CR.
func (a *AssetBase) RecordFile() error {
	data, err := yaml.Marshal(a.Config)
	if err != nil {
		return errors.Wrap(err, "failed to Marshal InstallConfig")
	}
	a.File = &asset.File{
		Filename: installConfigFilename,
		Data:     data,
	}
	return nil
}
