package installconfig

import (
	"net"

	"github.com/apparentlymart/go-cidr/cidr"
	"github.com/ghodss/yaml"
	"github.com/pkg/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"

	"github.com/openshift/installer/pkg/asset"
	"github.com/openshift/installer/pkg/ipnet"
	"github.com/openshift/installer/pkg/types"
)

const (
	installConfigFilename = "install-config.yml"
)

var (
	defaultServiceCIDR = parseCIDR("10.3.0.0/16")
	defaultPodCIDR     = parseCIDR("10.2.0.0/16")
)

// InstallConfig generates the install-config.yml file.
type InstallConfig struct {
	Config *types.InstallConfig
	file   *asset.File
}

var _ asset.WritableAsset = (*InstallConfig)(nil)

// Dependencies returns all of the dependencies directly needed by an
// InstallConfig asset.
func (a *InstallConfig) Dependencies() []asset.Asset {
	return []asset.Asset{
		&clusterID{},
		&emailAddress{},
		&password{},
		&sshPublicKey{},
		&baseDomain{},
		&clusterName{},
		&pullSecret{},
		&platform{},
	}
}

// Generate generates the install-config.yml file.
func (a *InstallConfig) Generate(parents asset.Parents) error {
	clusterID := &clusterID{}
	emailAddress := &emailAddress{}
	password := &password{}
	sshPublicKey := &sshPublicKey{}
	baseDomain := &baseDomain{}
	clusterName := &clusterName{}
	pullSecret := &pullSecret{}
	platform := &platform{}
	parents.Get(
		clusterID,
		emailAddress,
		password,
		sshPublicKey,
		baseDomain,
		clusterName,
		pullSecret,
		platform,
	)

	a.Config = &types.InstallConfig{
		ObjectMeta: metav1.ObjectMeta{
			Name: clusterName.clusterName,
		},
		ClusterID: clusterID.clusterID,
		Admin: types.Admin{
			Email:    emailAddress.emailAddress,
			Password: password.password,
			SSHKey:   sshPublicKey.key,
		},
		BaseDomain: baseDomain.baseDomain,
		Networking: types.Networking{
			// TODO(yifan): Flannel is the temporal default network type for now,
			// Need to update it to the new types.
			Type: "flannel",

			ServiceCIDR: ipnet.IPNet{
				IPNet: defaultServiceCIDR,
			},
			PodCIDR: ipnet.IPNet{
				IPNet: defaultPodCIDR,
			},
		},
		PullSecret: pullSecret.pullSecret,
	}

	numberOfMasters := int64(3)
	numberOfWorkers := int64(3)
	switch {
	case platform.aws != nil:
		a.Config.AWS = platform.aws
	case platform.openstack != nil:
		a.Config.OpenStack = platform.openstack
	case platform.libvirt != nil:
		a.Config.Libvirt = platform.libvirt
		a.Config.Libvirt.Network.Name = clusterName.clusterName
		numberOfMasters = 1
		numberOfWorkers = 1
	default:
		panic("unknown platform type")
	}

	a.Config.Machines = []types.MachinePool{
		{
			Name:     "master",
			Replicas: func(x int64) *int64 { return &x }(numberOfMasters),
		},
		{
			Name:     "worker",
			Replicas: func(x int64) *int64 { return &x }(numberOfWorkers),
		},
	}

	data, err := yaml.Marshal(a.Config)
	if err != nil {
		return errors.Wrap(err, "failed to Marshal InstallConfig")
	}
	a.file = &asset.File{
		Filename: "install-config.yml",
		Data:     data,
	}

	return nil
}

// Name returns the human-friendly name of the asset.
func (a *InstallConfig) Name() string {
	return "Install Config"
}

// Files returns the files generated by the asset.
func (a *InstallConfig) Files() []*asset.File {
	if a.file != nil {
		return []*asset.File{a.file}
	}
	return []*asset.File{}
}

// ClusterDNSIP returns the string representation of the DNS server's IP
// address.
func ClusterDNSIP(installConfig *types.InstallConfig) (string, error) {
	ip, err := cidr.Host(&installConfig.ServiceCIDR.IPNet, 10)
	if err != nil {
		return "", err
	}

	return ip.String(), nil
}

func parseCIDR(s string) net.IPNet {
	_, cidr, _ := net.ParseCIDR(s)
	return *cidr
}
