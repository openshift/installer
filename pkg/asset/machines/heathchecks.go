package machines

import (
	"fmt"
	"path/filepath"

	"github.com/ghodss/yaml"
	"github.com/pkg/errors"
	"github.com/sirupsen/logrus"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"

	"github.com/openshift/installer/pkg/asset"
)

// Begin FIXME: lazy, should vendor github.com/openshift/machine-api-operator/pkg/apis/healthchecking/v1beta1

// MachineHealthCheck FIXME
type MachineHealthCheck struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              MachineHealthCheckSpec `json:"spec,omitempty"`
}

// MachineHealthCheckSpec FIXME
type MachineHealthCheckSpec struct {
	Selector            metav1.LabelSelector `json:"selector"`
	UnhealthyConditions []UnhealthyCondition `json:"unhealthyConditions"`
}

// UnhealthyCondition FIXME
type UnhealthyCondition struct {
	Type    corev1.NodeConditionType `json:"type"`
	Status  corev1.ConditionStatus   `json:"status"`
	Timeout string                   `json:"timeout"`
}

// End FIXME

const (
	// healthCheckFileName is the format string for constructing the health-check filenames.
	healthCheckFileName = "99_openshift-cluster-api-health-check-%s.yaml"
)

var (
	healthCheckFileNamePattern = fmt.Sprintf(healthCheckFileName, "*")

	_ asset.WritableAsset = (*HealthChecks)(nil)
)

// HealthChecks generates MachineHealthChecks for configured machine pools.
type HealthChecks struct {
	Manifests []*asset.File
}

// Name returns a human friendly name for the asset.
func (a *HealthChecks) Name() string {
	return "Machine Health Checks"
}

// Dependencies returns all of the dependencies directly needed by the asset.
func (a *HealthChecks) Dependencies() []asset.Asset {
	return []asset.Asset{
		&Worker{},
	}
}

// Generate generates the asset.
func (a *HealthChecks) Generate(dependencies asset.Parents) error {
	worker := &Worker{}
	dependencies.Get(worker)

	roles := map[string]struct{}{}
	exists := struct{}{}
	machineSets, err := worker.MachineSets()
	if err != nil {
		return err
	}

	label := "machine.openshift.io/cluster-api-machine-role"
	for _, machineSet := range machineSets {
		role := machineSet.Spec.Template.ObjectMeta.Labels[label]
		if role == "" {
			logrus.Warnf("no role found for machine set %q", machineSet.ObjectMeta.Name)
		} else {
			roles[role] = exists
		}
	}

	unhealthyConditions := []UnhealthyCondition{
		{
			Type:    "Ready",
			Status:  "Unknown",
			Timeout: "5m",
		},
		{
			Type:    "Ready",
			Status:  "False",
			Timeout: "10m",
		},
	}

	a.Manifests = make([]*asset.File, 0, len(roles))
	for role := range roles {
		selector := metav1.LabelSelector{}
		selector.MatchLabels = make(map[string]string, 1)
		selector.MatchLabels[label] = role

		healthCheck := MachineHealthCheck{
			TypeMeta: metav1.TypeMeta{
				APIVersion: "machine.openshift.io/v1beta1",
				Kind:       "MachineHealthCheck",
			},
			ObjectMeta: metav1.ObjectMeta{
				Name:      role,
				Namespace: "openshift-machine-api",
			},
			Spec: MachineHealthCheckSpec{
				Selector:            selector,
				UnhealthyConditions: unhealthyConditions,
			},
		}

		data, err := yaml.Marshal(healthCheck)
		if err != nil {
			return errors.Wrapf(err, "marshal health check for %q", role)
		}

		a.Manifests = append(a.Manifests, &asset.File{
			Filename: filepath.Join(directory, fmt.Sprintf(healthCheckFileName, role)),
			Data:     data,
		})
	}

	asset.SortFiles(a.Manifests)

	return nil
}

// Files returns the files generated by the asset.
func (a *HealthChecks) Files() []*asset.File {
	return a.Manifests
}

// Load reads the asset files from disk.
func (a *HealthChecks) Load(f asset.FileFetcher) (found bool, err error) {
	fileList, err := f.FetchByPattern(filepath.Join(directory, healthCheckFileNamePattern))
	if err != nil {
		return true, err
	}

	a.Manifests = fileList
	return len(fileList) > 0, nil
}
