package machineconfig

import (
	"encoding/json"
	"strings"
	"testing"

	igntypes "github.com/coreos/ignition/v2/config/v3_2/types"
	"github.com/stretchr/testify/assert"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"

	mcfgv1 "github.com/openshift/api/machineconfiguration/v1"
	"github.com/openshift/installer/pkg/types"
)

// Generated by Cursor

func TestForDiskSetup(t *testing.T) {
	cases := []struct {
		name           string
		role           string
		device         string
		label          string
		path           string
		diskType       types.DiskType
		expectedError  string
		expectedConfig *mcfgv1.MachineConfig
	}{
		{
			name:     "etcd disk setup",
			role:     "master",
			device:   "/dev/sdb",
			label:    "etcd",
			path:     "/var/lib/etcd",
			diskType: types.Etcd,
			expectedConfig: &mcfgv1.MachineConfig{
				TypeMeta: metav1.TypeMeta{
					APIVersion: mcfgv1.SchemeGroupVersion.String(),
					Kind:       "MachineConfig",
				},
				ObjectMeta: metav1.ObjectMeta{
					Name: "01-disk-setup-etcd-master",
					Labels: map[string]string{
						"machineconfiguration.openshift.io/role": "master",
					},
				},
				Spec: mcfgv1.MachineConfigSpec{
					Config: runtime.RawExtension{},
				},
			},
		},
		{
			name:     "user-defined disk setup",
			role:     "worker",
			device:   "/dev/sdc",
			label:    "userdata",
			path:     "/var/lib/userdata",
			diskType: types.UserDefined,
			expectedConfig: &mcfgv1.MachineConfig{
				TypeMeta: metav1.TypeMeta{
					APIVersion: mcfgv1.SchemeGroupVersion.String(),
					Kind:       "MachineConfig",
				},
				ObjectMeta: metav1.ObjectMeta{
					Name: "01-disk-setup-userdata-worker",
					Labels: map[string]string{
						"machineconfiguration.openshift.io/role": "worker",
					},
				},
				Spec: mcfgv1.MachineConfigSpec{
					Config: runtime.RawExtension{},
				},
			},
		},
		{
			name:     "swap disk setup",
			role:     "master",
			device:   "/dev/sdd",
			label:    "swap",
			path:     "",
			diskType: types.Swap,
			expectedConfig: &mcfgv1.MachineConfig{
				TypeMeta: metav1.TypeMeta{
					APIVersion: mcfgv1.SchemeGroupVersion.String(),
					Kind:       "MachineConfig",
				},
				ObjectMeta: metav1.ObjectMeta{
					Name: "01-disk-setup-swap-master",
					Labels: map[string]string{
						"machineconfiguration.openshift.io/role": "master",
					},
				},
				Spec: mcfgv1.MachineConfigSpec{
					Config: runtime.RawExtension{},
				},
			},
		},
		{
			name:     "label with special characters",
			role:     "worker",
			device:   "/dev/sde",
			label:    "etcd-data[123]",
			path:     "/var/lib/etcd",
			diskType: types.Etcd,
			expectedConfig: &mcfgv1.MachineConfig{
				TypeMeta: metav1.TypeMeta{
					APIVersion: mcfgv1.SchemeGroupVersion.String(),
					Kind:       "MachineConfig",
				},
				ObjectMeta: metav1.ObjectMeta{
					Name: "01-disk-setup-etcddata123-worker",
					Labels: map[string]string{
						"machineconfiguration.openshift.io/role": "worker",
					},
				},
				Spec: mcfgv1.MachineConfigSpec{
					Config: runtime.RawExtension{},
				},
			},
		},
		{
			name:     "complex path with slashes",
			role:     "master",
			device:   "/dev/sdf",
			label:    "data",
			path:     "/var/lib/openshift/data",
			diskType: types.UserDefined,
			expectedConfig: &mcfgv1.MachineConfig{
				TypeMeta: metav1.TypeMeta{
					APIVersion: mcfgv1.SchemeGroupVersion.String(),
					Kind:       "MachineConfig",
				},
				ObjectMeta: metav1.ObjectMeta{
					Name: "01-disk-setup-data-master",
					Labels: map[string]string{
						"machineconfiguration.openshift.io/role": "master",
					},
				},
				Spec: mcfgv1.MachineConfigSpec{
					Config: runtime.RawExtension{},
				},
			},
		},
	}

	for _, tc := range cases {
		t.Run(tc.name, func(t *testing.T) {
			machineConfig, err := ForDiskSetup(tc.role, tc.device, tc.label, tc.path, tc.diskType)

			if tc.expectedError != "" {
				assert.Error(t, err)
				assert.Contains(t, err.Error(), tc.expectedError)
				return
			}

			assert.NoError(t, err)
			assert.NotNil(t, machineConfig)

			// Verify basic structure
			assert.Equal(t, tc.expectedConfig.TypeMeta, machineConfig.TypeMeta)
			assert.Equal(t, tc.expectedConfig.ObjectMeta.Name, machineConfig.ObjectMeta.Name)
			assert.Equal(t, tc.expectedConfig.ObjectMeta.Labels, machineConfig.ObjectMeta.Labels)

			// Verify the config is not empty
			assert.NotNil(t, machineConfig.Spec.Config)
			assert.NotEmpty(t, machineConfig.Spec.Config.Raw)

			// For label checks, use the sanitized label as produced by the code
			sanitizedLabel := ""
			switch tc.name {
			case "label with special characters":
				sanitizedLabel = "etcddata123"
			case "user-defined disk setup":
				sanitizedLabel = "userdata"
			case "etcd disk setup":
				sanitizedLabel = "etcd"
			case "complex path with slashes":
				sanitizedLabel = "data"
			case "swap disk setup":
				sanitizedLabel = "swap"
			}

			// Verify specific disk type behavior
			switch tc.diskType {
			case types.Etcd, types.UserDefined:
				assertEtcdUserDefinedConfig(t, machineConfig, tc.device, sanitizedLabel, tc.path)
			case types.Swap:
				assertSwapConfig(t, machineConfig, tc.device, sanitizedLabel)
			}
		})
	}
}

func assertEtcdUserDefinedConfig(t *testing.T, mc *mcfgv1.MachineConfig, device, label, path string) {
	t.Helper()

	// Parse the ignition config to verify disk and filesystem configuration
	ignConfig, err := parseIgnitionConfig(mc.Spec.Config.Raw)
	assert.NoError(t, err)

	// Verify disk configuration
	assert.Len(t, ignConfig.Storage.Disks, 1)
	disk := ignConfig.Storage.Disks[0]
	assert.Equal(t, device, disk.Device)
	assert.Len(t, disk.Partitions, 1)
	assert.Equal(t, label, *disk.Partitions[0].Label)
	assert.Equal(t, int64(0), int64(*disk.Partitions[0].StartMiB))
	assert.Equal(t, int64(0), int64(*disk.Partitions[0].SizeMiB))
	assert.True(t, *disk.WipeTable)

	// Verify filesystem configuration
	assert.Len(t, ignConfig.Storage.Filesystems, 1)
	fs := ignConfig.Storage.Filesystems[0]
	assert.Equal(t, "/dev/disk/by-partlabel/"+label, fs.Device)
	assert.Equal(t, "xfs", *fs.Format)
	assert.Equal(t, label, *fs.Label)
	assert.Equal(t, path, *fs.Path)
	assert.True(t, *fs.WipeFilesystem)
	// MountOptions is []igntypes.MountOption (alias for string), so compare as strings
	mountOpts := make([]string, 0, len(fs.MountOptions))
	for _, opt := range fs.MountOptions {
		mountOpts = append(mountOpts, string(opt))
	}
	assert.Contains(t, mountOpts, "defaults")
	assert.Contains(t, mountOpts, "prjquota")

	// Verify systemd unit
	assert.Len(t, ignConfig.Systemd.Units, 1)
	unit := ignConfig.Systemd.Units[0]
	expectedUnitName := path
	expectedUnitName = strings.Trim(expectedUnitName, "/")
	expectedUnitName = strings.ReplaceAll(expectedUnitName, "/", "-")
	expectedUnitName += ".mount"
	assert.Equal(t, expectedUnitName, unit.Name)
	assert.True(t, *unit.Enabled)
	assert.NotNil(t, unit.Contents)
}

func assertSwapConfig(t *testing.T, mc *mcfgv1.MachineConfig, device, label string) {
	t.Helper()

	// Parse the ignition config to verify disk and filesystem configuration
	ignConfig, err := parseIgnitionConfig(mc.Spec.Config.Raw)
	assert.NoError(t, err)

	// Verify disk configuration
	assert.Len(t, ignConfig.Storage.Disks, 1)
	disk := ignConfig.Storage.Disks[0]
	assert.Equal(t, device, disk.Device)
	assert.Len(t, disk.Partitions, 1)
	assert.Equal(t, label, *disk.Partitions[0].Label)
	assert.Equal(t, int64(0), int64(*disk.Partitions[0].StartMiB))
	assert.Equal(t, int64(0), int64(*disk.Partitions[0].SizeMiB))
	assert.Equal(t, "0657FD6D-A4AB-43C4-84E5-0933C84B4F4F", *disk.Partitions[0].GUID)
	assert.True(t, *disk.WipeTable)

	// Verify filesystem configuration
	assert.Len(t, ignConfig.Storage.Filesystems, 1)
	fs := ignConfig.Storage.Filesystems[0]
	assert.Equal(t, "/dev/disk/by-partlabel/"+label, fs.Device)
	assert.Equal(t, "swap", *fs.Format)
	assert.Equal(t, label, *fs.Label)

	// Verify systemd unit
	assert.Len(t, ignConfig.Systemd.Units, 1)
	unit := ignConfig.Systemd.Units[0]
	assert.Equal(t, "dev-disk-by\\x2dpartlabel-swap.swap", unit.Name)
	assert.True(t, *unit.Enabled)
	assert.NotNil(t, unit.Contents)
}

func TestDiskMountUnit(t *testing.T) {
	cases := []struct {
		name      string
		mountUnit diskMount
		expected  string
	}{
		{
			name: "basic mount unit",
			mountUnit: diskMount{
				MountPath: "/var/lib/etcd",
				Label:     "etcd",
			},
			expected: `[Unit]
Requires=systemd-fsck@dev-disk-by\x2dpartlabel-etcd.service
After=systemd-fsck@dev-disk-by\x2dpartlabel-etcd.service

[Mount]
Where=/var/lib/etcd
What=/dev/disk/by-partlabel/etcd
Type=xfs
Options=defaults,prjquota

[Install]
RequiredBy=local-fs.target
`,
		},
		{
			name: "complex path mount unit",
			mountUnit: diskMount{
				MountPath: "/var/lib/openshift/data",
				Label:     "userdata",
			},
			expected: `[Unit]
Requires=systemd-fsck@dev-disk-by\x2dpartlabel-userdata.service
After=systemd-fsck@dev-disk-by\x2dpartlabel-userdata.service

[Mount]
Where=/var/lib/openshift/data
What=/dev/disk/by-partlabel/userdata
Type=xfs
Options=defaults,prjquota

[Install]
RequiredBy=local-fs.target
`,
		},
	}

	for _, tc := range cases {
		t.Run(tc.name, func(t *testing.T) {
			// Test the template execution by creating a machine config
			// and verifying the generated unit content
			machineConfig, err := ForDiskSetup("test", "/dev/sdb", tc.mountUnit.Label, tc.mountUnit.MountPath, types.Etcd)
			assert.NoError(t, err)

			ignConfig, err := parseIgnitionConfig(machineConfig.Spec.Config.Raw)
			assert.NoError(t, err)

			assert.Len(t, ignConfig.Systemd.Units, 1)
			unit := ignConfig.Systemd.Units[0]
			assert.NotNil(t, unit.Contents)
			assert.Contains(t, *unit.Contents, tc.mountUnit.MountPath)
			assert.Contains(t, *unit.Contents, tc.mountUnit.Label)
		})
	}
}

func TestSwapMountUnit(t *testing.T) {
	cases := []struct {
		name     string
		label    string
		expected string
	}{
		{
			name:  "swap mount unit",
			label: "swap",
			expected: `[Swap]
What=/dev/disk/by-partlabel/swap

[Install]
WantedBy=swap.target
`,
		},
	}

	for _, tc := range cases {
		t.Run(tc.name, func(t *testing.T) {
			// Test the template execution by creating a machine config
			// and verifying the generated unit content
			machineConfig, err := ForDiskSetup("test", "/dev/sdb", tc.label, "", types.Swap)
			assert.NoError(t, err)

			ignConfig, err := parseIgnitionConfig(machineConfig.Spec.Config.Raw)
			assert.NoError(t, err)

			assert.Len(t, ignConfig.Systemd.Units, 1)
			unit := ignConfig.Systemd.Units[0]
			assert.NotNil(t, unit.Contents)
			assert.Contains(t, *unit.Contents, tc.label)
		})
	}
}

func TestLabelSanitization(t *testing.T) {
	cases := []struct {
		name          string
		inputLabel    string
		expectedLabel string
	}{
		{
			name:          "simple label",
			inputLabel:    "etcd",
			expectedLabel: "etcd",
		},
		{
			name:          "label with brackets",
			inputLabel:    "etcd[123]",
			expectedLabel: "etcd123",
		},
		{
			name:          "label with alphanumeric brackets",
			inputLabel:    "data[abc123]",
			expectedLabel: "dataabc123",
		},
		{
			name:          "label with multiple brackets",
			inputLabel:    "disk[1][2][3]",
			expectedLabel: "disk123",
		},
	}

	for _, tc := range cases {
		t.Run(tc.name, func(t *testing.T) {
			machineConfig, err := ForDiskSetup("test", "/dev/sdb", tc.inputLabel, "/var/lib/data", types.Etcd)
			assert.NoError(t, err)

			ignConfig, err := parseIgnitionConfig(machineConfig.Spec.Config.Raw)
			assert.NoError(t, err)

			// Verify the sanitized label is used in the disk partition
			assert.Len(t, ignConfig.Storage.Disks, 1)
			disk := ignConfig.Storage.Disks[0]
			assert.Len(t, disk.Partitions, 1)
			assert.Equal(t, tc.expectedLabel, *disk.Partitions[0].Label)

			// Verify the sanitized label is used in the filesystem
			assert.Len(t, ignConfig.Storage.Filesystems, 1)
			fs := ignConfig.Storage.Filesystems[0]
			assert.Equal(t, "/dev/disk/by-partlabel/"+tc.expectedLabel, fs.Device)
			assert.Equal(t, tc.expectedLabel, *fs.Label)
		})
	}
}

// Helper function to parse ignition config from raw bytes.
func parseIgnitionConfig(raw []byte) (*igntypes.Config, error) {
	ignConfig := &igntypes.Config{}
	err := json.Unmarshal(raw, ignConfig)
	return ignConfig, err
}
