#!/usr/bin/env bash
set -euoE pipefail ## -E option will cause functions to inherit trap

. /usr/local/bin/release-image.sh

mkdir --parents /etc/kubernetes/{manifests,bootstrap-configs,bootstrap-manifests}

ETCD_ENDPOINTS=

bootkube_podman_run() {
    # we run all commands in the host-network to prevent IP conflicts with
    # end-user infrastructure.
    podman run --quiet --net=host "${@}"
}

MACHINE_CONFIG_OPERATOR_IMAGE=$(image_for machine-config-operator)
MACHINE_CONFIG_OSCONTENT=$(image_for machine-os-content)
MACHINE_CONFIG_ETCD_IMAGE=$(image_for etcd)
MACHINE_CONFIG_INFRA_IMAGE=$(image_for pod)

CLUSTER_ETCD_OPERATOR_IMAGE=$(image_for cluster-etcd-operator)
CONFIG_OPERATOR_IMAGE=$(image_for cluster-config-operator)
KUBE_APISERVER_OPERATOR_IMAGE=$(image_for cluster-kube-apiserver-operator)
KUBE_CONTROLLER_MANAGER_OPERATOR_IMAGE=$(image_for cluster-kube-controller-manager-operator)
KUBE_SCHEDULER_OPERATOR_IMAGE=$(image_for cluster-kube-scheduler-operator)
INGRESS_OPERATOR_IMAGE=$(image_for cluster-ingress-operator)

CLOUD_CREDENTIAL_OPERATOR_IMAGE=$(image_for cloud-credential-operator)

OPENSHIFT_HYPERKUBE_IMAGE=$(image_for hyperkube)
OPENSHIFT_CLUSTER_POLICY_IMAGE=$(image_for cluster-policy-controller)

CLUSTER_BOOTSTRAP_IMAGE=$(image_for cluster-bootstrap)

KEEPALIVED_IMAGE=$(image_for keepalived-ipfailover || echo "no-keepalived-image")
COREDNS_IMAGE=$(image_for coredns)
MDNS_PUBLISHER_IMAGE=$(image_for mdns-publisher)
HAPROXY_IMAGE=$(image_for haproxy-router)
BAREMETAL_RUNTIMECFG_IMAGE=$(image_for baremetal-runtimecfg)

mkdir --parents ./{bootstrap-manifests,manifests}

if [ ! -f openshift-manifests.done ]
then
	echo "Moving OpenShift manifests in with the rest of them"
	cp openshift/* manifests/
	touch openshift-manifests.done
fi

if [ ! -f cvo-bootstrap.done ]
then
	echo "Rendering Cluster Version Operator Manifests..."

	rm --recursive --force cvo-bootstrap

	bootkube_podman_run \
		--volume "$PWD:/assets:z" \
		"${RELEASE_IMAGE_DIGEST}" \
		render \
			--output-dir=/assets/cvo-bootstrap \
			--release-image="${RELEASE_IMAGE_DIGEST}"

	cp cvo-bootstrap/bootstrap/* bootstrap-manifests/
	cp cvo-bootstrap/manifests/* manifests/
	## FIXME: CVO should use `/etc/kubernetes/bootstrap-secrets/kubeconfig` instead
	cp auth/kubeconfig-loopback /etc/kubernetes/kubeconfig

	touch cvo-bootstrap.done
fi

ETCD_ENDPOINTS=https://localhost:2379
if [ ! -f etcd-bootstrap.done ]
then
	echo "Rendering CEO Manifests..."
	bootkube_podman_run \
		--volume "$PWD:/assets:z" \
		"${CLUSTER_ETCD_OPERATOR_IMAGE}" \
		/usr/bin/cluster-etcd-operator render \
		--etcd-ca=/assets/tls/etcd-ca-bundle.crt \
		--etcd-ca-key=/assets/tls/etcd-signer.key \
		--manifest-etcd-image="${MACHINE_CONFIG_ETCD_IMAGE}" \
		--etcd-discovery-domain={{.ClusterDomain}} \
		--manifest-cluster-etcd-operator-image="${CLUSTER_ETCD_OPERATOR_IMAGE}" \
		--asset-input-dir=/assets/tls \
		--asset-output-dir=/assets/etcd-bootstrap \
		--config-output-file=/assets/etcd-bootstrap/config \
		--cluster-config-file=/assets/manifests/cluster-network-02-config.yml

	cp etcd-bootstrap/manifests/* manifests/
	cp etcd-bootstrap/bootstrap-manifests/etcd-member-pod.yaml /etc/kubernetes/manifests/

	mkdir --parents /etc/kubernetes/static-pod-resources/etcd-member
	cp tls/etcd-ca-bundle.crt /etc/kubernetes/static-pod-resources/etcd-member/ca.crt
	cp --recursive etcd-bootstrap/bootstrap-manifests/secrets/etcd-all-serving /etc/kubernetes/static-pod-resources/etcd-member
	cp --recursive etcd-bootstrap/bootstrap-manifests/secrets/etcd-all-peer /etc/kubernetes/static-pod-resources/etcd-member

	touch etcd-bootstrap.done
fi

if [ ! -f config-bootstrap.done ]
then
	echo "Rendering cluster config manifests..."

	rm --recursive --force config-bootstrap

	ADDITIONAL_FLAGS=""
	if [ -f "$PWD/manifests/cloud-provider-config.yaml" ]; then
		ADDITIONAL_FLAGS="--cloud-provider-config-input-file=/assets/manifests/cloud-provider-config.yaml"
	fi

	bootkube_podman_run \
		--volume "$PWD:/assets:z" \
		"${CONFIG_OPERATOR_IMAGE}" \
		/usr/bin/cluster-config-operator render \
		--cluster-infrastructure-input-file=/assets/manifests/cluster-infrastructure-02-config.yml \
		--cloud-provider-config-output-file=/assets/config-bootstrap/cloud-provider-config-generated.yaml \
		--config-output-file=/assets/config-bootstrap/config \
		--asset-input-dir=/assets/tls \
		--asset-output-dir=/assets/config-bootstrap \
		${ADDITIONAL_FLAGS}

	cp config-bootstrap/manifests/* manifests/

	touch config-bootstrap.done
fi

if [ ! -f kube-apiserver-bootstrap.done ]
then
	echo "Rendering Kubernetes API server core manifests..."

	rm --recursive --force kube-apiserver-bootstrap

	bootkube_podman_run  \
		--volume "$PWD:/assets:z" \
		"${KUBE_APISERVER_OPERATOR_IMAGE}" \
		/usr/bin/cluster-kube-apiserver-operator render \
		--manifest-etcd-serving-ca=etcd-ca-bundle.crt \
		--manifest-etcd-server-urls="${ETCD_ENDPOINTS}" \
		--manifest-image="${OPENSHIFT_HYPERKUBE_IMAGE}" \
		--manifest-operator-image="${KUBE_APISERVER_OPERATOR_IMAGE}" \
		--asset-input-dir=/assets/tls \
		--asset-output-dir=/assets/kube-apiserver-bootstrap \
		--config-output-file=/assets/kube-apiserver-bootstrap/config \
		--cluster-config-file=/assets/manifests/cluster-network-02-config.yml

	cp kube-apiserver-bootstrap/config /etc/kubernetes/bootstrap-configs/kube-apiserver-config.yaml
	cp kube-apiserver-bootstrap/bootstrap-manifests/* bootstrap-manifests/
	cp kube-apiserver-bootstrap/manifests/* manifests/

	touch kube-apiserver-bootstrap.done
fi

if [ ! -f kube-controller-manager-bootstrap.done ]
then
	echo "Rendering Kubernetes Controller Manager core manifests..."

	rm --recursive --force kube-controller-manager-bootstrap

	bootkube_podman_run \
		--volume "$PWD:/assets:z" \
		"${KUBE_CONTROLLER_MANAGER_OPERATOR_IMAGE}" \
		/usr/bin/cluster-kube-controller-manager-operator render \
		--cluster-policy-controller-image="${OPENSHIFT_CLUSTER_POLICY_IMAGE}" \
		--manifest-image="${OPENSHIFT_HYPERKUBE_IMAGE}" \
		--asset-input-dir=/assets/tls \
		--asset-output-dir=/assets/kube-controller-manager-bootstrap \
		--config-output-file=/assets/kube-controller-manager-bootstrap/config \
		--cpc-config-output-file=/assets/kube-controller-manager-bootstrap/cpc-config \
		--cluster-config-file=/assets/manifests/cluster-network-02-config.yml

	cp kube-controller-manager-bootstrap/config /etc/kubernetes/bootstrap-configs/kube-controller-manager-config.yaml
	cp kube-controller-manager-bootstrap/cpc-config /etc/kubernetes/bootstrap-configs/cluster-policy-controller-config.yaml
	cp kube-controller-manager-bootstrap/bootstrap-manifests/* bootstrap-manifests/
	cp kube-controller-manager-bootstrap/manifests/* manifests/

	touch kube-controller-manager-bootstrap.done
fi

if [ ! -f kube-scheduler-bootstrap.done ]
then
	echo "Rendering Kubernetes Scheduler core manifests..."

	rm --recursive --force kube-scheduler-bootstrap

	bootkube_podman_run \
		--volume "$PWD:/assets:z" \
		"${KUBE_SCHEDULER_OPERATOR_IMAGE}" \
		/usr/bin/cluster-kube-scheduler-operator render \
		--manifest-image="${OPENSHIFT_HYPERKUBE_IMAGE}" \
		--asset-input-dir=/assets/tls \
		--asset-output-dir=/assets/kube-scheduler-bootstrap \
		--config-output-file=/assets/kube-scheduler-bootstrap/config

	cp kube-scheduler-bootstrap/config /etc/kubernetes/bootstrap-configs/kube-scheduler-config.yaml
	cp kube-scheduler-bootstrap/bootstrap-manifests/* bootstrap-manifests/
	cp kube-scheduler-bootstrap/manifests/* manifests/

	touch kube-scheduler-bootstrap.done
fi

if [ ! -f ingress-operator-bootstrap.done ]
then
	echo "Rendering Ingress Operator core manifests..."

	rm --recursive --force ingress-operator-bootstrap

	bootkube_podman_run \
		--volume "$PWD:/assets:z" \
		"${INGRESS_OPERATOR_IMAGE}" \
		render \
		--prefix=cluster-ingress- \
		--output-dir=/assets/ingress-operator-manifests

	cp ingress-operator-manifests/* manifests/

	touch ingress-operator-bootstrap.done
fi

if [ ! -f mco-bootstrap.done ]
then
	echo "Rendering MCO manifests..."

	rm --recursive --force mco-bootstrap

	ADDITIONAL_FLAGS=""
	if [ -f "/opt/openshift/tls/cloud-ca-cert.pem" ]; then
		ADDITIONAL_FLAGS="--cloud-provider-ca-file=/assets/tls/cloud-ca-cert.pem"
	fi
	if [ -f "$PWD/manifests/cloud-provider-config.yaml" ]; then
		ADDITIONAL_FLAGS="${ADDITIONAL_FLAGS} --cloud-config-file=/assets/config-bootstrap/cloud-provider-config-generated.yaml"
	fi

	bootkube_podman_run \
		--user 0 \
		--volume "$PWD:/assets:z" \
		"${MACHINE_CONFIG_OPERATOR_IMAGE}" \
		bootstrap \
			--root-ca=/assets/tls/root-ca.crt \
			--kube-ca=/assets/tls/kube-apiserver-complete-client-ca-bundle.crt \
			--config-file=/assets/manifests/cluster-config.yaml \
			--dest-dir=/assets/mco-bootstrap \
			--pull-secret=/assets/manifests/openshift-config-secret-pull-secret.yaml \
			--machine-config-operator-image="${MACHINE_CONFIG_OPERATOR_IMAGE}" \
			--machine-config-oscontent-image="${MACHINE_CONFIG_OSCONTENT}" \
			--infra-image="${MACHINE_CONFIG_INFRA_IMAGE}" \
			--keepalived-image="${KEEPALIVED_IMAGE}" \
			--coredns-image="${COREDNS_IMAGE}" \
			--mdns-publisher-image="${MDNS_PUBLISHER_IMAGE}" \
			--haproxy-image="${HAPROXY_IMAGE}" \
			--baremetal-runtimecfg-image="${BAREMETAL_RUNTIMECFG_IMAGE}" \
			--release-image="${RELEASE_IMAGE_DIGEST}" \
			${ADDITIONAL_FLAGS}

	# Bootstrap MachineConfigController uses /etc/mcc/bootstrap/manifests/ dir to
	# 1. read the controller config rendered by MachineConfigOperator
	# 2. read the default MachineConfigPools rendered by MachineConfigOperator
	# 3. read any additional MachineConfigs that are needed for the default MachineConfigPools.
	mkdir --parents /etc/mcc/bootstrap /etc/mcs/bootstrap /etc/kubernetes/manifests /etc/kubernetes/static-pod-resources
	cp mco-bootstrap/bootstrap/manifests/* /etc/mcc/bootstrap/
	cp openshift/* /etc/mcc/bootstrap/
	# 4. read ImageContentSourcePolicy objects generated by the installer
	cp manifests/* /etc/mcc/bootstrap/
	cp auth/kubeconfig-kubelet /etc/mcs/kubeconfig
	cp mco-bootstrap/bootstrap/machineconfigoperator-bootstrap-pod.yaml /etc/kubernetes/manifests/

	copy_static_resources_for() {
	  # copy static resources from mco based on platform folder
	  local platform=$1
	  if [ -d mco-bootstrap/${platform}/manifests ]; then
	    cp mco-bootstrap/${platform}/manifests/* /etc/kubernetes/manifests/
	    cp --recursive mco-bootstrap/${platform}/static-pod-resources/* /etc/kubernetes/static-pod-resources/
	  fi
	}

	copy_static_resources_for baremetal
	copy_static_resources_for openstack
	copy_static_resources_for ovirt
	copy_static_resources_for vsphere

	cp mco-bootstrap/manifests/* manifests/

	# /etc/ssl/mcs/tls.{crt, key} are locations for MachineConfigServer's tls assets.
	mkdir --parents /etc/ssl/mcs/
	cp tls/machine-config-server.crt /etc/ssl/mcs/tls.crt
	cp tls/machine-config-server.key /etc/ssl/mcs/tls.key

	touch mco-bootstrap.done
fi

if [ ! -f cco-bootstrap.done ]
then
	echo "Rendering CCO manifests..."

	rm --recursive --force cco-bootstrap

	# shellcheck disable=SC2154
	bootkube_podman_run \
		--quiet \
		--user 0 \
		--volume "$PWD:/assets:z" \
		${CLOUD_CREDENTIAL_OPERATOR_IMAGE} \
		render \
			--dest-dir=/assets/cco-bootstrap \
			--manifests-dir=/assets/manifests \
			--cloud-credential-operator-image=${CLOUD_CREDENTIAL_OPERATOR_IMAGE}

	cp cco-bootstrap/manifests/* manifests/
	# skip copy if static pod manifest does not exist (ie CCO has been disabled)
	if [ -f cco-bootstrap/bootstrap-manifests/cloud-credential-operator-pod.yaml ]; then
		cp cco-bootstrap/bootstrap-manifests/* bootstrap-manifests/
	fi

	touch cco-bootstrap.done
fi

# Wait for the etcd cluster to come up.
until bootkube_podman_run \
        --rm \
		--name etcdctl \
		--env ETCDCTL_API=3 \
		--volume /opt/openshift/tls:/opt/openshift/tls:ro,z \
		--entrypoint etcdctl \
		"${MACHINE_CONFIG_ETCD_IMAGE}" \
		--dial-timeout=10m \
		--cacert=/opt/openshift/tls/etcd-ca-bundle.crt \
		--cert=/opt/openshift/tls/etcd-client.crt \
		--key=/opt/openshift/tls/etcd-client.key \
		--endpoints="${ETCD_ENDPOINTS}" \
		 endpoint health
do
	echo "etcdctl failed. Retrying in 5 seconds..."
	sleep 5
done


{{if .SingleNode}}

if [ ! -f write-to-disk.done ]
then

    # Get the master ignition for MCS
    curl -k  -H "Accept:'application/vnd.coreos.ignition+json;version=3.1.0, */*;q=0.1'" \
    https://localhost:22623/config/master -o /opt/master.ign

    # Write image + ignition to disk
    coreos-installer install --insecure -i /opt/master.ign /dev/vda

    touch write-to-disk.done

fi

if [ ! -f cb-bootstrap.done ]
then
    bootkube_podman_run \
        --rm \
        --volume "$PWD:/assets:z" \
        --volume /etc/kubernetes:/etc/kubernetes:z \
        quay.io/eranco74/cluster-bootstrap:cluster-profile \
        start --tear-down-early=false --asset-dir=/assets --cluster-profile="single-node-production-edge" --required-pods=""
        # TODO: make sure this finish! 
        touch cb-bootstrap.done
fi

if [ ! -f mount-disk.done ]
then
    echo "Mount disk"
    mkdir /mnt/rhcos
    mount /dev/vda1 /mnt/rhcos

    touch mount-disk.done
fi

if [ ! -f create-static-pods-data.done ]
then
    # TODO: add a service for moving these files to the right place post node reboot
    echo "Move etcd static pod"
    mkdir -p /mnt/rhcos/master/kubernetes/manifests
    mv /etc/kubernetes/manifests/etcd-member-pod.yaml /mnt/rhcos/master/kubernetes/manifests/etcd-pod.yaml

    cp /opt/openshift/bootstrap-manifests/kube* /mnt/rhcos/master/kubernetes/manifests/

    mkdir -p /mnt/rhcos/master/kubernetes/bootstrap-configs
    mkdir -p /mnt/rhcos/master/kubernetes/bootstrap-secrets

    cp -r /etc/kubernetes/bootstrap-configs /mnt/rhcos/master/kubernetes/
    cp -r /opt/openshift/tls/* /mnt/rhcos/master/kubernetes/bootstrap-secrets
    cp    /opt/openshift/auth/kubeconfig-loopback /mnt/rhcos/master/kubernetes/bootstrap-secrets/kubeconfig

    mkdir -p /mnt/rhcos/master/kubernetes/static-pod-resources/etcd-member
    cp tls/etcd-ca-bundle.crt /mnt/rhcos/master/kubernetes/static-pod-resources/etcd-member/ca.crt
    cp --recursive etcd-bootstrap/bootstrap-manifests/secrets/etcd-all-serving /mnt/rhcos/master/kubernetes/static-pod-resources/etcd-member
    cp --recursive etcd-bootstrap/bootstrap-manifests/secrets/etcd-all-peer /mnt/rhcos/master/kubernetes/static-pod-resources/etcd-member

    # TODO: wait for etcd pod to go down before copy the etcd data
    sleep 60
    cp -r /var/lib/etcd /mnt/rhcos/master/

    touch create-static-pods-data.done
fi

echo "Going to reboot"
# TODO: reoobt!!!
shutdown -r +1 "Bootstrap completed, server is going to reboot."


{{else}}
if [ ! -f cb-bootstrap.done ]
then
    bootkube_podman_run \
        --rm \
        --volume "$PWD:/assets:z" \
        --volume /etc/kubernetes:/etc/kubernetes:z \
        "${CLUSTER_BOOTSTRAP_IMAGE}" \
        start --tear-down-early=false --asset-dir=/assets --required-pods="openshift-kube-apiserver/kube-apiserver,openshift-kube-scheduler/openshift-kube-scheduler,openshift-kube-controller-manager/kube-controller-manager,openshift-cluster-version/cluster-version-operator"
    touch cb-bootstrap.done
fi

rm --force /etc/kubernetes/manifests/machineconfigoperator-bootstrap-pod.yaml

if [ ! -z "$CLUSTER_ETCD_OPERATOR_IMAGE" ]
then
	echo "Waiting for CEO to finish..."
	bootkube_podman_run \
		--volume "$PWD:/assets:z" \
		"${CLUSTER_ETCD_OPERATOR_IMAGE}" \
		/usr/bin/cluster-etcd-operator \
			wait-for-ceo \
			--kubeconfig /assets/auth/kubeconfig
fi

# Workaround for https://github.com/opencontainers/runc/pull/1807
touch /opt/openshift/.bootkube.done
echo "bootkube.service complete"

{{end}}
