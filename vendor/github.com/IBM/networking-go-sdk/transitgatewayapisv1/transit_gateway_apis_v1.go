/**
 * (C) Copyright IBM Corp. 2022.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * IBM OpenAPI SDK Code Generator Version: 3.43.5-e0ec19e2-20220124-172004
 */

// Package transitgatewayapisv1 : Operations and models for the TransitGatewayApisV1 service
package transitgatewayapisv1

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"reflect"
	"time"

	"github.com/IBM/go-sdk-core/v5/core"
	common "github.com/IBM/networking-go-sdk/common"
	"github.com/go-openapi/strfmt"
)

// TransitGatewayApisV1 : No description provided (generated by Openapi Generator
// https://github.com/openapitools/openapi-generator)
//
// API Version: __VERSION__
type TransitGatewayApisV1 struct {
	Service *core.BaseService

	// Requests the version of the API as of a date in the format `YYYY-MM-DD`. Any date up to the current date may be
	// provided. Specify the current date to request the latest version.
	Version *string
}

// DefaultServiceURL is the default URL to make service requests to.
const DefaultServiceURL = "https://transit.cloud.ibm.com/v1"

// DefaultServiceName is the default key used to find external configuration information.
const DefaultServiceName = "transit_gateway_apis"

// TransitGatewayApisV1Options : Service options
type TransitGatewayApisV1Options struct {
	ServiceName   string
	URL           string
	Authenticator core.Authenticator

	// Requests the version of the API as of a date in the format `YYYY-MM-DD`. Any date up to the current date may be
	// provided. Specify the current date to request the latest version.
	Version *string `validate:"required"`
}

// NewTransitGatewayApisV1UsingExternalConfig : constructs an instance of TransitGatewayApisV1 with passed in options and external configuration.
func NewTransitGatewayApisV1UsingExternalConfig(options *TransitGatewayApisV1Options) (transitGatewayApis *TransitGatewayApisV1, err error) {
	if options.ServiceName == "" {
		options.ServiceName = DefaultServiceName
	}

	if options.Authenticator == nil {
		options.Authenticator, err = core.GetAuthenticatorFromEnvironment(options.ServiceName)
		if err != nil {
			return
		}
	}

	transitGatewayApis, err = NewTransitGatewayApisV1(options)
	if err != nil {
		return
	}

	err = transitGatewayApis.Service.ConfigureService(options.ServiceName)
	if err != nil {
		return
	}

	if options.URL != "" {
		err = transitGatewayApis.Service.SetServiceURL(options.URL)
	}
	return
}

// NewTransitGatewayApisV1 : constructs an instance of TransitGatewayApisV1 with passed in options.
func NewTransitGatewayApisV1(options *TransitGatewayApisV1Options) (service *TransitGatewayApisV1, err error) {
	serviceOptions := &core.ServiceOptions{
		URL:           DefaultServiceURL,
		Authenticator: options.Authenticator,
	}

	err = core.ValidateStruct(options, "options")
	if err != nil {
		return
	}

	baseService, err := core.NewBaseService(serviceOptions)
	if err != nil {
		return
	}

	if options.URL != "" {
		err = baseService.SetServiceURL(options.URL)
		if err != nil {
			return
		}
	}

	service = &TransitGatewayApisV1{
		Service: baseService,
		Version: options.Version,
	}

	return
}

// GetServiceURLForRegion returns the service URL to be used for the specified region
func GetServiceURLForRegion(region string) (string, error) {
	return "", fmt.Errorf("service does not support regional URLs")
}

// Clone makes a copy of "transitGatewayApis" suitable for processing requests.
func (transitGatewayApis *TransitGatewayApisV1) Clone() *TransitGatewayApisV1 {
	if core.IsNil(transitGatewayApis) {
		return nil
	}
	clone := *transitGatewayApis
	clone.Service = transitGatewayApis.Service.Clone()
	return &clone
}

// SetServiceURL sets the service URL
func (transitGatewayApis *TransitGatewayApisV1) SetServiceURL(url string) error {
	return transitGatewayApis.Service.SetServiceURL(url)
}

// GetServiceURL returns the service URL
func (transitGatewayApis *TransitGatewayApisV1) GetServiceURL() string {
	return transitGatewayApis.Service.GetServiceURL()
}

// SetDefaultHeaders sets HTTP headers to be sent in every request
func (transitGatewayApis *TransitGatewayApisV1) SetDefaultHeaders(headers http.Header) {
	transitGatewayApis.Service.SetDefaultHeaders(headers)
}

// SetEnableGzipCompression sets the service's EnableGzipCompression field
func (transitGatewayApis *TransitGatewayApisV1) SetEnableGzipCompression(enableGzip bool) {
	transitGatewayApis.Service.SetEnableGzipCompression(enableGzip)
}

// GetEnableGzipCompression returns the service's EnableGzipCompression field
func (transitGatewayApis *TransitGatewayApisV1) GetEnableGzipCompression() bool {
	return transitGatewayApis.Service.GetEnableGzipCompression()
}

// EnableRetries enables automatic retries for requests invoked for this service instance.
// If either parameter is specified as 0, then a default value is used instead.
func (transitGatewayApis *TransitGatewayApisV1) EnableRetries(maxRetries int, maxRetryInterval time.Duration) {
	transitGatewayApis.Service.EnableRetries(maxRetries, maxRetryInterval)
}

// DisableRetries disables automatic retries for requests invoked for this service instance.
func (transitGatewayApis *TransitGatewayApisV1) DisableRetries() {
	transitGatewayApis.Service.DisableRetries()
}

// ListTransitGateways : Retrieves all Transit Gateways
// List all Transit Gateways in account the caller is authorized to view.
func (transitGatewayApis *TransitGatewayApisV1) ListTransitGateways(listTransitGatewaysOptions *ListTransitGatewaysOptions) (result *TransitGatewayCollection, response *core.DetailedResponse, err error) {
	return transitGatewayApis.ListTransitGatewaysWithContext(context.Background(), listTransitGatewaysOptions)
}

// ListTransitGatewaysWithContext is an alternate form of the ListTransitGateways method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) ListTransitGatewaysWithContext(ctx context.Context, listTransitGatewaysOptions *ListTransitGatewaysOptions) (result *TransitGatewayCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listTransitGatewaysOptions, "listTransitGatewaysOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/transit_gateways`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range listTransitGatewaysOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "ListTransitGateways")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))
	if listTransitGatewaysOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listTransitGatewaysOptions.Limit))
	}
	if listTransitGatewaysOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listTransitGatewaysOptions.Start))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTransitGatewayCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateTransitGateway : Creates a Transit Gateway
// Create a Transit Gateway based on the supplied input template.
func (transitGatewayApis *TransitGatewayApisV1) CreateTransitGateway(createTransitGatewayOptions *CreateTransitGatewayOptions) (result *TransitGateway, response *core.DetailedResponse, err error) {
	return transitGatewayApis.CreateTransitGatewayWithContext(context.Background(), createTransitGatewayOptions)
}

// CreateTransitGatewayWithContext is an alternate form of the CreateTransitGateway method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) CreateTransitGatewayWithContext(ctx context.Context, createTransitGatewayOptions *CreateTransitGatewayOptions) (result *TransitGateway, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createTransitGatewayOptions, "createTransitGatewayOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createTransitGatewayOptions, "createTransitGatewayOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/transit_gateways`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range createTransitGatewayOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "CreateTransitGateway")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	body := make(map[string]interface{})
	if createTransitGatewayOptions.Location != nil {
		body["location"] = createTransitGatewayOptions.Location
	}
	if createTransitGatewayOptions.Name != nil {
		body["name"] = createTransitGatewayOptions.Name
	}
	if createTransitGatewayOptions.Global != nil {
		body["global"] = createTransitGatewayOptions.Global
	}
	if createTransitGatewayOptions.ResourceGroup != nil {
		body["resource_group"] = createTransitGatewayOptions.ResourceGroup
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTransitGateway)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteTransitGateway : Deletes specified Transit Gateway
// This request deletes a Transit Gateway. This operation cannot be reversed. For this request to succeed, the Transit
// Gateway must not contain connections.
func (transitGatewayApis *TransitGatewayApisV1) DeleteTransitGateway(deleteTransitGatewayOptions *DeleteTransitGatewayOptions) (response *core.DetailedResponse, err error) {
	return transitGatewayApis.DeleteTransitGatewayWithContext(context.Background(), deleteTransitGatewayOptions)
}

// DeleteTransitGatewayWithContext is an alternate form of the DeleteTransitGateway method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) DeleteTransitGatewayWithContext(ctx context.Context, deleteTransitGatewayOptions *DeleteTransitGatewayOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteTransitGatewayOptions, "deleteTransitGatewayOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteTransitGatewayOptions, "deleteTransitGatewayOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *deleteTransitGatewayOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/transit_gateways/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteTransitGatewayOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "DeleteTransitGateway")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = transitGatewayApis.Service.Request(request, nil)

	return
}

// GetTransitGateway : Retrieves specified Transit Gateway
// This request retrieves a single Transit Gateway specified by the identifier in the URL.
func (transitGatewayApis *TransitGatewayApisV1) GetTransitGateway(getTransitGatewayOptions *GetTransitGatewayOptions) (result *TransitGateway, response *core.DetailedResponse, err error) {
	return transitGatewayApis.GetTransitGatewayWithContext(context.Background(), getTransitGatewayOptions)
}

// GetTransitGatewayWithContext is an alternate form of the GetTransitGateway method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) GetTransitGatewayWithContext(ctx context.Context, getTransitGatewayOptions *GetTransitGatewayOptions) (result *TransitGateway, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getTransitGatewayOptions, "getTransitGatewayOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getTransitGatewayOptions, "getTransitGatewayOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *getTransitGatewayOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/transit_gateways/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getTransitGatewayOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "GetTransitGateway")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTransitGateway)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// UpdateTransitGateway : Updates specified Transit Gateway
// This request updates a Transit Gateway's name and/or global flag.
func (transitGatewayApis *TransitGatewayApisV1) UpdateTransitGateway(updateTransitGatewayOptions *UpdateTransitGatewayOptions) (result *TransitGateway, response *core.DetailedResponse, err error) {
	return transitGatewayApis.UpdateTransitGatewayWithContext(context.Background(), updateTransitGatewayOptions)
}

// UpdateTransitGatewayWithContext is an alternate form of the UpdateTransitGateway method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) UpdateTransitGatewayWithContext(ctx context.Context, updateTransitGatewayOptions *UpdateTransitGatewayOptions) (result *TransitGateway, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateTransitGatewayOptions, "updateTransitGatewayOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateTransitGatewayOptions, "updateTransitGatewayOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *updateTransitGatewayOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/transit_gateways/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateTransitGatewayOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "UpdateTransitGateway")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	body := make(map[string]interface{})
	if updateTransitGatewayOptions.Global != nil {
		body["global"] = updateTransitGatewayOptions.Global
	}
	if updateTransitGatewayOptions.Name != nil {
		body["name"] = updateTransitGatewayOptions.Name
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTransitGateway)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListConnections : Retrieves all connections
// List all transit gateway connections associated with this account.
func (transitGatewayApis *TransitGatewayApisV1) ListConnections(listConnectionsOptions *ListConnectionsOptions) (result *TransitConnectionCollection, response *core.DetailedResponse, err error) {
	return transitGatewayApis.ListConnectionsWithContext(context.Background(), listConnectionsOptions)
}

// ListConnectionsWithContext is an alternate form of the ListConnections method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) ListConnectionsWithContext(ctx context.Context, listConnectionsOptions *ListConnectionsOptions) (result *TransitConnectionCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listConnectionsOptions, "listConnectionsOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/connections`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range listConnectionsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "ListConnections")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))
	if listConnectionsOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listConnectionsOptions.Limit))
	}
	if listConnectionsOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listConnectionsOptions.Start))
	}
	if listConnectionsOptions.NetworkID != nil {
		builder.AddQuery("network_id", fmt.Sprint(*listConnectionsOptions.NetworkID))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTransitConnectionCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListTransitGatewayConnections : Retrieves all connections in a Transit Gateway
// This request retrieves all connections in a Transit Gateway.
func (transitGatewayApis *TransitGatewayApisV1) ListTransitGatewayConnections(listTransitGatewayConnectionsOptions *ListTransitGatewayConnectionsOptions) (result *TransitGatewayConnectionCollection, response *core.DetailedResponse, err error) {
	return transitGatewayApis.ListTransitGatewayConnectionsWithContext(context.Background(), listTransitGatewayConnectionsOptions)
}

// ListTransitGatewayConnectionsWithContext is an alternate form of the ListTransitGatewayConnections method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) ListTransitGatewayConnectionsWithContext(ctx context.Context, listTransitGatewayConnectionsOptions *ListTransitGatewayConnectionsOptions) (result *TransitGatewayConnectionCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listTransitGatewayConnectionsOptions, "listTransitGatewayConnectionsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listTransitGatewayConnectionsOptions, "listTransitGatewayConnectionsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"transit_gateway_id": *listTransitGatewayConnectionsOptions.TransitGatewayID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/transit_gateways/{transit_gateway_id}/connections`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listTransitGatewayConnectionsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "ListTransitGatewayConnections")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTransitGatewayConnectionCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateTransitGatewayConnection : Add connection to a Transit Gateway
// Add a connection to Transit Gateway.
func (transitGatewayApis *TransitGatewayApisV1) CreateTransitGatewayConnection(createTransitGatewayConnectionOptions *CreateTransitGatewayConnectionOptions) (result *TransitGatewayConnectionCust, response *core.DetailedResponse, err error) {
	return transitGatewayApis.CreateTransitGatewayConnectionWithContext(context.Background(), createTransitGatewayConnectionOptions)
}

// CreateTransitGatewayConnectionWithContext is an alternate form of the CreateTransitGatewayConnection method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) CreateTransitGatewayConnectionWithContext(ctx context.Context, createTransitGatewayConnectionOptions *CreateTransitGatewayConnectionOptions) (result *TransitGatewayConnectionCust, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createTransitGatewayConnectionOptions, "createTransitGatewayConnectionOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createTransitGatewayConnectionOptions, "createTransitGatewayConnectionOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"transit_gateway_id": *createTransitGatewayConnectionOptions.TransitGatewayID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/transit_gateways/{transit_gateway_id}/connections`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range createTransitGatewayConnectionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "CreateTransitGatewayConnection")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	body := make(map[string]interface{})
	if createTransitGatewayConnectionOptions.NetworkType != nil {
		body["network_type"] = createTransitGatewayConnectionOptions.NetworkType
	}
	if createTransitGatewayConnectionOptions.BaseConnectionID != nil {
		body["base_connection_id"] = createTransitGatewayConnectionOptions.BaseConnectionID
	}
	if createTransitGatewayConnectionOptions.BaseNetworkType != nil {
		body["base_network_type"] = createTransitGatewayConnectionOptions.BaseNetworkType
	}
	if createTransitGatewayConnectionOptions.LocalGatewayIp != nil {
		body["local_gateway_ip"] = createTransitGatewayConnectionOptions.LocalGatewayIp
	}
	if createTransitGatewayConnectionOptions.LocalTunnelIp != nil {
		body["local_tunnel_ip"] = createTransitGatewayConnectionOptions.LocalTunnelIp
	}
	if createTransitGatewayConnectionOptions.Name != nil {
		body["name"] = createTransitGatewayConnectionOptions.Name
	}
	if createTransitGatewayConnectionOptions.NetworkAccountID != nil {
		body["network_account_id"] = createTransitGatewayConnectionOptions.NetworkAccountID
	}
	if createTransitGatewayConnectionOptions.NetworkID != nil {
		body["network_id"] = createTransitGatewayConnectionOptions.NetworkID
	}
	if createTransitGatewayConnectionOptions.PrefixFilters != nil {
		body["prefix_filters"] = createTransitGatewayConnectionOptions.PrefixFilters
	}
	if createTransitGatewayConnectionOptions.PrefixFiltersDefault != nil {
		body["prefix_filters_default"] = createTransitGatewayConnectionOptions.PrefixFiltersDefault
	}
	if createTransitGatewayConnectionOptions.RemoteBgpAsn != nil {
		body["remote_bgp_asn"] = createTransitGatewayConnectionOptions.RemoteBgpAsn
	}
	if createTransitGatewayConnectionOptions.RemoteGatewayIp != nil {
		body["remote_gateway_ip"] = createTransitGatewayConnectionOptions.RemoteGatewayIp
	}
	if createTransitGatewayConnectionOptions.RemoteTunnelIp != nil {
		body["remote_tunnel_ip"] = createTransitGatewayConnectionOptions.RemoteTunnelIp
	}
	if createTransitGatewayConnectionOptions.Zone != nil {
		body["zone"] = createTransitGatewayConnectionOptions.Zone
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTransitGatewayConnectionCust)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteTransitGatewayConnection : Remove connection from Transit Gateway
// After the specified connection is detached, entities still within the Transit Gateway will no longer be able to
// communicate directly to it through the IBM Cloud private backbone.
func (transitGatewayApis *TransitGatewayApisV1) DeleteTransitGatewayConnection(deleteTransitGatewayConnectionOptions *DeleteTransitGatewayConnectionOptions) (response *core.DetailedResponse, err error) {
	return transitGatewayApis.DeleteTransitGatewayConnectionWithContext(context.Background(), deleteTransitGatewayConnectionOptions)
}

// DeleteTransitGatewayConnectionWithContext is an alternate form of the DeleteTransitGatewayConnection method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) DeleteTransitGatewayConnectionWithContext(ctx context.Context, deleteTransitGatewayConnectionOptions *DeleteTransitGatewayConnectionOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteTransitGatewayConnectionOptions, "deleteTransitGatewayConnectionOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteTransitGatewayConnectionOptions, "deleteTransitGatewayConnectionOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"transit_gateway_id": *deleteTransitGatewayConnectionOptions.TransitGatewayID,
		"id":                 *deleteTransitGatewayConnectionOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/transit_gateways/{transit_gateway_id}/connections/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteTransitGatewayConnectionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "DeleteTransitGatewayConnection")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = transitGatewayApis.Service.Request(request, nil)

	return
}

// GetTransitGatewayConnection : Retrieves specified Transit Gateway connection
// This request retrieves a connection from the Transit Gateway.
func (transitGatewayApis *TransitGatewayApisV1) GetTransitGatewayConnection(getTransitGatewayConnectionOptions *GetTransitGatewayConnectionOptions) (result *TransitGatewayConnectionCust, response *core.DetailedResponse, err error) {
	return transitGatewayApis.GetTransitGatewayConnectionWithContext(context.Background(), getTransitGatewayConnectionOptions)
}

// GetTransitGatewayConnectionWithContext is an alternate form of the GetTransitGatewayConnection method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) GetTransitGatewayConnectionWithContext(ctx context.Context, getTransitGatewayConnectionOptions *GetTransitGatewayConnectionOptions) (result *TransitGatewayConnectionCust, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getTransitGatewayConnectionOptions, "getTransitGatewayConnectionOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getTransitGatewayConnectionOptions, "getTransitGatewayConnectionOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"transit_gateway_id": *getTransitGatewayConnectionOptions.TransitGatewayID,
		"id":                 *getTransitGatewayConnectionOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/transit_gateways/{transit_gateway_id}/connections/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getTransitGatewayConnectionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "GetTransitGatewayConnection")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTransitGatewayConnectionCust)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// UpdateTransitGatewayConnection : Updates specified Transit Gateway connection
// Update the name of a connection to a Transit Gateway.
func (transitGatewayApis *TransitGatewayApisV1) UpdateTransitGatewayConnection(updateTransitGatewayConnectionOptions *UpdateTransitGatewayConnectionOptions) (result *TransitGatewayConnectionCust, response *core.DetailedResponse, err error) {
	return transitGatewayApis.UpdateTransitGatewayConnectionWithContext(context.Background(), updateTransitGatewayConnectionOptions)
}

// UpdateTransitGatewayConnectionWithContext is an alternate form of the UpdateTransitGatewayConnection method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) UpdateTransitGatewayConnectionWithContext(ctx context.Context, updateTransitGatewayConnectionOptions *UpdateTransitGatewayConnectionOptions) (result *TransitGatewayConnectionCust, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateTransitGatewayConnectionOptions, "updateTransitGatewayConnectionOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateTransitGatewayConnectionOptions, "updateTransitGatewayConnectionOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"transit_gateway_id": *updateTransitGatewayConnectionOptions.TransitGatewayID,
		"id":                 *updateTransitGatewayConnectionOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/transit_gateways/{transit_gateway_id}/connections/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateTransitGatewayConnectionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "UpdateTransitGatewayConnection")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	body := make(map[string]interface{})
	if updateTransitGatewayConnectionOptions.Name != nil {
		body["name"] = updateTransitGatewayConnectionOptions.Name
	}
	if updateTransitGatewayConnectionOptions.PrefixFiltersDefault != nil {
		body["prefix_filters_default"] = updateTransitGatewayConnectionOptions.PrefixFiltersDefault
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTransitGatewayConnectionCust)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateTransitGatewayConnectionActions : Perform actions on a connection for a Transit Gateway
// Allow a network owner to approve or reject a cross-account connection request.
func (transitGatewayApis *TransitGatewayApisV1) CreateTransitGatewayConnectionActions(createTransitGatewayConnectionActionsOptions *CreateTransitGatewayConnectionActionsOptions) (response *core.DetailedResponse, err error) {
	return transitGatewayApis.CreateTransitGatewayConnectionActionsWithContext(context.Background(), createTransitGatewayConnectionActionsOptions)
}

// CreateTransitGatewayConnectionActionsWithContext is an alternate form of the CreateTransitGatewayConnectionActions method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) CreateTransitGatewayConnectionActionsWithContext(ctx context.Context, createTransitGatewayConnectionActionsOptions *CreateTransitGatewayConnectionActionsOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createTransitGatewayConnectionActionsOptions, "createTransitGatewayConnectionActionsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createTransitGatewayConnectionActionsOptions, "createTransitGatewayConnectionActionsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"transit_gateway_id": *createTransitGatewayConnectionActionsOptions.TransitGatewayID,
		"id":                 *createTransitGatewayConnectionActionsOptions.ID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/transit_gateways/{transit_gateway_id}/connections/{id}/actions`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range createTransitGatewayConnectionActionsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "CreateTransitGatewayConnectionActions")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	body := make(map[string]interface{})
	if createTransitGatewayConnectionActionsOptions.Action != nil {
		body["action"] = createTransitGatewayConnectionActionsOptions.Action
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = transitGatewayApis.Service.Request(request, nil)

	return
}

// ListGatewayLocations : List all locations that support Transit Gateways
// List all locations that support Transit Gateways.
func (transitGatewayApis *TransitGatewayApisV1) ListGatewayLocations(listGatewayLocationsOptions *ListGatewayLocationsOptions) (result *TSCollection, response *core.DetailedResponse, err error) {
	return transitGatewayApis.ListGatewayLocationsWithContext(context.Background(), listGatewayLocationsOptions)
}

// ListGatewayLocationsWithContext is an alternate form of the ListGatewayLocations method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) ListGatewayLocationsWithContext(ctx context.Context, listGatewayLocationsOptions *ListGatewayLocationsOptions) (result *TSCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listGatewayLocationsOptions, "listGatewayLocationsOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/locations`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range listGatewayLocationsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "ListGatewayLocations")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTSCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// GetGatewayLocation : Show the details of a given Transit Gateway location
// Get the details of a Transit Gateway Location.
func (transitGatewayApis *TransitGatewayApisV1) GetGatewayLocation(getGatewayLocationOptions *GetGatewayLocationOptions) (result *TSLocation, response *core.DetailedResponse, err error) {
	return transitGatewayApis.GetGatewayLocationWithContext(context.Background(), getGatewayLocationOptions)
}

// GetGatewayLocationWithContext is an alternate form of the GetGatewayLocation method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) GetGatewayLocationWithContext(ctx context.Context, getGatewayLocationOptions *GetGatewayLocationOptions) (result *TSLocation, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getGatewayLocationOptions, "getGatewayLocationOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getGatewayLocationOptions, "getGatewayLocationOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"name": *getGatewayLocationOptions.Name,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/locations/{name}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getGatewayLocationOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "GetGatewayLocation")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTSLocation)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListTransitGatewayConnectionPrefixFilters : Retrieves all prefix filters in a Transit Gateway connection
// This request retrieves all prefix filters in a Transit Gateway connection.
func (transitGatewayApis *TransitGatewayApisV1) ListTransitGatewayConnectionPrefixFilters(listTransitGatewayConnectionPrefixFiltersOptions *ListTransitGatewayConnectionPrefixFiltersOptions) (result *PrefixFilterCollection, response *core.DetailedResponse, err error) {
	return transitGatewayApis.ListTransitGatewayConnectionPrefixFiltersWithContext(context.Background(), listTransitGatewayConnectionPrefixFiltersOptions)
}

// ListTransitGatewayConnectionPrefixFiltersWithContext is an alternate form of the ListTransitGatewayConnectionPrefixFilters method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) ListTransitGatewayConnectionPrefixFiltersWithContext(ctx context.Context, listTransitGatewayConnectionPrefixFiltersOptions *ListTransitGatewayConnectionPrefixFiltersOptions) (result *PrefixFilterCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listTransitGatewayConnectionPrefixFiltersOptions, "listTransitGatewayConnectionPrefixFiltersOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listTransitGatewayConnectionPrefixFiltersOptions, "listTransitGatewayConnectionPrefixFiltersOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"transit_gateway_id": *listTransitGatewayConnectionPrefixFiltersOptions.TransitGatewayID,
		"id":                 *listTransitGatewayConnectionPrefixFiltersOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/transit_gateways/{transit_gateway_id}/connections/{id}/prefix_filters`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listTransitGatewayConnectionPrefixFiltersOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "ListTransitGatewayConnectionPrefixFilters")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalPrefixFilterCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateTransitGatewayConnectionPrefixFilter : Add a prefix filter to a Transit Gateway Connection
// Add a prefix filter to a Transit Gateway Connection.
func (transitGatewayApis *TransitGatewayApisV1) CreateTransitGatewayConnectionPrefixFilter(createTransitGatewayConnectionPrefixFilterOptions *CreateTransitGatewayConnectionPrefixFilterOptions) (result *PrefixFilterCust, response *core.DetailedResponse, err error) {
	return transitGatewayApis.CreateTransitGatewayConnectionPrefixFilterWithContext(context.Background(), createTransitGatewayConnectionPrefixFilterOptions)
}

// CreateTransitGatewayConnectionPrefixFilterWithContext is an alternate form of the CreateTransitGatewayConnectionPrefixFilter method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) CreateTransitGatewayConnectionPrefixFilterWithContext(ctx context.Context, createTransitGatewayConnectionPrefixFilterOptions *CreateTransitGatewayConnectionPrefixFilterOptions) (result *PrefixFilterCust, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createTransitGatewayConnectionPrefixFilterOptions, "createTransitGatewayConnectionPrefixFilterOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createTransitGatewayConnectionPrefixFilterOptions, "createTransitGatewayConnectionPrefixFilterOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"transit_gateway_id": *createTransitGatewayConnectionPrefixFilterOptions.TransitGatewayID,
		"id":                 *createTransitGatewayConnectionPrefixFilterOptions.ID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/transit_gateways/{transit_gateway_id}/connections/{id}/prefix_filters`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range createTransitGatewayConnectionPrefixFilterOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "CreateTransitGatewayConnectionPrefixFilter")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	body := make(map[string]interface{})
	if createTransitGatewayConnectionPrefixFilterOptions.Action != nil {
		body["action"] = createTransitGatewayConnectionPrefixFilterOptions.Action
	}
	if createTransitGatewayConnectionPrefixFilterOptions.Prefix != nil {
		body["prefix"] = createTransitGatewayConnectionPrefixFilterOptions.Prefix
	}
	if createTransitGatewayConnectionPrefixFilterOptions.Before != nil {
		body["before"] = createTransitGatewayConnectionPrefixFilterOptions.Before
	}
	if createTransitGatewayConnectionPrefixFilterOptions.Ge != nil {
		body["ge"] = createTransitGatewayConnectionPrefixFilterOptions.Ge
	}
	if createTransitGatewayConnectionPrefixFilterOptions.Le != nil {
		body["le"] = createTransitGatewayConnectionPrefixFilterOptions.Le
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalPrefixFilterCust)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ReplaceTransitGatewayConnectionPrefixFilter : Replaces the prefix filters of the Transit Gateway Connection
// Replaces the prefix filters of the Transit Gateway Connection.
func (transitGatewayApis *TransitGatewayApisV1) ReplaceTransitGatewayConnectionPrefixFilter(replaceTransitGatewayConnectionPrefixFilterOptions *ReplaceTransitGatewayConnectionPrefixFilterOptions) (result *PrefixFilterCollection, response *core.DetailedResponse, err error) {
	return transitGatewayApis.ReplaceTransitGatewayConnectionPrefixFilterWithContext(context.Background(), replaceTransitGatewayConnectionPrefixFilterOptions)
}

// ReplaceTransitGatewayConnectionPrefixFilterWithContext is an alternate form of the ReplaceTransitGatewayConnectionPrefixFilter method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) ReplaceTransitGatewayConnectionPrefixFilterWithContext(ctx context.Context, replaceTransitGatewayConnectionPrefixFilterOptions *ReplaceTransitGatewayConnectionPrefixFilterOptions) (result *PrefixFilterCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(replaceTransitGatewayConnectionPrefixFilterOptions, "replaceTransitGatewayConnectionPrefixFilterOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(replaceTransitGatewayConnectionPrefixFilterOptions, "replaceTransitGatewayConnectionPrefixFilterOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"transit_gateway_id": *replaceTransitGatewayConnectionPrefixFilterOptions.TransitGatewayID,
		"id":                 *replaceTransitGatewayConnectionPrefixFilterOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PUT)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/transit_gateways/{transit_gateway_id}/connections/{id}/prefix_filters`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range replaceTransitGatewayConnectionPrefixFilterOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "ReplaceTransitGatewayConnectionPrefixFilter")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	body := make(map[string]interface{})
	if replaceTransitGatewayConnectionPrefixFilterOptions.PrefixFilters != nil {
		body["prefix_filters"] = replaceTransitGatewayConnectionPrefixFilterOptions.PrefixFilters
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalPrefixFilterCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteTransitGatewayConnectionPrefixFilter : Remove prefix filter from Transit Gateway Connection
// Delete a prefix filter.
func (transitGatewayApis *TransitGatewayApisV1) DeleteTransitGatewayConnectionPrefixFilter(deleteTransitGatewayConnectionPrefixFilterOptions *DeleteTransitGatewayConnectionPrefixFilterOptions) (response *core.DetailedResponse, err error) {
	return transitGatewayApis.DeleteTransitGatewayConnectionPrefixFilterWithContext(context.Background(), deleteTransitGatewayConnectionPrefixFilterOptions)
}

// DeleteTransitGatewayConnectionPrefixFilterWithContext is an alternate form of the DeleteTransitGatewayConnectionPrefixFilter method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) DeleteTransitGatewayConnectionPrefixFilterWithContext(ctx context.Context, deleteTransitGatewayConnectionPrefixFilterOptions *DeleteTransitGatewayConnectionPrefixFilterOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteTransitGatewayConnectionPrefixFilterOptions, "deleteTransitGatewayConnectionPrefixFilterOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteTransitGatewayConnectionPrefixFilterOptions, "deleteTransitGatewayConnectionPrefixFilterOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"transit_gateway_id": *deleteTransitGatewayConnectionPrefixFilterOptions.TransitGatewayID,
		"id":                 *deleteTransitGatewayConnectionPrefixFilterOptions.ID,
		"filter_id":          *deleteTransitGatewayConnectionPrefixFilterOptions.FilterID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/transit_gateways/{transit_gateway_id}/connections/{id}/prefix_filters/{filter_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteTransitGatewayConnectionPrefixFilterOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "DeleteTransitGatewayConnectionPrefixFilter")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = transitGatewayApis.Service.Request(request, nil)

	return
}

// GetTransitGatewayConnectionPrefixFilter : Retrieves specified Transit Gateway connection prefix filter
// This request retrieves a prefix filter from the Transit Gateway Connection.
func (transitGatewayApis *TransitGatewayApisV1) GetTransitGatewayConnectionPrefixFilter(getTransitGatewayConnectionPrefixFilterOptions *GetTransitGatewayConnectionPrefixFilterOptions) (result *PrefixFilterCust, response *core.DetailedResponse, err error) {
	return transitGatewayApis.GetTransitGatewayConnectionPrefixFilterWithContext(context.Background(), getTransitGatewayConnectionPrefixFilterOptions)
}

// GetTransitGatewayConnectionPrefixFilterWithContext is an alternate form of the GetTransitGatewayConnectionPrefixFilter method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) GetTransitGatewayConnectionPrefixFilterWithContext(ctx context.Context, getTransitGatewayConnectionPrefixFilterOptions *GetTransitGatewayConnectionPrefixFilterOptions) (result *PrefixFilterCust, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getTransitGatewayConnectionPrefixFilterOptions, "getTransitGatewayConnectionPrefixFilterOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getTransitGatewayConnectionPrefixFilterOptions, "getTransitGatewayConnectionPrefixFilterOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"transit_gateway_id": *getTransitGatewayConnectionPrefixFilterOptions.TransitGatewayID,
		"id":                 *getTransitGatewayConnectionPrefixFilterOptions.ID,
		"filter_id":          *getTransitGatewayConnectionPrefixFilterOptions.FilterID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/transit_gateways/{transit_gateway_id}/connections/{id}/prefix_filters/{filter_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getTransitGatewayConnectionPrefixFilterOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "GetTransitGatewayConnectionPrefixFilter")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalPrefixFilterCust)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// UpdateTransitGatewayConnectionPrefixFilter : Updates specified Transit Gateway connection prefix filter
// Update prefix filter for a Transit Gateway Connection.
func (transitGatewayApis *TransitGatewayApisV1) UpdateTransitGatewayConnectionPrefixFilter(updateTransitGatewayConnectionPrefixFilterOptions *UpdateTransitGatewayConnectionPrefixFilterOptions) (result *PrefixFilterCust, response *core.DetailedResponse, err error) {
	return transitGatewayApis.UpdateTransitGatewayConnectionPrefixFilterWithContext(context.Background(), updateTransitGatewayConnectionPrefixFilterOptions)
}

// UpdateTransitGatewayConnectionPrefixFilterWithContext is an alternate form of the UpdateTransitGatewayConnectionPrefixFilter method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) UpdateTransitGatewayConnectionPrefixFilterWithContext(ctx context.Context, updateTransitGatewayConnectionPrefixFilterOptions *UpdateTransitGatewayConnectionPrefixFilterOptions) (result *PrefixFilterCust, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateTransitGatewayConnectionPrefixFilterOptions, "updateTransitGatewayConnectionPrefixFilterOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateTransitGatewayConnectionPrefixFilterOptions, "updateTransitGatewayConnectionPrefixFilterOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"transit_gateway_id": *updateTransitGatewayConnectionPrefixFilterOptions.TransitGatewayID,
		"id":                 *updateTransitGatewayConnectionPrefixFilterOptions.ID,
		"filter_id":          *updateTransitGatewayConnectionPrefixFilterOptions.FilterID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/transit_gateways/{transit_gateway_id}/connections/{id}/prefix_filters/{filter_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateTransitGatewayConnectionPrefixFilterOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "UpdateTransitGatewayConnectionPrefixFilter")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	body := make(map[string]interface{})
	if updateTransitGatewayConnectionPrefixFilterOptions.Action != nil {
		body["action"] = updateTransitGatewayConnectionPrefixFilterOptions.Action
	}
	if updateTransitGatewayConnectionPrefixFilterOptions.Before != nil {
		body["before"] = updateTransitGatewayConnectionPrefixFilterOptions.Before
	}
	if updateTransitGatewayConnectionPrefixFilterOptions.Ge != nil {
		body["ge"] = updateTransitGatewayConnectionPrefixFilterOptions.Ge
	}
	if updateTransitGatewayConnectionPrefixFilterOptions.Le != nil {
		body["le"] = updateTransitGatewayConnectionPrefixFilterOptions.Le
	}
	if updateTransitGatewayConnectionPrefixFilterOptions.Prefix != nil {
		body["prefix"] = updateTransitGatewayConnectionPrefixFilterOptions.Prefix
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalPrefixFilterCust)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListTransitGatewayRouteReports : List route reports
// Retrieve all route reports for the specified Transit Gateway.  There will normally be at most one completed report
// and one pending report.  Additionally, completed route reports are written to IBM Cloud Activity Tracker.
func (transitGatewayApis *TransitGatewayApisV1) ListTransitGatewayRouteReports(listTransitGatewayRouteReportsOptions *ListTransitGatewayRouteReportsOptions) (result *RouteReportCollection, response *core.DetailedResponse, err error) {
	return transitGatewayApis.ListTransitGatewayRouteReportsWithContext(context.Background(), listTransitGatewayRouteReportsOptions)
}

// ListTransitGatewayRouteReportsWithContext is an alternate form of the ListTransitGatewayRouteReports method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) ListTransitGatewayRouteReportsWithContext(ctx context.Context, listTransitGatewayRouteReportsOptions *ListTransitGatewayRouteReportsOptions) (result *RouteReportCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listTransitGatewayRouteReportsOptions, "listTransitGatewayRouteReportsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listTransitGatewayRouteReportsOptions, "listTransitGatewayRouteReportsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"transit_gateway_id": *listTransitGatewayRouteReportsOptions.TransitGatewayID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/transit_gateways/{transit_gateway_id}/route_reports`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listTransitGatewayRouteReportsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "ListTransitGatewayRouteReports")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalRouteReportCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateTransitGatewayRouteReport : Request a route report
// Request route report generation.  While report generation is in progress, additional requests to generate a report
// are ignored and return the current pending report.
func (transitGatewayApis *TransitGatewayApisV1) CreateTransitGatewayRouteReport(createTransitGatewayRouteReportOptions *CreateTransitGatewayRouteReportOptions) (result *RouteReport, response *core.DetailedResponse, err error) {
	return transitGatewayApis.CreateTransitGatewayRouteReportWithContext(context.Background(), createTransitGatewayRouteReportOptions)
}

// CreateTransitGatewayRouteReportWithContext is an alternate form of the CreateTransitGatewayRouteReport method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) CreateTransitGatewayRouteReportWithContext(ctx context.Context, createTransitGatewayRouteReportOptions *CreateTransitGatewayRouteReportOptions) (result *RouteReport, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createTransitGatewayRouteReportOptions, "createTransitGatewayRouteReportOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createTransitGatewayRouteReportOptions, "createTransitGatewayRouteReportOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"transit_gateway_id": *createTransitGatewayRouteReportOptions.TransitGatewayID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/transit_gateways/{transit_gateway_id}/route_reports`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range createTransitGatewayRouteReportOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "CreateTransitGatewayRouteReport")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalRouteReport)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteTransitGatewayRouteReport : Delete route report
// Delete a route report.
func (transitGatewayApis *TransitGatewayApisV1) DeleteTransitGatewayRouteReport(deleteTransitGatewayRouteReportOptions *DeleteTransitGatewayRouteReportOptions) (response *core.DetailedResponse, err error) {
	return transitGatewayApis.DeleteTransitGatewayRouteReportWithContext(context.Background(), deleteTransitGatewayRouteReportOptions)
}

// DeleteTransitGatewayRouteReportWithContext is an alternate form of the DeleteTransitGatewayRouteReport method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) DeleteTransitGatewayRouteReportWithContext(ctx context.Context, deleteTransitGatewayRouteReportOptions *DeleteTransitGatewayRouteReportOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteTransitGatewayRouteReportOptions, "deleteTransitGatewayRouteReportOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteTransitGatewayRouteReportOptions, "deleteTransitGatewayRouteReportOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"transit_gateway_id": *deleteTransitGatewayRouteReportOptions.TransitGatewayID,
		"id":                 *deleteTransitGatewayRouteReportOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/transit_gateways/{transit_gateway_id}/route_reports/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteTransitGatewayRouteReportOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "DeleteTransitGatewayRouteReport")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = transitGatewayApis.Service.Request(request, nil)

	return
}

// GetTransitGatewayRouteReport : Retrieve route report
// Retrieve a route report.
func (transitGatewayApis *TransitGatewayApisV1) GetTransitGatewayRouteReport(getTransitGatewayRouteReportOptions *GetTransitGatewayRouteReportOptions) (result *RouteReport, response *core.DetailedResponse, err error) {
	return transitGatewayApis.GetTransitGatewayRouteReportWithContext(context.Background(), getTransitGatewayRouteReportOptions)
}

// GetTransitGatewayRouteReportWithContext is an alternate form of the GetTransitGatewayRouteReport method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) GetTransitGatewayRouteReportWithContext(ctx context.Context, getTransitGatewayRouteReportOptions *GetTransitGatewayRouteReportOptions) (result *RouteReport, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getTransitGatewayRouteReportOptions, "getTransitGatewayRouteReportOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getTransitGatewayRouteReportOptions, "getTransitGatewayRouteReportOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"transit_gateway_id": *getTransitGatewayRouteReportOptions.TransitGatewayID,
		"id":                 *getTransitGatewayRouteReportOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/transit_gateways/{transit_gateway_id}/route_reports/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getTransitGatewayRouteReportOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "GetTransitGatewayRouteReport")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalRouteReport)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateTransitGatewayConnectionActionsOptions : The CreateTransitGatewayConnectionActions options.
type CreateTransitGatewayConnectionActionsOptions struct {
	// The Transit Gateway identifier.
	TransitGatewayID *string `json:"transit_gateway_id" validate:"required,ne="`

	// The connection identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The action that is to be performed against the connection request.
	Action *string `json:"action" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the CreateTransitGatewayConnectionActionsOptions.Action property.
// The action that is to be performed against the connection request.
const (
	CreateTransitGatewayConnectionActionsOptions_Action_Approve = "approve"
	CreateTransitGatewayConnectionActionsOptions_Action_Reject  = "reject"
)

// NewCreateTransitGatewayConnectionActionsOptions : Instantiate CreateTransitGatewayConnectionActionsOptions
func (*TransitGatewayApisV1) NewCreateTransitGatewayConnectionActionsOptions(transitGatewayID string, id string, action string) *CreateTransitGatewayConnectionActionsOptions {
	return &CreateTransitGatewayConnectionActionsOptions{
		TransitGatewayID: core.StringPtr(transitGatewayID),
		ID:               core.StringPtr(id),
		Action:           core.StringPtr(action),
	}
}

// SetTransitGatewayID : Allow user to set TransitGatewayID
func (_options *CreateTransitGatewayConnectionActionsOptions) SetTransitGatewayID(transitGatewayID string) *CreateTransitGatewayConnectionActionsOptions {
	_options.TransitGatewayID = core.StringPtr(transitGatewayID)
	return _options
}

// SetID : Allow user to set ID
func (_options *CreateTransitGatewayConnectionActionsOptions) SetID(id string) *CreateTransitGatewayConnectionActionsOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetAction : Allow user to set Action
func (_options *CreateTransitGatewayConnectionActionsOptions) SetAction(action string) *CreateTransitGatewayConnectionActionsOptions {
	_options.Action = core.StringPtr(action)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateTransitGatewayConnectionActionsOptions) SetHeaders(param map[string]string) *CreateTransitGatewayConnectionActionsOptions {
	options.Headers = param
	return options
}

// CreateTransitGatewayConnectionOptions : The CreateTransitGatewayConnection options.
type CreateTransitGatewayConnectionOptions struct {
	// The Transit Gateway identifier.
	TransitGatewayID *string `json:"transit_gateway_id" validate:"required,ne="`

	// Defines what type of network is connected via this connection. For access to gre_tunnel or unbound_gre_tunnel
	// connections contact IBM support.
	NetworkType *string `json:"network_type" validate:"required"`

	// network_type 'gre_tunnel' connections must be created over an existing network_type 'classic' connection. This field
	// must specify the ID of an active transit gateway network_type 'classic' connection in the same transit gateway.
	//
	// This field is required for network type 'gre_tunnel' connections.
	//
	// This field is required to be unspecified for network type 'classic', 'directlink', 'vpc', 'power_virtual_server' and
	// 'unbound_gre_tunnel' connections.
	BaseConnectionID *string `json:"base_connection_id,omitempty"`

	// The type of network the Unbound GRE tunnel is targeting. This field is required for network type
	// 'unbound_gre_tunnel' connections. This field is required to be unspecified for network type 'classic', 'directlink',
	// 'vpc', 'power_virtual_server' and 'gre_tunnel' connections.
	BaseNetworkType *string `json:"base_network_type,omitempty"`

	// Local gateway IP address. This field is required for network type 'gre_tunnel' and 'unbound_gre_tunnel' connections.
	// This field is required to be unspecified for network type 'classic', 'directlink', 'vpc' and 'power_virtual_server'
	// connections.
	LocalGatewayIp *string `json:"local_gateway_ip,omitempty"`

	// Local tunnel IP address. The local_tunnel_ip and remote_tunnel_ip addresses must be in the same /30 network. Neither
	// can be the network nor broadcast addresses.
	//
	// This field is required for network type 'gre_tunnel' and 'unbound_gre_tunnel' connections.
	//
	// This field is required to be unspecified for network type 'classic', 'directlink', 'vpc' and 'power_virtual_server'
	// connections.
	LocalTunnelIp *string `json:"local_tunnel_ip,omitempty"`

	// The user-defined name for this transit gateway connection. Network type 'vpc'  connections are defaulted to the name
	// of the VPC.  Network type 'classic' connections are named 'Classic'.
	//
	// This field is required for network type 'gre_tunnel' and 'unbound_gre_tunnel' connections.
	//
	// This field is optional for network type 'classic', 'directlink', 'vpc' and 'power_virtual_server' connections.
	Name *string `json:"name,omitempty"`

	// The ID of the account which owns the network that is being connected. Generally only used if the network is in a
	// different account than the gateway. This field is required for type 'unbound_gre_tunnel' when the
	// associated_network_type is 'classic' and the GRE tunnel is in a different account than the gateway.
	NetworkAccountID *string `json:"network_account_id,omitempty"`

	// The ID of the network being connected via this connection. For network types 'vpc','power_virtual_server' and
	// 'directlink' this is the CRN of the VPC / PowerVS / Direct Link gateway respectively. This field is required for
	// network type 'vpc', 'power_virtual_server' and 'directlink' connections. This field is required to be unspecified
	// for network type 'classic', 'gre_tunnel' and 'unbound_gre_tunnel' connections.
	NetworkID *string `json:"network_id,omitempty"`

	// Array of prefix route filters for a transit gateway connection. Prefix filters can be specified for netowrk type
	// 'vpc', 'classic', 'power_virtual_server' and 'directlink' connections. They are not allowed for type 'gre_tunnel'
	// connections. This is order dependent with those first in the array being applied first, and those at the end of the
	// array being applied last, or just before applying the default. This field is optional for network type 'classic',
	// 'vpc', 'directlink', and 'power_virtual_server' connections. This field is required to be unspecified for network
	// type 'gre_tunnel' and 'unbound_gre_tunnel' connections.
	PrefixFilters []TransitGatewayConnectionPrefixFilter `json:"prefix_filters,omitempty"`

	// Default setting of permit or deny which applies to any routes that don't match a specified filter. This field is
	// optional for network type 'classic', 'vpc', 'directlink', and 'power_virtual_server' connections. This field is
	// required to be unspecified for network type 'gre_tunnel' and 'unbound_gre_tunnel' connections.
	PrefixFiltersDefault *string `json:"prefix_filters_default,omitempty"`

	// Remote network BGP ASN. The following ASN values are reserved and unavailable 64512-64513, 65100, 65201-65234,
	// 65402-65433, 65500 and 4201065000-4201065999. If 'remote_bgp_asn' is omitted on gre_tunnel or unbound_gre_tunnel
	// connection create requests IBM will assign an ASN.
	//
	// This field is optional for network type 'gre_tunnel' and 'unbound_gre_tunnel' connections.
	//
	// This field is required to be unspecified for network type 'classic', 'directlink', 'vpc' and 'power_virtual_server'
	// connections.
	RemoteBgpAsn *int64 `json:"remote_bgp_asn,omitempty"`

	// Remote gateway IP address. This field is required for network type 'gre_tunnel' and 'unbound_gre_tunnel'
	// connections. This field is required to be unspecified for network type 'classic', 'directlink', 'vpc' and
	// 'power_virtual_server' connections.
	RemoteGatewayIp *string `json:"remote_gateway_ip,omitempty"`

	// Remote tunnel IP address. The local_tunnel_ip and remote_tunnel_ip addresses must be in the same /30 network.
	// Neither can be the network nor broadcast addresses.
	//
	// This field is required for network type 'gre_tunnel' and 'unbound_gre_tunnel' connections.
	//
	// This field is required to be unspecified for network type 'classic', 'directlink', 'vpc' and 'power_virtual_server'
	// connections.
	RemoteTunnelIp *string `json:"remote_tunnel_ip,omitempty"`

	// Specify the connection's location.  The specified availability zone must reside in the gateway's region.
	// Use the IBM Cloud global catalog to list zones within the desired region.
	//
	// This field is required for network type 'gre_tunnel' and 'unbound_gre_tunnel' connections.
	//
	// This field is required to be unspecified for network type 'classic', 'directlink', 'vpc' and 'power_virtual_server'
	// connections.
	Zone ZoneIdentityIntf `json:"zone,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the CreateTransitGatewayConnectionOptions.NetworkType property.
// Defines what type of network is connected via this connection. For access to gre_tunnel or unbound_gre_tunnel
// connections contact IBM support.
const (
	CreateTransitGatewayConnectionOptions_NetworkType_Classic            = "classic"
	CreateTransitGatewayConnectionOptions_NetworkType_Directlink         = "directlink"
	CreateTransitGatewayConnectionOptions_NetworkType_GreTunnel          = "gre_tunnel"
	CreateTransitGatewayConnectionOptions_NetworkType_PowerVirtualServer = "power_virtual_server"
	CreateTransitGatewayConnectionOptions_NetworkType_UnboundGreTunnel   = "unbound_gre_tunnel"
	CreateTransitGatewayConnectionOptions_NetworkType_Vpc                = "vpc"
)

// Constants associated with the CreateTransitGatewayConnectionOptions.BaseNetworkType property.
// The type of network the Unbound GRE tunnel is targeting. This field is required for network type 'unbound_gre_tunnel'
// connections. This field is required to be unspecified for network type 'classic', 'directlink', 'vpc',
// 'power_virtual_server' and 'gre_tunnel' connections.
const (
	CreateTransitGatewayConnectionOptions_BaseNetworkType_Classic = "classic"
)

// Constants associated with the CreateTransitGatewayConnectionOptions.PrefixFiltersDefault property.
// Default setting of permit or deny which applies to any routes that don't match a specified filter. This field is
// optional for network type 'classic', 'vpc', 'directlink', and 'power_virtual_server' connections. This field is
// required to be unspecified for network type 'gre_tunnel' and 'unbound_gre_tunnel' connections.
const (
	CreateTransitGatewayConnectionOptions_PrefixFiltersDefault_Deny   = "deny"
	CreateTransitGatewayConnectionOptions_PrefixFiltersDefault_Permit = "permit"
)

// NewCreateTransitGatewayConnectionOptions : Instantiate CreateTransitGatewayConnectionOptions
func (*TransitGatewayApisV1) NewCreateTransitGatewayConnectionOptions(transitGatewayID string, networkType string) *CreateTransitGatewayConnectionOptions {
	return &CreateTransitGatewayConnectionOptions{
		TransitGatewayID: core.StringPtr(transitGatewayID),
		NetworkType:      core.StringPtr(networkType),
	}
}

// SetTransitGatewayID : Allow user to set TransitGatewayID
func (_options *CreateTransitGatewayConnectionOptions) SetTransitGatewayID(transitGatewayID string) *CreateTransitGatewayConnectionOptions {
	_options.TransitGatewayID = core.StringPtr(transitGatewayID)
	return _options
}

// SetNetworkType : Allow user to set NetworkType
func (_options *CreateTransitGatewayConnectionOptions) SetNetworkType(networkType string) *CreateTransitGatewayConnectionOptions {
	_options.NetworkType = core.StringPtr(networkType)
	return _options
}

// SetBaseConnectionID : Allow user to set BaseConnectionID
func (_options *CreateTransitGatewayConnectionOptions) SetBaseConnectionID(baseConnectionID string) *CreateTransitGatewayConnectionOptions {
	_options.BaseConnectionID = core.StringPtr(baseConnectionID)
	return _options
}

// SetBaseNetworkType : Allow user to set BaseNetworkType
func (_options *CreateTransitGatewayConnectionOptions) SetBaseNetworkType(baseNetworkType string) *CreateTransitGatewayConnectionOptions {
	_options.BaseNetworkType = core.StringPtr(baseNetworkType)
	return _options
}

// SetLocalGatewayIp : Allow user to set LocalGatewayIp
func (_options *CreateTransitGatewayConnectionOptions) SetLocalGatewayIp(localGatewayIp string) *CreateTransitGatewayConnectionOptions {
	_options.LocalGatewayIp = core.StringPtr(localGatewayIp)
	return _options
}

// SetLocalTunnelIp : Allow user to set LocalTunnelIp
func (_options *CreateTransitGatewayConnectionOptions) SetLocalTunnelIp(localTunnelIp string) *CreateTransitGatewayConnectionOptions {
	_options.LocalTunnelIp = core.StringPtr(localTunnelIp)
	return _options
}

// SetName : Allow user to set Name
func (_options *CreateTransitGatewayConnectionOptions) SetName(name string) *CreateTransitGatewayConnectionOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetNetworkAccountID : Allow user to set NetworkAccountID
func (_options *CreateTransitGatewayConnectionOptions) SetNetworkAccountID(networkAccountID string) *CreateTransitGatewayConnectionOptions {
	_options.NetworkAccountID = core.StringPtr(networkAccountID)
	return _options
}

// SetNetworkID : Allow user to set NetworkID
func (_options *CreateTransitGatewayConnectionOptions) SetNetworkID(networkID string) *CreateTransitGatewayConnectionOptions {
	_options.NetworkID = core.StringPtr(networkID)
	return _options
}

// SetPrefixFilters : Allow user to set PrefixFilters
func (_options *CreateTransitGatewayConnectionOptions) SetPrefixFilters(prefixFilters []TransitGatewayConnectionPrefixFilter) *CreateTransitGatewayConnectionOptions {
	_options.PrefixFilters = prefixFilters
	return _options
}

// SetPrefixFiltersDefault : Allow user to set PrefixFiltersDefault
func (_options *CreateTransitGatewayConnectionOptions) SetPrefixFiltersDefault(prefixFiltersDefault string) *CreateTransitGatewayConnectionOptions {
	_options.PrefixFiltersDefault = core.StringPtr(prefixFiltersDefault)
	return _options
}

// SetRemoteBgpAsn : Allow user to set RemoteBgpAsn
func (_options *CreateTransitGatewayConnectionOptions) SetRemoteBgpAsn(remoteBgpAsn int64) *CreateTransitGatewayConnectionOptions {
	_options.RemoteBgpAsn = core.Int64Ptr(remoteBgpAsn)
	return _options
}

// SetRemoteGatewayIp : Allow user to set RemoteGatewayIp
func (_options *CreateTransitGatewayConnectionOptions) SetRemoteGatewayIp(remoteGatewayIp string) *CreateTransitGatewayConnectionOptions {
	_options.RemoteGatewayIp = core.StringPtr(remoteGatewayIp)
	return _options
}

// SetRemoteTunnelIp : Allow user to set RemoteTunnelIp
func (_options *CreateTransitGatewayConnectionOptions) SetRemoteTunnelIp(remoteTunnelIp string) *CreateTransitGatewayConnectionOptions {
	_options.RemoteTunnelIp = core.StringPtr(remoteTunnelIp)
	return _options
}

// SetZone : Allow user to set Zone
func (_options *CreateTransitGatewayConnectionOptions) SetZone(zone ZoneIdentityIntf) *CreateTransitGatewayConnectionOptions {
	_options.Zone = zone
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateTransitGatewayConnectionOptions) SetHeaders(param map[string]string) *CreateTransitGatewayConnectionOptions {
	options.Headers = param
	return options
}

// CreateTransitGatewayConnectionPrefixFilterOptions : The CreateTransitGatewayConnectionPrefixFilter options.
type CreateTransitGatewayConnectionPrefixFilterOptions struct {
	// The Transit Gateway identifier.
	TransitGatewayID *string `json:"transit_gateway_id" validate:"required,ne="`

	// The connection identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Whether to permit or deny prefix filter.
	Action *string `json:"action" validate:"required"`

	// IP Prefix.
	Prefix *string `json:"prefix" validate:"required"`

	// Identifier of prefix filter to handle the ordering and follow semantics:
	// - When a filter reference another filter in it's before field, then the filter making the reference is applied
	// before
	//   the referenced filter. For example: if filter A references filter B in its before field, A is applied before B.
	// - When a new filter is added that has the same before as an existing filter, then the older filter will have its
	// before
	//   field updated to point to the new filter. Starting with the above example: if filter C is added and it references
	// B in its
	//   before field, then A's before field should be modified to point to C, so the order of application would be A, C
	// and finally B.
	// - A filter that has an empty before reference will be applied last (though the date order mentioned above will still
	// apply).
	//   So continuing the above examples, if filter B has an empty before field, then it will be applied last, but if
	// filter D
	//   is created with an empty before field, then B's before field will be modified to point to D, so B will be applied
	// before D.
	Before *string `json:"before,omitempty"`

	// IP Prefix GE.
	Ge *int64 `json:"ge,omitempty"`

	// IP Prefix LE.
	Le *int64 `json:"le,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the CreateTransitGatewayConnectionPrefixFilterOptions.Action property.
// Whether to permit or deny prefix filter.
const (
	CreateTransitGatewayConnectionPrefixFilterOptions_Action_Deny   = "deny"
	CreateTransitGatewayConnectionPrefixFilterOptions_Action_Permit = "permit"
)

// NewCreateTransitGatewayConnectionPrefixFilterOptions : Instantiate CreateTransitGatewayConnectionPrefixFilterOptions
func (*TransitGatewayApisV1) NewCreateTransitGatewayConnectionPrefixFilterOptions(transitGatewayID string, id string, action string, prefix string) *CreateTransitGatewayConnectionPrefixFilterOptions {
	return &CreateTransitGatewayConnectionPrefixFilterOptions{
		TransitGatewayID: core.StringPtr(transitGatewayID),
		ID:               core.StringPtr(id),
		Action:           core.StringPtr(action),
		Prefix:           core.StringPtr(prefix),
	}
}

// SetTransitGatewayID : Allow user to set TransitGatewayID
func (_options *CreateTransitGatewayConnectionPrefixFilterOptions) SetTransitGatewayID(transitGatewayID string) *CreateTransitGatewayConnectionPrefixFilterOptions {
	_options.TransitGatewayID = core.StringPtr(transitGatewayID)
	return _options
}

// SetID : Allow user to set ID
func (_options *CreateTransitGatewayConnectionPrefixFilterOptions) SetID(id string) *CreateTransitGatewayConnectionPrefixFilterOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetAction : Allow user to set Action
func (_options *CreateTransitGatewayConnectionPrefixFilterOptions) SetAction(action string) *CreateTransitGatewayConnectionPrefixFilterOptions {
	_options.Action = core.StringPtr(action)
	return _options
}

// SetPrefix : Allow user to set Prefix
func (_options *CreateTransitGatewayConnectionPrefixFilterOptions) SetPrefix(prefix string) *CreateTransitGatewayConnectionPrefixFilterOptions {
	_options.Prefix = core.StringPtr(prefix)
	return _options
}

// SetBefore : Allow user to set Before
func (_options *CreateTransitGatewayConnectionPrefixFilterOptions) SetBefore(before string) *CreateTransitGatewayConnectionPrefixFilterOptions {
	_options.Before = core.StringPtr(before)
	return _options
}

// SetGe : Allow user to set Ge
func (_options *CreateTransitGatewayConnectionPrefixFilterOptions) SetGe(ge int64) *CreateTransitGatewayConnectionPrefixFilterOptions {
	_options.Ge = core.Int64Ptr(ge)
	return _options
}

// SetLe : Allow user to set Le
func (_options *CreateTransitGatewayConnectionPrefixFilterOptions) SetLe(le int64) *CreateTransitGatewayConnectionPrefixFilterOptions {
	_options.Le = core.Int64Ptr(le)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateTransitGatewayConnectionPrefixFilterOptions) SetHeaders(param map[string]string) *CreateTransitGatewayConnectionPrefixFilterOptions {
	options.Headers = param
	return options
}

// CreateTransitGatewayOptions : The CreateTransitGateway options.
type CreateTransitGatewayOptions struct {
	// Location of Transit Gateway Services.
	Location *string `json:"location" validate:"required"`

	// Name Transit Gateway Services.
	Name *string `json:"name" validate:"required"`

	// Allow global routing for a Transit Gateway. If unspecified, the default value is false.
	Global *bool `json:"global,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://console.bluemix.net/apidocs/resource-manager#introduction) is used.
	ResourceGroup *ResourceGroupIdentity `json:"resource_group,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateTransitGatewayOptions : Instantiate CreateTransitGatewayOptions
func (*TransitGatewayApisV1) NewCreateTransitGatewayOptions(location string, name string) *CreateTransitGatewayOptions {
	return &CreateTransitGatewayOptions{
		Location: core.StringPtr(location),
		Name:     core.StringPtr(name),
	}
}

// SetLocation : Allow user to set Location
func (_options *CreateTransitGatewayOptions) SetLocation(location string) *CreateTransitGatewayOptions {
	_options.Location = core.StringPtr(location)
	return _options
}

// SetName : Allow user to set Name
func (_options *CreateTransitGatewayOptions) SetName(name string) *CreateTransitGatewayOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetGlobal : Allow user to set Global
func (_options *CreateTransitGatewayOptions) SetGlobal(global bool) *CreateTransitGatewayOptions {
	_options.Global = core.BoolPtr(global)
	return _options
}

// SetResourceGroup : Allow user to set ResourceGroup
func (_options *CreateTransitGatewayOptions) SetResourceGroup(resourceGroup *ResourceGroupIdentity) *CreateTransitGatewayOptions {
	_options.ResourceGroup = resourceGroup
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateTransitGatewayOptions) SetHeaders(param map[string]string) *CreateTransitGatewayOptions {
	options.Headers = param
	return options
}

// CreateTransitGatewayRouteReportOptions : The CreateTransitGatewayRouteReport options.
type CreateTransitGatewayRouteReportOptions struct {
	// The Transit Gateway identifier.
	TransitGatewayID *string `json:"transit_gateway_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateTransitGatewayRouteReportOptions : Instantiate CreateTransitGatewayRouteReportOptions
func (*TransitGatewayApisV1) NewCreateTransitGatewayRouteReportOptions(transitGatewayID string) *CreateTransitGatewayRouteReportOptions {
	return &CreateTransitGatewayRouteReportOptions{
		TransitGatewayID: core.StringPtr(transitGatewayID),
	}
}

// SetTransitGatewayID : Allow user to set TransitGatewayID
func (_options *CreateTransitGatewayRouteReportOptions) SetTransitGatewayID(transitGatewayID string) *CreateTransitGatewayRouteReportOptions {
	_options.TransitGatewayID = core.StringPtr(transitGatewayID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateTransitGatewayRouteReportOptions) SetHeaders(param map[string]string) *CreateTransitGatewayRouteReportOptions {
	options.Headers = param
	return options
}

// DeleteTransitGatewayConnectionOptions : The DeleteTransitGatewayConnection options.
type DeleteTransitGatewayConnectionOptions struct {
	// The Transit Gateway identifier.
	TransitGatewayID *string `json:"transit_gateway_id" validate:"required,ne="`

	// The connection identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteTransitGatewayConnectionOptions : Instantiate DeleteTransitGatewayConnectionOptions
func (*TransitGatewayApisV1) NewDeleteTransitGatewayConnectionOptions(transitGatewayID string, id string) *DeleteTransitGatewayConnectionOptions {
	return &DeleteTransitGatewayConnectionOptions{
		TransitGatewayID: core.StringPtr(transitGatewayID),
		ID:               core.StringPtr(id),
	}
}

// SetTransitGatewayID : Allow user to set TransitGatewayID
func (_options *DeleteTransitGatewayConnectionOptions) SetTransitGatewayID(transitGatewayID string) *DeleteTransitGatewayConnectionOptions {
	_options.TransitGatewayID = core.StringPtr(transitGatewayID)
	return _options
}

// SetID : Allow user to set ID
func (_options *DeleteTransitGatewayConnectionOptions) SetID(id string) *DeleteTransitGatewayConnectionOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteTransitGatewayConnectionOptions) SetHeaders(param map[string]string) *DeleteTransitGatewayConnectionOptions {
	options.Headers = param
	return options
}

// DeleteTransitGatewayConnectionPrefixFilterOptions : The DeleteTransitGatewayConnectionPrefixFilter options.
type DeleteTransitGatewayConnectionPrefixFilterOptions struct {
	// The Transit Gateway identifier.
	TransitGatewayID *string `json:"transit_gateway_id" validate:"required,ne="`

	// The connection identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Prefix filter identifier.
	FilterID *string `json:"filter_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteTransitGatewayConnectionPrefixFilterOptions : Instantiate DeleteTransitGatewayConnectionPrefixFilterOptions
func (*TransitGatewayApisV1) NewDeleteTransitGatewayConnectionPrefixFilterOptions(transitGatewayID string, id string, filterID string) *DeleteTransitGatewayConnectionPrefixFilterOptions {
	return &DeleteTransitGatewayConnectionPrefixFilterOptions{
		TransitGatewayID: core.StringPtr(transitGatewayID),
		ID:               core.StringPtr(id),
		FilterID:         core.StringPtr(filterID),
	}
}

// SetTransitGatewayID : Allow user to set TransitGatewayID
func (_options *DeleteTransitGatewayConnectionPrefixFilterOptions) SetTransitGatewayID(transitGatewayID string) *DeleteTransitGatewayConnectionPrefixFilterOptions {
	_options.TransitGatewayID = core.StringPtr(transitGatewayID)
	return _options
}

// SetID : Allow user to set ID
func (_options *DeleteTransitGatewayConnectionPrefixFilterOptions) SetID(id string) *DeleteTransitGatewayConnectionPrefixFilterOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetFilterID : Allow user to set FilterID
func (_options *DeleteTransitGatewayConnectionPrefixFilterOptions) SetFilterID(filterID string) *DeleteTransitGatewayConnectionPrefixFilterOptions {
	_options.FilterID = core.StringPtr(filterID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteTransitGatewayConnectionPrefixFilterOptions) SetHeaders(param map[string]string) *DeleteTransitGatewayConnectionPrefixFilterOptions {
	options.Headers = param
	return options
}

// DeleteTransitGatewayOptions : The DeleteTransitGateway options.
type DeleteTransitGatewayOptions struct {
	// The Transit Gateway identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteTransitGatewayOptions : Instantiate DeleteTransitGatewayOptions
func (*TransitGatewayApisV1) NewDeleteTransitGatewayOptions(id string) *DeleteTransitGatewayOptions {
	return &DeleteTransitGatewayOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *DeleteTransitGatewayOptions) SetID(id string) *DeleteTransitGatewayOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteTransitGatewayOptions) SetHeaders(param map[string]string) *DeleteTransitGatewayOptions {
	options.Headers = param
	return options
}

// DeleteTransitGatewayRouteReportOptions : The DeleteTransitGatewayRouteReport options.
type DeleteTransitGatewayRouteReportOptions struct {
	// The Transit Gateway identifier.
	TransitGatewayID *string `json:"transit_gateway_id" validate:"required,ne="`

	// Route report identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteTransitGatewayRouteReportOptions : Instantiate DeleteTransitGatewayRouteReportOptions
func (*TransitGatewayApisV1) NewDeleteTransitGatewayRouteReportOptions(transitGatewayID string, id string) *DeleteTransitGatewayRouteReportOptions {
	return &DeleteTransitGatewayRouteReportOptions{
		TransitGatewayID: core.StringPtr(transitGatewayID),
		ID:               core.StringPtr(id),
	}
}

// SetTransitGatewayID : Allow user to set TransitGatewayID
func (_options *DeleteTransitGatewayRouteReportOptions) SetTransitGatewayID(transitGatewayID string) *DeleteTransitGatewayRouteReportOptions {
	_options.TransitGatewayID = core.StringPtr(transitGatewayID)
	return _options
}

// SetID : Allow user to set ID
func (_options *DeleteTransitGatewayRouteReportOptions) SetID(id string) *DeleteTransitGatewayRouteReportOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteTransitGatewayRouteReportOptions) SetHeaders(param map[string]string) *DeleteTransitGatewayRouteReportOptions {
	options.Headers = param
	return options
}

// GetGatewayLocationOptions : The GetGatewayLocation options.
type GetGatewayLocationOptions struct {
	// The Transit Gateway location Name.
	Name *string `json:"name" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetGatewayLocationOptions : Instantiate GetGatewayLocationOptions
func (*TransitGatewayApisV1) NewGetGatewayLocationOptions(name string) *GetGatewayLocationOptions {
	return &GetGatewayLocationOptions{
		Name: core.StringPtr(name),
	}
}

// SetName : Allow user to set Name
func (_options *GetGatewayLocationOptions) SetName(name string) *GetGatewayLocationOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetGatewayLocationOptions) SetHeaders(param map[string]string) *GetGatewayLocationOptions {
	options.Headers = param
	return options
}

// GetTransitGatewayConnectionOptions : The GetTransitGatewayConnection options.
type GetTransitGatewayConnectionOptions struct {
	// The Transit Gateway identifier.
	TransitGatewayID *string `json:"transit_gateway_id" validate:"required,ne="`

	// The connection identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetTransitGatewayConnectionOptions : Instantiate GetTransitGatewayConnectionOptions
func (*TransitGatewayApisV1) NewGetTransitGatewayConnectionOptions(transitGatewayID string, id string) *GetTransitGatewayConnectionOptions {
	return &GetTransitGatewayConnectionOptions{
		TransitGatewayID: core.StringPtr(transitGatewayID),
		ID:               core.StringPtr(id),
	}
}

// SetTransitGatewayID : Allow user to set TransitGatewayID
func (_options *GetTransitGatewayConnectionOptions) SetTransitGatewayID(transitGatewayID string) *GetTransitGatewayConnectionOptions {
	_options.TransitGatewayID = core.StringPtr(transitGatewayID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetTransitGatewayConnectionOptions) SetID(id string) *GetTransitGatewayConnectionOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetTransitGatewayConnectionOptions) SetHeaders(param map[string]string) *GetTransitGatewayConnectionOptions {
	options.Headers = param
	return options
}

// GetTransitGatewayConnectionPrefixFilterOptions : The GetTransitGatewayConnectionPrefixFilter options.
type GetTransitGatewayConnectionPrefixFilterOptions struct {
	// The Transit Gateway identifier.
	TransitGatewayID *string `json:"transit_gateway_id" validate:"required,ne="`

	// The connection identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Prefix filter identifier.
	FilterID *string `json:"filter_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetTransitGatewayConnectionPrefixFilterOptions : Instantiate GetTransitGatewayConnectionPrefixFilterOptions
func (*TransitGatewayApisV1) NewGetTransitGatewayConnectionPrefixFilterOptions(transitGatewayID string, id string, filterID string) *GetTransitGatewayConnectionPrefixFilterOptions {
	return &GetTransitGatewayConnectionPrefixFilterOptions{
		TransitGatewayID: core.StringPtr(transitGatewayID),
		ID:               core.StringPtr(id),
		FilterID:         core.StringPtr(filterID),
	}
}

// SetTransitGatewayID : Allow user to set TransitGatewayID
func (_options *GetTransitGatewayConnectionPrefixFilterOptions) SetTransitGatewayID(transitGatewayID string) *GetTransitGatewayConnectionPrefixFilterOptions {
	_options.TransitGatewayID = core.StringPtr(transitGatewayID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetTransitGatewayConnectionPrefixFilterOptions) SetID(id string) *GetTransitGatewayConnectionPrefixFilterOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetFilterID : Allow user to set FilterID
func (_options *GetTransitGatewayConnectionPrefixFilterOptions) SetFilterID(filterID string) *GetTransitGatewayConnectionPrefixFilterOptions {
	_options.FilterID = core.StringPtr(filterID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetTransitGatewayConnectionPrefixFilterOptions) SetHeaders(param map[string]string) *GetTransitGatewayConnectionPrefixFilterOptions {
	options.Headers = param
	return options
}

// GetTransitGatewayOptions : The GetTransitGateway options.
type GetTransitGatewayOptions struct {
	// The Transit Gateway identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetTransitGatewayOptions : Instantiate GetTransitGatewayOptions
func (*TransitGatewayApisV1) NewGetTransitGatewayOptions(id string) *GetTransitGatewayOptions {
	return &GetTransitGatewayOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *GetTransitGatewayOptions) SetID(id string) *GetTransitGatewayOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetTransitGatewayOptions) SetHeaders(param map[string]string) *GetTransitGatewayOptions {
	options.Headers = param
	return options
}

// GetTransitGatewayRouteReportOptions : The GetTransitGatewayRouteReport options.
type GetTransitGatewayRouteReportOptions struct {
	// The Transit Gateway identifier.
	TransitGatewayID *string `json:"transit_gateway_id" validate:"required,ne="`

	// Route report identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetTransitGatewayRouteReportOptions : Instantiate GetTransitGatewayRouteReportOptions
func (*TransitGatewayApisV1) NewGetTransitGatewayRouteReportOptions(transitGatewayID string, id string) *GetTransitGatewayRouteReportOptions {
	return &GetTransitGatewayRouteReportOptions{
		TransitGatewayID: core.StringPtr(transitGatewayID),
		ID:               core.StringPtr(id),
	}
}

// SetTransitGatewayID : Allow user to set TransitGatewayID
func (_options *GetTransitGatewayRouteReportOptions) SetTransitGatewayID(transitGatewayID string) *GetTransitGatewayRouteReportOptions {
	_options.TransitGatewayID = core.StringPtr(transitGatewayID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetTransitGatewayRouteReportOptions) SetID(id string) *GetTransitGatewayRouteReportOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetTransitGatewayRouteReportOptions) SetHeaders(param map[string]string) *GetTransitGatewayRouteReportOptions {
	options.Headers = param
	return options
}

// ListConnectionsOptions : The ListConnections options.
type ListConnectionsOptions struct {
	// The maximum number of resources to return per page.
	Limit *int64 `json:"limit,omitempty"`

	// A server supplied token determining which resource to start the page on.
	Start *string `json:"start,omitempty"`

	// Search for connections with the given network_id value.
	NetworkID *string `json:"network_id,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListConnectionsOptions : Instantiate ListConnectionsOptions
func (*TransitGatewayApisV1) NewListConnectionsOptions() *ListConnectionsOptions {
	return &ListConnectionsOptions{}
}

// SetLimit : Allow user to set Limit
func (_options *ListConnectionsOptions) SetLimit(limit int64) *ListConnectionsOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetStart : Allow user to set Start
func (_options *ListConnectionsOptions) SetStart(start string) *ListConnectionsOptions {
	_options.Start = core.StringPtr(start)
	return _options
}

// SetNetworkID : Allow user to set NetworkID
func (_options *ListConnectionsOptions) SetNetworkID(networkID string) *ListConnectionsOptions {
	_options.NetworkID = core.StringPtr(networkID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListConnectionsOptions) SetHeaders(param map[string]string) *ListConnectionsOptions {
	options.Headers = param
	return options
}

// ListGatewayLocationsOptions : The ListGatewayLocations options.
type ListGatewayLocationsOptions struct {

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListGatewayLocationsOptions : Instantiate ListGatewayLocationsOptions
func (*TransitGatewayApisV1) NewListGatewayLocationsOptions() *ListGatewayLocationsOptions {
	return &ListGatewayLocationsOptions{}
}

// SetHeaders : Allow user to set Headers
func (options *ListGatewayLocationsOptions) SetHeaders(param map[string]string) *ListGatewayLocationsOptions {
	options.Headers = param
	return options
}

// ListTransitGatewayConnectionPrefixFiltersOptions : The ListTransitGatewayConnectionPrefixFilters options.
type ListTransitGatewayConnectionPrefixFiltersOptions struct {
	// The Transit Gateway identifier.
	TransitGatewayID *string `json:"transit_gateway_id" validate:"required,ne="`

	// The connection identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListTransitGatewayConnectionPrefixFiltersOptions : Instantiate ListTransitGatewayConnectionPrefixFiltersOptions
func (*TransitGatewayApisV1) NewListTransitGatewayConnectionPrefixFiltersOptions(transitGatewayID string, id string) *ListTransitGatewayConnectionPrefixFiltersOptions {
	return &ListTransitGatewayConnectionPrefixFiltersOptions{
		TransitGatewayID: core.StringPtr(transitGatewayID),
		ID:               core.StringPtr(id),
	}
}

// SetTransitGatewayID : Allow user to set TransitGatewayID
func (_options *ListTransitGatewayConnectionPrefixFiltersOptions) SetTransitGatewayID(transitGatewayID string) *ListTransitGatewayConnectionPrefixFiltersOptions {
	_options.TransitGatewayID = core.StringPtr(transitGatewayID)
	return _options
}

// SetID : Allow user to set ID
func (_options *ListTransitGatewayConnectionPrefixFiltersOptions) SetID(id string) *ListTransitGatewayConnectionPrefixFiltersOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListTransitGatewayConnectionPrefixFiltersOptions) SetHeaders(param map[string]string) *ListTransitGatewayConnectionPrefixFiltersOptions {
	options.Headers = param
	return options
}

// ListTransitGatewayConnectionsOptions : The ListTransitGatewayConnections options.
type ListTransitGatewayConnectionsOptions struct {
	// The Transit Gateway identifier.
	TransitGatewayID *string `json:"transit_gateway_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListTransitGatewayConnectionsOptions : Instantiate ListTransitGatewayConnectionsOptions
func (*TransitGatewayApisV1) NewListTransitGatewayConnectionsOptions(transitGatewayID string) *ListTransitGatewayConnectionsOptions {
	return &ListTransitGatewayConnectionsOptions{
		TransitGatewayID: core.StringPtr(transitGatewayID),
	}
}

// SetTransitGatewayID : Allow user to set TransitGatewayID
func (_options *ListTransitGatewayConnectionsOptions) SetTransitGatewayID(transitGatewayID string) *ListTransitGatewayConnectionsOptions {
	_options.TransitGatewayID = core.StringPtr(transitGatewayID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListTransitGatewayConnectionsOptions) SetHeaders(param map[string]string) *ListTransitGatewayConnectionsOptions {
	options.Headers = param
	return options
}

// ListTransitGatewayRouteReportsOptions : The ListTransitGatewayRouteReports options.
type ListTransitGatewayRouteReportsOptions struct {
	// The Transit Gateway identifier.
	TransitGatewayID *string `json:"transit_gateway_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListTransitGatewayRouteReportsOptions : Instantiate ListTransitGatewayRouteReportsOptions
func (*TransitGatewayApisV1) NewListTransitGatewayRouteReportsOptions(transitGatewayID string) *ListTransitGatewayRouteReportsOptions {
	return &ListTransitGatewayRouteReportsOptions{
		TransitGatewayID: core.StringPtr(transitGatewayID),
	}
}

// SetTransitGatewayID : Allow user to set TransitGatewayID
func (_options *ListTransitGatewayRouteReportsOptions) SetTransitGatewayID(transitGatewayID string) *ListTransitGatewayRouteReportsOptions {
	_options.TransitGatewayID = core.StringPtr(transitGatewayID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListTransitGatewayRouteReportsOptions) SetHeaders(param map[string]string) *ListTransitGatewayRouteReportsOptions {
	options.Headers = param
	return options
}

// ListTransitGatewaysOptions : The ListTransitGateways options.
type ListTransitGatewaysOptions struct {
	// The maximum number of resources to return per page.
	Limit *int64 `json:"limit,omitempty"`

	// A server supplied token determining which resource to start the page on.
	Start *string `json:"start,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListTransitGatewaysOptions : Instantiate ListTransitGatewaysOptions
func (*TransitGatewayApisV1) NewListTransitGatewaysOptions() *ListTransitGatewaysOptions {
	return &ListTransitGatewaysOptions{}
}

// SetLimit : Allow user to set Limit
func (_options *ListTransitGatewaysOptions) SetLimit(limit int64) *ListTransitGatewaysOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetStart : Allow user to set Start
func (_options *ListTransitGatewaysOptions) SetStart(start string) *ListTransitGatewaysOptions {
	_options.Start = core.StringPtr(start)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListTransitGatewaysOptions) SetHeaders(param map[string]string) *ListTransitGatewaysOptions {
	options.Headers = param
	return options
}

// PrefixFilterCollection : prefix filters.
type PrefixFilterCollection struct {
	// Array of prefix filters.
	PrefixFilters []PrefixFilterCust `json:"prefix_filters" validate:"required"`
}

// UnmarshalPrefixFilterCollection unmarshals an instance of PrefixFilterCollection from the specified map of raw messages.
func UnmarshalPrefixFilterCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PrefixFilterCollection)
	err = core.UnmarshalModel(m, "prefix_filters", &obj.PrefixFilters, UnmarshalPrefixFilterCust)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PrefixFilterCust : prefix filter.
type PrefixFilterCust struct {
	// Whether to permit or deny prefix filter.
	Action *string `json:"action" validate:"required"`

	// Identifier of prefix filter that handles the ordering and follow semantics:
	// - When a filter reference another filter in it's before field, then the filter making the reference is applied
	// before
	//   the referenced filter. For example: if filter A references filter B in its before field, A is applied before B.
	// - When a new filter is added that has the same before as an existing filter, then the older filter will have its
	// before
	//   field updated to point to the new filter. Starting with the above example: if filter C is added and it references
	// B in its
	//   before field, then A's before field should be modified to point to C, so the order of application would be A, C
	// and finally B.
	// - A filter that has an empty before reference will be applied last (though the date order mentioned above will still
	// apply).
	//   So continuing the above examples, if filter B has an empty before field, then it will be applied last, but if
	// filter D
	//   is created with an empty before field, then B's before field will be modified to point to D, so B will be applied
	// before D.
	Before *string `json:"before,omitempty"`

	// The date and time that this prefix filter was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// IP Prefix GE.
	Ge *int64 `json:"ge,omitempty"`

	// Prefix Filter identifier.
	ID *string `json:"id" validate:"required"`

	// IP Prefix LE.
	Le *int64 `json:"le,omitempty"`

	// IP Prefix.
	Prefix *string `json:"prefix" validate:"required"`

	// The date and time that this prefix filter was last updated.
	UpdatedAt *strfmt.DateTime `json:"updated_at,omitempty"`
}

// Constants associated with the PrefixFilterCust.Action property.
// Whether to permit or deny prefix filter.
const (
	PrefixFilterCust_Action_Deny   = "deny"
	PrefixFilterCust_Action_Permit = "permit"
)

// UnmarshalPrefixFilterCust unmarshals an instance of PrefixFilterCust from the specified map of raw messages.
func UnmarshalPrefixFilterCust(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PrefixFilterCust)
	err = core.UnmarshalPrimitive(m, "action", &obj.Action)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "before", &obj.Before)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ge", &obj.Ge)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "le", &obj.Le)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "prefix", &obj.Prefix)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PrefixFilterPut : A prefix filter create template.
type PrefixFilterPut struct {
	// Whether to permit or deny prefix filter.
	Action *string `json:"action" validate:"required"`

	// IP Prefix GE.
	Ge *int64 `json:"ge,omitempty"`

	// IP Prefix LE.
	Le *int64 `json:"le,omitempty"`

	// IP Prefix.
	Prefix *string `json:"prefix" validate:"required"`
}

// Constants associated with the PrefixFilterPut.Action property.
// Whether to permit or deny prefix filter.
const (
	PrefixFilterPut_Action_Deny   = "deny"
	PrefixFilterPut_Action_Permit = "permit"
)

// NewPrefixFilterPut : Instantiate PrefixFilterPut (Generic Model Constructor)
func (*TransitGatewayApisV1) NewPrefixFilterPut(action string, prefix string) (_model *PrefixFilterPut, err error) {
	_model = &PrefixFilterPut{
		Action: core.StringPtr(action),
		Prefix: core.StringPtr(prefix),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

// UnmarshalPrefixFilterPut unmarshals an instance of PrefixFilterPut from the specified map of raw messages.
func UnmarshalPrefixFilterPut(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PrefixFilterPut)
	err = core.UnmarshalPrimitive(m, "action", &obj.Action)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ge", &obj.Ge)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "le", &obj.Le)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "prefix", &obj.Prefix)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ReplaceTransitGatewayConnectionPrefixFilterOptions : The ReplaceTransitGatewayConnectionPrefixFilter options.
type ReplaceTransitGatewayConnectionPrefixFilterOptions struct {
	// The Transit Gateway identifier.
	TransitGatewayID *string `json:"transit_gateway_id" validate:"required,ne="`

	// The connection identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Array of prefix filters.
	PrefixFilters []PrefixFilterPut `json:"prefix_filters" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewReplaceTransitGatewayConnectionPrefixFilterOptions : Instantiate ReplaceTransitGatewayConnectionPrefixFilterOptions
func (*TransitGatewayApisV1) NewReplaceTransitGatewayConnectionPrefixFilterOptions(transitGatewayID string, id string, prefixFilters []PrefixFilterPut) *ReplaceTransitGatewayConnectionPrefixFilterOptions {
	return &ReplaceTransitGatewayConnectionPrefixFilterOptions{
		TransitGatewayID: core.StringPtr(transitGatewayID),
		ID:               core.StringPtr(id),
		PrefixFilters:    prefixFilters,
	}
}

// SetTransitGatewayID : Allow user to set TransitGatewayID
func (_options *ReplaceTransitGatewayConnectionPrefixFilterOptions) SetTransitGatewayID(transitGatewayID string) *ReplaceTransitGatewayConnectionPrefixFilterOptions {
	_options.TransitGatewayID = core.StringPtr(transitGatewayID)
	return _options
}

// SetID : Allow user to set ID
func (_options *ReplaceTransitGatewayConnectionPrefixFilterOptions) SetID(id string) *ReplaceTransitGatewayConnectionPrefixFilterOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetPrefixFilters : Allow user to set PrefixFilters
func (_options *ReplaceTransitGatewayConnectionPrefixFilterOptions) SetPrefixFilters(prefixFilters []PrefixFilterPut) *ReplaceTransitGatewayConnectionPrefixFilterOptions {
	_options.PrefixFilters = prefixFilters
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ReplaceTransitGatewayConnectionPrefixFilterOptions) SetHeaders(param map[string]string) *ReplaceTransitGatewayConnectionPrefixFilterOptions {
	options.Headers = param
	return options
}

// ResourceGroupIdentity : The resource group to use. If unspecified, the account's [default resource
// group](https://console.bluemix.net/apidocs/resource-manager#introduction) is used.
type ResourceGroupIdentity struct {
	// The unique identifier for this resource group.
	ID *string `json:"id" validate:"required"`
}

// NewResourceGroupIdentity : Instantiate ResourceGroupIdentity (Generic Model Constructor)
func (*TransitGatewayApisV1) NewResourceGroupIdentity(id string) (_model *ResourceGroupIdentity, err error) {
	_model = &ResourceGroupIdentity{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

// UnmarshalResourceGroupIdentity unmarshals an instance of ResourceGroupIdentity from the specified map of raw messages.
func UnmarshalResourceGroupIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ResourceGroupIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ResourceGroupReference : The resource group to use. If unspecified, the account's [default resource
// group](https://console.bluemix.net/apidocs/resource-manager#introduction) is used.
type ResourceGroupReference struct {
	// The unique identifier for this resource group.
	ID *string `json:"id" validate:"required"`

	// The URL for this resource group.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalResourceGroupReference unmarshals an instance of ResourceGroupReference from the specified map of raw messages.
func UnmarshalResourceGroupReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ResourceGroupReference)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RouteReport : route report.
type RouteReport struct {
	// Array of connections with their routes.
	Connections []RouteReportConnection `json:"connections" validate:"required"`

	// Date and time route report was requested.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// Report identifier.
	ID *string `json:"id" validate:"required"`

	// Array of overlapping routes.
	OverlappingRoutes []RouteReportOverlappingRouteGroup `json:"overlapping_routes" validate:"required"`

	// Route report status. The list of enumerated values for this property may expand in the future. Code and processes
	// using this field must tolerate unexpected values.
	Status *string `json:"status" validate:"required"`

	// Date and time route report was last modified.
	UpdatedAt *strfmt.DateTime `json:"updated_at,omitempty"`
}

// Constants associated with the RouteReport.Status property.
// Route report status. The list of enumerated values for this property may expand in the future. Code and processes
// using this field must tolerate unexpected values.
const (
	RouteReport_Status_Complete = "complete"
	RouteReport_Status_Pending  = "pending"
)

// UnmarshalRouteReport unmarshals an instance of RouteReport from the specified map of raw messages.
func UnmarshalRouteReport(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RouteReport)
	err = core.UnmarshalModel(m, "connections", &obj.Connections, UnmarshalRouteReportConnection)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "overlapping_routes", &obj.OverlappingRoutes, UnmarshalRouteReportOverlappingRouteGroup)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RouteReportCollection : route reports.
type RouteReportCollection struct {
	// Array of route reports.
	RouteReports []RouteReport `json:"route_reports" validate:"required"`
}

// UnmarshalRouteReportCollection unmarshals an instance of RouteReportCollection from the specified map of raw messages.
func UnmarshalRouteReportCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RouteReportCollection)
	err = core.UnmarshalModel(m, "route_reports", &obj.RouteReports, UnmarshalRouteReport)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RouteReportConnection : route report connection.
type RouteReportConnection struct {
	// Array of connection's bgps.
	Bgps []RouteReportConnectionBgp `json:"bgps,omitempty"`

	// connection ID.
	ID *string `json:"id,omitempty"`

	// connection name.
	Name *string `json:"name,omitempty"`

	// Array of connection's routes.
	Routes []RouteReportConnectionRoute `json:"routes,omitempty"`

	// connection type.
	Type *string `json:"type,omitempty"`
}

// UnmarshalRouteReportConnection unmarshals an instance of RouteReportConnection from the specified map of raw messages.
func UnmarshalRouteReportConnection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RouteReportConnection)
	err = core.UnmarshalModel(m, "bgps", &obj.Bgps, UnmarshalRouteReportConnectionBgp)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "routes", &obj.Routes, UnmarshalRouteReportConnectionRoute)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RouteReportConnectionBgp : connection bgp details.
type RouteReportConnectionBgp struct {
	// AS path.
	AsPath *string `json:"as_path,omitempty"`

	// Indicates whether current route is used or not.
	IsUsed *bool `json:"is_used,omitempty"`

	// local preference.
	LocalPreference *string `json:"local_preference,omitempty"`

	// prefix.
	Prefix *string `json:"prefix,omitempty"`
}

// UnmarshalRouteReportConnectionBgp unmarshals an instance of RouteReportConnectionBgp from the specified map of raw messages.
func UnmarshalRouteReportConnectionBgp(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RouteReportConnectionBgp)
	err = core.UnmarshalPrimitive(m, "as_path", &obj.AsPath)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "is_used", &obj.IsUsed)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "local_preference", &obj.LocalPreference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "prefix", &obj.Prefix)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RouteReportConnectionRoute : connection used route.
type RouteReportConnectionRoute struct {
	// prefix.
	Prefix *string `json:"prefix,omitempty"`
}

// UnmarshalRouteReportConnectionRoute unmarshals an instance of RouteReportConnectionRoute from the specified map of raw messages.
func UnmarshalRouteReportConnectionRoute(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RouteReportConnectionRoute)
	err = core.UnmarshalPrimitive(m, "prefix", &obj.Prefix)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RouteReportOverlappingRoute : overlapping route details.
type RouteReportOverlappingRoute struct {
	// connection ID.
	ConnectionID *string `json:"connection_id,omitempty"`

	// overlapping prefix.
	Prefix *string `json:"prefix,omitempty"`
}

// UnmarshalRouteReportOverlappingRoute unmarshals an instance of RouteReportOverlappingRoute from the specified map of raw messages.
func UnmarshalRouteReportOverlappingRoute(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RouteReportOverlappingRoute)
	err = core.UnmarshalPrimitive(m, "connection_id", &obj.ConnectionID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "prefix", &obj.Prefix)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RouteReportOverlappingRouteGroup : Collection of overlapping route.
type RouteReportOverlappingRouteGroup struct {
	// Array of overlapping connection/prefix pairs.
	Routes []RouteReportOverlappingRoute `json:"routes,omitempty"`
}

// UnmarshalRouteReportOverlappingRouteGroup unmarshals an instance of RouteReportOverlappingRouteGroup from the specified map of raw messages.
func UnmarshalRouteReportOverlappingRouteGroup(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RouteReportOverlappingRouteGroup)
	err = core.UnmarshalModel(m, "routes", &obj.Routes, UnmarshalRouteReportOverlappingRoute)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TSCollection : A list of Transit Gateway locations.
type TSCollection struct {
	// Collection of Transit Gateway locations.
	Locations []TSLocationBasic `json:"locations" validate:"required"`
}

// UnmarshalTSCollection unmarshals an instance of TSCollection from the specified map of raw messages.
func UnmarshalTSCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TSCollection)
	err = core.UnmarshalModel(m, "locations", &obj.Locations, UnmarshalTSLocationBasic)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TSLocalLocation : Details of a local connection location.
type TSLocalLocation struct {
	// A descriptive display name for the location.
	DisplayName *string `json:"display_name,omitempty"`

	// The name of the location.
	Name *string `json:"name,omitempty"`

	// Array of supported connection types.
	SupportedConnectionTypes []string `json:"supported_connection_types,omitempty"`

	// The type of the location, determining is this a multi-zone region, a single data center, or a point of presence. The
	// list of enumerated values for this property may expand in the future. Code and processes using this field must
	// tolerate unexpected values.
	Type *string `json:"type,omitempty"`
}

// Constants associated with the TSLocalLocation.Type property.
// The type of the location, determining is this a multi-zone region, a single data center, or a point of presence. The
// list of enumerated values for this property may expand in the future. Code and processes using this field must
// tolerate unexpected values.
const (
	TSLocalLocation_Type_Dc     = "dc"
	TSLocalLocation_Type_Region = "region"
)

// UnmarshalTSLocalLocation unmarshals an instance of TSLocalLocation from the specified map of raw messages.
func UnmarshalTSLocalLocation(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TSLocalLocation)
	err = core.UnmarshalPrimitive(m, "display_name", &obj.DisplayName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "supported_connection_types", &obj.SupportedConnectionTypes)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TSLocation : Details of a Transit Gateway location.
type TSLocation struct {
	// The geographical location of this location, used for billing purposes.
	BillingLocation *string `json:"billing_location" validate:"required"`

	// Name of the Location.
	Name *string `json:"name" validate:"required"`

	// The type of the location, determining is this a multi-zone region, a single data center, or a point of presence.
	Type *string `json:"type" validate:"required"`

	// The set of network locations that are considered local for this Transit Gateway location.
	LocalConnectionLocations []TSLocalLocation `json:"local_connection_locations" validate:"required"`
}

// UnmarshalTSLocation unmarshals an instance of TSLocation from the specified map of raw messages.
func UnmarshalTSLocation(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TSLocation)
	err = core.UnmarshalPrimitive(m, "billing_location", &obj.BillingLocation)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "local_connection_locations", &obj.LocalConnectionLocations, UnmarshalTSLocalLocation)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TSLocationBasic : Details of a Transit Gateway location.
type TSLocationBasic struct {
	// The geographical location of this location, used for billing purposes.
	BillingLocation *string `json:"billing_location" validate:"required"`

	// Name of the Location.
	Name *string `json:"name" validate:"required"`

	// The type of the location, determining is this a multi-zone region, a single data center, or a point of presence.
	Type *string `json:"type" validate:"required"`
}

// UnmarshalTSLocationBasic unmarshals an instance of TSLocationBasic from the specified map of raw messages.
func UnmarshalTSLocationBasic(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TSLocationBasic)
	err = core.UnmarshalPrimitive(m, "billing_location", &obj.BillingLocation)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TransitConnection : Transit gateway connection.
type TransitConnection struct {
	// network_type 'gre_tunnel' connections use 'base_connection_id' to specify the id of a network_type 'classic'
	// connection the tunnel is configured over. The specified connection must reside in the same transit gateway and be in
	// an active state. The 'classic' connection cannot be deleted until any 'gre_tunnel' connections using it are deleted.
	// This field only applies to and is required for network type 'gre_tunnel' connections.
	BaseConnectionID *string `json:"base_connection_id,omitempty"`

	// The date and time that this connection was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The unique identifier for this connection.
	ID *string `json:"id" validate:"required"`

	// Local network BGP ASN.  This field only applies to network type 'gre_tunnel' connections.
	LocalBgpAsn *int64 `json:"local_bgp_asn,omitempty"`

	// Local gateway IP address.  This field only applies to network type 'gre_tunnel' connections.
	LocalGatewayIp *string `json:"local_gateway_ip,omitempty"`

	// Local tunnel IP address.  This field only applies to network type 'gre_tunnel' connections.
	LocalTunnelIp *string `json:"local_tunnel_ip,omitempty"`

	// GRE tunnel MTU.  This field only applies to network type 'gre_tunnel' connections.
	Mtu *int64 `json:"mtu,omitempty"`

	// The user-defined name for this transit gateway connection.
	Name *string `json:"name" validate:"required"`

	// The ID of the account which owns the connected network. Generally only used if the network is in a different IBM
	// Cloud account than the gateway.
	NetworkAccountID *string `json:"network_account_id,omitempty"`

	// The ID of the network being connected via this connection. This field is required for some types, such as 'vpc',
	// 'power_virtual_server' and 'directlink'. For network types 'vpc','power_virtual_server' and 'directlink' this is the
	// CRN of the VPC / PowerVS / Direct Link gateway respectively.
	NetworkID *string `json:"network_id,omitempty"`

	// Defines what type of network is connected via this connection. The list of enumerated values for this property may
	// expand in the future. Code and processes using this field must tolerate unexpected values.
	NetworkType *string `json:"network_type" validate:"required"`

	// Array of prefix route filters for a transit gateway connection. This is order dependent with those first in the
	// array being applied first, and those at the end of the array is applied last, or just before the default.
	PrefixFilters []TransitGatewayConnectionPrefixFilterReference `json:"prefix_filters,omitempty"`

	// Default setting of permit or deny which applies to any routes that don't match a specified filter.
	PrefixFiltersDefault *string `json:"prefix_filters_default" validate:"required"`

	// Remote network BGP ASN.  This field only applies to network type 'gre_tunnel' connections.
	RemoteBgpAsn *int64 `json:"remote_bgp_asn,omitempty"`

	// Remote gateway IP address.  This field only applies to network type 'gre_tunnel' connections.
	RemoteGatewayIp *string `json:"remote_gateway_ip,omitempty"`

	// Remote tunnel IP address.  This field only applies to network type 'gre_tunnel' connections.
	RemoteTunnelIp *string `json:"remote_tunnel_ip,omitempty"`

	// Only visible for cross account connections, this field represents the status of a connection request between IBM
	// Cloud accounts. The list of enumerated values for this property may expand in the future. Code and processes using
	// this field must tolerate unexpected values.
	RequestStatus *string `json:"request_status,omitempty"`

	// Connection state. The list of enumerated values for this property may expand in the future. Code and processes using
	// this field must tolerate unexpected values.
	Status *string `json:"status" validate:"required"`

	// Reference to the transit gateway that contains this connection.
	TransitGateway *TransitGatewayReference `json:"transit_gateway" validate:"required"`

	// The date and time that this connection was last updated.
	UpdatedAt *strfmt.DateTime `json:"updated_at,omitempty"`

	// Location of GRE tunnel.  This field only applies to network type 'gre_tunnel' connections.
	Zone *ZoneReference `json:"zone,omitempty"`
}

// Constants associated with the TransitConnection.NetworkType property.
// Defines what type of network is connected via this connection. The list of enumerated values for this property may
// expand in the future. Code and processes using this field must tolerate unexpected values.
const (
	TransitConnection_NetworkType_Classic            = "classic"
	TransitConnection_NetworkType_Directlink         = "directlink"
	TransitConnection_NetworkType_GreTunnel          = "gre_tunnel"
	TransitConnection_NetworkType_PowerVirtualServer = "power_virtual_server"
	TransitConnection_NetworkType_UnboundGreTunnel   = "unbound_gre_tunnel"
	TransitConnection_NetworkType_Vpc                = "vpc"
)

// Constants associated with the TransitConnection.PrefixFiltersDefault property.
// Default setting of permit or deny which applies to any routes that don't match a specified filter.
const (
	TransitConnection_PrefixFiltersDefault_Deny   = "deny"
	TransitConnection_PrefixFiltersDefault_Permit = "permit"
)

// Constants associated with the TransitConnection.RequestStatus property.
// Only visible for cross account connections, this field represents the status of a connection request between IBM
// Cloud accounts. The list of enumerated values for this property may expand in the future. Code and processes using
// this field must tolerate unexpected values.
const (
	TransitConnection_RequestStatus_Approved = "approved"
	TransitConnection_RequestStatus_Detached = "detached"
	TransitConnection_RequestStatus_Expired  = "expired"
	TransitConnection_RequestStatus_Pending  = "pending"
	TransitConnection_RequestStatus_Rejected = "rejected"
)

// Constants associated with the TransitConnection.Status property.
// Connection state. The list of enumerated values for this property may expand in the future. Code and processes using
// this field must tolerate unexpected values.
const (
	TransitConnection_Status_Attached   = "attached"
	TransitConnection_Status_Deleting   = "deleting"
	TransitConnection_Status_Detached   = "detached"
	TransitConnection_Status_Detaching  = "detaching"
	TransitConnection_Status_Failed     = "failed"
	TransitConnection_Status_Pending    = "pending"
	TransitConnection_Status_Suspended  = "suspended"
	TransitConnection_Status_Suspending = "suspending"
)

// UnmarshalTransitConnection unmarshals an instance of TransitConnection from the specified map of raw messages.
func UnmarshalTransitConnection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TransitConnection)
	err = core.UnmarshalPrimitive(m, "base_connection_id", &obj.BaseConnectionID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "local_bgp_asn", &obj.LocalBgpAsn)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "local_gateway_ip", &obj.LocalGatewayIp)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "local_tunnel_ip", &obj.LocalTunnelIp)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "mtu", &obj.Mtu)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "network_account_id", &obj.NetworkAccountID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "network_id", &obj.NetworkID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "network_type", &obj.NetworkType)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "prefix_filters", &obj.PrefixFilters, UnmarshalTransitGatewayConnectionPrefixFilterReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "prefix_filters_default", &obj.PrefixFiltersDefault)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "remote_bgp_asn", &obj.RemoteBgpAsn)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "remote_gateway_ip", &obj.RemoteGatewayIp)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "remote_tunnel_ip", &obj.RemoteTunnelIp)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "request_status", &obj.RequestStatus)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "transit_gateway", &obj.TransitGateway, UnmarshalTransitGatewayReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TransitConnectionCollection : Transit gateway connections.
type TransitConnectionCollection struct {
	// Array of transit gateway connections.
	Connections []TransitConnection `json:"connections" validate:"required"`

	// A reference to the first page of resources.
	First *TransitConnectionCollectionFirst `json:"first" validate:"required"`

	// The maximum number of connections returned on one request.
	Limit *int64 `json:"limit" validate:"required"`

	// A reference to the next page of resources; this reference is included for all pages except the last page.
	Next *TransitConnectionCollectionNext `json:"next,omitempty"`
}

// UnmarshalTransitConnectionCollection unmarshals an instance of TransitConnectionCollection from the specified map of raw messages.
func UnmarshalTransitConnectionCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TransitConnectionCollection)
	err = core.UnmarshalModel(m, "connections", &obj.Connections, UnmarshalTransitConnection)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalTransitConnectionCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalTransitConnectionCollectionNext)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *TransitConnectionCollection) GetNextStart() (*string, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	return resp.Next.Start, nil
}

// TransitConnectionCollectionFirst : A reference to the first page of resources.
type TransitConnectionCollectionFirst struct {
	// url.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalTransitConnectionCollectionFirst unmarshals an instance of TransitConnectionCollectionFirst from the specified map of raw messages.
func UnmarshalTransitConnectionCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TransitConnectionCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TransitConnectionCollectionNext : A reference to the next page of resources; this reference is included for all pages except the last page.
type TransitConnectionCollectionNext struct {
	// url.
	Href *string `json:"href,omitempty"`

	// server generated start token for next page of resources.
	Start *string `json:"start,omitempty"`
}

// UnmarshalTransitConnectionCollectionNext unmarshals an instance of TransitConnectionCollectionNext from the specified map of raw messages.
func UnmarshalTransitConnectionCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TransitConnectionCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "start", &obj.Start)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TransitGateway : Details of a Transit Gateway.
type TransitGateway struct {
	// The unique identifier for this Transit Gateway.
	ID *string `json:"id" validate:"required"`

	// The CRN for this Transit Gateway.
	Crn *string `json:"crn" validate:"required"`

	// A human readable name for the transit gateway.
	Name *string `json:"name" validate:"required"`

	// Location of Transit Gateway Services.
	Location *string `json:"location" validate:"required"`

	// The date and time that this gateway was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// Allow global routing for a Transit Gateway.
	Global *bool `json:"global" validate:"required"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://console.bluemix.net/apidocs/resource-manager#introduction) is used.
	ResourceGroup *ResourceGroupReference `json:"resource_group,omitempty"`

	// The status of the Transit Gateway. The list of enumerated values for this property may expand in the future. Code
	// and processes using this field must tolerate unexpected values.
	Status *string `json:"status" validate:"required"`

	// The date and time that this gateway was last updated.
	UpdatedAt *strfmt.DateTime `json:"updated_at,omitempty"`
}

// Constants associated with the TransitGateway.Status property.
// The status of the Transit Gateway. The list of enumerated values for this property may expand in the future. Code and
// processes using this field must tolerate unexpected values.
const (
	TransitGateway_Status_Available  = "available"
	TransitGateway_Status_Deleting   = "deleting"
	TransitGateway_Status_Failed     = "failed"
	TransitGateway_Status_Pending    = "pending"
	TransitGateway_Status_Suspended  = "suspended"
	TransitGateway_Status_Suspending = "suspending"
)

// UnmarshalTransitGateway unmarshals an instance of TransitGateway from the specified map of raw messages.
func UnmarshalTransitGateway(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TransitGateway)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.Crn)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "location", &obj.Location)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "global", &obj.Global)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TransitGatewayCollection : A list of Transit Gateways.
type TransitGatewayCollection struct {
	// A reference to the first page of resources.
	First *TransitGatewayCollectionFirst `json:"first" validate:"required"`

	// The maximum number of gateways returned on one request.
	Limit *int64 `json:"limit" validate:"required"`

	// A reference to the next page of resources; this reference is included for all pages except the last page.
	Next *TransitGatewayCollectionNext `json:"next,omitempty"`

	// Collection of Transit Services gateways.
	TransitGateways []TransitGateway `json:"transit_gateways" validate:"required"`
}

// UnmarshalTransitGatewayCollection unmarshals an instance of TransitGatewayCollection from the specified map of raw messages.
func UnmarshalTransitGatewayCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TransitGatewayCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalTransitGatewayCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalTransitGatewayCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "transit_gateways", &obj.TransitGateways, UnmarshalTransitGateway)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *TransitGatewayCollection) GetNextStart() (*string, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	return resp.Next.Start, nil
}

// TransitGatewayCollectionFirst : A reference to the first page of resources.
type TransitGatewayCollectionFirst struct {
	// url.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalTransitGatewayCollectionFirst unmarshals an instance of TransitGatewayCollectionFirst from the specified map of raw messages.
func UnmarshalTransitGatewayCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TransitGatewayCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TransitGatewayCollectionNext : A reference to the next page of resources; this reference is included for all pages except the last page.
type TransitGatewayCollectionNext struct {
	// url.
	Href *string `json:"href" validate:"required"`

	// server generated start token for next page of resources.
	Start *string `json:"start" validate:"required"`
}

// UnmarshalTransitGatewayCollectionNext unmarshals an instance of TransitGatewayCollectionNext from the specified map of raw messages.
func UnmarshalTransitGatewayCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TransitGatewayCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "start", &obj.Start)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TransitGatewayConnectionCollection : A set of Transit Gateway network connections.
type TransitGatewayConnectionCollection struct {
	// Array of transit gateways network Connections.
	Connections []TransitGatewayConnectionCust `json:"connections" validate:"required"`
}

// UnmarshalTransitGatewayConnectionCollection unmarshals an instance of TransitGatewayConnectionCollection from the specified map of raw messages.
func UnmarshalTransitGatewayConnectionCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TransitGatewayConnectionCollection)
	err = core.UnmarshalModel(m, "connections", &obj.Connections, UnmarshalTransitGatewayConnectionCust)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TransitGatewayConnectionCust : Connection included in transit gateway.
type TransitGatewayConnectionCust struct {
	// The type of network the GRE tunnel is targeting.
	BaseNetworkType *string `json:"base_network_type,omitempty"`

	// The user-defined name for this transit gateway connection.
	Name *string `json:"name" validate:"required"`

	// The ID of the network being connected via this connection. This field is required for some types, such as 'vpc',
	// 'power_virtual_server' and 'directlink'. For network types 'vpc','power_virtual_server' and 'directlink' this is the
	// CRN of the VPC / PowerVS / Direct Link gateway respectively.
	NetworkID *string `json:"network_id,omitempty"`

	// Defines what type of network is connected via this connection. The list of enumerated values for this property may
	// expand in the future. Code and processes using this field must tolerate unexpected values.
	NetworkType *string `json:"network_type" validate:"required"`

	// The unique identifier for this Transit Gateway Connection.
	ID *string `json:"id" validate:"required"`

	// network_type 'gre_tunnel' connections use 'base_connection_id' to specify the ID of a network_type 'classic'
	// connection the tunnel is configured over. The specified connection must reside in the same transit gateway and be in
	// an active state. The 'classic' connection cannot be deleted until any 'gre_tunnel' connections using it are deleted.
	// This field only applies to and is required for network type 'gre_tunnel' connections.
	BaseConnectionID *string `json:"base_connection_id,omitempty"`

	// The date and time that this connection was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// Local network BGP ASN.  This field only applies to network type 'gre_tunnel' and 'unbound_gre_tunnel' connections.
	LocalBgpAsn *int64 `json:"local_bgp_asn,omitempty"`

	// Local gateway IP address.  This field only applies to network type 'gre_tunnel' and 'unbound_gre_tunnel'
	// connections.
	LocalGatewayIp *string `json:"local_gateway_ip,omitempty"`

	// Local tunnel IP address.  This field only applies to network type 'gre_tunnel' and 'unbound_gre_tunnel' connections.
	LocalTunnelIp *string `json:"local_tunnel_ip,omitempty"`

	// GRE tunnel MTU.  This field only applies to network type 'gre_tunnel' and 'unbound_gre_tunnel' connections.
	Mtu *int64 `json:"mtu,omitempty"`

	// The ID of the account which owns the connected network. Generally only used if the network is in a different IBM
	// Cloud account than the gateway.
	NetworkAccountID *string `json:"network_account_id,omitempty"`

	// Array of prefix route filters for a transit gateway connection. This is order dependent with those first in the
	// array being applied first, and those at the end of the array is applied last, or just before the default.
	PrefixFilters []TransitGatewayConnectionPrefixFilterReference `json:"prefix_filters,omitempty"`

	// Default setting of permit or deny which applies to any routes that don't match a specified filter.
	PrefixFiltersDefault *string `json:"prefix_filters_default" validate:"required"`

	// Remote network BGP ASN.  This field only applies to network type 'gre_tunnel' and 'unbound_gre_tunnel' connections.
	RemoteBgpAsn *int64 `json:"remote_bgp_asn,omitempty"`

	// Remote gateway IP address.  This field only applies to network type 'gre_tunnel' and 'unbound_gre_tunnel'
	// connections.
	RemoteGatewayIp *string `json:"remote_gateway_ip,omitempty"`

	// Remote tunnel IP address.  This field only applies to network type 'gre_tunnel' and 'unbound_gre_tunnel'
	// connections.
	RemoteTunnelIp *string `json:"remote_tunnel_ip,omitempty"`

	// Only visible for cross account connections, this field represents the status of a connection request between IBM
	// Cloud accounts. The list of enumerated values for this property may expand in the future. Code and processes using
	// this field must tolerate unexpected values.
	RequestStatus *string `json:"request_status,omitempty"`

	// Connection's current configuration state. The list of enumerated values for this property may expand in the future.
	// Code and processes using this field must tolerate unexpected values.
	Status *string `json:"status,omitempty"`

	// The date and time that this connection was last updated.
	UpdatedAt *strfmt.DateTime `json:"updated_at,omitempty"`

	// Location of GRE tunnel.  This field only applies to network type 'gre_tunnel' and 'unbound_gre_tunnel' connections.
	Zone *TransitGatewayConnectionCustZone `json:"zone,omitempty"`
}

// Constants associated with the TransitGatewayConnectionCust.BaseNetworkType property.
// The type of network the GRE tunnel is targeting.
const (
	TransitGatewayConnectionCust_BaseNetworkType_Classic = "classic"
)

// Constants associated with the TransitGatewayConnectionCust.NetworkType property.
// Defines what type of network is connected via this connection. The list of enumerated values for this property may
// expand in the future. Code and processes using this field must tolerate unexpected values.
const (
	TransitGatewayConnectionCust_NetworkType_Classic            = "classic"
	TransitGatewayConnectionCust_NetworkType_Directlink         = "directlink"
	TransitGatewayConnectionCust_NetworkType_GreTunnel          = "gre_tunnel"
	TransitGatewayConnectionCust_NetworkType_PowerVirtualServer = "power_virtual_server"
	TransitGatewayConnectionCust_NetworkType_UnboundGreTunnel   = "unbound_gre_tunnel"
	TransitGatewayConnectionCust_NetworkType_Vpc                = "vpc"
)

// Constants associated with the TransitGatewayConnectionCust.PrefixFiltersDefault property.
// Default setting of permit or deny which applies to any routes that don't match a specified filter.
const (
	TransitGatewayConnectionCust_PrefixFiltersDefault_Deny   = "deny"
	TransitGatewayConnectionCust_PrefixFiltersDefault_Permit = "permit"
)

// Constants associated with the TransitGatewayConnectionCust.RequestStatus property.
// Only visible for cross account connections, this field represents the status of a connection request between IBM
// Cloud accounts. The list of enumerated values for this property may expand in the future. Code and processes using
// this field must tolerate unexpected values.
const (
	TransitGatewayConnectionCust_RequestStatus_Approved = "approved"
	TransitGatewayConnectionCust_RequestStatus_Detached = "detached"
	TransitGatewayConnectionCust_RequestStatus_Expired  = "expired"
	TransitGatewayConnectionCust_RequestStatus_Pending  = "pending"
	TransitGatewayConnectionCust_RequestStatus_Rejected = "rejected"
)

// Constants associated with the TransitGatewayConnectionCust.Status property.
// Connection's current configuration state. The list of enumerated values for this property may expand in the future.
// Code and processes using this field must tolerate unexpected values.
const (
	TransitGatewayConnectionCust_Status_Attached   = "attached"
	TransitGatewayConnectionCust_Status_Deleting   = "deleting"
	TransitGatewayConnectionCust_Status_Detached   = "detached"
	TransitGatewayConnectionCust_Status_Detaching  = "detaching"
	TransitGatewayConnectionCust_Status_Failed     = "failed"
	TransitGatewayConnectionCust_Status_Pending    = "pending"
	TransitGatewayConnectionCust_Status_Suspended  = "suspended"
	TransitGatewayConnectionCust_Status_Suspending = "suspending"
)

// UnmarshalTransitGatewayConnectionCust unmarshals an instance of TransitGatewayConnectionCust from the specified map of raw messages.
func UnmarshalTransitGatewayConnectionCust(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TransitGatewayConnectionCust)
	err = core.UnmarshalPrimitive(m, "base_network_type", &obj.BaseNetworkType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "network_id", &obj.NetworkID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "network_type", &obj.NetworkType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "base_connection_id", &obj.BaseConnectionID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "local_bgp_asn", &obj.LocalBgpAsn)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "local_gateway_ip", &obj.LocalGatewayIp)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "local_tunnel_ip", &obj.LocalTunnelIp)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "mtu", &obj.Mtu)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "network_account_id", &obj.NetworkAccountID)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "prefix_filters", &obj.PrefixFilters, UnmarshalTransitGatewayConnectionPrefixFilterReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "prefix_filters_default", &obj.PrefixFiltersDefault)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "remote_bgp_asn", &obj.RemoteBgpAsn)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "remote_gateway_ip", &obj.RemoteGatewayIp)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "remote_tunnel_ip", &obj.RemoteTunnelIp)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "request_status", &obj.RequestStatus)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalTransitGatewayConnectionCustZone)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TransitGatewayConnectionCustZone : Location of GRE tunnel.  This field only applies to network type 'gre_tunnel' and 'unbound_gre_tunnel' connections.
type TransitGatewayConnectionCustZone struct {
	// Availability zone name.
	Name *string `json:"name" validate:"required"`
}

// UnmarshalTransitGatewayConnectionCustZone unmarshals an instance of TransitGatewayConnectionCustZone from the specified map of raw messages.
func UnmarshalTransitGatewayConnectionCustZone(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TransitGatewayConnectionCustZone)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TransitGatewayConnectionPrefixFilter : A prefix filter for a Transit Gateway connection.
type TransitGatewayConnectionPrefixFilter struct {
	// Whether to permit or deny prefix filter.
	Action *string `json:"action" validate:"required"`

	// IP Prefix GE.
	Ge *int64 `json:"ge,omitempty"`

	// IP Prefix LE.
	Le *int64 `json:"le,omitempty"`

	// IP Prefix.
	Prefix *string `json:"prefix" validate:"required"`
}

// Constants associated with the TransitGatewayConnectionPrefixFilter.Action property.
// Whether to permit or deny prefix filter.
const (
	TransitGatewayConnectionPrefixFilter_Action_Deny   = "deny"
	TransitGatewayConnectionPrefixFilter_Action_Permit = "permit"
)

// NewTransitGatewayConnectionPrefixFilter : Instantiate TransitGatewayConnectionPrefixFilter (Generic Model Constructor)
func (*TransitGatewayApisV1) NewTransitGatewayConnectionPrefixFilter(action string, prefix string) (_model *TransitGatewayConnectionPrefixFilter, err error) {
	_model = &TransitGatewayConnectionPrefixFilter{
		Action: core.StringPtr(action),
		Prefix: core.StringPtr(prefix),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

// UnmarshalTransitGatewayConnectionPrefixFilter unmarshals an instance of TransitGatewayConnectionPrefixFilter from the specified map of raw messages.
func UnmarshalTransitGatewayConnectionPrefixFilter(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TransitGatewayConnectionPrefixFilter)
	err = core.UnmarshalPrimitive(m, "action", &obj.Action)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ge", &obj.Ge)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "le", &obj.Le)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "prefix", &obj.Prefix)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TransitGatewayConnectionPrefixFilterReference : A prefix filter reference object for a Transit Gateway connection.
type TransitGatewayConnectionPrefixFilterReference struct {
	// Whether to permit or deny prefix filter.
	Action *string `json:"action" validate:"required"`

	// Identifier of prefix filter that handles the ordering and follow semantics:
	// - When a filter reference another filter in it's before field, then the filter making the reference is applied
	// before
	//   the referenced filter. For example: if filter A references filter B in its before field, A is applied before B.
	// - When a new filter is added that has the same before as an existing filter, then the older filter will have its
	// before
	//   field updated to point to the new filter. Starting with the above example: if filter C is added and it references
	// B in its
	//   before field, then A's before field should be modified to point to C, so the order of application would be A, C
	// and finally B.
	// - A filter that has an empty before reference will be applied last (though the date order mentioned above will still
	// apply).
	//   So continuing the above examples, if filter B has an empty before field, then it will be applied last, but if
	// filter D
	//   is created with an empty before field, then B's before field will be modified to point to D, so B will be applied
	// before D.
	Before *string `json:"before,omitempty"`

	// The date and time that this prefix filter was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// IP Prefix GE.
	Ge *int64 `json:"ge,omitempty"`

	// Prefix Filter identifier.
	ID *string `json:"id" validate:"required"`

	// IP Prefix LE.
	Le *int64 `json:"le,omitempty"`

	// IP Prefix.
	Prefix *string `json:"prefix" validate:"required"`

	// The date and time that this prefix filter was last updated.
	UpdatedAt *strfmt.DateTime `json:"updated_at,omitempty"`
}

// Constants associated with the TransitGatewayConnectionPrefixFilterReference.Action property.
// Whether to permit or deny prefix filter.
const (
	TransitGatewayConnectionPrefixFilterReference_Action_Deny   = "deny"
	TransitGatewayConnectionPrefixFilterReference_Action_Permit = "permit"
)

// UnmarshalTransitGatewayConnectionPrefixFilterReference unmarshals an instance of TransitGatewayConnectionPrefixFilterReference from the specified map of raw messages.
func UnmarshalTransitGatewayConnectionPrefixFilterReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TransitGatewayConnectionPrefixFilterReference)
	err = core.UnmarshalPrimitive(m, "action", &obj.Action)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "before", &obj.Before)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ge", &obj.Ge)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "le", &obj.Le)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "prefix", &obj.Prefix)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TransitGatewayReference : Transit gateway reference.
type TransitGatewayReference struct {
	// gateway CRN.
	Crn *string `json:"crn" validate:"required"`

	// gateway ID.
	ID *string `json:"id" validate:"required"`

	// transit gateway name.
	Name *string `json:"name" validate:"required"`
}

// UnmarshalTransitGatewayReference unmarshals an instance of TransitGatewayReference from the specified map of raw messages.
func UnmarshalTransitGatewayReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TransitGatewayReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.Crn)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// UpdateTransitGatewayConnectionOptions : The UpdateTransitGatewayConnection options.
type UpdateTransitGatewayConnectionOptions struct {
	// The Transit Gateway identifier.
	TransitGatewayID *string `json:"transit_gateway_id" validate:"required,ne="`

	// The connection identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The user-defined name for this transit gateway. If specified as empty string or nil,  the name will be the network
	// name (the name of the VPC in the case of network type 'vpc',  and the word Classic, in the case of network type
	// 'classic').
	Name *string `json:"name,omitempty"`

	// Default setting of permit or deny which applies to any routes that don't match a specified filter.
	PrefixFiltersDefault *string `json:"prefix_filters_default,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the UpdateTransitGatewayConnectionOptions.PrefixFiltersDefault property.
// Default setting of permit or deny which applies to any routes that don't match a specified filter.
const (
	UpdateTransitGatewayConnectionOptions_PrefixFiltersDefault_Deny   = "deny"
	UpdateTransitGatewayConnectionOptions_PrefixFiltersDefault_Permit = "permit"
)

// NewUpdateTransitGatewayConnectionOptions : Instantiate UpdateTransitGatewayConnectionOptions
func (*TransitGatewayApisV1) NewUpdateTransitGatewayConnectionOptions(transitGatewayID string, id string) *UpdateTransitGatewayConnectionOptions {
	return &UpdateTransitGatewayConnectionOptions{
		TransitGatewayID: core.StringPtr(transitGatewayID),
		ID:               core.StringPtr(id),
	}
}

// SetTransitGatewayID : Allow user to set TransitGatewayID
func (_options *UpdateTransitGatewayConnectionOptions) SetTransitGatewayID(transitGatewayID string) *UpdateTransitGatewayConnectionOptions {
	_options.TransitGatewayID = core.StringPtr(transitGatewayID)
	return _options
}

// SetID : Allow user to set ID
func (_options *UpdateTransitGatewayConnectionOptions) SetID(id string) *UpdateTransitGatewayConnectionOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetName : Allow user to set Name
func (_options *UpdateTransitGatewayConnectionOptions) SetName(name string) *UpdateTransitGatewayConnectionOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetPrefixFiltersDefault : Allow user to set PrefixFiltersDefault
func (_options *UpdateTransitGatewayConnectionOptions) SetPrefixFiltersDefault(prefixFiltersDefault string) *UpdateTransitGatewayConnectionOptions {
	_options.PrefixFiltersDefault = core.StringPtr(prefixFiltersDefault)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateTransitGatewayConnectionOptions) SetHeaders(param map[string]string) *UpdateTransitGatewayConnectionOptions {
	options.Headers = param
	return options
}

// UpdateTransitGatewayConnectionPrefixFilterOptions : The UpdateTransitGatewayConnectionPrefixFilter options.
type UpdateTransitGatewayConnectionPrefixFilterOptions struct {
	// The Transit Gateway identifier.
	TransitGatewayID *string `json:"transit_gateway_id" validate:"required,ne="`

	// The connection identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Prefix filter identifier.
	FilterID *string `json:"filter_id" validate:"required,ne="`

	// Whether to permit or deny prefix filter.
	Action *string `json:"action,omitempty"`

	// Identifier of prefix filter to handle the ordering and follow semantics:
	// - When a filter reference another filter in it's before field, then the filter making the reference is applied
	// before
	//   the referenced filter. For example: if filter A references filter B in its before field, A is applied before B.
	// - When a new filter is added that has the same before as an existing filter, then the older filter will have its
	// before
	//   field updated to point to the new filter. Starting with the above example: if filter C is added and it references
	// B in its
	//   before field, then A's before field should be modified to point to C, so the order of application would be A, C
	// and finally B.
	// - A filter that has an empty before reference will be applied last (though the date order mentioned above will still
	// apply).
	//   So continuing the above examples, if filter B has an empty before field, then it will be applied last, but if
	// filter D
	//   is created with an empty before field, then B's before field will be modified to point to D, so B will be applied
	// before D.
	Before *string `json:"before,omitempty"`

	// IP Prefix GE.
	Ge *int64 `json:"ge,omitempty"`

	// IP Prefix LE.
	Le *int64 `json:"le,omitempty"`

	// IP Prefix.
	Prefix *string `json:"prefix,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the UpdateTransitGatewayConnectionPrefixFilterOptions.Action property.
// Whether to permit or deny prefix filter.
const (
	UpdateTransitGatewayConnectionPrefixFilterOptions_Action_Deny   = "deny"
	UpdateTransitGatewayConnectionPrefixFilterOptions_Action_Permit = "permit"
)

// NewUpdateTransitGatewayConnectionPrefixFilterOptions : Instantiate UpdateTransitGatewayConnectionPrefixFilterOptions
func (*TransitGatewayApisV1) NewUpdateTransitGatewayConnectionPrefixFilterOptions(transitGatewayID string, id string, filterID string) *UpdateTransitGatewayConnectionPrefixFilterOptions {
	return &UpdateTransitGatewayConnectionPrefixFilterOptions{
		TransitGatewayID: core.StringPtr(transitGatewayID),
		ID:               core.StringPtr(id),
		FilterID:         core.StringPtr(filterID),
	}
}

// SetTransitGatewayID : Allow user to set TransitGatewayID
func (_options *UpdateTransitGatewayConnectionPrefixFilterOptions) SetTransitGatewayID(transitGatewayID string) *UpdateTransitGatewayConnectionPrefixFilterOptions {
	_options.TransitGatewayID = core.StringPtr(transitGatewayID)
	return _options
}

// SetID : Allow user to set ID
func (_options *UpdateTransitGatewayConnectionPrefixFilterOptions) SetID(id string) *UpdateTransitGatewayConnectionPrefixFilterOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetFilterID : Allow user to set FilterID
func (_options *UpdateTransitGatewayConnectionPrefixFilterOptions) SetFilterID(filterID string) *UpdateTransitGatewayConnectionPrefixFilterOptions {
	_options.FilterID = core.StringPtr(filterID)
	return _options
}

// SetAction : Allow user to set Action
func (_options *UpdateTransitGatewayConnectionPrefixFilterOptions) SetAction(action string) *UpdateTransitGatewayConnectionPrefixFilterOptions {
	_options.Action = core.StringPtr(action)
	return _options
}

// SetBefore : Allow user to set Before
func (_options *UpdateTransitGatewayConnectionPrefixFilterOptions) SetBefore(before string) *UpdateTransitGatewayConnectionPrefixFilterOptions {
	_options.Before = core.StringPtr(before)
	return _options
}

// SetGe : Allow user to set Ge
func (_options *UpdateTransitGatewayConnectionPrefixFilterOptions) SetGe(ge int64) *UpdateTransitGatewayConnectionPrefixFilterOptions {
	_options.Ge = core.Int64Ptr(ge)
	return _options
}

// SetLe : Allow user to set Le
func (_options *UpdateTransitGatewayConnectionPrefixFilterOptions) SetLe(le int64) *UpdateTransitGatewayConnectionPrefixFilterOptions {
	_options.Le = core.Int64Ptr(le)
	return _options
}

// SetPrefix : Allow user to set Prefix
func (_options *UpdateTransitGatewayConnectionPrefixFilterOptions) SetPrefix(prefix string) *UpdateTransitGatewayConnectionPrefixFilterOptions {
	_options.Prefix = core.StringPtr(prefix)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateTransitGatewayConnectionPrefixFilterOptions) SetHeaders(param map[string]string) *UpdateTransitGatewayConnectionPrefixFilterOptions {
	options.Headers = param
	return options
}

// UpdateTransitGatewayOptions : The UpdateTransitGateway options.
type UpdateTransitGatewayOptions struct {
	// The Transit Gateway identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allow global routing for a Transit Gateway.
	Global *bool `json:"global,omitempty"`

	// The user-defined name for this transit gateway.
	Name *string `json:"name,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateTransitGatewayOptions : Instantiate UpdateTransitGatewayOptions
func (*TransitGatewayApisV1) NewUpdateTransitGatewayOptions(id string) *UpdateTransitGatewayOptions {
	return &UpdateTransitGatewayOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *UpdateTransitGatewayOptions) SetID(id string) *UpdateTransitGatewayOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetGlobal : Allow user to set Global
func (_options *UpdateTransitGatewayOptions) SetGlobal(global bool) *UpdateTransitGatewayOptions {
	_options.Global = core.BoolPtr(global)
	return _options
}

// SetName : Allow user to set Name
func (_options *UpdateTransitGatewayOptions) SetName(name string) *UpdateTransitGatewayOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateTransitGatewayOptions) SetHeaders(param map[string]string) *UpdateTransitGatewayOptions {
	options.Headers = param
	return options
}

// ZoneIdentity : ZoneIdentity struct
// Models which "extend" this model:
// - ZoneIdentityByName
type ZoneIdentity struct {
	// Availability zone name.
	Name *string `json:"name,omitempty"`
}

func (*ZoneIdentity) isaZoneIdentity() bool {
	return true
}

type ZoneIdentityIntf interface {
	isaZoneIdentity() bool
}

// UnmarshalZoneIdentity unmarshals an instance of ZoneIdentity from the specified map of raw messages.
func UnmarshalZoneIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ZoneIdentity)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ZoneReference : Availability zone reference.
type ZoneReference struct {
	// Availability zone name.
	Name *string `json:"name" validate:"required"`
}

// UnmarshalZoneReference unmarshals an instance of ZoneReference from the specified map of raw messages.
func UnmarshalZoneReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ZoneReference)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ZoneIdentityByName : Availability zone.
// This model "extends" ZoneIdentity
type ZoneIdentityByName struct {
	// Availability zone name.
	Name *string `json:"name,omitempty"`
}

func (*ZoneIdentityByName) isaZoneIdentity() bool {
	return true
}

// UnmarshalZoneIdentityByName unmarshals an instance of ZoneIdentityByName from the specified map of raw messages.
func UnmarshalZoneIdentityByName(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ZoneIdentityByName)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}
