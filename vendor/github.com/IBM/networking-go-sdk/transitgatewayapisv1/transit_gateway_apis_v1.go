/**
 * (C) Copyright IBM Corp. 2025.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * IBM OpenAPI SDK Code Generator Version: 3.73.0-eeee85a9-20230607-165104
 */

// Package transitgatewayapisv1 : Operations and models for the TransitGatewayApisV1 service
package transitgatewayapisv1

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"reflect"
	"time"

	"github.com/IBM/go-sdk-core/v5/core"
	common "github.com/IBM/networking-go-sdk/common"
	"github.com/go-openapi/strfmt"
)

// TransitGatewayApisV1 : No description provided (generated by Openapi Generator
// https://github.com/openapitools/openapi-generator)
//
// API Version: __VERSION__
type TransitGatewayApisV1 struct {
	Service *core.BaseService

	// Requests the version of the API as of a date in the format `YYYY-MM-DD`. Any date up to the current date may be
	// provided. Specify the current date to request the latest version.
	Version *string
}

// DefaultServiceURL is the default URL to make service requests to.
const DefaultServiceURL = "https://transit.cloud.ibm.com/v1"

// DefaultServiceName is the default key used to find external configuration information.
const DefaultServiceName = "transit_gateway_apis"

// TransitGatewayApisV1Options : Service options
type TransitGatewayApisV1Options struct {
	ServiceName   string
	URL           string
	Authenticator core.Authenticator

	// Requests the version of the API as of a date in the format `YYYY-MM-DD`. Any date up to the current date may be
	// provided. Specify the current date to request the latest version.
	Version *string `validate:"required"`
}

// NewTransitGatewayApisV1UsingExternalConfig : constructs an instance of TransitGatewayApisV1 with passed in options and external configuration.
func NewTransitGatewayApisV1UsingExternalConfig(options *TransitGatewayApisV1Options) (transitGatewayApis *TransitGatewayApisV1, err error) {
	if options.ServiceName == "" {
		options.ServiceName = DefaultServiceName
	}

	if options.Authenticator == nil {
		options.Authenticator, err = core.GetAuthenticatorFromEnvironment(options.ServiceName)
		if err != nil {
			return
		}
	}

	transitGatewayApis, err = NewTransitGatewayApisV1(options)
	if err != nil {
		return
	}

	err = transitGatewayApis.Service.ConfigureService(options.ServiceName)
	if err != nil {
		return
	}

	if options.URL != "" {
		err = transitGatewayApis.Service.SetServiceURL(options.URL)
	}
	return
}

// NewTransitGatewayApisV1 : constructs an instance of TransitGatewayApisV1 with passed in options.
func NewTransitGatewayApisV1(options *TransitGatewayApisV1Options) (service *TransitGatewayApisV1, err error) {
	serviceOptions := &core.ServiceOptions{
		URL:           DefaultServiceURL,
		Authenticator: options.Authenticator,
	}

	err = core.ValidateStruct(options, "options")
	if err != nil {
		return
	}

	baseService, err := core.NewBaseService(serviceOptions)
	if err != nil {
		return
	}

	if options.URL != "" {
		err = baseService.SetServiceURL(options.URL)
		if err != nil {
			return
		}
	}

	service = &TransitGatewayApisV1{
		Service: baseService,
		Version: options.Version,
	}

	return
}

// GetServiceURLForRegion returns the service URL to be used for the specified region
func GetServiceURLForRegion(region string) (string, error) {
	return "", fmt.Errorf("service does not support regional URLs")
}

// Clone makes a copy of "transitGatewayApis" suitable for processing requests.
func (transitGatewayApis *TransitGatewayApisV1) Clone() *TransitGatewayApisV1 {
	if core.IsNil(transitGatewayApis) {
		return nil
	}
	clone := *transitGatewayApis
	clone.Service = transitGatewayApis.Service.Clone()
	return &clone
}

// SetServiceURL sets the service URL
func (transitGatewayApis *TransitGatewayApisV1) SetServiceURL(url string) error {
	return transitGatewayApis.Service.SetServiceURL(url)
}

// GetServiceURL returns the service URL
func (transitGatewayApis *TransitGatewayApisV1) GetServiceURL() string {
	return transitGatewayApis.Service.GetServiceURL()
}

// SetDefaultHeaders sets HTTP headers to be sent in every request
func (transitGatewayApis *TransitGatewayApisV1) SetDefaultHeaders(headers http.Header) {
	transitGatewayApis.Service.SetDefaultHeaders(headers)
}

// SetEnableGzipCompression sets the service's EnableGzipCompression field
func (transitGatewayApis *TransitGatewayApisV1) SetEnableGzipCompression(enableGzip bool) {
	transitGatewayApis.Service.SetEnableGzipCompression(enableGzip)
}

// GetEnableGzipCompression returns the service's EnableGzipCompression field
func (transitGatewayApis *TransitGatewayApisV1) GetEnableGzipCompression() bool {
	return transitGatewayApis.Service.GetEnableGzipCompression()
}

// EnableRetries enables automatic retries for requests invoked for this service instance.
// If either parameter is specified as 0, then a default value is used instead.
func (transitGatewayApis *TransitGatewayApisV1) EnableRetries(maxRetries int, maxRetryInterval time.Duration) {
	transitGatewayApis.Service.EnableRetries(maxRetries, maxRetryInterval)
}

// DisableRetries disables automatic retries for requests invoked for this service instance.
func (transitGatewayApis *TransitGatewayApisV1) DisableRetries() {
	transitGatewayApis.Service.DisableRetries()
}

// ListTransitGateways : Retrieves all Transit Gateways
// List all Transit Gateways in account the caller is authorized to view.
func (transitGatewayApis *TransitGatewayApisV1) ListTransitGateways(listTransitGatewaysOptions *ListTransitGatewaysOptions) (result *TransitGatewayCollection, response *core.DetailedResponse, err error) {
	return transitGatewayApis.ListTransitGatewaysWithContext(context.Background(), listTransitGatewaysOptions)
}

// ListTransitGatewaysWithContext is an alternate form of the ListTransitGateways method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) ListTransitGatewaysWithContext(ctx context.Context, listTransitGatewaysOptions *ListTransitGatewaysOptions) (result *TransitGatewayCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listTransitGatewaysOptions, "listTransitGatewaysOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/transit_gateways`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range listTransitGatewaysOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "ListTransitGateways")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))
	if listTransitGatewaysOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listTransitGatewaysOptions.Limit))
	}
	if listTransitGatewaysOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listTransitGatewaysOptions.Start))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTransitGatewayCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateTransitGateway : Creates a Transit Gateway
// Create a Transit Gateway based on the supplied input template.
func (transitGatewayApis *TransitGatewayApisV1) CreateTransitGateway(createTransitGatewayOptions *CreateTransitGatewayOptions) (result *TransitGateway, response *core.DetailedResponse, err error) {
	return transitGatewayApis.CreateTransitGatewayWithContext(context.Background(), createTransitGatewayOptions)
}

// CreateTransitGatewayWithContext is an alternate form of the CreateTransitGateway method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) CreateTransitGatewayWithContext(ctx context.Context, createTransitGatewayOptions *CreateTransitGatewayOptions) (result *TransitGateway, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createTransitGatewayOptions, "createTransitGatewayOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createTransitGatewayOptions, "createTransitGatewayOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/transit_gateways`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range createTransitGatewayOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "CreateTransitGateway")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	body := make(map[string]interface{})
	if createTransitGatewayOptions.Location != nil {
		body["location"] = createTransitGatewayOptions.Location
	}
	if createTransitGatewayOptions.Name != nil {
		body["name"] = createTransitGatewayOptions.Name
	}
	if createTransitGatewayOptions.Global != nil {
		body["global"] = createTransitGatewayOptions.Global
	}
	if createTransitGatewayOptions.GreEnhancedRoutePropagation != nil {
		body["gre_enhanced_route_propagation"] = createTransitGatewayOptions.GreEnhancedRoutePropagation
	}
	if createTransitGatewayOptions.ResourceGroup != nil {
		body["resource_group"] = createTransitGatewayOptions.ResourceGroup
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTransitGateway)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteTransitGateway : Deletes specified Transit Gateway
// This request deletes a Transit Gateway. This operation cannot be reversed. For this request to succeed, the Transit
// Gateway must not contain connections.
func (transitGatewayApis *TransitGatewayApisV1) DeleteTransitGateway(deleteTransitGatewayOptions *DeleteTransitGatewayOptions) (response *core.DetailedResponse, err error) {
	return transitGatewayApis.DeleteTransitGatewayWithContext(context.Background(), deleteTransitGatewayOptions)
}

// DeleteTransitGatewayWithContext is an alternate form of the DeleteTransitGateway method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) DeleteTransitGatewayWithContext(ctx context.Context, deleteTransitGatewayOptions *DeleteTransitGatewayOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteTransitGatewayOptions, "deleteTransitGatewayOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteTransitGatewayOptions, "deleteTransitGatewayOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *deleteTransitGatewayOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/transit_gateways/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteTransitGatewayOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "DeleteTransitGateway")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = transitGatewayApis.Service.Request(request, nil)

	return
}

// GetTransitGateway : Retrieves specified Transit Gateway
// This request retrieves a single Transit Gateway specified by the identifier in the URL.
func (transitGatewayApis *TransitGatewayApisV1) GetTransitGateway(getTransitGatewayOptions *GetTransitGatewayOptions) (result *TransitGateway, response *core.DetailedResponse, err error) {
	return transitGatewayApis.GetTransitGatewayWithContext(context.Background(), getTransitGatewayOptions)
}

// GetTransitGatewayWithContext is an alternate form of the GetTransitGateway method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) GetTransitGatewayWithContext(ctx context.Context, getTransitGatewayOptions *GetTransitGatewayOptions) (result *TransitGateway, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getTransitGatewayOptions, "getTransitGatewayOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getTransitGatewayOptions, "getTransitGatewayOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *getTransitGatewayOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/transit_gateways/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getTransitGatewayOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "GetTransitGateway")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTransitGateway)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// UpdateTransitGateway : Updates specified Transit Gateway
// This request updates a Transit Gateway's name and/or global flag.
func (transitGatewayApis *TransitGatewayApisV1) UpdateTransitGateway(updateTransitGatewayOptions *UpdateTransitGatewayOptions) (result *TransitGateway, response *core.DetailedResponse, err error) {
	return transitGatewayApis.UpdateTransitGatewayWithContext(context.Background(), updateTransitGatewayOptions)
}

// UpdateTransitGatewayWithContext is an alternate form of the UpdateTransitGateway method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) UpdateTransitGatewayWithContext(ctx context.Context, updateTransitGatewayOptions *UpdateTransitGatewayOptions) (result *TransitGateway, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateTransitGatewayOptions, "updateTransitGatewayOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateTransitGatewayOptions, "updateTransitGatewayOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *updateTransitGatewayOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/transit_gateways/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateTransitGatewayOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "UpdateTransitGateway")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	body := make(map[string]interface{})
	if updateTransitGatewayOptions.Global != nil {
		body["global"] = updateTransitGatewayOptions.Global
	}
	if updateTransitGatewayOptions.GreEnhancedRoutePropagation != nil {
		body["gre_enhanced_route_propagation"] = updateTransitGatewayOptions.GreEnhancedRoutePropagation
	}
	if updateTransitGatewayOptions.Name != nil {
		body["name"] = updateTransitGatewayOptions.Name
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTransitGateway)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListConnections : Retrieves all connections
// List all transit gateway connections associated with this account.
func (transitGatewayApis *TransitGatewayApisV1) ListConnections(listConnectionsOptions *ListConnectionsOptions) (result *TransitConnectionCollection, response *core.DetailedResponse, err error) {
	return transitGatewayApis.ListConnectionsWithContext(context.Background(), listConnectionsOptions)
}

// ListConnectionsWithContext is an alternate form of the ListConnections method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) ListConnectionsWithContext(ctx context.Context, listConnectionsOptions *ListConnectionsOptions) (result *TransitConnectionCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listConnectionsOptions, "listConnectionsOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/connections`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range listConnectionsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "ListConnections")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))
	if listConnectionsOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listConnectionsOptions.Limit))
	}
	if listConnectionsOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listConnectionsOptions.Start))
	}
	if listConnectionsOptions.NetworkID != nil {
		builder.AddQuery("network_id", fmt.Sprint(*listConnectionsOptions.NetworkID))
	}
	if listConnectionsOptions.NetworkType != nil {
		builder.AddQuery("network_type", fmt.Sprint(*listConnectionsOptions.NetworkType))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTransitConnectionCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListTransitGatewayConnections : Retrieves all connections in a Transit Gateway
// This request retrieves all connections in a Transit Gateway.
func (transitGatewayApis *TransitGatewayApisV1) ListTransitGatewayConnections(listTransitGatewayConnectionsOptions *ListTransitGatewayConnectionsOptions) (result *TransitGatewayConnectionCollection, response *core.DetailedResponse, err error) {
	return transitGatewayApis.ListTransitGatewayConnectionsWithContext(context.Background(), listTransitGatewayConnectionsOptions)
}

// ListTransitGatewayConnectionsWithContext is an alternate form of the ListTransitGatewayConnections method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) ListTransitGatewayConnectionsWithContext(ctx context.Context, listTransitGatewayConnectionsOptions *ListTransitGatewayConnectionsOptions) (result *TransitGatewayConnectionCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listTransitGatewayConnectionsOptions, "listTransitGatewayConnectionsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listTransitGatewayConnectionsOptions, "listTransitGatewayConnectionsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"transit_gateway_id": *listTransitGatewayConnectionsOptions.TransitGatewayID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/transit_gateways/{transit_gateway_id}/connections`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listTransitGatewayConnectionsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "ListTransitGatewayConnections")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))
	if listTransitGatewayConnectionsOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listTransitGatewayConnectionsOptions.Start))
	}
	if listTransitGatewayConnectionsOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listTransitGatewayConnectionsOptions.Limit))
	}
	if listTransitGatewayConnectionsOptions.Name != nil {
		builder.AddQuery("name", fmt.Sprint(*listTransitGatewayConnectionsOptions.Name))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTransitGatewayConnectionCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateTransitGatewayConnection : Adds a connection to a Transit Gateway
// Add a connection to Transit Gateway.
func (transitGatewayApis *TransitGatewayApisV1) CreateTransitGatewayConnection(createTransitGatewayConnectionOptions *CreateTransitGatewayConnectionOptions) (result *TransitGatewayConnectionCust, response *core.DetailedResponse, err error) {
	return transitGatewayApis.CreateTransitGatewayConnectionWithContext(context.Background(), createTransitGatewayConnectionOptions)
}

// CreateTransitGatewayConnectionWithContext is an alternate form of the CreateTransitGatewayConnection method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) CreateTransitGatewayConnectionWithContext(ctx context.Context, createTransitGatewayConnectionOptions *CreateTransitGatewayConnectionOptions) (result *TransitGatewayConnectionCust, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createTransitGatewayConnectionOptions, "createTransitGatewayConnectionOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createTransitGatewayConnectionOptions, "createTransitGatewayConnectionOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"transit_gateway_id": *createTransitGatewayConnectionOptions.TransitGatewayID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/transit_gateways/{transit_gateway_id}/connections`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range createTransitGatewayConnectionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "CreateTransitGatewayConnection")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	body := make(map[string]interface{})
	if createTransitGatewayConnectionOptions.NetworkType != nil {
		body["network_type"] = createTransitGatewayConnectionOptions.NetworkType
	}
	if createTransitGatewayConnectionOptions.BaseConnectionID != nil {
		body["base_connection_id"] = createTransitGatewayConnectionOptions.BaseConnectionID
	}
	if createTransitGatewayConnectionOptions.BaseNetworkType != nil {
		body["base_network_type"] = createTransitGatewayConnectionOptions.BaseNetworkType
	}
	if createTransitGatewayConnectionOptions.Cidr != nil {
		body["cidr"] = createTransitGatewayConnectionOptions.Cidr
	}
	if createTransitGatewayConnectionOptions.LocalGatewayIp != nil {
		body["local_gateway_ip"] = createTransitGatewayConnectionOptions.LocalGatewayIp
	}
	if createTransitGatewayConnectionOptions.LocalTunnelIp != nil {
		body["local_tunnel_ip"] = createTransitGatewayConnectionOptions.LocalTunnelIp
	}
	if createTransitGatewayConnectionOptions.Name != nil {
		body["name"] = createTransitGatewayConnectionOptions.Name
	}
	if createTransitGatewayConnectionOptions.NetworkAccountID != nil {
		body["network_account_id"] = createTransitGatewayConnectionOptions.NetworkAccountID
	}
	if createTransitGatewayConnectionOptions.NetworkID != nil {
		body["network_id"] = createTransitGatewayConnectionOptions.NetworkID
	}
	if createTransitGatewayConnectionOptions.PrefixFilters != nil {
		body["prefix_filters"] = createTransitGatewayConnectionOptions.PrefixFilters
	}
	if createTransitGatewayConnectionOptions.PrefixFiltersDefault != nil {
		body["prefix_filters_default"] = createTransitGatewayConnectionOptions.PrefixFiltersDefault
	}
	if createTransitGatewayConnectionOptions.RemoteBgpAsn != nil {
		body["remote_bgp_asn"] = createTransitGatewayConnectionOptions.RemoteBgpAsn
	}
	if createTransitGatewayConnectionOptions.RemoteGatewayIp != nil {
		body["remote_gateway_ip"] = createTransitGatewayConnectionOptions.RemoteGatewayIp
	}
	if createTransitGatewayConnectionOptions.RemoteTunnelIp != nil {
		body["remote_tunnel_ip"] = createTransitGatewayConnectionOptions.RemoteTunnelIp
	}
	if createTransitGatewayConnectionOptions.Tunnels != nil {
		body["tunnels"] = createTransitGatewayConnectionOptions.Tunnels
	}
	if createTransitGatewayConnectionOptions.Zone != nil {
		body["zone"] = createTransitGatewayConnectionOptions.Zone
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTransitGatewayConnectionCust)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteTransitGatewayConnection : Removes a connection from Transit Gateway
// After the specified connection is detached, entities still within the Transit Gateway will no longer be able to
// communicate directly to it through the IBM Cloud private backbone.
func (transitGatewayApis *TransitGatewayApisV1) DeleteTransitGatewayConnection(deleteTransitGatewayConnectionOptions *DeleteTransitGatewayConnectionOptions) (response *core.DetailedResponse, err error) {
	return transitGatewayApis.DeleteTransitGatewayConnectionWithContext(context.Background(), deleteTransitGatewayConnectionOptions)
}

// DeleteTransitGatewayConnectionWithContext is an alternate form of the DeleteTransitGatewayConnection method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) DeleteTransitGatewayConnectionWithContext(ctx context.Context, deleteTransitGatewayConnectionOptions *DeleteTransitGatewayConnectionOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteTransitGatewayConnectionOptions, "deleteTransitGatewayConnectionOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteTransitGatewayConnectionOptions, "deleteTransitGatewayConnectionOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"transit_gateway_id": *deleteTransitGatewayConnectionOptions.TransitGatewayID,
		"id":                 *deleteTransitGatewayConnectionOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/transit_gateways/{transit_gateway_id}/connections/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteTransitGatewayConnectionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "DeleteTransitGatewayConnection")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = transitGatewayApis.Service.Request(request, nil)

	return
}

// GetTransitGatewayConnection : Retrieves specified Transit Gateway connection
// This request retrieves a connection from the Transit Gateway.
func (transitGatewayApis *TransitGatewayApisV1) GetTransitGatewayConnection(getTransitGatewayConnectionOptions *GetTransitGatewayConnectionOptions) (result *TransitGatewayConnectionCust, response *core.DetailedResponse, err error) {
	return transitGatewayApis.GetTransitGatewayConnectionWithContext(context.Background(), getTransitGatewayConnectionOptions)
}

// GetTransitGatewayConnectionWithContext is an alternate form of the GetTransitGatewayConnection method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) GetTransitGatewayConnectionWithContext(ctx context.Context, getTransitGatewayConnectionOptions *GetTransitGatewayConnectionOptions) (result *TransitGatewayConnectionCust, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getTransitGatewayConnectionOptions, "getTransitGatewayConnectionOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getTransitGatewayConnectionOptions, "getTransitGatewayConnectionOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"transit_gateway_id": *getTransitGatewayConnectionOptions.TransitGatewayID,
		"id":                 *getTransitGatewayConnectionOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/transit_gateways/{transit_gateway_id}/connections/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getTransitGatewayConnectionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "GetTransitGatewayConnection")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTransitGatewayConnectionCust)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// UpdateTransitGatewayConnection : Updates specified Transit Gateway connection
// Update the name of a connection to a Transit Gateway.
func (transitGatewayApis *TransitGatewayApisV1) UpdateTransitGatewayConnection(updateTransitGatewayConnectionOptions *UpdateTransitGatewayConnectionOptions) (result *TransitGatewayConnectionCust, response *core.DetailedResponse, err error) {
	return transitGatewayApis.UpdateTransitGatewayConnectionWithContext(context.Background(), updateTransitGatewayConnectionOptions)
}

// UpdateTransitGatewayConnectionWithContext is an alternate form of the UpdateTransitGatewayConnection method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) UpdateTransitGatewayConnectionWithContext(ctx context.Context, updateTransitGatewayConnectionOptions *UpdateTransitGatewayConnectionOptions) (result *TransitGatewayConnectionCust, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateTransitGatewayConnectionOptions, "updateTransitGatewayConnectionOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateTransitGatewayConnectionOptions, "updateTransitGatewayConnectionOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"transit_gateway_id": *updateTransitGatewayConnectionOptions.TransitGatewayID,
		"id":                 *updateTransitGatewayConnectionOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/transit_gateways/{transit_gateway_id}/connections/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateTransitGatewayConnectionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "UpdateTransitGatewayConnection")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	body := make(map[string]interface{})
	if updateTransitGatewayConnectionOptions.Name != nil {
		body["name"] = updateTransitGatewayConnectionOptions.Name
	}
	if updateTransitGatewayConnectionOptions.PrefixFiltersDefault != nil {
		body["prefix_filters_default"] = updateTransitGatewayConnectionOptions.PrefixFiltersDefault
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTransitGatewayConnectionCust)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateTransitGatewayConnectionActions : Performs actions on a connection for a Transit Gateway
// Allow a network owner to approve or reject a cross-account connection request.
func (transitGatewayApis *TransitGatewayApisV1) CreateTransitGatewayConnectionActions(createTransitGatewayConnectionActionsOptions *CreateTransitGatewayConnectionActionsOptions) (response *core.DetailedResponse, err error) {
	return transitGatewayApis.CreateTransitGatewayConnectionActionsWithContext(context.Background(), createTransitGatewayConnectionActionsOptions)
}

// CreateTransitGatewayConnectionActionsWithContext is an alternate form of the CreateTransitGatewayConnectionActions method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) CreateTransitGatewayConnectionActionsWithContext(ctx context.Context, createTransitGatewayConnectionActionsOptions *CreateTransitGatewayConnectionActionsOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createTransitGatewayConnectionActionsOptions, "createTransitGatewayConnectionActionsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createTransitGatewayConnectionActionsOptions, "createTransitGatewayConnectionActionsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"transit_gateway_id": *createTransitGatewayConnectionActionsOptions.TransitGatewayID,
		"id":                 *createTransitGatewayConnectionActionsOptions.ID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/transit_gateways/{transit_gateway_id}/connections/{id}/actions`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range createTransitGatewayConnectionActionsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "CreateTransitGatewayConnectionActions")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	body := make(map[string]interface{})
	if createTransitGatewayConnectionActionsOptions.Action != nil {
		body["action"] = createTransitGatewayConnectionActionsOptions.Action
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = transitGatewayApis.Service.Request(request, nil)

	return
}

// ListTransitGatewayGreTunnel : Retrieves specified Transit Gateway redundant gre connection tunnels
// This request retrieves a list of all the tunnels for connection.
func (transitGatewayApis *TransitGatewayApisV1) ListTransitGatewayGreTunnel(listTransitGatewayGreTunnelOptions *ListTransitGatewayGreTunnelOptions) (result *TransitGatewayTunnelCollection, response *core.DetailedResponse, err error) {
	return transitGatewayApis.ListTransitGatewayGreTunnelWithContext(context.Background(), listTransitGatewayGreTunnelOptions)
}

// ListTransitGatewayGreTunnelWithContext is an alternate form of the ListTransitGatewayGreTunnel method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) ListTransitGatewayGreTunnelWithContext(ctx context.Context, listTransitGatewayGreTunnelOptions *ListTransitGatewayGreTunnelOptions) (result *TransitGatewayTunnelCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listTransitGatewayGreTunnelOptions, "listTransitGatewayGreTunnelOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listTransitGatewayGreTunnelOptions, "listTransitGatewayGreTunnelOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"transit_gateway_id": *listTransitGatewayGreTunnelOptions.TransitGatewayID,
		"id":                 *listTransitGatewayGreTunnelOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/transit_gateways/{transit_gateway_id}/connections/{id}/tunnels`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listTransitGatewayGreTunnelOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "ListTransitGatewayGreTunnel")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTransitGatewayTunnelCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateTransitGatewayGreTunnel : Creates a Transit Gateway redundant GRE tunnel
// Add a tunnel to an existing Redundant GRE connection.
func (transitGatewayApis *TransitGatewayApisV1) CreateTransitGatewayGreTunnel(createTransitGatewayGreTunnelOptions *CreateTransitGatewayGreTunnelOptions) (result *TransitGatewayTunnel, response *core.DetailedResponse, err error) {
	return transitGatewayApis.CreateTransitGatewayGreTunnelWithContext(context.Background(), createTransitGatewayGreTunnelOptions)
}

// CreateTransitGatewayGreTunnelWithContext is an alternate form of the CreateTransitGatewayGreTunnel method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) CreateTransitGatewayGreTunnelWithContext(ctx context.Context, createTransitGatewayGreTunnelOptions *CreateTransitGatewayGreTunnelOptions) (result *TransitGatewayTunnel, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createTransitGatewayGreTunnelOptions, "createTransitGatewayGreTunnelOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createTransitGatewayGreTunnelOptions, "createTransitGatewayGreTunnelOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"transit_gateway_id": *createTransitGatewayGreTunnelOptions.TransitGatewayID,
		"id":                 *createTransitGatewayGreTunnelOptions.ID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/transit_gateways/{transit_gateway_id}/connections/{id}/tunnels`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range createTransitGatewayGreTunnelOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "CreateTransitGatewayGreTunnel")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	body := make(map[string]interface{})
	if createTransitGatewayGreTunnelOptions.LocalGatewayIp != nil {
		body["local_gateway_ip"] = createTransitGatewayGreTunnelOptions.LocalGatewayIp
	}
	if createTransitGatewayGreTunnelOptions.LocalTunnelIp != nil {
		body["local_tunnel_ip"] = createTransitGatewayGreTunnelOptions.LocalTunnelIp
	}
	if createTransitGatewayGreTunnelOptions.Name != nil {
		body["name"] = createTransitGatewayGreTunnelOptions.Name
	}
	if createTransitGatewayGreTunnelOptions.RemoteGatewayIp != nil {
		body["remote_gateway_ip"] = createTransitGatewayGreTunnelOptions.RemoteGatewayIp
	}
	if createTransitGatewayGreTunnelOptions.RemoteTunnelIp != nil {
		body["remote_tunnel_ip"] = createTransitGatewayGreTunnelOptions.RemoteTunnelIp
	}
	if createTransitGatewayGreTunnelOptions.Zone != nil {
		body["zone"] = createTransitGatewayGreTunnelOptions.Zone
	}
	if createTransitGatewayGreTunnelOptions.RemoteBgpAsn != nil {
		body["remote_bgp_asn"] = createTransitGatewayGreTunnelOptions.RemoteBgpAsn
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTransitGatewayTunnel)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteTransitGatewayConnectionTunnels : Deletes a specified Transit Gateway redundant GRE tunnel
// Remove a tunnel from a redundant GRE connection.
func (transitGatewayApis *TransitGatewayApisV1) DeleteTransitGatewayConnectionTunnels(deleteTransitGatewayConnectionTunnelsOptions *DeleteTransitGatewayConnectionTunnelsOptions) (response *core.DetailedResponse, err error) {
	return transitGatewayApis.DeleteTransitGatewayConnectionTunnelsWithContext(context.Background(), deleteTransitGatewayConnectionTunnelsOptions)
}

// DeleteTransitGatewayConnectionTunnelsWithContext is an alternate form of the DeleteTransitGatewayConnectionTunnels method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) DeleteTransitGatewayConnectionTunnelsWithContext(ctx context.Context, deleteTransitGatewayConnectionTunnelsOptions *DeleteTransitGatewayConnectionTunnelsOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteTransitGatewayConnectionTunnelsOptions, "deleteTransitGatewayConnectionTunnelsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteTransitGatewayConnectionTunnelsOptions, "deleteTransitGatewayConnectionTunnelsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"transit_gateway_id": *deleteTransitGatewayConnectionTunnelsOptions.TransitGatewayID,
		"id":                 *deleteTransitGatewayConnectionTunnelsOptions.ID,
		"gre_tunnel_id":      *deleteTransitGatewayConnectionTunnelsOptions.GreTunnelID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/transit_gateways/{transit_gateway_id}/connections/{id}/tunnels/{gre_tunnel_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteTransitGatewayConnectionTunnelsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "DeleteTransitGatewayConnectionTunnels")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = transitGatewayApis.Service.Request(request, nil)

	return
}

// GetTransitGatewayConnectionTunnels : Retrieves specified Transit Gateway connection tunnel
// This request retrieves a connection tunnel from the Transit Gateway connection.
func (transitGatewayApis *TransitGatewayApisV1) GetTransitGatewayConnectionTunnels(getTransitGatewayConnectionTunnelsOptions *GetTransitGatewayConnectionTunnelsOptions) (result *TransitGatewayTunnel, response *core.DetailedResponse, err error) {
	return transitGatewayApis.GetTransitGatewayConnectionTunnelsWithContext(context.Background(), getTransitGatewayConnectionTunnelsOptions)
}

// GetTransitGatewayConnectionTunnelsWithContext is an alternate form of the GetTransitGatewayConnectionTunnels method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) GetTransitGatewayConnectionTunnelsWithContext(ctx context.Context, getTransitGatewayConnectionTunnelsOptions *GetTransitGatewayConnectionTunnelsOptions) (result *TransitGatewayTunnel, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getTransitGatewayConnectionTunnelsOptions, "getTransitGatewayConnectionTunnelsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getTransitGatewayConnectionTunnelsOptions, "getTransitGatewayConnectionTunnelsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"transit_gateway_id": *getTransitGatewayConnectionTunnelsOptions.TransitGatewayID,
		"id":                 *getTransitGatewayConnectionTunnelsOptions.ID,
		"gre_tunnel_id":      *getTransitGatewayConnectionTunnelsOptions.GreTunnelID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/transit_gateways/{transit_gateway_id}/connections/{id}/tunnels/{gre_tunnel_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getTransitGatewayConnectionTunnelsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "GetTransitGatewayConnectionTunnels")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTransitGatewayTunnel)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// UpdateTransitGatewayConnectionTunnels : Updates specified Transit Gateway redundant GRE tunnel
// Update the name of a connection tunnel.
func (transitGatewayApis *TransitGatewayApisV1) UpdateTransitGatewayConnectionTunnels(updateTransitGatewayConnectionTunnelsOptions *UpdateTransitGatewayConnectionTunnelsOptions) (result *TransitGatewayTunnel, response *core.DetailedResponse, err error) {
	return transitGatewayApis.UpdateTransitGatewayConnectionTunnelsWithContext(context.Background(), updateTransitGatewayConnectionTunnelsOptions)
}

// UpdateTransitGatewayConnectionTunnelsWithContext is an alternate form of the UpdateTransitGatewayConnectionTunnels method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) UpdateTransitGatewayConnectionTunnelsWithContext(ctx context.Context, updateTransitGatewayConnectionTunnelsOptions *UpdateTransitGatewayConnectionTunnelsOptions) (result *TransitGatewayTunnel, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateTransitGatewayConnectionTunnelsOptions, "updateTransitGatewayConnectionTunnelsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateTransitGatewayConnectionTunnelsOptions, "updateTransitGatewayConnectionTunnelsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"transit_gateway_id": *updateTransitGatewayConnectionTunnelsOptions.TransitGatewayID,
		"id":                 *updateTransitGatewayConnectionTunnelsOptions.ID,
		"gre_tunnel_id":      *updateTransitGatewayConnectionTunnelsOptions.GreTunnelID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/transit_gateways/{transit_gateway_id}/connections/{id}/tunnels/{gre_tunnel_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateTransitGatewayConnectionTunnelsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "UpdateTransitGatewayConnectionTunnels")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/merge-patch+json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	_, err = builder.SetBodyContentJSON(updateTransitGatewayConnectionTunnelsOptions.TransitGatewayTunnelPatch)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTransitGatewayTunnel)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListGatewayLocations : Lists all locations that support Transit Gateways
// List all locations that support Transit Gateways.
func (transitGatewayApis *TransitGatewayApisV1) ListGatewayLocations(listGatewayLocationsOptions *ListGatewayLocationsOptions) (result *TSCollection, response *core.DetailedResponse, err error) {
	return transitGatewayApis.ListGatewayLocationsWithContext(context.Background(), listGatewayLocationsOptions)
}

// ListGatewayLocationsWithContext is an alternate form of the ListGatewayLocations method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) ListGatewayLocationsWithContext(ctx context.Context, listGatewayLocationsOptions *ListGatewayLocationsOptions) (result *TSCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listGatewayLocationsOptions, "listGatewayLocationsOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/locations`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range listGatewayLocationsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "ListGatewayLocations")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTSCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// GetGatewayLocation : Shows the details of a given Transit Gateway location
// Get the details of a Transit Gateway Location.
func (transitGatewayApis *TransitGatewayApisV1) GetGatewayLocation(getGatewayLocationOptions *GetGatewayLocationOptions) (result *TSLocation, response *core.DetailedResponse, err error) {
	return transitGatewayApis.GetGatewayLocationWithContext(context.Background(), getGatewayLocationOptions)
}

// GetGatewayLocationWithContext is an alternate form of the GetGatewayLocation method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) GetGatewayLocationWithContext(ctx context.Context, getGatewayLocationOptions *GetGatewayLocationOptions) (result *TSLocation, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getGatewayLocationOptions, "getGatewayLocationOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getGatewayLocationOptions, "getGatewayLocationOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"name": *getGatewayLocationOptions.Name,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/locations/{name}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getGatewayLocationOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "GetGatewayLocation")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTSLocation)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListTransitGatewayConnectionPrefixFilters : Retrieves all prefix filters in a Transit Gateway connection
// This request retrieves all prefix filters in a Transit Gateway connection.
func (transitGatewayApis *TransitGatewayApisV1) ListTransitGatewayConnectionPrefixFilters(listTransitGatewayConnectionPrefixFiltersOptions *ListTransitGatewayConnectionPrefixFiltersOptions) (result *PrefixFilterCollection, response *core.DetailedResponse, err error) {
	return transitGatewayApis.ListTransitGatewayConnectionPrefixFiltersWithContext(context.Background(), listTransitGatewayConnectionPrefixFiltersOptions)
}

// ListTransitGatewayConnectionPrefixFiltersWithContext is an alternate form of the ListTransitGatewayConnectionPrefixFilters method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) ListTransitGatewayConnectionPrefixFiltersWithContext(ctx context.Context, listTransitGatewayConnectionPrefixFiltersOptions *ListTransitGatewayConnectionPrefixFiltersOptions) (result *PrefixFilterCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listTransitGatewayConnectionPrefixFiltersOptions, "listTransitGatewayConnectionPrefixFiltersOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listTransitGatewayConnectionPrefixFiltersOptions, "listTransitGatewayConnectionPrefixFiltersOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"transit_gateway_id": *listTransitGatewayConnectionPrefixFiltersOptions.TransitGatewayID,
		"id":                 *listTransitGatewayConnectionPrefixFiltersOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/transit_gateways/{transit_gateway_id}/connections/{id}/prefix_filters`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listTransitGatewayConnectionPrefixFiltersOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "ListTransitGatewayConnectionPrefixFilters")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalPrefixFilterCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateTransitGatewayConnectionPrefixFilter : Add a prefix filter to a Transit Gateway connection
// Add a prefix filter to a Transit Gateway connection.
func (transitGatewayApis *TransitGatewayApisV1) CreateTransitGatewayConnectionPrefixFilter(createTransitGatewayConnectionPrefixFilterOptions *CreateTransitGatewayConnectionPrefixFilterOptions) (result *PrefixFilterCust, response *core.DetailedResponse, err error) {
	return transitGatewayApis.CreateTransitGatewayConnectionPrefixFilterWithContext(context.Background(), createTransitGatewayConnectionPrefixFilterOptions)
}

// CreateTransitGatewayConnectionPrefixFilterWithContext is an alternate form of the CreateTransitGatewayConnectionPrefixFilter method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) CreateTransitGatewayConnectionPrefixFilterWithContext(ctx context.Context, createTransitGatewayConnectionPrefixFilterOptions *CreateTransitGatewayConnectionPrefixFilterOptions) (result *PrefixFilterCust, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createTransitGatewayConnectionPrefixFilterOptions, "createTransitGatewayConnectionPrefixFilterOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createTransitGatewayConnectionPrefixFilterOptions, "createTransitGatewayConnectionPrefixFilterOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"transit_gateway_id": *createTransitGatewayConnectionPrefixFilterOptions.TransitGatewayID,
		"id":                 *createTransitGatewayConnectionPrefixFilterOptions.ID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/transit_gateways/{transit_gateway_id}/connections/{id}/prefix_filters`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range createTransitGatewayConnectionPrefixFilterOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "CreateTransitGatewayConnectionPrefixFilter")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	body := make(map[string]interface{})
	if createTransitGatewayConnectionPrefixFilterOptions.Action != nil {
		body["action"] = createTransitGatewayConnectionPrefixFilterOptions.Action
	}
	if createTransitGatewayConnectionPrefixFilterOptions.Prefix != nil {
		body["prefix"] = createTransitGatewayConnectionPrefixFilterOptions.Prefix
	}
	if createTransitGatewayConnectionPrefixFilterOptions.Before != nil {
		body["before"] = createTransitGatewayConnectionPrefixFilterOptions.Before
	}
	if createTransitGatewayConnectionPrefixFilterOptions.Ge != nil {
		body["ge"] = createTransitGatewayConnectionPrefixFilterOptions.Ge
	}
	if createTransitGatewayConnectionPrefixFilterOptions.Le != nil {
		body["le"] = createTransitGatewayConnectionPrefixFilterOptions.Le
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalPrefixFilterCust)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ReplaceTransitGatewayConnectionPrefixFilter : Replaces the prefix filters of the Transit Gateway connection
// Replaces the prefix filters of the Transit Gateway connection.
func (transitGatewayApis *TransitGatewayApisV1) ReplaceTransitGatewayConnectionPrefixFilter(replaceTransitGatewayConnectionPrefixFilterOptions *ReplaceTransitGatewayConnectionPrefixFilterOptions) (result *PrefixFilterCollection, response *core.DetailedResponse, err error) {
	return transitGatewayApis.ReplaceTransitGatewayConnectionPrefixFilterWithContext(context.Background(), replaceTransitGatewayConnectionPrefixFilterOptions)
}

// ReplaceTransitGatewayConnectionPrefixFilterWithContext is an alternate form of the ReplaceTransitGatewayConnectionPrefixFilter method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) ReplaceTransitGatewayConnectionPrefixFilterWithContext(ctx context.Context, replaceTransitGatewayConnectionPrefixFilterOptions *ReplaceTransitGatewayConnectionPrefixFilterOptions) (result *PrefixFilterCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(replaceTransitGatewayConnectionPrefixFilterOptions, "replaceTransitGatewayConnectionPrefixFilterOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(replaceTransitGatewayConnectionPrefixFilterOptions, "replaceTransitGatewayConnectionPrefixFilterOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"transit_gateway_id": *replaceTransitGatewayConnectionPrefixFilterOptions.TransitGatewayID,
		"id":                 *replaceTransitGatewayConnectionPrefixFilterOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PUT)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/transit_gateways/{transit_gateway_id}/connections/{id}/prefix_filters`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range replaceTransitGatewayConnectionPrefixFilterOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "ReplaceTransitGatewayConnectionPrefixFilter")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	body := make(map[string]interface{})
	if replaceTransitGatewayConnectionPrefixFilterOptions.PrefixFilters != nil {
		body["prefix_filters"] = replaceTransitGatewayConnectionPrefixFilterOptions.PrefixFilters
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalPrefixFilterCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteTransitGatewayConnectionPrefixFilter : Remove prefix filter from Transit Gateway connection
// Delete a prefix filter.
func (transitGatewayApis *TransitGatewayApisV1) DeleteTransitGatewayConnectionPrefixFilter(deleteTransitGatewayConnectionPrefixFilterOptions *DeleteTransitGatewayConnectionPrefixFilterOptions) (response *core.DetailedResponse, err error) {
	return transitGatewayApis.DeleteTransitGatewayConnectionPrefixFilterWithContext(context.Background(), deleteTransitGatewayConnectionPrefixFilterOptions)
}

// DeleteTransitGatewayConnectionPrefixFilterWithContext is an alternate form of the DeleteTransitGatewayConnectionPrefixFilter method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) DeleteTransitGatewayConnectionPrefixFilterWithContext(ctx context.Context, deleteTransitGatewayConnectionPrefixFilterOptions *DeleteTransitGatewayConnectionPrefixFilterOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteTransitGatewayConnectionPrefixFilterOptions, "deleteTransitGatewayConnectionPrefixFilterOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteTransitGatewayConnectionPrefixFilterOptions, "deleteTransitGatewayConnectionPrefixFilterOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"transit_gateway_id": *deleteTransitGatewayConnectionPrefixFilterOptions.TransitGatewayID,
		"id":                 *deleteTransitGatewayConnectionPrefixFilterOptions.ID,
		"filter_id":          *deleteTransitGatewayConnectionPrefixFilterOptions.FilterID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/transit_gateways/{transit_gateway_id}/connections/{id}/prefix_filters/{filter_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteTransitGatewayConnectionPrefixFilterOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "DeleteTransitGatewayConnectionPrefixFilter")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = transitGatewayApis.Service.Request(request, nil)

	return
}

// GetTransitGatewayConnectionPrefixFilter : Retrieves specified Transit Gateway connection prefix filter
// This request retrieves a prefix filter from the Transit Gateway connection.
func (transitGatewayApis *TransitGatewayApisV1) GetTransitGatewayConnectionPrefixFilter(getTransitGatewayConnectionPrefixFilterOptions *GetTransitGatewayConnectionPrefixFilterOptions) (result *PrefixFilterCust, response *core.DetailedResponse, err error) {
	return transitGatewayApis.GetTransitGatewayConnectionPrefixFilterWithContext(context.Background(), getTransitGatewayConnectionPrefixFilterOptions)
}

// GetTransitGatewayConnectionPrefixFilterWithContext is an alternate form of the GetTransitGatewayConnectionPrefixFilter method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) GetTransitGatewayConnectionPrefixFilterWithContext(ctx context.Context, getTransitGatewayConnectionPrefixFilterOptions *GetTransitGatewayConnectionPrefixFilterOptions) (result *PrefixFilterCust, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getTransitGatewayConnectionPrefixFilterOptions, "getTransitGatewayConnectionPrefixFilterOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getTransitGatewayConnectionPrefixFilterOptions, "getTransitGatewayConnectionPrefixFilterOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"transit_gateway_id": *getTransitGatewayConnectionPrefixFilterOptions.TransitGatewayID,
		"id":                 *getTransitGatewayConnectionPrefixFilterOptions.ID,
		"filter_id":          *getTransitGatewayConnectionPrefixFilterOptions.FilterID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/transit_gateways/{transit_gateway_id}/connections/{id}/prefix_filters/{filter_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getTransitGatewayConnectionPrefixFilterOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "GetTransitGatewayConnectionPrefixFilter")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalPrefixFilterCust)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// UpdateTransitGatewayConnectionPrefixFilter : Updates specified Transit Gateway connection prefix filter
// Update prefix filter for a Transit Gateway Connection.
func (transitGatewayApis *TransitGatewayApisV1) UpdateTransitGatewayConnectionPrefixFilter(updateTransitGatewayConnectionPrefixFilterOptions *UpdateTransitGatewayConnectionPrefixFilterOptions) (result *PrefixFilterCust, response *core.DetailedResponse, err error) {
	return transitGatewayApis.UpdateTransitGatewayConnectionPrefixFilterWithContext(context.Background(), updateTransitGatewayConnectionPrefixFilterOptions)
}

// UpdateTransitGatewayConnectionPrefixFilterWithContext is an alternate form of the UpdateTransitGatewayConnectionPrefixFilter method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) UpdateTransitGatewayConnectionPrefixFilterWithContext(ctx context.Context, updateTransitGatewayConnectionPrefixFilterOptions *UpdateTransitGatewayConnectionPrefixFilterOptions) (result *PrefixFilterCust, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateTransitGatewayConnectionPrefixFilterOptions, "updateTransitGatewayConnectionPrefixFilterOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateTransitGatewayConnectionPrefixFilterOptions, "updateTransitGatewayConnectionPrefixFilterOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"transit_gateway_id": *updateTransitGatewayConnectionPrefixFilterOptions.TransitGatewayID,
		"id":                 *updateTransitGatewayConnectionPrefixFilterOptions.ID,
		"filter_id":          *updateTransitGatewayConnectionPrefixFilterOptions.FilterID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/transit_gateways/{transit_gateway_id}/connections/{id}/prefix_filters/{filter_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateTransitGatewayConnectionPrefixFilterOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "UpdateTransitGatewayConnectionPrefixFilter")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	body := make(map[string]interface{})
	if updateTransitGatewayConnectionPrefixFilterOptions.Action != nil {
		body["action"] = updateTransitGatewayConnectionPrefixFilterOptions.Action
	}
	if updateTransitGatewayConnectionPrefixFilterOptions.Before != nil {
		body["before"] = updateTransitGatewayConnectionPrefixFilterOptions.Before
	}
	if updateTransitGatewayConnectionPrefixFilterOptions.Ge != nil {
		body["ge"] = updateTransitGatewayConnectionPrefixFilterOptions.Ge
	}
	if updateTransitGatewayConnectionPrefixFilterOptions.Le != nil {
		body["le"] = updateTransitGatewayConnectionPrefixFilterOptions.Le
	}
	if updateTransitGatewayConnectionPrefixFilterOptions.Prefix != nil {
		body["prefix"] = updateTransitGatewayConnectionPrefixFilterOptions.Prefix
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalPrefixFilterCust)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListTransitGatewayRouteReports : Lists route reports
// Retrieve all route reports for the specified Transit Gateway.  There will normally be at most one completed report
// and one pending report.  Additionally, completed route reports are written to IBM Cloud Activity Tracker.
func (transitGatewayApis *TransitGatewayApisV1) ListTransitGatewayRouteReports(listTransitGatewayRouteReportsOptions *ListTransitGatewayRouteReportsOptions) (result *RouteReportCollection, response *core.DetailedResponse, err error) {
	return transitGatewayApis.ListTransitGatewayRouteReportsWithContext(context.Background(), listTransitGatewayRouteReportsOptions)
}

// ListTransitGatewayRouteReportsWithContext is an alternate form of the ListTransitGatewayRouteReports method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) ListTransitGatewayRouteReportsWithContext(ctx context.Context, listTransitGatewayRouteReportsOptions *ListTransitGatewayRouteReportsOptions) (result *RouteReportCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listTransitGatewayRouteReportsOptions, "listTransitGatewayRouteReportsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listTransitGatewayRouteReportsOptions, "listTransitGatewayRouteReportsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"transit_gateway_id": *listTransitGatewayRouteReportsOptions.TransitGatewayID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/transit_gateways/{transit_gateway_id}/route_reports`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listTransitGatewayRouteReportsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "ListTransitGatewayRouteReports")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalRouteReportCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateTransitGatewayRouteReport : Requests a route report
// Request route report generation.  While report generation is in progress, additional requests to generate a report
// are ignored and return the current pending report.
func (transitGatewayApis *TransitGatewayApisV1) CreateTransitGatewayRouteReport(createTransitGatewayRouteReportOptions *CreateTransitGatewayRouteReportOptions) (result *RouteReport, response *core.DetailedResponse, err error) {
	return transitGatewayApis.CreateTransitGatewayRouteReportWithContext(context.Background(), createTransitGatewayRouteReportOptions)
}

// CreateTransitGatewayRouteReportWithContext is an alternate form of the CreateTransitGatewayRouteReport method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) CreateTransitGatewayRouteReportWithContext(ctx context.Context, createTransitGatewayRouteReportOptions *CreateTransitGatewayRouteReportOptions) (result *RouteReport, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createTransitGatewayRouteReportOptions, "createTransitGatewayRouteReportOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createTransitGatewayRouteReportOptions, "createTransitGatewayRouteReportOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"transit_gateway_id": *createTransitGatewayRouteReportOptions.TransitGatewayID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/transit_gateways/{transit_gateway_id}/route_reports`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range createTransitGatewayRouteReportOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "CreateTransitGatewayRouteReport")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalRouteReport)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteTransitGatewayRouteReport : Deletes a route report
// Delete a route report.
func (transitGatewayApis *TransitGatewayApisV1) DeleteTransitGatewayRouteReport(deleteTransitGatewayRouteReportOptions *DeleteTransitGatewayRouteReportOptions) (response *core.DetailedResponse, err error) {
	return transitGatewayApis.DeleteTransitGatewayRouteReportWithContext(context.Background(), deleteTransitGatewayRouteReportOptions)
}

// DeleteTransitGatewayRouteReportWithContext is an alternate form of the DeleteTransitGatewayRouteReport method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) DeleteTransitGatewayRouteReportWithContext(ctx context.Context, deleteTransitGatewayRouteReportOptions *DeleteTransitGatewayRouteReportOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteTransitGatewayRouteReportOptions, "deleteTransitGatewayRouteReportOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteTransitGatewayRouteReportOptions, "deleteTransitGatewayRouteReportOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"transit_gateway_id": *deleteTransitGatewayRouteReportOptions.TransitGatewayID,
		"id":                 *deleteTransitGatewayRouteReportOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/transit_gateways/{transit_gateway_id}/route_reports/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteTransitGatewayRouteReportOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "DeleteTransitGatewayRouteReport")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = transitGatewayApis.Service.Request(request, nil)

	return
}

// GetTransitGatewayRouteReport : Retrieves a route report
// Retrieve a route report.
func (transitGatewayApis *TransitGatewayApisV1) GetTransitGatewayRouteReport(getTransitGatewayRouteReportOptions *GetTransitGatewayRouteReportOptions) (result *RouteReport, response *core.DetailedResponse, err error) {
	return transitGatewayApis.GetTransitGatewayRouteReportWithContext(context.Background(), getTransitGatewayRouteReportOptions)
}

// GetTransitGatewayRouteReportWithContext is an alternate form of the GetTransitGatewayRouteReport method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) GetTransitGatewayRouteReportWithContext(ctx context.Context, getTransitGatewayRouteReportOptions *GetTransitGatewayRouteReportOptions) (result *RouteReport, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getTransitGatewayRouteReportOptions, "getTransitGatewayRouteReportOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getTransitGatewayRouteReportOptions, "getTransitGatewayRouteReportOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"transit_gateway_id": *getTransitGatewayRouteReportOptions.TransitGatewayID,
		"id":                 *getTransitGatewayRouteReportOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/transit_gateways/{transit_gateway_id}/route_reports/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getTransitGatewayRouteReportOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "GetTransitGatewayRouteReport")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalRouteReport)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateTransitGatewayConnectionActionsOptions : The CreateTransitGatewayConnectionActions options.
type CreateTransitGatewayConnectionActionsOptions struct {
	// The Transit Gateway identifier.
	TransitGatewayID *string `json:"transit_gateway_id" validate:"required,ne="`

	// The connection identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The action that is to be performed against the connection request.
	Action *string `json:"action" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the CreateTransitGatewayConnectionActionsOptions.Action property.
// The action that is to be performed against the connection request.
const (
	CreateTransitGatewayConnectionActionsOptions_Action_Approve = "approve"
	CreateTransitGatewayConnectionActionsOptions_Action_Reject  = "reject"
)

// NewCreateTransitGatewayConnectionActionsOptions : Instantiate CreateTransitGatewayConnectionActionsOptions
func (*TransitGatewayApisV1) NewCreateTransitGatewayConnectionActionsOptions(transitGatewayID string, id string, action string) *CreateTransitGatewayConnectionActionsOptions {
	return &CreateTransitGatewayConnectionActionsOptions{
		TransitGatewayID: core.StringPtr(transitGatewayID),
		ID:               core.StringPtr(id),
		Action:           core.StringPtr(action),
	}
}

// SetTransitGatewayID : Allow user to set TransitGatewayID
func (_options *CreateTransitGatewayConnectionActionsOptions) SetTransitGatewayID(transitGatewayID string) *CreateTransitGatewayConnectionActionsOptions {
	_options.TransitGatewayID = core.StringPtr(transitGatewayID)
	return _options
}

// SetID : Allow user to set ID
func (_options *CreateTransitGatewayConnectionActionsOptions) SetID(id string) *CreateTransitGatewayConnectionActionsOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetAction : Allow user to set Action
func (_options *CreateTransitGatewayConnectionActionsOptions) SetAction(action string) *CreateTransitGatewayConnectionActionsOptions {
	_options.Action = core.StringPtr(action)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateTransitGatewayConnectionActionsOptions) SetHeaders(param map[string]string) *CreateTransitGatewayConnectionActionsOptions {
	options.Headers = param
	return options
}

// CreateTransitGatewayConnectionOptions : The CreateTransitGatewayConnection options.
type CreateTransitGatewayConnectionOptions struct {
	// The Transit Gateway identifier.
	TransitGatewayID *string `json:"transit_gateway_id" validate:"required,ne="`

	// Defines what type of network is connected via this connection.
	NetworkType *string `json:"network_type" validate:"required"`

	// network_type `gre_tunnel` connections must be created over an existing network_type `classic` connection. This field
	// must specify the ID of an active transit gateway network_type `classic` connection in the same transit gateway.
	//
	// This field is required for network type `gre_tunnel` connections.
	//
	// This field is required to be unspecified for network type `classic`, `directlink`, `vpc`,
	// `power_virtual_server`, `unbound_gre_tunnel`, `vpn_gateway` and `redundant_gre` connections.
	// Deprecated: this field is deprecated and may be removed in a future release.
	BaseConnectionID *string `json:"base_connection_id,omitempty"`

	// The type of network the Unbound GRE tunnel is targeting. This field is required for network type
	// `unbound_gre_tunnel` and must be set to `classic`.  For a `redundant_gre` network type, the value is required and
	// can be either VPC or Classic. This field is required to be unspecified for network type `classic`, `directlink`,
	// `vpc`, `power_virtual_server`, `vpn_gateway` and `gre_tunnel` connections.
	BaseNetworkType *string `json:"base_network_type,omitempty"`

	// network_type 'vpn_gateway' connections use 'cidr' to specify the CIDR to use for the VPN GRE tunnels.
	//
	// This field is required for network type `vpn_gateway` connections.
	//
	// This field is required to be unspecified for network type `classic`, `directlink`, `vpc`, `power_virtual_server`,
	// `gre_tunnel`, `unbound_gre_tunnel`, and `redundant_gre` connections.
	Cidr *string `json:"cidr,omitempty"`

	// Local gateway IP address. This field is required for network type `gre_tunnel` and `unbound_gre_tunnel` connections.
	// This field is required to be unspecified for network type `classic`, `directlink`, `vpc`, `power_virtual_server`,
	// `vpn_gateway` and `redundant_gre` connections.
	LocalGatewayIp *string `json:"local_gateway_ip,omitempty"`

	// Local tunnel IP address. The local_tunnel_ip and remote_tunnel_ip addresses must be in the same /30 network. Neither
	// can be the network nor broadcast addresses.
	//
	// This field is required for network type `gre_tunnel` and `unbound_gre_tunnel` connections.
	//
	// This field is required to be unspecified for network type `classic`, `directlink`, `vpc`, `power_virtual_server`,
	// `vpn_gateway` and `redundant_gre` connections.
	LocalTunnelIp *string `json:"local_tunnel_ip,omitempty"`

	// The user-defined name for this transit gateway connection. Network type `vpc`  connections are defaulted to the name
	// of the VPC.  Network type `classic` connections are named `classic`.
	//
	// This field is required for network type `power_virtual_server`, `directlink`, `gre_tunnel`, `unbound_gre_tunnel`,
	// `vpn_gateway` and `redundant_gre` connections.
	//
	// This field is optional for network type `classic`, `vpc` connections.
	Name *string `json:"name,omitempty"`

	// The ID of the account which owns the network that is being connected. Generally only used if the network is in a
	// different account than the gateway. This field is required for type `unbound_gre_tunnel` when the
	// associated_network_type is `classic` or network_type is `redundant_gre` and the GRE tunnel is in a different account
	// than the gateway.
	NetworkAccountID *string `json:"network_account_id,omitempty"`

	// The ID of the network being connected via this connection. For network types `vpc`,`power_virtual_server`,
	// `directlink` and `vpn_gateway` this is the CRN of the VPC / PowerVS / VDC / Direct Link / VPN gateway respectively.
	// This field is required for network type `vpc`, `power_virtual_server`, `vpn_gateway`, and `directlink` connections.
	// It is also required for `redundant_gre` connections when the base_network_type is set to VPC. This field is required
	// to be unspecified for network type `classic`, `gre_tunnel` and `unbound_gre_tunnel` connections.
	NetworkID *string `json:"network_id,omitempty"`

	// Array of prefix route filters for a transit gateway connection. Prefix filters can be specified for netowrk type
	// `vpc`, `classic`, `power_virtual_server` and `directlink` connections. They are not allowed for type `gre_tunnel`
	// connections. This is order dependent with those first in the array being applied first, and those at the end of the
	// array being applied last, or just before applying the default. This field is optional for network type `classic`,
	// `vpc`, `directlink`, and `power_virtual_server` connections. This field is required to be unspecified for network
	// type `gre_tunnel`, `unbound_gre_tunnel`, `vpn_gateway` and `redundant_gre` connections.
	PrefixFilters []TransitGatewayConnectionPrefixFilter `json:"prefix_filters,omitempty"`

	// Default setting of permit or deny which applies to any routes that don't match a specified filter. This field is
	// optional for network type `classic`, `vpc`, `directlink`, and `power_virtual_server` connections. This field is
	// required to be unspecified for network type `gre_tunnel`, `unbound_gre_tunnel`, `vpn_gateway` and `redundant_gre`
	// connections.
	PrefixFiltersDefault *string `json:"prefix_filters_default,omitempty"`

	// Remote network BGP ASN. The following ASN values are reserved and unavailable 0, 13884, 36351, 64512-64513, 65100,
	// 65200-65234, 65402-65433, 65500 and 4201065000-4201065999. If `remote_bgp_asn` is omitted on gre_tunnel or
	// unbound_gre_tunnel connection create requests IBM will assign an ASN.
	//
	// This field is optional for network type `gre_tunnel` and `unbound_gre_tunnel` connections.
	//
	// This field is required to be unspecified for network type `classic`, `directlink`, `vpc`, `power_virtual_server`,
	// `vpn_gateway` and `gre_tunnel` connections.
	RemoteBgpAsn *int64 `json:"remote_bgp_asn,omitempty"`

	// Remote gateway IP address. This field is required for network type `gre_tunnel` and `unbound_gre_tunnel`
	// connections. This field is required to be unspecified for network type `classic`, `directlink`, `vpc`,
	// `power_virtual_server`, `vpn_gateway` and `redundant_gre` connections.
	RemoteGatewayIp *string `json:"remote_gateway_ip,omitempty"`

	// Remote tunnel IP address. The local_tunnel_ip and remote_tunnel_ip addresses must be in the same /30 network.
	// Neither can be the network nor broadcast addresses.
	//
	// This field is required for network type `gre_tunnel` and `unbound_gre_tunnel` connections.
	//
	// This field is required to be unspecified for network type `classic`, `directlink`, `vpc`,  `power_virtual_server`,
	// `vpn_gateway` and `redundant_gre` connections.
	RemoteTunnelIp *string `json:"remote_tunnel_ip,omitempty"`

	// Array of GRE tunnels for a transit gateway `redundant_gre` and `vpn_gateway` connections.  This field is required
	// for `redundant_gre` and `vpn_gateway` connections.
	Tunnels []TransitGatewayTunnelTemplate `json:"tunnels,omitempty"`

	// Specify the connection's location.  The specified availability zone must reside in the gateway's region.
	// Use the IBM Cloud global catalog to list zones within the desired region.
	//
	// This field is required for network type `gre_tunnel`, `unbound_gre_tunnel` and `vpn_gateway` connections.
	//
	// This field is required to be unspecified for network type `classic`, `directlink`, `vpc`, `power_virtual_server` and
	// `redundant_gre` connections.
	Zone ZoneIdentityIntf `json:"zone,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the CreateTransitGatewayConnectionOptions.NetworkType property.
// Defines what type of network is connected via this connection.
const (
	CreateTransitGatewayConnectionOptions_NetworkType_Classic            = "classic"
	CreateTransitGatewayConnectionOptions_NetworkType_Directlink         = "directlink"
	CreateTransitGatewayConnectionOptions_NetworkType_GreTunnel          = "gre_tunnel"
	CreateTransitGatewayConnectionOptions_NetworkType_PowerVirtualServer = "power_virtual_server"
	CreateTransitGatewayConnectionOptions_NetworkType_RedundantGre       = "redundant_gre"
	CreateTransitGatewayConnectionOptions_NetworkType_UnboundGreTunnel   = "unbound_gre_tunnel"
	CreateTransitGatewayConnectionOptions_NetworkType_Vpc                = "vpc"
	CreateTransitGatewayConnectionOptions_NetworkType_VpnGateway         = "vpn_gateway"
)

// Constants associated with the CreateTransitGatewayConnectionOptions.BaseNetworkType property.
// The type of network the Unbound GRE tunnel is targeting. This field is required for network type `unbound_gre_tunnel`
// and must be set to `classic`.  For a `redundant_gre` network type, the value is required and can be either VPC or
// Classic. This field is required to be unspecified for network type `classic`, `directlink`, `vpc`,
// `power_virtual_server`, `vpn_gateway` and `gre_tunnel` connections.
const (
	CreateTransitGatewayConnectionOptions_BaseNetworkType_Classic = "classic"
	CreateTransitGatewayConnectionOptions_BaseNetworkType_Vpc     = "vpc"
)

// Constants associated with the CreateTransitGatewayConnectionOptions.PrefixFiltersDefault property.
// Default setting of permit or deny which applies to any routes that don't match a specified filter. This field is
// optional for network type `classic`, `vpc`, `directlink`, and `power_virtual_server` connections. This field is
// required to be unspecified for network type `gre_tunnel`, `unbound_gre_tunnel`, `vpn_gateway` and `redundant_gre`
// connections.
const (
	CreateTransitGatewayConnectionOptions_PrefixFiltersDefault_Deny   = "deny"
	CreateTransitGatewayConnectionOptions_PrefixFiltersDefault_Permit = "permit"
)

// NewCreateTransitGatewayConnectionOptions : Instantiate CreateTransitGatewayConnectionOptions
func (*TransitGatewayApisV1) NewCreateTransitGatewayConnectionOptions(transitGatewayID string, networkType string) *CreateTransitGatewayConnectionOptions {
	return &CreateTransitGatewayConnectionOptions{
		TransitGatewayID: core.StringPtr(transitGatewayID),
		NetworkType:      core.StringPtr(networkType),
	}
}

// SetTransitGatewayID : Allow user to set TransitGatewayID
func (_options *CreateTransitGatewayConnectionOptions) SetTransitGatewayID(transitGatewayID string) *CreateTransitGatewayConnectionOptions {
	_options.TransitGatewayID = core.StringPtr(transitGatewayID)
	return _options
}

// SetNetworkType : Allow user to set NetworkType
func (_options *CreateTransitGatewayConnectionOptions) SetNetworkType(networkType string) *CreateTransitGatewayConnectionOptions {
	_options.NetworkType = core.StringPtr(networkType)
	return _options
}

// SetBaseConnectionID : Allow user to set BaseConnectionID
// Deprecated: this method is deprecated and may be removed in a future release.
func (_options *CreateTransitGatewayConnectionOptions) SetBaseConnectionID(baseConnectionID string) *CreateTransitGatewayConnectionOptions {
	_options.BaseConnectionID = core.StringPtr(baseConnectionID)
	return _options
}

// SetBaseNetworkType : Allow user to set BaseNetworkType
func (_options *CreateTransitGatewayConnectionOptions) SetBaseNetworkType(baseNetworkType string) *CreateTransitGatewayConnectionOptions {
	_options.BaseNetworkType = core.StringPtr(baseNetworkType)
	return _options
}

// SetCidr : Allow user to set Cidr
func (_options *CreateTransitGatewayConnectionOptions) SetCidr(cidr string) *CreateTransitGatewayConnectionOptions {
	_options.Cidr = core.StringPtr(cidr)
	return _options
}

// SetLocalGatewayIp : Allow user to set LocalGatewayIp
func (_options *CreateTransitGatewayConnectionOptions) SetLocalGatewayIp(localGatewayIp string) *CreateTransitGatewayConnectionOptions {
	_options.LocalGatewayIp = core.StringPtr(localGatewayIp)
	return _options
}

// SetLocalTunnelIp : Allow user to set LocalTunnelIp
func (_options *CreateTransitGatewayConnectionOptions) SetLocalTunnelIp(localTunnelIp string) *CreateTransitGatewayConnectionOptions {
	_options.LocalTunnelIp = core.StringPtr(localTunnelIp)
	return _options
}

// SetName : Allow user to set Name
func (_options *CreateTransitGatewayConnectionOptions) SetName(name string) *CreateTransitGatewayConnectionOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetNetworkAccountID : Allow user to set NetworkAccountID
func (_options *CreateTransitGatewayConnectionOptions) SetNetworkAccountID(networkAccountID string) *CreateTransitGatewayConnectionOptions {
	_options.NetworkAccountID = core.StringPtr(networkAccountID)
	return _options
}

// SetNetworkID : Allow user to set NetworkID
func (_options *CreateTransitGatewayConnectionOptions) SetNetworkID(networkID string) *CreateTransitGatewayConnectionOptions {
	_options.NetworkID = core.StringPtr(networkID)
	return _options
}

// SetPrefixFilters : Allow user to set PrefixFilters
func (_options *CreateTransitGatewayConnectionOptions) SetPrefixFilters(prefixFilters []TransitGatewayConnectionPrefixFilter) *CreateTransitGatewayConnectionOptions {
	_options.PrefixFilters = prefixFilters
	return _options
}

// SetPrefixFiltersDefault : Allow user to set PrefixFiltersDefault
func (_options *CreateTransitGatewayConnectionOptions) SetPrefixFiltersDefault(prefixFiltersDefault string) *CreateTransitGatewayConnectionOptions {
	_options.PrefixFiltersDefault = core.StringPtr(prefixFiltersDefault)
	return _options
}

// SetRemoteBgpAsn : Allow user to set RemoteBgpAsn
func (_options *CreateTransitGatewayConnectionOptions) SetRemoteBgpAsn(remoteBgpAsn int64) *CreateTransitGatewayConnectionOptions {
	_options.RemoteBgpAsn = core.Int64Ptr(remoteBgpAsn)
	return _options
}

// SetRemoteGatewayIp : Allow user to set RemoteGatewayIp
func (_options *CreateTransitGatewayConnectionOptions) SetRemoteGatewayIp(remoteGatewayIp string) *CreateTransitGatewayConnectionOptions {
	_options.RemoteGatewayIp = core.StringPtr(remoteGatewayIp)
	return _options
}

// SetRemoteTunnelIp : Allow user to set RemoteTunnelIp
func (_options *CreateTransitGatewayConnectionOptions) SetRemoteTunnelIp(remoteTunnelIp string) *CreateTransitGatewayConnectionOptions {
	_options.RemoteTunnelIp = core.StringPtr(remoteTunnelIp)
	return _options
}

// SetTunnels : Allow user to set Tunnels
func (_options *CreateTransitGatewayConnectionOptions) SetTunnels(tunnels []TransitGatewayTunnelTemplate) *CreateTransitGatewayConnectionOptions {
	_options.Tunnels = tunnels
	return _options
}

// SetZone : Allow user to set Zone
func (_options *CreateTransitGatewayConnectionOptions) SetZone(zone ZoneIdentityIntf) *CreateTransitGatewayConnectionOptions {
	_options.Zone = zone
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateTransitGatewayConnectionOptions) SetHeaders(param map[string]string) *CreateTransitGatewayConnectionOptions {
	options.Headers = param
	return options
}

// CreateTransitGatewayConnectionPrefixFilterOptions : The CreateTransitGatewayConnectionPrefixFilter options.
type CreateTransitGatewayConnectionPrefixFilterOptions struct {
	// The Transit Gateway identifier.
	TransitGatewayID *string `json:"transit_gateway_id" validate:"required,ne="`

	// The connection identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Whether or not this prefix filter should allow or deny prefixes matching this filter's prefix definition.
	Action *string `json:"action" validate:"required"`

	// The IPv4 Prefix to be matched by this filter. If both the `le` and `ge` are zero, then this filter will only apply
	// to routes that exactly match this prefix, while a non-zero value for either `le` or `ge`, this filter can apply to
	// multiple routes with different prefix lengths, but will still only apply to prefixes contained in the address space
	// defined by `prefix`.
	Prefix *string `json:"prefix" validate:"required"`

	// A reference to the prefix filter that will be the next filter applied to the Transit Gateway connection.
	//
	// If this field is blank, this prefix filter will be the last rule applied before the connection's default rule.
	//
	// When a prefix filter is created with the same before field as an existing prefix filter, the existing filter will be
	// applied before the new filter, and the existing filter's before field will be updated accordingly.
	Before *string `json:"before,omitempty"`

	// Defines the minimum matched prefix precision. If this field is non-zero then the filter will match all routes within
	// the `prefix` that have a prefix length greater than or equal to this value.
	//
	// This value can be zero, or a non-negative number greater than or equal to the prefix length of the filter's prefix
	// or less then or equal to 32. If this value is set to zero, the filter will not use the `ge` route matching behavior.
	// If the `le` value is non-zero the the `ge` value must between the prefix length and the
	// `le` value, inclusive.
	Ge *int64 `json:"ge,omitempty"`

	// Defines the maximum matched prefix precision. If this field is non-zero then the filter will match all routes within
	// the `prefix` that have a prefix length less than or equal to this value.
	//
	// This value can be zero, or a non-negative number greater than or equal to the prefix length of the filter's prefix
	// or less then or equal to 32. If this value is set to zero, the filter will not use the `le` route matching behavior.
	// If the `ge` value is non-zero the the `le` value must between the `ge` value and 32, inclusive.
	Le *int64 `json:"le,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the CreateTransitGatewayConnectionPrefixFilterOptions.Action property.
// Whether or not this prefix filter should allow or deny prefixes matching this filter's prefix definition.
const (
	CreateTransitGatewayConnectionPrefixFilterOptions_Action_Deny   = "deny"
	CreateTransitGatewayConnectionPrefixFilterOptions_Action_Permit = "permit"
)

// NewCreateTransitGatewayConnectionPrefixFilterOptions : Instantiate CreateTransitGatewayConnectionPrefixFilterOptions
func (*TransitGatewayApisV1) NewCreateTransitGatewayConnectionPrefixFilterOptions(transitGatewayID string, id string, action string, prefix string) *CreateTransitGatewayConnectionPrefixFilterOptions {
	return &CreateTransitGatewayConnectionPrefixFilterOptions{
		TransitGatewayID: core.StringPtr(transitGatewayID),
		ID:               core.StringPtr(id),
		Action:           core.StringPtr(action),
		Prefix:           core.StringPtr(prefix),
	}
}

// SetTransitGatewayID : Allow user to set TransitGatewayID
func (_options *CreateTransitGatewayConnectionPrefixFilterOptions) SetTransitGatewayID(transitGatewayID string) *CreateTransitGatewayConnectionPrefixFilterOptions {
	_options.TransitGatewayID = core.StringPtr(transitGatewayID)
	return _options
}

// SetID : Allow user to set ID
func (_options *CreateTransitGatewayConnectionPrefixFilterOptions) SetID(id string) *CreateTransitGatewayConnectionPrefixFilterOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetAction : Allow user to set Action
func (_options *CreateTransitGatewayConnectionPrefixFilterOptions) SetAction(action string) *CreateTransitGatewayConnectionPrefixFilterOptions {
	_options.Action = core.StringPtr(action)
	return _options
}

// SetPrefix : Allow user to set Prefix
func (_options *CreateTransitGatewayConnectionPrefixFilterOptions) SetPrefix(prefix string) *CreateTransitGatewayConnectionPrefixFilterOptions {
	_options.Prefix = core.StringPtr(prefix)
	return _options
}

// SetBefore : Allow user to set Before
func (_options *CreateTransitGatewayConnectionPrefixFilterOptions) SetBefore(before string) *CreateTransitGatewayConnectionPrefixFilterOptions {
	_options.Before = core.StringPtr(before)
	return _options
}

// SetGe : Allow user to set Ge
func (_options *CreateTransitGatewayConnectionPrefixFilterOptions) SetGe(ge int64) *CreateTransitGatewayConnectionPrefixFilterOptions {
	_options.Ge = core.Int64Ptr(ge)
	return _options
}

// SetLe : Allow user to set Le
func (_options *CreateTransitGatewayConnectionPrefixFilterOptions) SetLe(le int64) *CreateTransitGatewayConnectionPrefixFilterOptions {
	_options.Le = core.Int64Ptr(le)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateTransitGatewayConnectionPrefixFilterOptions) SetHeaders(param map[string]string) *CreateTransitGatewayConnectionPrefixFilterOptions {
	options.Headers = param
	return options
}

// CreateTransitGatewayGreTunnelOptions : The CreateTransitGatewayGreTunnel options.
type CreateTransitGatewayGreTunnelOptions struct {
	// The Transit Gateway identifier.
	TransitGatewayID *string `json:"transit_gateway_id" validate:"required,ne="`

	// The connection identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Local gateway IP address.
	LocalGatewayIp *string `json:"local_gateway_ip" validate:"required"`

	// Local tunnel IP address. The local_tunnel_ip and remote_tunnel_ip addresses must be in the same /30 network. Neither
	// can be the network nor broadcast addresses.
	LocalTunnelIp *string `json:"local_tunnel_ip" validate:"required"`

	// The user-defined name for this tunnel connection.
	Name *string `json:"name" validate:"required"`

	// Remote gateway IP address.
	RemoteGatewayIp *string `json:"remote_gateway_ip" validate:"required"`

	// Remote tunnel IP address. The local_tunnel_ip and remote_tunnel_ip addresses must be in the same /30 network.
	// Neither can be the network nor broadcast addresses.
	RemoteTunnelIp *string `json:"remote_tunnel_ip" validate:"required"`

	// Specify the connection's location.  The specified availability zone must reside in the gateway's region.
	// Use the IBM Cloud global catalog to list zones within the desired region.
	Zone ZoneIdentityIntf `json:"zone" validate:"required"`

	// Remote network BGP ASN. The following ASN values are reserved and unavailable 0, 13884, 36351, 64512-64513, 65100,
	// 65200-65234, 65402-65433, 65500 and 4201065000-4201065999. If `remote_bgp_asn` is omitted on create requests, IBM
	// will assign an ASN.
	RemoteBgpAsn *int64 `json:"remote_bgp_asn,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateTransitGatewayGreTunnelOptions : Instantiate CreateTransitGatewayGreTunnelOptions
func (*TransitGatewayApisV1) NewCreateTransitGatewayGreTunnelOptions(transitGatewayID string, id string, localGatewayIp string, localTunnelIp string, name string, remoteGatewayIp string, remoteTunnelIp string, zone ZoneIdentityIntf) *CreateTransitGatewayGreTunnelOptions {
	return &CreateTransitGatewayGreTunnelOptions{
		TransitGatewayID: core.StringPtr(transitGatewayID),
		ID:               core.StringPtr(id),
		LocalGatewayIp:   core.StringPtr(localGatewayIp),
		LocalTunnelIp:    core.StringPtr(localTunnelIp),
		Name:             core.StringPtr(name),
		RemoteGatewayIp:  core.StringPtr(remoteGatewayIp),
		RemoteTunnelIp:   core.StringPtr(remoteTunnelIp),
		Zone:             zone,
	}
}

// SetTransitGatewayID : Allow user to set TransitGatewayID
func (_options *CreateTransitGatewayGreTunnelOptions) SetTransitGatewayID(transitGatewayID string) *CreateTransitGatewayGreTunnelOptions {
	_options.TransitGatewayID = core.StringPtr(transitGatewayID)
	return _options
}

// SetID : Allow user to set ID
func (_options *CreateTransitGatewayGreTunnelOptions) SetID(id string) *CreateTransitGatewayGreTunnelOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetLocalGatewayIp : Allow user to set LocalGatewayIp
func (_options *CreateTransitGatewayGreTunnelOptions) SetLocalGatewayIp(localGatewayIp string) *CreateTransitGatewayGreTunnelOptions {
	_options.LocalGatewayIp = core.StringPtr(localGatewayIp)
	return _options
}

// SetLocalTunnelIp : Allow user to set LocalTunnelIp
func (_options *CreateTransitGatewayGreTunnelOptions) SetLocalTunnelIp(localTunnelIp string) *CreateTransitGatewayGreTunnelOptions {
	_options.LocalTunnelIp = core.StringPtr(localTunnelIp)
	return _options
}

// SetName : Allow user to set Name
func (_options *CreateTransitGatewayGreTunnelOptions) SetName(name string) *CreateTransitGatewayGreTunnelOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetRemoteGatewayIp : Allow user to set RemoteGatewayIp
func (_options *CreateTransitGatewayGreTunnelOptions) SetRemoteGatewayIp(remoteGatewayIp string) *CreateTransitGatewayGreTunnelOptions {
	_options.RemoteGatewayIp = core.StringPtr(remoteGatewayIp)
	return _options
}

// SetRemoteTunnelIp : Allow user to set RemoteTunnelIp
func (_options *CreateTransitGatewayGreTunnelOptions) SetRemoteTunnelIp(remoteTunnelIp string) *CreateTransitGatewayGreTunnelOptions {
	_options.RemoteTunnelIp = core.StringPtr(remoteTunnelIp)
	return _options
}

// SetZone : Allow user to set Zone
func (_options *CreateTransitGatewayGreTunnelOptions) SetZone(zone ZoneIdentityIntf) *CreateTransitGatewayGreTunnelOptions {
	_options.Zone = zone
	return _options
}

// SetRemoteBgpAsn : Allow user to set RemoteBgpAsn
func (_options *CreateTransitGatewayGreTunnelOptions) SetRemoteBgpAsn(remoteBgpAsn int64) *CreateTransitGatewayGreTunnelOptions {
	_options.RemoteBgpAsn = core.Int64Ptr(remoteBgpAsn)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateTransitGatewayGreTunnelOptions) SetHeaders(param map[string]string) *CreateTransitGatewayGreTunnelOptions {
	options.Headers = param
	return options
}

// CreateTransitGatewayOptions : The CreateTransitGateway options.
type CreateTransitGatewayOptions struct {
	// Location of Transit Gateway Services.
	Location *string `json:"location" validate:"required"`

	// A human readable name for the transit gateway.
	Name *string `json:"name" validate:"required"`

	// Allow global routing for a Transit Gateway. If unspecified, the default value is false.
	Global *bool `json:"global,omitempty"`

	// Allow GRE Enhanced Route Propagation on this gateway.
	GreEnhancedRoutePropagation *bool `json:"gre_enhanced_route_propagation,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://console.bluemix.net/apidocs/resource-manager#introduction) is used.
	ResourceGroup *ResourceGroupIdentity `json:"resource_group,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateTransitGatewayOptions : Instantiate CreateTransitGatewayOptions
func (*TransitGatewayApisV1) NewCreateTransitGatewayOptions(location string, name string) *CreateTransitGatewayOptions {
	return &CreateTransitGatewayOptions{
		Location: core.StringPtr(location),
		Name:     core.StringPtr(name),
	}
}

// SetLocation : Allow user to set Location
func (_options *CreateTransitGatewayOptions) SetLocation(location string) *CreateTransitGatewayOptions {
	_options.Location = core.StringPtr(location)
	return _options
}

// SetName : Allow user to set Name
func (_options *CreateTransitGatewayOptions) SetName(name string) *CreateTransitGatewayOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetGlobal : Allow user to set Global
func (_options *CreateTransitGatewayOptions) SetGlobal(global bool) *CreateTransitGatewayOptions {
	_options.Global = core.BoolPtr(global)
	return _options
}

// SetGreEnhancedRoutePropagation : Allow user to set GreEnhancedRoutePropagation
func (_options *CreateTransitGatewayOptions) SetGreEnhancedRoutePropagation(greEnhancedRoutePropagation bool) *CreateTransitGatewayOptions {
	_options.GreEnhancedRoutePropagation = core.BoolPtr(greEnhancedRoutePropagation)
	return _options
}

// SetResourceGroup : Allow user to set ResourceGroup
func (_options *CreateTransitGatewayOptions) SetResourceGroup(resourceGroup *ResourceGroupIdentity) *CreateTransitGatewayOptions {
	_options.ResourceGroup = resourceGroup
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateTransitGatewayOptions) SetHeaders(param map[string]string) *CreateTransitGatewayOptions {
	options.Headers = param
	return options
}

// CreateTransitGatewayRouteReportOptions : The CreateTransitGatewayRouteReport options.
type CreateTransitGatewayRouteReportOptions struct {
	// The Transit Gateway identifier.
	TransitGatewayID *string `json:"transit_gateway_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateTransitGatewayRouteReportOptions : Instantiate CreateTransitGatewayRouteReportOptions
func (*TransitGatewayApisV1) NewCreateTransitGatewayRouteReportOptions(transitGatewayID string) *CreateTransitGatewayRouteReportOptions {
	return &CreateTransitGatewayRouteReportOptions{
		TransitGatewayID: core.StringPtr(transitGatewayID),
	}
}

// SetTransitGatewayID : Allow user to set TransitGatewayID
func (_options *CreateTransitGatewayRouteReportOptions) SetTransitGatewayID(transitGatewayID string) *CreateTransitGatewayRouteReportOptions {
	_options.TransitGatewayID = core.StringPtr(transitGatewayID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateTransitGatewayRouteReportOptions) SetHeaders(param map[string]string) *CreateTransitGatewayRouteReportOptions {
	options.Headers = param
	return options
}

// DeleteTransitGatewayConnectionOptions : The DeleteTransitGatewayConnection options.
type DeleteTransitGatewayConnectionOptions struct {
	// The Transit Gateway identifier.
	TransitGatewayID *string `json:"transit_gateway_id" validate:"required,ne="`

	// The connection identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteTransitGatewayConnectionOptions : Instantiate DeleteTransitGatewayConnectionOptions
func (*TransitGatewayApisV1) NewDeleteTransitGatewayConnectionOptions(transitGatewayID string, id string) *DeleteTransitGatewayConnectionOptions {
	return &DeleteTransitGatewayConnectionOptions{
		TransitGatewayID: core.StringPtr(transitGatewayID),
		ID:               core.StringPtr(id),
	}
}

// SetTransitGatewayID : Allow user to set TransitGatewayID
func (_options *DeleteTransitGatewayConnectionOptions) SetTransitGatewayID(transitGatewayID string) *DeleteTransitGatewayConnectionOptions {
	_options.TransitGatewayID = core.StringPtr(transitGatewayID)
	return _options
}

// SetID : Allow user to set ID
func (_options *DeleteTransitGatewayConnectionOptions) SetID(id string) *DeleteTransitGatewayConnectionOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteTransitGatewayConnectionOptions) SetHeaders(param map[string]string) *DeleteTransitGatewayConnectionOptions {
	options.Headers = param
	return options
}

// DeleteTransitGatewayConnectionPrefixFilterOptions : The DeleteTransitGatewayConnectionPrefixFilter options.
type DeleteTransitGatewayConnectionPrefixFilterOptions struct {
	// The Transit Gateway identifier.
	TransitGatewayID *string `json:"transit_gateway_id" validate:"required,ne="`

	// The connection identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Prefix filter identifier.
	FilterID *string `json:"filter_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteTransitGatewayConnectionPrefixFilterOptions : Instantiate DeleteTransitGatewayConnectionPrefixFilterOptions
func (*TransitGatewayApisV1) NewDeleteTransitGatewayConnectionPrefixFilterOptions(transitGatewayID string, id string, filterID string) *DeleteTransitGatewayConnectionPrefixFilterOptions {
	return &DeleteTransitGatewayConnectionPrefixFilterOptions{
		TransitGatewayID: core.StringPtr(transitGatewayID),
		ID:               core.StringPtr(id),
		FilterID:         core.StringPtr(filterID),
	}
}

// SetTransitGatewayID : Allow user to set TransitGatewayID
func (_options *DeleteTransitGatewayConnectionPrefixFilterOptions) SetTransitGatewayID(transitGatewayID string) *DeleteTransitGatewayConnectionPrefixFilterOptions {
	_options.TransitGatewayID = core.StringPtr(transitGatewayID)
	return _options
}

// SetID : Allow user to set ID
func (_options *DeleteTransitGatewayConnectionPrefixFilterOptions) SetID(id string) *DeleteTransitGatewayConnectionPrefixFilterOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetFilterID : Allow user to set FilterID
func (_options *DeleteTransitGatewayConnectionPrefixFilterOptions) SetFilterID(filterID string) *DeleteTransitGatewayConnectionPrefixFilterOptions {
	_options.FilterID = core.StringPtr(filterID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteTransitGatewayConnectionPrefixFilterOptions) SetHeaders(param map[string]string) *DeleteTransitGatewayConnectionPrefixFilterOptions {
	options.Headers = param
	return options
}

// DeleteTransitGatewayConnectionTunnelsOptions : The DeleteTransitGatewayConnectionTunnels options.
type DeleteTransitGatewayConnectionTunnelsOptions struct {
	// The Transit Gateway identifier.
	TransitGatewayID *string `json:"transit_gateway_id" validate:"required,ne="`

	// The connection identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The tunnel identifier.
	GreTunnelID *string `json:"gre_tunnel_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteTransitGatewayConnectionTunnelsOptions : Instantiate DeleteTransitGatewayConnectionTunnelsOptions
func (*TransitGatewayApisV1) NewDeleteTransitGatewayConnectionTunnelsOptions(transitGatewayID string, id string, greTunnelID string) *DeleteTransitGatewayConnectionTunnelsOptions {
	return &DeleteTransitGatewayConnectionTunnelsOptions{
		TransitGatewayID: core.StringPtr(transitGatewayID),
		ID:               core.StringPtr(id),
		GreTunnelID:      core.StringPtr(greTunnelID),
	}
}

// SetTransitGatewayID : Allow user to set TransitGatewayID
func (_options *DeleteTransitGatewayConnectionTunnelsOptions) SetTransitGatewayID(transitGatewayID string) *DeleteTransitGatewayConnectionTunnelsOptions {
	_options.TransitGatewayID = core.StringPtr(transitGatewayID)
	return _options
}

// SetID : Allow user to set ID
func (_options *DeleteTransitGatewayConnectionTunnelsOptions) SetID(id string) *DeleteTransitGatewayConnectionTunnelsOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetGreTunnelID : Allow user to set GreTunnelID
func (_options *DeleteTransitGatewayConnectionTunnelsOptions) SetGreTunnelID(greTunnelID string) *DeleteTransitGatewayConnectionTunnelsOptions {
	_options.GreTunnelID = core.StringPtr(greTunnelID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteTransitGatewayConnectionTunnelsOptions) SetHeaders(param map[string]string) *DeleteTransitGatewayConnectionTunnelsOptions {
	options.Headers = param
	return options
}

// DeleteTransitGatewayOptions : The DeleteTransitGateway options.
type DeleteTransitGatewayOptions struct {
	// The Transit Gateway identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteTransitGatewayOptions : Instantiate DeleteTransitGatewayOptions
func (*TransitGatewayApisV1) NewDeleteTransitGatewayOptions(id string) *DeleteTransitGatewayOptions {
	return &DeleteTransitGatewayOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *DeleteTransitGatewayOptions) SetID(id string) *DeleteTransitGatewayOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteTransitGatewayOptions) SetHeaders(param map[string]string) *DeleteTransitGatewayOptions {
	options.Headers = param
	return options
}

// DeleteTransitGatewayRouteReportOptions : The DeleteTransitGatewayRouteReport options.
type DeleteTransitGatewayRouteReportOptions struct {
	// The Transit Gateway identifier.
	TransitGatewayID *string `json:"transit_gateway_id" validate:"required,ne="`

	// Route report identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteTransitGatewayRouteReportOptions : Instantiate DeleteTransitGatewayRouteReportOptions
func (*TransitGatewayApisV1) NewDeleteTransitGatewayRouteReportOptions(transitGatewayID string, id string) *DeleteTransitGatewayRouteReportOptions {
	return &DeleteTransitGatewayRouteReportOptions{
		TransitGatewayID: core.StringPtr(transitGatewayID),
		ID:               core.StringPtr(id),
	}
}

// SetTransitGatewayID : Allow user to set TransitGatewayID
func (_options *DeleteTransitGatewayRouteReportOptions) SetTransitGatewayID(transitGatewayID string) *DeleteTransitGatewayRouteReportOptions {
	_options.TransitGatewayID = core.StringPtr(transitGatewayID)
	return _options
}

// SetID : Allow user to set ID
func (_options *DeleteTransitGatewayRouteReportOptions) SetID(id string) *DeleteTransitGatewayRouteReportOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteTransitGatewayRouteReportOptions) SetHeaders(param map[string]string) *DeleteTransitGatewayRouteReportOptions {
	options.Headers = param
	return options
}

// GetGatewayLocationOptions : The GetGatewayLocation options.
type GetGatewayLocationOptions struct {
	// The Transit Gateway location Name.
	Name *string `json:"name" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetGatewayLocationOptions : Instantiate GetGatewayLocationOptions
func (*TransitGatewayApisV1) NewGetGatewayLocationOptions(name string) *GetGatewayLocationOptions {
	return &GetGatewayLocationOptions{
		Name: core.StringPtr(name),
	}
}

// SetName : Allow user to set Name
func (_options *GetGatewayLocationOptions) SetName(name string) *GetGatewayLocationOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetGatewayLocationOptions) SetHeaders(param map[string]string) *GetGatewayLocationOptions {
	options.Headers = param
	return options
}

// GetTransitGatewayConnectionOptions : The GetTransitGatewayConnection options.
type GetTransitGatewayConnectionOptions struct {
	// The Transit Gateway identifier.
	TransitGatewayID *string `json:"transit_gateway_id" validate:"required,ne="`

	// The connection identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetTransitGatewayConnectionOptions : Instantiate GetTransitGatewayConnectionOptions
func (*TransitGatewayApisV1) NewGetTransitGatewayConnectionOptions(transitGatewayID string, id string) *GetTransitGatewayConnectionOptions {
	return &GetTransitGatewayConnectionOptions{
		TransitGatewayID: core.StringPtr(transitGatewayID),
		ID:               core.StringPtr(id),
	}
}

// SetTransitGatewayID : Allow user to set TransitGatewayID
func (_options *GetTransitGatewayConnectionOptions) SetTransitGatewayID(transitGatewayID string) *GetTransitGatewayConnectionOptions {
	_options.TransitGatewayID = core.StringPtr(transitGatewayID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetTransitGatewayConnectionOptions) SetID(id string) *GetTransitGatewayConnectionOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetTransitGatewayConnectionOptions) SetHeaders(param map[string]string) *GetTransitGatewayConnectionOptions {
	options.Headers = param
	return options
}

// GetTransitGatewayConnectionPrefixFilterOptions : The GetTransitGatewayConnectionPrefixFilter options.
type GetTransitGatewayConnectionPrefixFilterOptions struct {
	// The Transit Gateway identifier.
	TransitGatewayID *string `json:"transit_gateway_id" validate:"required,ne="`

	// The connection identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Prefix filter identifier.
	FilterID *string `json:"filter_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetTransitGatewayConnectionPrefixFilterOptions : Instantiate GetTransitGatewayConnectionPrefixFilterOptions
func (*TransitGatewayApisV1) NewGetTransitGatewayConnectionPrefixFilterOptions(transitGatewayID string, id string, filterID string) *GetTransitGatewayConnectionPrefixFilterOptions {
	return &GetTransitGatewayConnectionPrefixFilterOptions{
		TransitGatewayID: core.StringPtr(transitGatewayID),
		ID:               core.StringPtr(id),
		FilterID:         core.StringPtr(filterID),
	}
}

// SetTransitGatewayID : Allow user to set TransitGatewayID
func (_options *GetTransitGatewayConnectionPrefixFilterOptions) SetTransitGatewayID(transitGatewayID string) *GetTransitGatewayConnectionPrefixFilterOptions {
	_options.TransitGatewayID = core.StringPtr(transitGatewayID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetTransitGatewayConnectionPrefixFilterOptions) SetID(id string) *GetTransitGatewayConnectionPrefixFilterOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetFilterID : Allow user to set FilterID
func (_options *GetTransitGatewayConnectionPrefixFilterOptions) SetFilterID(filterID string) *GetTransitGatewayConnectionPrefixFilterOptions {
	_options.FilterID = core.StringPtr(filterID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetTransitGatewayConnectionPrefixFilterOptions) SetHeaders(param map[string]string) *GetTransitGatewayConnectionPrefixFilterOptions {
	options.Headers = param
	return options
}

// GetTransitGatewayConnectionTunnelsOptions : The GetTransitGatewayConnectionTunnels options.
type GetTransitGatewayConnectionTunnelsOptions struct {
	// The Transit Gateway identifier.
	TransitGatewayID *string `json:"transit_gateway_id" validate:"required,ne="`

	// The connection identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The tunnel identifier.
	GreTunnelID *string `json:"gre_tunnel_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetTransitGatewayConnectionTunnelsOptions : Instantiate GetTransitGatewayConnectionTunnelsOptions
func (*TransitGatewayApisV1) NewGetTransitGatewayConnectionTunnelsOptions(transitGatewayID string, id string, greTunnelID string) *GetTransitGatewayConnectionTunnelsOptions {
	return &GetTransitGatewayConnectionTunnelsOptions{
		TransitGatewayID: core.StringPtr(transitGatewayID),
		ID:               core.StringPtr(id),
		GreTunnelID:      core.StringPtr(greTunnelID),
	}
}

// SetTransitGatewayID : Allow user to set TransitGatewayID
func (_options *GetTransitGatewayConnectionTunnelsOptions) SetTransitGatewayID(transitGatewayID string) *GetTransitGatewayConnectionTunnelsOptions {
	_options.TransitGatewayID = core.StringPtr(transitGatewayID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetTransitGatewayConnectionTunnelsOptions) SetID(id string) *GetTransitGatewayConnectionTunnelsOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetGreTunnelID : Allow user to set GreTunnelID
func (_options *GetTransitGatewayConnectionTunnelsOptions) SetGreTunnelID(greTunnelID string) *GetTransitGatewayConnectionTunnelsOptions {
	_options.GreTunnelID = core.StringPtr(greTunnelID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetTransitGatewayConnectionTunnelsOptions) SetHeaders(param map[string]string) *GetTransitGatewayConnectionTunnelsOptions {
	options.Headers = param
	return options
}

// GetTransitGatewayOptions : The GetTransitGateway options.
type GetTransitGatewayOptions struct {
	// The Transit Gateway identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetTransitGatewayOptions : Instantiate GetTransitGatewayOptions
func (*TransitGatewayApisV1) NewGetTransitGatewayOptions(id string) *GetTransitGatewayOptions {
	return &GetTransitGatewayOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *GetTransitGatewayOptions) SetID(id string) *GetTransitGatewayOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetTransitGatewayOptions) SetHeaders(param map[string]string) *GetTransitGatewayOptions {
	options.Headers = param
	return options
}

// GetTransitGatewayRouteReportOptions : The GetTransitGatewayRouteReport options.
type GetTransitGatewayRouteReportOptions struct {
	// The Transit Gateway identifier.
	TransitGatewayID *string `json:"transit_gateway_id" validate:"required,ne="`

	// Route report identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetTransitGatewayRouteReportOptions : Instantiate GetTransitGatewayRouteReportOptions
func (*TransitGatewayApisV1) NewGetTransitGatewayRouteReportOptions(transitGatewayID string, id string) *GetTransitGatewayRouteReportOptions {
	return &GetTransitGatewayRouteReportOptions{
		TransitGatewayID: core.StringPtr(transitGatewayID),
		ID:               core.StringPtr(id),
	}
}

// SetTransitGatewayID : Allow user to set TransitGatewayID
func (_options *GetTransitGatewayRouteReportOptions) SetTransitGatewayID(transitGatewayID string) *GetTransitGatewayRouteReportOptions {
	_options.TransitGatewayID = core.StringPtr(transitGatewayID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetTransitGatewayRouteReportOptions) SetID(id string) *GetTransitGatewayRouteReportOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetTransitGatewayRouteReportOptions) SetHeaders(param map[string]string) *GetTransitGatewayRouteReportOptions {
	options.Headers = param
	return options
}

// ListConnectionsOptions : The ListConnections options.
type ListConnectionsOptions struct {
	// The maximum number of resources to return per page.
	Limit *int64 `json:"limit,omitempty"`

	// A server supplied token determining which resource to start the page on.
	Start *string `json:"start,omitempty"`

	// Search for connections with the given network_id value.
	NetworkID *string `json:"network_id,omitempty"`

	// Search for connections with the given network_type value.
	NetworkType *string `json:"network_type,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListConnectionsOptions : Instantiate ListConnectionsOptions
func (*TransitGatewayApisV1) NewListConnectionsOptions() *ListConnectionsOptions {
	return &ListConnectionsOptions{}
}

// SetLimit : Allow user to set Limit
func (_options *ListConnectionsOptions) SetLimit(limit int64) *ListConnectionsOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetStart : Allow user to set Start
func (_options *ListConnectionsOptions) SetStart(start string) *ListConnectionsOptions {
	_options.Start = core.StringPtr(start)
	return _options
}

// SetNetworkID : Allow user to set NetworkID
func (_options *ListConnectionsOptions) SetNetworkID(networkID string) *ListConnectionsOptions {
	_options.NetworkID = core.StringPtr(networkID)
	return _options
}

// SetNetworkType : Allow user to set NetworkType
func (_options *ListConnectionsOptions) SetNetworkType(networkType string) *ListConnectionsOptions {
	_options.NetworkType = core.StringPtr(networkType)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListConnectionsOptions) SetHeaders(param map[string]string) *ListConnectionsOptions {
	options.Headers = param
	return options
}

// ListGatewayLocationsOptions : The ListGatewayLocations options.
type ListGatewayLocationsOptions struct {

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListGatewayLocationsOptions : Instantiate ListGatewayLocationsOptions
func (*TransitGatewayApisV1) NewListGatewayLocationsOptions() *ListGatewayLocationsOptions {
	return &ListGatewayLocationsOptions{}
}

// SetHeaders : Allow user to set Headers
func (options *ListGatewayLocationsOptions) SetHeaders(param map[string]string) *ListGatewayLocationsOptions {
	options.Headers = param
	return options
}

// ListTransitGatewayConnectionPrefixFiltersOptions : The ListTransitGatewayConnectionPrefixFilters options.
type ListTransitGatewayConnectionPrefixFiltersOptions struct {
	// The Transit Gateway identifier.
	TransitGatewayID *string `json:"transit_gateway_id" validate:"required,ne="`

	// The connection identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListTransitGatewayConnectionPrefixFiltersOptions : Instantiate ListTransitGatewayConnectionPrefixFiltersOptions
func (*TransitGatewayApisV1) NewListTransitGatewayConnectionPrefixFiltersOptions(transitGatewayID string, id string) *ListTransitGatewayConnectionPrefixFiltersOptions {
	return &ListTransitGatewayConnectionPrefixFiltersOptions{
		TransitGatewayID: core.StringPtr(transitGatewayID),
		ID:               core.StringPtr(id),
	}
}

// SetTransitGatewayID : Allow user to set TransitGatewayID
func (_options *ListTransitGatewayConnectionPrefixFiltersOptions) SetTransitGatewayID(transitGatewayID string) *ListTransitGatewayConnectionPrefixFiltersOptions {
	_options.TransitGatewayID = core.StringPtr(transitGatewayID)
	return _options
}

// SetID : Allow user to set ID
func (_options *ListTransitGatewayConnectionPrefixFiltersOptions) SetID(id string) *ListTransitGatewayConnectionPrefixFiltersOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListTransitGatewayConnectionPrefixFiltersOptions) SetHeaders(param map[string]string) *ListTransitGatewayConnectionPrefixFiltersOptions {
	options.Headers = param
	return options
}

// ListTransitGatewayConnectionsOptions : The ListTransitGatewayConnections options.
type ListTransitGatewayConnectionsOptions struct {
	// The Transit Gateway identifier.
	TransitGatewayID *string `json:"transit_gateway_id" validate:"required,ne="`

	// A server supplied token determining which resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The maximum number of resources to return per page.
	Limit *int64 `json:"limit,omitempty"`

	// Search for connections with the given name.
	Name *string `json:"name,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListTransitGatewayConnectionsOptions : Instantiate ListTransitGatewayConnectionsOptions
func (*TransitGatewayApisV1) NewListTransitGatewayConnectionsOptions(transitGatewayID string) *ListTransitGatewayConnectionsOptions {
	return &ListTransitGatewayConnectionsOptions{
		TransitGatewayID: core.StringPtr(transitGatewayID),
	}
}

// SetTransitGatewayID : Allow user to set TransitGatewayID
func (_options *ListTransitGatewayConnectionsOptions) SetTransitGatewayID(transitGatewayID string) *ListTransitGatewayConnectionsOptions {
	_options.TransitGatewayID = core.StringPtr(transitGatewayID)
	return _options
}

// SetStart : Allow user to set Start
func (_options *ListTransitGatewayConnectionsOptions) SetStart(start string) *ListTransitGatewayConnectionsOptions {
	_options.Start = core.StringPtr(start)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListTransitGatewayConnectionsOptions) SetLimit(limit int64) *ListTransitGatewayConnectionsOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetName : Allow user to set Name
func (_options *ListTransitGatewayConnectionsOptions) SetName(name string) *ListTransitGatewayConnectionsOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListTransitGatewayConnectionsOptions) SetHeaders(param map[string]string) *ListTransitGatewayConnectionsOptions {
	options.Headers = param
	return options
}

// ListTransitGatewayGreTunnelOptions : The ListTransitGatewayGreTunnel options.
type ListTransitGatewayGreTunnelOptions struct {
	// The Transit Gateway identifier.
	TransitGatewayID *string `json:"transit_gateway_id" validate:"required,ne="`

	// The connection identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListTransitGatewayGreTunnelOptions : Instantiate ListTransitGatewayGreTunnelOptions
func (*TransitGatewayApisV1) NewListTransitGatewayGreTunnelOptions(transitGatewayID string, id string) *ListTransitGatewayGreTunnelOptions {
	return &ListTransitGatewayGreTunnelOptions{
		TransitGatewayID: core.StringPtr(transitGatewayID),
		ID:               core.StringPtr(id),
	}
}

// SetTransitGatewayID : Allow user to set TransitGatewayID
func (_options *ListTransitGatewayGreTunnelOptions) SetTransitGatewayID(transitGatewayID string) *ListTransitGatewayGreTunnelOptions {
	_options.TransitGatewayID = core.StringPtr(transitGatewayID)
	return _options
}

// SetID : Allow user to set ID
func (_options *ListTransitGatewayGreTunnelOptions) SetID(id string) *ListTransitGatewayGreTunnelOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListTransitGatewayGreTunnelOptions) SetHeaders(param map[string]string) *ListTransitGatewayGreTunnelOptions {
	options.Headers = param
	return options
}

// ListTransitGatewayRouteReportsOptions : The ListTransitGatewayRouteReports options.
type ListTransitGatewayRouteReportsOptions struct {
	// The Transit Gateway identifier.
	TransitGatewayID *string `json:"transit_gateway_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListTransitGatewayRouteReportsOptions : Instantiate ListTransitGatewayRouteReportsOptions
func (*TransitGatewayApisV1) NewListTransitGatewayRouteReportsOptions(transitGatewayID string) *ListTransitGatewayRouteReportsOptions {
	return &ListTransitGatewayRouteReportsOptions{
		TransitGatewayID: core.StringPtr(transitGatewayID),
	}
}

// SetTransitGatewayID : Allow user to set TransitGatewayID
func (_options *ListTransitGatewayRouteReportsOptions) SetTransitGatewayID(transitGatewayID string) *ListTransitGatewayRouteReportsOptions {
	_options.TransitGatewayID = core.StringPtr(transitGatewayID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListTransitGatewayRouteReportsOptions) SetHeaders(param map[string]string) *ListTransitGatewayRouteReportsOptions {
	options.Headers = param
	return options
}

// ListTransitGatewaysOptions : The ListTransitGateways options.
type ListTransitGatewaysOptions struct {
	// The maximum number of resources to return per page.
	Limit *int64 `json:"limit,omitempty"`

	// A server supplied token determining which resource to start the page on.
	Start *string `json:"start,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListTransitGatewaysOptions : Instantiate ListTransitGatewaysOptions
func (*TransitGatewayApisV1) NewListTransitGatewaysOptions() *ListTransitGatewaysOptions {
	return &ListTransitGatewaysOptions{}
}

// SetLimit : Allow user to set Limit
func (_options *ListTransitGatewaysOptions) SetLimit(limit int64) *ListTransitGatewaysOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetStart : Allow user to set Start
func (_options *ListTransitGatewaysOptions) SetStart(start string) *ListTransitGatewaysOptions {
	_options.Start = core.StringPtr(start)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListTransitGatewaysOptions) SetHeaders(param map[string]string) *ListTransitGatewaysOptions {
	options.Headers = param
	return options
}

// PaginationFirstConnection : A reference to the first page of resources.
type PaginationFirstConnection struct {
	// url.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalPaginationFirstConnection unmarshals an instance of PaginationFirstConnection from the specified map of raw messages.
func UnmarshalPaginationFirstConnection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PaginationFirstConnection)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PaginationFirstTG : A reference to the first page of resources.
type PaginationFirstTG struct {
	// url.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalPaginationFirstTG unmarshals an instance of PaginationFirstTG from the specified map of raw messages.
func UnmarshalPaginationFirstTG(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PaginationFirstTG)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PaginationFirstTGWConnection : A reference to the first page of resources. This will be returned when number of connections in response are greater
// than max page limit.
type PaginationFirstTGWConnection struct {
	// url.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalPaginationFirstTGWConnection unmarshals an instance of PaginationFirstTGWConnection from the specified map of raw messages.
func UnmarshalPaginationFirstTGWConnection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PaginationFirstTGWConnection)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PaginationNextConnection : A reference to the next page of resources; this reference is included for all pages except the last page.
type PaginationNextConnection struct {
	// url.
	Href *string `json:"href" validate:"required"`

	// server generated start token for next page of resources.
	Start *string `json:"start" validate:"required"`
}

// UnmarshalPaginationNextConnection unmarshals an instance of PaginationNextConnection from the specified map of raw messages.
func UnmarshalPaginationNextConnection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PaginationNextConnection)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "start", &obj.Start)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PaginationNextTG : A reference to the next page of resources; this reference is included for all pages except the last page.
type PaginationNextTG struct {
	// url.
	Href *string `json:"href" validate:"required"`

	// server generated start token for next page of resources.
	Start *string `json:"start" validate:"required"`
}

// UnmarshalPaginationNextTG unmarshals an instance of PaginationNextTG from the specified map of raw messages.
func UnmarshalPaginationNextTG(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PaginationNextTG)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "start", &obj.Start)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PaginationNextTGWConnection : A reference to the next page of resources; this reference is included for all pages except the last page.
type PaginationNextTGWConnection struct {
	// url.
	Href *string `json:"href" validate:"required"`

	// server generated start token for next page of resources.
	Start *string `json:"start" validate:"required"`
}

// UnmarshalPaginationNextTGWConnection unmarshals an instance of PaginationNextTGWConnection from the specified map of raw messages.
func UnmarshalPaginationNextTGWConnection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PaginationNextTGWConnection)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "start", &obj.Start)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PrefixFilterCollection : prefix filters.
type PrefixFilterCollection struct {
	// Array of prefix filters.
	PrefixFilters []PrefixFilterCust `json:"prefix_filters" validate:"required"`
}

// UnmarshalPrefixFilterCollection unmarshals an instance of PrefixFilterCollection from the specified map of raw messages.
func UnmarshalPrefixFilterCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PrefixFilterCollection)
	err = core.UnmarshalModel(m, "prefix_filters", &obj.PrefixFilters, UnmarshalPrefixFilterCust)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PrefixFilterCust : prefix filter.
type PrefixFilterCust struct {
	// Whether or not this prefix filter should allow or deny prefixes matching this filter's prefix definition.
	Action *string `json:"action" validate:"required"`

	// A reference to the prefix filter that will be the next filter applied to the Transit Gateway connection.
	//
	// If this field is blank, this prefix filter will be the last rule applied before the connection's default rule.
	//
	// When a prefix filter is created with the same before field as an existing prefix filter, the existing filter will be
	// applied before the new filter, and the existing filter's before field will be updated accordingly.
	Before *string `json:"before,omitempty"`

	// The date and time that this prefix filter was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// Defines the minimum matched prefix precision. If this field is non-zero then the filter will match all routes within
	// the `prefix` that have a prefix length greater or equal to this value.
	//
	// This value can be zero, or a non-negative number greater than or equal to the prefix length of the filter's prefix
	// or less then or equal to 32. If this value is set to zero, the filter will not use the `ge` route matching behavior.
	// If the `le` value is non-zero the the `ge` value must between the prefix length and the
	// `le` value, inclusive.
	Ge *int64 `json:"ge,omitempty"`

	// Prefix Filter identifier.
	ID *string `json:"id" validate:"required"`

	// Defines the maximum matched prefix precision. If this field is non-zero then the filter will match all routes within
	// the `prefix` that have a prefix length less than or equal to this value.
	//
	// This value can be zero, or a non-negative number greater than or equal to the prefix length of the filter's prefix
	// or less then or equal to 32. If this value is set to zero, the filter will not use the `le` route matching behavior.
	// If the `ge` value is non-zero the the `le` value must between the `ge` value and 32, inclusive.
	Le *int64 `json:"le,omitempty"`

	// The IPv4 Prefix to be matched by this filter. If both the `le` and `ge` are zero, then this filter will only apply
	// to routes that exactly match this prefix, while a non-zero value for either `le` or `ge`, this filter can apply to
	// multiple routes with different prefix lengths, but will still only apply to prefixes contained in the address space
	// defined by `prefix`.
	Prefix *string `json:"prefix" validate:"required"`

	// The date and time that this prefix filter was last updated.
	UpdatedAt *strfmt.DateTime `json:"updated_at,omitempty"`
}

// Constants associated with the PrefixFilterCust.Action property.
// Whether or not this prefix filter should allow or deny prefixes matching this filter's prefix definition.
const (
	PrefixFilterCust_Action_Deny   = "deny"
	PrefixFilterCust_Action_Permit = "permit"
)

// UnmarshalPrefixFilterCust unmarshals an instance of PrefixFilterCust from the specified map of raw messages.
func UnmarshalPrefixFilterCust(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PrefixFilterCust)
	err = core.UnmarshalPrimitive(m, "action", &obj.Action)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "before", &obj.Before)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ge", &obj.Ge)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "le", &obj.Le)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "prefix", &obj.Prefix)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PrefixFilterPut : A prefix filter update template.
type PrefixFilterPut struct {
	// Whether or not this prefix filter should allow or deny prefixes matching this filter's prefix definition.
	Action *string `json:"action" validate:"required"`

	// Defines the minimum matched prefix precision. If this field is non-zero then the filter will match all routes within
	// the `prefix` that have a prefix length greater or equal to this value.
	//
	// This value can be zero, or a non-negative number greater than or equal to the prefix length of the filter's prefix
	// or less then or equal to 32. If this value is set to zero, the filter will not use the `ge` route matching behavior.
	// If the `le` value is non-zero the the `ge` value must between the prefix length and the
	// `le` value, inclusive.
	Ge *int64 `json:"ge,omitempty"`

	// Defines the maximum matched prefix precision. If this field is non-zero then the filter will match all routes within
	// the `prefix` that have a prefix length less than or equal to this value.
	//
	// This value can be zero, or a non-negative number greater than or equal to the prefix length of the filter's prefix
	// or less then or equal to 32. If this value is set to zero, the filter will not use the `le` route matching behavior.
	// If the `ge` value is non-zero the the `le` value must between the `ge` value and 32, inclusive.
	Le *int64 `json:"le,omitempty"`

	// The IPv4 Prefix to be matched by this filter. If both the `le` and `ge` are zero, then this filter will only apply
	// to routes that exactly match this prefix, while a non-zero value for either `le` or `ge`, this filter can apply to
	// multiple routes with different prefix lengths, but will still only apply to prefixes contained in the address space
	// defined by `prefix`.
	Prefix *string `json:"prefix" validate:"required"`
}

// Constants associated with the PrefixFilterPut.Action property.
// Whether or not this prefix filter should allow or deny prefixes matching this filter's prefix definition.
const (
	PrefixFilterPut_Action_Deny   = "deny"
	PrefixFilterPut_Action_Permit = "permit"
)

// NewPrefixFilterPut : Instantiate PrefixFilterPut (Generic Model Constructor)
func (*TransitGatewayApisV1) NewPrefixFilterPut(action string, prefix string) (_model *PrefixFilterPut, err error) {
	_model = &PrefixFilterPut{
		Action: core.StringPtr(action),
		Prefix: core.StringPtr(prefix),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

// UnmarshalPrefixFilterPut unmarshals an instance of PrefixFilterPut from the specified map of raw messages.
func UnmarshalPrefixFilterPut(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PrefixFilterPut)
	err = core.UnmarshalPrimitive(m, "action", &obj.Action)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ge", &obj.Ge)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "le", &obj.Le)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "prefix", &obj.Prefix)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ReplaceTransitGatewayConnectionPrefixFilterOptions : The ReplaceTransitGatewayConnectionPrefixFilter options.
type ReplaceTransitGatewayConnectionPrefixFilterOptions struct {
	// The Transit Gateway identifier.
	TransitGatewayID *string `json:"transit_gateway_id" validate:"required,ne="`

	// The connection identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Array of prefix filters.
	PrefixFilters []PrefixFilterPut `json:"prefix_filters" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewReplaceTransitGatewayConnectionPrefixFilterOptions : Instantiate ReplaceTransitGatewayConnectionPrefixFilterOptions
func (*TransitGatewayApisV1) NewReplaceTransitGatewayConnectionPrefixFilterOptions(transitGatewayID string, id string, prefixFilters []PrefixFilterPut) *ReplaceTransitGatewayConnectionPrefixFilterOptions {
	return &ReplaceTransitGatewayConnectionPrefixFilterOptions{
		TransitGatewayID: core.StringPtr(transitGatewayID),
		ID:               core.StringPtr(id),
		PrefixFilters:    prefixFilters,
	}
}

// SetTransitGatewayID : Allow user to set TransitGatewayID
func (_options *ReplaceTransitGatewayConnectionPrefixFilterOptions) SetTransitGatewayID(transitGatewayID string) *ReplaceTransitGatewayConnectionPrefixFilterOptions {
	_options.TransitGatewayID = core.StringPtr(transitGatewayID)
	return _options
}

// SetID : Allow user to set ID
func (_options *ReplaceTransitGatewayConnectionPrefixFilterOptions) SetID(id string) *ReplaceTransitGatewayConnectionPrefixFilterOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetPrefixFilters : Allow user to set PrefixFilters
func (_options *ReplaceTransitGatewayConnectionPrefixFilterOptions) SetPrefixFilters(prefixFilters []PrefixFilterPut) *ReplaceTransitGatewayConnectionPrefixFilterOptions {
	_options.PrefixFilters = prefixFilters
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ReplaceTransitGatewayConnectionPrefixFilterOptions) SetHeaders(param map[string]string) *ReplaceTransitGatewayConnectionPrefixFilterOptions {
	options.Headers = param
	return options
}

// ResourceGroupIdentity : The resource group to use. If unspecified, the account's [default resource
// group](https://console.bluemix.net/apidocs/resource-manager#introduction) is used.
type ResourceGroupIdentity struct {
	// The unique identifier for this resource group.
	ID *string `json:"id" validate:"required"`
}

// NewResourceGroupIdentity : Instantiate ResourceGroupIdentity (Generic Model Constructor)
func (*TransitGatewayApisV1) NewResourceGroupIdentity(id string) (_model *ResourceGroupIdentity, err error) {
	_model = &ResourceGroupIdentity{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

// UnmarshalResourceGroupIdentity unmarshals an instance of ResourceGroupIdentity from the specified map of raw messages.
func UnmarshalResourceGroupIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ResourceGroupIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ResourceGroupReference : The resource group to use. If unspecified, the account's [default resource
// group](https://console.bluemix.net/apidocs/resource-manager#introduction) is used.
type ResourceGroupReference struct {
	// The URL for this resource group.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this resource group.
	ID *string `json:"id" validate:"required"`
}

// UnmarshalResourceGroupReference unmarshals an instance of ResourceGroupReference from the specified map of raw messages.
func UnmarshalResourceGroupReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ResourceGroupReference)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RouteReport : route report.
type RouteReport struct {
	// Array of connections with their routes.
	Connections []RouteReportConnection `json:"connections" validate:"required"`

	// Date and time route report was requested.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// Report identifier.
	ID *string `json:"id" validate:"required"`

	// Array of overlapping routes.
	OverlappingRoutes []RouteReportOverlappingRouteGroup `json:"overlapping_routes" validate:"required"`

	// Route report status. The list of enumerated values for this property may expand in the future. Code and processes
	// using this field must tolerate unexpected values.
	Status *string `json:"status" validate:"required"`

	// Date and time route report was last modified.
	UpdatedAt *strfmt.DateTime `json:"updated_at,omitempty"`
}

// Constants associated with the RouteReport.Status property.
// Route report status. The list of enumerated values for this property may expand in the future. Code and processes
// using this field must tolerate unexpected values.
const (
	RouteReport_Status_Complete = "complete"
	RouteReport_Status_Failed   = "failed"
	RouteReport_Status_Pending  = "pending"
)

// UnmarshalRouteReport unmarshals an instance of RouteReport from the specified map of raw messages.
func UnmarshalRouteReport(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RouteReport)
	err = core.UnmarshalModel(m, "connections", &obj.Connections, UnmarshalRouteReportConnection)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "overlapping_routes", &obj.OverlappingRoutes, UnmarshalRouteReportOverlappingRouteGroup)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RouteReportCollection : route reports.
type RouteReportCollection struct {
	// Array of route reports.
	RouteReports []RouteReport `json:"route_reports" validate:"required"`
}

// UnmarshalRouteReportCollection unmarshals an instance of RouteReportCollection from the specified map of raw messages.
func UnmarshalRouteReportCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RouteReportCollection)
	err = core.UnmarshalModel(m, "route_reports", &obj.RouteReports, UnmarshalRouteReport)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RouteReportConnection : route report connection.
type RouteReportConnection struct {
	// Array of connection's bgps.
	Bgps []RouteReportConnectionBgp `json:"bgps,omitempty"`

	// connection ID.
	ID *string `json:"id,omitempty"`

	// connection name.
	Name *string `json:"name,omitempty"`

	// Array of connection's routes.
	Routes []RouteReportConnectionRoute `json:"routes,omitempty"`

	// connection type.
	Type *string `json:"type,omitempty"`
}

// UnmarshalRouteReportConnection unmarshals an instance of RouteReportConnection from the specified map of raw messages.
func UnmarshalRouteReportConnection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RouteReportConnection)
	err = core.UnmarshalModel(m, "bgps", &obj.Bgps, UnmarshalRouteReportConnectionBgp)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "routes", &obj.Routes, UnmarshalRouteReportConnectionRoute)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RouteReportConnectionBgp : connection bgp details.
type RouteReportConnectionBgp struct {
	// AS path.
	AsPath *string `json:"as_path,omitempty"`

	// Indicates whether current route is used or not.
	IsUsed *bool `json:"is_used,omitempty"`

	// local preference.
	LocalPreference *string `json:"local_preference,omitempty"`

	// prefix.
	Prefix *string `json:"prefix,omitempty"`
}

// UnmarshalRouteReportConnectionBgp unmarshals an instance of RouteReportConnectionBgp from the specified map of raw messages.
func UnmarshalRouteReportConnectionBgp(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RouteReportConnectionBgp)
	err = core.UnmarshalPrimitive(m, "as_path", &obj.AsPath)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "is_used", &obj.IsUsed)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "local_preference", &obj.LocalPreference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "prefix", &obj.Prefix)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RouteReportConnectionRoute : connection used route.
type RouteReportConnectionRoute struct {
	// prefix.
	Prefix *string `json:"prefix,omitempty"`
}

// UnmarshalRouteReportConnectionRoute unmarshals an instance of RouteReportConnectionRoute from the specified map of raw messages.
func UnmarshalRouteReportConnectionRoute(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RouteReportConnectionRoute)
	err = core.UnmarshalPrimitive(m, "prefix", &obj.Prefix)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RouteReportOverlappingRoute : overlapping route details.
type RouteReportOverlappingRoute struct {
	// connection ID.
	ConnectionID *string `json:"connection_id,omitempty"`

	// overlapping prefix.
	Prefix *string `json:"prefix,omitempty"`
}

// UnmarshalRouteReportOverlappingRoute unmarshals an instance of RouteReportOverlappingRoute from the specified map of raw messages.
func UnmarshalRouteReportOverlappingRoute(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RouteReportOverlappingRoute)
	err = core.UnmarshalPrimitive(m, "connection_id", &obj.ConnectionID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "prefix", &obj.Prefix)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RouteReportOverlappingRouteGroup : Collection of overlapping route.
type RouteReportOverlappingRouteGroup struct {
	// Array of overlapping connection/prefix pairs.
	Routes []RouteReportOverlappingRoute `json:"routes,omitempty"`
}

// UnmarshalRouteReportOverlappingRouteGroup unmarshals an instance of RouteReportOverlappingRouteGroup from the specified map of raw messages.
func UnmarshalRouteReportOverlappingRouteGroup(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RouteReportOverlappingRouteGroup)
	err = core.UnmarshalModel(m, "routes", &obj.Routes, UnmarshalRouteReportOverlappingRoute)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TSCollection : A list of Transit Gateway locations.
type TSCollection struct {
	// Collection of Transit Gateway locations.
	Locations []TSLocationBasic `json:"locations" validate:"required"`
}

// UnmarshalTSCollection unmarshals an instance of TSCollection from the specified map of raw messages.
func UnmarshalTSCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TSCollection)
	err = core.UnmarshalModel(m, "locations", &obj.Locations, UnmarshalTSLocationBasic)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TSLocalLocation : Details of a local connection location.
type TSLocalLocation struct {
	// A descriptive display name for the location.
	DisplayName *string `json:"display_name" validate:"required"`

	// The name of the location.
	Name *string `json:"name" validate:"required"`

	// Array of supported connection types.
	SupportedConnectionTypes []string `json:"supported_connection_types,omitempty"`

	// The type of the location, determining is this a multi-zone region, a single data center, or a point of presence. The
	// list of enumerated values for this property may expand in the future. Code and processes using this field must
	// tolerate unexpected values.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the TSLocalLocation.Type property.
// The type of the location, determining is this a multi-zone region, a single data center, or a point of presence. The
// list of enumerated values for this property may expand in the future. Code and processes using this field must
// tolerate unexpected values.
const (
	TSLocalLocation_Type_Dc     = "dc"
	TSLocalLocation_Type_Region = "region"
)

// UnmarshalTSLocalLocation unmarshals an instance of TSLocalLocation from the specified map of raw messages.
func UnmarshalTSLocalLocation(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TSLocalLocation)
	err = core.UnmarshalPrimitive(m, "display_name", &obj.DisplayName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "supported_connection_types", &obj.SupportedConnectionTypes)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TSLocation : Details of a Transit Gateway location.
type TSLocation struct {
	// The geographical location of this location, used for billing purposes.
	BillingLocation *string `json:"billing_location" validate:"required"`

	// Name of the Location.
	Name *string `json:"name" validate:"required"`

	// The type of the location, determining is this a multi-zone region, a single data center, or a point of presence.
	Type *string `json:"type" validate:"required"`

	// The set of network locations that are considered local for this Transit Gateway location.
	LocalConnectionLocations []TSLocalLocation `json:"local_connection_locations" validate:"required"`

	// List of valid zones for GRE tunnels.
	Zones []ZoneReference `json:"zones" validate:"required"`
}

// UnmarshalTSLocation unmarshals an instance of TSLocation from the specified map of raw messages.
func UnmarshalTSLocation(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TSLocation)
	err = core.UnmarshalPrimitive(m, "billing_location", &obj.BillingLocation)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "local_connection_locations", &obj.LocalConnectionLocations, UnmarshalTSLocalLocation)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zones", &obj.Zones, UnmarshalZoneReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TSLocationBasic : Details of a Transit Gateway location.
type TSLocationBasic struct {
	// The geographical location of this location, used for billing purposes.
	BillingLocation *string `json:"billing_location" validate:"required"`

	// Name of the Location.
	Name *string `json:"name" validate:"required"`

	// The type of the location, determining is this a multi-zone region, a single data center, or a point of presence.
	Type *string `json:"type" validate:"required"`
}

// UnmarshalTSLocationBasic unmarshals an instance of TSLocationBasic from the specified map of raw messages.
func UnmarshalTSLocationBasic(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TSLocationBasic)
	err = core.UnmarshalPrimitive(m, "billing_location", &obj.BillingLocation)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TransitConnection : Connection included in transit gateway.
type TransitConnection struct {
	// The type of network the GRE tunnel is targeting.
	BaseNetworkType *string `json:"base_network_type,omitempty"`

	// The user-defined name for this transit gateway connection.
	Name *string `json:"name" validate:"required"`

	// The ID of the network being connected via this connection. This field is required for some types, such as `vpc`,
	// `power_virtual_server`, `directlink`, `vpn_gateway` and `redundant_gre`. For network types `vpc`, `redundant_gre`,
	// `power_virtual_server` and `directlink` this is the CRN of the VPC  / PowerVS / VDC / Direct Link gateway
	// respectively.
	NetworkID *string `json:"network_id,omitempty"`

	// Defines what type of network is connected via this connection. The list of enumerated values for this property may
	// expand in the future. Code and processes using this field must tolerate unexpected values.
	NetworkType *string `json:"network_type" validate:"required"`

	// The unique identifier for this Transit Gateway connection.
	ID *string `json:"id" validate:"required"`

	// network_type `gre_tunnel` connections use `base_connection_id` to specify the ID of a network_type `classic`
	// connection the tunnel is configured over. The specified connection must reside in the same transit gateway and be in
	// an active state. The `classic` connection cannot be deleted until any `gre_tunnel` connections using it are deleted.
	// This field only applies to and is required for network type `gre_tunnel` connections.
	// Deprecated: this field is deprecated and may be removed in a future release.
	BaseConnectionID *string `json:"base_connection_id,omitempty"`

	// The date and time that this connection was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// Local network BGP ASN.  This field only applies to network type `gre_tunnel` and `unbound_gre_tunnel` connections.
	LocalBgpAsn *int64 `json:"local_bgp_asn,omitempty"`

	// Local gateway IP address.  This field only applies to network type `gre_tunnel` and `unbound_gre_tunnel`
	// connections.
	LocalGatewayIp *string `json:"local_gateway_ip,omitempty"`

	// Local tunnel IP address.  This field only applies to network type `gre_tunnel` and `unbound_gre_tunnel` connections.
	LocalTunnelIp *string `json:"local_tunnel_ip,omitempty"`

	// GRE tunnel MTU.  This field only applies to network type `gre_tunnel` and `unbound_gre_tunnel` connections.
	Mtu *int64 `json:"mtu,omitempty"`

	// The ID of the account which owns the connected network. Generally only used if the network is in a different IBM
	// Cloud account than the gateway.
	NetworkAccountID *string `json:"network_account_id,omitempty"`

	// Array of prefix route filters for a transit gateway connection. This is order dependent with those first in the
	// array being applied first, and those at the end of the array is applied last, or just before the default.
	//
	// This field does not apply to the `redundant_gre` network types.
	PrefixFilters []TransitGatewayConnectionPrefixFilterReference `json:"prefix_filters,omitempty"`

	// Default setting of permit or deny which applies to any routes that don't match a specified filter.
	//
	// This field does not apply to the `redundant_gre` network types.
	PrefixFiltersDefault *string `json:"prefix_filters_default,omitempty"`

	// Remote network BGP ASN.  This field only applies to network type `gre_tunnel` and `unbound_gre_tunnel` connections.
	RemoteBgpAsn *int64 `json:"remote_bgp_asn,omitempty"`

	// Remote gateway IP address.  This field only applies to network type `gre_tunnel` and `unbound_gre_tunnel`
	// connections.
	RemoteGatewayIp *string `json:"remote_gateway_ip,omitempty"`

	// Remote tunnel IP address.  This field only applies to network type `gre_tunnel` and `unbound_gre_tunnel`
	// connections.
	RemoteTunnelIp *string `json:"remote_tunnel_ip,omitempty"`

	// Only visible for cross account connections, this field represents the status of a connection request between IBM
	// Cloud accounts. The list of enumerated values for this property may expand in the future. Code and processes using
	// this field must tolerate unexpected values.
	RequestStatus *string `json:"request_status" validate:"required"`

	// Connection's current configuration state. The list of enumerated values for this property may expand in the future.
	// Code and processes using this field must tolerate unexpected values.
	Status *string `json:"status" validate:"required"`

	// Transit gateway reference.
	TransitGateway *TransitGatewayReference `json:"transit_gateway" validate:"required"`

	// Collection of all tunnels for `redundant_gre` and `vpn_gateway` connections.
	Tunnels []TransitGatewayTunnel `json:"tunnels,omitempty"`

	// The date and time that this connection was last updated.
	UpdatedAt *strfmt.DateTime `json:"updated_at" validate:"required"`

	// Availability zone reference.
	Zone *ZoneReference `json:"zone,omitempty"`
}

// Constants associated with the TransitConnection.BaseNetworkType property.
// The type of network the GRE tunnel is targeting.
const (
	TransitConnection_BaseNetworkType_Classic = "classic"
	TransitConnection_BaseNetworkType_Vpc     = "vpc"
)

// Constants associated with the TransitConnection.NetworkType property.
// Defines what type of network is connected via this connection. The list of enumerated values for this property may
// expand in the future. Code and processes using this field must tolerate unexpected values.
const (
	TransitConnection_NetworkType_Classic            = "classic"
	TransitConnection_NetworkType_Directlink         = "directlink"
	TransitConnection_NetworkType_GreTunnel          = "gre_tunnel"
	TransitConnection_NetworkType_PowerVirtualServer = "power_virtual_server"
	TransitConnection_NetworkType_RedundantGre       = "redundant_gre"
	TransitConnection_NetworkType_UnboundGreTunnel   = "unbound_gre_tunnel"
	TransitConnection_NetworkType_Vpc                = "vpc"
	TransitConnection_NetworkType_VpnGateway         = "vpn_gateway"
)

// Constants associated with the TransitConnection.PrefixFiltersDefault property.
// Default setting of permit or deny which applies to any routes that don't match a specified filter.
//
// This field does not apply to the `redundant_gre` network types.
const (
	TransitConnection_PrefixFiltersDefault_Deny   = "deny"
	TransitConnection_PrefixFiltersDefault_Permit = "permit"
)

// Constants associated with the TransitConnection.RequestStatus property.
// Only visible for cross account connections, this field represents the status of a connection request between IBM
// Cloud accounts. The list of enumerated values for this property may expand in the future. Code and processes using
// this field must tolerate unexpected values.
const (
	TransitConnection_RequestStatus_Approved = "approved"
	TransitConnection_RequestStatus_Detached = "detached"
	TransitConnection_RequestStatus_Expired  = "expired"
	TransitConnection_RequestStatus_Pending  = "pending"
	TransitConnection_RequestStatus_Rejected = "rejected"
)

// Constants associated with the TransitConnection.Status property.
// Connection's current configuration state. The list of enumerated values for this property may expand in the future.
// Code and processes using this field must tolerate unexpected values.
const (
	TransitConnection_Status_Attached       = "attached"
	TransitConnection_Status_Deleting       = "deleting"
	TransitConnection_Status_Detached       = "detached"
	TransitConnection_Status_Detaching      = "detaching"
	TransitConnection_Status_Failed         = "failed"
	TransitConnection_Status_NetworkPending = "network_pending"
	TransitConnection_Status_Pending        = "pending"
	TransitConnection_Status_Suspended      = "suspended"
	TransitConnection_Status_Suspending     = "suspending"
)

// UnmarshalTransitConnection unmarshals an instance of TransitConnection from the specified map of raw messages.
func UnmarshalTransitConnection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TransitConnection)
	err = core.UnmarshalPrimitive(m, "base_network_type", &obj.BaseNetworkType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "network_id", &obj.NetworkID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "network_type", &obj.NetworkType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "base_connection_id", &obj.BaseConnectionID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "local_bgp_asn", &obj.LocalBgpAsn)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "local_gateway_ip", &obj.LocalGatewayIp)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "local_tunnel_ip", &obj.LocalTunnelIp)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "mtu", &obj.Mtu)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "network_account_id", &obj.NetworkAccountID)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "prefix_filters", &obj.PrefixFilters, UnmarshalTransitGatewayConnectionPrefixFilterReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "prefix_filters_default", &obj.PrefixFiltersDefault)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "remote_bgp_asn", &obj.RemoteBgpAsn)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "remote_gateway_ip", &obj.RemoteGatewayIp)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "remote_tunnel_ip", &obj.RemoteTunnelIp)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "request_status", &obj.RequestStatus)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "transit_gateway", &obj.TransitGateway, UnmarshalTransitGatewayReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "tunnels", &obj.Tunnels, UnmarshalTransitGatewayTunnel)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TransitConnectionCollection : Transit gateway connections.
type TransitConnectionCollection struct {
	// Array of transit gateway connections.
	Connections []TransitConnection `json:"connections" validate:"required"`

	// A reference to the first page of resources.
	First *PaginationFirstConnection `json:"first" validate:"required"`

	// The maximum number of connections returned on one request.
	Limit *int64 `json:"limit" validate:"required"`

	// A reference to the next page of resources; this reference is included for all pages except the last page.
	Next *PaginationNextConnection `json:"next,omitempty"`
}

// UnmarshalTransitConnectionCollection unmarshals an instance of TransitConnectionCollection from the specified map of raw messages.
func UnmarshalTransitConnectionCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TransitConnectionCollection)
	err = core.UnmarshalModel(m, "connections", &obj.Connections, UnmarshalTransitConnection)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalPaginationFirstConnection)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalPaginationNextConnection)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *TransitConnectionCollection) GetNextStart() (*string, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	return resp.Next.Start, nil
}

// TransitGateway : Details of a Transit Gateway.
type TransitGateway struct {
	// The number of connections associated with this Transit Gateway.
	ConnectionCount *int64 `json:"connection_count,omitempty"`

	// Indicates if this Transit Gateway has a connection that needs attention (Such as cross account approval).
	ConnectionNeedsAttention *bool `json:"connection_needs_attention,omitempty"`

	// The date and time that this gateway was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// Cloud Resource Name of a transit gateway.
	Crn *string `json:"crn,omitempty"`

	// Allow global routing for a Transit Gateway.
	Global *bool `json:"global" validate:"required"`

	// Allow GRE Enhanced Route Propagation on this gateway.
	GreEnhancedRoutePropagation *bool `json:"gre_enhanced_route_propagation,omitempty"`

	// A unique identifier for this transit gateway.
	ID *string `json:"id" validate:"required"`

	// Location of Transit Gateway Services.
	Location *string `json:"location" validate:"required"`

	// A human readable name for the transit gateway.
	Name *string `json:"name" validate:"required"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://console.bluemix.net/apidocs/resource-manager#introduction) is used.
	ResourceGroup *ResourceGroupReference `json:"resource_group,omitempty"`

	// The status of the Transit Gateway. The list of enumerated values for this property may expand in the future. Code
	// and processes using this field must tolerate unexpected values.
	Status *string `json:"status" validate:"required"`

	// The date and time that this gateway was last updated.
	UpdatedAt *strfmt.DateTime `json:"updated_at,omitempty"`
}

// Constants associated with the TransitGateway.Status property.
// The status of the Transit Gateway. The list of enumerated values for this property may expand in the future. Code and
// processes using this field must tolerate unexpected values.
const (
	TransitGateway_Status_Available  = "available"
	TransitGateway_Status_Deleting   = "deleting"
	TransitGateway_Status_Failed     = "failed"
	TransitGateway_Status_Pending    = "pending"
	TransitGateway_Status_Suspended  = "suspended"
	TransitGateway_Status_Suspending = "suspending"
)

// UnmarshalTransitGateway unmarshals an instance of TransitGateway from the specified map of raw messages.
func UnmarshalTransitGateway(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TransitGateway)
	err = core.UnmarshalPrimitive(m, "connection_count", &obj.ConnectionCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "connection_needs_attention", &obj.ConnectionNeedsAttention)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.Crn)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "global", &obj.Global)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "gre_enhanced_route_propagation", &obj.GreEnhancedRoutePropagation)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "location", &obj.Location)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TransitGatewayCollection : A list of Transit Gateways.
type TransitGatewayCollection struct {
	// A reference to the first page of resources.
	First *PaginationFirstTG `json:"first" validate:"required"`

	// The maximum number of gateways returned on one request.
	Limit *int64 `json:"limit" validate:"required"`

	// A reference to the next page of resources; this reference is included for all pages except the last page.
	Next *PaginationNextTG `json:"next,omitempty"`

	// Collection of Transit Services gateways.
	TransitGateways []TransitGateway `json:"transit_gateways" validate:"required"`
}

// UnmarshalTransitGatewayCollection unmarshals an instance of TransitGatewayCollection from the specified map of raw messages.
func UnmarshalTransitGatewayCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TransitGatewayCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalPaginationFirstTG)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalPaginationNextTG)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "transit_gateways", &obj.TransitGateways, UnmarshalTransitGateway)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *TransitGatewayCollection) GetNextStart() (*string, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	return resp.Next.Start, nil
}

// TransitGatewayConnectionCollection : A set of Transit Gateway network connections.
type TransitGatewayConnectionCollection struct {
	// Array of transit gateways network Connections.
	Connections []TransitGatewayConnectionCust `json:"connections" validate:"required"`

	// A reference to the first page of resources.
	// This will be returned when number of connections in response are greater than max page limit.
	First *PaginationFirstTGWConnection `json:"first" validate:"required"`

	// The maximum number of connections returned on one request. This will be returned when number of connections in
	// response are greater than max page limit.
	Limit *int64 `json:"limit" validate:"required"`

	// A reference to the next page of resources; this reference is included for all pages except the last page.
	Next *PaginationNextTGWConnection `json:"next,omitempty"`

	// total number of resources across all pages (considering the supplied query parameter filters).
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalTransitGatewayConnectionCollection unmarshals an instance of TransitGatewayConnectionCollection from the specified map of raw messages.
func UnmarshalTransitGatewayConnectionCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TransitGatewayConnectionCollection)
	err = core.UnmarshalModel(m, "connections", &obj.Connections, UnmarshalTransitGatewayConnectionCust)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalPaginationFirstTGWConnection)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalPaginationNextTGWConnection)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *TransitGatewayConnectionCollection) GetNextStart() (*string, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	return resp.Next.Start, nil
}

// TransitGatewayConnectionCust : Connection included in transit gateway.
type TransitGatewayConnectionCust struct {
	// network_type `gre_tunnel` connections use `base_connection_id` to specify the ID of a network_type `classic`
	// connection the tunnel is configured over. The specified connection must reside in the same transit gateway and be in
	// an active state. The `classic` connection cannot be deleted until any `gre_tunnel` connections using it are deleted.
	// This field only applies to and is required for network type `gre_tunnel` connections.
	// Deprecated: this field is deprecated and may be removed in a future release.
	BaseConnectionID *string `json:"base_connection_id,omitempty"`

	// The type of network the Unbound GRE tunnel is targeting. This field is required for network type
	// `unbound_gre_tunnel` and must be set to `classic`.  For a `redundant_gre` network type, the value is required and
	// can be either VPC or Classic. This field is required to be unspecified for network type `classic`, `directlink`,
	// `vpc`, `power_virtual_server`, `vpn_gateway` and `gre_tunnel` connections.
	BaseNetworkType *string `json:"base_network_type,omitempty"`

	// network_type 'vpn_gateway' connections use 'cidr' to specify the CIDR to use for the VPN GRE tunnels.
	Cidr *string `json:"cidr,omitempty"`

	// The date and time that this connection was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The unique identifier for this Transit Gateway connection.
	ID *string `json:"id" validate:"required"`

	// Local network BGP ASN.  This field only applies to network type `gre_tunnel` and `unbound_gre_tunnel` connections.
	LocalBgpAsn *int64 `json:"local_bgp_asn,omitempty"`

	// Local gateway IP address.  This field only applies to network type `gre_tunnel` and `unbound_gre_tunnel`
	// connections.
	LocalGatewayIp *string `json:"local_gateway_ip,omitempty"`

	// Local tunnel IP address.  This field only applies to network type `gre_tunnel` and `unbound_gre_tunnel` connections.
	LocalTunnelIp *string `json:"local_tunnel_ip,omitempty"`

	// GRE tunnel MTU.  This field only applies to network type `gre_tunnel` and `unbound_gre_tunnel` connections.
	Mtu *int64 `json:"mtu,omitempty"`

	// The user-defined name for this transit gateway connection. Network type `vpc`  connections are defaulted to the name
	// of the VPC.  Network type `classic` connections are named `classic`.
	//
	// This field is required for network type `power_virtual_server`, `directlink`, `gre_tunnel`, `unbound_gre_tunnel`,
	// `vpn_gateway` and `redundant_gre` connections.
	//
	// This field is optional for network type `classic`, `vpc` connections.
	Name *string `json:"name,omitempty"`

	// The ID of the account which owns the connected network. Generally only used if the network is in a different IBM
	// Cloud account than the gateway.
	NetworkAccountID *string `json:"network_account_id,omitempty"`

	// The ID of the network being connected via this connection. For network types `vpc`,`power_virtual_server`,
	// `directlink` and `vpn_gateway` this is the CRN of the VPC / PowerVS / VDC / Direct Link / VPN gateway respectively.
	// This field is required for network type `vpc`, `power_virtual_server`, `vpn_gateway`, and `directlink` connections.
	// It is also required for `redundant_gre` connections when the base_network_type is set to VPC. This field is required
	// to be unspecified for network type `classic`, `gre_tunnel` and `unbound_gre_tunnel` connections.
	NetworkID *string `json:"network_id,omitempty"`

	// Defines what type of network is connected via this connection.
	NetworkType *string `json:"network_type,omitempty"`

	// Array of prefix route filters for a transit gateway connection. This is order dependent with those first in the
	// array being applied first, and those at the end of the array is applied last, or just before the default. This field
	// does not apply to the `redundant_gre` network type.
	PrefixFilters []TransitGatewayConnectionPrefixFilterReference `json:"prefix_filters,omitempty"`

	// Default setting of permit or deny which applies to any routes that don't match a specified filter. This field does
	// not apply to the `redundant_gre` network type.
	PrefixFiltersDefault *string `json:"prefix_filters_default,omitempty"`

	// Remote network BGP ASN.  This field only applies to network type `gre_tunnel` and `unbound_gre_tunnel` connections.
	RemoteBgpAsn *int64 `json:"remote_bgp_asn,omitempty"`

	// Remote gateway IP address.  This field only applies to network type `gre_tunnel` and `unbound_gre_tunnel`
	// connections.
	RemoteGatewayIp *string `json:"remote_gateway_ip,omitempty"`

	// Remote tunnel IP address.  This field only applies to network type `gre_tunnel` and `unbound_gre_tunnel`
	// connections.
	RemoteTunnelIp *string `json:"remote_tunnel_ip,omitempty"`

	// Only visible for cross account connections, this field represents the status of a connection request between IBM
	// Cloud accounts. The list of enumerated values for this property may expand in the future. Code and processes using
	// this field must tolerate unexpected values.
	RequestStatus *string `json:"request_status" validate:"required"`

	// Connection's current configuration state. The list of enumerated values for this property may expand in the future.
	// Code and processes using this field must tolerate unexpected values.
	Status *string `json:"status" validate:"required"`

	// Collection of all tunnels for `redundant_gre` and `vpn_gateway` connections.
	Tunnels []TransitGatewayTunnel `json:"tunnels,omitempty"`

	// The date and time that this connection was last updated.
	UpdatedAt *strfmt.DateTime `json:"updated_at" validate:"required"`

	// Location of GRE tunnel. This field is required for network type `gre_tunnel` and `vpn_gateway` connections.
	Zone *ZoneReference `json:"zone,omitempty"`
}

// Constants associated with the TransitGatewayConnectionCust.BaseNetworkType property.
// The type of network the Unbound GRE tunnel is targeting. This field is required for network type `unbound_gre_tunnel`
// and must be set to `classic`.  For a `redundant_gre` network type, the value is required and can be either VPC or
// Classic. This field is required to be unspecified for network type `classic`, `directlink`, `vpc`,
// `power_virtual_server`, `vpn_gateway` and `gre_tunnel` connections.
const (
	TransitGatewayConnectionCust_BaseNetworkType_Classic = "classic"
	TransitGatewayConnectionCust_BaseNetworkType_Vpc     = "vpc"
)

// Constants associated with the TransitGatewayConnectionCust.NetworkType property.
// Defines what type of network is connected via this connection.
const (
	TransitGatewayConnectionCust_NetworkType_Classic            = "classic"
	TransitGatewayConnectionCust_NetworkType_Directlink         = "directlink"
	TransitGatewayConnectionCust_NetworkType_GreTunnel          = "gre_tunnel"
	TransitGatewayConnectionCust_NetworkType_PowerVirtualServer = "power_virtual_server"
	TransitGatewayConnectionCust_NetworkType_RedundantGre       = "redundant_gre"
	TransitGatewayConnectionCust_NetworkType_UnboundGreTunnel   = "unbound_gre_tunnel"
	TransitGatewayConnectionCust_NetworkType_Vpc                = "vpc"
	TransitGatewayConnectionCust_NetworkType_VpnGateway         = "vpn_gateway"
)

// Constants associated with the TransitGatewayConnectionCust.PrefixFiltersDefault property.
// Default setting of permit or deny which applies to any routes that don't match a specified filter. This field does
// not apply to the `redundant_gre` network type.
const (
	TransitGatewayConnectionCust_PrefixFiltersDefault_Deny   = "deny"
	TransitGatewayConnectionCust_PrefixFiltersDefault_Permit = "permit"
)

// Constants associated with the TransitGatewayConnectionCust.RequestStatus property.
// Only visible for cross account connections, this field represents the status of a connection request between IBM
// Cloud accounts. The list of enumerated values for this property may expand in the future. Code and processes using
// this field must tolerate unexpected values.
const (
	TransitGatewayConnectionCust_RequestStatus_Approved = "approved"
	TransitGatewayConnectionCust_RequestStatus_Detached = "detached"
	TransitGatewayConnectionCust_RequestStatus_Expired  = "expired"
	TransitGatewayConnectionCust_RequestStatus_Pending  = "pending"
	TransitGatewayConnectionCust_RequestStatus_Rejected = "rejected"
)

// Constants associated with the TransitGatewayConnectionCust.Status property.
// Connection's current configuration state. The list of enumerated values for this property may expand in the future.
// Code and processes using this field must tolerate unexpected values.
const (
	TransitGatewayConnectionCust_Status_Attached       = "attached"
	TransitGatewayConnectionCust_Status_Deleting       = "deleting"
	TransitGatewayConnectionCust_Status_Detached       = "detached"
	TransitGatewayConnectionCust_Status_Detaching      = "detaching"
	TransitGatewayConnectionCust_Status_Failed         = "failed"
	TransitGatewayConnectionCust_Status_NetworkPending = "network_pending"
	TransitGatewayConnectionCust_Status_Pending        = "pending"
	TransitGatewayConnectionCust_Status_Suspended      = "suspended"
	TransitGatewayConnectionCust_Status_Suspending     = "suspending"
)

// UnmarshalTransitGatewayConnectionCust unmarshals an instance of TransitGatewayConnectionCust from the specified map of raw messages.
func UnmarshalTransitGatewayConnectionCust(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TransitGatewayConnectionCust)
	err = core.UnmarshalPrimitive(m, "base_connection_id", &obj.BaseConnectionID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "base_network_type", &obj.BaseNetworkType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "cidr", &obj.Cidr)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "local_bgp_asn", &obj.LocalBgpAsn)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "local_gateway_ip", &obj.LocalGatewayIp)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "local_tunnel_ip", &obj.LocalTunnelIp)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "mtu", &obj.Mtu)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "network_account_id", &obj.NetworkAccountID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "network_id", &obj.NetworkID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "network_type", &obj.NetworkType)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "prefix_filters", &obj.PrefixFilters, UnmarshalTransitGatewayConnectionPrefixFilterReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "prefix_filters_default", &obj.PrefixFiltersDefault)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "remote_bgp_asn", &obj.RemoteBgpAsn)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "remote_gateway_ip", &obj.RemoteGatewayIp)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "remote_tunnel_ip", &obj.RemoteTunnelIp)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "request_status", &obj.RequestStatus)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "tunnels", &obj.Tunnels, UnmarshalTransitGatewayTunnel)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TransitGatewayConnectionPrefixFilter : A prefix filter for a Transit Gateway connection.
type TransitGatewayConnectionPrefixFilter struct {
	// Whether to permit or deny prefix filter.
	Action *string `json:"action" validate:"required"`

	// IP Prefix GE.
	Ge *int64 `json:"ge,omitempty"`

	// IP Prefix LE.
	Le *int64 `json:"le,omitempty"`

	// IP Prefix.
	Prefix *string `json:"prefix" validate:"required"`
}

// Constants associated with the TransitGatewayConnectionPrefixFilter.Action property.
// Whether to permit or deny prefix filter.
const (
	TransitGatewayConnectionPrefixFilter_Action_Deny   = "deny"
	TransitGatewayConnectionPrefixFilter_Action_Permit = "permit"
)

// NewTransitGatewayConnectionPrefixFilter : Instantiate TransitGatewayConnectionPrefixFilter (Generic Model Constructor)
func (*TransitGatewayApisV1) NewTransitGatewayConnectionPrefixFilter(action string, prefix string) (_model *TransitGatewayConnectionPrefixFilter, err error) {
	_model = &TransitGatewayConnectionPrefixFilter{
		Action: core.StringPtr(action),
		Prefix: core.StringPtr(prefix),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

// UnmarshalTransitGatewayConnectionPrefixFilter unmarshals an instance of TransitGatewayConnectionPrefixFilter from the specified map of raw messages.
func UnmarshalTransitGatewayConnectionPrefixFilter(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TransitGatewayConnectionPrefixFilter)
	err = core.UnmarshalPrimitive(m, "action", &obj.Action)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ge", &obj.Ge)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "le", &obj.Le)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "prefix", &obj.Prefix)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TransitGatewayConnectionPrefixFilterReference : A prefix filter reference object for a Transit Gateway connection.
type TransitGatewayConnectionPrefixFilterReference struct {
	// Whether to permit or deny prefix filter.
	Action *string `json:"action" validate:"required"`

	// Identifier of prefix filter that handles the ordering and follow semantics:
	// - When a filter reference another filter in it's before field, then the filter making the reference is applied
	// before
	//   the referenced filter. For example: if filter A references filter B in its before field, A is applied before B.
	// - When a new filter is added that has the same before as an existing filter, then the older filter will have its
	// before
	//   field updated to point to the new filter. Starting with the above example: if filter C is added and it references
	// B in its
	//   before field, then A's before field should be modified to point to C, so the order of application would be A, C
	// and finally B.
	// - A filter that has an empty before reference will be applied last (though the date order mentioned above will still
	// apply).
	//   So continuing the above examples, if filter B has an empty before field, then it will be applied last, but if
	// filter D
	//   is created with an empty before field, then B's before field will be modified to point to D, so B will be applied
	// before D.
	Before *string `json:"before,omitempty"`

	// The date and time that this prefix filter was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// IP Prefix GE.
	Ge *int64 `json:"ge,omitempty"`

	// Prefix Filter identifier.
	ID *string `json:"id" validate:"required"`

	// IP Prefix LE.
	Le *int64 `json:"le,omitempty"`

	// IP Prefix.
	Prefix *string `json:"prefix" validate:"required"`

	// The date and time that this prefix filter was last updated.
	UpdatedAt *strfmt.DateTime `json:"updated_at,omitempty"`
}

// Constants associated with the TransitGatewayConnectionPrefixFilterReference.Action property.
// Whether to permit or deny prefix filter.
const (
	TransitGatewayConnectionPrefixFilterReference_Action_Deny   = "deny"
	TransitGatewayConnectionPrefixFilterReference_Action_Permit = "permit"
)

// UnmarshalTransitGatewayConnectionPrefixFilterReference unmarshals an instance of TransitGatewayConnectionPrefixFilterReference from the specified map of raw messages.
func UnmarshalTransitGatewayConnectionPrefixFilterReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TransitGatewayConnectionPrefixFilterReference)
	err = core.UnmarshalPrimitive(m, "action", &obj.Action)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "before", &obj.Before)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ge", &obj.Ge)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "le", &obj.Le)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "prefix", &obj.Prefix)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TransitGatewayReference : Transit gateway reference.
type TransitGatewayReference struct {
	// gateway CRN.
	Crn *string `json:"crn" validate:"required"`

	// gateway ID.
	ID *string `json:"id" validate:"required"`

	// transit gateway name.
	Name *string `json:"name" validate:"required"`
}

// UnmarshalTransitGatewayReference unmarshals an instance of TransitGatewayReference from the specified map of raw messages.
func UnmarshalTransitGatewayReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TransitGatewayReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.Crn)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TransitGatewayTunnel : Details for a redundant GRE tunnel.
type TransitGatewayTunnel struct {
	// The type of network the redundant GRE tunnel is targeting.
	BaseNetworkType *string `json:"base_network_type" validate:"required"`

	// The date and time that this GRE tunnel was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The unique identifier for this redundant GRE tunnel.
	ID *string `json:"id" validate:"required"`

	// Local network BGP ASN.  It is assigned by IBM when the tunnel is created.
	LocalBgpAsn *int64 `json:"local_bgp_asn" validate:"required"`

	// Local gateway IP address.
	LocalGatewayIp *string `json:"local_gateway_ip" validate:"required"`

	// Local tunnel IP address. The local_tunnel_ip and remote_tunnel_ip addresses must be in the same /30 network. Neither
	// can be the network nor broadcast addresses.
	LocalTunnelIp *string `json:"local_tunnel_ip" validate:"required"`

	// GRE tunnel MTU.
	Mtu *int64 `json:"mtu" validate:"required"`

	// The user-defined name for this tunnel.
	Name *string `json:"name" validate:"required"`

	// The ID of the account for cross account Classic connections.  This field is required when the GRE tunnel is in a
	// different account than the gateway and the base network is Classic.
	NetworkAccountID *string `json:"network_account_id,omitempty"`

	// The ID of the network VPC being connected via this connection.
	NetworkID *string `json:"network_id,omitempty"`

	// Remote network BGP ASN. The following ASN values are reserved and unavailable 0, 13884, 36351, 64512-64513, 65100,
	// 65200-65234, 65402-65433, 65500 and 4201065000-4201065999. If `remote_bgp_asn` is omitted on create requests, IBM
	// will assign an ASN.
	RemoteBgpAsn *int64 `json:"remote_bgp_asn" validate:"required"`

	// Remote gateway IP address.
	RemoteGatewayIp *string `json:"remote_gateway_ip" validate:"required"`

	// Remote tunnel IP address. The local_tunnel_ip and remote_tunnel_ip addresses must be in the same /30 network.
	// Neither can be the network nor broadcast addresses.
	RemoteTunnelIp *string `json:"remote_tunnel_ip" validate:"required"`

	// Tunnel's current configuration state. The list of enumerated values for this property may expand in the future. Code
	// and processes using this field must tolerate unexpected values.
	Status *string `json:"status" validate:"required"`

	// The date and time that this tunnel was last updated.
	UpdatedAt *strfmt.DateTime `json:"updated_at" validate:"required"`

	// Availability zone reference.
	Zone *ZoneReference `json:"zone" validate:"required"`
}

// Constants associated with the TransitGatewayTunnel.BaseNetworkType property.
// The type of network the redundant GRE tunnel is targeting.
const (
	TransitGatewayTunnel_BaseNetworkType_Classic = "classic"
	TransitGatewayTunnel_BaseNetworkType_Vpc     = "vpc"
)

// Constants associated with the TransitGatewayTunnel.Status property.
// Tunnel's current configuration state. The list of enumerated values for this property may expand in the future. Code
// and processes using this field must tolerate unexpected values.
const (
	TransitGatewayTunnel_Status_Attached   = "attached"
	TransitGatewayTunnel_Status_Deleting   = "deleting"
	TransitGatewayTunnel_Status_Detached   = "detached"
	TransitGatewayTunnel_Status_Detaching  = "detaching"
	TransitGatewayTunnel_Status_Failed     = "failed"
	TransitGatewayTunnel_Status_Pending    = "pending"
	TransitGatewayTunnel_Status_Suspended  = "suspended"
	TransitGatewayTunnel_Status_Suspending = "suspending"
)

// UnmarshalTransitGatewayTunnel unmarshals an instance of TransitGatewayTunnel from the specified map of raw messages.
func UnmarshalTransitGatewayTunnel(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TransitGatewayTunnel)
	err = core.UnmarshalPrimitive(m, "base_network_type", &obj.BaseNetworkType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "local_bgp_asn", &obj.LocalBgpAsn)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "local_gateway_ip", &obj.LocalGatewayIp)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "local_tunnel_ip", &obj.LocalTunnelIp)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "mtu", &obj.Mtu)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "network_account_id", &obj.NetworkAccountID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "network_id", &obj.NetworkID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "remote_bgp_asn", &obj.RemoteBgpAsn)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "remote_gateway_ip", &obj.RemoteGatewayIp)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "remote_tunnel_ip", &obj.RemoteTunnelIp)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TransitGatewayTunnelCollection : Collection of all tunnels for `redundant_gre` and `vpn_gateway` connections.
type TransitGatewayTunnelCollection struct {
	// Collection of all tunnels for `redundant_gre` and `vpn_gateway` connections.
	Tunnels []TransitGatewayTunnel `json:"tunnels" validate:"required"`
}

// UnmarshalTransitGatewayTunnelCollection unmarshals an instance of TransitGatewayTunnelCollection from the specified map of raw messages.
func UnmarshalTransitGatewayTunnelCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TransitGatewayTunnelCollection)
	err = core.UnmarshalModel(m, "tunnels", &obj.Tunnels, UnmarshalTransitGatewayTunnel)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TransitGatewayTunnelPatch : An update template for a Transit Gateway connection tunnel.
type TransitGatewayTunnelPatch struct {
	// The user-defined name for this connection tunnel.
	Name *string `json:"name,omitempty"`
}

// UnmarshalTransitGatewayTunnelPatch unmarshals an instance of TransitGatewayTunnelPatch from the specified map of raw messages.
func UnmarshalTransitGatewayTunnelPatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TransitGatewayTunnelPatch)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AsPatch returns a generic map representation of the TransitGatewayTunnelPatch
func (transitGatewayTunnelPatch *TransitGatewayTunnelPatch) AsPatch() (_patch map[string]interface{}, err error) {
	var jsonData []byte
	jsonData, err = json.Marshal(transitGatewayTunnelPatch)
	if err == nil {
		err = json.Unmarshal(jsonData, &_patch)
	}
	return
}

// TransitGatewayTunnelTemplate : A create template with information for redundant GRE tunnel.
type TransitGatewayTunnelTemplate struct {
	// Local gateway IP address.
	LocalGatewayIp *string `json:"local_gateway_ip" validate:"required"`

	// Local tunnel IP address. The local_tunnel_ip and remote_tunnel_ip addresses must be in the same /30 network. Neither
	// can be the network nor broadcast addresses.
	LocalTunnelIp *string `json:"local_tunnel_ip" validate:"required"`

	// The user-defined name for this tunnel connection.
	Name *string `json:"name" validate:"required"`

	// Remote network BGP ASN. The following ASN values are reserved and unavailable 0, 13884, 36351, 64512-64513, 65100,
	// 65200-65234, 65402-65433, 65500 and 4201065000-4201065999. If `remote_bgp_asn` is omitted on create requests, IBM
	// will assign an ASN.
	RemoteBgpAsn *int64 `json:"remote_bgp_asn,omitempty"`

	// Remote gateway IP address.
	RemoteGatewayIp *string `json:"remote_gateway_ip" validate:"required"`

	// Remote tunnel IP address. The local_tunnel_ip and remote_tunnel_ip addresses must be in the same /30 network.
	// Neither can be the network nor broadcast addresses.
	RemoteTunnelIp *string `json:"remote_tunnel_ip" validate:"required"`

	// Specify the connection's location.  The specified availability zone must reside in the gateway's region.
	// Use the IBM Cloud global catalog to list zones within the desired region.
	Zone ZoneIdentityIntf `json:"zone" validate:"required"`
}

// NewTransitGatewayTunnelTemplate : Instantiate TransitGatewayTunnelTemplate (Generic Model Constructor)
func (*TransitGatewayApisV1) NewTransitGatewayTunnelTemplate(localGatewayIp string, localTunnelIp string, name string, remoteGatewayIp string, remoteTunnelIp string, zone ZoneIdentityIntf) (_model *TransitGatewayTunnelTemplate, err error) {
	_model = &TransitGatewayTunnelTemplate{
		LocalGatewayIp:  core.StringPtr(localGatewayIp),
		LocalTunnelIp:   core.StringPtr(localTunnelIp),
		Name:            core.StringPtr(name),
		RemoteGatewayIp: core.StringPtr(remoteGatewayIp),
		RemoteTunnelIp:  core.StringPtr(remoteTunnelIp),
		Zone:            zone,
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

// UnmarshalTransitGatewayTunnelTemplate unmarshals an instance of TransitGatewayTunnelTemplate from the specified map of raw messages.
func UnmarshalTransitGatewayTunnelTemplate(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TransitGatewayTunnelTemplate)
	err = core.UnmarshalPrimitive(m, "local_gateway_ip", &obj.LocalGatewayIp)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "local_tunnel_ip", &obj.LocalTunnelIp)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "remote_bgp_asn", &obj.RemoteBgpAsn)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "remote_gateway_ip", &obj.RemoteGatewayIp)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "remote_tunnel_ip", &obj.RemoteTunnelIp)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// UpdateTransitGatewayConnectionOptions : The UpdateTransitGatewayConnection options.
type UpdateTransitGatewayConnectionOptions struct {
	// The Transit Gateway identifier.
	TransitGatewayID *string `json:"transit_gateway_id" validate:"required,ne="`

	// The connection identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The user-defined name for this transit gateway. If specified as empty string or nil,  the name will be the network
	// name (the name of the VPC in the case of network type `vpc`,  and the word Classic, in the case of network type
	// `classic`).
	Name *string `json:"name,omitempty"`

	// Default setting of permit or deny which applies to any routes that don't match a specified filter.
	PrefixFiltersDefault *string `json:"prefix_filters_default,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the UpdateTransitGatewayConnectionOptions.PrefixFiltersDefault property.
// Default setting of permit or deny which applies to any routes that don't match a specified filter.
const (
	UpdateTransitGatewayConnectionOptions_PrefixFiltersDefault_Deny   = "deny"
	UpdateTransitGatewayConnectionOptions_PrefixFiltersDefault_Permit = "permit"
)

// NewUpdateTransitGatewayConnectionOptions : Instantiate UpdateTransitGatewayConnectionOptions
func (*TransitGatewayApisV1) NewUpdateTransitGatewayConnectionOptions(transitGatewayID string, id string) *UpdateTransitGatewayConnectionOptions {
	return &UpdateTransitGatewayConnectionOptions{
		TransitGatewayID: core.StringPtr(transitGatewayID),
		ID:               core.StringPtr(id),
	}
}

// SetTransitGatewayID : Allow user to set TransitGatewayID
func (_options *UpdateTransitGatewayConnectionOptions) SetTransitGatewayID(transitGatewayID string) *UpdateTransitGatewayConnectionOptions {
	_options.TransitGatewayID = core.StringPtr(transitGatewayID)
	return _options
}

// SetID : Allow user to set ID
func (_options *UpdateTransitGatewayConnectionOptions) SetID(id string) *UpdateTransitGatewayConnectionOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetName : Allow user to set Name
func (_options *UpdateTransitGatewayConnectionOptions) SetName(name string) *UpdateTransitGatewayConnectionOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetPrefixFiltersDefault : Allow user to set PrefixFiltersDefault
func (_options *UpdateTransitGatewayConnectionOptions) SetPrefixFiltersDefault(prefixFiltersDefault string) *UpdateTransitGatewayConnectionOptions {
	_options.PrefixFiltersDefault = core.StringPtr(prefixFiltersDefault)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateTransitGatewayConnectionOptions) SetHeaders(param map[string]string) *UpdateTransitGatewayConnectionOptions {
	options.Headers = param
	return options
}

// UpdateTransitGatewayConnectionPrefixFilterOptions : The UpdateTransitGatewayConnectionPrefixFilter options.
type UpdateTransitGatewayConnectionPrefixFilterOptions struct {
	// The Transit Gateway identifier.
	TransitGatewayID *string `json:"transit_gateway_id" validate:"required,ne="`

	// The connection identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Prefix filter identifier.
	FilterID *string `json:"filter_id" validate:"required,ne="`

	// Whether or not this prefix filter should allow or deny prefixes matching this filter's prefix definition.
	Action *string `json:"action,omitempty"`

	// A reference to the prefix filter that will be the next filter applied to the Transit Gateway connection.
	//
	// If this field is blank, this prefix filter will be the last rule applied before the connection's default rule.
	//
	// When a prefix filter is created with the same before field as an existing prefix filter, the existing filter will be
	// applied before the new filter, and the existing filter's before field will be updated accordingly.
	Before *string `json:"before,omitempty"`

	// Defines the minimum matched prefix precision. If this field is non-zero then the filter will match all routes within
	// the `prefix` that have a prefix length greater or equal to this value.
	//
	// This value can be zero, or a non-negative number greater than or equal to the prefix length of the filter's prefix
	// or less then or equal to 32. If this value is set to zero, the filter will not use the `ge` route matching behavior.
	// If the `le` value is non-zero the the `ge` value must between the prefix length and the
	// `le` value, inclusive.
	Ge *int64 `json:"ge,omitempty"`

	// Defines the maximum matched prefix precision. If this field is non-zero then the filter will match all routes within
	// the `prefix` that have a prefix length less than or equal to this value.
	//
	// This value can be zero, or a non-negative number greater than or equal to the prefix length of the filter's prefix
	// or less then or equal to 32. If this value is set to zero, the filter will not use the `le` route matching behavior.
	// If the `ge` value is non-zero the the `le` value must between the `ge` value and 32, inclusive.
	Le *int64 `json:"le,omitempty"`

	// The IPv4 Prefix to be matched by this filter.
	Prefix *string `json:"prefix,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the UpdateTransitGatewayConnectionPrefixFilterOptions.Action property.
// Whether or not this prefix filter should allow or deny prefixes matching this filter's prefix definition.
const (
	UpdateTransitGatewayConnectionPrefixFilterOptions_Action_Deny   = "deny"
	UpdateTransitGatewayConnectionPrefixFilterOptions_Action_Permit = "permit"
)

// NewUpdateTransitGatewayConnectionPrefixFilterOptions : Instantiate UpdateTransitGatewayConnectionPrefixFilterOptions
func (*TransitGatewayApisV1) NewUpdateTransitGatewayConnectionPrefixFilterOptions(transitGatewayID string, id string, filterID string) *UpdateTransitGatewayConnectionPrefixFilterOptions {
	return &UpdateTransitGatewayConnectionPrefixFilterOptions{
		TransitGatewayID: core.StringPtr(transitGatewayID),
		ID:               core.StringPtr(id),
		FilterID:         core.StringPtr(filterID),
	}
}

// SetTransitGatewayID : Allow user to set TransitGatewayID
func (_options *UpdateTransitGatewayConnectionPrefixFilterOptions) SetTransitGatewayID(transitGatewayID string) *UpdateTransitGatewayConnectionPrefixFilterOptions {
	_options.TransitGatewayID = core.StringPtr(transitGatewayID)
	return _options
}

// SetID : Allow user to set ID
func (_options *UpdateTransitGatewayConnectionPrefixFilterOptions) SetID(id string) *UpdateTransitGatewayConnectionPrefixFilterOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetFilterID : Allow user to set FilterID
func (_options *UpdateTransitGatewayConnectionPrefixFilterOptions) SetFilterID(filterID string) *UpdateTransitGatewayConnectionPrefixFilterOptions {
	_options.FilterID = core.StringPtr(filterID)
	return _options
}

// SetAction : Allow user to set Action
func (_options *UpdateTransitGatewayConnectionPrefixFilterOptions) SetAction(action string) *UpdateTransitGatewayConnectionPrefixFilterOptions {
	_options.Action = core.StringPtr(action)
	return _options
}

// SetBefore : Allow user to set Before
func (_options *UpdateTransitGatewayConnectionPrefixFilterOptions) SetBefore(before string) *UpdateTransitGatewayConnectionPrefixFilterOptions {
	_options.Before = core.StringPtr(before)
	return _options
}

// SetGe : Allow user to set Ge
func (_options *UpdateTransitGatewayConnectionPrefixFilterOptions) SetGe(ge int64) *UpdateTransitGatewayConnectionPrefixFilterOptions {
	_options.Ge = core.Int64Ptr(ge)
	return _options
}

// SetLe : Allow user to set Le
func (_options *UpdateTransitGatewayConnectionPrefixFilterOptions) SetLe(le int64) *UpdateTransitGatewayConnectionPrefixFilterOptions {
	_options.Le = core.Int64Ptr(le)
	return _options
}

// SetPrefix : Allow user to set Prefix
func (_options *UpdateTransitGatewayConnectionPrefixFilterOptions) SetPrefix(prefix string) *UpdateTransitGatewayConnectionPrefixFilterOptions {
	_options.Prefix = core.StringPtr(prefix)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateTransitGatewayConnectionPrefixFilterOptions) SetHeaders(param map[string]string) *UpdateTransitGatewayConnectionPrefixFilterOptions {
	options.Headers = param
	return options
}

// UpdateTransitGatewayConnectionTunnelsOptions : The UpdateTransitGatewayConnectionTunnels options.
type UpdateTransitGatewayConnectionTunnelsOptions struct {
	// The Transit Gateway identifier.
	TransitGatewayID *string `json:"transit_gateway_id" validate:"required,ne="`

	// The connection identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The tunnel identifier.
	GreTunnelID *string `json:"gre_tunnel_id" validate:"required,ne="`

	// The update connection tunnel template.
	TransitGatewayTunnelPatch map[string]interface{} `json:"TransitGatewayTunnel_patch" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateTransitGatewayConnectionTunnelsOptions : Instantiate UpdateTransitGatewayConnectionTunnelsOptions
func (*TransitGatewayApisV1) NewUpdateTransitGatewayConnectionTunnelsOptions(transitGatewayID string, id string, greTunnelID string, transitGatewayTunnelPatch map[string]interface{}) *UpdateTransitGatewayConnectionTunnelsOptions {
	return &UpdateTransitGatewayConnectionTunnelsOptions{
		TransitGatewayID:          core.StringPtr(transitGatewayID),
		ID:                        core.StringPtr(id),
		GreTunnelID:               core.StringPtr(greTunnelID),
		TransitGatewayTunnelPatch: transitGatewayTunnelPatch,
	}
}

// SetTransitGatewayID : Allow user to set TransitGatewayID
func (_options *UpdateTransitGatewayConnectionTunnelsOptions) SetTransitGatewayID(transitGatewayID string) *UpdateTransitGatewayConnectionTunnelsOptions {
	_options.TransitGatewayID = core.StringPtr(transitGatewayID)
	return _options
}

// SetID : Allow user to set ID
func (_options *UpdateTransitGatewayConnectionTunnelsOptions) SetID(id string) *UpdateTransitGatewayConnectionTunnelsOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetGreTunnelID : Allow user to set GreTunnelID
func (_options *UpdateTransitGatewayConnectionTunnelsOptions) SetGreTunnelID(greTunnelID string) *UpdateTransitGatewayConnectionTunnelsOptions {
	_options.GreTunnelID = core.StringPtr(greTunnelID)
	return _options
}

// SetTransitGatewayTunnelPatch : Allow user to set TransitGatewayTunnelPatch
func (_options *UpdateTransitGatewayConnectionTunnelsOptions) SetTransitGatewayTunnelPatch(transitGatewayTunnelPatch map[string]interface{}) *UpdateTransitGatewayConnectionTunnelsOptions {
	_options.TransitGatewayTunnelPatch = transitGatewayTunnelPatch
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateTransitGatewayConnectionTunnelsOptions) SetHeaders(param map[string]string) *UpdateTransitGatewayConnectionTunnelsOptions {
	options.Headers = param
	return options
}

// UpdateTransitGatewayOptions : The UpdateTransitGateway options.
type UpdateTransitGatewayOptions struct {
	// The Transit Gateway identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allow global routing for a Transit Gateway.
	Global *bool `json:"global,omitempty"`

	// Allow GRE Enhanced Route Propagation on this gateway.
	GreEnhancedRoutePropagation *bool `json:"gre_enhanced_route_propagation,omitempty"`

	// A human readable name for a resource.
	Name *string `json:"name,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateTransitGatewayOptions : Instantiate UpdateTransitGatewayOptions
func (*TransitGatewayApisV1) NewUpdateTransitGatewayOptions(id string) *UpdateTransitGatewayOptions {
	return &UpdateTransitGatewayOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *UpdateTransitGatewayOptions) SetID(id string) *UpdateTransitGatewayOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetGlobal : Allow user to set Global
func (_options *UpdateTransitGatewayOptions) SetGlobal(global bool) *UpdateTransitGatewayOptions {
	_options.Global = core.BoolPtr(global)
	return _options
}

// SetGreEnhancedRoutePropagation : Allow user to set GreEnhancedRoutePropagation
func (_options *UpdateTransitGatewayOptions) SetGreEnhancedRoutePropagation(greEnhancedRoutePropagation bool) *UpdateTransitGatewayOptions {
	_options.GreEnhancedRoutePropagation = core.BoolPtr(greEnhancedRoutePropagation)
	return _options
}

// SetName : Allow user to set Name
func (_options *UpdateTransitGatewayOptions) SetName(name string) *UpdateTransitGatewayOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateTransitGatewayOptions) SetHeaders(param map[string]string) *UpdateTransitGatewayOptions {
	options.Headers = param
	return options
}

// ZoneIdentity : ZoneIdentity struct
// Models which "extend" this model:
// - ZoneIdentityByName
type ZoneIdentity struct {
	// Availability zone name.
	Name *string `json:"name,omitempty"`
}

func (*ZoneIdentity) isaZoneIdentity() bool {
	return true
}

type ZoneIdentityIntf interface {
	isaZoneIdentity() bool
}

// UnmarshalZoneIdentity unmarshals an instance of ZoneIdentity from the specified map of raw messages.
func UnmarshalZoneIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ZoneIdentity)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ZoneReference : Availability zone reference.
type ZoneReference struct {
	// Availability zone name.
	Name *string `json:"name" validate:"required"`
}

// UnmarshalZoneReference unmarshals an instance of ZoneReference from the specified map of raw messages.
func UnmarshalZoneReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ZoneReference)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ZoneIdentityByName : Availability zone.
// This model "extends" ZoneIdentity
type ZoneIdentityByName struct {
	// Availability zone name.
	Name *string `json:"name,omitempty"`
}

func (*ZoneIdentityByName) isaZoneIdentity() bool {
	return true
}

// UnmarshalZoneIdentityByName unmarshals an instance of ZoneIdentityByName from the specified map of raw messages.
func UnmarshalZoneIdentityByName(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ZoneIdentityByName)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TransitGatewaysPager can be used to simplify the use of the "ListTransitGateways" method.
type TransitGatewaysPager struct {
	hasNext     bool
	options     *ListTransitGatewaysOptions
	client      *TransitGatewayApisV1
	pageContext struct {
		next *string
	}
}

// NewTransitGatewaysPager returns a new TransitGatewaysPager instance.
func (transitGatewayApis *TransitGatewayApisV1) NewTransitGatewaysPager(options *ListTransitGatewaysOptions) (pager *TransitGatewaysPager, err error) {
	if options.Start != nil && *options.Start != "" {
		err = fmt.Errorf("the 'options.Start' field should not be set")
		return
	}

	var optionsCopy ListTransitGatewaysOptions = *options
	pager = &TransitGatewaysPager{
		hasNext: true,
		options: &optionsCopy,
		client:  transitGatewayApis,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *TransitGatewaysPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *TransitGatewaysPager) GetNextWithContext(ctx context.Context) (page []TransitGateway, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Start = pager.pageContext.next

	result, _, err := pager.client.ListTransitGatewaysWithContext(ctx, pager.options)
	if err != nil {
		return
	}

	var next *string
	if result.Next != nil {
		next = result.Next.Start
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.TransitGateways

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *TransitGatewaysPager) GetAllWithContext(ctx context.Context) (allItems []TransitGateway, err error) {
	for pager.HasNext() {
		var nextPage []TransitGateway
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *TransitGatewaysPager) GetNext() (page []TransitGateway, err error) {
	return pager.GetNextWithContext(context.Background())
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *TransitGatewaysPager) GetAll() (allItems []TransitGateway, err error) {
	return pager.GetAllWithContext(context.Background())
}

// ConnectionsPager can be used to simplify the use of the "ListConnections" method.
type ConnectionsPager struct {
	hasNext     bool
	options     *ListConnectionsOptions
	client      *TransitGatewayApisV1
	pageContext struct {
		next *string
	}
}

// NewConnectionsPager returns a new ConnectionsPager instance.
func (transitGatewayApis *TransitGatewayApisV1) NewConnectionsPager(options *ListConnectionsOptions) (pager *ConnectionsPager, err error) {
	if options.Start != nil && *options.Start != "" {
		err = fmt.Errorf("the 'options.Start' field should not be set")
		return
	}

	var optionsCopy ListConnectionsOptions = *options
	pager = &ConnectionsPager{
		hasNext: true,
		options: &optionsCopy,
		client:  transitGatewayApis,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *ConnectionsPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *ConnectionsPager) GetNextWithContext(ctx context.Context) (page []TransitConnection, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Start = pager.pageContext.next

	result, _, err := pager.client.ListConnectionsWithContext(ctx, pager.options)
	if err != nil {
		return
	}

	var next *string
	if result.Next != nil {
		next = result.Next.Start
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.Connections

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *ConnectionsPager) GetAllWithContext(ctx context.Context) (allItems []TransitConnection, err error) {
	for pager.HasNext() {
		var nextPage []TransitConnection
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *ConnectionsPager) GetNext() (page []TransitConnection, err error) {
	return pager.GetNextWithContext(context.Background())
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *ConnectionsPager) GetAll() (allItems []TransitConnection, err error) {
	return pager.GetAllWithContext(context.Background())
}

// TransitGatewayConnectionsPager can be used to simplify the use of the "ListTransitGatewayConnections" method.
type TransitGatewayConnectionsPager struct {
	hasNext     bool
	options     *ListTransitGatewayConnectionsOptions
	client      *TransitGatewayApisV1
	pageContext struct {
		next *string
	}
}

// NewTransitGatewayConnectionsPager returns a new TransitGatewayConnectionsPager instance.
func (transitGatewayApis *TransitGatewayApisV1) NewTransitGatewayConnectionsPager(options *ListTransitGatewayConnectionsOptions) (pager *TransitGatewayConnectionsPager, err error) {
	if options.Start != nil && *options.Start != "" {
		err = fmt.Errorf("the 'options.Start' field should not be set")
		return
	}

	var optionsCopy ListTransitGatewayConnectionsOptions = *options
	pager = &TransitGatewayConnectionsPager{
		hasNext: true,
		options: &optionsCopy,
		client:  transitGatewayApis,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *TransitGatewayConnectionsPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *TransitGatewayConnectionsPager) GetNextWithContext(ctx context.Context) (page []TransitGatewayConnectionCust, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Start = pager.pageContext.next

	result, _, err := pager.client.ListTransitGatewayConnectionsWithContext(ctx, pager.options)
	if err != nil {
		return
	}

	var next *string
	if result.Next != nil {
		next = result.Next.Start
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.Connections

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *TransitGatewayConnectionsPager) GetAllWithContext(ctx context.Context) (allItems []TransitGatewayConnectionCust, err error) {
	for pager.HasNext() {
		var nextPage []TransitGatewayConnectionCust
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *TransitGatewayConnectionsPager) GetNext() (page []TransitGatewayConnectionCust, err error) {
	return pager.GetNextWithContext(context.Background())
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *TransitGatewayConnectionsPager) GetAll() (allItems []TransitGatewayConnectionCust, err error) {
	return pager.GetAllWithContext(context.Background())
}
