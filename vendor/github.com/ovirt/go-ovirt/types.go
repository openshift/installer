//
// Copyright (c) 2017 Joey <majunjiev@gmail.com>.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package ovirtsdk

import (
	"fmt"
	"time"
)

// AffinityGroup An affinity group represents a group of virtual machines with a defined relationship.
type AffinityGroup struct {
	Struct
	cluster     *Cluster
	comment     *string
	description *string
	enforcing   *bool
	hostLabels  *AffinityLabelSlice
	hosts       *HostSlice
	hostsRule   *AffinityRule
	id          *string
	name        *string
	positive    *bool
	priority    *float64
	vmLabels    *AffinityLabelSlice
	vms         *VmSlice
	vmsRule     *AffinityRule
}

// SetCluster Type representation of a cluster.
//
// A JSON representation of a cluster:
//
// [source]
// ----
// {
//   "cluster" : [ {
//     "ballooning_enabled" : "false",
//     "cpu" : {
//       "architecture" : "x86_64",
//       "type" : "Intel SandyBridge Family"
//     },
//     "custom_scheduling_policy_properties" : {
//       "property" : [ {
//         "name" : "HighUtilization",
//         "value" : "80"
//       }, {
//         "name" : "CpuOverCommitDurationMinutes",
//         "value" : "2"
//       } ]
//     },
//     "error_handling" : {
//       "on_error" : "migrate"
//     },
//     "fencing_policy" : {
//       "enabled" : "true",
//       "skip_if_connectivity_broken" : {
//         "enabled" : "false",
//         "threshold" : "50"
//       },
//       "skip_if_gluster_bricks_up" : "false",
//       "skip_if_gluster_quorum_not_met" : "false",
//       "skip_if_sd_active" : {
//         "enabled" : "false"
//       }
//     },
//     "gluster_service" : "false",
//     "firewall_type" : "iptables",
//     "ha_reservation" : "false",
//     "ksm" : {
//       "enabled" : "true",
//       "merge_across_nodes" : "true"
//     },
//     "memory_policy" : {
//       "over_commit" : {
//         "percent" : "100"
//       },
//       "transparent_hugepages" : {
//         "enabled" : "true"
//       }
//     },
//     "migration" : {
//       "auto_converge" : "inherit",
//       "bandwidth" : {
//         "assignment_method" : "auto"
//       },
//       "compressed" : "inherit",
//       "policy" : {
//         "id" : "00000000-0000-0000-0000-000000000000"
//       }
//     },
//     "required_rng_sources" : {
//       "required_rng_source" : [ "random" ]
//     },
//     "switch_type" : "legacy",
//     "threads_as_cores" : "false",
//     "trusted_service" : "false",
//     "tunnel_migration" : "false",
//     "version" : {
//       "major" : "4",
//       "minor" : "1"
//     },
//     "virt_service" : "true",
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "mac_pool" : {
//       "href" : "/ovirt-engine/api/macpools/456",
//       "id" : "456"
//     },
//     "scheduling_policy" : {
//       "href" : "/ovirt-engine/api/schedulingpolicies/789",
//       "id" : "789"
//     },
//     "actions" : {
//       "link" : [ {
//         "href" : "/ovirt-engine/api/clusters/234/resetemulatedmachine",
//         "rel" : "resetemulatedmachine"
//       } ]
//     },
//     "name" : "Default",
//     "description" : "The default server cluster",
//     "href" : "/ovirt-engine/api/clusters/234",
//     "id" : "234",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/clusters/234/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/cpuprofiles",
//       "rel" : "cpuprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networkfilters",
//       "rel" : "networkfilters"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networks",
//       "rel" : "networks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/affinitygroups",
//       "rel" : "affinitygroups"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glusterhooks",
//       "rel" : "glusterhooks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glustervolumes",
//       "rel" : "glustervolumes"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/enabledfeatures",
//       "rel" : "enabledfeatures"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/externalnetworkproviders",
//       "rel" : "externalnetworkproviders"
//     } ]
//   } ]
// }
// ----
func (p *AffinityGroup) SetCluster(attr *Cluster) {
	p.cluster = attr
}

// Cluster Type representation of a cluster.
//
// A JSON representation of a cluster:
//
// [source]
// ----
// {
//   "cluster" : [ {
//     "ballooning_enabled" : "false",
//     "cpu" : {
//       "architecture" : "x86_64",
//       "type" : "Intel SandyBridge Family"
//     },
//     "custom_scheduling_policy_properties" : {
//       "property" : [ {
//         "name" : "HighUtilization",
//         "value" : "80"
//       }, {
//         "name" : "CpuOverCommitDurationMinutes",
//         "value" : "2"
//       } ]
//     },
//     "error_handling" : {
//       "on_error" : "migrate"
//     },
//     "fencing_policy" : {
//       "enabled" : "true",
//       "skip_if_connectivity_broken" : {
//         "enabled" : "false",
//         "threshold" : "50"
//       },
//       "skip_if_gluster_bricks_up" : "false",
//       "skip_if_gluster_quorum_not_met" : "false",
//       "skip_if_sd_active" : {
//         "enabled" : "false"
//       }
//     },
//     "gluster_service" : "false",
//     "firewall_type" : "iptables",
//     "ha_reservation" : "false",
//     "ksm" : {
//       "enabled" : "true",
//       "merge_across_nodes" : "true"
//     },
//     "memory_policy" : {
//       "over_commit" : {
//         "percent" : "100"
//       },
//       "transparent_hugepages" : {
//         "enabled" : "true"
//       }
//     },
//     "migration" : {
//       "auto_converge" : "inherit",
//       "bandwidth" : {
//         "assignment_method" : "auto"
//       },
//       "compressed" : "inherit",
//       "policy" : {
//         "id" : "00000000-0000-0000-0000-000000000000"
//       }
//     },
//     "required_rng_sources" : {
//       "required_rng_source" : [ "random" ]
//     },
//     "switch_type" : "legacy",
//     "threads_as_cores" : "false",
//     "trusted_service" : "false",
//     "tunnel_migration" : "false",
//     "version" : {
//       "major" : "4",
//       "minor" : "1"
//     },
//     "virt_service" : "true",
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "mac_pool" : {
//       "href" : "/ovirt-engine/api/macpools/456",
//       "id" : "456"
//     },
//     "scheduling_policy" : {
//       "href" : "/ovirt-engine/api/schedulingpolicies/789",
//       "id" : "789"
//     },
//     "actions" : {
//       "link" : [ {
//         "href" : "/ovirt-engine/api/clusters/234/resetemulatedmachine",
//         "rel" : "resetemulatedmachine"
//       } ]
//     },
//     "name" : "Default",
//     "description" : "The default server cluster",
//     "href" : "/ovirt-engine/api/clusters/234",
//     "id" : "234",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/clusters/234/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/cpuprofiles",
//       "rel" : "cpuprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networkfilters",
//       "rel" : "networkfilters"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networks",
//       "rel" : "networks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/affinitygroups",
//       "rel" : "affinitygroups"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glusterhooks",
//       "rel" : "glusterhooks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glustervolumes",
//       "rel" : "glustervolumes"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/enabledfeatures",
//       "rel" : "enabledfeatures"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/externalnetworkproviders",
//       "rel" : "externalnetworkproviders"
//     } ]
//   } ]
// }
// ----
func (p *AffinityGroup) Cluster() (*Cluster, bool) {
	if p.cluster != nil {
		return p.cluster, true
	}
	return nil, false
}

// MustCluster Type representation of a cluster.
//
// A JSON representation of a cluster:
//
// [source]
// ----
// {
//   "cluster" : [ {
//     "ballooning_enabled" : "false",
//     "cpu" : {
//       "architecture" : "x86_64",
//       "type" : "Intel SandyBridge Family"
//     },
//     "custom_scheduling_policy_properties" : {
//       "property" : [ {
//         "name" : "HighUtilization",
//         "value" : "80"
//       }, {
//         "name" : "CpuOverCommitDurationMinutes",
//         "value" : "2"
//       } ]
//     },
//     "error_handling" : {
//       "on_error" : "migrate"
//     },
//     "fencing_policy" : {
//       "enabled" : "true",
//       "skip_if_connectivity_broken" : {
//         "enabled" : "false",
//         "threshold" : "50"
//       },
//       "skip_if_gluster_bricks_up" : "false",
//       "skip_if_gluster_quorum_not_met" : "false",
//       "skip_if_sd_active" : {
//         "enabled" : "false"
//       }
//     },
//     "gluster_service" : "false",
//     "firewall_type" : "iptables",
//     "ha_reservation" : "false",
//     "ksm" : {
//       "enabled" : "true",
//       "merge_across_nodes" : "true"
//     },
//     "memory_policy" : {
//       "over_commit" : {
//         "percent" : "100"
//       },
//       "transparent_hugepages" : {
//         "enabled" : "true"
//       }
//     },
//     "migration" : {
//       "auto_converge" : "inherit",
//       "bandwidth" : {
//         "assignment_method" : "auto"
//       },
//       "compressed" : "inherit",
//       "policy" : {
//         "id" : "00000000-0000-0000-0000-000000000000"
//       }
//     },
//     "required_rng_sources" : {
//       "required_rng_source" : [ "random" ]
//     },
//     "switch_type" : "legacy",
//     "threads_as_cores" : "false",
//     "trusted_service" : "false",
//     "tunnel_migration" : "false",
//     "version" : {
//       "major" : "4",
//       "minor" : "1"
//     },
//     "virt_service" : "true",
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "mac_pool" : {
//       "href" : "/ovirt-engine/api/macpools/456",
//       "id" : "456"
//     },
//     "scheduling_policy" : {
//       "href" : "/ovirt-engine/api/schedulingpolicies/789",
//       "id" : "789"
//     },
//     "actions" : {
//       "link" : [ {
//         "href" : "/ovirt-engine/api/clusters/234/resetemulatedmachine",
//         "rel" : "resetemulatedmachine"
//       } ]
//     },
//     "name" : "Default",
//     "description" : "The default server cluster",
//     "href" : "/ovirt-engine/api/clusters/234",
//     "id" : "234",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/clusters/234/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/cpuprofiles",
//       "rel" : "cpuprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networkfilters",
//       "rel" : "networkfilters"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networks",
//       "rel" : "networks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/affinitygroups",
//       "rel" : "affinitygroups"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glusterhooks",
//       "rel" : "glusterhooks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glustervolumes",
//       "rel" : "glustervolumes"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/enabledfeatures",
//       "rel" : "enabledfeatures"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/externalnetworkproviders",
//       "rel" : "externalnetworkproviders"
//     } ]
//   } ]
// }
// ----
func (p *AffinityGroup) MustCluster() *Cluster {
	if p.cluster == nil {
		panic("the cluster must not be nil, please use Cluster() function instead")
	}
	return p.cluster
}

func (p *AffinityGroup) SetComment(attr string) {
	p.comment = &attr
}

func (p *AffinityGroup) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *AffinityGroup) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *AffinityGroup) SetDescription(attr string) {
	p.description = &attr
}

func (p *AffinityGroup) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *AffinityGroup) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *AffinityGroup) SetEnforcing(attr bool) {
	p.enforcing = &attr
}

func (p *AffinityGroup) Enforcing() (bool, bool) {
	if p.enforcing != nil {
		return *p.enforcing, true
	}
	var zero bool
	return zero, false
}

func (p *AffinityGroup) MustEnforcing() bool {
	if p.enforcing == nil {
		panic("the enforcing must not be nil, please use Enforcing() function instead")
	}
	return *p.enforcing
}

func (p *AffinityGroup) SetHostLabels(attr *AffinityLabelSlice) {
	p.hostLabels = attr
}

func (p *AffinityGroup) HostLabels() (*AffinityLabelSlice, bool) {
	if p.hostLabels != nil {
		return p.hostLabels, true
	}
	return nil, false
}

func (p *AffinityGroup) MustHostLabels() *AffinityLabelSlice {
	if p.hostLabels == nil {
		panic("the hostLabels must not be nil, please use HostLabels() function instead")
	}
	return p.hostLabels
}

func (p *AffinityGroup) SetHosts(attr *HostSlice) {
	p.hosts = attr
}

func (p *AffinityGroup) Hosts() (*HostSlice, bool) {
	if p.hosts != nil {
		return p.hosts, true
	}
	return nil, false
}

func (p *AffinityGroup) MustHosts() *HostSlice {
	if p.hosts == nil {
		panic("the hosts must not be nil, please use Hosts() function instead")
	}
	return p.hosts
}

// SetHostsRule Generic rule definition for affinity group. Each supported resource type (virtual machine, host) is controlled
// by a separate rule. This allows expressing of rules like: no affinity between defined virtual machines, but hard
// affinity between defined virtual machines and virtual hosts.
func (p *AffinityGroup) SetHostsRule(attr *AffinityRule) {
	p.hostsRule = attr
}

// HostsRule Generic rule definition for affinity group. Each supported resource type (virtual machine, host) is controlled
// by a separate rule. This allows expressing of rules like: no affinity between defined virtual machines, but hard
// affinity between defined virtual machines and virtual hosts.
func (p *AffinityGroup) HostsRule() (*AffinityRule, bool) {
	if p.hostsRule != nil {
		return p.hostsRule, true
	}
	return nil, false
}

// MustHostsRule Generic rule definition for affinity group. Each supported resource type (virtual machine, host) is controlled
// by a separate rule. This allows expressing of rules like: no affinity between defined virtual machines, but hard
// affinity between defined virtual machines and virtual hosts.
func (p *AffinityGroup) MustHostsRule() *AffinityRule {
	if p.hostsRule == nil {
		panic("the hostsRule must not be nil, please use HostsRule() function instead")
	}
	return p.hostsRule
}

func (p *AffinityGroup) SetId(attr string) {
	p.id = &attr
}

func (p *AffinityGroup) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *AffinityGroup) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *AffinityGroup) SetName(attr string) {
	p.name = &attr
}

func (p *AffinityGroup) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *AffinityGroup) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *AffinityGroup) SetPositive(attr bool) {
	p.positive = &attr
}

func (p *AffinityGroup) Positive() (bool, bool) {
	if p.positive != nil {
		return *p.positive, true
	}
	var zero bool
	return zero, false
}

func (p *AffinityGroup) MustPositive() bool {
	if p.positive == nil {
		panic("the positive must not be nil, please use Positive() function instead")
	}
	return *p.positive
}

func (p *AffinityGroup) SetPriority(attr float64) {
	p.priority = &attr
}

func (p *AffinityGroup) Priority() (float64, bool) {
	if p.priority != nil {
		return *p.priority, true
	}
	var zero float64
	return zero, false
}

func (p *AffinityGroup) MustPriority() float64 {
	if p.priority == nil {
		panic("the priority must not be nil, please use Priority() function instead")
	}
	return *p.priority
}

func (p *AffinityGroup) SetVmLabels(attr *AffinityLabelSlice) {
	p.vmLabels = attr
}

func (p *AffinityGroup) VmLabels() (*AffinityLabelSlice, bool) {
	if p.vmLabels != nil {
		return p.vmLabels, true
	}
	return nil, false
}

func (p *AffinityGroup) MustVmLabels() *AffinityLabelSlice {
	if p.vmLabels == nil {
		panic("the vmLabels must not be nil, please use VmLabels() function instead")
	}
	return p.vmLabels
}

func (p *AffinityGroup) SetVms(attr *VmSlice) {
	p.vms = attr
}

func (p *AffinityGroup) Vms() (*VmSlice, bool) {
	if p.vms != nil {
		return p.vms, true
	}
	return nil, false
}

func (p *AffinityGroup) MustVms() *VmSlice {
	if p.vms == nil {
		panic("the vms must not be nil, please use Vms() function instead")
	}
	return p.vms
}

// SetVmsRule Generic rule definition for affinity group. Each supported resource type (virtual machine, host) is controlled
// by a separate rule. This allows expressing of rules like: no affinity between defined virtual machines, but hard
// affinity between defined virtual machines and virtual hosts.
func (p *AffinityGroup) SetVmsRule(attr *AffinityRule) {
	p.vmsRule = attr
}

// VmsRule Generic rule definition for affinity group. Each supported resource type (virtual machine, host) is controlled
// by a separate rule. This allows expressing of rules like: no affinity between defined virtual machines, but hard
// affinity between defined virtual machines and virtual hosts.
func (p *AffinityGroup) VmsRule() (*AffinityRule, bool) {
	if p.vmsRule != nil {
		return p.vmsRule, true
	}
	return nil, false
}

// MustVmsRule Generic rule definition for affinity group. Each supported resource type (virtual machine, host) is controlled
// by a separate rule. This allows expressing of rules like: no affinity between defined virtual machines, but hard
// affinity between defined virtual machines and virtual hosts.
func (p *AffinityGroup) MustVmsRule() *AffinityRule {
	if p.vmsRule == nil {
		panic("the vmsRule must not be nil, please use VmsRule() function instead")
	}
	return p.vmsRule
}

// AffinityLabel The affinity label can influence virtual machine scheduling.
// It is most frequently used to create a sub-cluster from the available hosts.
type AffinityLabel struct {
	Struct
	comment                  *string
	description              *string
	hasImplicitAffinityGroup *bool
	hosts                    *HostSlice
	id                       *string
	name                     *string
	readOnly                 *bool
	vms                      *VmSlice
}

func (p *AffinityLabel) SetComment(attr string) {
	p.comment = &attr
}

func (p *AffinityLabel) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *AffinityLabel) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *AffinityLabel) SetDescription(attr string) {
	p.description = &attr
}

func (p *AffinityLabel) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *AffinityLabel) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *AffinityLabel) SetHasImplicitAffinityGroup(attr bool) {
	p.hasImplicitAffinityGroup = &attr
}

func (p *AffinityLabel) HasImplicitAffinityGroup() (bool, bool) {
	if p.hasImplicitAffinityGroup != nil {
		return *p.hasImplicitAffinityGroup, true
	}
	var zero bool
	return zero, false
}

func (p *AffinityLabel) MustHasImplicitAffinityGroup() bool {
	if p.hasImplicitAffinityGroup == nil {
		panic("the hasImplicitAffinityGroup must not be nil, please use HasImplicitAffinityGroup() function instead")
	}
	return *p.hasImplicitAffinityGroup
}

func (p *AffinityLabel) SetHosts(attr *HostSlice) {
	p.hosts = attr
}

func (p *AffinityLabel) Hosts() (*HostSlice, bool) {
	if p.hosts != nil {
		return p.hosts, true
	}
	return nil, false
}

func (p *AffinityLabel) MustHosts() *HostSlice {
	if p.hosts == nil {
		panic("the hosts must not be nil, please use Hosts() function instead")
	}
	return p.hosts
}

func (p *AffinityLabel) SetId(attr string) {
	p.id = &attr
}

func (p *AffinityLabel) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *AffinityLabel) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *AffinityLabel) SetName(attr string) {
	p.name = &attr
}

func (p *AffinityLabel) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *AffinityLabel) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *AffinityLabel) SetReadOnly(attr bool) {
	p.readOnly = &attr
}

func (p *AffinityLabel) ReadOnly() (bool, bool) {
	if p.readOnly != nil {
		return *p.readOnly, true
	}
	var zero bool
	return zero, false
}

func (p *AffinityLabel) MustReadOnly() bool {
	if p.readOnly == nil {
		panic("the readOnly must not be nil, please use ReadOnly() function instead")
	}
	return *p.readOnly
}

func (p *AffinityLabel) SetVms(attr *VmSlice) {
	p.vms = attr
}

func (p *AffinityLabel) Vms() (*VmSlice, bool) {
	if p.vms != nil {
		return p.vms, true
	}
	return nil, false
}

func (p *AffinityLabel) MustVms() *VmSlice {
	if p.vms == nil {
		panic("the vms must not be nil, please use Vms() function instead")
	}
	return p.vms
}

// AffinityRule Generic rule definition for affinity group. Each supported resource type (virtual machine, host) is controlled
// by a separate rule. This allows expressing of rules like: no affinity between defined virtual machines, but hard
// affinity between defined virtual machines and virtual hosts.
type AffinityRule struct {
	Struct
	enabled   *bool
	enforcing *bool
	positive  *bool
}

func (p *AffinityRule) SetEnabled(attr bool) {
	p.enabled = &attr
}

func (p *AffinityRule) Enabled() (bool, bool) {
	if p.enabled != nil {
		return *p.enabled, true
	}
	var zero bool
	return zero, false
}

func (p *AffinityRule) MustEnabled() bool {
	if p.enabled == nil {
		panic("the enabled must not be nil, please use Enabled() function instead")
	}
	return *p.enabled
}

func (p *AffinityRule) SetEnforcing(attr bool) {
	p.enforcing = &attr
}

func (p *AffinityRule) Enforcing() (bool, bool) {
	if p.enforcing != nil {
		return *p.enforcing, true
	}
	var zero bool
	return zero, false
}

func (p *AffinityRule) MustEnforcing() bool {
	if p.enforcing == nil {
		panic("the enforcing must not be nil, please use Enforcing() function instead")
	}
	return *p.enforcing
}

func (p *AffinityRule) SetPositive(attr bool) {
	p.positive = &attr
}

func (p *AffinityRule) Positive() (bool, bool) {
	if p.positive != nil {
		return *p.positive, true
	}
	var zero bool
	return zero, false
}

func (p *AffinityRule) MustPositive() bool {
	if p.positive == nil {
		panic("the positive must not be nil, please use Positive() function instead")
	}
	return *p.positive
}

// Agent Type representing a fence agent.
type Agent struct {
	Struct
	address        *string
	comment        *string
	concurrent     *bool
	description    *string
	encryptOptions *bool
	host           *Host
	id             *string
	name           *string
	options        *OptionSlice
	order          *int64
	password       *string
	port           *int64
	type_          *string
	username       *string
}

func (p *Agent) SetAddress(attr string) {
	p.address = &attr
}

func (p *Agent) Address() (string, bool) {
	if p.address != nil {
		return *p.address, true
	}
	var zero string
	return zero, false
}

func (p *Agent) MustAddress() string {
	if p.address == nil {
		panic("the address must not be nil, please use Address() function instead")
	}
	return *p.address
}

func (p *Agent) SetComment(attr string) {
	p.comment = &attr
}

func (p *Agent) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *Agent) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *Agent) SetConcurrent(attr bool) {
	p.concurrent = &attr
}

func (p *Agent) Concurrent() (bool, bool) {
	if p.concurrent != nil {
		return *p.concurrent, true
	}
	var zero bool
	return zero, false
}

func (p *Agent) MustConcurrent() bool {
	if p.concurrent == nil {
		panic("the concurrent must not be nil, please use Concurrent() function instead")
	}
	return *p.concurrent
}

func (p *Agent) SetDescription(attr string) {
	p.description = &attr
}

func (p *Agent) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *Agent) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *Agent) SetEncryptOptions(attr bool) {
	p.encryptOptions = &attr
}

func (p *Agent) EncryptOptions() (bool, bool) {
	if p.encryptOptions != nil {
		return *p.encryptOptions, true
	}
	var zero bool
	return zero, false
}

func (p *Agent) MustEncryptOptions() bool {
	if p.encryptOptions == nil {
		panic("the encryptOptions must not be nil, please use EncryptOptions() function instead")
	}
	return *p.encryptOptions
}

// SetHost Type representing a host.
func (p *Agent) SetHost(attr *Host) {
	p.host = attr
}

// Host Type representing a host.
func (p *Agent) Host() (*Host, bool) {
	if p.host != nil {
		return p.host, true
	}
	return nil, false
}

// MustHost Type representing a host.
func (p *Agent) MustHost() *Host {
	if p.host == nil {
		panic("the host must not be nil, please use Host() function instead")
	}
	return p.host
}

func (p *Agent) SetId(attr string) {
	p.id = &attr
}

func (p *Agent) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *Agent) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *Agent) SetName(attr string) {
	p.name = &attr
}

func (p *Agent) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *Agent) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *Agent) SetOptions(attr *OptionSlice) {
	p.options = attr
}

func (p *Agent) Options() (*OptionSlice, bool) {
	if p.options != nil {
		return p.options, true
	}
	return nil, false
}

func (p *Agent) MustOptions() *OptionSlice {
	if p.options == nil {
		panic("the options must not be nil, please use Options() function instead")
	}
	return p.options
}

func (p *Agent) SetOrder(attr int64) {
	p.order = &attr
}

func (p *Agent) Order() (int64, bool) {
	if p.order != nil {
		return *p.order, true
	}
	var zero int64
	return zero, false
}

func (p *Agent) MustOrder() int64 {
	if p.order == nil {
		panic("the order must not be nil, please use Order() function instead")
	}
	return *p.order
}

func (p *Agent) SetPassword(attr string) {
	p.password = &attr
}

func (p *Agent) Password() (string, bool) {
	if p.password != nil {
		return *p.password, true
	}
	var zero string
	return zero, false
}

func (p *Agent) MustPassword() string {
	if p.password == nil {
		panic("the password must not be nil, please use Password() function instead")
	}
	return *p.password
}

func (p *Agent) SetPort(attr int64) {
	p.port = &attr
}

func (p *Agent) Port() (int64, bool) {
	if p.port != nil {
		return *p.port, true
	}
	var zero int64
	return zero, false
}

func (p *Agent) MustPort() int64 {
	if p.port == nil {
		panic("the port must not be nil, please use Port() function instead")
	}
	return *p.port
}

func (p *Agent) SetType(attr string) {
	p.type_ = &attr
}

func (p *Agent) Type() (string, bool) {
	if p.type_ != nil {
		return *p.type_, true
	}
	var zero string
	return zero, false
}

func (p *Agent) MustType() string {
	if p.type_ == nil {
		panic("the type_ must not be nil, please use Type() function instead")
	}
	return *p.type_
}

func (p *Agent) SetUsername(attr string) {
	p.username = &attr
}

func (p *Agent) Username() (string, bool) {
	if p.username != nil {
		return *p.username, true
	}
	var zero string
	return zero, false
}

func (p *Agent) MustUsername() string {
	if p.username == nil {
		panic("the username must not be nil, please use Username() function instead")
	}
	return *p.username
}

// AgentConfiguration Deprecated Agent configuration settings.
//
// Ignored, because the deployment of OpenStack Neutron agent is dropped since {product-name} 4.4.0.
// The deployment of OpenStack hosts can be done by Red Hat OpenStack Platform Director or TripleO.
type AgentConfiguration struct {
	Struct
	address         *string
	brokerType      *MessageBrokerType
	networkMappings *string
	password        *string
	port            *int64
	username        *string
}

func (p *AgentConfiguration) SetAddress(attr string) {
	p.address = &attr
}

func (p *AgentConfiguration) Address() (string, bool) {
	if p.address != nil {
		return *p.address, true
	}
	var zero string
	return zero, false
}

func (p *AgentConfiguration) MustAddress() string {
	if p.address == nil {
		panic("the address must not be nil, please use Address() function instead")
	}
	return *p.address
}

// SetBrokerType Deprecated Message Broker type.
//
// Ignored, because the deployment of OpenStack Neutron agent is dropped since {product-name} 4.4.0.
func (p *AgentConfiguration) SetBrokerType(attr MessageBrokerType) {
	p.brokerType = &attr
}

// BrokerType Deprecated Message Broker type.
//
// Ignored, because the deployment of OpenStack Neutron agent is dropped since {product-name} 4.4.0.
func (p *AgentConfiguration) BrokerType() (MessageBrokerType, bool) {
	if p.brokerType != nil {
		return *p.brokerType, true
	}
	var zero MessageBrokerType
	return zero, false
}

// MustBrokerType Deprecated Message Broker type.
//
// Ignored, because the deployment of OpenStack Neutron agent is dropped since {product-name} 4.4.0.
func (p *AgentConfiguration) MustBrokerType() MessageBrokerType {
	if p.brokerType == nil {
		panic("the brokerType must not be nil, please use BrokerType() function instead")
	}
	return *p.brokerType
}

func (p *AgentConfiguration) SetNetworkMappings(attr string) {
	p.networkMappings = &attr
}

func (p *AgentConfiguration) NetworkMappings() (string, bool) {
	if p.networkMappings != nil {
		return *p.networkMappings, true
	}
	var zero string
	return zero, false
}

func (p *AgentConfiguration) MustNetworkMappings() string {
	if p.networkMappings == nil {
		panic("the networkMappings must not be nil, please use NetworkMappings() function instead")
	}
	return *p.networkMappings
}

func (p *AgentConfiguration) SetPassword(attr string) {
	p.password = &attr
}

func (p *AgentConfiguration) Password() (string, bool) {
	if p.password != nil {
		return *p.password, true
	}
	var zero string
	return zero, false
}

func (p *AgentConfiguration) MustPassword() string {
	if p.password == nil {
		panic("the password must not be nil, please use Password() function instead")
	}
	return *p.password
}

func (p *AgentConfiguration) SetPort(attr int64) {
	p.port = &attr
}

func (p *AgentConfiguration) Port() (int64, bool) {
	if p.port != nil {
		return *p.port, true
	}
	var zero int64
	return zero, false
}

func (p *AgentConfiguration) MustPort() int64 {
	if p.port == nil {
		panic("the port must not be nil, please use Port() function instead")
	}
	return *p.port
}

func (p *AgentConfiguration) SetUsername(attr string) {
	p.username = &attr
}

func (p *AgentConfiguration) Username() (string, bool) {
	if p.username != nil {
		return *p.username, true
	}
	var zero string
	return zero, false
}

func (p *AgentConfiguration) MustUsername() string {
	if p.username == nil {
		panic("the username must not be nil, please use Username() function instead")
	}
	return *p.username
}

// Api This type contains the information returned by the root service of the API.
//
// To get that information send a request like this:
//
// ....
// GET /ovirt-engine/api
// ....
//
// The result will be like this:
//
// [source,xml]
// ----
// <api>
//   <link rel="hosts" href="/ovirt-engine/api/hosts"/>
//   <link rel="vms" href="/ovirt-engine/api/vms"/>
//   ...
//   <product_info>
//     <name>oVirt Engine</name>
//     <vendor>ovirt.org</vendor>
//     <version>
//       <build>0</build>
//       <full_version>4.1.0_master</full_version>
//       <major>4</major>
//       <minor>1</minor>
//       <revision>0</revision>
//     </version>
//   </product_info>
//   <special_objects>
//     <link rel="templates/blank" href="..."/>
//     <link rel="tags/root" href="..."/>
//   </special_objects>
//   <summary>
//     <vms>
//       <total>10</total>
//       <active>3</active>
//     </vms>
//     <hosts>
//       <total>2</total>
//       <active>2</active>
//     </hosts>
//     <users>
//       <total>8</total>
//       <active>2</active>
//     </users>
//     <storage_domains>
//       <total>2</total>
//       <active>2</active>
//     </storage_domains>
//   </summary>
//   <time>2016-12-12T12:22:25.866+01:00</time>
// </api>
// ----
type Api struct {
	Struct
	authenticatedUser *User
	effectiveUser     *User
	productInfo       *ProductInfo
	specialObjects    *SpecialObjects
	summary           *ApiSummary
	time              *time.Time
}

// SetAuthenticatedUser Represents a user in the system.
func (p *Api) SetAuthenticatedUser(attr *User) {
	p.authenticatedUser = attr
}

// AuthenticatedUser Represents a user in the system.
func (p *Api) AuthenticatedUser() (*User, bool) {
	if p.authenticatedUser != nil {
		return p.authenticatedUser, true
	}
	return nil, false
}

// MustAuthenticatedUser Represents a user in the system.
func (p *Api) MustAuthenticatedUser() *User {
	if p.authenticatedUser == nil {
		panic("the authenticatedUser must not be nil, please use AuthenticatedUser() function instead")
	}
	return p.authenticatedUser
}

// SetEffectiveUser Represents a user in the system.
func (p *Api) SetEffectiveUser(attr *User) {
	p.effectiveUser = attr
}

// EffectiveUser Represents a user in the system.
func (p *Api) EffectiveUser() (*User, bool) {
	if p.effectiveUser != nil {
		return p.effectiveUser, true
	}
	return nil, false
}

// MustEffectiveUser Represents a user in the system.
func (p *Api) MustEffectiveUser() *User {
	if p.effectiveUser == nil {
		panic("the effectiveUser must not be nil, please use EffectiveUser() function instead")
	}
	return p.effectiveUser
}

// SetProductInfo Product information.
//
// The entry point contains a `product_info` element to help an API user determine the legitimacy of the
// {product-name} environment. This includes the name of the product, the `vendor` and the `version`.
//
// Verify a genuine {product-name} environment
//
// The follow elements identify a genuine {product-name} environment:
//
// [source]
// ----
// <api>
// ...
// <product_info>
//   <name>oVirt Engine</name>
//   <vendor>ovirt.org</vendor>
//   <version>
//     <build>0</build>
//     <full_version>4.1.0_master</full_version>
//     <major>4</major>
//     <minor>1</minor>
//     <revision>0</revision>
//   </version>
// </product_info>
// ...
// </api>
// ----
func (p *Api) SetProductInfo(attr *ProductInfo) {
	p.productInfo = attr
}

// ProductInfo Product information.
//
// The entry point contains a `product_info` element to help an API user determine the legitimacy of the
// {product-name} environment. This includes the name of the product, the `vendor` and the `version`.
//
// Verify a genuine {product-name} environment
//
// The follow elements identify a genuine {product-name} environment:
//
// [source]
// ----
// <api>
// ...
// <product_info>
//   <name>oVirt Engine</name>
//   <vendor>ovirt.org</vendor>
//   <version>
//     <build>0</build>
//     <full_version>4.1.0_master</full_version>
//     <major>4</major>
//     <minor>1</minor>
//     <revision>0</revision>
//   </version>
// </product_info>
// ...
// </api>
// ----
func (p *Api) ProductInfo() (*ProductInfo, bool) {
	if p.productInfo != nil {
		return p.productInfo, true
	}
	return nil, false
}

// MustProductInfo Product information.
//
// The entry point contains a `product_info` element to help an API user determine the legitimacy of the
// {product-name} environment. This includes the name of the product, the `vendor` and the `version`.
//
// Verify a genuine {product-name} environment
//
// The follow elements identify a genuine {product-name} environment:
//
// [source]
// ----
// <api>
// ...
// <product_info>
//   <name>oVirt Engine</name>
//   <vendor>ovirt.org</vendor>
//   <version>
//     <build>0</build>
//     <full_version>4.1.0_master</full_version>
//     <major>4</major>
//     <minor>1</minor>
//     <revision>0</revision>
//   </version>
// </product_info>
// ...
// </api>
// ----
func (p *Api) MustProductInfo() *ProductInfo {
	if p.productInfo == nil {
		panic("the productInfo must not be nil, please use ProductInfo() function instead")
	}
	return p.productInfo
}

// SetSpecialObjects This type contains references to special objects, such as blank templates and the root of a hierarchy of tags.
func (p *Api) SetSpecialObjects(attr *SpecialObjects) {
	p.specialObjects = attr
}

// SpecialObjects This type contains references to special objects, such as blank templates and the root of a hierarchy of tags.
func (p *Api) SpecialObjects() (*SpecialObjects, bool) {
	if p.specialObjects != nil {
		return p.specialObjects, true
	}
	return nil, false
}

// MustSpecialObjects This type contains references to special objects, such as blank templates and the root of a hierarchy of tags.
func (p *Api) MustSpecialObjects() *SpecialObjects {
	if p.specialObjects == nil {
		panic("the specialObjects must not be nil, please use SpecialObjects() function instead")
	}
	return p.specialObjects
}

// SetSummary A summary containing the total number of relevant objects, such as virtual machines, hosts, and storage domains.
func (p *Api) SetSummary(attr *ApiSummary) {
	p.summary = attr
}

// Summary A summary containing the total number of relevant objects, such as virtual machines, hosts, and storage domains.
func (p *Api) Summary() (*ApiSummary, bool) {
	if p.summary != nil {
		return p.summary, true
	}
	return nil, false
}

// MustSummary A summary containing the total number of relevant objects, such as virtual machines, hosts, and storage domains.
func (p *Api) MustSummary() *ApiSummary {
	if p.summary == nil {
		panic("the summary must not be nil, please use Summary() function instead")
	}
	return p.summary
}

func (p *Api) SetTime(attr time.Time) {
	p.time = &attr
}

func (p *Api) Time() (time.Time, bool) {
	if p.time != nil {
		return *p.time, true
	}
	var zero time.Time
	return zero, false
}

func (p *Api) MustTime() time.Time {
	if p.time == nil {
		panic("the time must not be nil, please use Time() function instead")
	}
	return *p.time
}

// ApiSummary A summary containing the total number of relevant objects, such as virtual machines, hosts, and storage domains.
type ApiSummary struct {
	Struct
	hosts          *ApiSummaryItem
	storageDomains *ApiSummaryItem
	users          *ApiSummaryItem
	vms            *ApiSummaryItem
}

// SetHosts This type contains an item of the API summary. Each item contains the total and active number of some kind of
// object.
func (p *ApiSummary) SetHosts(attr *ApiSummaryItem) {
	p.hosts = attr
}

// Hosts This type contains an item of the API summary. Each item contains the total and active number of some kind of
// object.
func (p *ApiSummary) Hosts() (*ApiSummaryItem, bool) {
	if p.hosts != nil {
		return p.hosts, true
	}
	return nil, false
}

// MustHosts This type contains an item of the API summary. Each item contains the total and active number of some kind of
// object.
func (p *ApiSummary) MustHosts() *ApiSummaryItem {
	if p.hosts == nil {
		panic("the hosts must not be nil, please use Hosts() function instead")
	}
	return p.hosts
}

// SetStorageDomains This type contains an item of the API summary. Each item contains the total and active number of some kind of
// object.
func (p *ApiSummary) SetStorageDomains(attr *ApiSummaryItem) {
	p.storageDomains = attr
}

// StorageDomains This type contains an item of the API summary. Each item contains the total and active number of some kind of
// object.
func (p *ApiSummary) StorageDomains() (*ApiSummaryItem, bool) {
	if p.storageDomains != nil {
		return p.storageDomains, true
	}
	return nil, false
}

// MustStorageDomains This type contains an item of the API summary. Each item contains the total and active number of some kind of
// object.
func (p *ApiSummary) MustStorageDomains() *ApiSummaryItem {
	if p.storageDomains == nil {
		panic("the storageDomains must not be nil, please use StorageDomains() function instead")
	}
	return p.storageDomains
}

// SetUsers This type contains an item of the API summary. Each item contains the total and active number of some kind of
// object.
func (p *ApiSummary) SetUsers(attr *ApiSummaryItem) {
	p.users = attr
}

// Users This type contains an item of the API summary. Each item contains the total and active number of some kind of
// object.
func (p *ApiSummary) Users() (*ApiSummaryItem, bool) {
	if p.users != nil {
		return p.users, true
	}
	return nil, false
}

// MustUsers This type contains an item of the API summary. Each item contains the total and active number of some kind of
// object.
func (p *ApiSummary) MustUsers() *ApiSummaryItem {
	if p.users == nil {
		panic("the users must not be nil, please use Users() function instead")
	}
	return p.users
}

// SetVms This type contains an item of the API summary. Each item contains the total and active number of some kind of
// object.
func (p *ApiSummary) SetVms(attr *ApiSummaryItem) {
	p.vms = attr
}

// Vms This type contains an item of the API summary. Each item contains the total and active number of some kind of
// object.
func (p *ApiSummary) Vms() (*ApiSummaryItem, bool) {
	if p.vms != nil {
		return p.vms, true
	}
	return nil, false
}

// MustVms This type contains an item of the API summary. Each item contains the total and active number of some kind of
// object.
func (p *ApiSummary) MustVms() *ApiSummaryItem {
	if p.vms == nil {
		panic("the vms must not be nil, please use Vms() function instead")
	}
	return p.vms
}

// ApiSummaryItem This type contains an item of the API summary. Each item contains the total and active number of some kind of
// object.
type ApiSummaryItem struct {
	Struct
	active *int64
	total  *int64
}

func (p *ApiSummaryItem) SetActive(attr int64) {
	p.active = &attr
}

func (p *ApiSummaryItem) Active() (int64, bool) {
	if p.active != nil {
		return *p.active, true
	}
	var zero int64
	return zero, false
}

func (p *ApiSummaryItem) MustActive() int64 {
	if p.active == nil {
		panic("the active must not be nil, please use Active() function instead")
	}
	return *p.active
}

func (p *ApiSummaryItem) SetTotal(attr int64) {
	p.total = &attr
}

func (p *ApiSummaryItem) Total() (int64, bool) {
	if p.total != nil {
		return *p.total, true
	}
	var zero int64
	return zero, false
}

func (p *ApiSummaryItem) MustTotal() int64 {
	if p.total == nil {
		panic("the total must not be nil, please use Total() function instead")
	}
	return *p.total
}

// Application Represents an application installed on a virtual machine. Applications are reported by the guest agent, if you
// deploy one on the virtual machine operating system.
//
// To get that information send a request like this:
//
// ....
// GET /ovirt-engine/api/vms/123/applications/456
// ....
//
// The result will be like this:
//
// [source,xml]
// ----
// <application href="/ovirt-engine/api/vms/123/applications/456" id="456">
//   <name>application-test-1.0.0-0.el7</name>
//   <vm href="/ovirt-engine/api/vms/123" id="123"/>
// </application>
// ----
type Application struct {
	Struct
	comment     *string
	description *string
	id          *string
	name        *string
	vm          *Vm
}

func (p *Application) SetComment(attr string) {
	p.comment = &attr
}

func (p *Application) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *Application) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *Application) SetDescription(attr string) {
	p.description = &attr
}

func (p *Application) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *Application) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *Application) SetId(attr string) {
	p.id = &attr
}

func (p *Application) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *Application) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *Application) SetName(attr string) {
	p.name = &attr
}

func (p *Application) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *Application) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

// SetVm Represents a virtual machine.
func (p *Application) SetVm(attr *Vm) {
	p.vm = attr
}

// Vm Represents a virtual machine.
func (p *Application) Vm() (*Vm, bool) {
	if p.vm != nil {
		return p.vm, true
	}
	return nil, false
}

// MustVm Represents a virtual machine.
func (p *Application) MustVm() *Vm {
	if p.vm == nil {
		panic("the vm must not be nil, please use Vm() function instead")
	}
	return p.vm
}

type AuthorizedKey struct {
	Struct
	comment     *string
	description *string
	id          *string
	key         *string
	name        *string
	user        *User
}

func (p *AuthorizedKey) SetComment(attr string) {
	p.comment = &attr
}

func (p *AuthorizedKey) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *AuthorizedKey) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *AuthorizedKey) SetDescription(attr string) {
	p.description = &attr
}

func (p *AuthorizedKey) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *AuthorizedKey) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *AuthorizedKey) SetId(attr string) {
	p.id = &attr
}

func (p *AuthorizedKey) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *AuthorizedKey) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *AuthorizedKey) SetKey(attr string) {
	p.key = &attr
}

func (p *AuthorizedKey) Key() (string, bool) {
	if p.key != nil {
		return *p.key, true
	}
	var zero string
	return zero, false
}

func (p *AuthorizedKey) MustKey() string {
	if p.key == nil {
		panic("the key must not be nil, please use Key() function instead")
	}
	return *p.key
}

func (p *AuthorizedKey) SetName(attr string) {
	p.name = &attr
}

func (p *AuthorizedKey) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *AuthorizedKey) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

// SetUser Represents a user in the system.
func (p *AuthorizedKey) SetUser(attr *User) {
	p.user = attr
}

// User Represents a user in the system.
func (p *AuthorizedKey) User() (*User, bool) {
	if p.user != nil {
		return p.user, true
	}
	return nil, false
}

// MustUser Represents a user in the system.
func (p *AuthorizedKey) MustUser() *User {
	if p.user == nil {
		panic("the user must not be nil, please use User() function instead")
	}
	return p.user
}

type Backup struct {
	Struct
	comment          *string
	creationDate     *time.Time
	description      *string
	disks            *DiskSlice
	fromCheckpointId *string
	host             *Host
	id               *string
	name             *string
	phase            *BackupPhase
	toCheckpointId   *string
	vm               *Vm
}

func (p *Backup) SetComment(attr string) {
	p.comment = &attr
}

func (p *Backup) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *Backup) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *Backup) SetCreationDate(attr time.Time) {
	p.creationDate = &attr
}

func (p *Backup) CreationDate() (time.Time, bool) {
	if p.creationDate != nil {
		return *p.creationDate, true
	}
	var zero time.Time
	return zero, false
}

func (p *Backup) MustCreationDate() time.Time {
	if p.creationDate == nil {
		panic("the creationDate must not be nil, please use CreationDate() function instead")
	}
	return *p.creationDate
}

func (p *Backup) SetDescription(attr string) {
	p.description = &attr
}

func (p *Backup) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *Backup) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *Backup) SetDisks(attr *DiskSlice) {
	p.disks = attr
}

func (p *Backup) Disks() (*DiskSlice, bool) {
	if p.disks != nil {
		return p.disks, true
	}
	return nil, false
}

func (p *Backup) MustDisks() *DiskSlice {
	if p.disks == nil {
		panic("the disks must not be nil, please use Disks() function instead")
	}
	return p.disks
}

func (p *Backup) SetFromCheckpointId(attr string) {
	p.fromCheckpointId = &attr
}

func (p *Backup) FromCheckpointId() (string, bool) {
	if p.fromCheckpointId != nil {
		return *p.fromCheckpointId, true
	}
	var zero string
	return zero, false
}

func (p *Backup) MustFromCheckpointId() string {
	if p.fromCheckpointId == nil {
		panic("the fromCheckpointId must not be nil, please use FromCheckpointId() function instead")
	}
	return *p.fromCheckpointId
}

// SetHost Type representing a host.
func (p *Backup) SetHost(attr *Host) {
	p.host = attr
}

// Host Type representing a host.
func (p *Backup) Host() (*Host, bool) {
	if p.host != nil {
		return p.host, true
	}
	return nil, false
}

// MustHost Type representing a host.
func (p *Backup) MustHost() *Host {
	if p.host == nil {
		panic("the host must not be nil, please use Host() function instead")
	}
	return p.host
}

func (p *Backup) SetId(attr string) {
	p.id = &attr
}

func (p *Backup) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *Backup) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *Backup) SetName(attr string) {
	p.name = &attr
}

func (p *Backup) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *Backup) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *Backup) SetPhase(attr BackupPhase) {
	p.phase = &attr
}

func (p *Backup) Phase() (BackupPhase, bool) {
	if p.phase != nil {
		return *p.phase, true
	}
	var zero BackupPhase
	return zero, false
}

func (p *Backup) MustPhase() BackupPhase {
	if p.phase == nil {
		panic("the phase must not be nil, please use Phase() function instead")
	}
	return *p.phase
}

func (p *Backup) SetToCheckpointId(attr string) {
	p.toCheckpointId = &attr
}

func (p *Backup) ToCheckpointId() (string, bool) {
	if p.toCheckpointId != nil {
		return *p.toCheckpointId, true
	}
	var zero string
	return zero, false
}

func (p *Backup) MustToCheckpointId() string {
	if p.toCheckpointId == nil {
		panic("the toCheckpointId must not be nil, please use ToCheckpointId() function instead")
	}
	return *p.toCheckpointId
}

// SetVm Represents a virtual machine.
func (p *Backup) SetVm(attr *Vm) {
	p.vm = attr
}

// Vm Represents a virtual machine.
func (p *Backup) Vm() (*Vm, bool) {
	if p.vm != nil {
		return p.vm, true
	}
	return nil, false
}

// MustVm Represents a virtual machine.
func (p *Backup) MustVm() *Vm {
	if p.vm == nil {
		panic("the vm must not be nil, please use Vm() function instead")
	}
	return p.vm
}

type Balance struct {
	Struct
	comment              *string
	description          *string
	id                   *string
	name                 *string
	schedulingPolicy     *SchedulingPolicy
	schedulingPolicyUnit *SchedulingPolicyUnit
}

func (p *Balance) SetComment(attr string) {
	p.comment = &attr
}

func (p *Balance) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *Balance) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *Balance) SetDescription(attr string) {
	p.description = &attr
}

func (p *Balance) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *Balance) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *Balance) SetId(attr string) {
	p.id = &attr
}

func (p *Balance) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *Balance) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *Balance) SetName(attr string) {
	p.name = &attr
}

func (p *Balance) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *Balance) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *Balance) SetSchedulingPolicy(attr *SchedulingPolicy) {
	p.schedulingPolicy = attr
}

func (p *Balance) SchedulingPolicy() (*SchedulingPolicy, bool) {
	if p.schedulingPolicy != nil {
		return p.schedulingPolicy, true
	}
	return nil, false
}

func (p *Balance) MustSchedulingPolicy() *SchedulingPolicy {
	if p.schedulingPolicy == nil {
		panic("the schedulingPolicy must not be nil, please use SchedulingPolicy() function instead")
	}
	return p.schedulingPolicy
}

func (p *Balance) SetSchedulingPolicyUnit(attr *SchedulingPolicyUnit) {
	p.schedulingPolicyUnit = attr
}

func (p *Balance) SchedulingPolicyUnit() (*SchedulingPolicyUnit, bool) {
	if p.schedulingPolicyUnit != nil {
		return p.schedulingPolicyUnit, true
	}
	return nil, false
}

func (p *Balance) MustSchedulingPolicyUnit() *SchedulingPolicyUnit {
	if p.schedulingPolicyUnit == nil {
		panic("the schedulingPolicyUnit must not be nil, please use SchedulingPolicyUnit() function instead")
	}
	return p.schedulingPolicyUnit
}

type Bios struct {
	Struct
	bootMenu *BootMenu
	type_    *BiosType
}

// SetBootMenu Represents boot menu configuration
// for virtual machines and templates.
func (p *Bios) SetBootMenu(attr *BootMenu) {
	p.bootMenu = attr
}

// BootMenu Represents boot menu configuration
// for virtual machines and templates.
func (p *Bios) BootMenu() (*BootMenu, bool) {
	if p.bootMenu != nil {
		return p.bootMenu, true
	}
	return nil, false
}

// MustBootMenu Represents boot menu configuration
// for virtual machines and templates.
func (p *Bios) MustBootMenu() *BootMenu {
	if p.bootMenu == nil {
		panic("the bootMenu must not be nil, please use BootMenu() function instead")
	}
	return p.bootMenu
}

// SetType Type representing a chipset and a BIOS type combination.
func (p *Bios) SetType(attr BiosType) {
	p.type_ = &attr
}

// Type Type representing a chipset and a BIOS type combination.
func (p *Bios) Type() (BiosType, bool) {
	if p.type_ != nil {
		return *p.type_, true
	}
	var zero BiosType
	return zero, false
}

// MustType Type representing a chipset and a BIOS type combination.
func (p *Bios) MustType() BiosType {
	if p.type_ == nil {
		panic("the type_ must not be nil, please use Type() function instead")
	}
	return *p.type_
}

type BlockStatistic struct {
	Struct
	statistics *StatisticSlice
}

func (p *BlockStatistic) SetStatistics(attr *StatisticSlice) {
	p.statistics = attr
}

func (p *BlockStatistic) Statistics() (*StatisticSlice, bool) {
	if p.statistics != nil {
		return p.statistics, true
	}
	return nil, false
}

func (p *BlockStatistic) MustStatistics() *StatisticSlice {
	if p.statistics == nil {
		panic("the statistics must not be nil, please use Statistics() function instead")
	}
	return p.statistics
}

// Bonding Represents a network interfaces bond.
type Bonding struct {
	Struct
	activeSlave  *HostNic
	adPartnerMac *Mac
	options      *OptionSlice
	slaves       *HostNicSlice
}

// SetActiveSlave Represents a host NIC.
//
// For example, the XML representation of a host NIC looks like this:
//
// [source,xml]
// ----
// <host_nic href="/ovirt-engine/api/hosts/123/nics/456" id="456">
//   <name>eth0</name>
//   <boot_protocol>static</boot_protocol>
//   <bridged>true</bridged>
//   <custom_configuration>true</custom_configuration>
//   <ip>
//     <address>192.168.122.39</address>
//     <gateway>192.168.122.1</gateway>
//     <netmask>255.255.255.0</netmask>
//     <version>v4</version>
//   </ip>
//   <ipv6>
//     <gateway>::</gateway>
//     <version>v6</version>
//   </ipv6>
//   <ipv6_boot_protocol>none</ipv6_boot_protocol>
//   <mac>
//     <address>52:54:00:0c:79:1d</address>
//   </mac>
//   <mtu>1500</mtu>
//   <status>up</status>
// </host_nic>
// ----
//
// A bonded interface is represented as a <<types/host_nic, HostNic>> object
// containing the `bonding` and `slaves` attributes.
//
// For example, the XML representation of a bonded host NIC looks like this:
//
// [source,xml]
// ----
// <host_nic href="/ovirt-engine/api/hosts/123/nics/456" id="456">
//   <name>bond0</name>
//   <mac address="00:00:00:00:00:00"/>
//   <ip>
//     <address>192.168.122.39</address>
//     <gateway>192.168.122.1</gateway>
//     <netmask>255.255.255.0</netmask>
//     <version>v4</version>
//   </ip>
//   <boot_protocol>dhcp</boot_protocol>
//   <bonding>
//     <options>
//       <option>
//         <name>mode</name>
//         <value>4</value>
//         <type>Dynamic link aggregation (802.3ad)</type>
//       </option>
//       <option>
//         <name>miimon</name>
//         <value>100</value>
//       </option>
//     </options>
//     <slaves>
//       <host_nic id="123"/>
//       <host_nic id="456"/>
//     </slaves>
//   </bonding>
//   <mtu>1500</mtu>
//   <bridged>true</bridged>
//   <custom_configuration>false</custom_configuration>
// </host_nic>
// ----
func (p *Bonding) SetActiveSlave(attr *HostNic) {
	p.activeSlave = attr
}

// ActiveSlave Represents a host NIC.
//
// For example, the XML representation of a host NIC looks like this:
//
// [source,xml]
// ----
// <host_nic href="/ovirt-engine/api/hosts/123/nics/456" id="456">
//   <name>eth0</name>
//   <boot_protocol>static</boot_protocol>
//   <bridged>true</bridged>
//   <custom_configuration>true</custom_configuration>
//   <ip>
//     <address>192.168.122.39</address>
//     <gateway>192.168.122.1</gateway>
//     <netmask>255.255.255.0</netmask>
//     <version>v4</version>
//   </ip>
//   <ipv6>
//     <gateway>::</gateway>
//     <version>v6</version>
//   </ipv6>
//   <ipv6_boot_protocol>none</ipv6_boot_protocol>
//   <mac>
//     <address>52:54:00:0c:79:1d</address>
//   </mac>
//   <mtu>1500</mtu>
//   <status>up</status>
// </host_nic>
// ----
//
// A bonded interface is represented as a <<types/host_nic, HostNic>> object
// containing the `bonding` and `slaves` attributes.
//
// For example, the XML representation of a bonded host NIC looks like this:
//
// [source,xml]
// ----
// <host_nic href="/ovirt-engine/api/hosts/123/nics/456" id="456">
//   <name>bond0</name>
//   <mac address="00:00:00:00:00:00"/>
//   <ip>
//     <address>192.168.122.39</address>
//     <gateway>192.168.122.1</gateway>
//     <netmask>255.255.255.0</netmask>
//     <version>v4</version>
//   </ip>
//   <boot_protocol>dhcp</boot_protocol>
//   <bonding>
//     <options>
//       <option>
//         <name>mode</name>
//         <value>4</value>
//         <type>Dynamic link aggregation (802.3ad)</type>
//       </option>
//       <option>
//         <name>miimon</name>
//         <value>100</value>
//       </option>
//     </options>
//     <slaves>
//       <host_nic id="123"/>
//       <host_nic id="456"/>
//     </slaves>
//   </bonding>
//   <mtu>1500</mtu>
//   <bridged>true</bridged>
//   <custom_configuration>false</custom_configuration>
// </host_nic>
// ----
func (p *Bonding) ActiveSlave() (*HostNic, bool) {
	if p.activeSlave != nil {
		return p.activeSlave, true
	}
	return nil, false
}

// MustActiveSlave Represents a host NIC.
//
// For example, the XML representation of a host NIC looks like this:
//
// [source,xml]
// ----
// <host_nic href="/ovirt-engine/api/hosts/123/nics/456" id="456">
//   <name>eth0</name>
//   <boot_protocol>static</boot_protocol>
//   <bridged>true</bridged>
//   <custom_configuration>true</custom_configuration>
//   <ip>
//     <address>192.168.122.39</address>
//     <gateway>192.168.122.1</gateway>
//     <netmask>255.255.255.0</netmask>
//     <version>v4</version>
//   </ip>
//   <ipv6>
//     <gateway>::</gateway>
//     <version>v6</version>
//   </ipv6>
//   <ipv6_boot_protocol>none</ipv6_boot_protocol>
//   <mac>
//     <address>52:54:00:0c:79:1d</address>
//   </mac>
//   <mtu>1500</mtu>
//   <status>up</status>
// </host_nic>
// ----
//
// A bonded interface is represented as a <<types/host_nic, HostNic>> object
// containing the `bonding` and `slaves` attributes.
//
// For example, the XML representation of a bonded host NIC looks like this:
//
// [source,xml]
// ----
// <host_nic href="/ovirt-engine/api/hosts/123/nics/456" id="456">
//   <name>bond0</name>
//   <mac address="00:00:00:00:00:00"/>
//   <ip>
//     <address>192.168.122.39</address>
//     <gateway>192.168.122.1</gateway>
//     <netmask>255.255.255.0</netmask>
//     <version>v4</version>
//   </ip>
//   <boot_protocol>dhcp</boot_protocol>
//   <bonding>
//     <options>
//       <option>
//         <name>mode</name>
//         <value>4</value>
//         <type>Dynamic link aggregation (802.3ad)</type>
//       </option>
//       <option>
//         <name>miimon</name>
//         <value>100</value>
//       </option>
//     </options>
//     <slaves>
//       <host_nic id="123"/>
//       <host_nic id="456"/>
//     </slaves>
//   </bonding>
//   <mtu>1500</mtu>
//   <bridged>true</bridged>
//   <custom_configuration>false</custom_configuration>
// </host_nic>
// ----
func (p *Bonding) MustActiveSlave() *HostNic {
	if p.activeSlave == nil {
		panic("the activeSlave must not be nil, please use ActiveSlave() function instead")
	}
	return p.activeSlave
}

// SetAdPartnerMac Represents a MAC address of a virtual network interface.
func (p *Bonding) SetAdPartnerMac(attr *Mac) {
	p.adPartnerMac = attr
}

// AdPartnerMac Represents a MAC address of a virtual network interface.
func (p *Bonding) AdPartnerMac() (*Mac, bool) {
	if p.adPartnerMac != nil {
		return p.adPartnerMac, true
	}
	return nil, false
}

// MustAdPartnerMac Represents a MAC address of a virtual network interface.
func (p *Bonding) MustAdPartnerMac() *Mac {
	if p.adPartnerMac == nil {
		panic("the adPartnerMac must not be nil, please use AdPartnerMac() function instead")
	}
	return p.adPartnerMac
}

func (p *Bonding) SetOptions(attr *OptionSlice) {
	p.options = attr
}

func (p *Bonding) Options() (*OptionSlice, bool) {
	if p.options != nil {
		return p.options, true
	}
	return nil, false
}

func (p *Bonding) MustOptions() *OptionSlice {
	if p.options == nil {
		panic("the options must not be nil, please use Options() function instead")
	}
	return p.options
}

func (p *Bonding) SetSlaves(attr *HostNicSlice) {
	p.slaves = attr
}

func (p *Bonding) Slaves() (*HostNicSlice, bool) {
	if p.slaves != nil {
		return p.slaves, true
	}
	return nil, false
}

func (p *Bonding) MustSlaves() *HostNicSlice {
	if p.slaves == nil {
		panic("the slaves must not be nil, please use Slaves() function instead")
	}
	return p.slaves
}

// Bookmark Represents a bookmark in the system.
type Bookmark struct {
	Struct
	comment     *string
	description *string
	id          *string
	name        *string
	value       *string
}

func (p *Bookmark) SetComment(attr string) {
	p.comment = &attr
}

func (p *Bookmark) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *Bookmark) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *Bookmark) SetDescription(attr string) {
	p.description = &attr
}

func (p *Bookmark) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *Bookmark) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *Bookmark) SetId(attr string) {
	p.id = &attr
}

func (p *Bookmark) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *Bookmark) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *Bookmark) SetName(attr string) {
	p.name = &attr
}

func (p *Bookmark) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *Bookmark) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *Bookmark) SetValue(attr string) {
	p.value = &attr
}

func (p *Bookmark) Value() (string, bool) {
	if p.value != nil {
		return *p.value, true
	}
	var zero string
	return zero, false
}

func (p *Bookmark) MustValue() string {
	if p.value == nil {
		panic("the value must not be nil, please use Value() function instead")
	}
	return *p.value
}

// Boot Configuration of the boot sequence of a virtual machine.
type Boot struct {
	Struct
	devices []BootDevice
}

func (p *Boot) SetDevices(attr []BootDevice) {
	p.devices = attr
}

func (p *Boot) Devices() ([]BootDevice, bool) {
	if p.devices != nil {
		return p.devices, true
	}
	return nil, false
}

func (p *Boot) MustDevices() []BootDevice {
	if p.devices == nil {
		panic("the devices must not be nil, please use Devices() function instead")
	}
	return p.devices
}

// BootMenu Represents boot menu configuration
// for virtual machines and templates.
type BootMenu struct {
	Struct
	enabled *bool
}

func (p *BootMenu) SetEnabled(attr bool) {
	p.enabled = &attr
}

func (p *BootMenu) Enabled() (bool, bool) {
	if p.enabled != nil {
		return *p.enabled, true
	}
	var zero bool
	return zero, false
}

func (p *BootMenu) MustEnabled() bool {
	if p.enabled == nil {
		panic("the enabled must not be nil, please use Enabled() function instead")
	}
	return *p.enabled
}

type BrickProfileDetail struct {
	Struct
	brick          *GlusterBrick
	profileDetails *ProfileDetailSlice
}

func (p *BrickProfileDetail) SetBrick(attr *GlusterBrick) {
	p.brick = attr
}

func (p *BrickProfileDetail) Brick() (*GlusterBrick, bool) {
	if p.brick != nil {
		return p.brick, true
	}
	return nil, false
}

func (p *BrickProfileDetail) MustBrick() *GlusterBrick {
	if p.brick == nil {
		panic("the brick must not be nil, please use Brick() function instead")
	}
	return p.brick
}

func (p *BrickProfileDetail) SetProfileDetails(attr *ProfileDetailSlice) {
	p.profileDetails = attr
}

func (p *BrickProfileDetail) ProfileDetails() (*ProfileDetailSlice, bool) {
	if p.profileDetails != nil {
		return p.profileDetails, true
	}
	return nil, false
}

func (p *BrickProfileDetail) MustProfileDetails() *ProfileDetailSlice {
	if p.profileDetails == nil {
		panic("the profileDetails must not be nil, please use ProfileDetails() function instead")
	}
	return p.profileDetails
}

type Cdrom struct {
	Struct
	comment      *string
	description  *string
	file         *File
	id           *string
	instanceType *InstanceType
	name         *string
	template     *Template
	vm           *Vm
	vms          *VmSlice
}

func (p *Cdrom) SetComment(attr string) {
	p.comment = &attr
}

func (p *Cdrom) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *Cdrom) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *Cdrom) SetDescription(attr string) {
	p.description = &attr
}

func (p *Cdrom) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *Cdrom) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *Cdrom) SetFile(attr *File) {
	p.file = attr
}

func (p *Cdrom) File() (*File, bool) {
	if p.file != nil {
		return p.file, true
	}
	return nil, false
}

func (p *Cdrom) MustFile() *File {
	if p.file == nil {
		panic("the file must not be nil, please use File() function instead")
	}
	return p.file
}

func (p *Cdrom) SetId(attr string) {
	p.id = &attr
}

func (p *Cdrom) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *Cdrom) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

// SetInstanceType Describes the hardware configuration of virtual machines.
//
// For example `medium` instance type includes 1 virtual CPU and 4 GiB of memory. It is a top-level
// entity (e.g. not bound to any data center or cluster). The attributes that are used for instance
// types and are common to virtual machine and template types are:
//
// - `console`
// - `cpu`
// - `custom_cpu_model`
// - `custom_emulated_machine`
// - `display`
// - `high_availability`
// - `io`
// - `memory`
// - `memory_policy`
// - `migration`
// - `migration_downtime`
// - `os`
// - `rng_device`
// - `soundcard_enabled`
// - `usb`
// - `virtio_scsi`
//
// When creating a virtual machine from both an instance type and a template, the virtual machine
// will inherit the hardware configurations from the instance type
//
// NOTE: An instance type inherits it's attributes from the template entity although most template
// attributes are not used in instance types.
func (p *Cdrom) SetInstanceType(attr *InstanceType) {
	p.instanceType = attr
}

// InstanceType Describes the hardware configuration of virtual machines.
//
// For example `medium` instance type includes 1 virtual CPU and 4 GiB of memory. It is a top-level
// entity (e.g. not bound to any data center or cluster). The attributes that are used for instance
// types and are common to virtual machine and template types are:
//
// - `console`
// - `cpu`
// - `custom_cpu_model`
// - `custom_emulated_machine`
// - `display`
// - `high_availability`
// - `io`
// - `memory`
// - `memory_policy`
// - `migration`
// - `migration_downtime`
// - `os`
// - `rng_device`
// - `soundcard_enabled`
// - `usb`
// - `virtio_scsi`
//
// When creating a virtual machine from both an instance type and a template, the virtual machine
// will inherit the hardware configurations from the instance type
//
// NOTE: An instance type inherits it's attributes from the template entity although most template
// attributes are not used in instance types.
func (p *Cdrom) InstanceType() (*InstanceType, bool) {
	if p.instanceType != nil {
		return p.instanceType, true
	}
	return nil, false
}

// MustInstanceType Describes the hardware configuration of virtual machines.
//
// For example `medium` instance type includes 1 virtual CPU and 4 GiB of memory. It is a top-level
// entity (e.g. not bound to any data center or cluster). The attributes that are used for instance
// types and are common to virtual machine and template types are:
//
// - `console`
// - `cpu`
// - `custom_cpu_model`
// - `custom_emulated_machine`
// - `display`
// - `high_availability`
// - `io`
// - `memory`
// - `memory_policy`
// - `migration`
// - `migration_downtime`
// - `os`
// - `rng_device`
// - `soundcard_enabled`
// - `usb`
// - `virtio_scsi`
//
// When creating a virtual machine from both an instance type and a template, the virtual machine
// will inherit the hardware configurations from the instance type
//
// NOTE: An instance type inherits it's attributes from the template entity although most template
// attributes are not used in instance types.
func (p *Cdrom) MustInstanceType() *InstanceType {
	if p.instanceType == nil {
		panic("the instanceType must not be nil, please use InstanceType() function instead")
	}
	return p.instanceType
}

func (p *Cdrom) SetName(attr string) {
	p.name = &attr
}

func (p *Cdrom) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *Cdrom) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

// SetTemplate The type that represents a virtual machine template.
// Templates allow for a rapid instantiation of virtual machines with common configuration and disk states.
func (p *Cdrom) SetTemplate(attr *Template) {
	p.template = attr
}

// Template The type that represents a virtual machine template.
// Templates allow for a rapid instantiation of virtual machines with common configuration and disk states.
func (p *Cdrom) Template() (*Template, bool) {
	if p.template != nil {
		return p.template, true
	}
	return nil, false
}

// MustTemplate The type that represents a virtual machine template.
// Templates allow for a rapid instantiation of virtual machines with common configuration and disk states.
func (p *Cdrom) MustTemplate() *Template {
	if p.template == nil {
		panic("the template must not be nil, please use Template() function instead")
	}
	return p.template
}

// SetVm Represents a virtual machine.
func (p *Cdrom) SetVm(attr *Vm) {
	p.vm = attr
}

// Vm Represents a virtual machine.
func (p *Cdrom) Vm() (*Vm, bool) {
	if p.vm != nil {
		return p.vm, true
	}
	return nil, false
}

// MustVm Represents a virtual machine.
func (p *Cdrom) MustVm() *Vm {
	if p.vm == nil {
		panic("the vm must not be nil, please use Vm() function instead")
	}
	return p.vm
}

func (p *Cdrom) SetVms(attr *VmSlice) {
	p.vms = attr
}

func (p *Cdrom) Vms() (*VmSlice, bool) {
	if p.vms != nil {
		return p.vms, true
	}
	return nil, false
}

func (p *Cdrom) MustVms() *VmSlice {
	if p.vms == nil {
		panic("the vms must not be nil, please use Vms() function instead")
	}
	return p.vms
}

type Certificate struct {
	Struct
	comment      *string
	content      *string
	description  *string
	id           *string
	name         *string
	organization *string
	subject      *string
}

func (p *Certificate) SetComment(attr string) {
	p.comment = &attr
}

func (p *Certificate) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *Certificate) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *Certificate) SetContent(attr string) {
	p.content = &attr
}

func (p *Certificate) Content() (string, bool) {
	if p.content != nil {
		return *p.content, true
	}
	var zero string
	return zero, false
}

func (p *Certificate) MustContent() string {
	if p.content == nil {
		panic("the content must not be nil, please use Content() function instead")
	}
	return *p.content
}

func (p *Certificate) SetDescription(attr string) {
	p.description = &attr
}

func (p *Certificate) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *Certificate) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *Certificate) SetId(attr string) {
	p.id = &attr
}

func (p *Certificate) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *Certificate) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *Certificate) SetName(attr string) {
	p.name = &attr
}

func (p *Certificate) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *Certificate) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *Certificate) SetOrganization(attr string) {
	p.organization = &attr
}

func (p *Certificate) Organization() (string, bool) {
	if p.organization != nil {
		return *p.organization, true
	}
	var zero string
	return zero, false
}

func (p *Certificate) MustOrganization() string {
	if p.organization == nil {
		panic("the organization must not be nil, please use Organization() function instead")
	}
	return *p.organization
}

func (p *Certificate) SetSubject(attr string) {
	p.subject = &attr
}

func (p *Certificate) Subject() (string, bool) {
	if p.subject != nil {
		return *p.subject, true
	}
	var zero string
	return zero, false
}

func (p *Certificate) MustSubject() string {
	if p.subject == nil {
		panic("the subject must not be nil, please use Subject() function instead")
	}
	return *p.subject
}

type Checkpoint struct {
	Struct
	comment      *string
	creationDate *time.Time
	description  *string
	disks        *DiskSlice
	id           *string
	name         *string
	parentId     *string
	state        *CheckpointState
	vm           *Vm
}

func (p *Checkpoint) SetComment(attr string) {
	p.comment = &attr
}

func (p *Checkpoint) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *Checkpoint) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *Checkpoint) SetCreationDate(attr time.Time) {
	p.creationDate = &attr
}

func (p *Checkpoint) CreationDate() (time.Time, bool) {
	if p.creationDate != nil {
		return *p.creationDate, true
	}
	var zero time.Time
	return zero, false
}

func (p *Checkpoint) MustCreationDate() time.Time {
	if p.creationDate == nil {
		panic("the creationDate must not be nil, please use CreationDate() function instead")
	}
	return *p.creationDate
}

func (p *Checkpoint) SetDescription(attr string) {
	p.description = &attr
}

func (p *Checkpoint) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *Checkpoint) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *Checkpoint) SetDisks(attr *DiskSlice) {
	p.disks = attr
}

func (p *Checkpoint) Disks() (*DiskSlice, bool) {
	if p.disks != nil {
		return p.disks, true
	}
	return nil, false
}

func (p *Checkpoint) MustDisks() *DiskSlice {
	if p.disks == nil {
		panic("the disks must not be nil, please use Disks() function instead")
	}
	return p.disks
}

func (p *Checkpoint) SetId(attr string) {
	p.id = &attr
}

func (p *Checkpoint) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *Checkpoint) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *Checkpoint) SetName(attr string) {
	p.name = &attr
}

func (p *Checkpoint) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *Checkpoint) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *Checkpoint) SetParentId(attr string) {
	p.parentId = &attr
}

func (p *Checkpoint) ParentId() (string, bool) {
	if p.parentId != nil {
		return *p.parentId, true
	}
	var zero string
	return zero, false
}

func (p *Checkpoint) MustParentId() string {
	if p.parentId == nil {
		panic("the parentId must not be nil, please use ParentId() function instead")
	}
	return *p.parentId
}

func (p *Checkpoint) SetState(attr CheckpointState) {
	p.state = &attr
}

func (p *Checkpoint) State() (CheckpointState, bool) {
	if p.state != nil {
		return *p.state, true
	}
	var zero CheckpointState
	return zero, false
}

func (p *Checkpoint) MustState() CheckpointState {
	if p.state == nil {
		panic("the state must not be nil, please use State() function instead")
	}
	return *p.state
}

// SetVm Represents a virtual machine.
func (p *Checkpoint) SetVm(attr *Vm) {
	p.vm = attr
}

// Vm Represents a virtual machine.
func (p *Checkpoint) Vm() (*Vm, bool) {
	if p.vm != nil {
		return p.vm, true
	}
	return nil, false
}

// MustVm Represents a virtual machine.
func (p *Checkpoint) MustVm() *Vm {
	if p.vm == nil {
		panic("the vm must not be nil, please use Vm() function instead")
	}
	return p.vm
}

// CloudInit Deprecated type to specify _cloud-init_ configuration.
//
// This type has been deprecated and replaced by alternative attributes inside the
// <<types/initialization, Initialization>> type. See the
// <<types/initialization/attributes/cloud_init, cloud_init>> attribute documentation for details.
type CloudInit struct {
	Struct
	authorizedKeys       *AuthorizedKeySlice
	files                *FileSlice
	host                 *Host
	networkConfiguration *NetworkConfiguration
	regenerateSshKeys    *bool
	timezone             *string
	users                *UserSlice
}

func (p *CloudInit) SetAuthorizedKeys(attr *AuthorizedKeySlice) {
	p.authorizedKeys = attr
}

func (p *CloudInit) AuthorizedKeys() (*AuthorizedKeySlice, bool) {
	if p.authorizedKeys != nil {
		return p.authorizedKeys, true
	}
	return nil, false
}

func (p *CloudInit) MustAuthorizedKeys() *AuthorizedKeySlice {
	if p.authorizedKeys == nil {
		panic("the authorizedKeys must not be nil, please use AuthorizedKeys() function instead")
	}
	return p.authorizedKeys
}

func (p *CloudInit) SetFiles(attr *FileSlice) {
	p.files = attr
}

func (p *CloudInit) Files() (*FileSlice, bool) {
	if p.files != nil {
		return p.files, true
	}
	return nil, false
}

func (p *CloudInit) MustFiles() *FileSlice {
	if p.files == nil {
		panic("the files must not be nil, please use Files() function instead")
	}
	return p.files
}

// SetHost Type representing a host.
func (p *CloudInit) SetHost(attr *Host) {
	p.host = attr
}

// Host Type representing a host.
func (p *CloudInit) Host() (*Host, bool) {
	if p.host != nil {
		return p.host, true
	}
	return nil, false
}

// MustHost Type representing a host.
func (p *CloudInit) MustHost() *Host {
	if p.host == nil {
		panic("the host must not be nil, please use Host() function instead")
	}
	return p.host
}

func (p *CloudInit) SetNetworkConfiguration(attr *NetworkConfiguration) {
	p.networkConfiguration = attr
}

func (p *CloudInit) NetworkConfiguration() (*NetworkConfiguration, bool) {
	if p.networkConfiguration != nil {
		return p.networkConfiguration, true
	}
	return nil, false
}

func (p *CloudInit) MustNetworkConfiguration() *NetworkConfiguration {
	if p.networkConfiguration == nil {
		panic("the networkConfiguration must not be nil, please use NetworkConfiguration() function instead")
	}
	return p.networkConfiguration
}

func (p *CloudInit) SetRegenerateSshKeys(attr bool) {
	p.regenerateSshKeys = &attr
}

func (p *CloudInit) RegenerateSshKeys() (bool, bool) {
	if p.regenerateSshKeys != nil {
		return *p.regenerateSshKeys, true
	}
	var zero bool
	return zero, false
}

func (p *CloudInit) MustRegenerateSshKeys() bool {
	if p.regenerateSshKeys == nil {
		panic("the regenerateSshKeys must not be nil, please use RegenerateSshKeys() function instead")
	}
	return *p.regenerateSshKeys
}

func (p *CloudInit) SetTimezone(attr string) {
	p.timezone = &attr
}

func (p *CloudInit) Timezone() (string, bool) {
	if p.timezone != nil {
		return *p.timezone, true
	}
	var zero string
	return zero, false
}

func (p *CloudInit) MustTimezone() string {
	if p.timezone == nil {
		panic("the timezone must not be nil, please use Timezone() function instead")
	}
	return *p.timezone
}

func (p *CloudInit) SetUsers(attr *UserSlice) {
	p.users = attr
}

func (p *CloudInit) Users() (*UserSlice, bool) {
	if p.users != nil {
		return p.users, true
	}
	return nil, false
}

func (p *CloudInit) MustUsers() *UserSlice {
	if p.users == nil {
		panic("the users must not be nil, please use Users() function instead")
	}
	return p.users
}

// Cluster Type representation of a cluster.
//
// A JSON representation of a cluster:
//
// [source]
// ----
// {
//   "cluster" : [ {
//     "ballooning_enabled" : "false",
//     "cpu" : {
//       "architecture" : "x86_64",
//       "type" : "Intel SandyBridge Family"
//     },
//     "custom_scheduling_policy_properties" : {
//       "property" : [ {
//         "name" : "HighUtilization",
//         "value" : "80"
//       }, {
//         "name" : "CpuOverCommitDurationMinutes",
//         "value" : "2"
//       } ]
//     },
//     "error_handling" : {
//       "on_error" : "migrate"
//     },
//     "fencing_policy" : {
//       "enabled" : "true",
//       "skip_if_connectivity_broken" : {
//         "enabled" : "false",
//         "threshold" : "50"
//       },
//       "skip_if_gluster_bricks_up" : "false",
//       "skip_if_gluster_quorum_not_met" : "false",
//       "skip_if_sd_active" : {
//         "enabled" : "false"
//       }
//     },
//     "gluster_service" : "false",
//     "firewall_type" : "iptables",
//     "ha_reservation" : "false",
//     "ksm" : {
//       "enabled" : "true",
//       "merge_across_nodes" : "true"
//     },
//     "memory_policy" : {
//       "over_commit" : {
//         "percent" : "100"
//       },
//       "transparent_hugepages" : {
//         "enabled" : "true"
//       }
//     },
//     "migration" : {
//       "auto_converge" : "inherit",
//       "bandwidth" : {
//         "assignment_method" : "auto"
//       },
//       "compressed" : "inherit",
//       "policy" : {
//         "id" : "00000000-0000-0000-0000-000000000000"
//       }
//     },
//     "required_rng_sources" : {
//       "required_rng_source" : [ "random" ]
//     },
//     "switch_type" : "legacy",
//     "threads_as_cores" : "false",
//     "trusted_service" : "false",
//     "tunnel_migration" : "false",
//     "version" : {
//       "major" : "4",
//       "minor" : "1"
//     },
//     "virt_service" : "true",
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "mac_pool" : {
//       "href" : "/ovirt-engine/api/macpools/456",
//       "id" : "456"
//     },
//     "scheduling_policy" : {
//       "href" : "/ovirt-engine/api/schedulingpolicies/789",
//       "id" : "789"
//     },
//     "actions" : {
//       "link" : [ {
//         "href" : "/ovirt-engine/api/clusters/234/resetemulatedmachine",
//         "rel" : "resetemulatedmachine"
//       } ]
//     },
//     "name" : "Default",
//     "description" : "The default server cluster",
//     "href" : "/ovirt-engine/api/clusters/234",
//     "id" : "234",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/clusters/234/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/cpuprofiles",
//       "rel" : "cpuprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networkfilters",
//       "rel" : "networkfilters"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networks",
//       "rel" : "networks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/affinitygroups",
//       "rel" : "affinitygroups"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glusterhooks",
//       "rel" : "glusterhooks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glustervolumes",
//       "rel" : "glustervolumes"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/enabledfeatures",
//       "rel" : "enabledfeatures"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/externalnetworkproviders",
//       "rel" : "externalnetworkproviders"
//     } ]
//   } ]
// }
// ----
type Cluster struct {
	Struct
	affinityGroups                   *AffinityGroupSlice
	ballooningEnabled                *bool
	biosType                         *BiosType
	comment                          *string
	cpu                              *Cpu
	cpuProfiles                      *CpuProfileSlice
	customSchedulingPolicyProperties *PropertySlice
	dataCenter                       *DataCenter
	description                      *string
	display                          *Display
	enabledFeatures                  *ClusterFeatureSlice
	errorHandling                    *ErrorHandling
	externalNetworkProviders         *ExternalProviderSlice
	fencingPolicy                    *FencingPolicy
	fipsMode                         *FipsMode
	firewallType                     *FirewallType
	glusterHooks                     *GlusterHookSlice
	glusterService                   *bool
	glusterTunedProfile              *string
	glusterVolumes                   *GlusterVolumeSlice
	haReservation                    *bool
	id                               *string
	ksm                              *Ksm
	logMaxMemoryUsedThreshold        *int64
	logMaxMemoryUsedThresholdType    *LogMaxMemoryUsedThresholdType
	macPool                          *MacPool
	maintenanceReasonRequired        *bool
	managementNetwork                *Network
	memoryPolicy                     *MemoryPolicy
	migration                        *MigrationOptions
	name                             *string
	networkFilters                   *NetworkFilterSlice
	networks                         *NetworkSlice
	optionalReason                   *bool
	permissions                      *PermissionSlice
	requiredRngSources               []RngSource
	schedulingPolicy                 *SchedulingPolicy
	serialNumber                     *SerialNumber
	supportedVersions                *VersionSlice
	switchType                       *SwitchType
	threadsAsCores                   *bool
	trustedService                   *bool
	tunnelMigration                  *bool
	version                          *Version
	virtService                      *bool
	vncEncryption                    *bool
}

func (p *Cluster) SetAffinityGroups(attr *AffinityGroupSlice) {
	p.affinityGroups = attr
}

func (p *Cluster) AffinityGroups() (*AffinityGroupSlice, bool) {
	if p.affinityGroups != nil {
		return p.affinityGroups, true
	}
	return nil, false
}

func (p *Cluster) MustAffinityGroups() *AffinityGroupSlice {
	if p.affinityGroups == nil {
		panic("the affinityGroups must not be nil, please use AffinityGroups() function instead")
	}
	return p.affinityGroups
}

func (p *Cluster) SetBallooningEnabled(attr bool) {
	p.ballooningEnabled = &attr
}

func (p *Cluster) BallooningEnabled() (bool, bool) {
	if p.ballooningEnabled != nil {
		return *p.ballooningEnabled, true
	}
	var zero bool
	return zero, false
}

func (p *Cluster) MustBallooningEnabled() bool {
	if p.ballooningEnabled == nil {
		panic("the ballooningEnabled must not be nil, please use BallooningEnabled() function instead")
	}
	return *p.ballooningEnabled
}

// SetBiosType Type representing a chipset and a BIOS type combination.
func (p *Cluster) SetBiosType(attr BiosType) {
	p.biosType = &attr
}

// BiosType Type representing a chipset and a BIOS type combination.
func (p *Cluster) BiosType() (BiosType, bool) {
	if p.biosType != nil {
		return *p.biosType, true
	}
	var zero BiosType
	return zero, false
}

// MustBiosType Type representing a chipset and a BIOS type combination.
func (p *Cluster) MustBiosType() BiosType {
	if p.biosType == nil {
		panic("the biosType must not be nil, please use BiosType() function instead")
	}
	return *p.biosType
}

func (p *Cluster) SetComment(attr string) {
	p.comment = &attr
}

func (p *Cluster) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *Cluster) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *Cluster) SetCpu(attr *Cpu) {
	p.cpu = attr
}

func (p *Cluster) Cpu() (*Cpu, bool) {
	if p.cpu != nil {
		return p.cpu, true
	}
	return nil, false
}

func (p *Cluster) MustCpu() *Cpu {
	if p.cpu == nil {
		panic("the cpu must not be nil, please use Cpu() function instead")
	}
	return p.cpu
}

func (p *Cluster) SetCpuProfiles(attr *CpuProfileSlice) {
	p.cpuProfiles = attr
}

func (p *Cluster) CpuProfiles() (*CpuProfileSlice, bool) {
	if p.cpuProfiles != nil {
		return p.cpuProfiles, true
	}
	return nil, false
}

func (p *Cluster) MustCpuProfiles() *CpuProfileSlice {
	if p.cpuProfiles == nil {
		panic("the cpuProfiles must not be nil, please use CpuProfiles() function instead")
	}
	return p.cpuProfiles
}

func (p *Cluster) SetCustomSchedulingPolicyProperties(attr *PropertySlice) {
	p.customSchedulingPolicyProperties = attr
}

func (p *Cluster) CustomSchedulingPolicyProperties() (*PropertySlice, bool) {
	if p.customSchedulingPolicyProperties != nil {
		return p.customSchedulingPolicyProperties, true
	}
	return nil, false
}

func (p *Cluster) MustCustomSchedulingPolicyProperties() *PropertySlice {
	if p.customSchedulingPolicyProperties == nil {
		panic("the customSchedulingPolicyProperties must not be nil, please use CustomSchedulingPolicyProperties() function instead")
	}
	return p.customSchedulingPolicyProperties
}

func (p *Cluster) SetDataCenter(attr *DataCenter) {
	p.dataCenter = attr
}

func (p *Cluster) DataCenter() (*DataCenter, bool) {
	if p.dataCenter != nil {
		return p.dataCenter, true
	}
	return nil, false
}

func (p *Cluster) MustDataCenter() *DataCenter {
	if p.dataCenter == nil {
		panic("the dataCenter must not be nil, please use DataCenter() function instead")
	}
	return p.dataCenter
}

func (p *Cluster) SetDescription(attr string) {
	p.description = &attr
}

func (p *Cluster) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *Cluster) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

// SetDisplay Represents a graphic console configuration.
func (p *Cluster) SetDisplay(attr *Display) {
	p.display = attr
}

// Display Represents a graphic console configuration.
func (p *Cluster) Display() (*Display, bool) {
	if p.display != nil {
		return p.display, true
	}
	return nil, false
}

// MustDisplay Represents a graphic console configuration.
func (p *Cluster) MustDisplay() *Display {
	if p.display == nil {
		panic("the display must not be nil, please use Display() function instead")
	}
	return p.display
}

func (p *Cluster) SetEnabledFeatures(attr *ClusterFeatureSlice) {
	p.enabledFeatures = attr
}

func (p *Cluster) EnabledFeatures() (*ClusterFeatureSlice, bool) {
	if p.enabledFeatures != nil {
		return p.enabledFeatures, true
	}
	return nil, false
}

func (p *Cluster) MustEnabledFeatures() *ClusterFeatureSlice {
	if p.enabledFeatures == nil {
		panic("the enabledFeatures must not be nil, please use EnabledFeatures() function instead")
	}
	return p.enabledFeatures
}

func (p *Cluster) SetErrorHandling(attr *ErrorHandling) {
	p.errorHandling = attr
}

func (p *Cluster) ErrorHandling() (*ErrorHandling, bool) {
	if p.errorHandling != nil {
		return p.errorHandling, true
	}
	return nil, false
}

func (p *Cluster) MustErrorHandling() *ErrorHandling {
	if p.errorHandling == nil {
		panic("the errorHandling must not be nil, please use ErrorHandling() function instead")
	}
	return p.errorHandling
}

func (p *Cluster) SetExternalNetworkProviders(attr *ExternalProviderSlice) {
	p.externalNetworkProviders = attr
}

func (p *Cluster) ExternalNetworkProviders() (*ExternalProviderSlice, bool) {
	if p.externalNetworkProviders != nil {
		return p.externalNetworkProviders, true
	}
	return nil, false
}

func (p *Cluster) MustExternalNetworkProviders() *ExternalProviderSlice {
	if p.externalNetworkProviders == nil {
		panic("the externalNetworkProviders must not be nil, please use ExternalNetworkProviders() function instead")
	}
	return p.externalNetworkProviders
}

// SetFencingPolicy Type representing a cluster fencing policy.
func (p *Cluster) SetFencingPolicy(attr *FencingPolicy) {
	p.fencingPolicy = attr
}

// FencingPolicy Type representing a cluster fencing policy.
func (p *Cluster) FencingPolicy() (*FencingPolicy, bool) {
	if p.fencingPolicy != nil {
		return p.fencingPolicy, true
	}
	return nil, false
}

// MustFencingPolicy Type representing a cluster fencing policy.
func (p *Cluster) MustFencingPolicy() *FencingPolicy {
	if p.fencingPolicy == nil {
		panic("the fencingPolicy must not be nil, please use FencingPolicy() function instead")
	}
	return p.fencingPolicy
}

// SetFipsMode Representation of the FIPS mode to the cluster.
func (p *Cluster) SetFipsMode(attr FipsMode) {
	p.fipsMode = &attr
}

// FipsMode Representation of the FIPS mode to the cluster.
func (p *Cluster) FipsMode() (FipsMode, bool) {
	if p.fipsMode != nil {
		return *p.fipsMode, true
	}
	var zero FipsMode
	return zero, false
}

// MustFipsMode Representation of the FIPS mode to the cluster.
func (p *Cluster) MustFipsMode() FipsMode {
	if p.fipsMode == nil {
		panic("the fipsMode must not be nil, please use FipsMode() function instead")
	}
	return *p.fipsMode
}

// SetFirewallType Describes all firewall types supported by the system.
func (p *Cluster) SetFirewallType(attr FirewallType) {
	p.firewallType = &attr
}

// FirewallType Describes all firewall types supported by the system.
func (p *Cluster) FirewallType() (FirewallType, bool) {
	if p.firewallType != nil {
		return *p.firewallType, true
	}
	var zero FirewallType
	return zero, false
}

// MustFirewallType Describes all firewall types supported by the system.
func (p *Cluster) MustFirewallType() FirewallType {
	if p.firewallType == nil {
		panic("the firewallType must not be nil, please use FirewallType() function instead")
	}
	return *p.firewallType
}

func (p *Cluster) SetGlusterHooks(attr *GlusterHookSlice) {
	p.glusterHooks = attr
}

func (p *Cluster) GlusterHooks() (*GlusterHookSlice, bool) {
	if p.glusterHooks != nil {
		return p.glusterHooks, true
	}
	return nil, false
}

func (p *Cluster) MustGlusterHooks() *GlusterHookSlice {
	if p.glusterHooks == nil {
		panic("the glusterHooks must not be nil, please use GlusterHooks() function instead")
	}
	return p.glusterHooks
}

func (p *Cluster) SetGlusterService(attr bool) {
	p.glusterService = &attr
}

func (p *Cluster) GlusterService() (bool, bool) {
	if p.glusterService != nil {
		return *p.glusterService, true
	}
	var zero bool
	return zero, false
}

func (p *Cluster) MustGlusterService() bool {
	if p.glusterService == nil {
		panic("the glusterService must not be nil, please use GlusterService() function instead")
	}
	return *p.glusterService
}

func (p *Cluster) SetGlusterTunedProfile(attr string) {
	p.glusterTunedProfile = &attr
}

func (p *Cluster) GlusterTunedProfile() (string, bool) {
	if p.glusterTunedProfile != nil {
		return *p.glusterTunedProfile, true
	}
	var zero string
	return zero, false
}

func (p *Cluster) MustGlusterTunedProfile() string {
	if p.glusterTunedProfile == nil {
		panic("the glusterTunedProfile must not be nil, please use GlusterTunedProfile() function instead")
	}
	return *p.glusterTunedProfile
}

func (p *Cluster) SetGlusterVolumes(attr *GlusterVolumeSlice) {
	p.glusterVolumes = attr
}

func (p *Cluster) GlusterVolumes() (*GlusterVolumeSlice, bool) {
	if p.glusterVolumes != nil {
		return p.glusterVolumes, true
	}
	return nil, false
}

func (p *Cluster) MustGlusterVolumes() *GlusterVolumeSlice {
	if p.glusterVolumes == nil {
		panic("the glusterVolumes must not be nil, please use GlusterVolumes() function instead")
	}
	return p.glusterVolumes
}

func (p *Cluster) SetHaReservation(attr bool) {
	p.haReservation = &attr
}

func (p *Cluster) HaReservation() (bool, bool) {
	if p.haReservation != nil {
		return *p.haReservation, true
	}
	var zero bool
	return zero, false
}

func (p *Cluster) MustHaReservation() bool {
	if p.haReservation == nil {
		panic("the haReservation must not be nil, please use HaReservation() function instead")
	}
	return *p.haReservation
}

func (p *Cluster) SetId(attr string) {
	p.id = &attr
}

func (p *Cluster) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *Cluster) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *Cluster) SetKsm(attr *Ksm) {
	p.ksm = attr
}

func (p *Cluster) Ksm() (*Ksm, bool) {
	if p.ksm != nil {
		return p.ksm, true
	}
	return nil, false
}

func (p *Cluster) MustKsm() *Ksm {
	if p.ksm == nil {
		panic("the ksm must not be nil, please use Ksm() function instead")
	}
	return p.ksm
}

func (p *Cluster) SetLogMaxMemoryUsedThreshold(attr int64) {
	p.logMaxMemoryUsedThreshold = &attr
}

func (p *Cluster) LogMaxMemoryUsedThreshold() (int64, bool) {
	if p.logMaxMemoryUsedThreshold != nil {
		return *p.logMaxMemoryUsedThreshold, true
	}
	var zero int64
	return zero, false
}

func (p *Cluster) MustLogMaxMemoryUsedThreshold() int64 {
	if p.logMaxMemoryUsedThreshold == nil {
		panic("the logMaxMemoryUsedThreshold must not be nil, please use LogMaxMemoryUsedThreshold() function instead")
	}
	return *p.logMaxMemoryUsedThreshold
}

// SetLogMaxMemoryUsedThresholdType Describes all maximum memory threshold types supported by the system.
func (p *Cluster) SetLogMaxMemoryUsedThresholdType(attr LogMaxMemoryUsedThresholdType) {
	p.logMaxMemoryUsedThresholdType = &attr
}

// LogMaxMemoryUsedThresholdType Describes all maximum memory threshold types supported by the system.
func (p *Cluster) LogMaxMemoryUsedThresholdType() (LogMaxMemoryUsedThresholdType, bool) {
	if p.logMaxMemoryUsedThresholdType != nil {
		return *p.logMaxMemoryUsedThresholdType, true
	}
	var zero LogMaxMemoryUsedThresholdType
	return zero, false
}

// MustLogMaxMemoryUsedThresholdType Describes all maximum memory threshold types supported by the system.
func (p *Cluster) MustLogMaxMemoryUsedThresholdType() LogMaxMemoryUsedThresholdType {
	if p.logMaxMemoryUsedThresholdType == nil {
		panic("the logMaxMemoryUsedThresholdType must not be nil, please use LogMaxMemoryUsedThresholdType() function instead")
	}
	return *p.logMaxMemoryUsedThresholdType
}

// SetMacPool Represents a MAC address pool.
//
// Example of an XML representation of a MAC address pool:
//
// [source,xml]
// ----
// <mac_pool href="/ovirt-engine/api/macpools/123" id="123">
//   <name>Default</name>
//   <description>Default MAC pool</description>
//   <allow_duplicates>false</allow_duplicates>
//   <default_pool>true</default_pool>
//   <ranges>
//     <range>
//       <from>00:1A:4A:16:01:51</from>
//       <to>00:1A:4A:16:01:E6</to>
//     </range>
//   </ranges>
// </mac_pool>
// ----
func (p *Cluster) SetMacPool(attr *MacPool) {
	p.macPool = attr
}

// MacPool Represents a MAC address pool.
//
// Example of an XML representation of a MAC address pool:
//
// [source,xml]
// ----
// <mac_pool href="/ovirt-engine/api/macpools/123" id="123">
//   <name>Default</name>
//   <description>Default MAC pool</description>
//   <allow_duplicates>false</allow_duplicates>
//   <default_pool>true</default_pool>
//   <ranges>
//     <range>
//       <from>00:1A:4A:16:01:51</from>
//       <to>00:1A:4A:16:01:E6</to>
//     </range>
//   </ranges>
// </mac_pool>
// ----
func (p *Cluster) MacPool() (*MacPool, bool) {
	if p.macPool != nil {
		return p.macPool, true
	}
	return nil, false
}

// MustMacPool Represents a MAC address pool.
//
// Example of an XML representation of a MAC address pool:
//
// [source,xml]
// ----
// <mac_pool href="/ovirt-engine/api/macpools/123" id="123">
//   <name>Default</name>
//   <description>Default MAC pool</description>
//   <allow_duplicates>false</allow_duplicates>
//   <default_pool>true</default_pool>
//   <ranges>
//     <range>
//       <from>00:1A:4A:16:01:51</from>
//       <to>00:1A:4A:16:01:E6</to>
//     </range>
//   </ranges>
// </mac_pool>
// ----
func (p *Cluster) MustMacPool() *MacPool {
	if p.macPool == nil {
		panic("the macPool must not be nil, please use MacPool() function instead")
	}
	return p.macPool
}

func (p *Cluster) SetMaintenanceReasonRequired(attr bool) {
	p.maintenanceReasonRequired = &attr
}

func (p *Cluster) MaintenanceReasonRequired() (bool, bool) {
	if p.maintenanceReasonRequired != nil {
		return *p.maintenanceReasonRequired, true
	}
	var zero bool
	return zero, false
}

func (p *Cluster) MustMaintenanceReasonRequired() bool {
	if p.maintenanceReasonRequired == nil {
		panic("the maintenanceReasonRequired must not be nil, please use MaintenanceReasonRequired() function instead")
	}
	return *p.maintenanceReasonRequired
}

// SetManagementNetwork The type for a logical network.
//
// An example of the JSON representation of a logical network:
//
// [source,json]
// ----
// {
//   "network" : [ {
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "stp" : "false",
//     "mtu" : "0",
//     "usages" : {
//       "usage" : [ "vm" ]
//     },
//     "name" : "ovirtmgmt",
//     "description" : "Management Network",
//     "href" : "/ovirt-engine/api/networks/456",
//     "id" : "456",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/networks/456/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/networks/456/vnicprofiles",
//       "rel" : "vnicprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/networks/456/labels",
//       "rel" : "labels"
//     } ]
//   } ]
// }
// ----
//
// An example of the XML representation of the same logical network:
//
// [source,xml]
// ----
// <network href="/ovirt-engine/api/networks/456" id="456">
//   <name>ovirtmgmt</name>
//   <description>Management Network</description>
//   <link href="/ovirt-engine/api/networks/456/permissions" rel="permissions"/>
//   <link href="/ovirt-engine/api/networks/456/vnicprofiles" rel="vnicprofiles"/>
//   <link href="/ovirt-engine/api/networks/456/labels" rel="labels"/>
//   <data_center href="/ovirt-engine/api/datacenters/123" id="123"/>
//   <stp>false</stp>
//   <mtu>0</mtu>
//   <usages>
//     <usage>vm</usage>
//   </usages>
// </network>
// ----
func (p *Cluster) SetManagementNetwork(attr *Network) {
	p.managementNetwork = attr
}

// ManagementNetwork The type for a logical network.
//
// An example of the JSON representation of a logical network:
//
// [source,json]
// ----
// {
//   "network" : [ {
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "stp" : "false",
//     "mtu" : "0",
//     "usages" : {
//       "usage" : [ "vm" ]
//     },
//     "name" : "ovirtmgmt",
//     "description" : "Management Network",
//     "href" : "/ovirt-engine/api/networks/456",
//     "id" : "456",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/networks/456/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/networks/456/vnicprofiles",
//       "rel" : "vnicprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/networks/456/labels",
//       "rel" : "labels"
//     } ]
//   } ]
// }
// ----
//
// An example of the XML representation of the same logical network:
//
// [source,xml]
// ----
// <network href="/ovirt-engine/api/networks/456" id="456">
//   <name>ovirtmgmt</name>
//   <description>Management Network</description>
//   <link href="/ovirt-engine/api/networks/456/permissions" rel="permissions"/>
//   <link href="/ovirt-engine/api/networks/456/vnicprofiles" rel="vnicprofiles"/>
//   <link href="/ovirt-engine/api/networks/456/labels" rel="labels"/>
//   <data_center href="/ovirt-engine/api/datacenters/123" id="123"/>
//   <stp>false</stp>
//   <mtu>0</mtu>
//   <usages>
//     <usage>vm</usage>
//   </usages>
// </network>
// ----
func (p *Cluster) ManagementNetwork() (*Network, bool) {
	if p.managementNetwork != nil {
		return p.managementNetwork, true
	}
	return nil, false
}

// MustManagementNetwork The type for a logical network.
//
// An example of the JSON representation of a logical network:
//
// [source,json]
// ----
// {
//   "network" : [ {
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "stp" : "false",
//     "mtu" : "0",
//     "usages" : {
//       "usage" : [ "vm" ]
//     },
//     "name" : "ovirtmgmt",
//     "description" : "Management Network",
//     "href" : "/ovirt-engine/api/networks/456",
//     "id" : "456",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/networks/456/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/networks/456/vnicprofiles",
//       "rel" : "vnicprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/networks/456/labels",
//       "rel" : "labels"
//     } ]
//   } ]
// }
// ----
//
// An example of the XML representation of the same logical network:
//
// [source,xml]
// ----
// <network href="/ovirt-engine/api/networks/456" id="456">
//   <name>ovirtmgmt</name>
//   <description>Management Network</description>
//   <link href="/ovirt-engine/api/networks/456/permissions" rel="permissions"/>
//   <link href="/ovirt-engine/api/networks/456/vnicprofiles" rel="vnicprofiles"/>
//   <link href="/ovirt-engine/api/networks/456/labels" rel="labels"/>
//   <data_center href="/ovirt-engine/api/datacenters/123" id="123"/>
//   <stp>false</stp>
//   <mtu>0</mtu>
//   <usages>
//     <usage>vm</usage>
//   </usages>
// </network>
// ----
func (p *Cluster) MustManagementNetwork() *Network {
	if p.managementNetwork == nil {
		panic("the managementNetwork must not be nil, please use ManagementNetwork() function instead")
	}
	return p.managementNetwork
}

// SetMemoryPolicy Logical grouping of memory-related properties of virtual machine-like entities.
func (p *Cluster) SetMemoryPolicy(attr *MemoryPolicy) {
	p.memoryPolicy = attr
}

// MemoryPolicy Logical grouping of memory-related properties of virtual machine-like entities.
func (p *Cluster) MemoryPolicy() (*MemoryPolicy, bool) {
	if p.memoryPolicy != nil {
		return p.memoryPolicy, true
	}
	return nil, false
}

// MustMemoryPolicy Logical grouping of memory-related properties of virtual machine-like entities.
func (p *Cluster) MustMemoryPolicy() *MemoryPolicy {
	if p.memoryPolicy == nil {
		panic("the memoryPolicy must not be nil, please use MemoryPolicy() function instead")
	}
	return p.memoryPolicy
}

// SetMigration The type for migration options.
func (p *Cluster) SetMigration(attr *MigrationOptions) {
	p.migration = attr
}

// Migration The type for migration options.
func (p *Cluster) Migration() (*MigrationOptions, bool) {
	if p.migration != nil {
		return p.migration, true
	}
	return nil, false
}

// MustMigration The type for migration options.
func (p *Cluster) MustMigration() *MigrationOptions {
	if p.migration == nil {
		panic("the migration must not be nil, please use Migration() function instead")
	}
	return p.migration
}

func (p *Cluster) SetName(attr string) {
	p.name = &attr
}

func (p *Cluster) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *Cluster) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *Cluster) SetNetworkFilters(attr *NetworkFilterSlice) {
	p.networkFilters = attr
}

func (p *Cluster) NetworkFilters() (*NetworkFilterSlice, bool) {
	if p.networkFilters != nil {
		return p.networkFilters, true
	}
	return nil, false
}

func (p *Cluster) MustNetworkFilters() *NetworkFilterSlice {
	if p.networkFilters == nil {
		panic("the networkFilters must not be nil, please use NetworkFilters() function instead")
	}
	return p.networkFilters
}

func (p *Cluster) SetNetworks(attr *NetworkSlice) {
	p.networks = attr
}

func (p *Cluster) Networks() (*NetworkSlice, bool) {
	if p.networks != nil {
		return p.networks, true
	}
	return nil, false
}

func (p *Cluster) MustNetworks() *NetworkSlice {
	if p.networks == nil {
		panic("the networks must not be nil, please use Networks() function instead")
	}
	return p.networks
}

func (p *Cluster) SetOptionalReason(attr bool) {
	p.optionalReason = &attr
}

func (p *Cluster) OptionalReason() (bool, bool) {
	if p.optionalReason != nil {
		return *p.optionalReason, true
	}
	var zero bool
	return zero, false
}

func (p *Cluster) MustOptionalReason() bool {
	if p.optionalReason == nil {
		panic("the optionalReason must not be nil, please use OptionalReason() function instead")
	}
	return *p.optionalReason
}

func (p *Cluster) SetPermissions(attr *PermissionSlice) {
	p.permissions = attr
}

func (p *Cluster) Permissions() (*PermissionSlice, bool) {
	if p.permissions != nil {
		return p.permissions, true
	}
	return nil, false
}

func (p *Cluster) MustPermissions() *PermissionSlice {
	if p.permissions == nil {
		panic("the permissions must not be nil, please use Permissions() function instead")
	}
	return p.permissions
}

func (p *Cluster) SetRequiredRngSources(attr []RngSource) {
	p.requiredRngSources = attr
}

func (p *Cluster) RequiredRngSources() ([]RngSource, bool) {
	if p.requiredRngSources != nil {
		return p.requiredRngSources, true
	}
	return nil, false
}

func (p *Cluster) MustRequiredRngSources() []RngSource {
	if p.requiredRngSources == nil {
		panic("the requiredRngSources must not be nil, please use RequiredRngSources() function instead")
	}
	return p.requiredRngSources
}

func (p *Cluster) SetSchedulingPolicy(attr *SchedulingPolicy) {
	p.schedulingPolicy = attr
}

func (p *Cluster) SchedulingPolicy() (*SchedulingPolicy, bool) {
	if p.schedulingPolicy != nil {
		return p.schedulingPolicy, true
	}
	return nil, false
}

func (p *Cluster) MustSchedulingPolicy() *SchedulingPolicy {
	if p.schedulingPolicy == nil {
		panic("the schedulingPolicy must not be nil, please use SchedulingPolicy() function instead")
	}
	return p.schedulingPolicy
}

func (p *Cluster) SetSerialNumber(attr *SerialNumber) {
	p.serialNumber = attr
}

func (p *Cluster) SerialNumber() (*SerialNumber, bool) {
	if p.serialNumber != nil {
		return p.serialNumber, true
	}
	return nil, false
}

func (p *Cluster) MustSerialNumber() *SerialNumber {
	if p.serialNumber == nil {
		panic("the serialNumber must not be nil, please use SerialNumber() function instead")
	}
	return p.serialNumber
}

func (p *Cluster) SetSupportedVersions(attr *VersionSlice) {
	p.supportedVersions = attr
}

func (p *Cluster) SupportedVersions() (*VersionSlice, bool) {
	if p.supportedVersions != nil {
		return p.supportedVersions, true
	}
	return nil, false
}

func (p *Cluster) MustSupportedVersions() *VersionSlice {
	if p.supportedVersions == nil {
		panic("the supportedVersions must not be nil, please use SupportedVersions() function instead")
	}
	return p.supportedVersions
}

// SetSwitchType Describes all switch types supported by the Manager.
func (p *Cluster) SetSwitchType(attr SwitchType) {
	p.switchType = &attr
}

// SwitchType Describes all switch types supported by the Manager.
func (p *Cluster) SwitchType() (SwitchType, bool) {
	if p.switchType != nil {
		return *p.switchType, true
	}
	var zero SwitchType
	return zero, false
}

// MustSwitchType Describes all switch types supported by the Manager.
func (p *Cluster) MustSwitchType() SwitchType {
	if p.switchType == nil {
		panic("the switchType must not be nil, please use SwitchType() function instead")
	}
	return *p.switchType
}

func (p *Cluster) SetThreadsAsCores(attr bool) {
	p.threadsAsCores = &attr
}

func (p *Cluster) ThreadsAsCores() (bool, bool) {
	if p.threadsAsCores != nil {
		return *p.threadsAsCores, true
	}
	var zero bool
	return zero, false
}

func (p *Cluster) MustThreadsAsCores() bool {
	if p.threadsAsCores == nil {
		panic("the threadsAsCores must not be nil, please use ThreadsAsCores() function instead")
	}
	return *p.threadsAsCores
}

func (p *Cluster) SetTrustedService(attr bool) {
	p.trustedService = &attr
}

func (p *Cluster) TrustedService() (bool, bool) {
	if p.trustedService != nil {
		return *p.trustedService, true
	}
	var zero bool
	return zero, false
}

func (p *Cluster) MustTrustedService() bool {
	if p.trustedService == nil {
		panic("the trustedService must not be nil, please use TrustedService() function instead")
	}
	return *p.trustedService
}

func (p *Cluster) SetTunnelMigration(attr bool) {
	p.tunnelMigration = &attr
}

func (p *Cluster) TunnelMigration() (bool, bool) {
	if p.tunnelMigration != nil {
		return *p.tunnelMigration, true
	}
	var zero bool
	return zero, false
}

func (p *Cluster) MustTunnelMigration() bool {
	if p.tunnelMigration == nil {
		panic("the tunnelMigration must not be nil, please use TunnelMigration() function instead")
	}
	return *p.tunnelMigration
}

func (p *Cluster) SetVersion(attr *Version) {
	p.version = attr
}

func (p *Cluster) Version() (*Version, bool) {
	if p.version != nil {
		return p.version, true
	}
	return nil, false
}

func (p *Cluster) MustVersion() *Version {
	if p.version == nil {
		panic("the version must not be nil, please use Version() function instead")
	}
	return p.version
}

func (p *Cluster) SetVirtService(attr bool) {
	p.virtService = &attr
}

func (p *Cluster) VirtService() (bool, bool) {
	if p.virtService != nil {
		return *p.virtService, true
	}
	var zero bool
	return zero, false
}

func (p *Cluster) MustVirtService() bool {
	if p.virtService == nil {
		panic("the virtService must not be nil, please use VirtService() function instead")
	}
	return *p.virtService
}

func (p *Cluster) SetVncEncryption(attr bool) {
	p.vncEncryption = &attr
}

func (p *Cluster) VncEncryption() (bool, bool) {
	if p.vncEncryption != nil {
		return *p.vncEncryption, true
	}
	var zero bool
	return zero, false
}

func (p *Cluster) MustVncEncryption() bool {
	if p.vncEncryption == nil {
		panic("the vncEncryption must not be nil, please use VncEncryption() function instead")
	}
	return *p.vncEncryption
}

// ClusterFeature Type represents an additional feature that is available at a cluster level.
type ClusterFeature struct {
	Struct
	clusterLevel *ClusterLevel
	comment      *string
	description  *string
	id           *string
	name         *string
}

// SetClusterLevel Describes the capabilities supported by a specific cluster level.
func (p *ClusterFeature) SetClusterLevel(attr *ClusterLevel) {
	p.clusterLevel = attr
}

// ClusterLevel Describes the capabilities supported by a specific cluster level.
func (p *ClusterFeature) ClusterLevel() (*ClusterLevel, bool) {
	if p.clusterLevel != nil {
		return p.clusterLevel, true
	}
	return nil, false
}

// MustClusterLevel Describes the capabilities supported by a specific cluster level.
func (p *ClusterFeature) MustClusterLevel() *ClusterLevel {
	if p.clusterLevel == nil {
		panic("the clusterLevel must not be nil, please use ClusterLevel() function instead")
	}
	return p.clusterLevel
}

func (p *ClusterFeature) SetComment(attr string) {
	p.comment = &attr
}

func (p *ClusterFeature) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *ClusterFeature) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *ClusterFeature) SetDescription(attr string) {
	p.description = &attr
}

func (p *ClusterFeature) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *ClusterFeature) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *ClusterFeature) SetId(attr string) {
	p.id = &attr
}

func (p *ClusterFeature) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *ClusterFeature) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *ClusterFeature) SetName(attr string) {
	p.name = &attr
}

func (p *ClusterFeature) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *ClusterFeature) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

// ClusterLevel Describes the capabilities supported by a specific cluster level.
type ClusterLevel struct {
	Struct
	clusterFeatures *ClusterFeatureSlice
	comment         *string
	cpuTypes        *CpuTypeSlice
	description     *string
	id              *string
	name            *string
	permits         *PermitSlice
}

func (p *ClusterLevel) SetClusterFeatures(attr *ClusterFeatureSlice) {
	p.clusterFeatures = attr
}

func (p *ClusterLevel) ClusterFeatures() (*ClusterFeatureSlice, bool) {
	if p.clusterFeatures != nil {
		return p.clusterFeatures, true
	}
	return nil, false
}

func (p *ClusterLevel) MustClusterFeatures() *ClusterFeatureSlice {
	if p.clusterFeatures == nil {
		panic("the clusterFeatures must not be nil, please use ClusterFeatures() function instead")
	}
	return p.clusterFeatures
}

func (p *ClusterLevel) SetComment(attr string) {
	p.comment = &attr
}

func (p *ClusterLevel) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *ClusterLevel) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *ClusterLevel) SetCpuTypes(attr *CpuTypeSlice) {
	p.cpuTypes = attr
}

func (p *ClusterLevel) CpuTypes() (*CpuTypeSlice, bool) {
	if p.cpuTypes != nil {
		return p.cpuTypes, true
	}
	return nil, false
}

func (p *ClusterLevel) MustCpuTypes() *CpuTypeSlice {
	if p.cpuTypes == nil {
		panic("the cpuTypes must not be nil, please use CpuTypes() function instead")
	}
	return p.cpuTypes
}

func (p *ClusterLevel) SetDescription(attr string) {
	p.description = &attr
}

func (p *ClusterLevel) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *ClusterLevel) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *ClusterLevel) SetId(attr string) {
	p.id = &attr
}

func (p *ClusterLevel) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *ClusterLevel) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *ClusterLevel) SetName(attr string) {
	p.name = &attr
}

func (p *ClusterLevel) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *ClusterLevel) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *ClusterLevel) SetPermits(attr *PermitSlice) {
	p.permits = attr
}

func (p *ClusterLevel) Permits() (*PermitSlice, bool) {
	if p.permits != nil {
		return p.permits, true
	}
	return nil, false
}

func (p *ClusterLevel) MustPermits() *PermitSlice {
	if p.permits == nil {
		panic("the permits must not be nil, please use Permits() function instead")
	}
	return p.permits
}

type Configuration struct {
	Struct
	data  *string
	type_ *ConfigurationType
}

func (p *Configuration) SetData(attr string) {
	p.data = &attr
}

func (p *Configuration) Data() (string, bool) {
	if p.data != nil {
		return *p.data, true
	}
	var zero string
	return zero, false
}

func (p *Configuration) MustData() string {
	if p.data == nil {
		panic("the data must not be nil, please use Data() function instead")
	}
	return *p.data
}

// SetType Configuration format types.
func (p *Configuration) SetType(attr ConfigurationType) {
	p.type_ = &attr
}

// Type Configuration format types.
func (p *Configuration) Type() (ConfigurationType, bool) {
	if p.type_ != nil {
		return *p.type_, true
	}
	var zero ConfigurationType
	return zero, false
}

// MustType Configuration format types.
func (p *Configuration) MustType() ConfigurationType {
	if p.type_ == nil {
		panic("the type_ must not be nil, please use Type() function instead")
	}
	return *p.type_
}

// Console Representation for serial console device.
type Console struct {
	Struct
	enabled *bool
}

func (p *Console) SetEnabled(attr bool) {
	p.enabled = &attr
}

func (p *Console) Enabled() (bool, bool) {
	if p.enabled != nil {
		return *p.enabled, true
	}
	var zero bool
	return zero, false
}

func (p *Console) MustEnabled() bool {
	if p.enabled == nil {
		panic("the enabled must not be nil, please use Enabled() function instead")
	}
	return *p.enabled
}

type Core struct {
	Struct
	index  *int64
	socket *int64
}

func (p *Core) SetIndex(attr int64) {
	p.index = &attr
}

func (p *Core) Index() (int64, bool) {
	if p.index != nil {
		return *p.index, true
	}
	var zero int64
	return zero, false
}

func (p *Core) MustIndex() int64 {
	if p.index == nil {
		panic("the index must not be nil, please use Index() function instead")
	}
	return *p.index
}

func (p *Core) SetSocket(attr int64) {
	p.socket = &attr
}

func (p *Core) Socket() (int64, bool) {
	if p.socket != nil {
		return *p.socket, true
	}
	var zero int64
	return zero, false
}

func (p *Core) MustSocket() int64 {
	if p.socket == nil {
		panic("the socket must not be nil, please use Socket() function instead")
	}
	return *p.socket
}

type Cpu struct {
	Struct
	architecture *Architecture
	cores        *CoreSlice
	cpuTune      *CpuTune
	level        *int64
	mode         *CpuMode
	name         *string
	speed        *float64
	topology     *CpuTopology
	type_        *string
}

func (p *Cpu) SetArchitecture(attr Architecture) {
	p.architecture = &attr
}

func (p *Cpu) Architecture() (Architecture, bool) {
	if p.architecture != nil {
		return *p.architecture, true
	}
	var zero Architecture
	return zero, false
}

func (p *Cpu) MustArchitecture() Architecture {
	if p.architecture == nil {
		panic("the architecture must not be nil, please use Architecture() function instead")
	}
	return *p.architecture
}

func (p *Cpu) SetCores(attr *CoreSlice) {
	p.cores = attr
}

func (p *Cpu) Cores() (*CoreSlice, bool) {
	if p.cores != nil {
		return p.cores, true
	}
	return nil, false
}

func (p *Cpu) MustCores() *CoreSlice {
	if p.cores == nil {
		panic("the cores must not be nil, please use Cores() function instead")
	}
	return p.cores
}

func (p *Cpu) SetCpuTune(attr *CpuTune) {
	p.cpuTune = attr
}

func (p *Cpu) CpuTune() (*CpuTune, bool) {
	if p.cpuTune != nil {
		return p.cpuTune, true
	}
	return nil, false
}

func (p *Cpu) MustCpuTune() *CpuTune {
	if p.cpuTune == nil {
		panic("the cpuTune must not be nil, please use CpuTune() function instead")
	}
	return p.cpuTune
}

func (p *Cpu) SetLevel(attr int64) {
	p.level = &attr
}

func (p *Cpu) Level() (int64, bool) {
	if p.level != nil {
		return *p.level, true
	}
	var zero int64
	return zero, false
}

func (p *Cpu) MustLevel() int64 {
	if p.level == nil {
		panic("the level must not be nil, please use Level() function instead")
	}
	return *p.level
}

func (p *Cpu) SetMode(attr CpuMode) {
	p.mode = &attr
}

func (p *Cpu) Mode() (CpuMode, bool) {
	if p.mode != nil {
		return *p.mode, true
	}
	var zero CpuMode
	return zero, false
}

func (p *Cpu) MustMode() CpuMode {
	if p.mode == nil {
		panic("the mode must not be nil, please use Mode() function instead")
	}
	return *p.mode
}

func (p *Cpu) SetName(attr string) {
	p.name = &attr
}

func (p *Cpu) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *Cpu) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *Cpu) SetSpeed(attr float64) {
	p.speed = &attr
}

func (p *Cpu) Speed() (float64, bool) {
	if p.speed != nil {
		return *p.speed, true
	}
	var zero float64
	return zero, false
}

func (p *Cpu) MustSpeed() float64 {
	if p.speed == nil {
		panic("the speed must not be nil, please use Speed() function instead")
	}
	return *p.speed
}

func (p *Cpu) SetTopology(attr *CpuTopology) {
	p.topology = attr
}

func (p *Cpu) Topology() (*CpuTopology, bool) {
	if p.topology != nil {
		return p.topology, true
	}
	return nil, false
}

func (p *Cpu) MustTopology() *CpuTopology {
	if p.topology == nil {
		panic("the topology must not be nil, please use Topology() function instead")
	}
	return p.topology
}

func (p *Cpu) SetType(attr string) {
	p.type_ = &attr
}

func (p *Cpu) Type() (string, bool) {
	if p.type_ != nil {
		return *p.type_, true
	}
	var zero string
	return zero, false
}

func (p *Cpu) MustType() string {
	if p.type_ == nil {
		panic("the type_ must not be nil, please use Type() function instead")
	}
	return *p.type_
}

type CpuProfile struct {
	Struct
	cluster     *Cluster
	comment     *string
	description *string
	id          *string
	name        *string
	permissions *PermissionSlice
	qos         *Qos
}

// SetCluster Type representation of a cluster.
//
// A JSON representation of a cluster:
//
// [source]
// ----
// {
//   "cluster" : [ {
//     "ballooning_enabled" : "false",
//     "cpu" : {
//       "architecture" : "x86_64",
//       "type" : "Intel SandyBridge Family"
//     },
//     "custom_scheduling_policy_properties" : {
//       "property" : [ {
//         "name" : "HighUtilization",
//         "value" : "80"
//       }, {
//         "name" : "CpuOverCommitDurationMinutes",
//         "value" : "2"
//       } ]
//     },
//     "error_handling" : {
//       "on_error" : "migrate"
//     },
//     "fencing_policy" : {
//       "enabled" : "true",
//       "skip_if_connectivity_broken" : {
//         "enabled" : "false",
//         "threshold" : "50"
//       },
//       "skip_if_gluster_bricks_up" : "false",
//       "skip_if_gluster_quorum_not_met" : "false",
//       "skip_if_sd_active" : {
//         "enabled" : "false"
//       }
//     },
//     "gluster_service" : "false",
//     "firewall_type" : "iptables",
//     "ha_reservation" : "false",
//     "ksm" : {
//       "enabled" : "true",
//       "merge_across_nodes" : "true"
//     },
//     "memory_policy" : {
//       "over_commit" : {
//         "percent" : "100"
//       },
//       "transparent_hugepages" : {
//         "enabled" : "true"
//       }
//     },
//     "migration" : {
//       "auto_converge" : "inherit",
//       "bandwidth" : {
//         "assignment_method" : "auto"
//       },
//       "compressed" : "inherit",
//       "policy" : {
//         "id" : "00000000-0000-0000-0000-000000000000"
//       }
//     },
//     "required_rng_sources" : {
//       "required_rng_source" : [ "random" ]
//     },
//     "switch_type" : "legacy",
//     "threads_as_cores" : "false",
//     "trusted_service" : "false",
//     "tunnel_migration" : "false",
//     "version" : {
//       "major" : "4",
//       "minor" : "1"
//     },
//     "virt_service" : "true",
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "mac_pool" : {
//       "href" : "/ovirt-engine/api/macpools/456",
//       "id" : "456"
//     },
//     "scheduling_policy" : {
//       "href" : "/ovirt-engine/api/schedulingpolicies/789",
//       "id" : "789"
//     },
//     "actions" : {
//       "link" : [ {
//         "href" : "/ovirt-engine/api/clusters/234/resetemulatedmachine",
//         "rel" : "resetemulatedmachine"
//       } ]
//     },
//     "name" : "Default",
//     "description" : "The default server cluster",
//     "href" : "/ovirt-engine/api/clusters/234",
//     "id" : "234",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/clusters/234/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/cpuprofiles",
//       "rel" : "cpuprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networkfilters",
//       "rel" : "networkfilters"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networks",
//       "rel" : "networks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/affinitygroups",
//       "rel" : "affinitygroups"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glusterhooks",
//       "rel" : "glusterhooks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glustervolumes",
//       "rel" : "glustervolumes"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/enabledfeatures",
//       "rel" : "enabledfeatures"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/externalnetworkproviders",
//       "rel" : "externalnetworkproviders"
//     } ]
//   } ]
// }
// ----
func (p *CpuProfile) SetCluster(attr *Cluster) {
	p.cluster = attr
}

// Cluster Type representation of a cluster.
//
// A JSON representation of a cluster:
//
// [source]
// ----
// {
//   "cluster" : [ {
//     "ballooning_enabled" : "false",
//     "cpu" : {
//       "architecture" : "x86_64",
//       "type" : "Intel SandyBridge Family"
//     },
//     "custom_scheduling_policy_properties" : {
//       "property" : [ {
//         "name" : "HighUtilization",
//         "value" : "80"
//       }, {
//         "name" : "CpuOverCommitDurationMinutes",
//         "value" : "2"
//       } ]
//     },
//     "error_handling" : {
//       "on_error" : "migrate"
//     },
//     "fencing_policy" : {
//       "enabled" : "true",
//       "skip_if_connectivity_broken" : {
//         "enabled" : "false",
//         "threshold" : "50"
//       },
//       "skip_if_gluster_bricks_up" : "false",
//       "skip_if_gluster_quorum_not_met" : "false",
//       "skip_if_sd_active" : {
//         "enabled" : "false"
//       }
//     },
//     "gluster_service" : "false",
//     "firewall_type" : "iptables",
//     "ha_reservation" : "false",
//     "ksm" : {
//       "enabled" : "true",
//       "merge_across_nodes" : "true"
//     },
//     "memory_policy" : {
//       "over_commit" : {
//         "percent" : "100"
//       },
//       "transparent_hugepages" : {
//         "enabled" : "true"
//       }
//     },
//     "migration" : {
//       "auto_converge" : "inherit",
//       "bandwidth" : {
//         "assignment_method" : "auto"
//       },
//       "compressed" : "inherit",
//       "policy" : {
//         "id" : "00000000-0000-0000-0000-000000000000"
//       }
//     },
//     "required_rng_sources" : {
//       "required_rng_source" : [ "random" ]
//     },
//     "switch_type" : "legacy",
//     "threads_as_cores" : "false",
//     "trusted_service" : "false",
//     "tunnel_migration" : "false",
//     "version" : {
//       "major" : "4",
//       "minor" : "1"
//     },
//     "virt_service" : "true",
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "mac_pool" : {
//       "href" : "/ovirt-engine/api/macpools/456",
//       "id" : "456"
//     },
//     "scheduling_policy" : {
//       "href" : "/ovirt-engine/api/schedulingpolicies/789",
//       "id" : "789"
//     },
//     "actions" : {
//       "link" : [ {
//         "href" : "/ovirt-engine/api/clusters/234/resetemulatedmachine",
//         "rel" : "resetemulatedmachine"
//       } ]
//     },
//     "name" : "Default",
//     "description" : "The default server cluster",
//     "href" : "/ovirt-engine/api/clusters/234",
//     "id" : "234",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/clusters/234/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/cpuprofiles",
//       "rel" : "cpuprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networkfilters",
//       "rel" : "networkfilters"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networks",
//       "rel" : "networks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/affinitygroups",
//       "rel" : "affinitygroups"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glusterhooks",
//       "rel" : "glusterhooks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glustervolumes",
//       "rel" : "glustervolumes"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/enabledfeatures",
//       "rel" : "enabledfeatures"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/externalnetworkproviders",
//       "rel" : "externalnetworkproviders"
//     } ]
//   } ]
// }
// ----
func (p *CpuProfile) Cluster() (*Cluster, bool) {
	if p.cluster != nil {
		return p.cluster, true
	}
	return nil, false
}

// MustCluster Type representation of a cluster.
//
// A JSON representation of a cluster:
//
// [source]
// ----
// {
//   "cluster" : [ {
//     "ballooning_enabled" : "false",
//     "cpu" : {
//       "architecture" : "x86_64",
//       "type" : "Intel SandyBridge Family"
//     },
//     "custom_scheduling_policy_properties" : {
//       "property" : [ {
//         "name" : "HighUtilization",
//         "value" : "80"
//       }, {
//         "name" : "CpuOverCommitDurationMinutes",
//         "value" : "2"
//       } ]
//     },
//     "error_handling" : {
//       "on_error" : "migrate"
//     },
//     "fencing_policy" : {
//       "enabled" : "true",
//       "skip_if_connectivity_broken" : {
//         "enabled" : "false",
//         "threshold" : "50"
//       },
//       "skip_if_gluster_bricks_up" : "false",
//       "skip_if_gluster_quorum_not_met" : "false",
//       "skip_if_sd_active" : {
//         "enabled" : "false"
//       }
//     },
//     "gluster_service" : "false",
//     "firewall_type" : "iptables",
//     "ha_reservation" : "false",
//     "ksm" : {
//       "enabled" : "true",
//       "merge_across_nodes" : "true"
//     },
//     "memory_policy" : {
//       "over_commit" : {
//         "percent" : "100"
//       },
//       "transparent_hugepages" : {
//         "enabled" : "true"
//       }
//     },
//     "migration" : {
//       "auto_converge" : "inherit",
//       "bandwidth" : {
//         "assignment_method" : "auto"
//       },
//       "compressed" : "inherit",
//       "policy" : {
//         "id" : "00000000-0000-0000-0000-000000000000"
//       }
//     },
//     "required_rng_sources" : {
//       "required_rng_source" : [ "random" ]
//     },
//     "switch_type" : "legacy",
//     "threads_as_cores" : "false",
//     "trusted_service" : "false",
//     "tunnel_migration" : "false",
//     "version" : {
//       "major" : "4",
//       "minor" : "1"
//     },
//     "virt_service" : "true",
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "mac_pool" : {
//       "href" : "/ovirt-engine/api/macpools/456",
//       "id" : "456"
//     },
//     "scheduling_policy" : {
//       "href" : "/ovirt-engine/api/schedulingpolicies/789",
//       "id" : "789"
//     },
//     "actions" : {
//       "link" : [ {
//         "href" : "/ovirt-engine/api/clusters/234/resetemulatedmachine",
//         "rel" : "resetemulatedmachine"
//       } ]
//     },
//     "name" : "Default",
//     "description" : "The default server cluster",
//     "href" : "/ovirt-engine/api/clusters/234",
//     "id" : "234",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/clusters/234/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/cpuprofiles",
//       "rel" : "cpuprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networkfilters",
//       "rel" : "networkfilters"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networks",
//       "rel" : "networks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/affinitygroups",
//       "rel" : "affinitygroups"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glusterhooks",
//       "rel" : "glusterhooks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glustervolumes",
//       "rel" : "glustervolumes"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/enabledfeatures",
//       "rel" : "enabledfeatures"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/externalnetworkproviders",
//       "rel" : "externalnetworkproviders"
//     } ]
//   } ]
// }
// ----
func (p *CpuProfile) MustCluster() *Cluster {
	if p.cluster == nil {
		panic("the cluster must not be nil, please use Cluster() function instead")
	}
	return p.cluster
}

func (p *CpuProfile) SetComment(attr string) {
	p.comment = &attr
}

func (p *CpuProfile) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *CpuProfile) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *CpuProfile) SetDescription(attr string) {
	p.description = &attr
}

func (p *CpuProfile) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *CpuProfile) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *CpuProfile) SetId(attr string) {
	p.id = &attr
}

func (p *CpuProfile) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *CpuProfile) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *CpuProfile) SetName(attr string) {
	p.name = &attr
}

func (p *CpuProfile) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *CpuProfile) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *CpuProfile) SetPermissions(attr *PermissionSlice) {
	p.permissions = attr
}

func (p *CpuProfile) Permissions() (*PermissionSlice, bool) {
	if p.permissions != nil {
		return p.permissions, true
	}
	return nil, false
}

func (p *CpuProfile) MustPermissions() *PermissionSlice {
	if p.permissions == nil {
		panic("the permissions must not be nil, please use Permissions() function instead")
	}
	return p.permissions
}

// SetQos This type represents the attributes to define Quality of service (QoS).
//
// For storage the `type` is <<types/qos_type, storage>>, the attributes `max_throughput`, `max_read_throughput`,
// `max_write_throughput`, `max_iops`, `max_read_iops` and `max_write_iops` are relevant.
//
// For resources with computing capabilities the `type` is <<types/qos_type, cpu>>, the attribute `cpu_limit` is
// relevant.
//
// For virtual machines networks the `type` is <<types/qos_type, network>>, the attributes `inbound_average`,
// `inbound_peak`, `inbound_burst`, `outbound_average`, `outbound_peak` and `outbound_burst` are relevant.
//
// For host networks the `type` is <<types/qos_type, hostnetwork>>, the attributes `outbound_average_linkshare`,
// `outbound_average_upperlimit` and `outbound_average_realtime` are relevant.
func (p *CpuProfile) SetQos(attr *Qos) {
	p.qos = attr
}

// Qos This type represents the attributes to define Quality of service (QoS).
//
// For storage the `type` is <<types/qos_type, storage>>, the attributes `max_throughput`, `max_read_throughput`,
// `max_write_throughput`, `max_iops`, `max_read_iops` and `max_write_iops` are relevant.
//
// For resources with computing capabilities the `type` is <<types/qos_type, cpu>>, the attribute `cpu_limit` is
// relevant.
//
// For virtual machines networks the `type` is <<types/qos_type, network>>, the attributes `inbound_average`,
// `inbound_peak`, `inbound_burst`, `outbound_average`, `outbound_peak` and `outbound_burst` are relevant.
//
// For host networks the `type` is <<types/qos_type, hostnetwork>>, the attributes `outbound_average_linkshare`,
// `outbound_average_upperlimit` and `outbound_average_realtime` are relevant.
func (p *CpuProfile) Qos() (*Qos, bool) {
	if p.qos != nil {
		return p.qos, true
	}
	return nil, false
}

// MustQos This type represents the attributes to define Quality of service (QoS).
//
// For storage the `type` is <<types/qos_type, storage>>, the attributes `max_throughput`, `max_read_throughput`,
// `max_write_throughput`, `max_iops`, `max_read_iops` and `max_write_iops` are relevant.
//
// For resources with computing capabilities the `type` is <<types/qos_type, cpu>>, the attribute `cpu_limit` is
// relevant.
//
// For virtual machines networks the `type` is <<types/qos_type, network>>, the attributes `inbound_average`,
// `inbound_peak`, `inbound_burst`, `outbound_average`, `outbound_peak` and `outbound_burst` are relevant.
//
// For host networks the `type` is <<types/qos_type, hostnetwork>>, the attributes `outbound_average_linkshare`,
// `outbound_average_upperlimit` and `outbound_average_realtime` are relevant.
func (p *CpuProfile) MustQos() *Qos {
	if p.qos == nil {
		panic("the qos must not be nil, please use Qos() function instead")
	}
	return p.qos
}

type CpuTopology struct {
	Struct
	cores   *int64
	sockets *int64
	threads *int64
}

func (p *CpuTopology) SetCores(attr int64) {
	p.cores = &attr
}

func (p *CpuTopology) Cores() (int64, bool) {
	if p.cores != nil {
		return *p.cores, true
	}
	var zero int64
	return zero, false
}

func (p *CpuTopology) MustCores() int64 {
	if p.cores == nil {
		panic("the cores must not be nil, please use Cores() function instead")
	}
	return *p.cores
}

func (p *CpuTopology) SetSockets(attr int64) {
	p.sockets = &attr
}

func (p *CpuTopology) Sockets() (int64, bool) {
	if p.sockets != nil {
		return *p.sockets, true
	}
	var zero int64
	return zero, false
}

func (p *CpuTopology) MustSockets() int64 {
	if p.sockets == nil {
		panic("the sockets must not be nil, please use Sockets() function instead")
	}
	return *p.sockets
}

func (p *CpuTopology) SetThreads(attr int64) {
	p.threads = &attr
}

func (p *CpuTopology) Threads() (int64, bool) {
	if p.threads != nil {
		return *p.threads, true
	}
	var zero int64
	return zero, false
}

func (p *CpuTopology) MustThreads() int64 {
	if p.threads == nil {
		panic("the threads must not be nil, please use Threads() function instead")
	}
	return *p.threads
}

type CpuTune struct {
	Struct
	vcpuPins *VcpuPinSlice
}

func (p *CpuTune) SetVcpuPins(attr *VcpuPinSlice) {
	p.vcpuPins = attr
}

func (p *CpuTune) VcpuPins() (*VcpuPinSlice, bool) {
	if p.vcpuPins != nil {
		return p.vcpuPins, true
	}
	return nil, false
}

func (p *CpuTune) MustVcpuPins() *VcpuPinSlice {
	if p.vcpuPins == nil {
		panic("the vcpuPins must not be nil, please use VcpuPins() function instead")
	}
	return p.vcpuPins
}

// CpuType Describes a supported CPU type.
type CpuType struct {
	Struct
	architecture *Architecture
	level        *int64
	name         *string
}

func (p *CpuType) SetArchitecture(attr Architecture) {
	p.architecture = &attr
}

func (p *CpuType) Architecture() (Architecture, bool) {
	if p.architecture != nil {
		return *p.architecture, true
	}
	var zero Architecture
	return zero, false
}

func (p *CpuType) MustArchitecture() Architecture {
	if p.architecture == nil {
		panic("the architecture must not be nil, please use Architecture() function instead")
	}
	return *p.architecture
}

func (p *CpuType) SetLevel(attr int64) {
	p.level = &attr
}

func (p *CpuType) Level() (int64, bool) {
	if p.level != nil {
		return *p.level, true
	}
	var zero int64
	return zero, false
}

func (p *CpuType) MustLevel() int64 {
	if p.level == nil {
		panic("the level must not be nil, please use Level() function instead")
	}
	return *p.level
}

func (p *CpuType) SetName(attr string) {
	p.name = &attr
}

func (p *CpuType) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *CpuType) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

// CustomProperty Custom property representation.
type CustomProperty struct {
	Struct
	name   *string
	regexp *string
	value  *string
}

func (p *CustomProperty) SetName(attr string) {
	p.name = &attr
}

func (p *CustomProperty) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *CustomProperty) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *CustomProperty) SetRegexp(attr string) {
	p.regexp = &attr
}

func (p *CustomProperty) Regexp() (string, bool) {
	if p.regexp != nil {
		return *p.regexp, true
	}
	var zero string
	return zero, false
}

func (p *CustomProperty) MustRegexp() string {
	if p.regexp == nil {
		panic("the regexp must not be nil, please use Regexp() function instead")
	}
	return *p.regexp
}

func (p *CustomProperty) SetValue(attr string) {
	p.value = &attr
}

func (p *CustomProperty) Value() (string, bool) {
	if p.value != nil {
		return *p.value, true
	}
	var zero string
	return zero, false
}

func (p *CustomProperty) MustValue() string {
	if p.value == nil {
		panic("the value must not be nil, please use Value() function instead")
	}
	return *p.value
}

type DataCenter struct {
	Struct
	clusters          *ClusterSlice
	comment           *string
	description       *string
	id                *string
	iscsiBonds        *IscsiBondSlice
	local             *bool
	macPool           *MacPool
	name              *string
	networks          *NetworkSlice
	permissions       *PermissionSlice
	qoss              *QosSlice
	quotaMode         *QuotaModeType
	quotas            *QuotaSlice
	status            *DataCenterStatus
	storageDomains    *StorageDomainSlice
	storageFormat     *StorageFormat
	supportedVersions *VersionSlice
	version           *Version
}

func (p *DataCenter) SetClusters(attr *ClusterSlice) {
	p.clusters = attr
}

func (p *DataCenter) Clusters() (*ClusterSlice, bool) {
	if p.clusters != nil {
		return p.clusters, true
	}
	return nil, false
}

func (p *DataCenter) MustClusters() *ClusterSlice {
	if p.clusters == nil {
		panic("the clusters must not be nil, please use Clusters() function instead")
	}
	return p.clusters
}

func (p *DataCenter) SetComment(attr string) {
	p.comment = &attr
}

func (p *DataCenter) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *DataCenter) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *DataCenter) SetDescription(attr string) {
	p.description = &attr
}

func (p *DataCenter) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *DataCenter) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *DataCenter) SetId(attr string) {
	p.id = &attr
}

func (p *DataCenter) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *DataCenter) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *DataCenter) SetIscsiBonds(attr *IscsiBondSlice) {
	p.iscsiBonds = attr
}

func (p *DataCenter) IscsiBonds() (*IscsiBondSlice, bool) {
	if p.iscsiBonds != nil {
		return p.iscsiBonds, true
	}
	return nil, false
}

func (p *DataCenter) MustIscsiBonds() *IscsiBondSlice {
	if p.iscsiBonds == nil {
		panic("the iscsiBonds must not be nil, please use IscsiBonds() function instead")
	}
	return p.iscsiBonds
}

func (p *DataCenter) SetLocal(attr bool) {
	p.local = &attr
}

func (p *DataCenter) Local() (bool, bool) {
	if p.local != nil {
		return *p.local, true
	}
	var zero bool
	return zero, false
}

func (p *DataCenter) MustLocal() bool {
	if p.local == nil {
		panic("the local must not be nil, please use Local() function instead")
	}
	return *p.local
}

// SetMacPool Represents a MAC address pool.
//
// Example of an XML representation of a MAC address pool:
//
// [source,xml]
// ----
// <mac_pool href="/ovirt-engine/api/macpools/123" id="123">
//   <name>Default</name>
//   <description>Default MAC pool</description>
//   <allow_duplicates>false</allow_duplicates>
//   <default_pool>true</default_pool>
//   <ranges>
//     <range>
//       <from>00:1A:4A:16:01:51</from>
//       <to>00:1A:4A:16:01:E6</to>
//     </range>
//   </ranges>
// </mac_pool>
// ----
func (p *DataCenter) SetMacPool(attr *MacPool) {
	p.macPool = attr
}

// MacPool Represents a MAC address pool.
//
// Example of an XML representation of a MAC address pool:
//
// [source,xml]
// ----
// <mac_pool href="/ovirt-engine/api/macpools/123" id="123">
//   <name>Default</name>
//   <description>Default MAC pool</description>
//   <allow_duplicates>false</allow_duplicates>
//   <default_pool>true</default_pool>
//   <ranges>
//     <range>
//       <from>00:1A:4A:16:01:51</from>
//       <to>00:1A:4A:16:01:E6</to>
//     </range>
//   </ranges>
// </mac_pool>
// ----
func (p *DataCenter) MacPool() (*MacPool, bool) {
	if p.macPool != nil {
		return p.macPool, true
	}
	return nil, false
}

// MustMacPool Represents a MAC address pool.
//
// Example of an XML representation of a MAC address pool:
//
// [source,xml]
// ----
// <mac_pool href="/ovirt-engine/api/macpools/123" id="123">
//   <name>Default</name>
//   <description>Default MAC pool</description>
//   <allow_duplicates>false</allow_duplicates>
//   <default_pool>true</default_pool>
//   <ranges>
//     <range>
//       <from>00:1A:4A:16:01:51</from>
//       <to>00:1A:4A:16:01:E6</to>
//     </range>
//   </ranges>
// </mac_pool>
// ----
func (p *DataCenter) MustMacPool() *MacPool {
	if p.macPool == nil {
		panic("the macPool must not be nil, please use MacPool() function instead")
	}
	return p.macPool
}

func (p *DataCenter) SetName(attr string) {
	p.name = &attr
}

func (p *DataCenter) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *DataCenter) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *DataCenter) SetNetworks(attr *NetworkSlice) {
	p.networks = attr
}

func (p *DataCenter) Networks() (*NetworkSlice, bool) {
	if p.networks != nil {
		return p.networks, true
	}
	return nil, false
}

func (p *DataCenter) MustNetworks() *NetworkSlice {
	if p.networks == nil {
		panic("the networks must not be nil, please use Networks() function instead")
	}
	return p.networks
}

func (p *DataCenter) SetPermissions(attr *PermissionSlice) {
	p.permissions = attr
}

func (p *DataCenter) Permissions() (*PermissionSlice, bool) {
	if p.permissions != nil {
		return p.permissions, true
	}
	return nil, false
}

func (p *DataCenter) MustPermissions() *PermissionSlice {
	if p.permissions == nil {
		panic("the permissions must not be nil, please use Permissions() function instead")
	}
	return p.permissions
}

func (p *DataCenter) SetQoss(attr *QosSlice) {
	p.qoss = attr
}

func (p *DataCenter) Qoss() (*QosSlice, bool) {
	if p.qoss != nil {
		return p.qoss, true
	}
	return nil, false
}

func (p *DataCenter) MustQoss() *QosSlice {
	if p.qoss == nil {
		panic("the qoss must not be nil, please use Qoss() function instead")
	}
	return p.qoss
}

func (p *DataCenter) SetQuotaMode(attr QuotaModeType) {
	p.quotaMode = &attr
}

func (p *DataCenter) QuotaMode() (QuotaModeType, bool) {
	if p.quotaMode != nil {
		return *p.quotaMode, true
	}
	var zero QuotaModeType
	return zero, false
}

func (p *DataCenter) MustQuotaMode() QuotaModeType {
	if p.quotaMode == nil {
		panic("the quotaMode must not be nil, please use QuotaMode() function instead")
	}
	return *p.quotaMode
}

func (p *DataCenter) SetQuotas(attr *QuotaSlice) {
	p.quotas = attr
}

func (p *DataCenter) Quotas() (*QuotaSlice, bool) {
	if p.quotas != nil {
		return p.quotas, true
	}
	return nil, false
}

func (p *DataCenter) MustQuotas() *QuotaSlice {
	if p.quotas == nil {
		panic("the quotas must not be nil, please use Quotas() function instead")
	}
	return p.quotas
}

func (p *DataCenter) SetStatus(attr DataCenterStatus) {
	p.status = &attr
}

func (p *DataCenter) Status() (DataCenterStatus, bool) {
	if p.status != nil {
		return *p.status, true
	}
	var zero DataCenterStatus
	return zero, false
}

func (p *DataCenter) MustStatus() DataCenterStatus {
	if p.status == nil {
		panic("the status must not be nil, please use Status() function instead")
	}
	return *p.status
}

func (p *DataCenter) SetStorageDomains(attr *StorageDomainSlice) {
	p.storageDomains = attr
}

func (p *DataCenter) StorageDomains() (*StorageDomainSlice, bool) {
	if p.storageDomains != nil {
		return p.storageDomains, true
	}
	return nil, false
}

func (p *DataCenter) MustStorageDomains() *StorageDomainSlice {
	if p.storageDomains == nil {
		panic("the storageDomains must not be nil, please use StorageDomains() function instead")
	}
	return p.storageDomains
}

// SetStorageFormat Type which represents a format of <<types/storage_domain, storage domain>>.
func (p *DataCenter) SetStorageFormat(attr StorageFormat) {
	p.storageFormat = &attr
}

// StorageFormat Type which represents a format of <<types/storage_domain, storage domain>>.
func (p *DataCenter) StorageFormat() (StorageFormat, bool) {
	if p.storageFormat != nil {
		return *p.storageFormat, true
	}
	var zero StorageFormat
	return zero, false
}

// MustStorageFormat Type which represents a format of <<types/storage_domain, storage domain>>.
func (p *DataCenter) MustStorageFormat() StorageFormat {
	if p.storageFormat == nil {
		panic("the storageFormat must not be nil, please use StorageFormat() function instead")
	}
	return *p.storageFormat
}

func (p *DataCenter) SetSupportedVersions(attr *VersionSlice) {
	p.supportedVersions = attr
}

func (p *DataCenter) SupportedVersions() (*VersionSlice, bool) {
	if p.supportedVersions != nil {
		return p.supportedVersions, true
	}
	return nil, false
}

func (p *DataCenter) MustSupportedVersions() *VersionSlice {
	if p.supportedVersions == nil {
		panic("the supportedVersions must not be nil, please use SupportedVersions() function instead")
	}
	return p.supportedVersions
}

func (p *DataCenter) SetVersion(attr *Version) {
	p.version = attr
}

func (p *DataCenter) Version() (*Version, bool) {
	if p.version != nil {
		return p.version, true
	}
	return nil, false
}

func (p *DataCenter) MustVersion() *Version {
	if p.version == nil {
		panic("the version must not be nil, please use Version() function instead")
	}
	return p.version
}

// Device A device wraps links to potential parents of a device.
type Device struct {
	Struct
	comment      *string
	description  *string
	id           *string
	instanceType *InstanceType
	name         *string
	template     *Template
	vm           *Vm
	vms          *VmSlice
}

func (p *Device) SetComment(attr string) {
	p.comment = &attr
}

func (p *Device) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *Device) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *Device) SetDescription(attr string) {
	p.description = &attr
}

func (p *Device) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *Device) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *Device) SetId(attr string) {
	p.id = &attr
}

func (p *Device) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *Device) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

// SetInstanceType Describes the hardware configuration of virtual machines.
//
// For example `medium` instance type includes 1 virtual CPU and 4 GiB of memory. It is a top-level
// entity (e.g. not bound to any data center or cluster). The attributes that are used for instance
// types and are common to virtual machine and template types are:
//
// - `console`
// - `cpu`
// - `custom_cpu_model`
// - `custom_emulated_machine`
// - `display`
// - `high_availability`
// - `io`
// - `memory`
// - `memory_policy`
// - `migration`
// - `migration_downtime`
// - `os`
// - `rng_device`
// - `soundcard_enabled`
// - `usb`
// - `virtio_scsi`
//
// When creating a virtual machine from both an instance type and a template, the virtual machine
// will inherit the hardware configurations from the instance type
//
// NOTE: An instance type inherits it's attributes from the template entity although most template
// attributes are not used in instance types.
func (p *Device) SetInstanceType(attr *InstanceType) {
	p.instanceType = attr
}

// InstanceType Describes the hardware configuration of virtual machines.
//
// For example `medium` instance type includes 1 virtual CPU and 4 GiB of memory. It is a top-level
// entity (e.g. not bound to any data center or cluster). The attributes that are used for instance
// types and are common to virtual machine and template types are:
//
// - `console`
// - `cpu`
// - `custom_cpu_model`
// - `custom_emulated_machine`
// - `display`
// - `high_availability`
// - `io`
// - `memory`
// - `memory_policy`
// - `migration`
// - `migration_downtime`
// - `os`
// - `rng_device`
// - `soundcard_enabled`
// - `usb`
// - `virtio_scsi`
//
// When creating a virtual machine from both an instance type and a template, the virtual machine
// will inherit the hardware configurations from the instance type
//
// NOTE: An instance type inherits it's attributes from the template entity although most template
// attributes are not used in instance types.
func (p *Device) InstanceType() (*InstanceType, bool) {
	if p.instanceType != nil {
		return p.instanceType, true
	}
	return nil, false
}

// MustInstanceType Describes the hardware configuration of virtual machines.
//
// For example `medium` instance type includes 1 virtual CPU and 4 GiB of memory. It is a top-level
// entity (e.g. not bound to any data center or cluster). The attributes that are used for instance
// types and are common to virtual machine and template types are:
//
// - `console`
// - `cpu`
// - `custom_cpu_model`
// - `custom_emulated_machine`
// - `display`
// - `high_availability`
// - `io`
// - `memory`
// - `memory_policy`
// - `migration`
// - `migration_downtime`
// - `os`
// - `rng_device`
// - `soundcard_enabled`
// - `usb`
// - `virtio_scsi`
//
// When creating a virtual machine from both an instance type and a template, the virtual machine
// will inherit the hardware configurations from the instance type
//
// NOTE: An instance type inherits it's attributes from the template entity although most template
// attributes are not used in instance types.
func (p *Device) MustInstanceType() *InstanceType {
	if p.instanceType == nil {
		panic("the instanceType must not be nil, please use InstanceType() function instead")
	}
	return p.instanceType
}

func (p *Device) SetName(attr string) {
	p.name = &attr
}

func (p *Device) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *Device) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

// SetTemplate The type that represents a virtual machine template.
// Templates allow for a rapid instantiation of virtual machines with common configuration and disk states.
func (p *Device) SetTemplate(attr *Template) {
	p.template = attr
}

// Template The type that represents a virtual machine template.
// Templates allow for a rapid instantiation of virtual machines with common configuration and disk states.
func (p *Device) Template() (*Template, bool) {
	if p.template != nil {
		return p.template, true
	}
	return nil, false
}

// MustTemplate The type that represents a virtual machine template.
// Templates allow for a rapid instantiation of virtual machines with common configuration and disk states.
func (p *Device) MustTemplate() *Template {
	if p.template == nil {
		panic("the template must not be nil, please use Template() function instead")
	}
	return p.template
}

// SetVm Represents a virtual machine.
func (p *Device) SetVm(attr *Vm) {
	p.vm = attr
}

// Vm Represents a virtual machine.
func (p *Device) Vm() (*Vm, bool) {
	if p.vm != nil {
		return p.vm, true
	}
	return nil, false
}

// MustVm Represents a virtual machine.
func (p *Device) MustVm() *Vm {
	if p.vm == nil {
		panic("the vm must not be nil, please use Vm() function instead")
	}
	return p.vm
}

func (p *Device) SetVms(attr *VmSlice) {
	p.vms = attr
}

func (p *Device) Vms() (*VmSlice, bool) {
	if p.vms != nil {
		return p.vms, true
	}
	return nil, false
}

func (p *Device) MustVms() *VmSlice {
	if p.vms == nil {
		panic("the vms must not be nil, please use Vms() function instead")
	}
	return p.vms
}

// Disk Represents a virtual disk device.
type Disk struct {
	Struct
	active              *bool
	actualSize          *int64
	alias               *string
	backup              *DiskBackup
	backupMode          *DiskBackupMode
	bootable            *bool
	comment             *string
	contentType         *DiskContentType
	description         *string
	diskProfile         *DiskProfile
	diskSnapshots       *DiskSnapshotSlice
	externalDisk        *string
	format              *DiskFormat
	id                  *string
	imageId             *string
	initialSize         *int64
	instanceType        *InstanceType
	interface_          *DiskInterface
	logicalName         *string
	lunStorage          *HostStorage
	name                *string
	openstackVolumeType *OpenStackVolumeType
	permissions         *PermissionSlice
	propagateErrors     *bool
	provisionedSize     *int64
	qcowVersion         *QcowVersion
	quota               *Quota
	readOnly            *bool
	sgio                *ScsiGenericIO
	shareable           *bool
	snapshot            *Snapshot
	sparse              *bool
	statistics          *StatisticSlice
	status              *DiskStatus
	storageDomain       *StorageDomain
	storageDomains      *StorageDomainSlice
	storageType         *DiskStorageType
	template            *Template
	totalSize           *int64
	usesScsiReservation *bool
	vm                  *Vm
	vms                 *VmSlice
	wipeAfterDelete     *bool
}

func (p *Disk) SetActive(attr bool) {
	p.active = &attr
}

func (p *Disk) Active() (bool, bool) {
	if p.active != nil {
		return *p.active, true
	}
	var zero bool
	return zero, false
}

func (p *Disk) MustActive() bool {
	if p.active == nil {
		panic("the active must not be nil, please use Active() function instead")
	}
	return *p.active
}

func (p *Disk) SetActualSize(attr int64) {
	p.actualSize = &attr
}

func (p *Disk) ActualSize() (int64, bool) {
	if p.actualSize != nil {
		return *p.actualSize, true
	}
	var zero int64
	return zero, false
}

func (p *Disk) MustActualSize() int64 {
	if p.actualSize == nil {
		panic("the actualSize must not be nil, please use ActualSize() function instead")
	}
	return *p.actualSize
}

func (p *Disk) SetAlias(attr string) {
	p.alias = &attr
}

func (p *Disk) Alias() (string, bool) {
	if p.alias != nil {
		return *p.alias, true
	}
	var zero string
	return zero, false
}

func (p *Disk) MustAlias() string {
	if p.alias == nil {
		panic("the alias must not be nil, please use Alias() function instead")
	}
	return *p.alias
}

// SetBackup Represents an enumeration of the backup mechanism
// that is enabled on the disk.
func (p *Disk) SetBackup(attr DiskBackup) {
	p.backup = &attr
}

// Backup Represents an enumeration of the backup mechanism
// that is enabled on the disk.
func (p *Disk) Backup() (DiskBackup, bool) {
	if p.backup != nil {
		return *p.backup, true
	}
	var zero DiskBackup
	return zero, false
}

// MustBackup Represents an enumeration of the backup mechanism
// that is enabled on the disk.
func (p *Disk) MustBackup() DiskBackup {
	if p.backup == nil {
		panic("the backup must not be nil, please use Backup() function instead")
	}
	return *p.backup
}

// SetBackupMode Represents an enumeration of backup modes
func (p *Disk) SetBackupMode(attr DiskBackupMode) {
	p.backupMode = &attr
}

// BackupMode Represents an enumeration of backup modes
func (p *Disk) BackupMode() (DiskBackupMode, bool) {
	if p.backupMode != nil {
		return *p.backupMode, true
	}
	var zero DiskBackupMode
	return zero, false
}

// MustBackupMode Represents an enumeration of backup modes
func (p *Disk) MustBackupMode() DiskBackupMode {
	if p.backupMode == nil {
		panic("the backupMode must not be nil, please use BackupMode() function instead")
	}
	return *p.backupMode
}

func (p *Disk) SetBootable(attr bool) {
	p.bootable = &attr
}

func (p *Disk) Bootable() (bool, bool) {
	if p.bootable != nil {
		return *p.bootable, true
	}
	var zero bool
	return zero, false
}

func (p *Disk) MustBootable() bool {
	if p.bootable == nil {
		panic("the bootable must not be nil, please use Bootable() function instead")
	}
	return *p.bootable
}

func (p *Disk) SetComment(attr string) {
	p.comment = &attr
}

func (p *Disk) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *Disk) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

// SetContentType The actual content residing on the disk.
func (p *Disk) SetContentType(attr DiskContentType) {
	p.contentType = &attr
}

// ContentType The actual content residing on the disk.
func (p *Disk) ContentType() (DiskContentType, bool) {
	if p.contentType != nil {
		return *p.contentType, true
	}
	var zero DiskContentType
	return zero, false
}

// MustContentType The actual content residing on the disk.
func (p *Disk) MustContentType() DiskContentType {
	if p.contentType == nil {
		panic("the contentType must not be nil, please use ContentType() function instead")
	}
	return *p.contentType
}

func (p *Disk) SetDescription(attr string) {
	p.description = &attr
}

func (p *Disk) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *Disk) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *Disk) SetDiskProfile(attr *DiskProfile) {
	p.diskProfile = attr
}

func (p *Disk) DiskProfile() (*DiskProfile, bool) {
	if p.diskProfile != nil {
		return p.diskProfile, true
	}
	return nil, false
}

func (p *Disk) MustDiskProfile() *DiskProfile {
	if p.diskProfile == nil {
		panic("the diskProfile must not be nil, please use DiskProfile() function instead")
	}
	return p.diskProfile
}

func (p *Disk) SetDiskSnapshots(attr *DiskSnapshotSlice) {
	p.diskSnapshots = attr
}

func (p *Disk) DiskSnapshots() (*DiskSnapshotSlice, bool) {
	if p.diskSnapshots != nil {
		return p.diskSnapshots, true
	}
	return nil, false
}

func (p *Disk) MustDiskSnapshots() *DiskSnapshotSlice {
	if p.diskSnapshots == nil {
		panic("the diskSnapshots must not be nil, please use DiskSnapshots() function instead")
	}
	return p.diskSnapshots
}

func (p *Disk) SetExternalDisk(attr string) {
	p.externalDisk = &attr
}

func (p *Disk) ExternalDisk() (string, bool) {
	if p.externalDisk != nil {
		return *p.externalDisk, true
	}
	var zero string
	return zero, false
}

func (p *Disk) MustExternalDisk() string {
	if p.externalDisk == nil {
		panic("the externalDisk must not be nil, please use ExternalDisk() function instead")
	}
	return *p.externalDisk
}

// SetFormat The underlying storage format of disks.
func (p *Disk) SetFormat(attr DiskFormat) {
	p.format = &attr
}

// Format The underlying storage format of disks.
func (p *Disk) Format() (DiskFormat, bool) {
	if p.format != nil {
		return *p.format, true
	}
	var zero DiskFormat
	return zero, false
}

// MustFormat The underlying storage format of disks.
func (p *Disk) MustFormat() DiskFormat {
	if p.format == nil {
		panic("the format must not be nil, please use Format() function instead")
	}
	return *p.format
}

func (p *Disk) SetId(attr string) {
	p.id = &attr
}

func (p *Disk) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *Disk) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *Disk) SetImageId(attr string) {
	p.imageId = &attr
}

func (p *Disk) ImageId() (string, bool) {
	if p.imageId != nil {
		return *p.imageId, true
	}
	var zero string
	return zero, false
}

func (p *Disk) MustImageId() string {
	if p.imageId == nil {
		panic("the imageId must not be nil, please use ImageId() function instead")
	}
	return *p.imageId
}

func (p *Disk) SetInitialSize(attr int64) {
	p.initialSize = &attr
}

func (p *Disk) InitialSize() (int64, bool) {
	if p.initialSize != nil {
		return *p.initialSize, true
	}
	var zero int64
	return zero, false
}

func (p *Disk) MustInitialSize() int64 {
	if p.initialSize == nil {
		panic("the initialSize must not be nil, please use InitialSize() function instead")
	}
	return *p.initialSize
}

// SetInstanceType Describes the hardware configuration of virtual machines.
//
// For example `medium` instance type includes 1 virtual CPU and 4 GiB of memory. It is a top-level
// entity (e.g. not bound to any data center or cluster). The attributes that are used for instance
// types and are common to virtual machine and template types are:
//
// - `console`
// - `cpu`
// - `custom_cpu_model`
// - `custom_emulated_machine`
// - `display`
// - `high_availability`
// - `io`
// - `memory`
// - `memory_policy`
// - `migration`
// - `migration_downtime`
// - `os`
// - `rng_device`
// - `soundcard_enabled`
// - `usb`
// - `virtio_scsi`
//
// When creating a virtual machine from both an instance type and a template, the virtual machine
// will inherit the hardware configurations from the instance type
//
// NOTE: An instance type inherits it's attributes from the template entity although most template
// attributes are not used in instance types.
func (p *Disk) SetInstanceType(attr *InstanceType) {
	p.instanceType = attr
}

// InstanceType Describes the hardware configuration of virtual machines.
//
// For example `medium` instance type includes 1 virtual CPU and 4 GiB of memory. It is a top-level
// entity (e.g. not bound to any data center or cluster). The attributes that are used for instance
// types and are common to virtual machine and template types are:
//
// - `console`
// - `cpu`
// - `custom_cpu_model`
// - `custom_emulated_machine`
// - `display`
// - `high_availability`
// - `io`
// - `memory`
// - `memory_policy`
// - `migration`
// - `migration_downtime`
// - `os`
// - `rng_device`
// - `soundcard_enabled`
// - `usb`
// - `virtio_scsi`
//
// When creating a virtual machine from both an instance type and a template, the virtual machine
// will inherit the hardware configurations from the instance type
//
// NOTE: An instance type inherits it's attributes from the template entity although most template
// attributes are not used in instance types.
func (p *Disk) InstanceType() (*InstanceType, bool) {
	if p.instanceType != nil {
		return p.instanceType, true
	}
	return nil, false
}

// MustInstanceType Describes the hardware configuration of virtual machines.
//
// For example `medium` instance type includes 1 virtual CPU and 4 GiB of memory. It is a top-level
// entity (e.g. not bound to any data center or cluster). The attributes that are used for instance
// types and are common to virtual machine and template types are:
//
// - `console`
// - `cpu`
// - `custom_cpu_model`
// - `custom_emulated_machine`
// - `display`
// - `high_availability`
// - `io`
// - `memory`
// - `memory_policy`
// - `migration`
// - `migration_downtime`
// - `os`
// - `rng_device`
// - `soundcard_enabled`
// - `usb`
// - `virtio_scsi`
//
// When creating a virtual machine from both an instance type and a template, the virtual machine
// will inherit the hardware configurations from the instance type
//
// NOTE: An instance type inherits it's attributes from the template entity although most template
// attributes are not used in instance types.
func (p *Disk) MustInstanceType() *InstanceType {
	if p.instanceType == nil {
		panic("the instanceType must not be nil, please use InstanceType() function instead")
	}
	return p.instanceType
}

// SetInterface The underlying storage interface of disks communication with controller.
func (p *Disk) SetInterface(attr DiskInterface) {
	p.interface_ = &attr
}

// Interface The underlying storage interface of disks communication with controller.
func (p *Disk) Interface() (DiskInterface, bool) {
	if p.interface_ != nil {
		return *p.interface_, true
	}
	var zero DiskInterface
	return zero, false
}

// MustInterface The underlying storage interface of disks communication with controller.
func (p *Disk) MustInterface() DiskInterface {
	if p.interface_ == nil {
		panic("the interface_ must not be nil, please use Interface() function instead")
	}
	return *p.interface_
}

func (p *Disk) SetLogicalName(attr string) {
	p.logicalName = &attr
}

func (p *Disk) LogicalName() (string, bool) {
	if p.logicalName != nil {
		return *p.logicalName, true
	}
	var zero string
	return zero, false
}

func (p *Disk) MustLogicalName() string {
	if p.logicalName == nil {
		panic("the logicalName must not be nil, please use LogicalName() function instead")
	}
	return *p.logicalName
}

func (p *Disk) SetLunStorage(attr *HostStorage) {
	p.lunStorage = attr
}

func (p *Disk) LunStorage() (*HostStorage, bool) {
	if p.lunStorage != nil {
		return p.lunStorage, true
	}
	return nil, false
}

func (p *Disk) MustLunStorage() *HostStorage {
	if p.lunStorage == nil {
		panic("the lunStorage must not be nil, please use LunStorage() function instead")
	}
	return p.lunStorage
}

func (p *Disk) SetName(attr string) {
	p.name = &attr
}

func (p *Disk) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *Disk) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *Disk) SetOpenstackVolumeType(attr *OpenStackVolumeType) {
	p.openstackVolumeType = attr
}

func (p *Disk) OpenstackVolumeType() (*OpenStackVolumeType, bool) {
	if p.openstackVolumeType != nil {
		return p.openstackVolumeType, true
	}
	return nil, false
}

func (p *Disk) MustOpenstackVolumeType() *OpenStackVolumeType {
	if p.openstackVolumeType == nil {
		panic("the openstackVolumeType must not be nil, please use OpenstackVolumeType() function instead")
	}
	return p.openstackVolumeType
}

func (p *Disk) SetPermissions(attr *PermissionSlice) {
	p.permissions = attr
}

func (p *Disk) Permissions() (*PermissionSlice, bool) {
	if p.permissions != nil {
		return p.permissions, true
	}
	return nil, false
}

func (p *Disk) MustPermissions() *PermissionSlice {
	if p.permissions == nil {
		panic("the permissions must not be nil, please use Permissions() function instead")
	}
	return p.permissions
}

func (p *Disk) SetPropagateErrors(attr bool) {
	p.propagateErrors = &attr
}

func (p *Disk) PropagateErrors() (bool, bool) {
	if p.propagateErrors != nil {
		return *p.propagateErrors, true
	}
	var zero bool
	return zero, false
}

func (p *Disk) MustPropagateErrors() bool {
	if p.propagateErrors == nil {
		panic("the propagateErrors must not be nil, please use PropagateErrors() function instead")
	}
	return *p.propagateErrors
}

func (p *Disk) SetProvisionedSize(attr int64) {
	p.provisionedSize = &attr
}

func (p *Disk) ProvisionedSize() (int64, bool) {
	if p.provisionedSize != nil {
		return *p.provisionedSize, true
	}
	var zero int64
	return zero, false
}

func (p *Disk) MustProvisionedSize() int64 {
	if p.provisionedSize == nil {
		panic("the provisionedSize must not be nil, please use ProvisionedSize() function instead")
	}
	return *p.provisionedSize
}

// SetQcowVersion The QCOW version specifies to the qemu which qemu version the volume supports.
//
// This field can be updated using the update API and will be reported only for QCOW volumes,
// it is determined by the storage domain's version which the disk is created on.
// Storage domains with version lower than V4 support QCOW2 version 2 volumes,
// while V4 storage domains also support QCOW2 version 3.
// For more information about features of the different QCOW versions, see http://wiki.qemu.org/Features/Qcow3[here].
func (p *Disk) SetQcowVersion(attr QcowVersion) {
	p.qcowVersion = &attr
}

// QcowVersion The QCOW version specifies to the qemu which qemu version the volume supports.
//
// This field can be updated using the update API and will be reported only for QCOW volumes,
// it is determined by the storage domain's version which the disk is created on.
// Storage domains with version lower than V4 support QCOW2 version 2 volumes,
// while V4 storage domains also support QCOW2 version 3.
// For more information about features of the different QCOW versions, see http://wiki.qemu.org/Features/Qcow3[here].
func (p *Disk) QcowVersion() (QcowVersion, bool) {
	if p.qcowVersion != nil {
		return *p.qcowVersion, true
	}
	var zero QcowVersion
	return zero, false
}

// MustQcowVersion The QCOW version specifies to the qemu which qemu version the volume supports.
//
// This field can be updated using the update API and will be reported only for QCOW volumes,
// it is determined by the storage domain's version which the disk is created on.
// Storage domains with version lower than V4 support QCOW2 version 2 volumes,
// while V4 storage domains also support QCOW2 version 3.
// For more information about features of the different QCOW versions, see http://wiki.qemu.org/Features/Qcow3[here].
func (p *Disk) MustQcowVersion() QcowVersion {
	if p.qcowVersion == nil {
		panic("the qcowVersion must not be nil, please use QcowVersion() function instead")
	}
	return *p.qcowVersion
}

// SetQuota Represents a quota object.
//
// An example XML representation of a quota:
//
// [source,xml]
// ----
// <quota href="/ovirt-engine/api/datacenters/7044934e/quotas/dcad5ddc" id="dcad5ddc">
//   <name>My Quota</name>
//   <description>A quota for my oVirt environment</description>
//   <cluster_hard_limit_pct>0</cluster_hard_limit_pct>
//   <cluster_soft_limit_pct>0</cluster_soft_limit_pct>
//   <data_center href="/ovirt-engine/api/datacenters/7044934e" id="7044934e"/>
//   <storage_hard_limit_pct>0</storage_hard_limit_pct>
//   <storage_soft_limit_pct>0</storage_soft_limit_pct>
// </quota>
// ----
func (p *Disk) SetQuota(attr *Quota) {
	p.quota = attr
}

// Quota Represents a quota object.
//
// An example XML representation of a quota:
//
// [source,xml]
// ----
// <quota href="/ovirt-engine/api/datacenters/7044934e/quotas/dcad5ddc" id="dcad5ddc">
//   <name>My Quota</name>
//   <description>A quota for my oVirt environment</description>
//   <cluster_hard_limit_pct>0</cluster_hard_limit_pct>
//   <cluster_soft_limit_pct>0</cluster_soft_limit_pct>
//   <data_center href="/ovirt-engine/api/datacenters/7044934e" id="7044934e"/>
//   <storage_hard_limit_pct>0</storage_hard_limit_pct>
//   <storage_soft_limit_pct>0</storage_soft_limit_pct>
// </quota>
// ----
func (p *Disk) Quota() (*Quota, bool) {
	if p.quota != nil {
		return p.quota, true
	}
	return nil, false
}

// MustQuota Represents a quota object.
//
// An example XML representation of a quota:
//
// [source,xml]
// ----
// <quota href="/ovirt-engine/api/datacenters/7044934e/quotas/dcad5ddc" id="dcad5ddc">
//   <name>My Quota</name>
//   <description>A quota for my oVirt environment</description>
//   <cluster_hard_limit_pct>0</cluster_hard_limit_pct>
//   <cluster_soft_limit_pct>0</cluster_soft_limit_pct>
//   <data_center href="/ovirt-engine/api/datacenters/7044934e" id="7044934e"/>
//   <storage_hard_limit_pct>0</storage_hard_limit_pct>
//   <storage_soft_limit_pct>0</storage_soft_limit_pct>
// </quota>
// ----
func (p *Disk) MustQuota() *Quota {
	if p.quota == nil {
		panic("the quota must not be nil, please use Quota() function instead")
	}
	return p.quota
}

func (p *Disk) SetReadOnly(attr bool) {
	p.readOnly = &attr
}

func (p *Disk) ReadOnly() (bool, bool) {
	if p.readOnly != nil {
		return *p.readOnly, true
	}
	var zero bool
	return zero, false
}

func (p *Disk) MustReadOnly() bool {
	if p.readOnly == nil {
		panic("the readOnly must not be nil, please use ReadOnly() function instead")
	}
	return *p.readOnly
}

// SetSgio When a direct LUN disk is using SCSI passthrough the privileged I/O policy is determined by this enum.
func (p *Disk) SetSgio(attr ScsiGenericIO) {
	p.sgio = &attr
}

// Sgio When a direct LUN disk is using SCSI passthrough the privileged I/O policy is determined by this enum.
func (p *Disk) Sgio() (ScsiGenericIO, bool) {
	if p.sgio != nil {
		return *p.sgio, true
	}
	var zero ScsiGenericIO
	return zero, false
}

// MustSgio When a direct LUN disk is using SCSI passthrough the privileged I/O policy is determined by this enum.
func (p *Disk) MustSgio() ScsiGenericIO {
	if p.sgio == nil {
		panic("the sgio must not be nil, please use Sgio() function instead")
	}
	return *p.sgio
}

func (p *Disk) SetShareable(attr bool) {
	p.shareable = &attr
}

func (p *Disk) Shareable() (bool, bool) {
	if p.shareable != nil {
		return *p.shareable, true
	}
	var zero bool
	return zero, false
}

func (p *Disk) MustShareable() bool {
	if p.shareable == nil {
		panic("the shareable must not be nil, please use Shareable() function instead")
	}
	return *p.shareable
}

// SetSnapshot Represents a snapshot object.
//
// Example XML representation:
//
// [source,xml]
// ----
// <snapshot id="456" href="/ovirt-engine/api/vms/123/snapshots/456">
//   <actions>
//     <link rel="restore" href="/ovirt-engine/api/vms/123/snapshots/456/restore"/>
//   </actions>
//   <vm id="123" href="/ovirt-engine/api/vms/123"/>
//   <description>Virtual Machine 1 - Snapshot A</description>
//   <type>active</type>
//   <date>2010-08-16T14:24:29</date>
//   <persist_memorystate>false</persist_memorystate>
// </snapshot>
// ----
func (p *Disk) SetSnapshot(attr *Snapshot) {
	p.snapshot = attr
}

// Snapshot Represents a snapshot object.
//
// Example XML representation:
//
// [source,xml]
// ----
// <snapshot id="456" href="/ovirt-engine/api/vms/123/snapshots/456">
//   <actions>
//     <link rel="restore" href="/ovirt-engine/api/vms/123/snapshots/456/restore"/>
//   </actions>
//   <vm id="123" href="/ovirt-engine/api/vms/123"/>
//   <description>Virtual Machine 1 - Snapshot A</description>
//   <type>active</type>
//   <date>2010-08-16T14:24:29</date>
//   <persist_memorystate>false</persist_memorystate>
// </snapshot>
// ----
func (p *Disk) Snapshot() (*Snapshot, bool) {
	if p.snapshot != nil {
		return p.snapshot, true
	}
	return nil, false
}

// MustSnapshot Represents a snapshot object.
//
// Example XML representation:
//
// [source,xml]
// ----
// <snapshot id="456" href="/ovirt-engine/api/vms/123/snapshots/456">
//   <actions>
//     <link rel="restore" href="/ovirt-engine/api/vms/123/snapshots/456/restore"/>
//   </actions>
//   <vm id="123" href="/ovirt-engine/api/vms/123"/>
//   <description>Virtual Machine 1 - Snapshot A</description>
//   <type>active</type>
//   <date>2010-08-16T14:24:29</date>
//   <persist_memorystate>false</persist_memorystate>
// </snapshot>
// ----
func (p *Disk) MustSnapshot() *Snapshot {
	if p.snapshot == nil {
		panic("the snapshot must not be nil, please use Snapshot() function instead")
	}
	return p.snapshot
}

func (p *Disk) SetSparse(attr bool) {
	p.sparse = &attr
}

func (p *Disk) Sparse() (bool, bool) {
	if p.sparse != nil {
		return *p.sparse, true
	}
	var zero bool
	return zero, false
}

func (p *Disk) MustSparse() bool {
	if p.sparse == nil {
		panic("the sparse must not be nil, please use Sparse() function instead")
	}
	return *p.sparse
}

func (p *Disk) SetStatistics(attr *StatisticSlice) {
	p.statistics = attr
}

func (p *Disk) Statistics() (*StatisticSlice, bool) {
	if p.statistics != nil {
		return p.statistics, true
	}
	return nil, false
}

func (p *Disk) MustStatistics() *StatisticSlice {
	if p.statistics == nil {
		panic("the statistics must not be nil, please use Statistics() function instead")
	}
	return p.statistics
}

// SetStatus Current status representation for disk.
func (p *Disk) SetStatus(attr DiskStatus) {
	p.status = &attr
}

// Status Current status representation for disk.
func (p *Disk) Status() (DiskStatus, bool) {
	if p.status != nil {
		return *p.status, true
	}
	var zero DiskStatus
	return zero, false
}

// MustStatus Current status representation for disk.
func (p *Disk) MustStatus() DiskStatus {
	if p.status == nil {
		panic("the status must not be nil, please use Status() function instead")
	}
	return *p.status
}

// SetStorageDomain Storage domain.
//
// An XML representation of a NFS storage domain with identifier `123`:
//
// [source,xml]
// ----
// <storage_domain href="/ovirt-engine/api/storagedomains/123" id="123">
//   <name>mydata</name>
//   <description>My data</description>
//   <available>38654705664</available>
//   <committed>1073741824</committed>
//   <critical_space_action_blocker>5</critical_space_action_blocker>
//   <external_status>ok</external_status>
//   <master>true</master>
//   <storage>
//     <address>mynfs.example.com</address>
//     <nfs_version>v3</nfs_version>
//     <path>/exports/mydata</path>
//     <type>nfs</type>
//   </storage>
//   <storage_format>v3</storage_format>
//   <type>data</type>
//   <used>13958643712</used>
//   <warning_low_space_indicator>10</warning_low_space_indicator>
//   <wipe_after_delete>false</wipe_after_delete>
//   <data_centers>
//     <data_center href="/ovirt-engine/api/datacenters/456" id="456"/>
//   </data_centers>
// </storage_domain>
// ----
func (p *Disk) SetStorageDomain(attr *StorageDomain) {
	p.storageDomain = attr
}

// StorageDomain Storage domain.
//
// An XML representation of a NFS storage domain with identifier `123`:
//
// [source,xml]
// ----
// <storage_domain href="/ovirt-engine/api/storagedomains/123" id="123">
//   <name>mydata</name>
//   <description>My data</description>
//   <available>38654705664</available>
//   <committed>1073741824</committed>
//   <critical_space_action_blocker>5</critical_space_action_blocker>
//   <external_status>ok</external_status>
//   <master>true</master>
//   <storage>
//     <address>mynfs.example.com</address>
//     <nfs_version>v3</nfs_version>
//     <path>/exports/mydata</path>
//     <type>nfs</type>
//   </storage>
//   <storage_format>v3</storage_format>
//   <type>data</type>
//   <used>13958643712</used>
//   <warning_low_space_indicator>10</warning_low_space_indicator>
//   <wipe_after_delete>false</wipe_after_delete>
//   <data_centers>
//     <data_center href="/ovirt-engine/api/datacenters/456" id="456"/>
//   </data_centers>
// </storage_domain>
// ----
func (p *Disk) StorageDomain() (*StorageDomain, bool) {
	if p.storageDomain != nil {
		return p.storageDomain, true
	}
	return nil, false
}

// MustStorageDomain Storage domain.
//
// An XML representation of a NFS storage domain with identifier `123`:
//
// [source,xml]
// ----
// <storage_domain href="/ovirt-engine/api/storagedomains/123" id="123">
//   <name>mydata</name>
//   <description>My data</description>
//   <available>38654705664</available>
//   <committed>1073741824</committed>
//   <critical_space_action_blocker>5</critical_space_action_blocker>
//   <external_status>ok</external_status>
//   <master>true</master>
//   <storage>
//     <address>mynfs.example.com</address>
//     <nfs_version>v3</nfs_version>
//     <path>/exports/mydata</path>
//     <type>nfs</type>
//   </storage>
//   <storage_format>v3</storage_format>
//   <type>data</type>
//   <used>13958643712</used>
//   <warning_low_space_indicator>10</warning_low_space_indicator>
//   <wipe_after_delete>false</wipe_after_delete>
//   <data_centers>
//     <data_center href="/ovirt-engine/api/datacenters/456" id="456"/>
//   </data_centers>
// </storage_domain>
// ----
func (p *Disk) MustStorageDomain() *StorageDomain {
	if p.storageDomain == nil {
		panic("the storageDomain must not be nil, please use StorageDomain() function instead")
	}
	return p.storageDomain
}

func (p *Disk) SetStorageDomains(attr *StorageDomainSlice) {
	p.storageDomains = attr
}

func (p *Disk) StorageDomains() (*StorageDomainSlice, bool) {
	if p.storageDomains != nil {
		return p.storageDomains, true
	}
	return nil, false
}

func (p *Disk) MustStorageDomains() *StorageDomainSlice {
	if p.storageDomains == nil {
		panic("the storageDomains must not be nil, please use StorageDomains() function instead")
	}
	return p.storageDomains
}

func (p *Disk) SetStorageType(attr DiskStorageType) {
	p.storageType = &attr
}

func (p *Disk) StorageType() (DiskStorageType, bool) {
	if p.storageType != nil {
		return *p.storageType, true
	}
	var zero DiskStorageType
	return zero, false
}

func (p *Disk) MustStorageType() DiskStorageType {
	if p.storageType == nil {
		panic("the storageType must not be nil, please use StorageType() function instead")
	}
	return *p.storageType
}

// SetTemplate The type that represents a virtual machine template.
// Templates allow for a rapid instantiation of virtual machines with common configuration and disk states.
func (p *Disk) SetTemplate(attr *Template) {
	p.template = attr
}

// Template The type that represents a virtual machine template.
// Templates allow for a rapid instantiation of virtual machines with common configuration and disk states.
func (p *Disk) Template() (*Template, bool) {
	if p.template != nil {
		return p.template, true
	}
	return nil, false
}

// MustTemplate The type that represents a virtual machine template.
// Templates allow for a rapid instantiation of virtual machines with common configuration and disk states.
func (p *Disk) MustTemplate() *Template {
	if p.template == nil {
		panic("the template must not be nil, please use Template() function instead")
	}
	return p.template
}

func (p *Disk) SetTotalSize(attr int64) {
	p.totalSize = &attr
}

func (p *Disk) TotalSize() (int64, bool) {
	if p.totalSize != nil {
		return *p.totalSize, true
	}
	var zero int64
	return zero, false
}

func (p *Disk) MustTotalSize() int64 {
	if p.totalSize == nil {
		panic("the totalSize must not be nil, please use TotalSize() function instead")
	}
	return *p.totalSize
}

func (p *Disk) SetUsesScsiReservation(attr bool) {
	p.usesScsiReservation = &attr
}

func (p *Disk) UsesScsiReservation() (bool, bool) {
	if p.usesScsiReservation != nil {
		return *p.usesScsiReservation, true
	}
	var zero bool
	return zero, false
}

func (p *Disk) MustUsesScsiReservation() bool {
	if p.usesScsiReservation == nil {
		panic("the usesScsiReservation must not be nil, please use UsesScsiReservation() function instead")
	}
	return *p.usesScsiReservation
}

// SetVm Represents a virtual machine.
func (p *Disk) SetVm(attr *Vm) {
	p.vm = attr
}

// Vm Represents a virtual machine.
func (p *Disk) Vm() (*Vm, bool) {
	if p.vm != nil {
		return p.vm, true
	}
	return nil, false
}

// MustVm Represents a virtual machine.
func (p *Disk) MustVm() *Vm {
	if p.vm == nil {
		panic("the vm must not be nil, please use Vm() function instead")
	}
	return p.vm
}

func (p *Disk) SetVms(attr *VmSlice) {
	p.vms = attr
}

func (p *Disk) Vms() (*VmSlice, bool) {
	if p.vms != nil {
		return p.vms, true
	}
	return nil, false
}

func (p *Disk) MustVms() *VmSlice {
	if p.vms == nil {
		panic("the vms must not be nil, please use Vms() function instead")
	}
	return p.vms
}

func (p *Disk) SetWipeAfterDelete(attr bool) {
	p.wipeAfterDelete = &attr
}

func (p *Disk) WipeAfterDelete() (bool, bool) {
	if p.wipeAfterDelete != nil {
		return *p.wipeAfterDelete, true
	}
	var zero bool
	return zero, false
}

func (p *Disk) MustWipeAfterDelete() bool {
	if p.wipeAfterDelete == nil {
		panic("the wipeAfterDelete must not be nil, please use WipeAfterDelete() function instead")
	}
	return *p.wipeAfterDelete
}

// DiskAttachment Describes how a disk is attached to a virtual machine.
type DiskAttachment struct {
	Struct
	active              *bool
	bootable            *bool
	comment             *string
	description         *string
	disk                *Disk
	id                  *string
	interface_          *DiskInterface
	logicalName         *string
	name                *string
	passDiscard         *bool
	readOnly            *bool
	template            *Template
	usesScsiReservation *bool
	vm                  *Vm
}

func (p *DiskAttachment) SetActive(attr bool) {
	p.active = &attr
}

func (p *DiskAttachment) Active() (bool, bool) {
	if p.active != nil {
		return *p.active, true
	}
	var zero bool
	return zero, false
}

func (p *DiskAttachment) MustActive() bool {
	if p.active == nil {
		panic("the active must not be nil, please use Active() function instead")
	}
	return *p.active
}

func (p *DiskAttachment) SetBootable(attr bool) {
	p.bootable = &attr
}

func (p *DiskAttachment) Bootable() (bool, bool) {
	if p.bootable != nil {
		return *p.bootable, true
	}
	var zero bool
	return zero, false
}

func (p *DiskAttachment) MustBootable() bool {
	if p.bootable == nil {
		panic("the bootable must not be nil, please use Bootable() function instead")
	}
	return *p.bootable
}

func (p *DiskAttachment) SetComment(attr string) {
	p.comment = &attr
}

func (p *DiskAttachment) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *DiskAttachment) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *DiskAttachment) SetDescription(attr string) {
	p.description = &attr
}

func (p *DiskAttachment) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *DiskAttachment) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

// SetDisk Represents a virtual disk device.
func (p *DiskAttachment) SetDisk(attr *Disk) {
	p.disk = attr
}

// Disk Represents a virtual disk device.
func (p *DiskAttachment) Disk() (*Disk, bool) {
	if p.disk != nil {
		return p.disk, true
	}
	return nil, false
}

// MustDisk Represents a virtual disk device.
func (p *DiskAttachment) MustDisk() *Disk {
	if p.disk == nil {
		panic("the disk must not be nil, please use Disk() function instead")
	}
	return p.disk
}

func (p *DiskAttachment) SetId(attr string) {
	p.id = &attr
}

func (p *DiskAttachment) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *DiskAttachment) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

// SetInterface The underlying storage interface of disks communication with controller.
func (p *DiskAttachment) SetInterface(attr DiskInterface) {
	p.interface_ = &attr
}

// Interface The underlying storage interface of disks communication with controller.
func (p *DiskAttachment) Interface() (DiskInterface, bool) {
	if p.interface_ != nil {
		return *p.interface_, true
	}
	var zero DiskInterface
	return zero, false
}

// MustInterface The underlying storage interface of disks communication with controller.
func (p *DiskAttachment) MustInterface() DiskInterface {
	if p.interface_ == nil {
		panic("the interface_ must not be nil, please use Interface() function instead")
	}
	return *p.interface_
}

func (p *DiskAttachment) SetLogicalName(attr string) {
	p.logicalName = &attr
}

func (p *DiskAttachment) LogicalName() (string, bool) {
	if p.logicalName != nil {
		return *p.logicalName, true
	}
	var zero string
	return zero, false
}

func (p *DiskAttachment) MustLogicalName() string {
	if p.logicalName == nil {
		panic("the logicalName must not be nil, please use LogicalName() function instead")
	}
	return *p.logicalName
}

func (p *DiskAttachment) SetName(attr string) {
	p.name = &attr
}

func (p *DiskAttachment) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *DiskAttachment) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *DiskAttachment) SetPassDiscard(attr bool) {
	p.passDiscard = &attr
}

func (p *DiskAttachment) PassDiscard() (bool, bool) {
	if p.passDiscard != nil {
		return *p.passDiscard, true
	}
	var zero bool
	return zero, false
}

func (p *DiskAttachment) MustPassDiscard() bool {
	if p.passDiscard == nil {
		panic("the passDiscard must not be nil, please use PassDiscard() function instead")
	}
	return *p.passDiscard
}

func (p *DiskAttachment) SetReadOnly(attr bool) {
	p.readOnly = &attr
}

func (p *DiskAttachment) ReadOnly() (bool, bool) {
	if p.readOnly != nil {
		return *p.readOnly, true
	}
	var zero bool
	return zero, false
}

func (p *DiskAttachment) MustReadOnly() bool {
	if p.readOnly == nil {
		panic("the readOnly must not be nil, please use ReadOnly() function instead")
	}
	return *p.readOnly
}

// SetTemplate The type that represents a virtual machine template.
// Templates allow for a rapid instantiation of virtual machines with common configuration and disk states.
func (p *DiskAttachment) SetTemplate(attr *Template) {
	p.template = attr
}

// Template The type that represents a virtual machine template.
// Templates allow for a rapid instantiation of virtual machines with common configuration and disk states.
func (p *DiskAttachment) Template() (*Template, bool) {
	if p.template != nil {
		return p.template, true
	}
	return nil, false
}

// MustTemplate The type that represents a virtual machine template.
// Templates allow for a rapid instantiation of virtual machines with common configuration and disk states.
func (p *DiskAttachment) MustTemplate() *Template {
	if p.template == nil {
		panic("the template must not be nil, please use Template() function instead")
	}
	return p.template
}

func (p *DiskAttachment) SetUsesScsiReservation(attr bool) {
	p.usesScsiReservation = &attr
}

func (p *DiskAttachment) UsesScsiReservation() (bool, bool) {
	if p.usesScsiReservation != nil {
		return *p.usesScsiReservation, true
	}
	var zero bool
	return zero, false
}

func (p *DiskAttachment) MustUsesScsiReservation() bool {
	if p.usesScsiReservation == nil {
		panic("the usesScsiReservation must not be nil, please use UsesScsiReservation() function instead")
	}
	return *p.usesScsiReservation
}

// SetVm Represents a virtual machine.
func (p *DiskAttachment) SetVm(attr *Vm) {
	p.vm = attr
}

// Vm Represents a virtual machine.
func (p *DiskAttachment) Vm() (*Vm, bool) {
	if p.vm != nil {
		return p.vm, true
	}
	return nil, false
}

// MustVm Represents a virtual machine.
func (p *DiskAttachment) MustVm() *Vm {
	if p.vm == nil {
		panic("the vm must not be nil, please use Vm() function instead")
	}
	return p.vm
}

type DiskProfile struct {
	Struct
	comment       *string
	description   *string
	id            *string
	name          *string
	permissions   *PermissionSlice
	qos           *Qos
	storageDomain *StorageDomain
}

func (p *DiskProfile) SetComment(attr string) {
	p.comment = &attr
}

func (p *DiskProfile) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *DiskProfile) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *DiskProfile) SetDescription(attr string) {
	p.description = &attr
}

func (p *DiskProfile) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *DiskProfile) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *DiskProfile) SetId(attr string) {
	p.id = &attr
}

func (p *DiskProfile) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *DiskProfile) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *DiskProfile) SetName(attr string) {
	p.name = &attr
}

func (p *DiskProfile) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *DiskProfile) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *DiskProfile) SetPermissions(attr *PermissionSlice) {
	p.permissions = attr
}

func (p *DiskProfile) Permissions() (*PermissionSlice, bool) {
	if p.permissions != nil {
		return p.permissions, true
	}
	return nil, false
}

func (p *DiskProfile) MustPermissions() *PermissionSlice {
	if p.permissions == nil {
		panic("the permissions must not be nil, please use Permissions() function instead")
	}
	return p.permissions
}

// SetQos This type represents the attributes to define Quality of service (QoS).
//
// For storage the `type` is <<types/qos_type, storage>>, the attributes `max_throughput`, `max_read_throughput`,
// `max_write_throughput`, `max_iops`, `max_read_iops` and `max_write_iops` are relevant.
//
// For resources with computing capabilities the `type` is <<types/qos_type, cpu>>, the attribute `cpu_limit` is
// relevant.
//
// For virtual machines networks the `type` is <<types/qos_type, network>>, the attributes `inbound_average`,
// `inbound_peak`, `inbound_burst`, `outbound_average`, `outbound_peak` and `outbound_burst` are relevant.
//
// For host networks the `type` is <<types/qos_type, hostnetwork>>, the attributes `outbound_average_linkshare`,
// `outbound_average_upperlimit` and `outbound_average_realtime` are relevant.
func (p *DiskProfile) SetQos(attr *Qos) {
	p.qos = attr
}

// Qos This type represents the attributes to define Quality of service (QoS).
//
// For storage the `type` is <<types/qos_type, storage>>, the attributes `max_throughput`, `max_read_throughput`,
// `max_write_throughput`, `max_iops`, `max_read_iops` and `max_write_iops` are relevant.
//
// For resources with computing capabilities the `type` is <<types/qos_type, cpu>>, the attribute `cpu_limit` is
// relevant.
//
// For virtual machines networks the `type` is <<types/qos_type, network>>, the attributes `inbound_average`,
// `inbound_peak`, `inbound_burst`, `outbound_average`, `outbound_peak` and `outbound_burst` are relevant.
//
// For host networks the `type` is <<types/qos_type, hostnetwork>>, the attributes `outbound_average_linkshare`,
// `outbound_average_upperlimit` and `outbound_average_realtime` are relevant.
func (p *DiskProfile) Qos() (*Qos, bool) {
	if p.qos != nil {
		return p.qos, true
	}
	return nil, false
}

// MustQos This type represents the attributes to define Quality of service (QoS).
//
// For storage the `type` is <<types/qos_type, storage>>, the attributes `max_throughput`, `max_read_throughput`,
// `max_write_throughput`, `max_iops`, `max_read_iops` and `max_write_iops` are relevant.
//
// For resources with computing capabilities the `type` is <<types/qos_type, cpu>>, the attribute `cpu_limit` is
// relevant.
//
// For virtual machines networks the `type` is <<types/qos_type, network>>, the attributes `inbound_average`,
// `inbound_peak`, `inbound_burst`, `outbound_average`, `outbound_peak` and `outbound_burst` are relevant.
//
// For host networks the `type` is <<types/qos_type, hostnetwork>>, the attributes `outbound_average_linkshare`,
// `outbound_average_upperlimit` and `outbound_average_realtime` are relevant.
func (p *DiskProfile) MustQos() *Qos {
	if p.qos == nil {
		panic("the qos must not be nil, please use Qos() function instead")
	}
	return p.qos
}

// SetStorageDomain Storage domain.
//
// An XML representation of a NFS storage domain with identifier `123`:
//
// [source,xml]
// ----
// <storage_domain href="/ovirt-engine/api/storagedomains/123" id="123">
//   <name>mydata</name>
//   <description>My data</description>
//   <available>38654705664</available>
//   <committed>1073741824</committed>
//   <critical_space_action_blocker>5</critical_space_action_blocker>
//   <external_status>ok</external_status>
//   <master>true</master>
//   <storage>
//     <address>mynfs.example.com</address>
//     <nfs_version>v3</nfs_version>
//     <path>/exports/mydata</path>
//     <type>nfs</type>
//   </storage>
//   <storage_format>v3</storage_format>
//   <type>data</type>
//   <used>13958643712</used>
//   <warning_low_space_indicator>10</warning_low_space_indicator>
//   <wipe_after_delete>false</wipe_after_delete>
//   <data_centers>
//     <data_center href="/ovirt-engine/api/datacenters/456" id="456"/>
//   </data_centers>
// </storage_domain>
// ----
func (p *DiskProfile) SetStorageDomain(attr *StorageDomain) {
	p.storageDomain = attr
}

// StorageDomain Storage domain.
//
// An XML representation of a NFS storage domain with identifier `123`:
//
// [source,xml]
// ----
// <storage_domain href="/ovirt-engine/api/storagedomains/123" id="123">
//   <name>mydata</name>
//   <description>My data</description>
//   <available>38654705664</available>
//   <committed>1073741824</committed>
//   <critical_space_action_blocker>5</critical_space_action_blocker>
//   <external_status>ok</external_status>
//   <master>true</master>
//   <storage>
//     <address>mynfs.example.com</address>
//     <nfs_version>v3</nfs_version>
//     <path>/exports/mydata</path>
//     <type>nfs</type>
//   </storage>
//   <storage_format>v3</storage_format>
//   <type>data</type>
//   <used>13958643712</used>
//   <warning_low_space_indicator>10</warning_low_space_indicator>
//   <wipe_after_delete>false</wipe_after_delete>
//   <data_centers>
//     <data_center href="/ovirt-engine/api/datacenters/456" id="456"/>
//   </data_centers>
// </storage_domain>
// ----
func (p *DiskProfile) StorageDomain() (*StorageDomain, bool) {
	if p.storageDomain != nil {
		return p.storageDomain, true
	}
	return nil, false
}

// MustStorageDomain Storage domain.
//
// An XML representation of a NFS storage domain with identifier `123`:
//
// [source,xml]
// ----
// <storage_domain href="/ovirt-engine/api/storagedomains/123" id="123">
//   <name>mydata</name>
//   <description>My data</description>
//   <available>38654705664</available>
//   <committed>1073741824</committed>
//   <critical_space_action_blocker>5</critical_space_action_blocker>
//   <external_status>ok</external_status>
//   <master>true</master>
//   <storage>
//     <address>mynfs.example.com</address>
//     <nfs_version>v3</nfs_version>
//     <path>/exports/mydata</path>
//     <type>nfs</type>
//   </storage>
//   <storage_format>v3</storage_format>
//   <type>data</type>
//   <used>13958643712</used>
//   <warning_low_space_indicator>10</warning_low_space_indicator>
//   <wipe_after_delete>false</wipe_after_delete>
//   <data_centers>
//     <data_center href="/ovirt-engine/api/datacenters/456" id="456"/>
//   </data_centers>
// </storage_domain>
// ----
func (p *DiskProfile) MustStorageDomain() *StorageDomain {
	if p.storageDomain == nil {
		panic("the storageDomain must not be nil, please use StorageDomain() function instead")
	}
	return p.storageDomain
}

type DiskSnapshot struct {
	Struct
	active              *bool
	actualSize          *int64
	alias               *string
	backup              *DiskBackup
	backupMode          *DiskBackupMode
	bootable            *bool
	comment             *string
	contentType         *DiskContentType
	description         *string
	disk                *Disk
	diskProfile         *DiskProfile
	diskSnapshots       *DiskSnapshotSlice
	externalDisk        *string
	format              *DiskFormat
	id                  *string
	imageId             *string
	initialSize         *int64
	instanceType        *InstanceType
	interface_          *DiskInterface
	logicalName         *string
	lunStorage          *HostStorage
	name                *string
	openstackVolumeType *OpenStackVolumeType
	parent              *DiskSnapshot
	permissions         *PermissionSlice
	propagateErrors     *bool
	provisionedSize     *int64
	qcowVersion         *QcowVersion
	quota               *Quota
	readOnly            *bool
	sgio                *ScsiGenericIO
	shareable           *bool
	snapshot            *Snapshot
	sparse              *bool
	statistics          *StatisticSlice
	status              *DiskStatus
	storageDomain       *StorageDomain
	storageDomains      *StorageDomainSlice
	storageType         *DiskStorageType
	template            *Template
	totalSize           *int64
	usesScsiReservation *bool
	vm                  *Vm
	vms                 *VmSlice
	wipeAfterDelete     *bool
}

func (p *DiskSnapshot) SetActive(attr bool) {
	p.active = &attr
}

func (p *DiskSnapshot) Active() (bool, bool) {
	if p.active != nil {
		return *p.active, true
	}
	var zero bool
	return zero, false
}

func (p *DiskSnapshot) MustActive() bool {
	if p.active == nil {
		panic("the active must not be nil, please use Active() function instead")
	}
	return *p.active
}

func (p *DiskSnapshot) SetActualSize(attr int64) {
	p.actualSize = &attr
}

func (p *DiskSnapshot) ActualSize() (int64, bool) {
	if p.actualSize != nil {
		return *p.actualSize, true
	}
	var zero int64
	return zero, false
}

func (p *DiskSnapshot) MustActualSize() int64 {
	if p.actualSize == nil {
		panic("the actualSize must not be nil, please use ActualSize() function instead")
	}
	return *p.actualSize
}

func (p *DiskSnapshot) SetAlias(attr string) {
	p.alias = &attr
}

func (p *DiskSnapshot) Alias() (string, bool) {
	if p.alias != nil {
		return *p.alias, true
	}
	var zero string
	return zero, false
}

func (p *DiskSnapshot) MustAlias() string {
	if p.alias == nil {
		panic("the alias must not be nil, please use Alias() function instead")
	}
	return *p.alias
}

// SetBackup Represents an enumeration of the backup mechanism
// that is enabled on the disk.
func (p *DiskSnapshot) SetBackup(attr DiskBackup) {
	p.backup = &attr
}

// Backup Represents an enumeration of the backup mechanism
// that is enabled on the disk.
func (p *DiskSnapshot) Backup() (DiskBackup, bool) {
	if p.backup != nil {
		return *p.backup, true
	}
	var zero DiskBackup
	return zero, false
}

// MustBackup Represents an enumeration of the backup mechanism
// that is enabled on the disk.
func (p *DiskSnapshot) MustBackup() DiskBackup {
	if p.backup == nil {
		panic("the backup must not be nil, please use Backup() function instead")
	}
	return *p.backup
}

// SetBackupMode Represents an enumeration of backup modes
func (p *DiskSnapshot) SetBackupMode(attr DiskBackupMode) {
	p.backupMode = &attr
}

// BackupMode Represents an enumeration of backup modes
func (p *DiskSnapshot) BackupMode() (DiskBackupMode, bool) {
	if p.backupMode != nil {
		return *p.backupMode, true
	}
	var zero DiskBackupMode
	return zero, false
}

// MustBackupMode Represents an enumeration of backup modes
func (p *DiskSnapshot) MustBackupMode() DiskBackupMode {
	if p.backupMode == nil {
		panic("the backupMode must not be nil, please use BackupMode() function instead")
	}
	return *p.backupMode
}

func (p *DiskSnapshot) SetBootable(attr bool) {
	p.bootable = &attr
}

func (p *DiskSnapshot) Bootable() (bool, bool) {
	if p.bootable != nil {
		return *p.bootable, true
	}
	var zero bool
	return zero, false
}

func (p *DiskSnapshot) MustBootable() bool {
	if p.bootable == nil {
		panic("the bootable must not be nil, please use Bootable() function instead")
	}
	return *p.bootable
}

func (p *DiskSnapshot) SetComment(attr string) {
	p.comment = &attr
}

func (p *DiskSnapshot) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *DiskSnapshot) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

// SetContentType The actual content residing on the disk.
func (p *DiskSnapshot) SetContentType(attr DiskContentType) {
	p.contentType = &attr
}

// ContentType The actual content residing on the disk.
func (p *DiskSnapshot) ContentType() (DiskContentType, bool) {
	if p.contentType != nil {
		return *p.contentType, true
	}
	var zero DiskContentType
	return zero, false
}

// MustContentType The actual content residing on the disk.
func (p *DiskSnapshot) MustContentType() DiskContentType {
	if p.contentType == nil {
		panic("the contentType must not be nil, please use ContentType() function instead")
	}
	return *p.contentType
}

func (p *DiskSnapshot) SetDescription(attr string) {
	p.description = &attr
}

func (p *DiskSnapshot) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *DiskSnapshot) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

// SetDisk Represents a virtual disk device.
func (p *DiskSnapshot) SetDisk(attr *Disk) {
	p.disk = attr
}

// Disk Represents a virtual disk device.
func (p *DiskSnapshot) Disk() (*Disk, bool) {
	if p.disk != nil {
		return p.disk, true
	}
	return nil, false
}

// MustDisk Represents a virtual disk device.
func (p *DiskSnapshot) MustDisk() *Disk {
	if p.disk == nil {
		panic("the disk must not be nil, please use Disk() function instead")
	}
	return p.disk
}

func (p *DiskSnapshot) SetDiskProfile(attr *DiskProfile) {
	p.diskProfile = attr
}

func (p *DiskSnapshot) DiskProfile() (*DiskProfile, bool) {
	if p.diskProfile != nil {
		return p.diskProfile, true
	}
	return nil, false
}

func (p *DiskSnapshot) MustDiskProfile() *DiskProfile {
	if p.diskProfile == nil {
		panic("the diskProfile must not be nil, please use DiskProfile() function instead")
	}
	return p.diskProfile
}

func (p *DiskSnapshot) SetDiskSnapshots(attr *DiskSnapshotSlice) {
	p.diskSnapshots = attr
}

func (p *DiskSnapshot) DiskSnapshots() (*DiskSnapshotSlice, bool) {
	if p.diskSnapshots != nil {
		return p.diskSnapshots, true
	}
	return nil, false
}

func (p *DiskSnapshot) MustDiskSnapshots() *DiskSnapshotSlice {
	if p.diskSnapshots == nil {
		panic("the diskSnapshots must not be nil, please use DiskSnapshots() function instead")
	}
	return p.diskSnapshots
}

func (p *DiskSnapshot) SetExternalDisk(attr string) {
	p.externalDisk = &attr
}

func (p *DiskSnapshot) ExternalDisk() (string, bool) {
	if p.externalDisk != nil {
		return *p.externalDisk, true
	}
	var zero string
	return zero, false
}

func (p *DiskSnapshot) MustExternalDisk() string {
	if p.externalDisk == nil {
		panic("the externalDisk must not be nil, please use ExternalDisk() function instead")
	}
	return *p.externalDisk
}

// SetFormat The underlying storage format of disks.
func (p *DiskSnapshot) SetFormat(attr DiskFormat) {
	p.format = &attr
}

// Format The underlying storage format of disks.
func (p *DiskSnapshot) Format() (DiskFormat, bool) {
	if p.format != nil {
		return *p.format, true
	}
	var zero DiskFormat
	return zero, false
}

// MustFormat The underlying storage format of disks.
func (p *DiskSnapshot) MustFormat() DiskFormat {
	if p.format == nil {
		panic("the format must not be nil, please use Format() function instead")
	}
	return *p.format
}

func (p *DiskSnapshot) SetId(attr string) {
	p.id = &attr
}

func (p *DiskSnapshot) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *DiskSnapshot) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *DiskSnapshot) SetImageId(attr string) {
	p.imageId = &attr
}

func (p *DiskSnapshot) ImageId() (string, bool) {
	if p.imageId != nil {
		return *p.imageId, true
	}
	var zero string
	return zero, false
}

func (p *DiskSnapshot) MustImageId() string {
	if p.imageId == nil {
		panic("the imageId must not be nil, please use ImageId() function instead")
	}
	return *p.imageId
}

func (p *DiskSnapshot) SetInitialSize(attr int64) {
	p.initialSize = &attr
}

func (p *DiskSnapshot) InitialSize() (int64, bool) {
	if p.initialSize != nil {
		return *p.initialSize, true
	}
	var zero int64
	return zero, false
}

func (p *DiskSnapshot) MustInitialSize() int64 {
	if p.initialSize == nil {
		panic("the initialSize must not be nil, please use InitialSize() function instead")
	}
	return *p.initialSize
}

// SetInstanceType Describes the hardware configuration of virtual machines.
//
// For example `medium` instance type includes 1 virtual CPU and 4 GiB of memory. It is a top-level
// entity (e.g. not bound to any data center or cluster). The attributes that are used for instance
// types and are common to virtual machine and template types are:
//
// - `console`
// - `cpu`
// - `custom_cpu_model`
// - `custom_emulated_machine`
// - `display`
// - `high_availability`
// - `io`
// - `memory`
// - `memory_policy`
// - `migration`
// - `migration_downtime`
// - `os`
// - `rng_device`
// - `soundcard_enabled`
// - `usb`
// - `virtio_scsi`
//
// When creating a virtual machine from both an instance type and a template, the virtual machine
// will inherit the hardware configurations from the instance type
//
// NOTE: An instance type inherits it's attributes from the template entity although most template
// attributes are not used in instance types.
func (p *DiskSnapshot) SetInstanceType(attr *InstanceType) {
	p.instanceType = attr
}

// InstanceType Describes the hardware configuration of virtual machines.
//
// For example `medium` instance type includes 1 virtual CPU and 4 GiB of memory. It is a top-level
// entity (e.g. not bound to any data center or cluster). The attributes that are used for instance
// types and are common to virtual machine and template types are:
//
// - `console`
// - `cpu`
// - `custom_cpu_model`
// - `custom_emulated_machine`
// - `display`
// - `high_availability`
// - `io`
// - `memory`
// - `memory_policy`
// - `migration`
// - `migration_downtime`
// - `os`
// - `rng_device`
// - `soundcard_enabled`
// - `usb`
// - `virtio_scsi`
//
// When creating a virtual machine from both an instance type and a template, the virtual machine
// will inherit the hardware configurations from the instance type
//
// NOTE: An instance type inherits it's attributes from the template entity although most template
// attributes are not used in instance types.
func (p *DiskSnapshot) InstanceType() (*InstanceType, bool) {
	if p.instanceType != nil {
		return p.instanceType, true
	}
	return nil, false
}

// MustInstanceType Describes the hardware configuration of virtual machines.
//
// For example `medium` instance type includes 1 virtual CPU and 4 GiB of memory. It is a top-level
// entity (e.g. not bound to any data center or cluster). The attributes that are used for instance
// types and are common to virtual machine and template types are:
//
// - `console`
// - `cpu`
// - `custom_cpu_model`
// - `custom_emulated_machine`
// - `display`
// - `high_availability`
// - `io`
// - `memory`
// - `memory_policy`
// - `migration`
// - `migration_downtime`
// - `os`
// - `rng_device`
// - `soundcard_enabled`
// - `usb`
// - `virtio_scsi`
//
// When creating a virtual machine from both an instance type and a template, the virtual machine
// will inherit the hardware configurations from the instance type
//
// NOTE: An instance type inherits it's attributes from the template entity although most template
// attributes are not used in instance types.
func (p *DiskSnapshot) MustInstanceType() *InstanceType {
	if p.instanceType == nil {
		panic("the instanceType must not be nil, please use InstanceType() function instead")
	}
	return p.instanceType
}

// SetInterface The underlying storage interface of disks communication with controller.
func (p *DiskSnapshot) SetInterface(attr DiskInterface) {
	p.interface_ = &attr
}

// Interface The underlying storage interface of disks communication with controller.
func (p *DiskSnapshot) Interface() (DiskInterface, bool) {
	if p.interface_ != nil {
		return *p.interface_, true
	}
	var zero DiskInterface
	return zero, false
}

// MustInterface The underlying storage interface of disks communication with controller.
func (p *DiskSnapshot) MustInterface() DiskInterface {
	if p.interface_ == nil {
		panic("the interface_ must not be nil, please use Interface() function instead")
	}
	return *p.interface_
}

func (p *DiskSnapshot) SetLogicalName(attr string) {
	p.logicalName = &attr
}

func (p *DiskSnapshot) LogicalName() (string, bool) {
	if p.logicalName != nil {
		return *p.logicalName, true
	}
	var zero string
	return zero, false
}

func (p *DiskSnapshot) MustLogicalName() string {
	if p.logicalName == nil {
		panic("the logicalName must not be nil, please use LogicalName() function instead")
	}
	return *p.logicalName
}

func (p *DiskSnapshot) SetLunStorage(attr *HostStorage) {
	p.lunStorage = attr
}

func (p *DiskSnapshot) LunStorage() (*HostStorage, bool) {
	if p.lunStorage != nil {
		return p.lunStorage, true
	}
	return nil, false
}

func (p *DiskSnapshot) MustLunStorage() *HostStorage {
	if p.lunStorage == nil {
		panic("the lunStorage must not be nil, please use LunStorage() function instead")
	}
	return p.lunStorage
}

func (p *DiskSnapshot) SetName(attr string) {
	p.name = &attr
}

func (p *DiskSnapshot) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *DiskSnapshot) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *DiskSnapshot) SetOpenstackVolumeType(attr *OpenStackVolumeType) {
	p.openstackVolumeType = attr
}

func (p *DiskSnapshot) OpenstackVolumeType() (*OpenStackVolumeType, bool) {
	if p.openstackVolumeType != nil {
		return p.openstackVolumeType, true
	}
	return nil, false
}

func (p *DiskSnapshot) MustOpenstackVolumeType() *OpenStackVolumeType {
	if p.openstackVolumeType == nil {
		panic("the openstackVolumeType must not be nil, please use OpenstackVolumeType() function instead")
	}
	return p.openstackVolumeType
}

func (p *DiskSnapshot) SetParent(attr *DiskSnapshot) {
	p.parent = attr
}

func (p *DiskSnapshot) Parent() (*DiskSnapshot, bool) {
	if p.parent != nil {
		return p.parent, true
	}
	return nil, false
}

func (p *DiskSnapshot) MustParent() *DiskSnapshot {
	if p.parent == nil {
		panic("the parent must not be nil, please use Parent() function instead")
	}
	return p.parent
}

func (p *DiskSnapshot) SetPermissions(attr *PermissionSlice) {
	p.permissions = attr
}

func (p *DiskSnapshot) Permissions() (*PermissionSlice, bool) {
	if p.permissions != nil {
		return p.permissions, true
	}
	return nil, false
}

func (p *DiskSnapshot) MustPermissions() *PermissionSlice {
	if p.permissions == nil {
		panic("the permissions must not be nil, please use Permissions() function instead")
	}
	return p.permissions
}

func (p *DiskSnapshot) SetPropagateErrors(attr bool) {
	p.propagateErrors = &attr
}

func (p *DiskSnapshot) PropagateErrors() (bool, bool) {
	if p.propagateErrors != nil {
		return *p.propagateErrors, true
	}
	var zero bool
	return zero, false
}

func (p *DiskSnapshot) MustPropagateErrors() bool {
	if p.propagateErrors == nil {
		panic("the propagateErrors must not be nil, please use PropagateErrors() function instead")
	}
	return *p.propagateErrors
}

func (p *DiskSnapshot) SetProvisionedSize(attr int64) {
	p.provisionedSize = &attr
}

func (p *DiskSnapshot) ProvisionedSize() (int64, bool) {
	if p.provisionedSize != nil {
		return *p.provisionedSize, true
	}
	var zero int64
	return zero, false
}

func (p *DiskSnapshot) MustProvisionedSize() int64 {
	if p.provisionedSize == nil {
		panic("the provisionedSize must not be nil, please use ProvisionedSize() function instead")
	}
	return *p.provisionedSize
}

// SetQcowVersion The QCOW version specifies to the qemu which qemu version the volume supports.
//
// This field can be updated using the update API and will be reported only for QCOW volumes,
// it is determined by the storage domain's version which the disk is created on.
// Storage domains with version lower than V4 support QCOW2 version 2 volumes,
// while V4 storage domains also support QCOW2 version 3.
// For more information about features of the different QCOW versions, see http://wiki.qemu.org/Features/Qcow3[here].
func (p *DiskSnapshot) SetQcowVersion(attr QcowVersion) {
	p.qcowVersion = &attr
}

// QcowVersion The QCOW version specifies to the qemu which qemu version the volume supports.
//
// This field can be updated using the update API and will be reported only for QCOW volumes,
// it is determined by the storage domain's version which the disk is created on.
// Storage domains with version lower than V4 support QCOW2 version 2 volumes,
// while V4 storage domains also support QCOW2 version 3.
// For more information about features of the different QCOW versions, see http://wiki.qemu.org/Features/Qcow3[here].
func (p *DiskSnapshot) QcowVersion() (QcowVersion, bool) {
	if p.qcowVersion != nil {
		return *p.qcowVersion, true
	}
	var zero QcowVersion
	return zero, false
}

// MustQcowVersion The QCOW version specifies to the qemu which qemu version the volume supports.
//
// This field can be updated using the update API and will be reported only for QCOW volumes,
// it is determined by the storage domain's version which the disk is created on.
// Storage domains with version lower than V4 support QCOW2 version 2 volumes,
// while V4 storage domains also support QCOW2 version 3.
// For more information about features of the different QCOW versions, see http://wiki.qemu.org/Features/Qcow3[here].
func (p *DiskSnapshot) MustQcowVersion() QcowVersion {
	if p.qcowVersion == nil {
		panic("the qcowVersion must not be nil, please use QcowVersion() function instead")
	}
	return *p.qcowVersion
}

// SetQuota Represents a quota object.
//
// An example XML representation of a quota:
//
// [source,xml]
// ----
// <quota href="/ovirt-engine/api/datacenters/7044934e/quotas/dcad5ddc" id="dcad5ddc">
//   <name>My Quota</name>
//   <description>A quota for my oVirt environment</description>
//   <cluster_hard_limit_pct>0</cluster_hard_limit_pct>
//   <cluster_soft_limit_pct>0</cluster_soft_limit_pct>
//   <data_center href="/ovirt-engine/api/datacenters/7044934e" id="7044934e"/>
//   <storage_hard_limit_pct>0</storage_hard_limit_pct>
//   <storage_soft_limit_pct>0</storage_soft_limit_pct>
// </quota>
// ----
func (p *DiskSnapshot) SetQuota(attr *Quota) {
	p.quota = attr
}

// Quota Represents a quota object.
//
// An example XML representation of a quota:
//
// [source,xml]
// ----
// <quota href="/ovirt-engine/api/datacenters/7044934e/quotas/dcad5ddc" id="dcad5ddc">
//   <name>My Quota</name>
//   <description>A quota for my oVirt environment</description>
//   <cluster_hard_limit_pct>0</cluster_hard_limit_pct>
//   <cluster_soft_limit_pct>0</cluster_soft_limit_pct>
//   <data_center href="/ovirt-engine/api/datacenters/7044934e" id="7044934e"/>
//   <storage_hard_limit_pct>0</storage_hard_limit_pct>
//   <storage_soft_limit_pct>0</storage_soft_limit_pct>
// </quota>
// ----
func (p *DiskSnapshot) Quota() (*Quota, bool) {
	if p.quota != nil {
		return p.quota, true
	}
	return nil, false
}

// MustQuota Represents a quota object.
//
// An example XML representation of a quota:
//
// [source,xml]
// ----
// <quota href="/ovirt-engine/api/datacenters/7044934e/quotas/dcad5ddc" id="dcad5ddc">
//   <name>My Quota</name>
//   <description>A quota for my oVirt environment</description>
//   <cluster_hard_limit_pct>0</cluster_hard_limit_pct>
//   <cluster_soft_limit_pct>0</cluster_soft_limit_pct>
//   <data_center href="/ovirt-engine/api/datacenters/7044934e" id="7044934e"/>
//   <storage_hard_limit_pct>0</storage_hard_limit_pct>
//   <storage_soft_limit_pct>0</storage_soft_limit_pct>
// </quota>
// ----
func (p *DiskSnapshot) MustQuota() *Quota {
	if p.quota == nil {
		panic("the quota must not be nil, please use Quota() function instead")
	}
	return p.quota
}

func (p *DiskSnapshot) SetReadOnly(attr bool) {
	p.readOnly = &attr
}

func (p *DiskSnapshot) ReadOnly() (bool, bool) {
	if p.readOnly != nil {
		return *p.readOnly, true
	}
	var zero bool
	return zero, false
}

func (p *DiskSnapshot) MustReadOnly() bool {
	if p.readOnly == nil {
		panic("the readOnly must not be nil, please use ReadOnly() function instead")
	}
	return *p.readOnly
}

// SetSgio When a direct LUN disk is using SCSI passthrough the privileged I/O policy is determined by this enum.
func (p *DiskSnapshot) SetSgio(attr ScsiGenericIO) {
	p.sgio = &attr
}

// Sgio When a direct LUN disk is using SCSI passthrough the privileged I/O policy is determined by this enum.
func (p *DiskSnapshot) Sgio() (ScsiGenericIO, bool) {
	if p.sgio != nil {
		return *p.sgio, true
	}
	var zero ScsiGenericIO
	return zero, false
}

// MustSgio When a direct LUN disk is using SCSI passthrough the privileged I/O policy is determined by this enum.
func (p *DiskSnapshot) MustSgio() ScsiGenericIO {
	if p.sgio == nil {
		panic("the sgio must not be nil, please use Sgio() function instead")
	}
	return *p.sgio
}

func (p *DiskSnapshot) SetShareable(attr bool) {
	p.shareable = &attr
}

func (p *DiskSnapshot) Shareable() (bool, bool) {
	if p.shareable != nil {
		return *p.shareable, true
	}
	var zero bool
	return zero, false
}

func (p *DiskSnapshot) MustShareable() bool {
	if p.shareable == nil {
		panic("the shareable must not be nil, please use Shareable() function instead")
	}
	return *p.shareable
}

// SetSnapshot Represents a snapshot object.
//
// Example XML representation:
//
// [source,xml]
// ----
// <snapshot id="456" href="/ovirt-engine/api/vms/123/snapshots/456">
//   <actions>
//     <link rel="restore" href="/ovirt-engine/api/vms/123/snapshots/456/restore"/>
//   </actions>
//   <vm id="123" href="/ovirt-engine/api/vms/123"/>
//   <description>Virtual Machine 1 - Snapshot A</description>
//   <type>active</type>
//   <date>2010-08-16T14:24:29</date>
//   <persist_memorystate>false</persist_memorystate>
// </snapshot>
// ----
func (p *DiskSnapshot) SetSnapshot(attr *Snapshot) {
	p.snapshot = attr
}

// Snapshot Represents a snapshot object.
//
// Example XML representation:
//
// [source,xml]
// ----
// <snapshot id="456" href="/ovirt-engine/api/vms/123/snapshots/456">
//   <actions>
//     <link rel="restore" href="/ovirt-engine/api/vms/123/snapshots/456/restore"/>
//   </actions>
//   <vm id="123" href="/ovirt-engine/api/vms/123"/>
//   <description>Virtual Machine 1 - Snapshot A</description>
//   <type>active</type>
//   <date>2010-08-16T14:24:29</date>
//   <persist_memorystate>false</persist_memorystate>
// </snapshot>
// ----
func (p *DiskSnapshot) Snapshot() (*Snapshot, bool) {
	if p.snapshot != nil {
		return p.snapshot, true
	}
	return nil, false
}

// MustSnapshot Represents a snapshot object.
//
// Example XML representation:
//
// [source,xml]
// ----
// <snapshot id="456" href="/ovirt-engine/api/vms/123/snapshots/456">
//   <actions>
//     <link rel="restore" href="/ovirt-engine/api/vms/123/snapshots/456/restore"/>
//   </actions>
//   <vm id="123" href="/ovirt-engine/api/vms/123"/>
//   <description>Virtual Machine 1 - Snapshot A</description>
//   <type>active</type>
//   <date>2010-08-16T14:24:29</date>
//   <persist_memorystate>false</persist_memorystate>
// </snapshot>
// ----
func (p *DiskSnapshot) MustSnapshot() *Snapshot {
	if p.snapshot == nil {
		panic("the snapshot must not be nil, please use Snapshot() function instead")
	}
	return p.snapshot
}

func (p *DiskSnapshot) SetSparse(attr bool) {
	p.sparse = &attr
}

func (p *DiskSnapshot) Sparse() (bool, bool) {
	if p.sparse != nil {
		return *p.sparse, true
	}
	var zero bool
	return zero, false
}

func (p *DiskSnapshot) MustSparse() bool {
	if p.sparse == nil {
		panic("the sparse must not be nil, please use Sparse() function instead")
	}
	return *p.sparse
}

func (p *DiskSnapshot) SetStatistics(attr *StatisticSlice) {
	p.statistics = attr
}

func (p *DiskSnapshot) Statistics() (*StatisticSlice, bool) {
	if p.statistics != nil {
		return p.statistics, true
	}
	return nil, false
}

func (p *DiskSnapshot) MustStatistics() *StatisticSlice {
	if p.statistics == nil {
		panic("the statistics must not be nil, please use Statistics() function instead")
	}
	return p.statistics
}

// SetStatus Current status representation for disk.
func (p *DiskSnapshot) SetStatus(attr DiskStatus) {
	p.status = &attr
}

// Status Current status representation for disk.
func (p *DiskSnapshot) Status() (DiskStatus, bool) {
	if p.status != nil {
		return *p.status, true
	}
	var zero DiskStatus
	return zero, false
}

// MustStatus Current status representation for disk.
func (p *DiskSnapshot) MustStatus() DiskStatus {
	if p.status == nil {
		panic("the status must not be nil, please use Status() function instead")
	}
	return *p.status
}

// SetStorageDomain Storage domain.
//
// An XML representation of a NFS storage domain with identifier `123`:
//
// [source,xml]
// ----
// <storage_domain href="/ovirt-engine/api/storagedomains/123" id="123">
//   <name>mydata</name>
//   <description>My data</description>
//   <available>38654705664</available>
//   <committed>1073741824</committed>
//   <critical_space_action_blocker>5</critical_space_action_blocker>
//   <external_status>ok</external_status>
//   <master>true</master>
//   <storage>
//     <address>mynfs.example.com</address>
//     <nfs_version>v3</nfs_version>
//     <path>/exports/mydata</path>
//     <type>nfs</type>
//   </storage>
//   <storage_format>v3</storage_format>
//   <type>data</type>
//   <used>13958643712</used>
//   <warning_low_space_indicator>10</warning_low_space_indicator>
//   <wipe_after_delete>false</wipe_after_delete>
//   <data_centers>
//     <data_center href="/ovirt-engine/api/datacenters/456" id="456"/>
//   </data_centers>
// </storage_domain>
// ----
func (p *DiskSnapshot) SetStorageDomain(attr *StorageDomain) {
	p.storageDomain = attr
}

// StorageDomain Storage domain.
//
// An XML representation of a NFS storage domain with identifier `123`:
//
// [source,xml]
// ----
// <storage_domain href="/ovirt-engine/api/storagedomains/123" id="123">
//   <name>mydata</name>
//   <description>My data</description>
//   <available>38654705664</available>
//   <committed>1073741824</committed>
//   <critical_space_action_blocker>5</critical_space_action_blocker>
//   <external_status>ok</external_status>
//   <master>true</master>
//   <storage>
//     <address>mynfs.example.com</address>
//     <nfs_version>v3</nfs_version>
//     <path>/exports/mydata</path>
//     <type>nfs</type>
//   </storage>
//   <storage_format>v3</storage_format>
//   <type>data</type>
//   <used>13958643712</used>
//   <warning_low_space_indicator>10</warning_low_space_indicator>
//   <wipe_after_delete>false</wipe_after_delete>
//   <data_centers>
//     <data_center href="/ovirt-engine/api/datacenters/456" id="456"/>
//   </data_centers>
// </storage_domain>
// ----
func (p *DiskSnapshot) StorageDomain() (*StorageDomain, bool) {
	if p.storageDomain != nil {
		return p.storageDomain, true
	}
	return nil, false
}

// MustStorageDomain Storage domain.
//
// An XML representation of a NFS storage domain with identifier `123`:
//
// [source,xml]
// ----
// <storage_domain href="/ovirt-engine/api/storagedomains/123" id="123">
//   <name>mydata</name>
//   <description>My data</description>
//   <available>38654705664</available>
//   <committed>1073741824</committed>
//   <critical_space_action_blocker>5</critical_space_action_blocker>
//   <external_status>ok</external_status>
//   <master>true</master>
//   <storage>
//     <address>mynfs.example.com</address>
//     <nfs_version>v3</nfs_version>
//     <path>/exports/mydata</path>
//     <type>nfs</type>
//   </storage>
//   <storage_format>v3</storage_format>
//   <type>data</type>
//   <used>13958643712</used>
//   <warning_low_space_indicator>10</warning_low_space_indicator>
//   <wipe_after_delete>false</wipe_after_delete>
//   <data_centers>
//     <data_center href="/ovirt-engine/api/datacenters/456" id="456"/>
//   </data_centers>
// </storage_domain>
// ----
func (p *DiskSnapshot) MustStorageDomain() *StorageDomain {
	if p.storageDomain == nil {
		panic("the storageDomain must not be nil, please use StorageDomain() function instead")
	}
	return p.storageDomain
}

func (p *DiskSnapshot) SetStorageDomains(attr *StorageDomainSlice) {
	p.storageDomains = attr
}

func (p *DiskSnapshot) StorageDomains() (*StorageDomainSlice, bool) {
	if p.storageDomains != nil {
		return p.storageDomains, true
	}
	return nil, false
}

func (p *DiskSnapshot) MustStorageDomains() *StorageDomainSlice {
	if p.storageDomains == nil {
		panic("the storageDomains must not be nil, please use StorageDomains() function instead")
	}
	return p.storageDomains
}

func (p *DiskSnapshot) SetStorageType(attr DiskStorageType) {
	p.storageType = &attr
}

func (p *DiskSnapshot) StorageType() (DiskStorageType, bool) {
	if p.storageType != nil {
		return *p.storageType, true
	}
	var zero DiskStorageType
	return zero, false
}

func (p *DiskSnapshot) MustStorageType() DiskStorageType {
	if p.storageType == nil {
		panic("the storageType must not be nil, please use StorageType() function instead")
	}
	return *p.storageType
}

// SetTemplate The type that represents a virtual machine template.
// Templates allow for a rapid instantiation of virtual machines with common configuration and disk states.
func (p *DiskSnapshot) SetTemplate(attr *Template) {
	p.template = attr
}

// Template The type that represents a virtual machine template.
// Templates allow for a rapid instantiation of virtual machines with common configuration and disk states.
func (p *DiskSnapshot) Template() (*Template, bool) {
	if p.template != nil {
		return p.template, true
	}
	return nil, false
}

// MustTemplate The type that represents a virtual machine template.
// Templates allow for a rapid instantiation of virtual machines with common configuration and disk states.
func (p *DiskSnapshot) MustTemplate() *Template {
	if p.template == nil {
		panic("the template must not be nil, please use Template() function instead")
	}
	return p.template
}

func (p *DiskSnapshot) SetTotalSize(attr int64) {
	p.totalSize = &attr
}

func (p *DiskSnapshot) TotalSize() (int64, bool) {
	if p.totalSize != nil {
		return *p.totalSize, true
	}
	var zero int64
	return zero, false
}

func (p *DiskSnapshot) MustTotalSize() int64 {
	if p.totalSize == nil {
		panic("the totalSize must not be nil, please use TotalSize() function instead")
	}
	return *p.totalSize
}

func (p *DiskSnapshot) SetUsesScsiReservation(attr bool) {
	p.usesScsiReservation = &attr
}

func (p *DiskSnapshot) UsesScsiReservation() (bool, bool) {
	if p.usesScsiReservation != nil {
		return *p.usesScsiReservation, true
	}
	var zero bool
	return zero, false
}

func (p *DiskSnapshot) MustUsesScsiReservation() bool {
	if p.usesScsiReservation == nil {
		panic("the usesScsiReservation must not be nil, please use UsesScsiReservation() function instead")
	}
	return *p.usesScsiReservation
}

// SetVm Represents a virtual machine.
func (p *DiskSnapshot) SetVm(attr *Vm) {
	p.vm = attr
}

// Vm Represents a virtual machine.
func (p *DiskSnapshot) Vm() (*Vm, bool) {
	if p.vm != nil {
		return p.vm, true
	}
	return nil, false
}

// MustVm Represents a virtual machine.
func (p *DiskSnapshot) MustVm() *Vm {
	if p.vm == nil {
		panic("the vm must not be nil, please use Vm() function instead")
	}
	return p.vm
}

func (p *DiskSnapshot) SetVms(attr *VmSlice) {
	p.vms = attr
}

func (p *DiskSnapshot) Vms() (*VmSlice, bool) {
	if p.vms != nil {
		return p.vms, true
	}
	return nil, false
}

func (p *DiskSnapshot) MustVms() *VmSlice {
	if p.vms == nil {
		panic("the vms must not be nil, please use Vms() function instead")
	}
	return p.vms
}

func (p *DiskSnapshot) SetWipeAfterDelete(attr bool) {
	p.wipeAfterDelete = &attr
}

func (p *DiskSnapshot) WipeAfterDelete() (bool, bool) {
	if p.wipeAfterDelete != nil {
		return *p.wipeAfterDelete, true
	}
	var zero bool
	return zero, false
}

func (p *DiskSnapshot) MustWipeAfterDelete() bool {
	if p.wipeAfterDelete == nil {
		panic("the wipeAfterDelete must not be nil, please use WipeAfterDelete() function instead")
	}
	return *p.wipeAfterDelete
}

// Display Represents a graphic console configuration.
type Display struct {
	Struct
	address             *string
	allowOverride       *bool
	certificate         *Certificate
	copyPasteEnabled    *bool
	disconnectAction    *string
	fileTransferEnabled *bool
	keyboardLayout      *string
	monitors            *int64
	port                *int64
	proxy               *string
	securePort          *int64
	singleQxlPci        *bool
	smartcardEnabled    *bool
	type_               *DisplayType
}

func (p *Display) SetAddress(attr string) {
	p.address = &attr
}

func (p *Display) Address() (string, bool) {
	if p.address != nil {
		return *p.address, true
	}
	var zero string
	return zero, false
}

func (p *Display) MustAddress() string {
	if p.address == nil {
		panic("the address must not be nil, please use Address() function instead")
	}
	return *p.address
}

func (p *Display) SetAllowOverride(attr bool) {
	p.allowOverride = &attr
}

func (p *Display) AllowOverride() (bool, bool) {
	if p.allowOverride != nil {
		return *p.allowOverride, true
	}
	var zero bool
	return zero, false
}

func (p *Display) MustAllowOverride() bool {
	if p.allowOverride == nil {
		panic("the allowOverride must not be nil, please use AllowOverride() function instead")
	}
	return *p.allowOverride
}

func (p *Display) SetCertificate(attr *Certificate) {
	p.certificate = attr
}

func (p *Display) Certificate() (*Certificate, bool) {
	if p.certificate != nil {
		return p.certificate, true
	}
	return nil, false
}

func (p *Display) MustCertificate() *Certificate {
	if p.certificate == nil {
		panic("the certificate must not be nil, please use Certificate() function instead")
	}
	return p.certificate
}

func (p *Display) SetCopyPasteEnabled(attr bool) {
	p.copyPasteEnabled = &attr
}

func (p *Display) CopyPasteEnabled() (bool, bool) {
	if p.copyPasteEnabled != nil {
		return *p.copyPasteEnabled, true
	}
	var zero bool
	return zero, false
}

func (p *Display) MustCopyPasteEnabled() bool {
	if p.copyPasteEnabled == nil {
		panic("the copyPasteEnabled must not be nil, please use CopyPasteEnabled() function instead")
	}
	return *p.copyPasteEnabled
}

func (p *Display) SetDisconnectAction(attr string) {
	p.disconnectAction = &attr
}

func (p *Display) DisconnectAction() (string, bool) {
	if p.disconnectAction != nil {
		return *p.disconnectAction, true
	}
	var zero string
	return zero, false
}

func (p *Display) MustDisconnectAction() string {
	if p.disconnectAction == nil {
		panic("the disconnectAction must not be nil, please use DisconnectAction() function instead")
	}
	return *p.disconnectAction
}

func (p *Display) SetFileTransferEnabled(attr bool) {
	p.fileTransferEnabled = &attr
}

func (p *Display) FileTransferEnabled() (bool, bool) {
	if p.fileTransferEnabled != nil {
		return *p.fileTransferEnabled, true
	}
	var zero bool
	return zero, false
}

func (p *Display) MustFileTransferEnabled() bool {
	if p.fileTransferEnabled == nil {
		panic("the fileTransferEnabled must not be nil, please use FileTransferEnabled() function instead")
	}
	return *p.fileTransferEnabled
}

func (p *Display) SetKeyboardLayout(attr string) {
	p.keyboardLayout = &attr
}

func (p *Display) KeyboardLayout() (string, bool) {
	if p.keyboardLayout != nil {
		return *p.keyboardLayout, true
	}
	var zero string
	return zero, false
}

func (p *Display) MustKeyboardLayout() string {
	if p.keyboardLayout == nil {
		panic("the keyboardLayout must not be nil, please use KeyboardLayout() function instead")
	}
	return *p.keyboardLayout
}

func (p *Display) SetMonitors(attr int64) {
	p.monitors = &attr
}

func (p *Display) Monitors() (int64, bool) {
	if p.monitors != nil {
		return *p.monitors, true
	}
	var zero int64
	return zero, false
}

func (p *Display) MustMonitors() int64 {
	if p.monitors == nil {
		panic("the monitors must not be nil, please use Monitors() function instead")
	}
	return *p.monitors
}

func (p *Display) SetPort(attr int64) {
	p.port = &attr
}

func (p *Display) Port() (int64, bool) {
	if p.port != nil {
		return *p.port, true
	}
	var zero int64
	return zero, false
}

func (p *Display) MustPort() int64 {
	if p.port == nil {
		panic("the port must not be nil, please use Port() function instead")
	}
	return *p.port
}

func (p *Display) SetProxy(attr string) {
	p.proxy = &attr
}

func (p *Display) Proxy() (string, bool) {
	if p.proxy != nil {
		return *p.proxy, true
	}
	var zero string
	return zero, false
}

func (p *Display) MustProxy() string {
	if p.proxy == nil {
		panic("the proxy must not be nil, please use Proxy() function instead")
	}
	return *p.proxy
}

func (p *Display) SetSecurePort(attr int64) {
	p.securePort = &attr
}

func (p *Display) SecurePort() (int64, bool) {
	if p.securePort != nil {
		return *p.securePort, true
	}
	var zero int64
	return zero, false
}

func (p *Display) MustSecurePort() int64 {
	if p.securePort == nil {
		panic("the securePort must not be nil, please use SecurePort() function instead")
	}
	return *p.securePort
}

func (p *Display) SetSingleQxlPci(attr bool) {
	p.singleQxlPci = &attr
}

func (p *Display) SingleQxlPci() (bool, bool) {
	if p.singleQxlPci != nil {
		return *p.singleQxlPci, true
	}
	var zero bool
	return zero, false
}

func (p *Display) MustSingleQxlPci() bool {
	if p.singleQxlPci == nil {
		panic("the singleQxlPci must not be nil, please use SingleQxlPci() function instead")
	}
	return *p.singleQxlPci
}

func (p *Display) SetSmartcardEnabled(attr bool) {
	p.smartcardEnabled = &attr
}

func (p *Display) SmartcardEnabled() (bool, bool) {
	if p.smartcardEnabled != nil {
		return *p.smartcardEnabled, true
	}
	var zero bool
	return zero, false
}

func (p *Display) MustSmartcardEnabled() bool {
	if p.smartcardEnabled == nil {
		panic("the smartcardEnabled must not be nil, please use SmartcardEnabled() function instead")
	}
	return *p.smartcardEnabled
}

// SetType Represents an enumeration of the protocol used
// to connect to the graphic console of the virtual
// machine.
func (p *Display) SetType(attr DisplayType) {
	p.type_ = &attr
}

// Type Represents an enumeration of the protocol used
// to connect to the graphic console of the virtual
// machine.
func (p *Display) Type() (DisplayType, bool) {
	if p.type_ != nil {
		return *p.type_, true
	}
	var zero DisplayType
	return zero, false
}

// MustType Represents an enumeration of the protocol used
// to connect to the graphic console of the virtual
// machine.
func (p *Display) MustType() DisplayType {
	if p.type_ == nil {
		panic("the type_ must not be nil, please use Type() function instead")
	}
	return *p.type_
}

// Dns Represents the DNS resolver configuration.
type Dns struct {
	Struct
	searchDomains *HostSlice
	servers       *HostSlice
}

func (p *Dns) SetSearchDomains(attr *HostSlice) {
	p.searchDomains = attr
}

func (p *Dns) SearchDomains() (*HostSlice, bool) {
	if p.searchDomains != nil {
		return p.searchDomains, true
	}
	return nil, false
}

func (p *Dns) MustSearchDomains() *HostSlice {
	if p.searchDomains == nil {
		panic("the searchDomains must not be nil, please use SearchDomains() function instead")
	}
	return p.searchDomains
}

func (p *Dns) SetServers(attr *HostSlice) {
	p.servers = attr
}

func (p *Dns) Servers() (*HostSlice, bool) {
	if p.servers != nil {
		return p.servers, true
	}
	return nil, false
}

func (p *Dns) MustServers() *HostSlice {
	if p.servers == nil {
		panic("the servers must not be nil, please use Servers() function instead")
	}
	return p.servers
}

// DnsResolverConfiguration Represents the DNS resolver configuration.
type DnsResolverConfiguration struct {
	Struct
	nameServers []string
}

func (p *DnsResolverConfiguration) SetNameServers(attr []string) {
	p.nameServers = attr
}

func (p *DnsResolverConfiguration) NameServers() ([]string, bool) {
	if p.nameServers != nil {
		return p.nameServers, true
	}
	return nil, false
}

func (p *DnsResolverConfiguration) MustNameServers() []string {
	if p.nameServers == nil {
		panic("the nameServers must not be nil, please use NameServers() function instead")
	}
	return p.nameServers
}

// Domain This type represents a directory service domain.
type Domain struct {
	Struct
	comment     *string
	description *string
	groups      *GroupSlice
	id          *string
	name        *string
	user        *User
	users       *UserSlice
}

func (p *Domain) SetComment(attr string) {
	p.comment = &attr
}

func (p *Domain) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *Domain) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *Domain) SetDescription(attr string) {
	p.description = &attr
}

func (p *Domain) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *Domain) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *Domain) SetGroups(attr *GroupSlice) {
	p.groups = attr
}

func (p *Domain) Groups() (*GroupSlice, bool) {
	if p.groups != nil {
		return p.groups, true
	}
	return nil, false
}

func (p *Domain) MustGroups() *GroupSlice {
	if p.groups == nil {
		panic("the groups must not be nil, please use Groups() function instead")
	}
	return p.groups
}

func (p *Domain) SetId(attr string) {
	p.id = &attr
}

func (p *Domain) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *Domain) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *Domain) SetName(attr string) {
	p.name = &attr
}

func (p *Domain) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *Domain) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

// SetUser Represents a user in the system.
func (p *Domain) SetUser(attr *User) {
	p.user = attr
}

// User Represents a user in the system.
func (p *Domain) User() (*User, bool) {
	if p.user != nil {
		return p.user, true
	}
	return nil, false
}

// MustUser Represents a user in the system.
func (p *Domain) MustUser() *User {
	if p.user == nil {
		panic("the user must not be nil, please use User() function instead")
	}
	return p.user
}

func (p *Domain) SetUsers(attr *UserSlice) {
	p.users = attr
}

func (p *Domain) Users() (*UserSlice, bool) {
	if p.users != nil {
		return p.users, true
	}
	return nil, false
}

func (p *Domain) MustUsers() *UserSlice {
	if p.users == nil {
		panic("the users must not be nil, please use Users() function instead")
	}
	return p.users
}

type EntityProfileDetail struct {
	Struct
	profileDetails *ProfileDetailSlice
}

func (p *EntityProfileDetail) SetProfileDetails(attr *ProfileDetailSlice) {
	p.profileDetails = attr
}

func (p *EntityProfileDetail) ProfileDetails() (*ProfileDetailSlice, bool) {
	if p.profileDetails != nil {
		return p.profileDetails, true
	}
	return nil, false
}

func (p *EntityProfileDetail) MustProfileDetails() *ProfileDetailSlice {
	if p.profileDetails == nil {
		panic("the profileDetails must not be nil, please use ProfileDetails() function instead")
	}
	return p.profileDetails
}

type ErrorHandling struct {
	Struct
	onError *MigrateOnError
}

func (p *ErrorHandling) SetOnError(attr MigrateOnError) {
	p.onError = &attr
}

func (p *ErrorHandling) OnError() (MigrateOnError, bool) {
	if p.onError != nil {
		return *p.onError, true
	}
	var zero MigrateOnError
	return zero, false
}

func (p *ErrorHandling) MustOnError() MigrateOnError {
	if p.onError == nil {
		panic("the onError must not be nil, please use OnError() function instead")
	}
	return *p.onError
}

// Event Type representing an event.
type Event struct {
	Struct
	cluster       *Cluster
	code          *int64
	comment       *string
	correlationId *string
	customData    *string
	customId      *int64
	dataCenter    *DataCenter
	description   *string
	floodRate     *int64
	host          *Host
	id            *string
	index         *int64
	logOnHost     *bool
	name          *string
	origin        *string
	severity      *LogSeverity
	storageDomain *StorageDomain
	template      *Template
	time          *time.Time
	user          *User
	vm            *Vm
}

// SetCluster Type representation of a cluster.
//
// A JSON representation of a cluster:
//
// [source]
// ----
// {
//   "cluster" : [ {
//     "ballooning_enabled" : "false",
//     "cpu" : {
//       "architecture" : "x86_64",
//       "type" : "Intel SandyBridge Family"
//     },
//     "custom_scheduling_policy_properties" : {
//       "property" : [ {
//         "name" : "HighUtilization",
//         "value" : "80"
//       }, {
//         "name" : "CpuOverCommitDurationMinutes",
//         "value" : "2"
//       } ]
//     },
//     "error_handling" : {
//       "on_error" : "migrate"
//     },
//     "fencing_policy" : {
//       "enabled" : "true",
//       "skip_if_connectivity_broken" : {
//         "enabled" : "false",
//         "threshold" : "50"
//       },
//       "skip_if_gluster_bricks_up" : "false",
//       "skip_if_gluster_quorum_not_met" : "false",
//       "skip_if_sd_active" : {
//         "enabled" : "false"
//       }
//     },
//     "gluster_service" : "false",
//     "firewall_type" : "iptables",
//     "ha_reservation" : "false",
//     "ksm" : {
//       "enabled" : "true",
//       "merge_across_nodes" : "true"
//     },
//     "memory_policy" : {
//       "over_commit" : {
//         "percent" : "100"
//       },
//       "transparent_hugepages" : {
//         "enabled" : "true"
//       }
//     },
//     "migration" : {
//       "auto_converge" : "inherit",
//       "bandwidth" : {
//         "assignment_method" : "auto"
//       },
//       "compressed" : "inherit",
//       "policy" : {
//         "id" : "00000000-0000-0000-0000-000000000000"
//       }
//     },
//     "required_rng_sources" : {
//       "required_rng_source" : [ "random" ]
//     },
//     "switch_type" : "legacy",
//     "threads_as_cores" : "false",
//     "trusted_service" : "false",
//     "tunnel_migration" : "false",
//     "version" : {
//       "major" : "4",
//       "minor" : "1"
//     },
//     "virt_service" : "true",
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "mac_pool" : {
//       "href" : "/ovirt-engine/api/macpools/456",
//       "id" : "456"
//     },
//     "scheduling_policy" : {
//       "href" : "/ovirt-engine/api/schedulingpolicies/789",
//       "id" : "789"
//     },
//     "actions" : {
//       "link" : [ {
//         "href" : "/ovirt-engine/api/clusters/234/resetemulatedmachine",
//         "rel" : "resetemulatedmachine"
//       } ]
//     },
//     "name" : "Default",
//     "description" : "The default server cluster",
//     "href" : "/ovirt-engine/api/clusters/234",
//     "id" : "234",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/clusters/234/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/cpuprofiles",
//       "rel" : "cpuprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networkfilters",
//       "rel" : "networkfilters"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networks",
//       "rel" : "networks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/affinitygroups",
//       "rel" : "affinitygroups"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glusterhooks",
//       "rel" : "glusterhooks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glustervolumes",
//       "rel" : "glustervolumes"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/enabledfeatures",
//       "rel" : "enabledfeatures"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/externalnetworkproviders",
//       "rel" : "externalnetworkproviders"
//     } ]
//   } ]
// }
// ----
func (p *Event) SetCluster(attr *Cluster) {
	p.cluster = attr
}

// Cluster Type representation of a cluster.
//
// A JSON representation of a cluster:
//
// [source]
// ----
// {
//   "cluster" : [ {
//     "ballooning_enabled" : "false",
//     "cpu" : {
//       "architecture" : "x86_64",
//       "type" : "Intel SandyBridge Family"
//     },
//     "custom_scheduling_policy_properties" : {
//       "property" : [ {
//         "name" : "HighUtilization",
//         "value" : "80"
//       }, {
//         "name" : "CpuOverCommitDurationMinutes",
//         "value" : "2"
//       } ]
//     },
//     "error_handling" : {
//       "on_error" : "migrate"
//     },
//     "fencing_policy" : {
//       "enabled" : "true",
//       "skip_if_connectivity_broken" : {
//         "enabled" : "false",
//         "threshold" : "50"
//       },
//       "skip_if_gluster_bricks_up" : "false",
//       "skip_if_gluster_quorum_not_met" : "false",
//       "skip_if_sd_active" : {
//         "enabled" : "false"
//       }
//     },
//     "gluster_service" : "false",
//     "firewall_type" : "iptables",
//     "ha_reservation" : "false",
//     "ksm" : {
//       "enabled" : "true",
//       "merge_across_nodes" : "true"
//     },
//     "memory_policy" : {
//       "over_commit" : {
//         "percent" : "100"
//       },
//       "transparent_hugepages" : {
//         "enabled" : "true"
//       }
//     },
//     "migration" : {
//       "auto_converge" : "inherit",
//       "bandwidth" : {
//         "assignment_method" : "auto"
//       },
//       "compressed" : "inherit",
//       "policy" : {
//         "id" : "00000000-0000-0000-0000-000000000000"
//       }
//     },
//     "required_rng_sources" : {
//       "required_rng_source" : [ "random" ]
//     },
//     "switch_type" : "legacy",
//     "threads_as_cores" : "false",
//     "trusted_service" : "false",
//     "tunnel_migration" : "false",
//     "version" : {
//       "major" : "4",
//       "minor" : "1"
//     },
//     "virt_service" : "true",
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "mac_pool" : {
//       "href" : "/ovirt-engine/api/macpools/456",
//       "id" : "456"
//     },
//     "scheduling_policy" : {
//       "href" : "/ovirt-engine/api/schedulingpolicies/789",
//       "id" : "789"
//     },
//     "actions" : {
//       "link" : [ {
//         "href" : "/ovirt-engine/api/clusters/234/resetemulatedmachine",
//         "rel" : "resetemulatedmachine"
//       } ]
//     },
//     "name" : "Default",
//     "description" : "The default server cluster",
//     "href" : "/ovirt-engine/api/clusters/234",
//     "id" : "234",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/clusters/234/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/cpuprofiles",
//       "rel" : "cpuprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networkfilters",
//       "rel" : "networkfilters"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networks",
//       "rel" : "networks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/affinitygroups",
//       "rel" : "affinitygroups"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glusterhooks",
//       "rel" : "glusterhooks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glustervolumes",
//       "rel" : "glustervolumes"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/enabledfeatures",
//       "rel" : "enabledfeatures"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/externalnetworkproviders",
//       "rel" : "externalnetworkproviders"
//     } ]
//   } ]
// }
// ----
func (p *Event) Cluster() (*Cluster, bool) {
	if p.cluster != nil {
		return p.cluster, true
	}
	return nil, false
}

// MustCluster Type representation of a cluster.
//
// A JSON representation of a cluster:
//
// [source]
// ----
// {
//   "cluster" : [ {
//     "ballooning_enabled" : "false",
//     "cpu" : {
//       "architecture" : "x86_64",
//       "type" : "Intel SandyBridge Family"
//     },
//     "custom_scheduling_policy_properties" : {
//       "property" : [ {
//         "name" : "HighUtilization",
//         "value" : "80"
//       }, {
//         "name" : "CpuOverCommitDurationMinutes",
//         "value" : "2"
//       } ]
//     },
//     "error_handling" : {
//       "on_error" : "migrate"
//     },
//     "fencing_policy" : {
//       "enabled" : "true",
//       "skip_if_connectivity_broken" : {
//         "enabled" : "false",
//         "threshold" : "50"
//       },
//       "skip_if_gluster_bricks_up" : "false",
//       "skip_if_gluster_quorum_not_met" : "false",
//       "skip_if_sd_active" : {
//         "enabled" : "false"
//       }
//     },
//     "gluster_service" : "false",
//     "firewall_type" : "iptables",
//     "ha_reservation" : "false",
//     "ksm" : {
//       "enabled" : "true",
//       "merge_across_nodes" : "true"
//     },
//     "memory_policy" : {
//       "over_commit" : {
//         "percent" : "100"
//       },
//       "transparent_hugepages" : {
//         "enabled" : "true"
//       }
//     },
//     "migration" : {
//       "auto_converge" : "inherit",
//       "bandwidth" : {
//         "assignment_method" : "auto"
//       },
//       "compressed" : "inherit",
//       "policy" : {
//         "id" : "00000000-0000-0000-0000-000000000000"
//       }
//     },
//     "required_rng_sources" : {
//       "required_rng_source" : [ "random" ]
//     },
//     "switch_type" : "legacy",
//     "threads_as_cores" : "false",
//     "trusted_service" : "false",
//     "tunnel_migration" : "false",
//     "version" : {
//       "major" : "4",
//       "minor" : "1"
//     },
//     "virt_service" : "true",
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "mac_pool" : {
//       "href" : "/ovirt-engine/api/macpools/456",
//       "id" : "456"
//     },
//     "scheduling_policy" : {
//       "href" : "/ovirt-engine/api/schedulingpolicies/789",
//       "id" : "789"
//     },
//     "actions" : {
//       "link" : [ {
//         "href" : "/ovirt-engine/api/clusters/234/resetemulatedmachine",
//         "rel" : "resetemulatedmachine"
//       } ]
//     },
//     "name" : "Default",
//     "description" : "The default server cluster",
//     "href" : "/ovirt-engine/api/clusters/234",
//     "id" : "234",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/clusters/234/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/cpuprofiles",
//       "rel" : "cpuprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networkfilters",
//       "rel" : "networkfilters"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networks",
//       "rel" : "networks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/affinitygroups",
//       "rel" : "affinitygroups"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glusterhooks",
//       "rel" : "glusterhooks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glustervolumes",
//       "rel" : "glustervolumes"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/enabledfeatures",
//       "rel" : "enabledfeatures"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/externalnetworkproviders",
//       "rel" : "externalnetworkproviders"
//     } ]
//   } ]
// }
// ----
func (p *Event) MustCluster() *Cluster {
	if p.cluster == nil {
		panic("the cluster must not be nil, please use Cluster() function instead")
	}
	return p.cluster
}

func (p *Event) SetCode(attr int64) {
	p.code = &attr
}

func (p *Event) Code() (int64, bool) {
	if p.code != nil {
		return *p.code, true
	}
	var zero int64
	return zero, false
}

func (p *Event) MustCode() int64 {
	if p.code == nil {
		panic("the code must not be nil, please use Code() function instead")
	}
	return *p.code
}

func (p *Event) SetComment(attr string) {
	p.comment = &attr
}

func (p *Event) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *Event) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *Event) SetCorrelationId(attr string) {
	p.correlationId = &attr
}

func (p *Event) CorrelationId() (string, bool) {
	if p.correlationId != nil {
		return *p.correlationId, true
	}
	var zero string
	return zero, false
}

func (p *Event) MustCorrelationId() string {
	if p.correlationId == nil {
		panic("the correlationId must not be nil, please use CorrelationId() function instead")
	}
	return *p.correlationId
}

func (p *Event) SetCustomData(attr string) {
	p.customData = &attr
}

func (p *Event) CustomData() (string, bool) {
	if p.customData != nil {
		return *p.customData, true
	}
	var zero string
	return zero, false
}

func (p *Event) MustCustomData() string {
	if p.customData == nil {
		panic("the customData must not be nil, please use CustomData() function instead")
	}
	return *p.customData
}

func (p *Event) SetCustomId(attr int64) {
	p.customId = &attr
}

func (p *Event) CustomId() (int64, bool) {
	if p.customId != nil {
		return *p.customId, true
	}
	var zero int64
	return zero, false
}

func (p *Event) MustCustomId() int64 {
	if p.customId == nil {
		panic("the customId must not be nil, please use CustomId() function instead")
	}
	return *p.customId
}

func (p *Event) SetDataCenter(attr *DataCenter) {
	p.dataCenter = attr
}

func (p *Event) DataCenter() (*DataCenter, bool) {
	if p.dataCenter != nil {
		return p.dataCenter, true
	}
	return nil, false
}

func (p *Event) MustDataCenter() *DataCenter {
	if p.dataCenter == nil {
		panic("the dataCenter must not be nil, please use DataCenter() function instead")
	}
	return p.dataCenter
}

func (p *Event) SetDescription(attr string) {
	p.description = &attr
}

func (p *Event) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *Event) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *Event) SetFloodRate(attr int64) {
	p.floodRate = &attr
}

func (p *Event) FloodRate() (int64, bool) {
	if p.floodRate != nil {
		return *p.floodRate, true
	}
	var zero int64
	return zero, false
}

func (p *Event) MustFloodRate() int64 {
	if p.floodRate == nil {
		panic("the floodRate must not be nil, please use FloodRate() function instead")
	}
	return *p.floodRate
}

// SetHost Type representing a host.
func (p *Event) SetHost(attr *Host) {
	p.host = attr
}

// Host Type representing a host.
func (p *Event) Host() (*Host, bool) {
	if p.host != nil {
		return p.host, true
	}
	return nil, false
}

// MustHost Type representing a host.
func (p *Event) MustHost() *Host {
	if p.host == nil {
		panic("the host must not be nil, please use Host() function instead")
	}
	return p.host
}

func (p *Event) SetId(attr string) {
	p.id = &attr
}

func (p *Event) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *Event) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *Event) SetIndex(attr int64) {
	p.index = &attr
}

func (p *Event) Index() (int64, bool) {
	if p.index != nil {
		return *p.index, true
	}
	var zero int64
	return zero, false
}

func (p *Event) MustIndex() int64 {
	if p.index == nil {
		panic("the index must not be nil, please use Index() function instead")
	}
	return *p.index
}

func (p *Event) SetLogOnHost(attr bool) {
	p.logOnHost = &attr
}

func (p *Event) LogOnHost() (bool, bool) {
	if p.logOnHost != nil {
		return *p.logOnHost, true
	}
	var zero bool
	return zero, false
}

func (p *Event) MustLogOnHost() bool {
	if p.logOnHost == nil {
		panic("the logOnHost must not be nil, please use LogOnHost() function instead")
	}
	return *p.logOnHost
}

func (p *Event) SetName(attr string) {
	p.name = &attr
}

func (p *Event) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *Event) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *Event) SetOrigin(attr string) {
	p.origin = &attr
}

func (p *Event) Origin() (string, bool) {
	if p.origin != nil {
		return *p.origin, true
	}
	var zero string
	return zero, false
}

func (p *Event) MustOrigin() string {
	if p.origin == nil {
		panic("the origin must not be nil, please use Origin() function instead")
	}
	return *p.origin
}

// SetSeverity Enum representing a severity of an event.
func (p *Event) SetSeverity(attr LogSeverity) {
	p.severity = &attr
}

// Severity Enum representing a severity of an event.
func (p *Event) Severity() (LogSeverity, bool) {
	if p.severity != nil {
		return *p.severity, true
	}
	var zero LogSeverity
	return zero, false
}

// MustSeverity Enum representing a severity of an event.
func (p *Event) MustSeverity() LogSeverity {
	if p.severity == nil {
		panic("the severity must not be nil, please use Severity() function instead")
	}
	return *p.severity
}

// SetStorageDomain Storage domain.
//
// An XML representation of a NFS storage domain with identifier `123`:
//
// [source,xml]
// ----
// <storage_domain href="/ovirt-engine/api/storagedomains/123" id="123">
//   <name>mydata</name>
//   <description>My data</description>
//   <available>38654705664</available>
//   <committed>1073741824</committed>
//   <critical_space_action_blocker>5</critical_space_action_blocker>
//   <external_status>ok</external_status>
//   <master>true</master>
//   <storage>
//     <address>mynfs.example.com</address>
//     <nfs_version>v3</nfs_version>
//     <path>/exports/mydata</path>
//     <type>nfs</type>
//   </storage>
//   <storage_format>v3</storage_format>
//   <type>data</type>
//   <used>13958643712</used>
//   <warning_low_space_indicator>10</warning_low_space_indicator>
//   <wipe_after_delete>false</wipe_after_delete>
//   <data_centers>
//     <data_center href="/ovirt-engine/api/datacenters/456" id="456"/>
//   </data_centers>
// </storage_domain>
// ----
func (p *Event) SetStorageDomain(attr *StorageDomain) {
	p.storageDomain = attr
}

// StorageDomain Storage domain.
//
// An XML representation of a NFS storage domain with identifier `123`:
//
// [source,xml]
// ----
// <storage_domain href="/ovirt-engine/api/storagedomains/123" id="123">
//   <name>mydata</name>
//   <description>My data</description>
//   <available>38654705664</available>
//   <committed>1073741824</committed>
//   <critical_space_action_blocker>5</critical_space_action_blocker>
//   <external_status>ok</external_status>
//   <master>true</master>
//   <storage>
//     <address>mynfs.example.com</address>
//     <nfs_version>v3</nfs_version>
//     <path>/exports/mydata</path>
//     <type>nfs</type>
//   </storage>
//   <storage_format>v3</storage_format>
//   <type>data</type>
//   <used>13958643712</used>
//   <warning_low_space_indicator>10</warning_low_space_indicator>
//   <wipe_after_delete>false</wipe_after_delete>
//   <data_centers>
//     <data_center href="/ovirt-engine/api/datacenters/456" id="456"/>
//   </data_centers>
// </storage_domain>
// ----
func (p *Event) StorageDomain() (*StorageDomain, bool) {
	if p.storageDomain != nil {
		return p.storageDomain, true
	}
	return nil, false
}

// MustStorageDomain Storage domain.
//
// An XML representation of a NFS storage domain with identifier `123`:
//
// [source,xml]
// ----
// <storage_domain href="/ovirt-engine/api/storagedomains/123" id="123">
//   <name>mydata</name>
//   <description>My data</description>
//   <available>38654705664</available>
//   <committed>1073741824</committed>
//   <critical_space_action_blocker>5</critical_space_action_blocker>
//   <external_status>ok</external_status>
//   <master>true</master>
//   <storage>
//     <address>mynfs.example.com</address>
//     <nfs_version>v3</nfs_version>
//     <path>/exports/mydata</path>
//     <type>nfs</type>
//   </storage>
//   <storage_format>v3</storage_format>
//   <type>data</type>
//   <used>13958643712</used>
//   <warning_low_space_indicator>10</warning_low_space_indicator>
//   <wipe_after_delete>false</wipe_after_delete>
//   <data_centers>
//     <data_center href="/ovirt-engine/api/datacenters/456" id="456"/>
//   </data_centers>
// </storage_domain>
// ----
func (p *Event) MustStorageDomain() *StorageDomain {
	if p.storageDomain == nil {
		panic("the storageDomain must not be nil, please use StorageDomain() function instead")
	}
	return p.storageDomain
}

// SetTemplate The type that represents a virtual machine template.
// Templates allow for a rapid instantiation of virtual machines with common configuration and disk states.
func (p *Event) SetTemplate(attr *Template) {
	p.template = attr
}

// Template The type that represents a virtual machine template.
// Templates allow for a rapid instantiation of virtual machines with common configuration and disk states.
func (p *Event) Template() (*Template, bool) {
	if p.template != nil {
		return p.template, true
	}
	return nil, false
}

// MustTemplate The type that represents a virtual machine template.
// Templates allow for a rapid instantiation of virtual machines with common configuration and disk states.
func (p *Event) MustTemplate() *Template {
	if p.template == nil {
		panic("the template must not be nil, please use Template() function instead")
	}
	return p.template
}

func (p *Event) SetTime(attr time.Time) {
	p.time = &attr
}

func (p *Event) Time() (time.Time, bool) {
	if p.time != nil {
		return *p.time, true
	}
	var zero time.Time
	return zero, false
}

func (p *Event) MustTime() time.Time {
	if p.time == nil {
		panic("the time must not be nil, please use Time() function instead")
	}
	return *p.time
}

// SetUser Represents a user in the system.
func (p *Event) SetUser(attr *User) {
	p.user = attr
}

// User Represents a user in the system.
func (p *Event) User() (*User, bool) {
	if p.user != nil {
		return p.user, true
	}
	return nil, false
}

// MustUser Represents a user in the system.
func (p *Event) MustUser() *User {
	if p.user == nil {
		panic("the user must not be nil, please use User() function instead")
	}
	return p.user
}

// SetVm Represents a virtual machine.
func (p *Event) SetVm(attr *Vm) {
	p.vm = attr
}

// Vm Represents a virtual machine.
func (p *Event) Vm() (*Vm, bool) {
	if p.vm != nil {
		return p.vm, true
	}
	return nil, false
}

// MustVm Represents a virtual machine.
func (p *Event) MustVm() *Vm {
	if p.vm == nil {
		panic("the vm must not be nil, please use Vm() function instead")
	}
	return p.vm
}

type EventSubscription struct {
	Struct
	address            *string
	comment            *string
	description        *string
	event              *NotifiableEvent
	id                 *string
	name               *string
	notificationMethod *NotificationMethod
	user               *User
}

func (p *EventSubscription) SetAddress(attr string) {
	p.address = &attr
}

func (p *EventSubscription) Address() (string, bool) {
	if p.address != nil {
		return *p.address, true
	}
	var zero string
	return zero, false
}

func (p *EventSubscription) MustAddress() string {
	if p.address == nil {
		panic("the address must not be nil, please use Address() function instead")
	}
	return *p.address
}

func (p *EventSubscription) SetComment(attr string) {
	p.comment = &attr
}

func (p *EventSubscription) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *EventSubscription) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *EventSubscription) SetDescription(attr string) {
	p.description = &attr
}

func (p *EventSubscription) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *EventSubscription) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

// SetEvent Type representing a subset of events in the {product-name} server:
// those which a user may subscribe to receive a notification about.
func (p *EventSubscription) SetEvent(attr NotifiableEvent) {
	p.event = &attr
}

// Event Type representing a subset of events in the {product-name} server:
// those which a user may subscribe to receive a notification about.
func (p *EventSubscription) Event() (NotifiableEvent, bool) {
	if p.event != nil {
		return *p.event, true
	}
	var zero NotifiableEvent
	return zero, false
}

// MustEvent Type representing a subset of events in the {product-name} server:
// those which a user may subscribe to receive a notification about.
func (p *EventSubscription) MustEvent() NotifiableEvent {
	if p.event == nil {
		panic("the event must not be nil, please use Event() function instead")
	}
	return *p.event
}

func (p *EventSubscription) SetId(attr string) {
	p.id = &attr
}

func (p *EventSubscription) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *EventSubscription) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *EventSubscription) SetName(attr string) {
	p.name = &attr
}

func (p *EventSubscription) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *EventSubscription) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

// SetNotificationMethod Type representing the notification method for an event
// subscription. Currently only SMTP is supported by the API
// In the future support for SNMP notifications may be added.
func (p *EventSubscription) SetNotificationMethod(attr NotificationMethod) {
	p.notificationMethod = &attr
}

// NotificationMethod Type representing the notification method for an event
// subscription. Currently only SMTP is supported by the API
// In the future support for SNMP notifications may be added.
func (p *EventSubscription) NotificationMethod() (NotificationMethod, bool) {
	if p.notificationMethod != nil {
		return *p.notificationMethod, true
	}
	var zero NotificationMethod
	return zero, false
}

// MustNotificationMethod Type representing the notification method for an event
// subscription. Currently only SMTP is supported by the API
// In the future support for SNMP notifications may be added.
func (p *EventSubscription) MustNotificationMethod() NotificationMethod {
	if p.notificationMethod == nil {
		panic("the notificationMethod must not be nil, please use NotificationMethod() function instead")
	}
	return *p.notificationMethod
}

// SetUser Represents a user in the system.
func (p *EventSubscription) SetUser(attr *User) {
	p.user = attr
}

// User Represents a user in the system.
func (p *EventSubscription) User() (*User, bool) {
	if p.user != nil {
		return p.user, true
	}
	return nil, false
}

// MustUser Represents a user in the system.
func (p *EventSubscription) MustUser() *User {
	if p.user == nil {
		panic("the user must not be nil, please use User() function instead")
	}
	return p.user
}

type ExternalComputeResource struct {
	Struct
	comment              *string
	description          *string
	externalHostProvider *ExternalHostProvider
	id                   *string
	name                 *string
	provider             *string
	url                  *string
	user                 *string
}

func (p *ExternalComputeResource) SetComment(attr string) {
	p.comment = &attr
}

func (p *ExternalComputeResource) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *ExternalComputeResource) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *ExternalComputeResource) SetDescription(attr string) {
	p.description = &attr
}

func (p *ExternalComputeResource) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *ExternalComputeResource) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

// SetExternalHostProvider Represents an external host provider,
// such as Foreman or Satellite.
//
// See https://www.theforeman.org/ for more details on Foreman.
// See https://access.redhat.com/products/red-hat-satellite
// for more details on Red Hat Satellite.
func (p *ExternalComputeResource) SetExternalHostProvider(attr *ExternalHostProvider) {
	p.externalHostProvider = attr
}

// ExternalHostProvider Represents an external host provider,
// such as Foreman or Satellite.
//
// See https://www.theforeman.org/ for more details on Foreman.
// See https://access.redhat.com/products/red-hat-satellite
// for more details on Red Hat Satellite.
func (p *ExternalComputeResource) ExternalHostProvider() (*ExternalHostProvider, bool) {
	if p.externalHostProvider != nil {
		return p.externalHostProvider, true
	}
	return nil, false
}

// MustExternalHostProvider Represents an external host provider,
// such as Foreman or Satellite.
//
// See https://www.theforeman.org/ for more details on Foreman.
// See https://access.redhat.com/products/red-hat-satellite
// for more details on Red Hat Satellite.
func (p *ExternalComputeResource) MustExternalHostProvider() *ExternalHostProvider {
	if p.externalHostProvider == nil {
		panic("the externalHostProvider must not be nil, please use ExternalHostProvider() function instead")
	}
	return p.externalHostProvider
}

func (p *ExternalComputeResource) SetId(attr string) {
	p.id = &attr
}

func (p *ExternalComputeResource) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *ExternalComputeResource) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *ExternalComputeResource) SetName(attr string) {
	p.name = &attr
}

func (p *ExternalComputeResource) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *ExternalComputeResource) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *ExternalComputeResource) SetProvider(attr string) {
	p.provider = &attr
}

func (p *ExternalComputeResource) Provider() (string, bool) {
	if p.provider != nil {
		return *p.provider, true
	}
	var zero string
	return zero, false
}

func (p *ExternalComputeResource) MustProvider() string {
	if p.provider == nil {
		panic("the provider must not be nil, please use Provider() function instead")
	}
	return *p.provider
}

func (p *ExternalComputeResource) SetUrl(attr string) {
	p.url = &attr
}

func (p *ExternalComputeResource) Url() (string, bool) {
	if p.url != nil {
		return *p.url, true
	}
	var zero string
	return zero, false
}

func (p *ExternalComputeResource) MustUrl() string {
	if p.url == nil {
		panic("the url must not be nil, please use Url() function instead")
	}
	return *p.url
}

func (p *ExternalComputeResource) SetUser(attr string) {
	p.user = &attr
}

func (p *ExternalComputeResource) User() (string, bool) {
	if p.user != nil {
		return *p.user, true
	}
	var zero string
	return zero, false
}

func (p *ExternalComputeResource) MustUser() string {
	if p.user == nil {
		panic("the user must not be nil, please use User() function instead")
	}
	return *p.user
}

type ExternalDiscoveredHost struct {
	Struct
	comment              *string
	description          *string
	externalHostProvider *ExternalHostProvider
	id                   *string
	ip                   *string
	lastReport           *string
	mac                  *string
	name                 *string
	subnetName           *string
}

func (p *ExternalDiscoveredHost) SetComment(attr string) {
	p.comment = &attr
}

func (p *ExternalDiscoveredHost) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *ExternalDiscoveredHost) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *ExternalDiscoveredHost) SetDescription(attr string) {
	p.description = &attr
}

func (p *ExternalDiscoveredHost) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *ExternalDiscoveredHost) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

// SetExternalHostProvider Represents an external host provider,
// such as Foreman or Satellite.
//
// See https://www.theforeman.org/ for more details on Foreman.
// See https://access.redhat.com/products/red-hat-satellite
// for more details on Red Hat Satellite.
func (p *ExternalDiscoveredHost) SetExternalHostProvider(attr *ExternalHostProvider) {
	p.externalHostProvider = attr
}

// ExternalHostProvider Represents an external host provider,
// such as Foreman or Satellite.
//
// See https://www.theforeman.org/ for more details on Foreman.
// See https://access.redhat.com/products/red-hat-satellite
// for more details on Red Hat Satellite.
func (p *ExternalDiscoveredHost) ExternalHostProvider() (*ExternalHostProvider, bool) {
	if p.externalHostProvider != nil {
		return p.externalHostProvider, true
	}
	return nil, false
}

// MustExternalHostProvider Represents an external host provider,
// such as Foreman or Satellite.
//
// See https://www.theforeman.org/ for more details on Foreman.
// See https://access.redhat.com/products/red-hat-satellite
// for more details on Red Hat Satellite.
func (p *ExternalDiscoveredHost) MustExternalHostProvider() *ExternalHostProvider {
	if p.externalHostProvider == nil {
		panic("the externalHostProvider must not be nil, please use ExternalHostProvider() function instead")
	}
	return p.externalHostProvider
}

func (p *ExternalDiscoveredHost) SetId(attr string) {
	p.id = &attr
}

func (p *ExternalDiscoveredHost) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *ExternalDiscoveredHost) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *ExternalDiscoveredHost) SetIp(attr string) {
	p.ip = &attr
}

func (p *ExternalDiscoveredHost) Ip() (string, bool) {
	if p.ip != nil {
		return *p.ip, true
	}
	var zero string
	return zero, false
}

func (p *ExternalDiscoveredHost) MustIp() string {
	if p.ip == nil {
		panic("the ip must not be nil, please use Ip() function instead")
	}
	return *p.ip
}

func (p *ExternalDiscoveredHost) SetLastReport(attr string) {
	p.lastReport = &attr
}

func (p *ExternalDiscoveredHost) LastReport() (string, bool) {
	if p.lastReport != nil {
		return *p.lastReport, true
	}
	var zero string
	return zero, false
}

func (p *ExternalDiscoveredHost) MustLastReport() string {
	if p.lastReport == nil {
		panic("the lastReport must not be nil, please use LastReport() function instead")
	}
	return *p.lastReport
}

func (p *ExternalDiscoveredHost) SetMac(attr string) {
	p.mac = &attr
}

func (p *ExternalDiscoveredHost) Mac() (string, bool) {
	if p.mac != nil {
		return *p.mac, true
	}
	var zero string
	return zero, false
}

func (p *ExternalDiscoveredHost) MustMac() string {
	if p.mac == nil {
		panic("the mac must not be nil, please use Mac() function instead")
	}
	return *p.mac
}

func (p *ExternalDiscoveredHost) SetName(attr string) {
	p.name = &attr
}

func (p *ExternalDiscoveredHost) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *ExternalDiscoveredHost) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *ExternalDiscoveredHost) SetSubnetName(attr string) {
	p.subnetName = &attr
}

func (p *ExternalDiscoveredHost) SubnetName() (string, bool) {
	if p.subnetName != nil {
		return *p.subnetName, true
	}
	var zero string
	return zero, false
}

func (p *ExternalDiscoveredHost) MustSubnetName() string {
	if p.subnetName == nil {
		panic("the subnetName must not be nil, please use SubnetName() function instead")
	}
	return *p.subnetName
}

// ExternalHost Represents a host provisioned by a host
// provider (such as Foreman/Satellite).
//
// See https://www.theforeman.org/ for more details on Foreman.
// See https://access.redhat.com/products/red-hat-satellite
// for more details on Red Hat Satellite.
type ExternalHost struct {
	Struct
	address              *string
	comment              *string
	description          *string
	externalHostProvider *ExternalHostProvider
	id                   *string
	name                 *string
}

func (p *ExternalHost) SetAddress(attr string) {
	p.address = &attr
}

func (p *ExternalHost) Address() (string, bool) {
	if p.address != nil {
		return *p.address, true
	}
	var zero string
	return zero, false
}

func (p *ExternalHost) MustAddress() string {
	if p.address == nil {
		panic("the address must not be nil, please use Address() function instead")
	}
	return *p.address
}

func (p *ExternalHost) SetComment(attr string) {
	p.comment = &attr
}

func (p *ExternalHost) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *ExternalHost) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *ExternalHost) SetDescription(attr string) {
	p.description = &attr
}

func (p *ExternalHost) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *ExternalHost) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

// SetExternalHostProvider Represents an external host provider,
// such as Foreman or Satellite.
//
// See https://www.theforeman.org/ for more details on Foreman.
// See https://access.redhat.com/products/red-hat-satellite
// for more details on Red Hat Satellite.
func (p *ExternalHost) SetExternalHostProvider(attr *ExternalHostProvider) {
	p.externalHostProvider = attr
}

// ExternalHostProvider Represents an external host provider,
// such as Foreman or Satellite.
//
// See https://www.theforeman.org/ for more details on Foreman.
// See https://access.redhat.com/products/red-hat-satellite
// for more details on Red Hat Satellite.
func (p *ExternalHost) ExternalHostProvider() (*ExternalHostProvider, bool) {
	if p.externalHostProvider != nil {
		return p.externalHostProvider, true
	}
	return nil, false
}

// MustExternalHostProvider Represents an external host provider,
// such as Foreman or Satellite.
//
// See https://www.theforeman.org/ for more details on Foreman.
// See https://access.redhat.com/products/red-hat-satellite
// for more details on Red Hat Satellite.
func (p *ExternalHost) MustExternalHostProvider() *ExternalHostProvider {
	if p.externalHostProvider == nil {
		panic("the externalHostProvider must not be nil, please use ExternalHostProvider() function instead")
	}
	return p.externalHostProvider
}

func (p *ExternalHost) SetId(attr string) {
	p.id = &attr
}

func (p *ExternalHost) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *ExternalHost) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *ExternalHost) SetName(attr string) {
	p.name = &attr
}

func (p *ExternalHost) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *ExternalHost) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

type ExternalHostGroup struct {
	Struct
	architectureName     *string
	comment              *string
	description          *string
	domainName           *string
	externalHostProvider *ExternalHostProvider
	id                   *string
	name                 *string
	operatingSystemName  *string
	subnetName           *string
}

func (p *ExternalHostGroup) SetArchitectureName(attr string) {
	p.architectureName = &attr
}

func (p *ExternalHostGroup) ArchitectureName() (string, bool) {
	if p.architectureName != nil {
		return *p.architectureName, true
	}
	var zero string
	return zero, false
}

func (p *ExternalHostGroup) MustArchitectureName() string {
	if p.architectureName == nil {
		panic("the architectureName must not be nil, please use ArchitectureName() function instead")
	}
	return *p.architectureName
}

func (p *ExternalHostGroup) SetComment(attr string) {
	p.comment = &attr
}

func (p *ExternalHostGroup) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *ExternalHostGroup) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *ExternalHostGroup) SetDescription(attr string) {
	p.description = &attr
}

func (p *ExternalHostGroup) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *ExternalHostGroup) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *ExternalHostGroup) SetDomainName(attr string) {
	p.domainName = &attr
}

func (p *ExternalHostGroup) DomainName() (string, bool) {
	if p.domainName != nil {
		return *p.domainName, true
	}
	var zero string
	return zero, false
}

func (p *ExternalHostGroup) MustDomainName() string {
	if p.domainName == nil {
		panic("the domainName must not be nil, please use DomainName() function instead")
	}
	return *p.domainName
}

// SetExternalHostProvider Represents an external host provider,
// such as Foreman or Satellite.
//
// See https://www.theforeman.org/ for more details on Foreman.
// See https://access.redhat.com/products/red-hat-satellite
// for more details on Red Hat Satellite.
func (p *ExternalHostGroup) SetExternalHostProvider(attr *ExternalHostProvider) {
	p.externalHostProvider = attr
}

// ExternalHostProvider Represents an external host provider,
// such as Foreman or Satellite.
//
// See https://www.theforeman.org/ for more details on Foreman.
// See https://access.redhat.com/products/red-hat-satellite
// for more details on Red Hat Satellite.
func (p *ExternalHostGroup) ExternalHostProvider() (*ExternalHostProvider, bool) {
	if p.externalHostProvider != nil {
		return p.externalHostProvider, true
	}
	return nil, false
}

// MustExternalHostProvider Represents an external host provider,
// such as Foreman or Satellite.
//
// See https://www.theforeman.org/ for more details on Foreman.
// See https://access.redhat.com/products/red-hat-satellite
// for more details on Red Hat Satellite.
func (p *ExternalHostGroup) MustExternalHostProvider() *ExternalHostProvider {
	if p.externalHostProvider == nil {
		panic("the externalHostProvider must not be nil, please use ExternalHostProvider() function instead")
	}
	return p.externalHostProvider
}

func (p *ExternalHostGroup) SetId(attr string) {
	p.id = &attr
}

func (p *ExternalHostGroup) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *ExternalHostGroup) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *ExternalHostGroup) SetName(attr string) {
	p.name = &attr
}

func (p *ExternalHostGroup) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *ExternalHostGroup) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *ExternalHostGroup) SetOperatingSystemName(attr string) {
	p.operatingSystemName = &attr
}

func (p *ExternalHostGroup) OperatingSystemName() (string, bool) {
	if p.operatingSystemName != nil {
		return *p.operatingSystemName, true
	}
	var zero string
	return zero, false
}

func (p *ExternalHostGroup) MustOperatingSystemName() string {
	if p.operatingSystemName == nil {
		panic("the operatingSystemName must not be nil, please use OperatingSystemName() function instead")
	}
	return *p.operatingSystemName
}

func (p *ExternalHostGroup) SetSubnetName(attr string) {
	p.subnetName = &attr
}

func (p *ExternalHostGroup) SubnetName() (string, bool) {
	if p.subnetName != nil {
		return *p.subnetName, true
	}
	var zero string
	return zero, false
}

func (p *ExternalHostGroup) MustSubnetName() string {
	if p.subnetName == nil {
		panic("the subnetName must not be nil, please use SubnetName() function instead")
	}
	return *p.subnetName
}

// ExternalHostProvider Represents an external host provider,
// such as Foreman or Satellite.
//
// See https://www.theforeman.org/ for more details on Foreman.
// See https://access.redhat.com/products/red-hat-satellite
// for more details on Red Hat Satellite.
type ExternalHostProvider struct {
	Struct
	authenticationUrl      *string
	certificates           *CertificateSlice
	comment                *string
	computeResources       *ExternalComputeResourceSlice
	description            *string
	discoveredHosts        *ExternalDiscoveredHostSlice
	hostGroups             *ExternalHostGroupSlice
	hosts                  *HostSlice
	id                     *string
	name                   *string
	password               *string
	properties             *PropertySlice
	requiresAuthentication *bool
	url                    *string
	username               *string
}

func (p *ExternalHostProvider) SetAuthenticationUrl(attr string) {
	p.authenticationUrl = &attr
}

func (p *ExternalHostProvider) AuthenticationUrl() (string, bool) {
	if p.authenticationUrl != nil {
		return *p.authenticationUrl, true
	}
	var zero string
	return zero, false
}

func (p *ExternalHostProvider) MustAuthenticationUrl() string {
	if p.authenticationUrl == nil {
		panic("the authenticationUrl must not be nil, please use AuthenticationUrl() function instead")
	}
	return *p.authenticationUrl
}

func (p *ExternalHostProvider) SetCertificates(attr *CertificateSlice) {
	p.certificates = attr
}

func (p *ExternalHostProvider) Certificates() (*CertificateSlice, bool) {
	if p.certificates != nil {
		return p.certificates, true
	}
	return nil, false
}

func (p *ExternalHostProvider) MustCertificates() *CertificateSlice {
	if p.certificates == nil {
		panic("the certificates must not be nil, please use Certificates() function instead")
	}
	return p.certificates
}

func (p *ExternalHostProvider) SetComment(attr string) {
	p.comment = &attr
}

func (p *ExternalHostProvider) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *ExternalHostProvider) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *ExternalHostProvider) SetComputeResources(attr *ExternalComputeResourceSlice) {
	p.computeResources = attr
}

func (p *ExternalHostProvider) ComputeResources() (*ExternalComputeResourceSlice, bool) {
	if p.computeResources != nil {
		return p.computeResources, true
	}
	return nil, false
}

func (p *ExternalHostProvider) MustComputeResources() *ExternalComputeResourceSlice {
	if p.computeResources == nil {
		panic("the computeResources must not be nil, please use ComputeResources() function instead")
	}
	return p.computeResources
}

func (p *ExternalHostProvider) SetDescription(attr string) {
	p.description = &attr
}

func (p *ExternalHostProvider) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *ExternalHostProvider) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *ExternalHostProvider) SetDiscoveredHosts(attr *ExternalDiscoveredHostSlice) {
	p.discoveredHosts = attr
}

func (p *ExternalHostProvider) DiscoveredHosts() (*ExternalDiscoveredHostSlice, bool) {
	if p.discoveredHosts != nil {
		return p.discoveredHosts, true
	}
	return nil, false
}

func (p *ExternalHostProvider) MustDiscoveredHosts() *ExternalDiscoveredHostSlice {
	if p.discoveredHosts == nil {
		panic("the discoveredHosts must not be nil, please use DiscoveredHosts() function instead")
	}
	return p.discoveredHosts
}

func (p *ExternalHostProvider) SetHostGroups(attr *ExternalHostGroupSlice) {
	p.hostGroups = attr
}

func (p *ExternalHostProvider) HostGroups() (*ExternalHostGroupSlice, bool) {
	if p.hostGroups != nil {
		return p.hostGroups, true
	}
	return nil, false
}

func (p *ExternalHostProvider) MustHostGroups() *ExternalHostGroupSlice {
	if p.hostGroups == nil {
		panic("the hostGroups must not be nil, please use HostGroups() function instead")
	}
	return p.hostGroups
}

func (p *ExternalHostProvider) SetHosts(attr *HostSlice) {
	p.hosts = attr
}

func (p *ExternalHostProvider) Hosts() (*HostSlice, bool) {
	if p.hosts != nil {
		return p.hosts, true
	}
	return nil, false
}

func (p *ExternalHostProvider) MustHosts() *HostSlice {
	if p.hosts == nil {
		panic("the hosts must not be nil, please use Hosts() function instead")
	}
	return p.hosts
}

func (p *ExternalHostProvider) SetId(attr string) {
	p.id = &attr
}

func (p *ExternalHostProvider) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *ExternalHostProvider) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *ExternalHostProvider) SetName(attr string) {
	p.name = &attr
}

func (p *ExternalHostProvider) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *ExternalHostProvider) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *ExternalHostProvider) SetPassword(attr string) {
	p.password = &attr
}

func (p *ExternalHostProvider) Password() (string, bool) {
	if p.password != nil {
		return *p.password, true
	}
	var zero string
	return zero, false
}

func (p *ExternalHostProvider) MustPassword() string {
	if p.password == nil {
		panic("the password must not be nil, please use Password() function instead")
	}
	return *p.password
}

func (p *ExternalHostProvider) SetProperties(attr *PropertySlice) {
	p.properties = attr
}

func (p *ExternalHostProvider) Properties() (*PropertySlice, bool) {
	if p.properties != nil {
		return p.properties, true
	}
	return nil, false
}

func (p *ExternalHostProvider) MustProperties() *PropertySlice {
	if p.properties == nil {
		panic("the properties must not be nil, please use Properties() function instead")
	}
	return p.properties
}

func (p *ExternalHostProvider) SetRequiresAuthentication(attr bool) {
	p.requiresAuthentication = &attr
}

func (p *ExternalHostProvider) RequiresAuthentication() (bool, bool) {
	if p.requiresAuthentication != nil {
		return *p.requiresAuthentication, true
	}
	var zero bool
	return zero, false
}

func (p *ExternalHostProvider) MustRequiresAuthentication() bool {
	if p.requiresAuthentication == nil {
		panic("the requiresAuthentication must not be nil, please use RequiresAuthentication() function instead")
	}
	return *p.requiresAuthentication
}

func (p *ExternalHostProvider) SetUrl(attr string) {
	p.url = &attr
}

func (p *ExternalHostProvider) Url() (string, bool) {
	if p.url != nil {
		return *p.url, true
	}
	var zero string
	return zero, false
}

func (p *ExternalHostProvider) MustUrl() string {
	if p.url == nil {
		panic("the url must not be nil, please use Url() function instead")
	}
	return *p.url
}

func (p *ExternalHostProvider) SetUsername(attr string) {
	p.username = &attr
}

func (p *ExternalHostProvider) Username() (string, bool) {
	if p.username != nil {
		return *p.username, true
	}
	var zero string
	return zero, false
}

func (p *ExternalHostProvider) MustUsername() string {
	if p.username == nil {
		panic("the username must not be nil, please use Username() function instead")
	}
	return *p.username
}

// ExternalNetworkProviderConfiguration Describes how an external network provider is provisioned on a host.
type ExternalNetworkProviderConfiguration struct {
	Struct
	comment                 *string
	description             *string
	externalNetworkProvider *ExternalProvider
	host                    *Host
	id                      *string
	name                    *string
}

func (p *ExternalNetworkProviderConfiguration) SetComment(attr string) {
	p.comment = &attr
}

func (p *ExternalNetworkProviderConfiguration) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *ExternalNetworkProviderConfiguration) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *ExternalNetworkProviderConfiguration) SetDescription(attr string) {
	p.description = &attr
}

func (p *ExternalNetworkProviderConfiguration) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *ExternalNetworkProviderConfiguration) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

// SetExternalNetworkProvider Represents an external provider.
func (p *ExternalNetworkProviderConfiguration) SetExternalNetworkProvider(attr *ExternalProvider) {
	p.externalNetworkProvider = attr
}

// ExternalNetworkProvider Represents an external provider.
func (p *ExternalNetworkProviderConfiguration) ExternalNetworkProvider() (*ExternalProvider, bool) {
	if p.externalNetworkProvider != nil {
		return p.externalNetworkProvider, true
	}
	return nil, false
}

// MustExternalNetworkProvider Represents an external provider.
func (p *ExternalNetworkProviderConfiguration) MustExternalNetworkProvider() *ExternalProvider {
	if p.externalNetworkProvider == nil {
		panic("the externalNetworkProvider must not be nil, please use ExternalNetworkProvider() function instead")
	}
	return p.externalNetworkProvider
}

// SetHost Type representing a host.
func (p *ExternalNetworkProviderConfiguration) SetHost(attr *Host) {
	p.host = attr
}

// Host Type representing a host.
func (p *ExternalNetworkProviderConfiguration) Host() (*Host, bool) {
	if p.host != nil {
		return p.host, true
	}
	return nil, false
}

// MustHost Type representing a host.
func (p *ExternalNetworkProviderConfiguration) MustHost() *Host {
	if p.host == nil {
		panic("the host must not be nil, please use Host() function instead")
	}
	return p.host
}

func (p *ExternalNetworkProviderConfiguration) SetId(attr string) {
	p.id = &attr
}

func (p *ExternalNetworkProviderConfiguration) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *ExternalNetworkProviderConfiguration) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *ExternalNetworkProviderConfiguration) SetName(attr string) {
	p.name = &attr
}

func (p *ExternalNetworkProviderConfiguration) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *ExternalNetworkProviderConfiguration) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

// ExternalProvider Represents an external provider.
type ExternalProvider struct {
	Struct
	authenticationUrl      *string
	comment                *string
	description            *string
	id                     *string
	name                   *string
	password               *string
	properties             *PropertySlice
	requiresAuthentication *bool
	url                    *string
	username               *string
}

func (p *ExternalProvider) SetAuthenticationUrl(attr string) {
	p.authenticationUrl = &attr
}

func (p *ExternalProvider) AuthenticationUrl() (string, bool) {
	if p.authenticationUrl != nil {
		return *p.authenticationUrl, true
	}
	var zero string
	return zero, false
}

func (p *ExternalProvider) MustAuthenticationUrl() string {
	if p.authenticationUrl == nil {
		panic("the authenticationUrl must not be nil, please use AuthenticationUrl() function instead")
	}
	return *p.authenticationUrl
}

func (p *ExternalProvider) SetComment(attr string) {
	p.comment = &attr
}

func (p *ExternalProvider) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *ExternalProvider) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *ExternalProvider) SetDescription(attr string) {
	p.description = &attr
}

func (p *ExternalProvider) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *ExternalProvider) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *ExternalProvider) SetId(attr string) {
	p.id = &attr
}

func (p *ExternalProvider) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *ExternalProvider) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *ExternalProvider) SetName(attr string) {
	p.name = &attr
}

func (p *ExternalProvider) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *ExternalProvider) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *ExternalProvider) SetPassword(attr string) {
	p.password = &attr
}

func (p *ExternalProvider) Password() (string, bool) {
	if p.password != nil {
		return *p.password, true
	}
	var zero string
	return zero, false
}

func (p *ExternalProvider) MustPassword() string {
	if p.password == nil {
		panic("the password must not be nil, please use Password() function instead")
	}
	return *p.password
}

func (p *ExternalProvider) SetProperties(attr *PropertySlice) {
	p.properties = attr
}

func (p *ExternalProvider) Properties() (*PropertySlice, bool) {
	if p.properties != nil {
		return p.properties, true
	}
	return nil, false
}

func (p *ExternalProvider) MustProperties() *PropertySlice {
	if p.properties == nil {
		panic("the properties must not be nil, please use Properties() function instead")
	}
	return p.properties
}

func (p *ExternalProvider) SetRequiresAuthentication(attr bool) {
	p.requiresAuthentication = &attr
}

func (p *ExternalProvider) RequiresAuthentication() (bool, bool) {
	if p.requiresAuthentication != nil {
		return *p.requiresAuthentication, true
	}
	var zero bool
	return zero, false
}

func (p *ExternalProvider) MustRequiresAuthentication() bool {
	if p.requiresAuthentication == nil {
		panic("the requiresAuthentication must not be nil, please use RequiresAuthentication() function instead")
	}
	return *p.requiresAuthentication
}

func (p *ExternalProvider) SetUrl(attr string) {
	p.url = &attr
}

func (p *ExternalProvider) Url() (string, bool) {
	if p.url != nil {
		return *p.url, true
	}
	var zero string
	return zero, false
}

func (p *ExternalProvider) MustUrl() string {
	if p.url == nil {
		panic("the url must not be nil, please use Url() function instead")
	}
	return *p.url
}

func (p *ExternalProvider) SetUsername(attr string) {
	p.username = &attr
}

func (p *ExternalProvider) Username() (string, bool) {
	if p.username != nil {
		return *p.username, true
	}
	var zero string
	return zero, false
}

func (p *ExternalProvider) MustUsername() string {
	if p.username == nil {
		panic("the username must not be nil, please use Username() function instead")
	}
	return *p.username
}

// ExternalTemplateImport Describes the parameters for the template import operation from an external system.
// Currently supports OVA only.
type ExternalTemplateImport struct {
	Struct
	cluster       *Cluster
	cpuProfile    *CpuProfile
	host          *Host
	quota         *Quota
	storageDomain *StorageDomain
	template      *Template
	url           *string
}

// SetCluster Type representation of a cluster.
//
// A JSON representation of a cluster:
//
// [source]
// ----
// {
//   "cluster" : [ {
//     "ballooning_enabled" : "false",
//     "cpu" : {
//       "architecture" : "x86_64",
//       "type" : "Intel SandyBridge Family"
//     },
//     "custom_scheduling_policy_properties" : {
//       "property" : [ {
//         "name" : "HighUtilization",
//         "value" : "80"
//       }, {
//         "name" : "CpuOverCommitDurationMinutes",
//         "value" : "2"
//       } ]
//     },
//     "error_handling" : {
//       "on_error" : "migrate"
//     },
//     "fencing_policy" : {
//       "enabled" : "true",
//       "skip_if_connectivity_broken" : {
//         "enabled" : "false",
//         "threshold" : "50"
//       },
//       "skip_if_gluster_bricks_up" : "false",
//       "skip_if_gluster_quorum_not_met" : "false",
//       "skip_if_sd_active" : {
//         "enabled" : "false"
//       }
//     },
//     "gluster_service" : "false",
//     "firewall_type" : "iptables",
//     "ha_reservation" : "false",
//     "ksm" : {
//       "enabled" : "true",
//       "merge_across_nodes" : "true"
//     },
//     "memory_policy" : {
//       "over_commit" : {
//         "percent" : "100"
//       },
//       "transparent_hugepages" : {
//         "enabled" : "true"
//       }
//     },
//     "migration" : {
//       "auto_converge" : "inherit",
//       "bandwidth" : {
//         "assignment_method" : "auto"
//       },
//       "compressed" : "inherit",
//       "policy" : {
//         "id" : "00000000-0000-0000-0000-000000000000"
//       }
//     },
//     "required_rng_sources" : {
//       "required_rng_source" : [ "random" ]
//     },
//     "switch_type" : "legacy",
//     "threads_as_cores" : "false",
//     "trusted_service" : "false",
//     "tunnel_migration" : "false",
//     "version" : {
//       "major" : "4",
//       "minor" : "1"
//     },
//     "virt_service" : "true",
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "mac_pool" : {
//       "href" : "/ovirt-engine/api/macpools/456",
//       "id" : "456"
//     },
//     "scheduling_policy" : {
//       "href" : "/ovirt-engine/api/schedulingpolicies/789",
//       "id" : "789"
//     },
//     "actions" : {
//       "link" : [ {
//         "href" : "/ovirt-engine/api/clusters/234/resetemulatedmachine",
//         "rel" : "resetemulatedmachine"
//       } ]
//     },
//     "name" : "Default",
//     "description" : "The default server cluster",
//     "href" : "/ovirt-engine/api/clusters/234",
//     "id" : "234",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/clusters/234/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/cpuprofiles",
//       "rel" : "cpuprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networkfilters",
//       "rel" : "networkfilters"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networks",
//       "rel" : "networks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/affinitygroups",
//       "rel" : "affinitygroups"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glusterhooks",
//       "rel" : "glusterhooks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glustervolumes",
//       "rel" : "glustervolumes"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/enabledfeatures",
//       "rel" : "enabledfeatures"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/externalnetworkproviders",
//       "rel" : "externalnetworkproviders"
//     } ]
//   } ]
// }
// ----
func (p *ExternalTemplateImport) SetCluster(attr *Cluster) {
	p.cluster = attr
}

// Cluster Type representation of a cluster.
//
// A JSON representation of a cluster:
//
// [source]
// ----
// {
//   "cluster" : [ {
//     "ballooning_enabled" : "false",
//     "cpu" : {
//       "architecture" : "x86_64",
//       "type" : "Intel SandyBridge Family"
//     },
//     "custom_scheduling_policy_properties" : {
//       "property" : [ {
//         "name" : "HighUtilization",
//         "value" : "80"
//       }, {
//         "name" : "CpuOverCommitDurationMinutes",
//         "value" : "2"
//       } ]
//     },
//     "error_handling" : {
//       "on_error" : "migrate"
//     },
//     "fencing_policy" : {
//       "enabled" : "true",
//       "skip_if_connectivity_broken" : {
//         "enabled" : "false",
//         "threshold" : "50"
//       },
//       "skip_if_gluster_bricks_up" : "false",
//       "skip_if_gluster_quorum_not_met" : "false",
//       "skip_if_sd_active" : {
//         "enabled" : "false"
//       }
//     },
//     "gluster_service" : "false",
//     "firewall_type" : "iptables",
//     "ha_reservation" : "false",
//     "ksm" : {
//       "enabled" : "true",
//       "merge_across_nodes" : "true"
//     },
//     "memory_policy" : {
//       "over_commit" : {
//         "percent" : "100"
//       },
//       "transparent_hugepages" : {
//         "enabled" : "true"
//       }
//     },
//     "migration" : {
//       "auto_converge" : "inherit",
//       "bandwidth" : {
//         "assignment_method" : "auto"
//       },
//       "compressed" : "inherit",
//       "policy" : {
//         "id" : "00000000-0000-0000-0000-000000000000"
//       }
//     },
//     "required_rng_sources" : {
//       "required_rng_source" : [ "random" ]
//     },
//     "switch_type" : "legacy",
//     "threads_as_cores" : "false",
//     "trusted_service" : "false",
//     "tunnel_migration" : "false",
//     "version" : {
//       "major" : "4",
//       "minor" : "1"
//     },
//     "virt_service" : "true",
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "mac_pool" : {
//       "href" : "/ovirt-engine/api/macpools/456",
//       "id" : "456"
//     },
//     "scheduling_policy" : {
//       "href" : "/ovirt-engine/api/schedulingpolicies/789",
//       "id" : "789"
//     },
//     "actions" : {
//       "link" : [ {
//         "href" : "/ovirt-engine/api/clusters/234/resetemulatedmachine",
//         "rel" : "resetemulatedmachine"
//       } ]
//     },
//     "name" : "Default",
//     "description" : "The default server cluster",
//     "href" : "/ovirt-engine/api/clusters/234",
//     "id" : "234",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/clusters/234/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/cpuprofiles",
//       "rel" : "cpuprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networkfilters",
//       "rel" : "networkfilters"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networks",
//       "rel" : "networks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/affinitygroups",
//       "rel" : "affinitygroups"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glusterhooks",
//       "rel" : "glusterhooks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glustervolumes",
//       "rel" : "glustervolumes"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/enabledfeatures",
//       "rel" : "enabledfeatures"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/externalnetworkproviders",
//       "rel" : "externalnetworkproviders"
//     } ]
//   } ]
// }
// ----
func (p *ExternalTemplateImport) Cluster() (*Cluster, bool) {
	if p.cluster != nil {
		return p.cluster, true
	}
	return nil, false
}

// MustCluster Type representation of a cluster.
//
// A JSON representation of a cluster:
//
// [source]
// ----
// {
//   "cluster" : [ {
//     "ballooning_enabled" : "false",
//     "cpu" : {
//       "architecture" : "x86_64",
//       "type" : "Intel SandyBridge Family"
//     },
//     "custom_scheduling_policy_properties" : {
//       "property" : [ {
//         "name" : "HighUtilization",
//         "value" : "80"
//       }, {
//         "name" : "CpuOverCommitDurationMinutes",
//         "value" : "2"
//       } ]
//     },
//     "error_handling" : {
//       "on_error" : "migrate"
//     },
//     "fencing_policy" : {
//       "enabled" : "true",
//       "skip_if_connectivity_broken" : {
//         "enabled" : "false",
//         "threshold" : "50"
//       },
//       "skip_if_gluster_bricks_up" : "false",
//       "skip_if_gluster_quorum_not_met" : "false",
//       "skip_if_sd_active" : {
//         "enabled" : "false"
//       }
//     },
//     "gluster_service" : "false",
//     "firewall_type" : "iptables",
//     "ha_reservation" : "false",
//     "ksm" : {
//       "enabled" : "true",
//       "merge_across_nodes" : "true"
//     },
//     "memory_policy" : {
//       "over_commit" : {
//         "percent" : "100"
//       },
//       "transparent_hugepages" : {
//         "enabled" : "true"
//       }
//     },
//     "migration" : {
//       "auto_converge" : "inherit",
//       "bandwidth" : {
//         "assignment_method" : "auto"
//       },
//       "compressed" : "inherit",
//       "policy" : {
//         "id" : "00000000-0000-0000-0000-000000000000"
//       }
//     },
//     "required_rng_sources" : {
//       "required_rng_source" : [ "random" ]
//     },
//     "switch_type" : "legacy",
//     "threads_as_cores" : "false",
//     "trusted_service" : "false",
//     "tunnel_migration" : "false",
//     "version" : {
//       "major" : "4",
//       "minor" : "1"
//     },
//     "virt_service" : "true",
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "mac_pool" : {
//       "href" : "/ovirt-engine/api/macpools/456",
//       "id" : "456"
//     },
//     "scheduling_policy" : {
//       "href" : "/ovirt-engine/api/schedulingpolicies/789",
//       "id" : "789"
//     },
//     "actions" : {
//       "link" : [ {
//         "href" : "/ovirt-engine/api/clusters/234/resetemulatedmachine",
//         "rel" : "resetemulatedmachine"
//       } ]
//     },
//     "name" : "Default",
//     "description" : "The default server cluster",
//     "href" : "/ovirt-engine/api/clusters/234",
//     "id" : "234",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/clusters/234/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/cpuprofiles",
//       "rel" : "cpuprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networkfilters",
//       "rel" : "networkfilters"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networks",
//       "rel" : "networks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/affinitygroups",
//       "rel" : "affinitygroups"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glusterhooks",
//       "rel" : "glusterhooks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glustervolumes",
//       "rel" : "glustervolumes"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/enabledfeatures",
//       "rel" : "enabledfeatures"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/externalnetworkproviders",
//       "rel" : "externalnetworkproviders"
//     } ]
//   } ]
// }
// ----
func (p *ExternalTemplateImport) MustCluster() *Cluster {
	if p.cluster == nil {
		panic("the cluster must not be nil, please use Cluster() function instead")
	}
	return p.cluster
}

func (p *ExternalTemplateImport) SetCpuProfile(attr *CpuProfile) {
	p.cpuProfile = attr
}

func (p *ExternalTemplateImport) CpuProfile() (*CpuProfile, bool) {
	if p.cpuProfile != nil {
		return p.cpuProfile, true
	}
	return nil, false
}

func (p *ExternalTemplateImport) MustCpuProfile() *CpuProfile {
	if p.cpuProfile == nil {
		panic("the cpuProfile must not be nil, please use CpuProfile() function instead")
	}
	return p.cpuProfile
}

// SetHost Type representing a host.
func (p *ExternalTemplateImport) SetHost(attr *Host) {
	p.host = attr
}

// Host Type representing a host.
func (p *ExternalTemplateImport) Host() (*Host, bool) {
	if p.host != nil {
		return p.host, true
	}
	return nil, false
}

// MustHost Type representing a host.
func (p *ExternalTemplateImport) MustHost() *Host {
	if p.host == nil {
		panic("the host must not be nil, please use Host() function instead")
	}
	return p.host
}

// SetQuota Represents a quota object.
//
// An example XML representation of a quota:
//
// [source,xml]
// ----
// <quota href="/ovirt-engine/api/datacenters/7044934e/quotas/dcad5ddc" id="dcad5ddc">
//   <name>My Quota</name>
//   <description>A quota for my oVirt environment</description>
//   <cluster_hard_limit_pct>0</cluster_hard_limit_pct>
//   <cluster_soft_limit_pct>0</cluster_soft_limit_pct>
//   <data_center href="/ovirt-engine/api/datacenters/7044934e" id="7044934e"/>
//   <storage_hard_limit_pct>0</storage_hard_limit_pct>
//   <storage_soft_limit_pct>0</storage_soft_limit_pct>
// </quota>
// ----
func (p *ExternalTemplateImport) SetQuota(attr *Quota) {
	p.quota = attr
}

// Quota Represents a quota object.
//
// An example XML representation of a quota:
//
// [source,xml]
// ----
// <quota href="/ovirt-engine/api/datacenters/7044934e/quotas/dcad5ddc" id="dcad5ddc">
//   <name>My Quota</name>
//   <description>A quota for my oVirt environment</description>
//   <cluster_hard_limit_pct>0</cluster_hard_limit_pct>
//   <cluster_soft_limit_pct>0</cluster_soft_limit_pct>
//   <data_center href="/ovirt-engine/api/datacenters/7044934e" id="7044934e"/>
//   <storage_hard_limit_pct>0</storage_hard_limit_pct>
//   <storage_soft_limit_pct>0</storage_soft_limit_pct>
// </quota>
// ----
func (p *ExternalTemplateImport) Quota() (*Quota, bool) {
	if p.quota != nil {
		return p.quota, true
	}
	return nil, false
}

// MustQuota Represents a quota object.
//
// An example XML representation of a quota:
//
// [source,xml]
// ----
// <quota href="/ovirt-engine/api/datacenters/7044934e/quotas/dcad5ddc" id="dcad5ddc">
//   <name>My Quota</name>
//   <description>A quota for my oVirt environment</description>
//   <cluster_hard_limit_pct>0</cluster_hard_limit_pct>
//   <cluster_soft_limit_pct>0</cluster_soft_limit_pct>
//   <data_center href="/ovirt-engine/api/datacenters/7044934e" id="7044934e"/>
//   <storage_hard_limit_pct>0</storage_hard_limit_pct>
//   <storage_soft_limit_pct>0</storage_soft_limit_pct>
// </quota>
// ----
func (p *ExternalTemplateImport) MustQuota() *Quota {
	if p.quota == nil {
		panic("the quota must not be nil, please use Quota() function instead")
	}
	return p.quota
}

// SetStorageDomain Storage domain.
//
// An XML representation of a NFS storage domain with identifier `123`:
//
// [source,xml]
// ----
// <storage_domain href="/ovirt-engine/api/storagedomains/123" id="123">
//   <name>mydata</name>
//   <description>My data</description>
//   <available>38654705664</available>
//   <committed>1073741824</committed>
//   <critical_space_action_blocker>5</critical_space_action_blocker>
//   <external_status>ok</external_status>
//   <master>true</master>
//   <storage>
//     <address>mynfs.example.com</address>
//     <nfs_version>v3</nfs_version>
//     <path>/exports/mydata</path>
//     <type>nfs</type>
//   </storage>
//   <storage_format>v3</storage_format>
//   <type>data</type>
//   <used>13958643712</used>
//   <warning_low_space_indicator>10</warning_low_space_indicator>
//   <wipe_after_delete>false</wipe_after_delete>
//   <data_centers>
//     <data_center href="/ovirt-engine/api/datacenters/456" id="456"/>
//   </data_centers>
// </storage_domain>
// ----
func (p *ExternalTemplateImport) SetStorageDomain(attr *StorageDomain) {
	p.storageDomain = attr
}

// StorageDomain Storage domain.
//
// An XML representation of a NFS storage domain with identifier `123`:
//
// [source,xml]
// ----
// <storage_domain href="/ovirt-engine/api/storagedomains/123" id="123">
//   <name>mydata</name>
//   <description>My data</description>
//   <available>38654705664</available>
//   <committed>1073741824</committed>
//   <critical_space_action_blocker>5</critical_space_action_blocker>
//   <external_status>ok</external_status>
//   <master>true</master>
//   <storage>
//     <address>mynfs.example.com</address>
//     <nfs_version>v3</nfs_version>
//     <path>/exports/mydata</path>
//     <type>nfs</type>
//   </storage>
//   <storage_format>v3</storage_format>
//   <type>data</type>
//   <used>13958643712</used>
//   <warning_low_space_indicator>10</warning_low_space_indicator>
//   <wipe_after_delete>false</wipe_after_delete>
//   <data_centers>
//     <data_center href="/ovirt-engine/api/datacenters/456" id="456"/>
//   </data_centers>
// </storage_domain>
// ----
func (p *ExternalTemplateImport) StorageDomain() (*StorageDomain, bool) {
	if p.storageDomain != nil {
		return p.storageDomain, true
	}
	return nil, false
}

// MustStorageDomain Storage domain.
//
// An XML representation of a NFS storage domain with identifier `123`:
//
// [source,xml]
// ----
// <storage_domain href="/ovirt-engine/api/storagedomains/123" id="123">
//   <name>mydata</name>
//   <description>My data</description>
//   <available>38654705664</available>
//   <committed>1073741824</committed>
//   <critical_space_action_blocker>5</critical_space_action_blocker>
//   <external_status>ok</external_status>
//   <master>true</master>
//   <storage>
//     <address>mynfs.example.com</address>
//     <nfs_version>v3</nfs_version>
//     <path>/exports/mydata</path>
//     <type>nfs</type>
//   </storage>
//   <storage_format>v3</storage_format>
//   <type>data</type>
//   <used>13958643712</used>
//   <warning_low_space_indicator>10</warning_low_space_indicator>
//   <wipe_after_delete>false</wipe_after_delete>
//   <data_centers>
//     <data_center href="/ovirt-engine/api/datacenters/456" id="456"/>
//   </data_centers>
// </storage_domain>
// ----
func (p *ExternalTemplateImport) MustStorageDomain() *StorageDomain {
	if p.storageDomain == nil {
		panic("the storageDomain must not be nil, please use StorageDomain() function instead")
	}
	return p.storageDomain
}

// SetTemplate The type that represents a virtual machine template.
// Templates allow for a rapid instantiation of virtual machines with common configuration and disk states.
func (p *ExternalTemplateImport) SetTemplate(attr *Template) {
	p.template = attr
}

// Template The type that represents a virtual machine template.
// Templates allow for a rapid instantiation of virtual machines with common configuration and disk states.
func (p *ExternalTemplateImport) Template() (*Template, bool) {
	if p.template != nil {
		return p.template, true
	}
	return nil, false
}

// MustTemplate The type that represents a virtual machine template.
// Templates allow for a rapid instantiation of virtual machines with common configuration and disk states.
func (p *ExternalTemplateImport) MustTemplate() *Template {
	if p.template == nil {
		panic("the template must not be nil, please use Template() function instead")
	}
	return p.template
}

func (p *ExternalTemplateImport) SetUrl(attr string) {
	p.url = &attr
}

func (p *ExternalTemplateImport) Url() (string, bool) {
	if p.url != nil {
		return *p.url, true
	}
	var zero string
	return zero, false
}

func (p *ExternalTemplateImport) MustUrl() string {
	if p.url == nil {
		panic("the url must not be nil, please use Url() function instead")
	}
	return *p.url
}

// ExternalVmImport Describes the parameters for the virtual machine import operation from an external system.
type ExternalVmImport struct {
	Struct
	cluster       *Cluster
	cpuProfile    *CpuProfile
	driversIso    *File
	host          *Host
	name          *string
	password      *string
	provider      *ExternalVmProviderType
	quota         *Quota
	sparse        *bool
	storageDomain *StorageDomain
	url           *string
	username      *string
	vm            *Vm
}

// SetCluster Type representation of a cluster.
//
// A JSON representation of a cluster:
//
// [source]
// ----
// {
//   "cluster" : [ {
//     "ballooning_enabled" : "false",
//     "cpu" : {
//       "architecture" : "x86_64",
//       "type" : "Intel SandyBridge Family"
//     },
//     "custom_scheduling_policy_properties" : {
//       "property" : [ {
//         "name" : "HighUtilization",
//         "value" : "80"
//       }, {
//         "name" : "CpuOverCommitDurationMinutes",
//         "value" : "2"
//       } ]
//     },
//     "error_handling" : {
//       "on_error" : "migrate"
//     },
//     "fencing_policy" : {
//       "enabled" : "true",
//       "skip_if_connectivity_broken" : {
//         "enabled" : "false",
//         "threshold" : "50"
//       },
//       "skip_if_gluster_bricks_up" : "false",
//       "skip_if_gluster_quorum_not_met" : "false",
//       "skip_if_sd_active" : {
//         "enabled" : "false"
//       }
//     },
//     "gluster_service" : "false",
//     "firewall_type" : "iptables",
//     "ha_reservation" : "false",
//     "ksm" : {
//       "enabled" : "true",
//       "merge_across_nodes" : "true"
//     },
//     "memory_policy" : {
//       "over_commit" : {
//         "percent" : "100"
//       },
//       "transparent_hugepages" : {
//         "enabled" : "true"
//       }
//     },
//     "migration" : {
//       "auto_converge" : "inherit",
//       "bandwidth" : {
//         "assignment_method" : "auto"
//       },
//       "compressed" : "inherit",
//       "policy" : {
//         "id" : "00000000-0000-0000-0000-000000000000"
//       }
//     },
//     "required_rng_sources" : {
//       "required_rng_source" : [ "random" ]
//     },
//     "switch_type" : "legacy",
//     "threads_as_cores" : "false",
//     "trusted_service" : "false",
//     "tunnel_migration" : "false",
//     "version" : {
//       "major" : "4",
//       "minor" : "1"
//     },
//     "virt_service" : "true",
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "mac_pool" : {
//       "href" : "/ovirt-engine/api/macpools/456",
//       "id" : "456"
//     },
//     "scheduling_policy" : {
//       "href" : "/ovirt-engine/api/schedulingpolicies/789",
//       "id" : "789"
//     },
//     "actions" : {
//       "link" : [ {
//         "href" : "/ovirt-engine/api/clusters/234/resetemulatedmachine",
//         "rel" : "resetemulatedmachine"
//       } ]
//     },
//     "name" : "Default",
//     "description" : "The default server cluster",
//     "href" : "/ovirt-engine/api/clusters/234",
//     "id" : "234",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/clusters/234/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/cpuprofiles",
//       "rel" : "cpuprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networkfilters",
//       "rel" : "networkfilters"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networks",
//       "rel" : "networks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/affinitygroups",
//       "rel" : "affinitygroups"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glusterhooks",
//       "rel" : "glusterhooks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glustervolumes",
//       "rel" : "glustervolumes"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/enabledfeatures",
//       "rel" : "enabledfeatures"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/externalnetworkproviders",
//       "rel" : "externalnetworkproviders"
//     } ]
//   } ]
// }
// ----
func (p *ExternalVmImport) SetCluster(attr *Cluster) {
	p.cluster = attr
}

// Cluster Type representation of a cluster.
//
// A JSON representation of a cluster:
//
// [source]
// ----
// {
//   "cluster" : [ {
//     "ballooning_enabled" : "false",
//     "cpu" : {
//       "architecture" : "x86_64",
//       "type" : "Intel SandyBridge Family"
//     },
//     "custom_scheduling_policy_properties" : {
//       "property" : [ {
//         "name" : "HighUtilization",
//         "value" : "80"
//       }, {
//         "name" : "CpuOverCommitDurationMinutes",
//         "value" : "2"
//       } ]
//     },
//     "error_handling" : {
//       "on_error" : "migrate"
//     },
//     "fencing_policy" : {
//       "enabled" : "true",
//       "skip_if_connectivity_broken" : {
//         "enabled" : "false",
//         "threshold" : "50"
//       },
//       "skip_if_gluster_bricks_up" : "false",
//       "skip_if_gluster_quorum_not_met" : "false",
//       "skip_if_sd_active" : {
//         "enabled" : "false"
//       }
//     },
//     "gluster_service" : "false",
//     "firewall_type" : "iptables",
//     "ha_reservation" : "false",
//     "ksm" : {
//       "enabled" : "true",
//       "merge_across_nodes" : "true"
//     },
//     "memory_policy" : {
//       "over_commit" : {
//         "percent" : "100"
//       },
//       "transparent_hugepages" : {
//         "enabled" : "true"
//       }
//     },
//     "migration" : {
//       "auto_converge" : "inherit",
//       "bandwidth" : {
//         "assignment_method" : "auto"
//       },
//       "compressed" : "inherit",
//       "policy" : {
//         "id" : "00000000-0000-0000-0000-000000000000"
//       }
//     },
//     "required_rng_sources" : {
//       "required_rng_source" : [ "random" ]
//     },
//     "switch_type" : "legacy",
//     "threads_as_cores" : "false",
//     "trusted_service" : "false",
//     "tunnel_migration" : "false",
//     "version" : {
//       "major" : "4",
//       "minor" : "1"
//     },
//     "virt_service" : "true",
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "mac_pool" : {
//       "href" : "/ovirt-engine/api/macpools/456",
//       "id" : "456"
//     },
//     "scheduling_policy" : {
//       "href" : "/ovirt-engine/api/schedulingpolicies/789",
//       "id" : "789"
//     },
//     "actions" : {
//       "link" : [ {
//         "href" : "/ovirt-engine/api/clusters/234/resetemulatedmachine",
//         "rel" : "resetemulatedmachine"
//       } ]
//     },
//     "name" : "Default",
//     "description" : "The default server cluster",
//     "href" : "/ovirt-engine/api/clusters/234",
//     "id" : "234",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/clusters/234/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/cpuprofiles",
//       "rel" : "cpuprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networkfilters",
//       "rel" : "networkfilters"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networks",
//       "rel" : "networks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/affinitygroups",
//       "rel" : "affinitygroups"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glusterhooks",
//       "rel" : "glusterhooks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glustervolumes",
//       "rel" : "glustervolumes"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/enabledfeatures",
//       "rel" : "enabledfeatures"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/externalnetworkproviders",
//       "rel" : "externalnetworkproviders"
//     } ]
//   } ]
// }
// ----
func (p *ExternalVmImport) Cluster() (*Cluster, bool) {
	if p.cluster != nil {
		return p.cluster, true
	}
	return nil, false
}

// MustCluster Type representation of a cluster.
//
// A JSON representation of a cluster:
//
// [source]
// ----
// {
//   "cluster" : [ {
//     "ballooning_enabled" : "false",
//     "cpu" : {
//       "architecture" : "x86_64",
//       "type" : "Intel SandyBridge Family"
//     },
//     "custom_scheduling_policy_properties" : {
//       "property" : [ {
//         "name" : "HighUtilization",
//         "value" : "80"
//       }, {
//         "name" : "CpuOverCommitDurationMinutes",
//         "value" : "2"
//       } ]
//     },
//     "error_handling" : {
//       "on_error" : "migrate"
//     },
//     "fencing_policy" : {
//       "enabled" : "true",
//       "skip_if_connectivity_broken" : {
//         "enabled" : "false",
//         "threshold" : "50"
//       },
//       "skip_if_gluster_bricks_up" : "false",
//       "skip_if_gluster_quorum_not_met" : "false",
//       "skip_if_sd_active" : {
//         "enabled" : "false"
//       }
//     },
//     "gluster_service" : "false",
//     "firewall_type" : "iptables",
//     "ha_reservation" : "false",
//     "ksm" : {
//       "enabled" : "true",
//       "merge_across_nodes" : "true"
//     },
//     "memory_policy" : {
//       "over_commit" : {
//         "percent" : "100"
//       },
//       "transparent_hugepages" : {
//         "enabled" : "true"
//       }
//     },
//     "migration" : {
//       "auto_converge" : "inherit",
//       "bandwidth" : {
//         "assignment_method" : "auto"
//       },
//       "compressed" : "inherit",
//       "policy" : {
//         "id" : "00000000-0000-0000-0000-000000000000"
//       }
//     },
//     "required_rng_sources" : {
//       "required_rng_source" : [ "random" ]
//     },
//     "switch_type" : "legacy",
//     "threads_as_cores" : "false",
//     "trusted_service" : "false",
//     "tunnel_migration" : "false",
//     "version" : {
//       "major" : "4",
//       "minor" : "1"
//     },
//     "virt_service" : "true",
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "mac_pool" : {
//       "href" : "/ovirt-engine/api/macpools/456",
//       "id" : "456"
//     },
//     "scheduling_policy" : {
//       "href" : "/ovirt-engine/api/schedulingpolicies/789",
//       "id" : "789"
//     },
//     "actions" : {
//       "link" : [ {
//         "href" : "/ovirt-engine/api/clusters/234/resetemulatedmachine",
//         "rel" : "resetemulatedmachine"
//       } ]
//     },
//     "name" : "Default",
//     "description" : "The default server cluster",
//     "href" : "/ovirt-engine/api/clusters/234",
//     "id" : "234",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/clusters/234/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/cpuprofiles",
//       "rel" : "cpuprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networkfilters",
//       "rel" : "networkfilters"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networks",
//       "rel" : "networks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/affinitygroups",
//       "rel" : "affinitygroups"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glusterhooks",
//       "rel" : "glusterhooks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glustervolumes",
//       "rel" : "glustervolumes"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/enabledfeatures",
//       "rel" : "enabledfeatures"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/externalnetworkproviders",
//       "rel" : "externalnetworkproviders"
//     } ]
//   } ]
// }
// ----
func (p *ExternalVmImport) MustCluster() *Cluster {
	if p.cluster == nil {
		panic("the cluster must not be nil, please use Cluster() function instead")
	}
	return p.cluster
}

func (p *ExternalVmImport) SetCpuProfile(attr *CpuProfile) {
	p.cpuProfile = attr
}

func (p *ExternalVmImport) CpuProfile() (*CpuProfile, bool) {
	if p.cpuProfile != nil {
		return p.cpuProfile, true
	}
	return nil, false
}

func (p *ExternalVmImport) MustCpuProfile() *CpuProfile {
	if p.cpuProfile == nil {
		panic("the cpuProfile must not be nil, please use CpuProfile() function instead")
	}
	return p.cpuProfile
}

func (p *ExternalVmImport) SetDriversIso(attr *File) {
	p.driversIso = attr
}

func (p *ExternalVmImport) DriversIso() (*File, bool) {
	if p.driversIso != nil {
		return p.driversIso, true
	}
	return nil, false
}

func (p *ExternalVmImport) MustDriversIso() *File {
	if p.driversIso == nil {
		panic("the driversIso must not be nil, please use DriversIso() function instead")
	}
	return p.driversIso
}

// SetHost Type representing a host.
func (p *ExternalVmImport) SetHost(attr *Host) {
	p.host = attr
}

// Host Type representing a host.
func (p *ExternalVmImport) Host() (*Host, bool) {
	if p.host != nil {
		return p.host, true
	}
	return nil, false
}

// MustHost Type representing a host.
func (p *ExternalVmImport) MustHost() *Host {
	if p.host == nil {
		panic("the host must not be nil, please use Host() function instead")
	}
	return p.host
}

func (p *ExternalVmImport) SetName(attr string) {
	p.name = &attr
}

func (p *ExternalVmImport) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *ExternalVmImport) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *ExternalVmImport) SetPassword(attr string) {
	p.password = &attr
}

func (p *ExternalVmImport) Password() (string, bool) {
	if p.password != nil {
		return *p.password, true
	}
	var zero string
	return zero, false
}

func (p *ExternalVmImport) MustPassword() string {
	if p.password == nil {
		panic("the password must not be nil, please use Password() function instead")
	}
	return *p.password
}

// SetProvider Describes the type of external hypervisor system.
func (p *ExternalVmImport) SetProvider(attr ExternalVmProviderType) {
	p.provider = &attr
}

// Provider Describes the type of external hypervisor system.
func (p *ExternalVmImport) Provider() (ExternalVmProviderType, bool) {
	if p.provider != nil {
		return *p.provider, true
	}
	var zero ExternalVmProviderType
	return zero, false
}

// MustProvider Describes the type of external hypervisor system.
func (p *ExternalVmImport) MustProvider() ExternalVmProviderType {
	if p.provider == nil {
		panic("the provider must not be nil, please use Provider() function instead")
	}
	return *p.provider
}

// SetQuota Represents a quota object.
//
// An example XML representation of a quota:
//
// [source,xml]
// ----
// <quota href="/ovirt-engine/api/datacenters/7044934e/quotas/dcad5ddc" id="dcad5ddc">
//   <name>My Quota</name>
//   <description>A quota for my oVirt environment</description>
//   <cluster_hard_limit_pct>0</cluster_hard_limit_pct>
//   <cluster_soft_limit_pct>0</cluster_soft_limit_pct>
//   <data_center href="/ovirt-engine/api/datacenters/7044934e" id="7044934e"/>
//   <storage_hard_limit_pct>0</storage_hard_limit_pct>
//   <storage_soft_limit_pct>0</storage_soft_limit_pct>
// </quota>
// ----
func (p *ExternalVmImport) SetQuota(attr *Quota) {
	p.quota = attr
}

// Quota Represents a quota object.
//
// An example XML representation of a quota:
//
// [source,xml]
// ----
// <quota href="/ovirt-engine/api/datacenters/7044934e/quotas/dcad5ddc" id="dcad5ddc">
//   <name>My Quota</name>
//   <description>A quota for my oVirt environment</description>
//   <cluster_hard_limit_pct>0</cluster_hard_limit_pct>
//   <cluster_soft_limit_pct>0</cluster_soft_limit_pct>
//   <data_center href="/ovirt-engine/api/datacenters/7044934e" id="7044934e"/>
//   <storage_hard_limit_pct>0</storage_hard_limit_pct>
//   <storage_soft_limit_pct>0</storage_soft_limit_pct>
// </quota>
// ----
func (p *ExternalVmImport) Quota() (*Quota, bool) {
	if p.quota != nil {
		return p.quota, true
	}
	return nil, false
}

// MustQuota Represents a quota object.
//
// An example XML representation of a quota:
//
// [source,xml]
// ----
// <quota href="/ovirt-engine/api/datacenters/7044934e/quotas/dcad5ddc" id="dcad5ddc">
//   <name>My Quota</name>
//   <description>A quota for my oVirt environment</description>
//   <cluster_hard_limit_pct>0</cluster_hard_limit_pct>
//   <cluster_soft_limit_pct>0</cluster_soft_limit_pct>
//   <data_center href="/ovirt-engine/api/datacenters/7044934e" id="7044934e"/>
//   <storage_hard_limit_pct>0</storage_hard_limit_pct>
//   <storage_soft_limit_pct>0</storage_soft_limit_pct>
// </quota>
// ----
func (p *ExternalVmImport) MustQuota() *Quota {
	if p.quota == nil {
		panic("the quota must not be nil, please use Quota() function instead")
	}
	return p.quota
}

func (p *ExternalVmImport) SetSparse(attr bool) {
	p.sparse = &attr
}

func (p *ExternalVmImport) Sparse() (bool, bool) {
	if p.sparse != nil {
		return *p.sparse, true
	}
	var zero bool
	return zero, false
}

func (p *ExternalVmImport) MustSparse() bool {
	if p.sparse == nil {
		panic("the sparse must not be nil, please use Sparse() function instead")
	}
	return *p.sparse
}

// SetStorageDomain Storage domain.
//
// An XML representation of a NFS storage domain with identifier `123`:
//
// [source,xml]
// ----
// <storage_domain href="/ovirt-engine/api/storagedomains/123" id="123">
//   <name>mydata</name>
//   <description>My data</description>
//   <available>38654705664</available>
//   <committed>1073741824</committed>
//   <critical_space_action_blocker>5</critical_space_action_blocker>
//   <external_status>ok</external_status>
//   <master>true</master>
//   <storage>
//     <address>mynfs.example.com</address>
//     <nfs_version>v3</nfs_version>
//     <path>/exports/mydata</path>
//     <type>nfs</type>
//   </storage>
//   <storage_format>v3</storage_format>
//   <type>data</type>
//   <used>13958643712</used>
//   <warning_low_space_indicator>10</warning_low_space_indicator>
//   <wipe_after_delete>false</wipe_after_delete>
//   <data_centers>
//     <data_center href="/ovirt-engine/api/datacenters/456" id="456"/>
//   </data_centers>
// </storage_domain>
// ----
func (p *ExternalVmImport) SetStorageDomain(attr *StorageDomain) {
	p.storageDomain = attr
}

// StorageDomain Storage domain.
//
// An XML representation of a NFS storage domain with identifier `123`:
//
// [source,xml]
// ----
// <storage_domain href="/ovirt-engine/api/storagedomains/123" id="123">
//   <name>mydata</name>
//   <description>My data</description>
//   <available>38654705664</available>
//   <committed>1073741824</committed>
//   <critical_space_action_blocker>5</critical_space_action_blocker>
//   <external_status>ok</external_status>
//   <master>true</master>
//   <storage>
//     <address>mynfs.example.com</address>
//     <nfs_version>v3</nfs_version>
//     <path>/exports/mydata</path>
//     <type>nfs</type>
//   </storage>
//   <storage_format>v3</storage_format>
//   <type>data</type>
//   <used>13958643712</used>
//   <warning_low_space_indicator>10</warning_low_space_indicator>
//   <wipe_after_delete>false</wipe_after_delete>
//   <data_centers>
//     <data_center href="/ovirt-engine/api/datacenters/456" id="456"/>
//   </data_centers>
// </storage_domain>
// ----
func (p *ExternalVmImport) StorageDomain() (*StorageDomain, bool) {
	if p.storageDomain != nil {
		return p.storageDomain, true
	}
	return nil, false
}

// MustStorageDomain Storage domain.
//
// An XML representation of a NFS storage domain with identifier `123`:
//
// [source,xml]
// ----
// <storage_domain href="/ovirt-engine/api/storagedomains/123" id="123">
//   <name>mydata</name>
//   <description>My data</description>
//   <available>38654705664</available>
//   <committed>1073741824</committed>
//   <critical_space_action_blocker>5</critical_space_action_blocker>
//   <external_status>ok</external_status>
//   <master>true</master>
//   <storage>
//     <address>mynfs.example.com</address>
//     <nfs_version>v3</nfs_version>
//     <path>/exports/mydata</path>
//     <type>nfs</type>
//   </storage>
//   <storage_format>v3</storage_format>
//   <type>data</type>
//   <used>13958643712</used>
//   <warning_low_space_indicator>10</warning_low_space_indicator>
//   <wipe_after_delete>false</wipe_after_delete>
//   <data_centers>
//     <data_center href="/ovirt-engine/api/datacenters/456" id="456"/>
//   </data_centers>
// </storage_domain>
// ----
func (p *ExternalVmImport) MustStorageDomain() *StorageDomain {
	if p.storageDomain == nil {
		panic("the storageDomain must not be nil, please use StorageDomain() function instead")
	}
	return p.storageDomain
}

func (p *ExternalVmImport) SetUrl(attr string) {
	p.url = &attr
}

func (p *ExternalVmImport) Url() (string, bool) {
	if p.url != nil {
		return *p.url, true
	}
	var zero string
	return zero, false
}

func (p *ExternalVmImport) MustUrl() string {
	if p.url == nil {
		panic("the url must not be nil, please use Url() function instead")
	}
	return *p.url
}

func (p *ExternalVmImport) SetUsername(attr string) {
	p.username = &attr
}

func (p *ExternalVmImport) Username() (string, bool) {
	if p.username != nil {
		return *p.username, true
	}
	var zero string
	return zero, false
}

func (p *ExternalVmImport) MustUsername() string {
	if p.username == nil {
		panic("the username must not be nil, please use Username() function instead")
	}
	return *p.username
}

// SetVm Represents a virtual machine.
func (p *ExternalVmImport) SetVm(attr *Vm) {
	p.vm = attr
}

// Vm Represents a virtual machine.
func (p *ExternalVmImport) Vm() (*Vm, bool) {
	if p.vm != nil {
		return p.vm, true
	}
	return nil, false
}

// MustVm Represents a virtual machine.
func (p *ExternalVmImport) MustVm() *Vm {
	if p.vm == nil {
		panic("the vm must not be nil, please use Vm() function instead")
	}
	return p.vm
}

// FencingPolicy Type representing a cluster fencing policy.
type FencingPolicy struct {
	Struct
	enabled                   *bool
	skipIfConnectivityBroken  *SkipIfConnectivityBroken
	skipIfGlusterBricksUp     *bool
	skipIfGlusterQuorumNotMet *bool
	skipIfSdActive            *SkipIfSdActive
}

func (p *FencingPolicy) SetEnabled(attr bool) {
	p.enabled = &attr
}

func (p *FencingPolicy) Enabled() (bool, bool) {
	if p.enabled != nil {
		return *p.enabled, true
	}
	var zero bool
	return zero, false
}

func (p *FencingPolicy) MustEnabled() bool {
	if p.enabled == nil {
		panic("the enabled must not be nil, please use Enabled() function instead")
	}
	return *p.enabled
}

func (p *FencingPolicy) SetSkipIfConnectivityBroken(attr *SkipIfConnectivityBroken) {
	p.skipIfConnectivityBroken = attr
}

func (p *FencingPolicy) SkipIfConnectivityBroken() (*SkipIfConnectivityBroken, bool) {
	if p.skipIfConnectivityBroken != nil {
		return p.skipIfConnectivityBroken, true
	}
	return nil, false
}

func (p *FencingPolicy) MustSkipIfConnectivityBroken() *SkipIfConnectivityBroken {
	if p.skipIfConnectivityBroken == nil {
		panic("the skipIfConnectivityBroken must not be nil, please use SkipIfConnectivityBroken() function instead")
	}
	return p.skipIfConnectivityBroken
}

func (p *FencingPolicy) SetSkipIfGlusterBricksUp(attr bool) {
	p.skipIfGlusterBricksUp = &attr
}

func (p *FencingPolicy) SkipIfGlusterBricksUp() (bool, bool) {
	if p.skipIfGlusterBricksUp != nil {
		return *p.skipIfGlusterBricksUp, true
	}
	var zero bool
	return zero, false
}

func (p *FencingPolicy) MustSkipIfGlusterBricksUp() bool {
	if p.skipIfGlusterBricksUp == nil {
		panic("the skipIfGlusterBricksUp must not be nil, please use SkipIfGlusterBricksUp() function instead")
	}
	return *p.skipIfGlusterBricksUp
}

func (p *FencingPolicy) SetSkipIfGlusterQuorumNotMet(attr bool) {
	p.skipIfGlusterQuorumNotMet = &attr
}

func (p *FencingPolicy) SkipIfGlusterQuorumNotMet() (bool, bool) {
	if p.skipIfGlusterQuorumNotMet != nil {
		return *p.skipIfGlusterQuorumNotMet, true
	}
	var zero bool
	return zero, false
}

func (p *FencingPolicy) MustSkipIfGlusterQuorumNotMet() bool {
	if p.skipIfGlusterQuorumNotMet == nil {
		panic("the skipIfGlusterQuorumNotMet must not be nil, please use SkipIfGlusterQuorumNotMet() function instead")
	}
	return *p.skipIfGlusterQuorumNotMet
}

// SetSkipIfSdActive This type represents the storage related
// configuration in the fencing policy.
func (p *FencingPolicy) SetSkipIfSdActive(attr *SkipIfSdActive) {
	p.skipIfSdActive = attr
}

// SkipIfSdActive This type represents the storage related
// configuration in the fencing policy.
func (p *FencingPolicy) SkipIfSdActive() (*SkipIfSdActive, bool) {
	if p.skipIfSdActive != nil {
		return p.skipIfSdActive, true
	}
	return nil, false
}

// MustSkipIfSdActive This type represents the storage related
// configuration in the fencing policy.
func (p *FencingPolicy) MustSkipIfSdActive() *SkipIfSdActive {
	if p.skipIfSdActive == nil {
		panic("the skipIfSdActive must not be nil, please use SkipIfSdActive() function instead")
	}
	return p.skipIfSdActive
}

type File struct {
	Struct
	comment       *string
	content       *string
	description   *string
	id            *string
	name          *string
	storageDomain *StorageDomain
	type_         *string
}

func (p *File) SetComment(attr string) {
	p.comment = &attr
}

func (p *File) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *File) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *File) SetContent(attr string) {
	p.content = &attr
}

func (p *File) Content() (string, bool) {
	if p.content != nil {
		return *p.content, true
	}
	var zero string
	return zero, false
}

func (p *File) MustContent() string {
	if p.content == nil {
		panic("the content must not be nil, please use Content() function instead")
	}
	return *p.content
}

func (p *File) SetDescription(attr string) {
	p.description = &attr
}

func (p *File) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *File) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *File) SetId(attr string) {
	p.id = &attr
}

func (p *File) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *File) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *File) SetName(attr string) {
	p.name = &attr
}

func (p *File) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *File) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

// SetStorageDomain Storage domain.
//
// An XML representation of a NFS storage domain with identifier `123`:
//
// [source,xml]
// ----
// <storage_domain href="/ovirt-engine/api/storagedomains/123" id="123">
//   <name>mydata</name>
//   <description>My data</description>
//   <available>38654705664</available>
//   <committed>1073741824</committed>
//   <critical_space_action_blocker>5</critical_space_action_blocker>
//   <external_status>ok</external_status>
//   <master>true</master>
//   <storage>
//     <address>mynfs.example.com</address>
//     <nfs_version>v3</nfs_version>
//     <path>/exports/mydata</path>
//     <type>nfs</type>
//   </storage>
//   <storage_format>v3</storage_format>
//   <type>data</type>
//   <used>13958643712</used>
//   <warning_low_space_indicator>10</warning_low_space_indicator>
//   <wipe_after_delete>false</wipe_after_delete>
//   <data_centers>
//     <data_center href="/ovirt-engine/api/datacenters/456" id="456"/>
//   </data_centers>
// </storage_domain>
// ----
func (p *File) SetStorageDomain(attr *StorageDomain) {
	p.storageDomain = attr
}

// StorageDomain Storage domain.
//
// An XML representation of a NFS storage domain with identifier `123`:
//
// [source,xml]
// ----
// <storage_domain href="/ovirt-engine/api/storagedomains/123" id="123">
//   <name>mydata</name>
//   <description>My data</description>
//   <available>38654705664</available>
//   <committed>1073741824</committed>
//   <critical_space_action_blocker>5</critical_space_action_blocker>
//   <external_status>ok</external_status>
//   <master>true</master>
//   <storage>
//     <address>mynfs.example.com</address>
//     <nfs_version>v3</nfs_version>
//     <path>/exports/mydata</path>
//     <type>nfs</type>
//   </storage>
//   <storage_format>v3</storage_format>
//   <type>data</type>
//   <used>13958643712</used>
//   <warning_low_space_indicator>10</warning_low_space_indicator>
//   <wipe_after_delete>false</wipe_after_delete>
//   <data_centers>
//     <data_center href="/ovirt-engine/api/datacenters/456" id="456"/>
//   </data_centers>
// </storage_domain>
// ----
func (p *File) StorageDomain() (*StorageDomain, bool) {
	if p.storageDomain != nil {
		return p.storageDomain, true
	}
	return nil, false
}

// MustStorageDomain Storage domain.
//
// An XML representation of a NFS storage domain with identifier `123`:
//
// [source,xml]
// ----
// <storage_domain href="/ovirt-engine/api/storagedomains/123" id="123">
//   <name>mydata</name>
//   <description>My data</description>
//   <available>38654705664</available>
//   <committed>1073741824</committed>
//   <critical_space_action_blocker>5</critical_space_action_blocker>
//   <external_status>ok</external_status>
//   <master>true</master>
//   <storage>
//     <address>mynfs.example.com</address>
//     <nfs_version>v3</nfs_version>
//     <path>/exports/mydata</path>
//     <type>nfs</type>
//   </storage>
//   <storage_format>v3</storage_format>
//   <type>data</type>
//   <used>13958643712</used>
//   <warning_low_space_indicator>10</warning_low_space_indicator>
//   <wipe_after_delete>false</wipe_after_delete>
//   <data_centers>
//     <data_center href="/ovirt-engine/api/datacenters/456" id="456"/>
//   </data_centers>
// </storage_domain>
// ----
func (p *File) MustStorageDomain() *StorageDomain {
	if p.storageDomain == nil {
		panic("the storageDomain must not be nil, please use StorageDomain() function instead")
	}
	return p.storageDomain
}

func (p *File) SetType(attr string) {
	p.type_ = &attr
}

func (p *File) Type() (string, bool) {
	if p.type_ != nil {
		return *p.type_, true
	}
	var zero string
	return zero, false
}

func (p *File) MustType() string {
	if p.type_ == nil {
		panic("the type_ must not be nil, please use Type() function instead")
	}
	return *p.type_
}

type Filter struct {
	Struct
	comment              *string
	description          *string
	id                   *string
	name                 *string
	position             *int64
	schedulingPolicyUnit *SchedulingPolicyUnit
}

func (p *Filter) SetComment(attr string) {
	p.comment = &attr
}

func (p *Filter) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *Filter) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *Filter) SetDescription(attr string) {
	p.description = &attr
}

func (p *Filter) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *Filter) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *Filter) SetId(attr string) {
	p.id = &attr
}

func (p *Filter) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *Filter) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *Filter) SetName(attr string) {
	p.name = &attr
}

func (p *Filter) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *Filter) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *Filter) SetPosition(attr int64) {
	p.position = &attr
}

func (p *Filter) Position() (int64, bool) {
	if p.position != nil {
		return *p.position, true
	}
	var zero int64
	return zero, false
}

func (p *Filter) MustPosition() int64 {
	if p.position == nil {
		panic("the position must not be nil, please use Position() function instead")
	}
	return *p.position
}

func (p *Filter) SetSchedulingPolicyUnit(attr *SchedulingPolicyUnit) {
	p.schedulingPolicyUnit = attr
}

func (p *Filter) SchedulingPolicyUnit() (*SchedulingPolicyUnit, bool) {
	if p.schedulingPolicyUnit != nil {
		return p.schedulingPolicyUnit, true
	}
	return nil, false
}

func (p *Filter) MustSchedulingPolicyUnit() *SchedulingPolicyUnit {
	if p.schedulingPolicyUnit == nil {
		panic("the schedulingPolicyUnit must not be nil, please use SchedulingPolicyUnit() function instead")
	}
	return p.schedulingPolicyUnit
}

// Floppy The underlying representation of a floppy file.
type Floppy struct {
	Struct
	comment      *string
	description  *string
	file         *File
	id           *string
	instanceType *InstanceType
	name         *string
	template     *Template
	vm           *Vm
	vms          *VmSlice
}

func (p *Floppy) SetComment(attr string) {
	p.comment = &attr
}

func (p *Floppy) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *Floppy) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *Floppy) SetDescription(attr string) {
	p.description = &attr
}

func (p *Floppy) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *Floppy) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *Floppy) SetFile(attr *File) {
	p.file = attr
}

func (p *Floppy) File() (*File, bool) {
	if p.file != nil {
		return p.file, true
	}
	return nil, false
}

func (p *Floppy) MustFile() *File {
	if p.file == nil {
		panic("the file must not be nil, please use File() function instead")
	}
	return p.file
}

func (p *Floppy) SetId(attr string) {
	p.id = &attr
}

func (p *Floppy) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *Floppy) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

// SetInstanceType Describes the hardware configuration of virtual machines.
//
// For example `medium` instance type includes 1 virtual CPU and 4 GiB of memory. It is a top-level
// entity (e.g. not bound to any data center or cluster). The attributes that are used for instance
// types and are common to virtual machine and template types are:
//
// - `console`
// - `cpu`
// - `custom_cpu_model`
// - `custom_emulated_machine`
// - `display`
// - `high_availability`
// - `io`
// - `memory`
// - `memory_policy`
// - `migration`
// - `migration_downtime`
// - `os`
// - `rng_device`
// - `soundcard_enabled`
// - `usb`
// - `virtio_scsi`
//
// When creating a virtual machine from both an instance type and a template, the virtual machine
// will inherit the hardware configurations from the instance type
//
// NOTE: An instance type inherits it's attributes from the template entity although most template
// attributes are not used in instance types.
func (p *Floppy) SetInstanceType(attr *InstanceType) {
	p.instanceType = attr
}

// InstanceType Describes the hardware configuration of virtual machines.
//
// For example `medium` instance type includes 1 virtual CPU and 4 GiB of memory. It is a top-level
// entity (e.g. not bound to any data center or cluster). The attributes that are used for instance
// types and are common to virtual machine and template types are:
//
// - `console`
// - `cpu`
// - `custom_cpu_model`
// - `custom_emulated_machine`
// - `display`
// - `high_availability`
// - `io`
// - `memory`
// - `memory_policy`
// - `migration`
// - `migration_downtime`
// - `os`
// - `rng_device`
// - `soundcard_enabled`
// - `usb`
// - `virtio_scsi`
//
// When creating a virtual machine from both an instance type and a template, the virtual machine
// will inherit the hardware configurations from the instance type
//
// NOTE: An instance type inherits it's attributes from the template entity although most template
// attributes are not used in instance types.
func (p *Floppy) InstanceType() (*InstanceType, bool) {
	if p.instanceType != nil {
		return p.instanceType, true
	}
	return nil, false
}

// MustInstanceType Describes the hardware configuration of virtual machines.
//
// For example `medium` instance type includes 1 virtual CPU and 4 GiB of memory. It is a top-level
// entity (e.g. not bound to any data center or cluster). The attributes that are used for instance
// types and are common to virtual machine and template types are:
//
// - `console`
// - `cpu`
// - `custom_cpu_model`
// - `custom_emulated_machine`
// - `display`
// - `high_availability`
// - `io`
// - `memory`
// - `memory_policy`
// - `migration`
// - `migration_downtime`
// - `os`
// - `rng_device`
// - `soundcard_enabled`
// - `usb`
// - `virtio_scsi`
//
// When creating a virtual machine from both an instance type and a template, the virtual machine
// will inherit the hardware configurations from the instance type
//
// NOTE: An instance type inherits it's attributes from the template entity although most template
// attributes are not used in instance types.
func (p *Floppy) MustInstanceType() *InstanceType {
	if p.instanceType == nil {
		panic("the instanceType must not be nil, please use InstanceType() function instead")
	}
	return p.instanceType
}

func (p *Floppy) SetName(attr string) {
	p.name = &attr
}

func (p *Floppy) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *Floppy) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

// SetTemplate The type that represents a virtual machine template.
// Templates allow for a rapid instantiation of virtual machines with common configuration and disk states.
func (p *Floppy) SetTemplate(attr *Template) {
	p.template = attr
}

// Template The type that represents a virtual machine template.
// Templates allow for a rapid instantiation of virtual machines with common configuration and disk states.
func (p *Floppy) Template() (*Template, bool) {
	if p.template != nil {
		return p.template, true
	}
	return nil, false
}

// MustTemplate The type that represents a virtual machine template.
// Templates allow for a rapid instantiation of virtual machines with common configuration and disk states.
func (p *Floppy) MustTemplate() *Template {
	if p.template == nil {
		panic("the template must not be nil, please use Template() function instead")
	}
	return p.template
}

// SetVm Represents a virtual machine.
func (p *Floppy) SetVm(attr *Vm) {
	p.vm = attr
}

// Vm Represents a virtual machine.
func (p *Floppy) Vm() (*Vm, bool) {
	if p.vm != nil {
		return p.vm, true
	}
	return nil, false
}

// MustVm Represents a virtual machine.
func (p *Floppy) MustVm() *Vm {
	if p.vm == nil {
		panic("the vm must not be nil, please use Vm() function instead")
	}
	return p.vm
}

func (p *Floppy) SetVms(attr *VmSlice) {
	p.vms = attr
}

func (p *Floppy) Vms() (*VmSlice, bool) {
	if p.vms != nil {
		return p.vms, true
	}
	return nil, false
}

func (p *Floppy) MustVms() *VmSlice {
	if p.vms == nil {
		panic("the vms must not be nil, please use Vms() function instead")
	}
	return p.vms
}

type FopStatistic struct {
	Struct
	name       *string
	statistics *StatisticSlice
}

func (p *FopStatistic) SetName(attr string) {
	p.name = &attr
}

func (p *FopStatistic) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *FopStatistic) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *FopStatistic) SetStatistics(attr *StatisticSlice) {
	p.statistics = attr
}

func (p *FopStatistic) Statistics() (*StatisticSlice, bool) {
	if p.statistics != nil {
		return p.statistics, true
	}
	return nil, false
}

func (p *FopStatistic) MustStatistics() *StatisticSlice {
	if p.statistics == nil {
		panic("the statistics must not be nil, please use Statistics() function instead")
	}
	return p.statistics
}

type GlusterBrick struct {
	Struct
	brickDir       *string
	comment        *string
	description    *string
	device         *string
	fsName         *string
	glusterClients *GlusterClientSlice
	glusterVolume  *GlusterVolume
	id             *string
	instanceType   *InstanceType
	memoryPools    *GlusterMemoryPoolSlice
	mntOptions     *string
	name           *string
	pid            *int64
	port           *int64
	serverId       *string
	statistics     *StatisticSlice
	status         *GlusterBrickStatus
	template       *Template
	vm             *Vm
	vms            *VmSlice
}

func (p *GlusterBrick) SetBrickDir(attr string) {
	p.brickDir = &attr
}

func (p *GlusterBrick) BrickDir() (string, bool) {
	if p.brickDir != nil {
		return *p.brickDir, true
	}
	var zero string
	return zero, false
}

func (p *GlusterBrick) MustBrickDir() string {
	if p.brickDir == nil {
		panic("the brickDir must not be nil, please use BrickDir() function instead")
	}
	return *p.brickDir
}

func (p *GlusterBrick) SetComment(attr string) {
	p.comment = &attr
}

func (p *GlusterBrick) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *GlusterBrick) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *GlusterBrick) SetDescription(attr string) {
	p.description = &attr
}

func (p *GlusterBrick) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *GlusterBrick) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *GlusterBrick) SetDevice(attr string) {
	p.device = &attr
}

func (p *GlusterBrick) Device() (string, bool) {
	if p.device != nil {
		return *p.device, true
	}
	var zero string
	return zero, false
}

func (p *GlusterBrick) MustDevice() string {
	if p.device == nil {
		panic("the device must not be nil, please use Device() function instead")
	}
	return *p.device
}

func (p *GlusterBrick) SetFsName(attr string) {
	p.fsName = &attr
}

func (p *GlusterBrick) FsName() (string, bool) {
	if p.fsName != nil {
		return *p.fsName, true
	}
	var zero string
	return zero, false
}

func (p *GlusterBrick) MustFsName() string {
	if p.fsName == nil {
		panic("the fsName must not be nil, please use FsName() function instead")
	}
	return *p.fsName
}

func (p *GlusterBrick) SetGlusterClients(attr *GlusterClientSlice) {
	p.glusterClients = attr
}

func (p *GlusterBrick) GlusterClients() (*GlusterClientSlice, bool) {
	if p.glusterClients != nil {
		return p.glusterClients, true
	}
	return nil, false
}

func (p *GlusterBrick) MustGlusterClients() *GlusterClientSlice {
	if p.glusterClients == nil {
		panic("the glusterClients must not be nil, please use GlusterClients() function instead")
	}
	return p.glusterClients
}

func (p *GlusterBrick) SetGlusterVolume(attr *GlusterVolume) {
	p.glusterVolume = attr
}

func (p *GlusterBrick) GlusterVolume() (*GlusterVolume, bool) {
	if p.glusterVolume != nil {
		return p.glusterVolume, true
	}
	return nil, false
}

func (p *GlusterBrick) MustGlusterVolume() *GlusterVolume {
	if p.glusterVolume == nil {
		panic("the glusterVolume must not be nil, please use GlusterVolume() function instead")
	}
	return p.glusterVolume
}

func (p *GlusterBrick) SetId(attr string) {
	p.id = &attr
}

func (p *GlusterBrick) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *GlusterBrick) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

// SetInstanceType Describes the hardware configuration of virtual machines.
//
// For example `medium` instance type includes 1 virtual CPU and 4 GiB of memory. It is a top-level
// entity (e.g. not bound to any data center or cluster). The attributes that are used for instance
// types and are common to virtual machine and template types are:
//
// - `console`
// - `cpu`
// - `custom_cpu_model`
// - `custom_emulated_machine`
// - `display`
// - `high_availability`
// - `io`
// - `memory`
// - `memory_policy`
// - `migration`
// - `migration_downtime`
// - `os`
// - `rng_device`
// - `soundcard_enabled`
// - `usb`
// - `virtio_scsi`
//
// When creating a virtual machine from both an instance type and a template, the virtual machine
// will inherit the hardware configurations from the instance type
//
// NOTE: An instance type inherits it's attributes from the template entity although most template
// attributes are not used in instance types.
func (p *GlusterBrick) SetInstanceType(attr *InstanceType) {
	p.instanceType = attr
}

// InstanceType Describes the hardware configuration of virtual machines.
//
// For example `medium` instance type includes 1 virtual CPU and 4 GiB of memory. It is a top-level
// entity (e.g. not bound to any data center or cluster). The attributes that are used for instance
// types and are common to virtual machine and template types are:
//
// - `console`
// - `cpu`
// - `custom_cpu_model`
// - `custom_emulated_machine`
// - `display`
// - `high_availability`
// - `io`
// - `memory`
// - `memory_policy`
// - `migration`
// - `migration_downtime`
// - `os`
// - `rng_device`
// - `soundcard_enabled`
// - `usb`
// - `virtio_scsi`
//
// When creating a virtual machine from both an instance type and a template, the virtual machine
// will inherit the hardware configurations from the instance type
//
// NOTE: An instance type inherits it's attributes from the template entity although most template
// attributes are not used in instance types.
func (p *GlusterBrick) InstanceType() (*InstanceType, bool) {
	if p.instanceType != nil {
		return p.instanceType, true
	}
	return nil, false
}

// MustInstanceType Describes the hardware configuration of virtual machines.
//
// For example `medium` instance type includes 1 virtual CPU and 4 GiB of memory. It is a top-level
// entity (e.g. not bound to any data center or cluster). The attributes that are used for instance
// types and are common to virtual machine and template types are:
//
// - `console`
// - `cpu`
// - `custom_cpu_model`
// - `custom_emulated_machine`
// - `display`
// - `high_availability`
// - `io`
// - `memory`
// - `memory_policy`
// - `migration`
// - `migration_downtime`
// - `os`
// - `rng_device`
// - `soundcard_enabled`
// - `usb`
// - `virtio_scsi`
//
// When creating a virtual machine from both an instance type and a template, the virtual machine
// will inherit the hardware configurations from the instance type
//
// NOTE: An instance type inherits it's attributes from the template entity although most template
// attributes are not used in instance types.
func (p *GlusterBrick) MustInstanceType() *InstanceType {
	if p.instanceType == nil {
		panic("the instanceType must not be nil, please use InstanceType() function instead")
	}
	return p.instanceType
}

func (p *GlusterBrick) SetMemoryPools(attr *GlusterMemoryPoolSlice) {
	p.memoryPools = attr
}

func (p *GlusterBrick) MemoryPools() (*GlusterMemoryPoolSlice, bool) {
	if p.memoryPools != nil {
		return p.memoryPools, true
	}
	return nil, false
}

func (p *GlusterBrick) MustMemoryPools() *GlusterMemoryPoolSlice {
	if p.memoryPools == nil {
		panic("the memoryPools must not be nil, please use MemoryPools() function instead")
	}
	return p.memoryPools
}

func (p *GlusterBrick) SetMntOptions(attr string) {
	p.mntOptions = &attr
}

func (p *GlusterBrick) MntOptions() (string, bool) {
	if p.mntOptions != nil {
		return *p.mntOptions, true
	}
	var zero string
	return zero, false
}

func (p *GlusterBrick) MustMntOptions() string {
	if p.mntOptions == nil {
		panic("the mntOptions must not be nil, please use MntOptions() function instead")
	}
	return *p.mntOptions
}

func (p *GlusterBrick) SetName(attr string) {
	p.name = &attr
}

func (p *GlusterBrick) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *GlusterBrick) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *GlusterBrick) SetPid(attr int64) {
	p.pid = &attr
}

func (p *GlusterBrick) Pid() (int64, bool) {
	if p.pid != nil {
		return *p.pid, true
	}
	var zero int64
	return zero, false
}

func (p *GlusterBrick) MustPid() int64 {
	if p.pid == nil {
		panic("the pid must not be nil, please use Pid() function instead")
	}
	return *p.pid
}

func (p *GlusterBrick) SetPort(attr int64) {
	p.port = &attr
}

func (p *GlusterBrick) Port() (int64, bool) {
	if p.port != nil {
		return *p.port, true
	}
	var zero int64
	return zero, false
}

func (p *GlusterBrick) MustPort() int64 {
	if p.port == nil {
		panic("the port must not be nil, please use Port() function instead")
	}
	return *p.port
}

func (p *GlusterBrick) SetServerId(attr string) {
	p.serverId = &attr
}

func (p *GlusterBrick) ServerId() (string, bool) {
	if p.serverId != nil {
		return *p.serverId, true
	}
	var zero string
	return zero, false
}

func (p *GlusterBrick) MustServerId() string {
	if p.serverId == nil {
		panic("the serverId must not be nil, please use ServerId() function instead")
	}
	return *p.serverId
}

func (p *GlusterBrick) SetStatistics(attr *StatisticSlice) {
	p.statistics = attr
}

func (p *GlusterBrick) Statistics() (*StatisticSlice, bool) {
	if p.statistics != nil {
		return p.statistics, true
	}
	return nil, false
}

func (p *GlusterBrick) MustStatistics() *StatisticSlice {
	if p.statistics == nil {
		panic("the statistics must not be nil, please use Statistics() function instead")
	}
	return p.statistics
}

func (p *GlusterBrick) SetStatus(attr GlusterBrickStatus) {
	p.status = &attr
}

func (p *GlusterBrick) Status() (GlusterBrickStatus, bool) {
	if p.status != nil {
		return *p.status, true
	}
	var zero GlusterBrickStatus
	return zero, false
}

func (p *GlusterBrick) MustStatus() GlusterBrickStatus {
	if p.status == nil {
		panic("the status must not be nil, please use Status() function instead")
	}
	return *p.status
}

// SetTemplate The type that represents a virtual machine template.
// Templates allow for a rapid instantiation of virtual machines with common configuration and disk states.
func (p *GlusterBrick) SetTemplate(attr *Template) {
	p.template = attr
}

// Template The type that represents a virtual machine template.
// Templates allow for a rapid instantiation of virtual machines with common configuration and disk states.
func (p *GlusterBrick) Template() (*Template, bool) {
	if p.template != nil {
		return p.template, true
	}
	return nil, false
}

// MustTemplate The type that represents a virtual machine template.
// Templates allow for a rapid instantiation of virtual machines with common configuration and disk states.
func (p *GlusterBrick) MustTemplate() *Template {
	if p.template == nil {
		panic("the template must not be nil, please use Template() function instead")
	}
	return p.template
}

// SetVm Represents a virtual machine.
func (p *GlusterBrick) SetVm(attr *Vm) {
	p.vm = attr
}

// Vm Represents a virtual machine.
func (p *GlusterBrick) Vm() (*Vm, bool) {
	if p.vm != nil {
		return p.vm, true
	}
	return nil, false
}

// MustVm Represents a virtual machine.
func (p *GlusterBrick) MustVm() *Vm {
	if p.vm == nil {
		panic("the vm must not be nil, please use Vm() function instead")
	}
	return p.vm
}

func (p *GlusterBrick) SetVms(attr *VmSlice) {
	p.vms = attr
}

func (p *GlusterBrick) Vms() (*VmSlice, bool) {
	if p.vms != nil {
		return p.vms, true
	}
	return nil, false
}

func (p *GlusterBrick) MustVms() *VmSlice {
	if p.vms == nil {
		panic("the vms must not be nil, please use Vms() function instead")
	}
	return p.vms
}

type GlusterBrickAdvancedDetails struct {
	Struct
	comment        *string
	description    *string
	device         *string
	fsName         *string
	glusterClients *GlusterClientSlice
	id             *string
	instanceType   *InstanceType
	memoryPools    *GlusterMemoryPoolSlice
	mntOptions     *string
	name           *string
	pid            *int64
	port           *int64
	template       *Template
	vm             *Vm
	vms            *VmSlice
}

func (p *GlusterBrickAdvancedDetails) SetComment(attr string) {
	p.comment = &attr
}

func (p *GlusterBrickAdvancedDetails) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *GlusterBrickAdvancedDetails) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *GlusterBrickAdvancedDetails) SetDescription(attr string) {
	p.description = &attr
}

func (p *GlusterBrickAdvancedDetails) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *GlusterBrickAdvancedDetails) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *GlusterBrickAdvancedDetails) SetDevice(attr string) {
	p.device = &attr
}

func (p *GlusterBrickAdvancedDetails) Device() (string, bool) {
	if p.device != nil {
		return *p.device, true
	}
	var zero string
	return zero, false
}

func (p *GlusterBrickAdvancedDetails) MustDevice() string {
	if p.device == nil {
		panic("the device must not be nil, please use Device() function instead")
	}
	return *p.device
}

func (p *GlusterBrickAdvancedDetails) SetFsName(attr string) {
	p.fsName = &attr
}

func (p *GlusterBrickAdvancedDetails) FsName() (string, bool) {
	if p.fsName != nil {
		return *p.fsName, true
	}
	var zero string
	return zero, false
}

func (p *GlusterBrickAdvancedDetails) MustFsName() string {
	if p.fsName == nil {
		panic("the fsName must not be nil, please use FsName() function instead")
	}
	return *p.fsName
}

func (p *GlusterBrickAdvancedDetails) SetGlusterClients(attr *GlusterClientSlice) {
	p.glusterClients = attr
}

func (p *GlusterBrickAdvancedDetails) GlusterClients() (*GlusterClientSlice, bool) {
	if p.glusterClients != nil {
		return p.glusterClients, true
	}
	return nil, false
}

func (p *GlusterBrickAdvancedDetails) MustGlusterClients() *GlusterClientSlice {
	if p.glusterClients == nil {
		panic("the glusterClients must not be nil, please use GlusterClients() function instead")
	}
	return p.glusterClients
}

func (p *GlusterBrickAdvancedDetails) SetId(attr string) {
	p.id = &attr
}

func (p *GlusterBrickAdvancedDetails) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *GlusterBrickAdvancedDetails) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

// SetInstanceType Describes the hardware configuration of virtual machines.
//
// For example `medium` instance type includes 1 virtual CPU and 4 GiB of memory. It is a top-level
// entity (e.g. not bound to any data center or cluster). The attributes that are used for instance
// types and are common to virtual machine and template types are:
//
// - `console`
// - `cpu`
// - `custom_cpu_model`
// - `custom_emulated_machine`
// - `display`
// - `high_availability`
// - `io`
// - `memory`
// - `memory_policy`
// - `migration`
// - `migration_downtime`
// - `os`
// - `rng_device`
// - `soundcard_enabled`
// - `usb`
// - `virtio_scsi`
//
// When creating a virtual machine from both an instance type and a template, the virtual machine
// will inherit the hardware configurations from the instance type
//
// NOTE: An instance type inherits it's attributes from the template entity although most template
// attributes are not used in instance types.
func (p *GlusterBrickAdvancedDetails) SetInstanceType(attr *InstanceType) {
	p.instanceType = attr
}

// InstanceType Describes the hardware configuration of virtual machines.
//
// For example `medium` instance type includes 1 virtual CPU and 4 GiB of memory. It is a top-level
// entity (e.g. not bound to any data center or cluster). The attributes that are used for instance
// types and are common to virtual machine and template types are:
//
// - `console`
// - `cpu`
// - `custom_cpu_model`
// - `custom_emulated_machine`
// - `display`
// - `high_availability`
// - `io`
// - `memory`
// - `memory_policy`
// - `migration`
// - `migration_downtime`
// - `os`
// - `rng_device`
// - `soundcard_enabled`
// - `usb`
// - `virtio_scsi`
//
// When creating a virtual machine from both an instance type and a template, the virtual machine
// will inherit the hardware configurations from the instance type
//
// NOTE: An instance type inherits it's attributes from the template entity although most template
// attributes are not used in instance types.
func (p *GlusterBrickAdvancedDetails) InstanceType() (*InstanceType, bool) {
	if p.instanceType != nil {
		return p.instanceType, true
	}
	return nil, false
}

// MustInstanceType Describes the hardware configuration of virtual machines.
//
// For example `medium` instance type includes 1 virtual CPU and 4 GiB of memory. It is a top-level
// entity (e.g. not bound to any data center or cluster). The attributes that are used for instance
// types and are common to virtual machine and template types are:
//
// - `console`
// - `cpu`
// - `custom_cpu_model`
// - `custom_emulated_machine`
// - `display`
// - `high_availability`
// - `io`
// - `memory`
// - `memory_policy`
// - `migration`
// - `migration_downtime`
// - `os`
// - `rng_device`
// - `soundcard_enabled`
// - `usb`
// - `virtio_scsi`
//
// When creating a virtual machine from both an instance type and a template, the virtual machine
// will inherit the hardware configurations from the instance type
//
// NOTE: An instance type inherits it's attributes from the template entity although most template
// attributes are not used in instance types.
func (p *GlusterBrickAdvancedDetails) MustInstanceType() *InstanceType {
	if p.instanceType == nil {
		panic("the instanceType must not be nil, please use InstanceType() function instead")
	}
	return p.instanceType
}

func (p *GlusterBrickAdvancedDetails) SetMemoryPools(attr *GlusterMemoryPoolSlice) {
	p.memoryPools = attr
}

func (p *GlusterBrickAdvancedDetails) MemoryPools() (*GlusterMemoryPoolSlice, bool) {
	if p.memoryPools != nil {
		return p.memoryPools, true
	}
	return nil, false
}

func (p *GlusterBrickAdvancedDetails) MustMemoryPools() *GlusterMemoryPoolSlice {
	if p.memoryPools == nil {
		panic("the memoryPools must not be nil, please use MemoryPools() function instead")
	}
	return p.memoryPools
}

func (p *GlusterBrickAdvancedDetails) SetMntOptions(attr string) {
	p.mntOptions = &attr
}

func (p *GlusterBrickAdvancedDetails) MntOptions() (string, bool) {
	if p.mntOptions != nil {
		return *p.mntOptions, true
	}
	var zero string
	return zero, false
}

func (p *GlusterBrickAdvancedDetails) MustMntOptions() string {
	if p.mntOptions == nil {
		panic("the mntOptions must not be nil, please use MntOptions() function instead")
	}
	return *p.mntOptions
}

func (p *GlusterBrickAdvancedDetails) SetName(attr string) {
	p.name = &attr
}

func (p *GlusterBrickAdvancedDetails) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *GlusterBrickAdvancedDetails) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *GlusterBrickAdvancedDetails) SetPid(attr int64) {
	p.pid = &attr
}

func (p *GlusterBrickAdvancedDetails) Pid() (int64, bool) {
	if p.pid != nil {
		return *p.pid, true
	}
	var zero int64
	return zero, false
}

func (p *GlusterBrickAdvancedDetails) MustPid() int64 {
	if p.pid == nil {
		panic("the pid must not be nil, please use Pid() function instead")
	}
	return *p.pid
}

func (p *GlusterBrickAdvancedDetails) SetPort(attr int64) {
	p.port = &attr
}

func (p *GlusterBrickAdvancedDetails) Port() (int64, bool) {
	if p.port != nil {
		return *p.port, true
	}
	var zero int64
	return zero, false
}

func (p *GlusterBrickAdvancedDetails) MustPort() int64 {
	if p.port == nil {
		panic("the port must not be nil, please use Port() function instead")
	}
	return *p.port
}

// SetTemplate The type that represents a virtual machine template.
// Templates allow for a rapid instantiation of virtual machines with common configuration and disk states.
func (p *GlusterBrickAdvancedDetails) SetTemplate(attr *Template) {
	p.template = attr
}

// Template The type that represents a virtual machine template.
// Templates allow for a rapid instantiation of virtual machines with common configuration and disk states.
func (p *GlusterBrickAdvancedDetails) Template() (*Template, bool) {
	if p.template != nil {
		return p.template, true
	}
	return nil, false
}

// MustTemplate The type that represents a virtual machine template.
// Templates allow for a rapid instantiation of virtual machines with common configuration and disk states.
func (p *GlusterBrickAdvancedDetails) MustTemplate() *Template {
	if p.template == nil {
		panic("the template must not be nil, please use Template() function instead")
	}
	return p.template
}

// SetVm Represents a virtual machine.
func (p *GlusterBrickAdvancedDetails) SetVm(attr *Vm) {
	p.vm = attr
}

// Vm Represents a virtual machine.
func (p *GlusterBrickAdvancedDetails) Vm() (*Vm, bool) {
	if p.vm != nil {
		return p.vm, true
	}
	return nil, false
}

// MustVm Represents a virtual machine.
func (p *GlusterBrickAdvancedDetails) MustVm() *Vm {
	if p.vm == nil {
		panic("the vm must not be nil, please use Vm() function instead")
	}
	return p.vm
}

func (p *GlusterBrickAdvancedDetails) SetVms(attr *VmSlice) {
	p.vms = attr
}

func (p *GlusterBrickAdvancedDetails) Vms() (*VmSlice, bool) {
	if p.vms != nil {
		return p.vms, true
	}
	return nil, false
}

func (p *GlusterBrickAdvancedDetails) MustVms() *VmSlice {
	if p.vms == nil {
		panic("the vms must not be nil, please use Vms() function instead")
	}
	return p.vms
}

type GlusterBrickMemoryInfo struct {
	Struct
	memoryPools *GlusterMemoryPoolSlice
}

func (p *GlusterBrickMemoryInfo) SetMemoryPools(attr *GlusterMemoryPoolSlice) {
	p.memoryPools = attr
}

func (p *GlusterBrickMemoryInfo) MemoryPools() (*GlusterMemoryPoolSlice, bool) {
	if p.memoryPools != nil {
		return p.memoryPools, true
	}
	return nil, false
}

func (p *GlusterBrickMemoryInfo) MustMemoryPools() *GlusterMemoryPoolSlice {
	if p.memoryPools == nil {
		panic("the memoryPools must not be nil, please use MemoryPools() function instead")
	}
	return p.memoryPools
}

type GlusterClient struct {
	Struct
	bytesRead    *int64
	bytesWritten *int64
	clientPort   *int64
	hostName     *string
}

func (p *GlusterClient) SetBytesRead(attr int64) {
	p.bytesRead = &attr
}

func (p *GlusterClient) BytesRead() (int64, bool) {
	if p.bytesRead != nil {
		return *p.bytesRead, true
	}
	var zero int64
	return zero, false
}

func (p *GlusterClient) MustBytesRead() int64 {
	if p.bytesRead == nil {
		panic("the bytesRead must not be nil, please use BytesRead() function instead")
	}
	return *p.bytesRead
}

func (p *GlusterClient) SetBytesWritten(attr int64) {
	p.bytesWritten = &attr
}

func (p *GlusterClient) BytesWritten() (int64, bool) {
	if p.bytesWritten != nil {
		return *p.bytesWritten, true
	}
	var zero int64
	return zero, false
}

func (p *GlusterClient) MustBytesWritten() int64 {
	if p.bytesWritten == nil {
		panic("the bytesWritten must not be nil, please use BytesWritten() function instead")
	}
	return *p.bytesWritten
}

func (p *GlusterClient) SetClientPort(attr int64) {
	p.clientPort = &attr
}

func (p *GlusterClient) ClientPort() (int64, bool) {
	if p.clientPort != nil {
		return *p.clientPort, true
	}
	var zero int64
	return zero, false
}

func (p *GlusterClient) MustClientPort() int64 {
	if p.clientPort == nil {
		panic("the clientPort must not be nil, please use ClientPort() function instead")
	}
	return *p.clientPort
}

func (p *GlusterClient) SetHostName(attr string) {
	p.hostName = &attr
}

func (p *GlusterClient) HostName() (string, bool) {
	if p.hostName != nil {
		return *p.hostName, true
	}
	var zero string
	return zero, false
}

func (p *GlusterClient) MustHostName() string {
	if p.hostName == nil {
		panic("the hostName must not be nil, please use HostName() function instead")
	}
	return *p.hostName
}

type GlusterHook struct {
	Struct
	checksum       *string
	cluster        *Cluster
	comment        *string
	conflictStatus *int64
	conflicts      *string
	content        *string
	contentType    *HookContentType
	description    *string
	glusterCommand *string
	id             *string
	name           *string
	serverHooks    *GlusterServerHookSlice
	stage          *HookStage
	status         *GlusterHookStatus
}

func (p *GlusterHook) SetChecksum(attr string) {
	p.checksum = &attr
}

func (p *GlusterHook) Checksum() (string, bool) {
	if p.checksum != nil {
		return *p.checksum, true
	}
	var zero string
	return zero, false
}

func (p *GlusterHook) MustChecksum() string {
	if p.checksum == nil {
		panic("the checksum must not be nil, please use Checksum() function instead")
	}
	return *p.checksum
}

// SetCluster Type representation of a cluster.
//
// A JSON representation of a cluster:
//
// [source]
// ----
// {
//   "cluster" : [ {
//     "ballooning_enabled" : "false",
//     "cpu" : {
//       "architecture" : "x86_64",
//       "type" : "Intel SandyBridge Family"
//     },
//     "custom_scheduling_policy_properties" : {
//       "property" : [ {
//         "name" : "HighUtilization",
//         "value" : "80"
//       }, {
//         "name" : "CpuOverCommitDurationMinutes",
//         "value" : "2"
//       } ]
//     },
//     "error_handling" : {
//       "on_error" : "migrate"
//     },
//     "fencing_policy" : {
//       "enabled" : "true",
//       "skip_if_connectivity_broken" : {
//         "enabled" : "false",
//         "threshold" : "50"
//       },
//       "skip_if_gluster_bricks_up" : "false",
//       "skip_if_gluster_quorum_not_met" : "false",
//       "skip_if_sd_active" : {
//         "enabled" : "false"
//       }
//     },
//     "gluster_service" : "false",
//     "firewall_type" : "iptables",
//     "ha_reservation" : "false",
//     "ksm" : {
//       "enabled" : "true",
//       "merge_across_nodes" : "true"
//     },
//     "memory_policy" : {
//       "over_commit" : {
//         "percent" : "100"
//       },
//       "transparent_hugepages" : {
//         "enabled" : "true"
//       }
//     },
//     "migration" : {
//       "auto_converge" : "inherit",
//       "bandwidth" : {
//         "assignment_method" : "auto"
//       },
//       "compressed" : "inherit",
//       "policy" : {
//         "id" : "00000000-0000-0000-0000-000000000000"
//       }
//     },
//     "required_rng_sources" : {
//       "required_rng_source" : [ "random" ]
//     },
//     "switch_type" : "legacy",
//     "threads_as_cores" : "false",
//     "trusted_service" : "false",
//     "tunnel_migration" : "false",
//     "version" : {
//       "major" : "4",
//       "minor" : "1"
//     },
//     "virt_service" : "true",
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "mac_pool" : {
//       "href" : "/ovirt-engine/api/macpools/456",
//       "id" : "456"
//     },
//     "scheduling_policy" : {
//       "href" : "/ovirt-engine/api/schedulingpolicies/789",
//       "id" : "789"
//     },
//     "actions" : {
//       "link" : [ {
//         "href" : "/ovirt-engine/api/clusters/234/resetemulatedmachine",
//         "rel" : "resetemulatedmachine"
//       } ]
//     },
//     "name" : "Default",
//     "description" : "The default server cluster",
//     "href" : "/ovirt-engine/api/clusters/234",
//     "id" : "234",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/clusters/234/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/cpuprofiles",
//       "rel" : "cpuprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networkfilters",
//       "rel" : "networkfilters"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networks",
//       "rel" : "networks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/affinitygroups",
//       "rel" : "affinitygroups"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glusterhooks",
//       "rel" : "glusterhooks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glustervolumes",
//       "rel" : "glustervolumes"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/enabledfeatures",
//       "rel" : "enabledfeatures"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/externalnetworkproviders",
//       "rel" : "externalnetworkproviders"
//     } ]
//   } ]
// }
// ----
func (p *GlusterHook) SetCluster(attr *Cluster) {
	p.cluster = attr
}

// Cluster Type representation of a cluster.
//
// A JSON representation of a cluster:
//
// [source]
// ----
// {
//   "cluster" : [ {
//     "ballooning_enabled" : "false",
//     "cpu" : {
//       "architecture" : "x86_64",
//       "type" : "Intel SandyBridge Family"
//     },
//     "custom_scheduling_policy_properties" : {
//       "property" : [ {
//         "name" : "HighUtilization",
//         "value" : "80"
//       }, {
//         "name" : "CpuOverCommitDurationMinutes",
//         "value" : "2"
//       } ]
//     },
//     "error_handling" : {
//       "on_error" : "migrate"
//     },
//     "fencing_policy" : {
//       "enabled" : "true",
//       "skip_if_connectivity_broken" : {
//         "enabled" : "false",
//         "threshold" : "50"
//       },
//       "skip_if_gluster_bricks_up" : "false",
//       "skip_if_gluster_quorum_not_met" : "false",
//       "skip_if_sd_active" : {
//         "enabled" : "false"
//       }
//     },
//     "gluster_service" : "false",
//     "firewall_type" : "iptables",
//     "ha_reservation" : "false",
//     "ksm" : {
//       "enabled" : "true",
//       "merge_across_nodes" : "true"
//     },
//     "memory_policy" : {
//       "over_commit" : {
//         "percent" : "100"
//       },
//       "transparent_hugepages" : {
//         "enabled" : "true"
//       }
//     },
//     "migration" : {
//       "auto_converge" : "inherit",
//       "bandwidth" : {
//         "assignment_method" : "auto"
//       },
//       "compressed" : "inherit",
//       "policy" : {
//         "id" : "00000000-0000-0000-0000-000000000000"
//       }
//     },
//     "required_rng_sources" : {
//       "required_rng_source" : [ "random" ]
//     },
//     "switch_type" : "legacy",
//     "threads_as_cores" : "false",
//     "trusted_service" : "false",
//     "tunnel_migration" : "false",
//     "version" : {
//       "major" : "4",
//       "minor" : "1"
//     },
//     "virt_service" : "true",
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "mac_pool" : {
//       "href" : "/ovirt-engine/api/macpools/456",
//       "id" : "456"
//     },
//     "scheduling_policy" : {
//       "href" : "/ovirt-engine/api/schedulingpolicies/789",
//       "id" : "789"
//     },
//     "actions" : {
//       "link" : [ {
//         "href" : "/ovirt-engine/api/clusters/234/resetemulatedmachine",
//         "rel" : "resetemulatedmachine"
//       } ]
//     },
//     "name" : "Default",
//     "description" : "The default server cluster",
//     "href" : "/ovirt-engine/api/clusters/234",
//     "id" : "234",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/clusters/234/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/cpuprofiles",
//       "rel" : "cpuprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networkfilters",
//       "rel" : "networkfilters"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networks",
//       "rel" : "networks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/affinitygroups",
//       "rel" : "affinitygroups"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glusterhooks",
//       "rel" : "glusterhooks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glustervolumes",
//       "rel" : "glustervolumes"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/enabledfeatures",
//       "rel" : "enabledfeatures"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/externalnetworkproviders",
//       "rel" : "externalnetworkproviders"
//     } ]
//   } ]
// }
// ----
func (p *GlusterHook) Cluster() (*Cluster, bool) {
	if p.cluster != nil {
		return p.cluster, true
	}
	return nil, false
}

// MustCluster Type representation of a cluster.
//
// A JSON representation of a cluster:
//
// [source]
// ----
// {
//   "cluster" : [ {
//     "ballooning_enabled" : "false",
//     "cpu" : {
//       "architecture" : "x86_64",
//       "type" : "Intel SandyBridge Family"
//     },
//     "custom_scheduling_policy_properties" : {
//       "property" : [ {
//         "name" : "HighUtilization",
//         "value" : "80"
//       }, {
//         "name" : "CpuOverCommitDurationMinutes",
//         "value" : "2"
//       } ]
//     },
//     "error_handling" : {
//       "on_error" : "migrate"
//     },
//     "fencing_policy" : {
//       "enabled" : "true",
//       "skip_if_connectivity_broken" : {
//         "enabled" : "false",
//         "threshold" : "50"
//       },
//       "skip_if_gluster_bricks_up" : "false",
//       "skip_if_gluster_quorum_not_met" : "false",
//       "skip_if_sd_active" : {
//         "enabled" : "false"
//       }
//     },
//     "gluster_service" : "false",
//     "firewall_type" : "iptables",
//     "ha_reservation" : "false",
//     "ksm" : {
//       "enabled" : "true",
//       "merge_across_nodes" : "true"
//     },
//     "memory_policy" : {
//       "over_commit" : {
//         "percent" : "100"
//       },
//       "transparent_hugepages" : {
//         "enabled" : "true"
//       }
//     },
//     "migration" : {
//       "auto_converge" : "inherit",
//       "bandwidth" : {
//         "assignment_method" : "auto"
//       },
//       "compressed" : "inherit",
//       "policy" : {
//         "id" : "00000000-0000-0000-0000-000000000000"
//       }
//     },
//     "required_rng_sources" : {
//       "required_rng_source" : [ "random" ]
//     },
//     "switch_type" : "legacy",
//     "threads_as_cores" : "false",
//     "trusted_service" : "false",
//     "tunnel_migration" : "false",
//     "version" : {
//       "major" : "4",
//       "minor" : "1"
//     },
//     "virt_service" : "true",
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "mac_pool" : {
//       "href" : "/ovirt-engine/api/macpools/456",
//       "id" : "456"
//     },
//     "scheduling_policy" : {
//       "href" : "/ovirt-engine/api/schedulingpolicies/789",
//       "id" : "789"
//     },
//     "actions" : {
//       "link" : [ {
//         "href" : "/ovirt-engine/api/clusters/234/resetemulatedmachine",
//         "rel" : "resetemulatedmachine"
//       } ]
//     },
//     "name" : "Default",
//     "description" : "The default server cluster",
//     "href" : "/ovirt-engine/api/clusters/234",
//     "id" : "234",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/clusters/234/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/cpuprofiles",
//       "rel" : "cpuprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networkfilters",
//       "rel" : "networkfilters"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networks",
//       "rel" : "networks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/affinitygroups",
//       "rel" : "affinitygroups"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glusterhooks",
//       "rel" : "glusterhooks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glustervolumes",
//       "rel" : "glustervolumes"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/enabledfeatures",
//       "rel" : "enabledfeatures"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/externalnetworkproviders",
//       "rel" : "externalnetworkproviders"
//     } ]
//   } ]
// }
// ----
func (p *GlusterHook) MustCluster() *Cluster {
	if p.cluster == nil {
		panic("the cluster must not be nil, please use Cluster() function instead")
	}
	return p.cluster
}

func (p *GlusterHook) SetComment(attr string) {
	p.comment = &attr
}

func (p *GlusterHook) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *GlusterHook) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *GlusterHook) SetConflictStatus(attr int64) {
	p.conflictStatus = &attr
}

func (p *GlusterHook) ConflictStatus() (int64, bool) {
	if p.conflictStatus != nil {
		return *p.conflictStatus, true
	}
	var zero int64
	return zero, false
}

func (p *GlusterHook) MustConflictStatus() int64 {
	if p.conflictStatus == nil {
		panic("the conflictStatus must not be nil, please use ConflictStatus() function instead")
	}
	return *p.conflictStatus
}

func (p *GlusterHook) SetConflicts(attr string) {
	p.conflicts = &attr
}

func (p *GlusterHook) Conflicts() (string, bool) {
	if p.conflicts != nil {
		return *p.conflicts, true
	}
	var zero string
	return zero, false
}

func (p *GlusterHook) MustConflicts() string {
	if p.conflicts == nil {
		panic("the conflicts must not be nil, please use Conflicts() function instead")
	}
	return *p.conflicts
}

func (p *GlusterHook) SetContent(attr string) {
	p.content = &attr
}

func (p *GlusterHook) Content() (string, bool) {
	if p.content != nil {
		return *p.content, true
	}
	var zero string
	return zero, false
}

func (p *GlusterHook) MustContent() string {
	if p.content == nil {
		panic("the content must not be nil, please use Content() function instead")
	}
	return *p.content
}

// SetContentType Represents content type of hook script.
func (p *GlusterHook) SetContentType(attr HookContentType) {
	p.contentType = &attr
}

// ContentType Represents content type of hook script.
func (p *GlusterHook) ContentType() (HookContentType, bool) {
	if p.contentType != nil {
		return *p.contentType, true
	}
	var zero HookContentType
	return zero, false
}

// MustContentType Represents content type of hook script.
func (p *GlusterHook) MustContentType() HookContentType {
	if p.contentType == nil {
		panic("the contentType must not be nil, please use ContentType() function instead")
	}
	return *p.contentType
}

func (p *GlusterHook) SetDescription(attr string) {
	p.description = &attr
}

func (p *GlusterHook) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *GlusterHook) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *GlusterHook) SetGlusterCommand(attr string) {
	p.glusterCommand = &attr
}

func (p *GlusterHook) GlusterCommand() (string, bool) {
	if p.glusterCommand != nil {
		return *p.glusterCommand, true
	}
	var zero string
	return zero, false
}

func (p *GlusterHook) MustGlusterCommand() string {
	if p.glusterCommand == nil {
		panic("the glusterCommand must not be nil, please use GlusterCommand() function instead")
	}
	return *p.glusterCommand
}

func (p *GlusterHook) SetId(attr string) {
	p.id = &attr
}

func (p *GlusterHook) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *GlusterHook) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *GlusterHook) SetName(attr string) {
	p.name = &attr
}

func (p *GlusterHook) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *GlusterHook) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *GlusterHook) SetServerHooks(attr *GlusterServerHookSlice) {
	p.serverHooks = attr
}

func (p *GlusterHook) ServerHooks() (*GlusterServerHookSlice, bool) {
	if p.serverHooks != nil {
		return p.serverHooks, true
	}
	return nil, false
}

func (p *GlusterHook) MustServerHooks() *GlusterServerHookSlice {
	if p.serverHooks == nil {
		panic("the serverHooks must not be nil, please use ServerHooks() function instead")
	}
	return p.serverHooks
}

// SetStage Type represents a stage of volume event at which hook executes.
func (p *GlusterHook) SetStage(attr HookStage) {
	p.stage = &attr
}

// Stage Type represents a stage of volume event at which hook executes.
func (p *GlusterHook) Stage() (HookStage, bool) {
	if p.stage != nil {
		return *p.stage, true
	}
	var zero HookStage
	return zero, false
}

// MustStage Type represents a stage of volume event at which hook executes.
func (p *GlusterHook) MustStage() HookStage {
	if p.stage == nil {
		panic("the stage must not be nil, please use Stage() function instead")
	}
	return *p.stage
}

func (p *GlusterHook) SetStatus(attr GlusterHookStatus) {
	p.status = &attr
}

func (p *GlusterHook) Status() (GlusterHookStatus, bool) {
	if p.status != nil {
		return *p.status, true
	}
	var zero GlusterHookStatus
	return zero, false
}

func (p *GlusterHook) MustStatus() GlusterHookStatus {
	if p.status == nil {
		panic("the status must not be nil, please use Status() function instead")
	}
	return *p.status
}

type GlusterMemoryPool struct {
	Struct
	allocCount  *int64
	coldCount   *int64
	comment     *string
	description *string
	hotCount    *int64
	id          *string
	maxAlloc    *int64
	maxStdalloc *int64
	name        *string
	paddedSize  *int64
	poolMisses  *int64
	type_       *string
}

func (p *GlusterMemoryPool) SetAllocCount(attr int64) {
	p.allocCount = &attr
}

func (p *GlusterMemoryPool) AllocCount() (int64, bool) {
	if p.allocCount != nil {
		return *p.allocCount, true
	}
	var zero int64
	return zero, false
}

func (p *GlusterMemoryPool) MustAllocCount() int64 {
	if p.allocCount == nil {
		panic("the allocCount must not be nil, please use AllocCount() function instead")
	}
	return *p.allocCount
}

func (p *GlusterMemoryPool) SetColdCount(attr int64) {
	p.coldCount = &attr
}

func (p *GlusterMemoryPool) ColdCount() (int64, bool) {
	if p.coldCount != nil {
		return *p.coldCount, true
	}
	var zero int64
	return zero, false
}

func (p *GlusterMemoryPool) MustColdCount() int64 {
	if p.coldCount == nil {
		panic("the coldCount must not be nil, please use ColdCount() function instead")
	}
	return *p.coldCount
}

func (p *GlusterMemoryPool) SetComment(attr string) {
	p.comment = &attr
}

func (p *GlusterMemoryPool) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *GlusterMemoryPool) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *GlusterMemoryPool) SetDescription(attr string) {
	p.description = &attr
}

func (p *GlusterMemoryPool) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *GlusterMemoryPool) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *GlusterMemoryPool) SetHotCount(attr int64) {
	p.hotCount = &attr
}

func (p *GlusterMemoryPool) HotCount() (int64, bool) {
	if p.hotCount != nil {
		return *p.hotCount, true
	}
	var zero int64
	return zero, false
}

func (p *GlusterMemoryPool) MustHotCount() int64 {
	if p.hotCount == nil {
		panic("the hotCount must not be nil, please use HotCount() function instead")
	}
	return *p.hotCount
}

func (p *GlusterMemoryPool) SetId(attr string) {
	p.id = &attr
}

func (p *GlusterMemoryPool) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *GlusterMemoryPool) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *GlusterMemoryPool) SetMaxAlloc(attr int64) {
	p.maxAlloc = &attr
}

func (p *GlusterMemoryPool) MaxAlloc() (int64, bool) {
	if p.maxAlloc != nil {
		return *p.maxAlloc, true
	}
	var zero int64
	return zero, false
}

func (p *GlusterMemoryPool) MustMaxAlloc() int64 {
	if p.maxAlloc == nil {
		panic("the maxAlloc must not be nil, please use MaxAlloc() function instead")
	}
	return *p.maxAlloc
}

func (p *GlusterMemoryPool) SetMaxStdalloc(attr int64) {
	p.maxStdalloc = &attr
}

func (p *GlusterMemoryPool) MaxStdalloc() (int64, bool) {
	if p.maxStdalloc != nil {
		return *p.maxStdalloc, true
	}
	var zero int64
	return zero, false
}

func (p *GlusterMemoryPool) MustMaxStdalloc() int64 {
	if p.maxStdalloc == nil {
		panic("the maxStdalloc must not be nil, please use MaxStdalloc() function instead")
	}
	return *p.maxStdalloc
}

func (p *GlusterMemoryPool) SetName(attr string) {
	p.name = &attr
}

func (p *GlusterMemoryPool) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *GlusterMemoryPool) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *GlusterMemoryPool) SetPaddedSize(attr int64) {
	p.paddedSize = &attr
}

func (p *GlusterMemoryPool) PaddedSize() (int64, bool) {
	if p.paddedSize != nil {
		return *p.paddedSize, true
	}
	var zero int64
	return zero, false
}

func (p *GlusterMemoryPool) MustPaddedSize() int64 {
	if p.paddedSize == nil {
		panic("the paddedSize must not be nil, please use PaddedSize() function instead")
	}
	return *p.paddedSize
}

func (p *GlusterMemoryPool) SetPoolMisses(attr int64) {
	p.poolMisses = &attr
}

func (p *GlusterMemoryPool) PoolMisses() (int64, bool) {
	if p.poolMisses != nil {
		return *p.poolMisses, true
	}
	var zero int64
	return zero, false
}

func (p *GlusterMemoryPool) MustPoolMisses() int64 {
	if p.poolMisses == nil {
		panic("the poolMisses must not be nil, please use PoolMisses() function instead")
	}
	return *p.poolMisses
}

func (p *GlusterMemoryPool) SetType(attr string) {
	p.type_ = &attr
}

func (p *GlusterMemoryPool) Type() (string, bool) {
	if p.type_ != nil {
		return *p.type_, true
	}
	var zero string
	return zero, false
}

func (p *GlusterMemoryPool) MustType() string {
	if p.type_ == nil {
		panic("the type_ must not be nil, please use Type() function instead")
	}
	return *p.type_
}

type GlusterServerHook struct {
	Struct
	checksum    *string
	comment     *string
	contentType *HookContentType
	description *string
	host        *Host
	id          *string
	name        *string
	status      *GlusterHookStatus
}

func (p *GlusterServerHook) SetChecksum(attr string) {
	p.checksum = &attr
}

func (p *GlusterServerHook) Checksum() (string, bool) {
	if p.checksum != nil {
		return *p.checksum, true
	}
	var zero string
	return zero, false
}

func (p *GlusterServerHook) MustChecksum() string {
	if p.checksum == nil {
		panic("the checksum must not be nil, please use Checksum() function instead")
	}
	return *p.checksum
}

func (p *GlusterServerHook) SetComment(attr string) {
	p.comment = &attr
}

func (p *GlusterServerHook) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *GlusterServerHook) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

// SetContentType Represents content type of hook script.
func (p *GlusterServerHook) SetContentType(attr HookContentType) {
	p.contentType = &attr
}

// ContentType Represents content type of hook script.
func (p *GlusterServerHook) ContentType() (HookContentType, bool) {
	if p.contentType != nil {
		return *p.contentType, true
	}
	var zero HookContentType
	return zero, false
}

// MustContentType Represents content type of hook script.
func (p *GlusterServerHook) MustContentType() HookContentType {
	if p.contentType == nil {
		panic("the contentType must not be nil, please use ContentType() function instead")
	}
	return *p.contentType
}

func (p *GlusterServerHook) SetDescription(attr string) {
	p.description = &attr
}

func (p *GlusterServerHook) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *GlusterServerHook) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

// SetHost Type representing a host.
func (p *GlusterServerHook) SetHost(attr *Host) {
	p.host = attr
}

// Host Type representing a host.
func (p *GlusterServerHook) Host() (*Host, bool) {
	if p.host != nil {
		return p.host, true
	}
	return nil, false
}

// MustHost Type representing a host.
func (p *GlusterServerHook) MustHost() *Host {
	if p.host == nil {
		panic("the host must not be nil, please use Host() function instead")
	}
	return p.host
}

func (p *GlusterServerHook) SetId(attr string) {
	p.id = &attr
}

func (p *GlusterServerHook) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *GlusterServerHook) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *GlusterServerHook) SetName(attr string) {
	p.name = &attr
}

func (p *GlusterServerHook) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *GlusterServerHook) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *GlusterServerHook) SetStatus(attr GlusterHookStatus) {
	p.status = &attr
}

func (p *GlusterServerHook) Status() (GlusterHookStatus, bool) {
	if p.status != nil {
		return *p.status, true
	}
	var zero GlusterHookStatus
	return zero, false
}

func (p *GlusterServerHook) MustStatus() GlusterHookStatus {
	if p.status == nil {
		panic("the status must not be nil, please use Status() function instead")
	}
	return *p.status
}

type GlusterVolume struct {
	Struct
	bricks          *GlusterBrickSlice
	cluster         *Cluster
	comment         *string
	description     *string
	disperseCount   *int64
	id              *string
	name            *string
	options         *OptionSlice
	redundancyCount *int64
	replicaCount    *int64
	statistics      *StatisticSlice
	status          *GlusterVolumeStatus
	stripeCount     *int64
	transportTypes  []TransportType
	volumeType      *GlusterVolumeType
}

func (p *GlusterVolume) SetBricks(attr *GlusterBrickSlice) {
	p.bricks = attr
}

func (p *GlusterVolume) Bricks() (*GlusterBrickSlice, bool) {
	if p.bricks != nil {
		return p.bricks, true
	}
	return nil, false
}

func (p *GlusterVolume) MustBricks() *GlusterBrickSlice {
	if p.bricks == nil {
		panic("the bricks must not be nil, please use Bricks() function instead")
	}
	return p.bricks
}

// SetCluster Type representation of a cluster.
//
// A JSON representation of a cluster:
//
// [source]
// ----
// {
//   "cluster" : [ {
//     "ballooning_enabled" : "false",
//     "cpu" : {
//       "architecture" : "x86_64",
//       "type" : "Intel SandyBridge Family"
//     },
//     "custom_scheduling_policy_properties" : {
//       "property" : [ {
//         "name" : "HighUtilization",
//         "value" : "80"
//       }, {
//         "name" : "CpuOverCommitDurationMinutes",
//         "value" : "2"
//       } ]
//     },
//     "error_handling" : {
//       "on_error" : "migrate"
//     },
//     "fencing_policy" : {
//       "enabled" : "true",
//       "skip_if_connectivity_broken" : {
//         "enabled" : "false",
//         "threshold" : "50"
//       },
//       "skip_if_gluster_bricks_up" : "false",
//       "skip_if_gluster_quorum_not_met" : "false",
//       "skip_if_sd_active" : {
//         "enabled" : "false"
//       }
//     },
//     "gluster_service" : "false",
//     "firewall_type" : "iptables",
//     "ha_reservation" : "false",
//     "ksm" : {
//       "enabled" : "true",
//       "merge_across_nodes" : "true"
//     },
//     "memory_policy" : {
//       "over_commit" : {
//         "percent" : "100"
//       },
//       "transparent_hugepages" : {
//         "enabled" : "true"
//       }
//     },
//     "migration" : {
//       "auto_converge" : "inherit",
//       "bandwidth" : {
//         "assignment_method" : "auto"
//       },
//       "compressed" : "inherit",
//       "policy" : {
//         "id" : "00000000-0000-0000-0000-000000000000"
//       }
//     },
//     "required_rng_sources" : {
//       "required_rng_source" : [ "random" ]
//     },
//     "switch_type" : "legacy",
//     "threads_as_cores" : "false",
//     "trusted_service" : "false",
//     "tunnel_migration" : "false",
//     "version" : {
//       "major" : "4",
//       "minor" : "1"
//     },
//     "virt_service" : "true",
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "mac_pool" : {
//       "href" : "/ovirt-engine/api/macpools/456",
//       "id" : "456"
//     },
//     "scheduling_policy" : {
//       "href" : "/ovirt-engine/api/schedulingpolicies/789",
//       "id" : "789"
//     },
//     "actions" : {
//       "link" : [ {
//         "href" : "/ovirt-engine/api/clusters/234/resetemulatedmachine",
//         "rel" : "resetemulatedmachine"
//       } ]
//     },
//     "name" : "Default",
//     "description" : "The default server cluster",
//     "href" : "/ovirt-engine/api/clusters/234",
//     "id" : "234",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/clusters/234/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/cpuprofiles",
//       "rel" : "cpuprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networkfilters",
//       "rel" : "networkfilters"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networks",
//       "rel" : "networks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/affinitygroups",
//       "rel" : "affinitygroups"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glusterhooks",
//       "rel" : "glusterhooks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glustervolumes",
//       "rel" : "glustervolumes"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/enabledfeatures",
//       "rel" : "enabledfeatures"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/externalnetworkproviders",
//       "rel" : "externalnetworkproviders"
//     } ]
//   } ]
// }
// ----
func (p *GlusterVolume) SetCluster(attr *Cluster) {
	p.cluster = attr
}

// Cluster Type representation of a cluster.
//
// A JSON representation of a cluster:
//
// [source]
// ----
// {
//   "cluster" : [ {
//     "ballooning_enabled" : "false",
//     "cpu" : {
//       "architecture" : "x86_64",
//       "type" : "Intel SandyBridge Family"
//     },
//     "custom_scheduling_policy_properties" : {
//       "property" : [ {
//         "name" : "HighUtilization",
//         "value" : "80"
//       }, {
//         "name" : "CpuOverCommitDurationMinutes",
//         "value" : "2"
//       } ]
//     },
//     "error_handling" : {
//       "on_error" : "migrate"
//     },
//     "fencing_policy" : {
//       "enabled" : "true",
//       "skip_if_connectivity_broken" : {
//         "enabled" : "false",
//         "threshold" : "50"
//       },
//       "skip_if_gluster_bricks_up" : "false",
//       "skip_if_gluster_quorum_not_met" : "false",
//       "skip_if_sd_active" : {
//         "enabled" : "false"
//       }
//     },
//     "gluster_service" : "false",
//     "firewall_type" : "iptables",
//     "ha_reservation" : "false",
//     "ksm" : {
//       "enabled" : "true",
//       "merge_across_nodes" : "true"
//     },
//     "memory_policy" : {
//       "over_commit" : {
//         "percent" : "100"
//       },
//       "transparent_hugepages" : {
//         "enabled" : "true"
//       }
//     },
//     "migration" : {
//       "auto_converge" : "inherit",
//       "bandwidth" : {
//         "assignment_method" : "auto"
//       },
//       "compressed" : "inherit",
//       "policy" : {
//         "id" : "00000000-0000-0000-0000-000000000000"
//       }
//     },
//     "required_rng_sources" : {
//       "required_rng_source" : [ "random" ]
//     },
//     "switch_type" : "legacy",
//     "threads_as_cores" : "false",
//     "trusted_service" : "false",
//     "tunnel_migration" : "false",
//     "version" : {
//       "major" : "4",
//       "minor" : "1"
//     },
//     "virt_service" : "true",
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "mac_pool" : {
//       "href" : "/ovirt-engine/api/macpools/456",
//       "id" : "456"
//     },
//     "scheduling_policy" : {
//       "href" : "/ovirt-engine/api/schedulingpolicies/789",
//       "id" : "789"
//     },
//     "actions" : {
//       "link" : [ {
//         "href" : "/ovirt-engine/api/clusters/234/resetemulatedmachine",
//         "rel" : "resetemulatedmachine"
//       } ]
//     },
//     "name" : "Default",
//     "description" : "The default server cluster",
//     "href" : "/ovirt-engine/api/clusters/234",
//     "id" : "234",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/clusters/234/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/cpuprofiles",
//       "rel" : "cpuprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networkfilters",
//       "rel" : "networkfilters"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networks",
//       "rel" : "networks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/affinitygroups",
//       "rel" : "affinitygroups"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glusterhooks",
//       "rel" : "glusterhooks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glustervolumes",
//       "rel" : "glustervolumes"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/enabledfeatures",
//       "rel" : "enabledfeatures"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/externalnetworkproviders",
//       "rel" : "externalnetworkproviders"
//     } ]
//   } ]
// }
// ----
func (p *GlusterVolume) Cluster() (*Cluster, bool) {
	if p.cluster != nil {
		return p.cluster, true
	}
	return nil, false
}

// MustCluster Type representation of a cluster.
//
// A JSON representation of a cluster:
//
// [source]
// ----
// {
//   "cluster" : [ {
//     "ballooning_enabled" : "false",
//     "cpu" : {
//       "architecture" : "x86_64",
//       "type" : "Intel SandyBridge Family"
//     },
//     "custom_scheduling_policy_properties" : {
//       "property" : [ {
//         "name" : "HighUtilization",
//         "value" : "80"
//       }, {
//         "name" : "CpuOverCommitDurationMinutes",
//         "value" : "2"
//       } ]
//     },
//     "error_handling" : {
//       "on_error" : "migrate"
//     },
//     "fencing_policy" : {
//       "enabled" : "true",
//       "skip_if_connectivity_broken" : {
//         "enabled" : "false",
//         "threshold" : "50"
//       },
//       "skip_if_gluster_bricks_up" : "false",
//       "skip_if_gluster_quorum_not_met" : "false",
//       "skip_if_sd_active" : {
//         "enabled" : "false"
//       }
//     },
//     "gluster_service" : "false",
//     "firewall_type" : "iptables",
//     "ha_reservation" : "false",
//     "ksm" : {
//       "enabled" : "true",
//       "merge_across_nodes" : "true"
//     },
//     "memory_policy" : {
//       "over_commit" : {
//         "percent" : "100"
//       },
//       "transparent_hugepages" : {
//         "enabled" : "true"
//       }
//     },
//     "migration" : {
//       "auto_converge" : "inherit",
//       "bandwidth" : {
//         "assignment_method" : "auto"
//       },
//       "compressed" : "inherit",
//       "policy" : {
//         "id" : "00000000-0000-0000-0000-000000000000"
//       }
//     },
//     "required_rng_sources" : {
//       "required_rng_source" : [ "random" ]
//     },
//     "switch_type" : "legacy",
//     "threads_as_cores" : "false",
//     "trusted_service" : "false",
//     "tunnel_migration" : "false",
//     "version" : {
//       "major" : "4",
//       "minor" : "1"
//     },
//     "virt_service" : "true",
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "mac_pool" : {
//       "href" : "/ovirt-engine/api/macpools/456",
//       "id" : "456"
//     },
//     "scheduling_policy" : {
//       "href" : "/ovirt-engine/api/schedulingpolicies/789",
//       "id" : "789"
//     },
//     "actions" : {
//       "link" : [ {
//         "href" : "/ovirt-engine/api/clusters/234/resetemulatedmachine",
//         "rel" : "resetemulatedmachine"
//       } ]
//     },
//     "name" : "Default",
//     "description" : "The default server cluster",
//     "href" : "/ovirt-engine/api/clusters/234",
//     "id" : "234",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/clusters/234/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/cpuprofiles",
//       "rel" : "cpuprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networkfilters",
//       "rel" : "networkfilters"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networks",
//       "rel" : "networks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/affinitygroups",
//       "rel" : "affinitygroups"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glusterhooks",
//       "rel" : "glusterhooks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glustervolumes",
//       "rel" : "glustervolumes"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/enabledfeatures",
//       "rel" : "enabledfeatures"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/externalnetworkproviders",
//       "rel" : "externalnetworkproviders"
//     } ]
//   } ]
// }
// ----
func (p *GlusterVolume) MustCluster() *Cluster {
	if p.cluster == nil {
		panic("the cluster must not be nil, please use Cluster() function instead")
	}
	return p.cluster
}

func (p *GlusterVolume) SetComment(attr string) {
	p.comment = &attr
}

func (p *GlusterVolume) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *GlusterVolume) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *GlusterVolume) SetDescription(attr string) {
	p.description = &attr
}

func (p *GlusterVolume) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *GlusterVolume) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *GlusterVolume) SetDisperseCount(attr int64) {
	p.disperseCount = &attr
}

func (p *GlusterVolume) DisperseCount() (int64, bool) {
	if p.disperseCount != nil {
		return *p.disperseCount, true
	}
	var zero int64
	return zero, false
}

func (p *GlusterVolume) MustDisperseCount() int64 {
	if p.disperseCount == nil {
		panic("the disperseCount must not be nil, please use DisperseCount() function instead")
	}
	return *p.disperseCount
}

func (p *GlusterVolume) SetId(attr string) {
	p.id = &attr
}

func (p *GlusterVolume) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *GlusterVolume) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *GlusterVolume) SetName(attr string) {
	p.name = &attr
}

func (p *GlusterVolume) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *GlusterVolume) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *GlusterVolume) SetOptions(attr *OptionSlice) {
	p.options = attr
}

func (p *GlusterVolume) Options() (*OptionSlice, bool) {
	if p.options != nil {
		return p.options, true
	}
	return nil, false
}

func (p *GlusterVolume) MustOptions() *OptionSlice {
	if p.options == nil {
		panic("the options must not be nil, please use Options() function instead")
	}
	return p.options
}

func (p *GlusterVolume) SetRedundancyCount(attr int64) {
	p.redundancyCount = &attr
}

func (p *GlusterVolume) RedundancyCount() (int64, bool) {
	if p.redundancyCount != nil {
		return *p.redundancyCount, true
	}
	var zero int64
	return zero, false
}

func (p *GlusterVolume) MustRedundancyCount() int64 {
	if p.redundancyCount == nil {
		panic("the redundancyCount must not be nil, please use RedundancyCount() function instead")
	}
	return *p.redundancyCount
}

func (p *GlusterVolume) SetReplicaCount(attr int64) {
	p.replicaCount = &attr
}

func (p *GlusterVolume) ReplicaCount() (int64, bool) {
	if p.replicaCount != nil {
		return *p.replicaCount, true
	}
	var zero int64
	return zero, false
}

func (p *GlusterVolume) MustReplicaCount() int64 {
	if p.replicaCount == nil {
		panic("the replicaCount must not be nil, please use ReplicaCount() function instead")
	}
	return *p.replicaCount
}

func (p *GlusterVolume) SetStatistics(attr *StatisticSlice) {
	p.statistics = attr
}

func (p *GlusterVolume) Statistics() (*StatisticSlice, bool) {
	if p.statistics != nil {
		return p.statistics, true
	}
	return nil, false
}

func (p *GlusterVolume) MustStatistics() *StatisticSlice {
	if p.statistics == nil {
		panic("the statistics must not be nil, please use Statistics() function instead")
	}
	return p.statistics
}

func (p *GlusterVolume) SetStatus(attr GlusterVolumeStatus) {
	p.status = &attr
}

func (p *GlusterVolume) Status() (GlusterVolumeStatus, bool) {
	if p.status != nil {
		return *p.status, true
	}
	var zero GlusterVolumeStatus
	return zero, false
}

func (p *GlusterVolume) MustStatus() GlusterVolumeStatus {
	if p.status == nil {
		panic("the status must not be nil, please use Status() function instead")
	}
	return *p.status
}

func (p *GlusterVolume) SetStripeCount(attr int64) {
	p.stripeCount = &attr
}

func (p *GlusterVolume) StripeCount() (int64, bool) {
	if p.stripeCount != nil {
		return *p.stripeCount, true
	}
	var zero int64
	return zero, false
}

func (p *GlusterVolume) MustStripeCount() int64 {
	if p.stripeCount == nil {
		panic("the stripeCount must not be nil, please use StripeCount() function instead")
	}
	return *p.stripeCount
}

func (p *GlusterVolume) SetTransportTypes(attr []TransportType) {
	p.transportTypes = attr
}

func (p *GlusterVolume) TransportTypes() ([]TransportType, bool) {
	if p.transportTypes != nil {
		return p.transportTypes, true
	}
	return nil, false
}

func (p *GlusterVolume) MustTransportTypes() []TransportType {
	if p.transportTypes == nil {
		panic("the transportTypes must not be nil, please use TransportTypes() function instead")
	}
	return p.transportTypes
}

// SetVolumeType Type representing the type of Gluster Volume.
func (p *GlusterVolume) SetVolumeType(attr GlusterVolumeType) {
	p.volumeType = &attr
}

// VolumeType Type representing the type of Gluster Volume.
func (p *GlusterVolume) VolumeType() (GlusterVolumeType, bool) {
	if p.volumeType != nil {
		return *p.volumeType, true
	}
	var zero GlusterVolumeType
	return zero, false
}

// MustVolumeType Type representing the type of Gluster Volume.
func (p *GlusterVolume) MustVolumeType() GlusterVolumeType {
	if p.volumeType == nil {
		panic("the volumeType must not be nil, please use VolumeType() function instead")
	}
	return *p.volumeType
}

type GlusterVolumeProfileDetails struct {
	Struct
	brickProfileDetails *BrickProfileDetailSlice
	comment             *string
	description         *string
	id                  *string
	name                *string
	nfsProfileDetails   *NfsProfileDetailSlice
}

func (p *GlusterVolumeProfileDetails) SetBrickProfileDetails(attr *BrickProfileDetailSlice) {
	p.brickProfileDetails = attr
}

func (p *GlusterVolumeProfileDetails) BrickProfileDetails() (*BrickProfileDetailSlice, bool) {
	if p.brickProfileDetails != nil {
		return p.brickProfileDetails, true
	}
	return nil, false
}

func (p *GlusterVolumeProfileDetails) MustBrickProfileDetails() *BrickProfileDetailSlice {
	if p.brickProfileDetails == nil {
		panic("the brickProfileDetails must not be nil, please use BrickProfileDetails() function instead")
	}
	return p.brickProfileDetails
}

func (p *GlusterVolumeProfileDetails) SetComment(attr string) {
	p.comment = &attr
}

func (p *GlusterVolumeProfileDetails) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *GlusterVolumeProfileDetails) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *GlusterVolumeProfileDetails) SetDescription(attr string) {
	p.description = &attr
}

func (p *GlusterVolumeProfileDetails) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *GlusterVolumeProfileDetails) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *GlusterVolumeProfileDetails) SetId(attr string) {
	p.id = &attr
}

func (p *GlusterVolumeProfileDetails) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *GlusterVolumeProfileDetails) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *GlusterVolumeProfileDetails) SetName(attr string) {
	p.name = &attr
}

func (p *GlusterVolumeProfileDetails) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *GlusterVolumeProfileDetails) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *GlusterVolumeProfileDetails) SetNfsProfileDetails(attr *NfsProfileDetailSlice) {
	p.nfsProfileDetails = attr
}

func (p *GlusterVolumeProfileDetails) NfsProfileDetails() (*NfsProfileDetailSlice, bool) {
	if p.nfsProfileDetails != nil {
		return p.nfsProfileDetails, true
	}
	return nil, false
}

func (p *GlusterVolumeProfileDetails) MustNfsProfileDetails() *NfsProfileDetailSlice {
	if p.nfsProfileDetails == nil {
		panic("the nfsProfileDetails must not be nil, please use NfsProfileDetails() function instead")
	}
	return p.nfsProfileDetails
}

type GraphicsConsole struct {
	Struct
	address      *string
	comment      *string
	description  *string
	id           *string
	instanceType *InstanceType
	name         *string
	port         *int64
	protocol     *GraphicsType
	template     *Template
	tlsPort      *int64
	vm           *Vm
}

func (p *GraphicsConsole) SetAddress(attr string) {
	p.address = &attr
}

func (p *GraphicsConsole) Address() (string, bool) {
	if p.address != nil {
		return *p.address, true
	}
	var zero string
	return zero, false
}

func (p *GraphicsConsole) MustAddress() string {
	if p.address == nil {
		panic("the address must not be nil, please use Address() function instead")
	}
	return *p.address
}

func (p *GraphicsConsole) SetComment(attr string) {
	p.comment = &attr
}

func (p *GraphicsConsole) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *GraphicsConsole) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *GraphicsConsole) SetDescription(attr string) {
	p.description = &attr
}

func (p *GraphicsConsole) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *GraphicsConsole) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *GraphicsConsole) SetId(attr string) {
	p.id = &attr
}

func (p *GraphicsConsole) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *GraphicsConsole) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

// SetInstanceType Describes the hardware configuration of virtual machines.
//
// For example `medium` instance type includes 1 virtual CPU and 4 GiB of memory. It is a top-level
// entity (e.g. not bound to any data center or cluster). The attributes that are used for instance
// types and are common to virtual machine and template types are:
//
// - `console`
// - `cpu`
// - `custom_cpu_model`
// - `custom_emulated_machine`
// - `display`
// - `high_availability`
// - `io`
// - `memory`
// - `memory_policy`
// - `migration`
// - `migration_downtime`
// - `os`
// - `rng_device`
// - `soundcard_enabled`
// - `usb`
// - `virtio_scsi`
//
// When creating a virtual machine from both an instance type and a template, the virtual machine
// will inherit the hardware configurations from the instance type
//
// NOTE: An instance type inherits it's attributes from the template entity although most template
// attributes are not used in instance types.
func (p *GraphicsConsole) SetInstanceType(attr *InstanceType) {
	p.instanceType = attr
}

// InstanceType Describes the hardware configuration of virtual machines.
//
// For example `medium` instance type includes 1 virtual CPU and 4 GiB of memory. It is a top-level
// entity (e.g. not bound to any data center or cluster). The attributes that are used for instance
// types and are common to virtual machine and template types are:
//
// - `console`
// - `cpu`
// - `custom_cpu_model`
// - `custom_emulated_machine`
// - `display`
// - `high_availability`
// - `io`
// - `memory`
// - `memory_policy`
// - `migration`
// - `migration_downtime`
// - `os`
// - `rng_device`
// - `soundcard_enabled`
// - `usb`
// - `virtio_scsi`
//
// When creating a virtual machine from both an instance type and a template, the virtual machine
// will inherit the hardware configurations from the instance type
//
// NOTE: An instance type inherits it's attributes from the template entity although most template
// attributes are not used in instance types.
func (p *GraphicsConsole) InstanceType() (*InstanceType, bool) {
	if p.instanceType != nil {
		return p.instanceType, true
	}
	return nil, false
}

// MustInstanceType Describes the hardware configuration of virtual machines.
//
// For example `medium` instance type includes 1 virtual CPU and 4 GiB of memory. It is a top-level
// entity (e.g. not bound to any data center or cluster). The attributes that are used for instance
// types and are common to virtual machine and template types are:
//
// - `console`
// - `cpu`
// - `custom_cpu_model`
// - `custom_emulated_machine`
// - `display`
// - `high_availability`
// - `io`
// - `memory`
// - `memory_policy`
// - `migration`
// - `migration_downtime`
// - `os`
// - `rng_device`
// - `soundcard_enabled`
// - `usb`
// - `virtio_scsi`
//
// When creating a virtual machine from both an instance type and a template, the virtual machine
// will inherit the hardware configurations from the instance type
//
// NOTE: An instance type inherits it's attributes from the template entity although most template
// attributes are not used in instance types.
func (p *GraphicsConsole) MustInstanceType() *InstanceType {
	if p.instanceType == nil {
		panic("the instanceType must not be nil, please use InstanceType() function instead")
	}
	return p.instanceType
}

func (p *GraphicsConsole) SetName(attr string) {
	p.name = &attr
}

func (p *GraphicsConsole) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *GraphicsConsole) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *GraphicsConsole) SetPort(attr int64) {
	p.port = &attr
}

func (p *GraphicsConsole) Port() (int64, bool) {
	if p.port != nil {
		return *p.port, true
	}
	var zero int64
	return zero, false
}

func (p *GraphicsConsole) MustPort() int64 {
	if p.port == nil {
		panic("the port must not be nil, please use Port() function instead")
	}
	return *p.port
}

// SetProtocol The graphics protocol used to connect to the graphic console.
func (p *GraphicsConsole) SetProtocol(attr GraphicsType) {
	p.protocol = &attr
}

// Protocol The graphics protocol used to connect to the graphic console.
func (p *GraphicsConsole) Protocol() (GraphicsType, bool) {
	if p.protocol != nil {
		return *p.protocol, true
	}
	var zero GraphicsType
	return zero, false
}

// MustProtocol The graphics protocol used to connect to the graphic console.
func (p *GraphicsConsole) MustProtocol() GraphicsType {
	if p.protocol == nil {
		panic("the protocol must not be nil, please use Protocol() function instead")
	}
	return *p.protocol
}

// SetTemplate The type that represents a virtual machine template.
// Templates allow for a rapid instantiation of virtual machines with common configuration and disk states.
func (p *GraphicsConsole) SetTemplate(attr *Template) {
	p.template = attr
}

// Template The type that represents a virtual machine template.
// Templates allow for a rapid instantiation of virtual machines with common configuration and disk states.
func (p *GraphicsConsole) Template() (*Template, bool) {
	if p.template != nil {
		return p.template, true
	}
	return nil, false
}

// MustTemplate The type that represents a virtual machine template.
// Templates allow for a rapid instantiation of virtual machines with common configuration and disk states.
func (p *GraphicsConsole) MustTemplate() *Template {
	if p.template == nil {
		panic("the template must not be nil, please use Template() function instead")
	}
	return p.template
}

func (p *GraphicsConsole) SetTlsPort(attr int64) {
	p.tlsPort = &attr
}

func (p *GraphicsConsole) TlsPort() (int64, bool) {
	if p.tlsPort != nil {
		return *p.tlsPort, true
	}
	var zero int64
	return zero, false
}

func (p *GraphicsConsole) MustTlsPort() int64 {
	if p.tlsPort == nil {
		panic("the tlsPort must not be nil, please use TlsPort() function instead")
	}
	return *p.tlsPort
}

// SetVm Represents a virtual machine.
func (p *GraphicsConsole) SetVm(attr *Vm) {
	p.vm = attr
}

// Vm Represents a virtual machine.
func (p *GraphicsConsole) Vm() (*Vm, bool) {
	if p.vm != nil {
		return p.vm, true
	}
	return nil, false
}

// MustVm Represents a virtual machine.
func (p *GraphicsConsole) MustVm() *Vm {
	if p.vm == nil {
		panic("the vm must not be nil, please use Vm() function instead")
	}
	return p.vm
}

// Group This type represents all groups in the directory service.
type Group struct {
	Struct
	comment       *string
	description   *string
	domain        *Domain
	domainEntryId *string
	id            *string
	name          *string
	namespace     *string
	permissions   *PermissionSlice
	roles         *RoleSlice
	tags          *TagSlice
}

func (p *Group) SetComment(attr string) {
	p.comment = &attr
}

func (p *Group) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *Group) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *Group) SetDescription(attr string) {
	p.description = &attr
}

func (p *Group) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *Group) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

// SetDomain This type represents a directory service domain.
func (p *Group) SetDomain(attr *Domain) {
	p.domain = attr
}

// Domain This type represents a directory service domain.
func (p *Group) Domain() (*Domain, bool) {
	if p.domain != nil {
		return p.domain, true
	}
	return nil, false
}

// MustDomain This type represents a directory service domain.
func (p *Group) MustDomain() *Domain {
	if p.domain == nil {
		panic("the domain must not be nil, please use Domain() function instead")
	}
	return p.domain
}

func (p *Group) SetDomainEntryId(attr string) {
	p.domainEntryId = &attr
}

func (p *Group) DomainEntryId() (string, bool) {
	if p.domainEntryId != nil {
		return *p.domainEntryId, true
	}
	var zero string
	return zero, false
}

func (p *Group) MustDomainEntryId() string {
	if p.domainEntryId == nil {
		panic("the domainEntryId must not be nil, please use DomainEntryId() function instead")
	}
	return *p.domainEntryId
}

func (p *Group) SetId(attr string) {
	p.id = &attr
}

func (p *Group) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *Group) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *Group) SetName(attr string) {
	p.name = &attr
}

func (p *Group) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *Group) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *Group) SetNamespace(attr string) {
	p.namespace = &attr
}

func (p *Group) Namespace() (string, bool) {
	if p.namespace != nil {
		return *p.namespace, true
	}
	var zero string
	return zero, false
}

func (p *Group) MustNamespace() string {
	if p.namespace == nil {
		panic("the namespace must not be nil, please use Namespace() function instead")
	}
	return *p.namespace
}

func (p *Group) SetPermissions(attr *PermissionSlice) {
	p.permissions = attr
}

func (p *Group) Permissions() (*PermissionSlice, bool) {
	if p.permissions != nil {
		return p.permissions, true
	}
	return nil, false
}

func (p *Group) MustPermissions() *PermissionSlice {
	if p.permissions == nil {
		panic("the permissions must not be nil, please use Permissions() function instead")
	}
	return p.permissions
}

func (p *Group) SetRoles(attr *RoleSlice) {
	p.roles = attr
}

func (p *Group) Roles() (*RoleSlice, bool) {
	if p.roles != nil {
		return p.roles, true
	}
	return nil, false
}

func (p *Group) MustRoles() *RoleSlice {
	if p.roles == nil {
		panic("the roles must not be nil, please use Roles() function instead")
	}
	return p.roles
}

func (p *Group) SetTags(attr *TagSlice) {
	p.tags = attr
}

func (p *Group) Tags() (*TagSlice, bool) {
	if p.tags != nil {
		return p.tags, true
	}
	return nil, false
}

func (p *Group) MustTags() *TagSlice {
	if p.tags == nil {
		panic("the tags must not be nil, please use Tags() function instead")
	}
	return p.tags
}

// GuestOperatingSystem Represents an operating system installed on the virtual machine.
//
// To get that information send a request like this:
//
// ....
// GET /ovirt-engine/api/vms/123
// ....
//
// The result will be like this:
//
// [source,xml]
// ----
// <vm href="/ovirt-engine/api/vms/123" id="123">
// ...
//   <guest_operating_system>
//     <architecture>x86_64</architecture>
//     <codename>Maipo</codename>
//     <distribution>Red Hat Enterprise Linux Server</distribution>
//     <family>Linux</family>
//     <kernel>
//       <version>
//         <build>0</build>
//         <full_version>3.10.0-514.10.2.el7.x86_64</full_version>
//         <major>3</major>
//         <minor>10</minor>
//         <revision>514</revision>
//       </version>
//     </kernel>
//     <version>
//       <full_version>7.3</full_version>
//       <major>7</major>
//       <minor>3</minor>
//     </version>
//   </guest_operating_system>
// </vm>
// ----
type GuestOperatingSystem struct {
	Struct
	architecture *string
	codename     *string
	distribution *string
	family       *string
	kernel       *Kernel
	version      *Version
}

func (p *GuestOperatingSystem) SetArchitecture(attr string) {
	p.architecture = &attr
}

func (p *GuestOperatingSystem) Architecture() (string, bool) {
	if p.architecture != nil {
		return *p.architecture, true
	}
	var zero string
	return zero, false
}

func (p *GuestOperatingSystem) MustArchitecture() string {
	if p.architecture == nil {
		panic("the architecture must not be nil, please use Architecture() function instead")
	}
	return *p.architecture
}

func (p *GuestOperatingSystem) SetCodename(attr string) {
	p.codename = &attr
}

func (p *GuestOperatingSystem) Codename() (string, bool) {
	if p.codename != nil {
		return *p.codename, true
	}
	var zero string
	return zero, false
}

func (p *GuestOperatingSystem) MustCodename() string {
	if p.codename == nil {
		panic("the codename must not be nil, please use Codename() function instead")
	}
	return *p.codename
}

func (p *GuestOperatingSystem) SetDistribution(attr string) {
	p.distribution = &attr
}

func (p *GuestOperatingSystem) Distribution() (string, bool) {
	if p.distribution != nil {
		return *p.distribution, true
	}
	var zero string
	return zero, false
}

func (p *GuestOperatingSystem) MustDistribution() string {
	if p.distribution == nil {
		panic("the distribution must not be nil, please use Distribution() function instead")
	}
	return *p.distribution
}

func (p *GuestOperatingSystem) SetFamily(attr string) {
	p.family = &attr
}

func (p *GuestOperatingSystem) Family() (string, bool) {
	if p.family != nil {
		return *p.family, true
	}
	var zero string
	return zero, false
}

func (p *GuestOperatingSystem) MustFamily() string {
	if p.family == nil {
		panic("the family must not be nil, please use Family() function instead")
	}
	return *p.family
}

func (p *GuestOperatingSystem) SetKernel(attr *Kernel) {
	p.kernel = attr
}

func (p *GuestOperatingSystem) Kernel() (*Kernel, bool) {
	if p.kernel != nil {
		return p.kernel, true
	}
	return nil, false
}

func (p *GuestOperatingSystem) MustKernel() *Kernel {
	if p.kernel == nil {
		panic("the kernel must not be nil, please use Kernel() function instead")
	}
	return p.kernel
}

func (p *GuestOperatingSystem) SetVersion(attr *Version) {
	p.version = attr
}

func (p *GuestOperatingSystem) Version() (*Version, bool) {
	if p.version != nil {
		return p.version, true
	}
	return nil, false
}

func (p *GuestOperatingSystem) MustVersion() *Version {
	if p.version == nil {
		panic("the version must not be nil, please use Version() function instead")
	}
	return p.version
}

// HardwareInformation Represents hardware information of host.
//
// To get that information send a request like this:
//
// ....
// GET /ovirt-engine/api/hosts/123
// ....
//
// The result will be like this:
//
// [source,xml]
// ----
// <host href="/ovirt-engine/api/hosts/123" id="123">
//   ...
//   <hardware_information>
//     <family>Red Hat Enterprise Linux</family>
//     <manufacturer>Red Hat</manufacturer>
//     <product_name>RHEV Hypervisor</product_name>
//     <serial_number>01234567-89AB-CDEF-0123-456789ABCDEF</serial_number>
//     <supported_rng_sources>
//       <supported_rng_source>random</supported_rng_source>
//     </supported_rng_sources>
//     <uuid>12345678-9ABC-DEF0-1234-56789ABCDEF0</uuid>
//     <version>1.2-34.5.el7ev</version>
//   </hardware_information>
//   ...
// </application>
// ----
type HardwareInformation struct {
	Struct
	family              *string
	manufacturer        *string
	productName         *string
	serialNumber        *string
	supportedRngSources []RngSource
	uuid                *string
	version             *string
}

func (p *HardwareInformation) SetFamily(attr string) {
	p.family = &attr
}

func (p *HardwareInformation) Family() (string, bool) {
	if p.family != nil {
		return *p.family, true
	}
	var zero string
	return zero, false
}

func (p *HardwareInformation) MustFamily() string {
	if p.family == nil {
		panic("the family must not be nil, please use Family() function instead")
	}
	return *p.family
}

func (p *HardwareInformation) SetManufacturer(attr string) {
	p.manufacturer = &attr
}

func (p *HardwareInformation) Manufacturer() (string, bool) {
	if p.manufacturer != nil {
		return *p.manufacturer, true
	}
	var zero string
	return zero, false
}

func (p *HardwareInformation) MustManufacturer() string {
	if p.manufacturer == nil {
		panic("the manufacturer must not be nil, please use Manufacturer() function instead")
	}
	return *p.manufacturer
}

func (p *HardwareInformation) SetProductName(attr string) {
	p.productName = &attr
}

func (p *HardwareInformation) ProductName() (string, bool) {
	if p.productName != nil {
		return *p.productName, true
	}
	var zero string
	return zero, false
}

func (p *HardwareInformation) MustProductName() string {
	if p.productName == nil {
		panic("the productName must not be nil, please use ProductName() function instead")
	}
	return *p.productName
}

func (p *HardwareInformation) SetSerialNumber(attr string) {
	p.serialNumber = &attr
}

func (p *HardwareInformation) SerialNumber() (string, bool) {
	if p.serialNumber != nil {
		return *p.serialNumber, true
	}
	var zero string
	return zero, false
}

func (p *HardwareInformation) MustSerialNumber() string {
	if p.serialNumber == nil {
		panic("the serialNumber must not be nil, please use SerialNumber() function instead")
	}
	return *p.serialNumber
}

func (p *HardwareInformation) SetSupportedRngSources(attr []RngSource) {
	p.supportedRngSources = attr
}

func (p *HardwareInformation) SupportedRngSources() ([]RngSource, bool) {
	if p.supportedRngSources != nil {
		return p.supportedRngSources, true
	}
	return nil, false
}

func (p *HardwareInformation) MustSupportedRngSources() []RngSource {
	if p.supportedRngSources == nil {
		panic("the supportedRngSources must not be nil, please use SupportedRngSources() function instead")
	}
	return p.supportedRngSources
}

func (p *HardwareInformation) SetUuid(attr string) {
	p.uuid = &attr
}

func (p *HardwareInformation) Uuid() (string, bool) {
	if p.uuid != nil {
		return *p.uuid, true
	}
	var zero string
	return zero, false
}

func (p *HardwareInformation) MustUuid() string {
	if p.uuid == nil {
		panic("the uuid must not be nil, please use Uuid() function instead")
	}
	return *p.uuid
}

func (p *HardwareInformation) SetVersion(attr string) {
	p.version = &attr
}

func (p *HardwareInformation) Version() (string, bool) {
	if p.version != nil {
		return *p.version, true
	}
	var zero string
	return zero, false
}

func (p *HardwareInformation) MustVersion() string {
	if p.version == nil {
		panic("the version must not be nil, please use Version() function instead")
	}
	return *p.version
}

// HighAvailability Type representing high availability of a virtual machine.
type HighAvailability struct {
	Struct
	enabled  *bool
	priority *int64
}

func (p *HighAvailability) SetEnabled(attr bool) {
	p.enabled = &attr
}

func (p *HighAvailability) Enabled() (bool, bool) {
	if p.enabled != nil {
		return *p.enabled, true
	}
	var zero bool
	return zero, false
}

func (p *HighAvailability) MustEnabled() bool {
	if p.enabled == nil {
		panic("the enabled must not be nil, please use Enabled() function instead")
	}
	return *p.enabled
}

func (p *HighAvailability) SetPriority(attr int64) {
	p.priority = &attr
}

func (p *HighAvailability) Priority() (int64, bool) {
	if p.priority != nil {
		return *p.priority, true
	}
	var zero int64
	return zero, false
}

func (p *HighAvailability) MustPriority() int64 {
	if p.priority == nil {
		panic("the priority must not be nil, please use Priority() function instead")
	}
	return *p.priority
}

// Hook Represents a hook.
type Hook struct {
	Struct
	comment     *string
	description *string
	eventName   *string
	host        *Host
	id          *string
	md5         *string
	name        *string
}

func (p *Hook) SetComment(attr string) {
	p.comment = &attr
}

func (p *Hook) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *Hook) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *Hook) SetDescription(attr string) {
	p.description = &attr
}

func (p *Hook) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *Hook) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *Hook) SetEventName(attr string) {
	p.eventName = &attr
}

func (p *Hook) EventName() (string, bool) {
	if p.eventName != nil {
		return *p.eventName, true
	}
	var zero string
	return zero, false
}

func (p *Hook) MustEventName() string {
	if p.eventName == nil {
		panic("the eventName must not be nil, please use EventName() function instead")
	}
	return *p.eventName
}

// SetHost Type representing a host.
func (p *Hook) SetHost(attr *Host) {
	p.host = attr
}

// Host Type representing a host.
func (p *Hook) Host() (*Host, bool) {
	if p.host != nil {
		return p.host, true
	}
	return nil, false
}

// MustHost Type representing a host.
func (p *Hook) MustHost() *Host {
	if p.host == nil {
		panic("the host must not be nil, please use Host() function instead")
	}
	return p.host
}

func (p *Hook) SetId(attr string) {
	p.id = &attr
}

func (p *Hook) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *Hook) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *Hook) SetMd5(attr string) {
	p.md5 = &attr
}

func (p *Hook) Md5() (string, bool) {
	if p.md5 != nil {
		return *p.md5, true
	}
	var zero string
	return zero, false
}

func (p *Hook) MustMd5() string {
	if p.md5 == nil {
		panic("the md5 must not be nil, please use Md5() function instead")
	}
	return *p.md5
}

func (p *Hook) SetName(attr string) {
	p.name = &attr
}

func (p *Hook) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *Hook) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

// Host Type representing a host.
type Host struct {
	Struct
	address                               *string
	affinityLabels                        *AffinityLabelSlice
	agents                                *AgentSlice
	autoNumaStatus                        *AutoNumaStatus
	certificate                           *Certificate
	cluster                               *Cluster
	comment                               *string
	cpu                                   *Cpu
	description                           *string
	devicePassthrough                     *HostDevicePassthrough
	devices                               *HostDeviceSlice
	display                               *Display
	externalHostProvider                  *ExternalHostProvider
	externalNetworkProviderConfigurations *ExternalNetworkProviderConfigurationSlice
	externalStatus                        *ExternalStatus
	hardwareInformation                   *HardwareInformation
	hooks                                 *HookSlice
	hostedEngine                          *HostedEngine
	id                                    *string
	iscsi                                 *IscsiDetails
	katelloErrata                         *KatelloErratumSlice
	kdumpStatus                           *KdumpStatus
	ksm                                   *Ksm
	libvirtVersion                        *Version
	maxSchedulingMemory                   *int64
	memory                                *int64
	name                                  *string
	networkAttachments                    *NetworkAttachmentSlice
	networkOperationInProgress            *bool
	nics                                  *HostNicSlice
	numaNodes                             *NumaNodeSlice
	numaSupported                         *bool
	os                                    *OperatingSystem
	overrideIptables                      *bool
	permissions                           *PermissionSlice
	port                                  *int64
	powerManagement                       *PowerManagement
	protocol                              *HostProtocol
	reinstallationRequired                *bool
	rootPassword                          *string
	seLinux                               *SeLinux
	spm                                   *Spm
	ssh                                   *Ssh
	statistics                            *StatisticSlice
	status                                *HostStatus
	statusDetail                          *string
	storageConnectionExtensions           *StorageConnectionExtensionSlice
	storages                              *HostStorageSlice
	summary                               *VmSummary
	tags                                  *TagSlice
	transparentHugePages                  *TransparentHugePages
	type_                                 *HostType
	unmanagedNetworks                     *UnmanagedNetworkSlice
	updateAvailable                       *bool
	version                               *Version
	vgpuPlacement                         *VgpuPlacement
}

func (p *Host) SetAddress(attr string) {
	p.address = &attr
}

func (p *Host) Address() (string, bool) {
	if p.address != nil {
		return *p.address, true
	}
	var zero string
	return zero, false
}

func (p *Host) MustAddress() string {
	if p.address == nil {
		panic("the address must not be nil, please use Address() function instead")
	}
	return *p.address
}

func (p *Host) SetAffinityLabels(attr *AffinityLabelSlice) {
	p.affinityLabels = attr
}

func (p *Host) AffinityLabels() (*AffinityLabelSlice, bool) {
	if p.affinityLabels != nil {
		return p.affinityLabels, true
	}
	return nil, false
}

func (p *Host) MustAffinityLabels() *AffinityLabelSlice {
	if p.affinityLabels == nil {
		panic("the affinityLabels must not be nil, please use AffinityLabels() function instead")
	}
	return p.affinityLabels
}

func (p *Host) SetAgents(attr *AgentSlice) {
	p.agents = attr
}

func (p *Host) Agents() (*AgentSlice, bool) {
	if p.agents != nil {
		return p.agents, true
	}
	return nil, false
}

func (p *Host) MustAgents() *AgentSlice {
	if p.agents == nil {
		panic("the agents must not be nil, please use Agents() function instead")
	}
	return p.agents
}

func (p *Host) SetAutoNumaStatus(attr AutoNumaStatus) {
	p.autoNumaStatus = &attr
}

func (p *Host) AutoNumaStatus() (AutoNumaStatus, bool) {
	if p.autoNumaStatus != nil {
		return *p.autoNumaStatus, true
	}
	var zero AutoNumaStatus
	return zero, false
}

func (p *Host) MustAutoNumaStatus() AutoNumaStatus {
	if p.autoNumaStatus == nil {
		panic("the autoNumaStatus must not be nil, please use AutoNumaStatus() function instead")
	}
	return *p.autoNumaStatus
}

func (p *Host) SetCertificate(attr *Certificate) {
	p.certificate = attr
}

func (p *Host) Certificate() (*Certificate, bool) {
	if p.certificate != nil {
		return p.certificate, true
	}
	return nil, false
}

func (p *Host) MustCertificate() *Certificate {
	if p.certificate == nil {
		panic("the certificate must not be nil, please use Certificate() function instead")
	}
	return p.certificate
}

// SetCluster Type representation of a cluster.
//
// A JSON representation of a cluster:
//
// [source]
// ----
// {
//   "cluster" : [ {
//     "ballooning_enabled" : "false",
//     "cpu" : {
//       "architecture" : "x86_64",
//       "type" : "Intel SandyBridge Family"
//     },
//     "custom_scheduling_policy_properties" : {
//       "property" : [ {
//         "name" : "HighUtilization",
//         "value" : "80"
//       }, {
//         "name" : "CpuOverCommitDurationMinutes",
//         "value" : "2"
//       } ]
//     },
//     "error_handling" : {
//       "on_error" : "migrate"
//     },
//     "fencing_policy" : {
//       "enabled" : "true",
//       "skip_if_connectivity_broken" : {
//         "enabled" : "false",
//         "threshold" : "50"
//       },
//       "skip_if_gluster_bricks_up" : "false",
//       "skip_if_gluster_quorum_not_met" : "false",
//       "skip_if_sd_active" : {
//         "enabled" : "false"
//       }
//     },
//     "gluster_service" : "false",
//     "firewall_type" : "iptables",
//     "ha_reservation" : "false",
//     "ksm" : {
//       "enabled" : "true",
//       "merge_across_nodes" : "true"
//     },
//     "memory_policy" : {
//       "over_commit" : {
//         "percent" : "100"
//       },
//       "transparent_hugepages" : {
//         "enabled" : "true"
//       }
//     },
//     "migration" : {
//       "auto_converge" : "inherit",
//       "bandwidth" : {
//         "assignment_method" : "auto"
//       },
//       "compressed" : "inherit",
//       "policy" : {
//         "id" : "00000000-0000-0000-0000-000000000000"
//       }
//     },
//     "required_rng_sources" : {
//       "required_rng_source" : [ "random" ]
//     },
//     "switch_type" : "legacy",
//     "threads_as_cores" : "false",
//     "trusted_service" : "false",
//     "tunnel_migration" : "false",
//     "version" : {
//       "major" : "4",
//       "minor" : "1"
//     },
//     "virt_service" : "true",
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "mac_pool" : {
//       "href" : "/ovirt-engine/api/macpools/456",
//       "id" : "456"
//     },
//     "scheduling_policy" : {
//       "href" : "/ovirt-engine/api/schedulingpolicies/789",
//       "id" : "789"
//     },
//     "actions" : {
//       "link" : [ {
//         "href" : "/ovirt-engine/api/clusters/234/resetemulatedmachine",
//         "rel" : "resetemulatedmachine"
//       } ]
//     },
//     "name" : "Default",
//     "description" : "The default server cluster",
//     "href" : "/ovirt-engine/api/clusters/234",
//     "id" : "234",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/clusters/234/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/cpuprofiles",
//       "rel" : "cpuprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networkfilters",
//       "rel" : "networkfilters"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networks",
//       "rel" : "networks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/affinitygroups",
//       "rel" : "affinitygroups"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glusterhooks",
//       "rel" : "glusterhooks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glustervolumes",
//       "rel" : "glustervolumes"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/enabledfeatures",
//       "rel" : "enabledfeatures"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/externalnetworkproviders",
//       "rel" : "externalnetworkproviders"
//     } ]
//   } ]
// }
// ----
func (p *Host) SetCluster(attr *Cluster) {
	p.cluster = attr
}

// Cluster Type representation of a cluster.
//
// A JSON representation of a cluster:
//
// [source]
// ----
// {
//   "cluster" : [ {
//     "ballooning_enabled" : "false",
//     "cpu" : {
//       "architecture" : "x86_64",
//       "type" : "Intel SandyBridge Family"
//     },
//     "custom_scheduling_policy_properties" : {
//       "property" : [ {
//         "name" : "HighUtilization",
//         "value" : "80"
//       }, {
//         "name" : "CpuOverCommitDurationMinutes",
//         "value" : "2"
//       } ]
//     },
//     "error_handling" : {
//       "on_error" : "migrate"
//     },
//     "fencing_policy" : {
//       "enabled" : "true",
//       "skip_if_connectivity_broken" : {
//         "enabled" : "false",
//         "threshold" : "50"
//       },
//       "skip_if_gluster_bricks_up" : "false",
//       "skip_if_gluster_quorum_not_met" : "false",
//       "skip_if_sd_active" : {
//         "enabled" : "false"
//       }
//     },
//     "gluster_service" : "false",
//     "firewall_type" : "iptables",
//     "ha_reservation" : "false",
//     "ksm" : {
//       "enabled" : "true",
//       "merge_across_nodes" : "true"
//     },
//     "memory_policy" : {
//       "over_commit" : {
//         "percent" : "100"
//       },
//       "transparent_hugepages" : {
//         "enabled" : "true"
//       }
//     },
//     "migration" : {
//       "auto_converge" : "inherit",
//       "bandwidth" : {
//         "assignment_method" : "auto"
//       },
//       "compressed" : "inherit",
//       "policy" : {
//         "id" : "00000000-0000-0000-0000-000000000000"
//       }
//     },
//     "required_rng_sources" : {
//       "required_rng_source" : [ "random" ]
//     },
//     "switch_type" : "legacy",
//     "threads_as_cores" : "false",
//     "trusted_service" : "false",
//     "tunnel_migration" : "false",
//     "version" : {
//       "major" : "4",
//       "minor" : "1"
//     },
//     "virt_service" : "true",
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "mac_pool" : {
//       "href" : "/ovirt-engine/api/macpools/456",
//       "id" : "456"
//     },
//     "scheduling_policy" : {
//       "href" : "/ovirt-engine/api/schedulingpolicies/789",
//       "id" : "789"
//     },
//     "actions" : {
//       "link" : [ {
//         "href" : "/ovirt-engine/api/clusters/234/resetemulatedmachine",
//         "rel" : "resetemulatedmachine"
//       } ]
//     },
//     "name" : "Default",
//     "description" : "The default server cluster",
//     "href" : "/ovirt-engine/api/clusters/234",
//     "id" : "234",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/clusters/234/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/cpuprofiles",
//       "rel" : "cpuprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networkfilters",
//       "rel" : "networkfilters"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networks",
//       "rel" : "networks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/affinitygroups",
//       "rel" : "affinitygroups"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glusterhooks",
//       "rel" : "glusterhooks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glustervolumes",
//       "rel" : "glustervolumes"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/enabledfeatures",
//       "rel" : "enabledfeatures"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/externalnetworkproviders",
//       "rel" : "externalnetworkproviders"
//     } ]
//   } ]
// }
// ----
func (p *Host) Cluster() (*Cluster, bool) {
	if p.cluster != nil {
		return p.cluster, true
	}
	return nil, false
}

// MustCluster Type representation of a cluster.
//
// A JSON representation of a cluster:
//
// [source]
// ----
// {
//   "cluster" : [ {
//     "ballooning_enabled" : "false",
//     "cpu" : {
//       "architecture" : "x86_64",
//       "type" : "Intel SandyBridge Family"
//     },
//     "custom_scheduling_policy_properties" : {
//       "property" : [ {
//         "name" : "HighUtilization",
//         "value" : "80"
//       }, {
//         "name" : "CpuOverCommitDurationMinutes",
//         "value" : "2"
//       } ]
//     },
//     "error_handling" : {
//       "on_error" : "migrate"
//     },
//     "fencing_policy" : {
//       "enabled" : "true",
//       "skip_if_connectivity_broken" : {
//         "enabled" : "false",
//         "threshold" : "50"
//       },
//       "skip_if_gluster_bricks_up" : "false",
//       "skip_if_gluster_quorum_not_met" : "false",
//       "skip_if_sd_active" : {
//         "enabled" : "false"
//       }
//     },
//     "gluster_service" : "false",
//     "firewall_type" : "iptables",
//     "ha_reservation" : "false",
//     "ksm" : {
//       "enabled" : "true",
//       "merge_across_nodes" : "true"
//     },
//     "memory_policy" : {
//       "over_commit" : {
//         "percent" : "100"
//       },
//       "transparent_hugepages" : {
//         "enabled" : "true"
//       }
//     },
//     "migration" : {
//       "auto_converge" : "inherit",
//       "bandwidth" : {
//         "assignment_method" : "auto"
//       },
//       "compressed" : "inherit",
//       "policy" : {
//         "id" : "00000000-0000-0000-0000-000000000000"
//       }
//     },
//     "required_rng_sources" : {
//       "required_rng_source" : [ "random" ]
//     },
//     "switch_type" : "legacy",
//     "threads_as_cores" : "false",
//     "trusted_service" : "false",
//     "tunnel_migration" : "false",
//     "version" : {
//       "major" : "4",
//       "minor" : "1"
//     },
//     "virt_service" : "true",
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "mac_pool" : {
//       "href" : "/ovirt-engine/api/macpools/456",
//       "id" : "456"
//     },
//     "scheduling_policy" : {
//       "href" : "/ovirt-engine/api/schedulingpolicies/789",
//       "id" : "789"
//     },
//     "actions" : {
//       "link" : [ {
//         "href" : "/ovirt-engine/api/clusters/234/resetemulatedmachine",
//         "rel" : "resetemulatedmachine"
//       } ]
//     },
//     "name" : "Default",
//     "description" : "The default server cluster",
//     "href" : "/ovirt-engine/api/clusters/234",
//     "id" : "234",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/clusters/234/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/cpuprofiles",
//       "rel" : "cpuprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networkfilters",
//       "rel" : "networkfilters"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networks",
//       "rel" : "networks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/affinitygroups",
//       "rel" : "affinitygroups"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glusterhooks",
//       "rel" : "glusterhooks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glustervolumes",
//       "rel" : "glustervolumes"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/enabledfeatures",
//       "rel" : "enabledfeatures"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/externalnetworkproviders",
//       "rel" : "externalnetworkproviders"
//     } ]
//   } ]
// }
// ----
func (p *Host) MustCluster() *Cluster {
	if p.cluster == nil {
		panic("the cluster must not be nil, please use Cluster() function instead")
	}
	return p.cluster
}

func (p *Host) SetComment(attr string) {
	p.comment = &attr
}

func (p *Host) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *Host) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *Host) SetCpu(attr *Cpu) {
	p.cpu = attr
}

func (p *Host) Cpu() (*Cpu, bool) {
	if p.cpu != nil {
		return p.cpu, true
	}
	return nil, false
}

func (p *Host) MustCpu() *Cpu {
	if p.cpu == nil {
		panic("the cpu must not be nil, please use Cpu() function instead")
	}
	return p.cpu
}

func (p *Host) SetDescription(attr string) {
	p.description = &attr
}

func (p *Host) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *Host) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *Host) SetDevicePassthrough(attr *HostDevicePassthrough) {
	p.devicePassthrough = attr
}

func (p *Host) DevicePassthrough() (*HostDevicePassthrough, bool) {
	if p.devicePassthrough != nil {
		return p.devicePassthrough, true
	}
	return nil, false
}

func (p *Host) MustDevicePassthrough() *HostDevicePassthrough {
	if p.devicePassthrough == nil {
		panic("the devicePassthrough must not be nil, please use DevicePassthrough() function instead")
	}
	return p.devicePassthrough
}

func (p *Host) SetDevices(attr *HostDeviceSlice) {
	p.devices = attr
}

func (p *Host) Devices() (*HostDeviceSlice, bool) {
	if p.devices != nil {
		return p.devices, true
	}
	return nil, false
}

func (p *Host) MustDevices() *HostDeviceSlice {
	if p.devices == nil {
		panic("the devices must not be nil, please use Devices() function instead")
	}
	return p.devices
}

// SetDisplay Represents a graphic console configuration.
func (p *Host) SetDisplay(attr *Display) {
	p.display = attr
}

// Display Represents a graphic console configuration.
func (p *Host) Display() (*Display, bool) {
	if p.display != nil {
		return p.display, true
	}
	return nil, false
}

// MustDisplay Represents a graphic console configuration.
func (p *Host) MustDisplay() *Display {
	if p.display == nil {
		panic("the display must not be nil, please use Display() function instead")
	}
	return p.display
}

// SetExternalHostProvider Represents an external host provider,
// such as Foreman or Satellite.
//
// See https://www.theforeman.org/ for more details on Foreman.
// See https://access.redhat.com/products/red-hat-satellite
// for more details on Red Hat Satellite.
func (p *Host) SetExternalHostProvider(attr *ExternalHostProvider) {
	p.externalHostProvider = attr
}

// ExternalHostProvider Represents an external host provider,
// such as Foreman or Satellite.
//
// See https://www.theforeman.org/ for more details on Foreman.
// See https://access.redhat.com/products/red-hat-satellite
// for more details on Red Hat Satellite.
func (p *Host) ExternalHostProvider() (*ExternalHostProvider, bool) {
	if p.externalHostProvider != nil {
		return p.externalHostProvider, true
	}
	return nil, false
}

// MustExternalHostProvider Represents an external host provider,
// such as Foreman or Satellite.
//
// See https://www.theforeman.org/ for more details on Foreman.
// See https://access.redhat.com/products/red-hat-satellite
// for more details on Red Hat Satellite.
func (p *Host) MustExternalHostProvider() *ExternalHostProvider {
	if p.externalHostProvider == nil {
		panic("the externalHostProvider must not be nil, please use ExternalHostProvider() function instead")
	}
	return p.externalHostProvider
}

func (p *Host) SetExternalNetworkProviderConfigurations(attr *ExternalNetworkProviderConfigurationSlice) {
	p.externalNetworkProviderConfigurations = attr
}

func (p *Host) ExternalNetworkProviderConfigurations() (*ExternalNetworkProviderConfigurationSlice, bool) {
	if p.externalNetworkProviderConfigurations != nil {
		return p.externalNetworkProviderConfigurations, true
	}
	return nil, false
}

func (p *Host) MustExternalNetworkProviderConfigurations() *ExternalNetworkProviderConfigurationSlice {
	if p.externalNetworkProviderConfigurations == nil {
		panic("the externalNetworkProviderConfigurations must not be nil, please use ExternalNetworkProviderConfigurations() function instead")
	}
	return p.externalNetworkProviderConfigurations
}

// SetExternalStatus Represents an external status.
// This status is currently used for <<types/host, hosts>>
// and <<types/storage_domain, storage domains>>, and allows an external
// system to update status of objects it is aware of.
func (p *Host) SetExternalStatus(attr ExternalStatus) {
	p.externalStatus = &attr
}

// ExternalStatus Represents an external status.
// This status is currently used for <<types/host, hosts>>
// and <<types/storage_domain, storage domains>>, and allows an external
// system to update status of objects it is aware of.
func (p *Host) ExternalStatus() (ExternalStatus, bool) {
	if p.externalStatus != nil {
		return *p.externalStatus, true
	}
	var zero ExternalStatus
	return zero, false
}

// MustExternalStatus Represents an external status.
// This status is currently used for <<types/host, hosts>>
// and <<types/storage_domain, storage domains>>, and allows an external
// system to update status of objects it is aware of.
func (p *Host) MustExternalStatus() ExternalStatus {
	if p.externalStatus == nil {
		panic("the externalStatus must not be nil, please use ExternalStatus() function instead")
	}
	return *p.externalStatus
}

// SetHardwareInformation Represents hardware information of host.
//
// To get that information send a request like this:
//
// ....
// GET /ovirt-engine/api/hosts/123
// ....
//
// The result will be like this:
//
// [source,xml]
// ----
// <host href="/ovirt-engine/api/hosts/123" id="123">
//   ...
//   <hardware_information>
//     <family>Red Hat Enterprise Linux</family>
//     <manufacturer>Red Hat</manufacturer>
//     <product_name>RHEV Hypervisor</product_name>
//     <serial_number>01234567-89AB-CDEF-0123-456789ABCDEF</serial_number>
//     <supported_rng_sources>
//       <supported_rng_source>random</supported_rng_source>
//     </supported_rng_sources>
//     <uuid>12345678-9ABC-DEF0-1234-56789ABCDEF0</uuid>
//     <version>1.2-34.5.el7ev</version>
//   </hardware_information>
//   ...
// </application>
// ----
func (p *Host) SetHardwareInformation(attr *HardwareInformation) {
	p.hardwareInformation = attr
}

// HardwareInformation Represents hardware information of host.
//
// To get that information send a request like this:
//
// ....
// GET /ovirt-engine/api/hosts/123
// ....
//
// The result will be like this:
//
// [source,xml]
// ----
// <host href="/ovirt-engine/api/hosts/123" id="123">
//   ...
//   <hardware_information>
//     <family>Red Hat Enterprise Linux</family>
//     <manufacturer>Red Hat</manufacturer>
//     <product_name>RHEV Hypervisor</product_name>
//     <serial_number>01234567-89AB-CDEF-0123-456789ABCDEF</serial_number>
//     <supported_rng_sources>
//       <supported_rng_source>random</supported_rng_source>
//     </supported_rng_sources>
//     <uuid>12345678-9ABC-DEF0-1234-56789ABCDEF0</uuid>
//     <version>1.2-34.5.el7ev</version>
//   </hardware_information>
//   ...
// </application>
// ----
func (p *Host) HardwareInformation() (*HardwareInformation, bool) {
	if p.hardwareInformation != nil {
		return p.hardwareInformation, true
	}
	return nil, false
}

// MustHardwareInformation Represents hardware information of host.
//
// To get that information send a request like this:
//
// ....
// GET /ovirt-engine/api/hosts/123
// ....
//
// The result will be like this:
//
// [source,xml]
// ----
// <host href="/ovirt-engine/api/hosts/123" id="123">
//   ...
//   <hardware_information>
//     <family>Red Hat Enterprise Linux</family>
//     <manufacturer>Red Hat</manufacturer>
//     <product_name>RHEV Hypervisor</product_name>
//     <serial_number>01234567-89AB-CDEF-0123-456789ABCDEF</serial_number>
//     <supported_rng_sources>
//       <supported_rng_source>random</supported_rng_source>
//     </supported_rng_sources>
//     <uuid>12345678-9ABC-DEF0-1234-56789ABCDEF0</uuid>
//     <version>1.2-34.5.el7ev</version>
//   </hardware_information>
//   ...
// </application>
// ----
func (p *Host) MustHardwareInformation() *HardwareInformation {
	if p.hardwareInformation == nil {
		panic("the hardwareInformation must not be nil, please use HardwareInformation() function instead")
	}
	return p.hardwareInformation
}

func (p *Host) SetHooks(attr *HookSlice) {
	p.hooks = attr
}

func (p *Host) Hooks() (*HookSlice, bool) {
	if p.hooks != nil {
		return p.hooks, true
	}
	return nil, false
}

func (p *Host) MustHooks() *HookSlice {
	if p.hooks == nil {
		panic("the hooks must not be nil, please use Hooks() function instead")
	}
	return p.hooks
}

func (p *Host) SetHostedEngine(attr *HostedEngine) {
	p.hostedEngine = attr
}

func (p *Host) HostedEngine() (*HostedEngine, bool) {
	if p.hostedEngine != nil {
		return p.hostedEngine, true
	}
	return nil, false
}

func (p *Host) MustHostedEngine() *HostedEngine {
	if p.hostedEngine == nil {
		panic("the hostedEngine must not be nil, please use HostedEngine() function instead")
	}
	return p.hostedEngine
}

func (p *Host) SetId(attr string) {
	p.id = &attr
}

func (p *Host) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *Host) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *Host) SetIscsi(attr *IscsiDetails) {
	p.iscsi = attr
}

func (p *Host) Iscsi() (*IscsiDetails, bool) {
	if p.iscsi != nil {
		return p.iscsi, true
	}
	return nil, false
}

func (p *Host) MustIscsi() *IscsiDetails {
	if p.iscsi == nil {
		panic("the iscsi must not be nil, please use Iscsi() function instead")
	}
	return p.iscsi
}

func (p *Host) SetKatelloErrata(attr *KatelloErratumSlice) {
	p.katelloErrata = attr
}

func (p *Host) KatelloErrata() (*KatelloErratumSlice, bool) {
	if p.katelloErrata != nil {
		return p.katelloErrata, true
	}
	return nil, false
}

func (p *Host) MustKatelloErrata() *KatelloErratumSlice {
	if p.katelloErrata == nil {
		panic("the katelloErrata must not be nil, please use KatelloErrata() function instead")
	}
	return p.katelloErrata
}

func (p *Host) SetKdumpStatus(attr KdumpStatus) {
	p.kdumpStatus = &attr
}

func (p *Host) KdumpStatus() (KdumpStatus, bool) {
	if p.kdumpStatus != nil {
		return *p.kdumpStatus, true
	}
	var zero KdumpStatus
	return zero, false
}

func (p *Host) MustKdumpStatus() KdumpStatus {
	if p.kdumpStatus == nil {
		panic("the kdumpStatus must not be nil, please use KdumpStatus() function instead")
	}
	return *p.kdumpStatus
}

func (p *Host) SetKsm(attr *Ksm) {
	p.ksm = attr
}

func (p *Host) Ksm() (*Ksm, bool) {
	if p.ksm != nil {
		return p.ksm, true
	}
	return nil, false
}

func (p *Host) MustKsm() *Ksm {
	if p.ksm == nil {
		panic("the ksm must not be nil, please use Ksm() function instead")
	}
	return p.ksm
}

func (p *Host) SetLibvirtVersion(attr *Version) {
	p.libvirtVersion = attr
}

func (p *Host) LibvirtVersion() (*Version, bool) {
	if p.libvirtVersion != nil {
		return p.libvirtVersion, true
	}
	return nil, false
}

func (p *Host) MustLibvirtVersion() *Version {
	if p.libvirtVersion == nil {
		panic("the libvirtVersion must not be nil, please use LibvirtVersion() function instead")
	}
	return p.libvirtVersion
}

func (p *Host) SetMaxSchedulingMemory(attr int64) {
	p.maxSchedulingMemory = &attr
}

func (p *Host) MaxSchedulingMemory() (int64, bool) {
	if p.maxSchedulingMemory != nil {
		return *p.maxSchedulingMemory, true
	}
	var zero int64
	return zero, false
}

func (p *Host) MustMaxSchedulingMemory() int64 {
	if p.maxSchedulingMemory == nil {
		panic("the maxSchedulingMemory must not be nil, please use MaxSchedulingMemory() function instead")
	}
	return *p.maxSchedulingMemory
}

func (p *Host) SetMemory(attr int64) {
	p.memory = &attr
}

func (p *Host) Memory() (int64, bool) {
	if p.memory != nil {
		return *p.memory, true
	}
	var zero int64
	return zero, false
}

func (p *Host) MustMemory() int64 {
	if p.memory == nil {
		panic("the memory must not be nil, please use Memory() function instead")
	}
	return *p.memory
}

func (p *Host) SetName(attr string) {
	p.name = &attr
}

func (p *Host) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *Host) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *Host) SetNetworkAttachments(attr *NetworkAttachmentSlice) {
	p.networkAttachments = attr
}

func (p *Host) NetworkAttachments() (*NetworkAttachmentSlice, bool) {
	if p.networkAttachments != nil {
		return p.networkAttachments, true
	}
	return nil, false
}

func (p *Host) MustNetworkAttachments() *NetworkAttachmentSlice {
	if p.networkAttachments == nil {
		panic("the networkAttachments must not be nil, please use NetworkAttachments() function instead")
	}
	return p.networkAttachments
}

func (p *Host) SetNetworkOperationInProgress(attr bool) {
	p.networkOperationInProgress = &attr
}

func (p *Host) NetworkOperationInProgress() (bool, bool) {
	if p.networkOperationInProgress != nil {
		return *p.networkOperationInProgress, true
	}
	var zero bool
	return zero, false
}

func (p *Host) MustNetworkOperationInProgress() bool {
	if p.networkOperationInProgress == nil {
		panic("the networkOperationInProgress must not be nil, please use NetworkOperationInProgress() function instead")
	}
	return *p.networkOperationInProgress
}

func (p *Host) SetNics(attr *HostNicSlice) {
	p.nics = attr
}

func (p *Host) Nics() (*HostNicSlice, bool) {
	if p.nics != nil {
		return p.nics, true
	}
	return nil, false
}

func (p *Host) MustNics() *HostNicSlice {
	if p.nics == nil {
		panic("the nics must not be nil, please use Nics() function instead")
	}
	return p.nics
}

func (p *Host) SetNumaNodes(attr *NumaNodeSlice) {
	p.numaNodes = attr
}

func (p *Host) NumaNodes() (*NumaNodeSlice, bool) {
	if p.numaNodes != nil {
		return p.numaNodes, true
	}
	return nil, false
}

func (p *Host) MustNumaNodes() *NumaNodeSlice {
	if p.numaNodes == nil {
		panic("the numaNodes must not be nil, please use NumaNodes() function instead")
	}
	return p.numaNodes
}

func (p *Host) SetNumaSupported(attr bool) {
	p.numaSupported = &attr
}

func (p *Host) NumaSupported() (bool, bool) {
	if p.numaSupported != nil {
		return *p.numaSupported, true
	}
	var zero bool
	return zero, false
}

func (p *Host) MustNumaSupported() bool {
	if p.numaSupported == nil {
		panic("the numaSupported must not be nil, please use NumaSupported() function instead")
	}
	return *p.numaSupported
}

// SetOs Information describing the operating system. This is used for both virtual machines and hosts.
func (p *Host) SetOs(attr *OperatingSystem) {
	p.os = attr
}

// Os Information describing the operating system. This is used for both virtual machines and hosts.
func (p *Host) Os() (*OperatingSystem, bool) {
	if p.os != nil {
		return p.os, true
	}
	return nil, false
}

// MustOs Information describing the operating system. This is used for both virtual machines and hosts.
func (p *Host) MustOs() *OperatingSystem {
	if p.os == nil {
		panic("the os must not be nil, please use Os() function instead")
	}
	return p.os
}

func (p *Host) SetOverrideIptables(attr bool) {
	p.overrideIptables = &attr
}

func (p *Host) OverrideIptables() (bool, bool) {
	if p.overrideIptables != nil {
		return *p.overrideIptables, true
	}
	var zero bool
	return zero, false
}

func (p *Host) MustOverrideIptables() bool {
	if p.overrideIptables == nil {
		panic("the overrideIptables must not be nil, please use OverrideIptables() function instead")
	}
	return *p.overrideIptables
}

func (p *Host) SetPermissions(attr *PermissionSlice) {
	p.permissions = attr
}

func (p *Host) Permissions() (*PermissionSlice, bool) {
	if p.permissions != nil {
		return p.permissions, true
	}
	return nil, false
}

func (p *Host) MustPermissions() *PermissionSlice {
	if p.permissions == nil {
		panic("the permissions must not be nil, please use Permissions() function instead")
	}
	return p.permissions
}

func (p *Host) SetPort(attr int64) {
	p.port = &attr
}

func (p *Host) Port() (int64, bool) {
	if p.port != nil {
		return *p.port, true
	}
	var zero int64
	return zero, false
}

func (p *Host) MustPort() int64 {
	if p.port == nil {
		panic("the port must not be nil, please use Port() function instead")
	}
	return *p.port
}

func (p *Host) SetPowerManagement(attr *PowerManagement) {
	p.powerManagement = attr
}

func (p *Host) PowerManagement() (*PowerManagement, bool) {
	if p.powerManagement != nil {
		return p.powerManagement, true
	}
	return nil, false
}

func (p *Host) MustPowerManagement() *PowerManagement {
	if p.powerManagement == nil {
		panic("the powerManagement must not be nil, please use PowerManagement() function instead")
	}
	return p.powerManagement
}

// SetProtocol The protocol used by the engine to communicate with
// a host.
//
// WARNING: Since version 4.1 of the engine the protocol
// is always set to `stomp` since `xml` was removed.
func (p *Host) SetProtocol(attr HostProtocol) {
	p.protocol = &attr
}

// Protocol The protocol used by the engine to communicate with
// a host.
//
// WARNING: Since version 4.1 of the engine the protocol
// is always set to `stomp` since `xml` was removed.
func (p *Host) Protocol() (HostProtocol, bool) {
	if p.protocol != nil {
		return *p.protocol, true
	}
	var zero HostProtocol
	return zero, false
}

// MustProtocol The protocol used by the engine to communicate with
// a host.
//
// WARNING: Since version 4.1 of the engine the protocol
// is always set to `stomp` since `xml` was removed.
func (p *Host) MustProtocol() HostProtocol {
	if p.protocol == nil {
		panic("the protocol must not be nil, please use Protocol() function instead")
	}
	return *p.protocol
}

func (p *Host) SetReinstallationRequired(attr bool) {
	p.reinstallationRequired = &attr
}

func (p *Host) ReinstallationRequired() (bool, bool) {
	if p.reinstallationRequired != nil {
		return *p.reinstallationRequired, true
	}
	var zero bool
	return zero, false
}

func (p *Host) MustReinstallationRequired() bool {
	if p.reinstallationRequired == nil {
		panic("the reinstallationRequired must not be nil, please use ReinstallationRequired() function instead")
	}
	return *p.reinstallationRequired
}

func (p *Host) SetRootPassword(attr string) {
	p.rootPassword = &attr
}

func (p *Host) RootPassword() (string, bool) {
	if p.rootPassword != nil {
		return *p.rootPassword, true
	}
	var zero string
	return zero, false
}

func (p *Host) MustRootPassword() string {
	if p.rootPassword == nil {
		panic("the rootPassword must not be nil, please use RootPassword() function instead")
	}
	return *p.rootPassword
}

// SetSeLinux Represents SELinux in the system.
func (p *Host) SetSeLinux(attr *SeLinux) {
	p.seLinux = attr
}

// SeLinux Represents SELinux in the system.
func (p *Host) SeLinux() (*SeLinux, bool) {
	if p.seLinux != nil {
		return p.seLinux, true
	}
	return nil, false
}

// MustSeLinux Represents SELinux in the system.
func (p *Host) MustSeLinux() *SeLinux {
	if p.seLinux == nil {
		panic("the seLinux must not be nil, please use SeLinux() function instead")
	}
	return p.seLinux
}

func (p *Host) SetSpm(attr *Spm) {
	p.spm = attr
}

func (p *Host) Spm() (*Spm, bool) {
	if p.spm != nil {
		return p.spm, true
	}
	return nil, false
}

func (p *Host) MustSpm() *Spm {
	if p.spm == nil {
		panic("the spm must not be nil, please use Spm() function instead")
	}
	return p.spm
}

func (p *Host) SetSsh(attr *Ssh) {
	p.ssh = attr
}

func (p *Host) Ssh() (*Ssh, bool) {
	if p.ssh != nil {
		return p.ssh, true
	}
	return nil, false
}

func (p *Host) MustSsh() *Ssh {
	if p.ssh == nil {
		panic("the ssh must not be nil, please use Ssh() function instead")
	}
	return p.ssh
}

func (p *Host) SetStatistics(attr *StatisticSlice) {
	p.statistics = attr
}

func (p *Host) Statistics() (*StatisticSlice, bool) {
	if p.statistics != nil {
		return p.statistics, true
	}
	return nil, false
}

func (p *Host) MustStatistics() *StatisticSlice {
	if p.statistics == nil {
		panic("the statistics must not be nil, please use Statistics() function instead")
	}
	return p.statistics
}

// SetStatus Type representing a host status.
func (p *Host) SetStatus(attr HostStatus) {
	p.status = &attr
}

// Status Type representing a host status.
func (p *Host) Status() (HostStatus, bool) {
	if p.status != nil {
		return *p.status, true
	}
	var zero HostStatus
	return zero, false
}

// MustStatus Type representing a host status.
func (p *Host) MustStatus() HostStatus {
	if p.status == nil {
		panic("the status must not be nil, please use Status() function instead")
	}
	return *p.status
}

func (p *Host) SetStatusDetail(attr string) {
	p.statusDetail = &attr
}

func (p *Host) StatusDetail() (string, bool) {
	if p.statusDetail != nil {
		return *p.statusDetail, true
	}
	var zero string
	return zero, false
}

func (p *Host) MustStatusDetail() string {
	if p.statusDetail == nil {
		panic("the statusDetail must not be nil, please use StatusDetail() function instead")
	}
	return *p.statusDetail
}

func (p *Host) SetStorageConnectionExtensions(attr *StorageConnectionExtensionSlice) {
	p.storageConnectionExtensions = attr
}

func (p *Host) StorageConnectionExtensions() (*StorageConnectionExtensionSlice, bool) {
	if p.storageConnectionExtensions != nil {
		return p.storageConnectionExtensions, true
	}
	return nil, false
}

func (p *Host) MustStorageConnectionExtensions() *StorageConnectionExtensionSlice {
	if p.storageConnectionExtensions == nil {
		panic("the storageConnectionExtensions must not be nil, please use StorageConnectionExtensions() function instead")
	}
	return p.storageConnectionExtensions
}

func (p *Host) SetStorages(attr *HostStorageSlice) {
	p.storages = attr
}

func (p *Host) Storages() (*HostStorageSlice, bool) {
	if p.storages != nil {
		return p.storages, true
	}
	return nil, false
}

func (p *Host) MustStorages() *HostStorageSlice {
	if p.storages == nil {
		panic("the storages must not be nil, please use Storages() function instead")
	}
	return p.storages
}

// SetSummary Type containing information related to virtual machines on a particular host.
func (p *Host) SetSummary(attr *VmSummary) {
	p.summary = attr
}

// Summary Type containing information related to virtual machines on a particular host.
func (p *Host) Summary() (*VmSummary, bool) {
	if p.summary != nil {
		return p.summary, true
	}
	return nil, false
}

// MustSummary Type containing information related to virtual machines on a particular host.
func (p *Host) MustSummary() *VmSummary {
	if p.summary == nil {
		panic("the summary must not be nil, please use Summary() function instead")
	}
	return p.summary
}

func (p *Host) SetTags(attr *TagSlice) {
	p.tags = attr
}

func (p *Host) Tags() (*TagSlice, bool) {
	if p.tags != nil {
		return p.tags, true
	}
	return nil, false
}

func (p *Host) MustTags() *TagSlice {
	if p.tags == nil {
		panic("the tags must not be nil, please use Tags() function instead")
	}
	return p.tags
}

// SetTransparentHugePages Type representing a transparent huge pages (THP) support.
func (p *Host) SetTransparentHugePages(attr *TransparentHugePages) {
	p.transparentHugePages = attr
}

// TransparentHugePages Type representing a transparent huge pages (THP) support.
func (p *Host) TransparentHugePages() (*TransparentHugePages, bool) {
	if p.transparentHugePages != nil {
		return p.transparentHugePages, true
	}
	return nil, false
}

// MustTransparentHugePages Type representing a transparent huge pages (THP) support.
func (p *Host) MustTransparentHugePages() *TransparentHugePages {
	if p.transparentHugePages == nil {
		panic("the transparentHugePages must not be nil, please use TransparentHugePages() function instead")
	}
	return p.transparentHugePages
}

// SetType This enumerated type is used to determine which type of operating system is used by the host.
func (p *Host) SetType(attr HostType) {
	p.type_ = &attr
}

// Type This enumerated type is used to determine which type of operating system is used by the host.
func (p *Host) Type() (HostType, bool) {
	if p.type_ != nil {
		return *p.type_, true
	}
	var zero HostType
	return zero, false
}

// MustType This enumerated type is used to determine which type of operating system is used by the host.
func (p *Host) MustType() HostType {
	if p.type_ == nil {
		panic("the type_ must not be nil, please use Type() function instead")
	}
	return *p.type_
}

func (p *Host) SetUnmanagedNetworks(attr *UnmanagedNetworkSlice) {
	p.unmanagedNetworks = attr
}

func (p *Host) UnmanagedNetworks() (*UnmanagedNetworkSlice, bool) {
	if p.unmanagedNetworks != nil {
		return p.unmanagedNetworks, true
	}
	return nil, false
}

func (p *Host) MustUnmanagedNetworks() *UnmanagedNetworkSlice {
	if p.unmanagedNetworks == nil {
		panic("the unmanagedNetworks must not be nil, please use UnmanagedNetworks() function instead")
	}
	return p.unmanagedNetworks
}

func (p *Host) SetUpdateAvailable(attr bool) {
	p.updateAvailable = &attr
}

func (p *Host) UpdateAvailable() (bool, bool) {
	if p.updateAvailable != nil {
		return *p.updateAvailable, true
	}
	var zero bool
	return zero, false
}

func (p *Host) MustUpdateAvailable() bool {
	if p.updateAvailable == nil {
		panic("the updateAvailable must not be nil, please use UpdateAvailable() function instead")
	}
	return *p.updateAvailable
}

func (p *Host) SetVersion(attr *Version) {
	p.version = attr
}

func (p *Host) Version() (*Version, bool) {
	if p.version != nil {
		return p.version, true
	}
	return nil, false
}

func (p *Host) MustVersion() *Version {
	if p.version == nil {
		panic("the version must not be nil, please use Version() function instead")
	}
	return p.version
}

// SetVgpuPlacement The vGPU placement strategy.
//
// It can either put vGPUs on the first available physical
// cards, or spread them over multiple physical cards.
func (p *Host) SetVgpuPlacement(attr VgpuPlacement) {
	p.vgpuPlacement = &attr
}

// VgpuPlacement The vGPU placement strategy.
//
// It can either put vGPUs on the first available physical
// cards, or spread them over multiple physical cards.
func (p *Host) VgpuPlacement() (VgpuPlacement, bool) {
	if p.vgpuPlacement != nil {
		return *p.vgpuPlacement, true
	}
	var zero VgpuPlacement
	return zero, false
}

// MustVgpuPlacement The vGPU placement strategy.
//
// It can either put vGPUs on the first available physical
// cards, or spread them over multiple physical cards.
func (p *Host) MustVgpuPlacement() VgpuPlacement {
	if p.vgpuPlacement == nil {
		panic("the vgpuPlacement must not be nil, please use VgpuPlacement() function instead")
	}
	return *p.vgpuPlacement
}

type HostDevice struct {
	Struct
	capability       *string
	comment          *string
	description      *string
	driver           *string
	host             *Host
	id               *string
	iommuGroup       *int64
	mDevTypes        *MDevTypeSlice
	name             *string
	parentDevice     *HostDevice
	physicalFunction *HostDevice
	placeholder      *bool
	product          *Product
	vendor           *Vendor
	virtualFunctions *int64
	vm               *Vm
}

func (p *HostDevice) SetCapability(attr string) {
	p.capability = &attr
}

func (p *HostDevice) Capability() (string, bool) {
	if p.capability != nil {
		return *p.capability, true
	}
	var zero string
	return zero, false
}

func (p *HostDevice) MustCapability() string {
	if p.capability == nil {
		panic("the capability must not be nil, please use Capability() function instead")
	}
	return *p.capability
}

func (p *HostDevice) SetComment(attr string) {
	p.comment = &attr
}

func (p *HostDevice) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *HostDevice) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *HostDevice) SetDescription(attr string) {
	p.description = &attr
}

func (p *HostDevice) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *HostDevice) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *HostDevice) SetDriver(attr string) {
	p.driver = &attr
}

func (p *HostDevice) Driver() (string, bool) {
	if p.driver != nil {
		return *p.driver, true
	}
	var zero string
	return zero, false
}

func (p *HostDevice) MustDriver() string {
	if p.driver == nil {
		panic("the driver must not be nil, please use Driver() function instead")
	}
	return *p.driver
}

// SetHost Type representing a host.
func (p *HostDevice) SetHost(attr *Host) {
	p.host = attr
}

// Host Type representing a host.
func (p *HostDevice) Host() (*Host, bool) {
	if p.host != nil {
		return p.host, true
	}
	return nil, false
}

// MustHost Type representing a host.
func (p *HostDevice) MustHost() *Host {
	if p.host == nil {
		panic("the host must not be nil, please use Host() function instead")
	}
	return p.host
}

func (p *HostDevice) SetId(attr string) {
	p.id = &attr
}

func (p *HostDevice) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *HostDevice) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *HostDevice) SetIommuGroup(attr int64) {
	p.iommuGroup = &attr
}

func (p *HostDevice) IommuGroup() (int64, bool) {
	if p.iommuGroup != nil {
		return *p.iommuGroup, true
	}
	var zero int64
	return zero, false
}

func (p *HostDevice) MustIommuGroup() int64 {
	if p.iommuGroup == nil {
		panic("the iommuGroup must not be nil, please use IommuGroup() function instead")
	}
	return *p.iommuGroup
}

func (p *HostDevice) SetMDevTypes(attr *MDevTypeSlice) {
	p.mDevTypes = attr
}

func (p *HostDevice) MDevTypes() (*MDevTypeSlice, bool) {
	if p.mDevTypes != nil {
		return p.mDevTypes, true
	}
	return nil, false
}

func (p *HostDevice) MustMDevTypes() *MDevTypeSlice {
	if p.mDevTypes == nil {
		panic("the mDevTypes must not be nil, please use MDevTypes() function instead")
	}
	return p.mDevTypes
}

func (p *HostDevice) SetName(attr string) {
	p.name = &attr
}

func (p *HostDevice) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *HostDevice) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *HostDevice) SetParentDevice(attr *HostDevice) {
	p.parentDevice = attr
}

func (p *HostDevice) ParentDevice() (*HostDevice, bool) {
	if p.parentDevice != nil {
		return p.parentDevice, true
	}
	return nil, false
}

func (p *HostDevice) MustParentDevice() *HostDevice {
	if p.parentDevice == nil {
		panic("the parentDevice must not be nil, please use ParentDevice() function instead")
	}
	return p.parentDevice
}

func (p *HostDevice) SetPhysicalFunction(attr *HostDevice) {
	p.physicalFunction = attr
}

func (p *HostDevice) PhysicalFunction() (*HostDevice, bool) {
	if p.physicalFunction != nil {
		return p.physicalFunction, true
	}
	return nil, false
}

func (p *HostDevice) MustPhysicalFunction() *HostDevice {
	if p.physicalFunction == nil {
		panic("the physicalFunction must not be nil, please use PhysicalFunction() function instead")
	}
	return p.physicalFunction
}

func (p *HostDevice) SetPlaceholder(attr bool) {
	p.placeholder = &attr
}

func (p *HostDevice) Placeholder() (bool, bool) {
	if p.placeholder != nil {
		return *p.placeholder, true
	}
	var zero bool
	return zero, false
}

func (p *HostDevice) MustPlaceholder() bool {
	if p.placeholder == nil {
		panic("the placeholder must not be nil, please use Placeholder() function instead")
	}
	return *p.placeholder
}

func (p *HostDevice) SetProduct(attr *Product) {
	p.product = attr
}

func (p *HostDevice) Product() (*Product, bool) {
	if p.product != nil {
		return p.product, true
	}
	return nil, false
}

func (p *HostDevice) MustProduct() *Product {
	if p.product == nil {
		panic("the product must not be nil, please use Product() function instead")
	}
	return p.product
}

func (p *HostDevice) SetVendor(attr *Vendor) {
	p.vendor = attr
}

func (p *HostDevice) Vendor() (*Vendor, bool) {
	if p.vendor != nil {
		return p.vendor, true
	}
	return nil, false
}

func (p *HostDevice) MustVendor() *Vendor {
	if p.vendor == nil {
		panic("the vendor must not be nil, please use Vendor() function instead")
	}
	return p.vendor
}

func (p *HostDevice) SetVirtualFunctions(attr int64) {
	p.virtualFunctions = &attr
}

func (p *HostDevice) VirtualFunctions() (int64, bool) {
	if p.virtualFunctions != nil {
		return *p.virtualFunctions, true
	}
	var zero int64
	return zero, false
}

func (p *HostDevice) MustVirtualFunctions() int64 {
	if p.virtualFunctions == nil {
		panic("the virtualFunctions must not be nil, please use VirtualFunctions() function instead")
	}
	return *p.virtualFunctions
}

// SetVm Represents a virtual machine.
func (p *HostDevice) SetVm(attr *Vm) {
	p.vm = attr
}

// Vm Represents a virtual machine.
func (p *HostDevice) Vm() (*Vm, bool) {
	if p.vm != nil {
		return p.vm, true
	}
	return nil, false
}

// MustVm Represents a virtual machine.
func (p *HostDevice) MustVm() *Vm {
	if p.vm == nil {
		panic("the vm must not be nil, please use Vm() function instead")
	}
	return p.vm
}

type HostDevicePassthrough struct {
	Struct
	enabled *bool
}

func (p *HostDevicePassthrough) SetEnabled(attr bool) {
	p.enabled = &attr
}

func (p *HostDevicePassthrough) Enabled() (bool, bool) {
	if p.enabled != nil {
		return *p.enabled, true
	}
	var zero bool
	return zero, false
}

func (p *HostDevicePassthrough) MustEnabled() bool {
	if p.enabled == nil {
		panic("the enabled must not be nil, please use Enabled() function instead")
	}
	return *p.enabled
}

// HostNic Represents a host NIC.
//
// For example, the XML representation of a host NIC looks like this:
//
// [source,xml]
// ----
// <host_nic href="/ovirt-engine/api/hosts/123/nics/456" id="456">
//   <name>eth0</name>
//   <boot_protocol>static</boot_protocol>
//   <bridged>true</bridged>
//   <custom_configuration>true</custom_configuration>
//   <ip>
//     <address>192.168.122.39</address>
//     <gateway>192.168.122.1</gateway>
//     <netmask>255.255.255.0</netmask>
//     <version>v4</version>
//   </ip>
//   <ipv6>
//     <gateway>::</gateway>
//     <version>v6</version>
//   </ipv6>
//   <ipv6_boot_protocol>none</ipv6_boot_protocol>
//   <mac>
//     <address>52:54:00:0c:79:1d</address>
//   </mac>
//   <mtu>1500</mtu>
//   <status>up</status>
// </host_nic>
// ----
//
// A bonded interface is represented as a <<types/host_nic, HostNic>> object
// containing the `bonding` and `slaves` attributes.
//
// For example, the XML representation of a bonded host NIC looks like this:
//
// [source,xml]
// ----
// <host_nic href="/ovirt-engine/api/hosts/123/nics/456" id="456">
//   <name>bond0</name>
//   <mac address="00:00:00:00:00:00"/>
//   <ip>
//     <address>192.168.122.39</address>
//     <gateway>192.168.122.1</gateway>
//     <netmask>255.255.255.0</netmask>
//     <version>v4</version>
//   </ip>
//   <boot_protocol>dhcp</boot_protocol>
//   <bonding>
//     <options>
//       <option>
//         <name>mode</name>
//         <value>4</value>
//         <type>Dynamic link aggregation (802.3ad)</type>
//       </option>
//       <option>
//         <name>miimon</name>
//         <value>100</value>
//       </option>
//     </options>
//     <slaves>
//       <host_nic id="123"/>
//       <host_nic id="456"/>
//     </slaves>
//   </bonding>
//   <mtu>1500</mtu>
//   <bridged>true</bridged>
//   <custom_configuration>false</custom_configuration>
// </host_nic>
// ----
type HostNic struct {
	Struct
	adAggregatorId                *int64
	baseInterface                 *string
	bonding                       *Bonding
	bootProtocol                  *BootProtocol
	bridged                       *bool
	checkConnectivity             *bool
	comment                       *string
	customConfiguration           *bool
	description                   *string
	host                          *Host
	id                            *string
	ip                            *Ip
	ipv6                          *Ip
	ipv6BootProtocol              *BootProtocol
	mac                           *Mac
	mtu                           *int64
	name                          *string
	network                       *Network
	networkLabels                 *NetworkLabelSlice
	overrideConfiguration         *bool
	physicalFunction              *HostNic
	properties                    *PropertySlice
	qos                           *Qos
	speed                         *int64
	statistics                    *StatisticSlice
	status                        *NicStatus
	virtualFunctionsConfiguration *HostNicVirtualFunctionsConfiguration
	vlan                          *Vlan
}

func (p *HostNic) SetAdAggregatorId(attr int64) {
	p.adAggregatorId = &attr
}

func (p *HostNic) AdAggregatorId() (int64, bool) {
	if p.adAggregatorId != nil {
		return *p.adAggregatorId, true
	}
	var zero int64
	return zero, false
}

func (p *HostNic) MustAdAggregatorId() int64 {
	if p.adAggregatorId == nil {
		panic("the adAggregatorId must not be nil, please use AdAggregatorId() function instead")
	}
	return *p.adAggregatorId
}

func (p *HostNic) SetBaseInterface(attr string) {
	p.baseInterface = &attr
}

func (p *HostNic) BaseInterface() (string, bool) {
	if p.baseInterface != nil {
		return *p.baseInterface, true
	}
	var zero string
	return zero, false
}

func (p *HostNic) MustBaseInterface() string {
	if p.baseInterface == nil {
		panic("the baseInterface must not be nil, please use BaseInterface() function instead")
	}
	return *p.baseInterface
}

// SetBonding Represents a network interfaces bond.
func (p *HostNic) SetBonding(attr *Bonding) {
	p.bonding = attr
}

// Bonding Represents a network interfaces bond.
func (p *HostNic) Bonding() (*Bonding, bool) {
	if p.bonding != nil {
		return p.bonding, true
	}
	return nil, false
}

// MustBonding Represents a network interfaces bond.
func (p *HostNic) MustBonding() *Bonding {
	if p.bonding == nil {
		panic("the bonding must not be nil, please use Bonding() function instead")
	}
	return p.bonding
}

// SetBootProtocol Defines the options of the IP address assignment method to a NIC.
func (p *HostNic) SetBootProtocol(attr BootProtocol) {
	p.bootProtocol = &attr
}

// BootProtocol Defines the options of the IP address assignment method to a NIC.
func (p *HostNic) BootProtocol() (BootProtocol, bool) {
	if p.bootProtocol != nil {
		return *p.bootProtocol, true
	}
	var zero BootProtocol
	return zero, false
}

// MustBootProtocol Defines the options of the IP address assignment method to a NIC.
func (p *HostNic) MustBootProtocol() BootProtocol {
	if p.bootProtocol == nil {
		panic("the bootProtocol must not be nil, please use BootProtocol() function instead")
	}
	return *p.bootProtocol
}

func (p *HostNic) SetBridged(attr bool) {
	p.bridged = &attr
}

func (p *HostNic) Bridged() (bool, bool) {
	if p.bridged != nil {
		return *p.bridged, true
	}
	var zero bool
	return zero, false
}

func (p *HostNic) MustBridged() bool {
	if p.bridged == nil {
		panic("the bridged must not be nil, please use Bridged() function instead")
	}
	return *p.bridged
}

func (p *HostNic) SetCheckConnectivity(attr bool) {
	p.checkConnectivity = &attr
}

func (p *HostNic) CheckConnectivity() (bool, bool) {
	if p.checkConnectivity != nil {
		return *p.checkConnectivity, true
	}
	var zero bool
	return zero, false
}

func (p *HostNic) MustCheckConnectivity() bool {
	if p.checkConnectivity == nil {
		panic("the checkConnectivity must not be nil, please use CheckConnectivity() function instead")
	}
	return *p.checkConnectivity
}

func (p *HostNic) SetComment(attr string) {
	p.comment = &attr
}

func (p *HostNic) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *HostNic) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *HostNic) SetCustomConfiguration(attr bool) {
	p.customConfiguration = &attr
}

func (p *HostNic) CustomConfiguration() (bool, bool) {
	if p.customConfiguration != nil {
		return *p.customConfiguration, true
	}
	var zero bool
	return zero, false
}

func (p *HostNic) MustCustomConfiguration() bool {
	if p.customConfiguration == nil {
		panic("the customConfiguration must not be nil, please use CustomConfiguration() function instead")
	}
	return *p.customConfiguration
}

func (p *HostNic) SetDescription(attr string) {
	p.description = &attr
}

func (p *HostNic) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *HostNic) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

// SetHost Type representing a host.
func (p *HostNic) SetHost(attr *Host) {
	p.host = attr
}

// Host Type representing a host.
func (p *HostNic) Host() (*Host, bool) {
	if p.host != nil {
		return p.host, true
	}
	return nil, false
}

// MustHost Type representing a host.
func (p *HostNic) MustHost() *Host {
	if p.host == nil {
		panic("the host must not be nil, please use Host() function instead")
	}
	return p.host
}

func (p *HostNic) SetId(attr string) {
	p.id = &attr
}

func (p *HostNic) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *HostNic) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

// SetIp Represents the IP configuration of a network interface.
func (p *HostNic) SetIp(attr *Ip) {
	p.ip = attr
}

// Ip Represents the IP configuration of a network interface.
func (p *HostNic) Ip() (*Ip, bool) {
	if p.ip != nil {
		return p.ip, true
	}
	return nil, false
}

// MustIp Represents the IP configuration of a network interface.
func (p *HostNic) MustIp() *Ip {
	if p.ip == nil {
		panic("the ip must not be nil, please use Ip() function instead")
	}
	return p.ip
}

// SetIpv6 Represents the IP configuration of a network interface.
func (p *HostNic) SetIpv6(attr *Ip) {
	p.ipv6 = attr
}

// Ipv6 Represents the IP configuration of a network interface.
func (p *HostNic) Ipv6() (*Ip, bool) {
	if p.ipv6 != nil {
		return p.ipv6, true
	}
	return nil, false
}

// MustIpv6 Represents the IP configuration of a network interface.
func (p *HostNic) MustIpv6() *Ip {
	if p.ipv6 == nil {
		panic("the ipv6 must not be nil, please use Ipv6() function instead")
	}
	return p.ipv6
}

// SetIpv6BootProtocol Defines the options of the IP address assignment method to a NIC.
func (p *HostNic) SetIpv6BootProtocol(attr BootProtocol) {
	p.ipv6BootProtocol = &attr
}

// Ipv6BootProtocol Defines the options of the IP address assignment method to a NIC.
func (p *HostNic) Ipv6BootProtocol() (BootProtocol, bool) {
	if p.ipv6BootProtocol != nil {
		return *p.ipv6BootProtocol, true
	}
	var zero BootProtocol
	return zero, false
}

// MustIpv6BootProtocol Defines the options of the IP address assignment method to a NIC.
func (p *HostNic) MustIpv6BootProtocol() BootProtocol {
	if p.ipv6BootProtocol == nil {
		panic("the ipv6BootProtocol must not be nil, please use Ipv6BootProtocol() function instead")
	}
	return *p.ipv6BootProtocol
}

// SetMac Represents a MAC address of a virtual network interface.
func (p *HostNic) SetMac(attr *Mac) {
	p.mac = attr
}

// Mac Represents a MAC address of a virtual network interface.
func (p *HostNic) Mac() (*Mac, bool) {
	if p.mac != nil {
		return p.mac, true
	}
	return nil, false
}

// MustMac Represents a MAC address of a virtual network interface.
func (p *HostNic) MustMac() *Mac {
	if p.mac == nil {
		panic("the mac must not be nil, please use Mac() function instead")
	}
	return p.mac
}

func (p *HostNic) SetMtu(attr int64) {
	p.mtu = &attr
}

func (p *HostNic) Mtu() (int64, bool) {
	if p.mtu != nil {
		return *p.mtu, true
	}
	var zero int64
	return zero, false
}

func (p *HostNic) MustMtu() int64 {
	if p.mtu == nil {
		panic("the mtu must not be nil, please use Mtu() function instead")
	}
	return *p.mtu
}

func (p *HostNic) SetName(attr string) {
	p.name = &attr
}

func (p *HostNic) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *HostNic) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

// SetNetwork The type for a logical network.
//
// An example of the JSON representation of a logical network:
//
// [source,json]
// ----
// {
//   "network" : [ {
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "stp" : "false",
//     "mtu" : "0",
//     "usages" : {
//       "usage" : [ "vm" ]
//     },
//     "name" : "ovirtmgmt",
//     "description" : "Management Network",
//     "href" : "/ovirt-engine/api/networks/456",
//     "id" : "456",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/networks/456/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/networks/456/vnicprofiles",
//       "rel" : "vnicprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/networks/456/labels",
//       "rel" : "labels"
//     } ]
//   } ]
// }
// ----
//
// An example of the XML representation of the same logical network:
//
// [source,xml]
// ----
// <network href="/ovirt-engine/api/networks/456" id="456">
//   <name>ovirtmgmt</name>
//   <description>Management Network</description>
//   <link href="/ovirt-engine/api/networks/456/permissions" rel="permissions"/>
//   <link href="/ovirt-engine/api/networks/456/vnicprofiles" rel="vnicprofiles"/>
//   <link href="/ovirt-engine/api/networks/456/labels" rel="labels"/>
//   <data_center href="/ovirt-engine/api/datacenters/123" id="123"/>
//   <stp>false</stp>
//   <mtu>0</mtu>
//   <usages>
//     <usage>vm</usage>
//   </usages>
// </network>
// ----
func (p *HostNic) SetNetwork(attr *Network) {
	p.network = attr
}

// Network The type for a logical network.
//
// An example of the JSON representation of a logical network:
//
// [source,json]
// ----
// {
//   "network" : [ {
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "stp" : "false",
//     "mtu" : "0",
//     "usages" : {
//       "usage" : [ "vm" ]
//     },
//     "name" : "ovirtmgmt",
//     "description" : "Management Network",
//     "href" : "/ovirt-engine/api/networks/456",
//     "id" : "456",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/networks/456/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/networks/456/vnicprofiles",
//       "rel" : "vnicprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/networks/456/labels",
//       "rel" : "labels"
//     } ]
//   } ]
// }
// ----
//
// An example of the XML representation of the same logical network:
//
// [source,xml]
// ----
// <network href="/ovirt-engine/api/networks/456" id="456">
//   <name>ovirtmgmt</name>
//   <description>Management Network</description>
//   <link href="/ovirt-engine/api/networks/456/permissions" rel="permissions"/>
//   <link href="/ovirt-engine/api/networks/456/vnicprofiles" rel="vnicprofiles"/>
//   <link href="/ovirt-engine/api/networks/456/labels" rel="labels"/>
//   <data_center href="/ovirt-engine/api/datacenters/123" id="123"/>
//   <stp>false</stp>
//   <mtu>0</mtu>
//   <usages>
//     <usage>vm</usage>
//   </usages>
// </network>
// ----
func (p *HostNic) Network() (*Network, bool) {
	if p.network != nil {
		return p.network, true
	}
	return nil, false
}

// MustNetwork The type for a logical network.
//
// An example of the JSON representation of a logical network:
//
// [source,json]
// ----
// {
//   "network" : [ {
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "stp" : "false",
//     "mtu" : "0",
//     "usages" : {
//       "usage" : [ "vm" ]
//     },
//     "name" : "ovirtmgmt",
//     "description" : "Management Network",
//     "href" : "/ovirt-engine/api/networks/456",
//     "id" : "456",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/networks/456/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/networks/456/vnicprofiles",
//       "rel" : "vnicprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/networks/456/labels",
//       "rel" : "labels"
//     } ]
//   } ]
// }
// ----
//
// An example of the XML representation of the same logical network:
//
// [source,xml]
// ----
// <network href="/ovirt-engine/api/networks/456" id="456">
//   <name>ovirtmgmt</name>
//   <description>Management Network</description>
//   <link href="/ovirt-engine/api/networks/456/permissions" rel="permissions"/>
//   <link href="/ovirt-engine/api/networks/456/vnicprofiles" rel="vnicprofiles"/>
//   <link href="/ovirt-engine/api/networks/456/labels" rel="labels"/>
//   <data_center href="/ovirt-engine/api/datacenters/123" id="123"/>
//   <stp>false</stp>
//   <mtu>0</mtu>
//   <usages>
//     <usage>vm</usage>
//   </usages>
// </network>
// ----
func (p *HostNic) MustNetwork() *Network {
	if p.network == nil {
		panic("the network must not be nil, please use Network() function instead")
	}
	return p.network
}

func (p *HostNic) SetNetworkLabels(attr *NetworkLabelSlice) {
	p.networkLabels = attr
}

func (p *HostNic) NetworkLabels() (*NetworkLabelSlice, bool) {
	if p.networkLabels != nil {
		return p.networkLabels, true
	}
	return nil, false
}

func (p *HostNic) MustNetworkLabels() *NetworkLabelSlice {
	if p.networkLabels == nil {
		panic("the networkLabels must not be nil, please use NetworkLabels() function instead")
	}
	return p.networkLabels
}

func (p *HostNic) SetOverrideConfiguration(attr bool) {
	p.overrideConfiguration = &attr
}

func (p *HostNic) OverrideConfiguration() (bool, bool) {
	if p.overrideConfiguration != nil {
		return *p.overrideConfiguration, true
	}
	var zero bool
	return zero, false
}

func (p *HostNic) MustOverrideConfiguration() bool {
	if p.overrideConfiguration == nil {
		panic("the overrideConfiguration must not be nil, please use OverrideConfiguration() function instead")
	}
	return *p.overrideConfiguration
}

// SetPhysicalFunction Represents a host NIC.
//
// For example, the XML representation of a host NIC looks like this:
//
// [source,xml]
// ----
// <host_nic href="/ovirt-engine/api/hosts/123/nics/456" id="456">
//   <name>eth0</name>
//   <boot_protocol>static</boot_protocol>
//   <bridged>true</bridged>
//   <custom_configuration>true</custom_configuration>
//   <ip>
//     <address>192.168.122.39</address>
//     <gateway>192.168.122.1</gateway>
//     <netmask>255.255.255.0</netmask>
//     <version>v4</version>
//   </ip>
//   <ipv6>
//     <gateway>::</gateway>
//     <version>v6</version>
//   </ipv6>
//   <ipv6_boot_protocol>none</ipv6_boot_protocol>
//   <mac>
//     <address>52:54:00:0c:79:1d</address>
//   </mac>
//   <mtu>1500</mtu>
//   <status>up</status>
// </host_nic>
// ----
//
// A bonded interface is represented as a <<types/host_nic, HostNic>> object
// containing the `bonding` and `slaves` attributes.
//
// For example, the XML representation of a bonded host NIC looks like this:
//
// [source,xml]
// ----
// <host_nic href="/ovirt-engine/api/hosts/123/nics/456" id="456">
//   <name>bond0</name>
//   <mac address="00:00:00:00:00:00"/>
//   <ip>
//     <address>192.168.122.39</address>
//     <gateway>192.168.122.1</gateway>
//     <netmask>255.255.255.0</netmask>
//     <version>v4</version>
//   </ip>
//   <boot_protocol>dhcp</boot_protocol>
//   <bonding>
//     <options>
//       <option>
//         <name>mode</name>
//         <value>4</value>
//         <type>Dynamic link aggregation (802.3ad)</type>
//       </option>
//       <option>
//         <name>miimon</name>
//         <value>100</value>
//       </option>
//     </options>
//     <slaves>
//       <host_nic id="123"/>
//       <host_nic id="456"/>
//     </slaves>
//   </bonding>
//   <mtu>1500</mtu>
//   <bridged>true</bridged>
//   <custom_configuration>false</custom_configuration>
// </host_nic>
// ----
func (p *HostNic) SetPhysicalFunction(attr *HostNic) {
	p.physicalFunction = attr
}

// PhysicalFunction Represents a host NIC.
//
// For example, the XML representation of a host NIC looks like this:
//
// [source,xml]
// ----
// <host_nic href="/ovirt-engine/api/hosts/123/nics/456" id="456">
//   <name>eth0</name>
//   <boot_protocol>static</boot_protocol>
//   <bridged>true</bridged>
//   <custom_configuration>true</custom_configuration>
//   <ip>
//     <address>192.168.122.39</address>
//     <gateway>192.168.122.1</gateway>
//     <netmask>255.255.255.0</netmask>
//     <version>v4</version>
//   </ip>
//   <ipv6>
//     <gateway>::</gateway>
//     <version>v6</version>
//   </ipv6>
//   <ipv6_boot_protocol>none</ipv6_boot_protocol>
//   <mac>
//     <address>52:54:00:0c:79:1d</address>
//   </mac>
//   <mtu>1500</mtu>
//   <status>up</status>
// </host_nic>
// ----
//
// A bonded interface is represented as a <<types/host_nic, HostNic>> object
// containing the `bonding` and `slaves` attributes.
//
// For example, the XML representation of a bonded host NIC looks like this:
//
// [source,xml]
// ----
// <host_nic href="/ovirt-engine/api/hosts/123/nics/456" id="456">
//   <name>bond0</name>
//   <mac address="00:00:00:00:00:00"/>
//   <ip>
//     <address>192.168.122.39</address>
//     <gateway>192.168.122.1</gateway>
//     <netmask>255.255.255.0</netmask>
//     <version>v4</version>
//   </ip>
//   <boot_protocol>dhcp</boot_protocol>
//   <bonding>
//     <options>
//       <option>
//         <name>mode</name>
//         <value>4</value>
//         <type>Dynamic link aggregation (802.3ad)</type>
//       </option>
//       <option>
//         <name>miimon</name>
//         <value>100</value>
//       </option>
//     </options>
//     <slaves>
//       <host_nic id="123"/>
//       <host_nic id="456"/>
//     </slaves>
//   </bonding>
//   <mtu>1500</mtu>
//   <bridged>true</bridged>
//   <custom_configuration>false</custom_configuration>
// </host_nic>
// ----
func (p *HostNic) PhysicalFunction() (*HostNic, bool) {
	if p.physicalFunction != nil {
		return p.physicalFunction, true
	}
	return nil, false
}

// MustPhysicalFunction Represents a host NIC.
//
// For example, the XML representation of a host NIC looks like this:
//
// [source,xml]
// ----
// <host_nic href="/ovirt-engine/api/hosts/123/nics/456" id="456">
//   <name>eth0</name>
//   <boot_protocol>static</boot_protocol>
//   <bridged>true</bridged>
//   <custom_configuration>true</custom_configuration>
//   <ip>
//     <address>192.168.122.39</address>
//     <gateway>192.168.122.1</gateway>
//     <netmask>255.255.255.0</netmask>
//     <version>v4</version>
//   </ip>
//   <ipv6>
//     <gateway>::</gateway>
//     <version>v6</version>
//   </ipv6>
//   <ipv6_boot_protocol>none</ipv6_boot_protocol>
//   <mac>
//     <address>52:54:00:0c:79:1d</address>
//   </mac>
//   <mtu>1500</mtu>
//   <status>up</status>
// </host_nic>
// ----
//
// A bonded interface is represented as a <<types/host_nic, HostNic>> object
// containing the `bonding` and `slaves` attributes.
//
// For example, the XML representation of a bonded host NIC looks like this:
//
// [source,xml]
// ----
// <host_nic href="/ovirt-engine/api/hosts/123/nics/456" id="456">
//   <name>bond0</name>
//   <mac address="00:00:00:00:00:00"/>
//   <ip>
//     <address>192.168.122.39</address>
//     <gateway>192.168.122.1</gateway>
//     <netmask>255.255.255.0</netmask>
//     <version>v4</version>
//   </ip>
//   <boot_protocol>dhcp</boot_protocol>
//   <bonding>
//     <options>
//       <option>
//         <name>mode</name>
//         <value>4</value>
//         <type>Dynamic link aggregation (802.3ad)</type>
//       </option>
//       <option>
//         <name>miimon</name>
//         <value>100</value>
//       </option>
//     </options>
//     <slaves>
//       <host_nic id="123"/>
//       <host_nic id="456"/>
//     </slaves>
//   </bonding>
//   <mtu>1500</mtu>
//   <bridged>true</bridged>
//   <custom_configuration>false</custom_configuration>
// </host_nic>
// ----
func (p *HostNic) MustPhysicalFunction() *HostNic {
	if p.physicalFunction == nil {
		panic("the physicalFunction must not be nil, please use PhysicalFunction() function instead")
	}
	return p.physicalFunction
}

func (p *HostNic) SetProperties(attr *PropertySlice) {
	p.properties = attr
}

func (p *HostNic) Properties() (*PropertySlice, bool) {
	if p.properties != nil {
		return p.properties, true
	}
	return nil, false
}

func (p *HostNic) MustProperties() *PropertySlice {
	if p.properties == nil {
		panic("the properties must not be nil, please use Properties() function instead")
	}
	return p.properties
}

// SetQos This type represents the attributes to define Quality of service (QoS).
//
// For storage the `type` is <<types/qos_type, storage>>, the attributes `max_throughput`, `max_read_throughput`,
// `max_write_throughput`, `max_iops`, `max_read_iops` and `max_write_iops` are relevant.
//
// For resources with computing capabilities the `type` is <<types/qos_type, cpu>>, the attribute `cpu_limit` is
// relevant.
//
// For virtual machines networks the `type` is <<types/qos_type, network>>, the attributes `inbound_average`,
// `inbound_peak`, `inbound_burst`, `outbound_average`, `outbound_peak` and `outbound_burst` are relevant.
//
// For host networks the `type` is <<types/qos_type, hostnetwork>>, the attributes `outbound_average_linkshare`,
// `outbound_average_upperlimit` and `outbound_average_realtime` are relevant.
func (p *HostNic) SetQos(attr *Qos) {
	p.qos = attr
}

// Qos This type represents the attributes to define Quality of service (QoS).
//
// For storage the `type` is <<types/qos_type, storage>>, the attributes `max_throughput`, `max_read_throughput`,
// `max_write_throughput`, `max_iops`, `max_read_iops` and `max_write_iops` are relevant.
//
// For resources with computing capabilities the `type` is <<types/qos_type, cpu>>, the attribute `cpu_limit` is
// relevant.
//
// For virtual machines networks the `type` is <<types/qos_type, network>>, the attributes `inbound_average`,
// `inbound_peak`, `inbound_burst`, `outbound_average`, `outbound_peak` and `outbound_burst` are relevant.
//
// For host networks the `type` is <<types/qos_type, hostnetwork>>, the attributes `outbound_average_linkshare`,
// `outbound_average_upperlimit` and `outbound_average_realtime` are relevant.
func (p *HostNic) Qos() (*Qos, bool) {
	if p.qos != nil {
		return p.qos, true
	}
	return nil, false
}

// MustQos This type represents the attributes to define Quality of service (QoS).
//
// For storage the `type` is <<types/qos_type, storage>>, the attributes `max_throughput`, `max_read_throughput`,
// `max_write_throughput`, `max_iops`, `max_read_iops` and `max_write_iops` are relevant.
//
// For resources with computing capabilities the `type` is <<types/qos_type, cpu>>, the attribute `cpu_limit` is
// relevant.
//
// For virtual machines networks the `type` is <<types/qos_type, network>>, the attributes `inbound_average`,
// `inbound_peak`, `inbound_burst`, `outbound_average`, `outbound_peak` and `outbound_burst` are relevant.
//
// For host networks the `type` is <<types/qos_type, hostnetwork>>, the attributes `outbound_average_linkshare`,
// `outbound_average_upperlimit` and `outbound_average_realtime` are relevant.
func (p *HostNic) MustQos() *Qos {
	if p.qos == nil {
		panic("the qos must not be nil, please use Qos() function instead")
	}
	return p.qos
}

func (p *HostNic) SetSpeed(attr int64) {
	p.speed = &attr
}

func (p *HostNic) Speed() (int64, bool) {
	if p.speed != nil {
		return *p.speed, true
	}
	var zero int64
	return zero, false
}

func (p *HostNic) MustSpeed() int64 {
	if p.speed == nil {
		panic("the speed must not be nil, please use Speed() function instead")
	}
	return *p.speed
}

func (p *HostNic) SetStatistics(attr *StatisticSlice) {
	p.statistics = attr
}

func (p *HostNic) Statistics() (*StatisticSlice, bool) {
	if p.statistics != nil {
		return p.statistics, true
	}
	return nil, false
}

func (p *HostNic) MustStatistics() *StatisticSlice {
	if p.statistics == nil {
		panic("the statistics must not be nil, please use Statistics() function instead")
	}
	return p.statistics
}

// SetStatus Network interface card status.
func (p *HostNic) SetStatus(attr NicStatus) {
	p.status = &attr
}

// Status Network interface card status.
func (p *HostNic) Status() (NicStatus, bool) {
	if p.status != nil {
		return *p.status, true
	}
	var zero NicStatus
	return zero, false
}

// MustStatus Network interface card status.
func (p *HostNic) MustStatus() NicStatus {
	if p.status == nil {
		panic("the status must not be nil, please use Status() function instead")
	}
	return *p.status
}

// SetVirtualFunctionsConfiguration Describes the virtual functions configuration of an SR-IOV-enabled physical function NIC.
func (p *HostNic) SetVirtualFunctionsConfiguration(attr *HostNicVirtualFunctionsConfiguration) {
	p.virtualFunctionsConfiguration = attr
}

// VirtualFunctionsConfiguration Describes the virtual functions configuration of an SR-IOV-enabled physical function NIC.
func (p *HostNic) VirtualFunctionsConfiguration() (*HostNicVirtualFunctionsConfiguration, bool) {
	if p.virtualFunctionsConfiguration != nil {
		return p.virtualFunctionsConfiguration, true
	}
	return nil, false
}

// MustVirtualFunctionsConfiguration Describes the virtual functions configuration of an SR-IOV-enabled physical function NIC.
func (p *HostNic) MustVirtualFunctionsConfiguration() *HostNicVirtualFunctionsConfiguration {
	if p.virtualFunctionsConfiguration == nil {
		panic("the virtualFunctionsConfiguration must not be nil, please use VirtualFunctionsConfiguration() function instead")
	}
	return p.virtualFunctionsConfiguration
}

// SetVlan Type representing a Virtual LAN (VLAN) type.
func (p *HostNic) SetVlan(attr *Vlan) {
	p.vlan = attr
}

// Vlan Type representing a Virtual LAN (VLAN) type.
func (p *HostNic) Vlan() (*Vlan, bool) {
	if p.vlan != nil {
		return p.vlan, true
	}
	return nil, false
}

// MustVlan Type representing a Virtual LAN (VLAN) type.
func (p *HostNic) MustVlan() *Vlan {
	if p.vlan == nil {
		panic("the vlan must not be nil, please use Vlan() function instead")
	}
	return p.vlan
}

// HostNicVirtualFunctionsConfiguration Describes the virtual functions configuration of an SR-IOV-enabled physical function NIC.
type HostNicVirtualFunctionsConfiguration struct {
	Struct
	allNetworksAllowed          *bool
	maxNumberOfVirtualFunctions *int64
	numberOfVirtualFunctions    *int64
}

func (p *HostNicVirtualFunctionsConfiguration) SetAllNetworksAllowed(attr bool) {
	p.allNetworksAllowed = &attr
}

func (p *HostNicVirtualFunctionsConfiguration) AllNetworksAllowed() (bool, bool) {
	if p.allNetworksAllowed != nil {
		return *p.allNetworksAllowed, true
	}
	var zero bool
	return zero, false
}

func (p *HostNicVirtualFunctionsConfiguration) MustAllNetworksAllowed() bool {
	if p.allNetworksAllowed == nil {
		panic("the allNetworksAllowed must not be nil, please use AllNetworksAllowed() function instead")
	}
	return *p.allNetworksAllowed
}

func (p *HostNicVirtualFunctionsConfiguration) SetMaxNumberOfVirtualFunctions(attr int64) {
	p.maxNumberOfVirtualFunctions = &attr
}

func (p *HostNicVirtualFunctionsConfiguration) MaxNumberOfVirtualFunctions() (int64, bool) {
	if p.maxNumberOfVirtualFunctions != nil {
		return *p.maxNumberOfVirtualFunctions, true
	}
	var zero int64
	return zero, false
}

func (p *HostNicVirtualFunctionsConfiguration) MustMaxNumberOfVirtualFunctions() int64 {
	if p.maxNumberOfVirtualFunctions == nil {
		panic("the maxNumberOfVirtualFunctions must not be nil, please use MaxNumberOfVirtualFunctions() function instead")
	}
	return *p.maxNumberOfVirtualFunctions
}

func (p *HostNicVirtualFunctionsConfiguration) SetNumberOfVirtualFunctions(attr int64) {
	p.numberOfVirtualFunctions = &attr
}

func (p *HostNicVirtualFunctionsConfiguration) NumberOfVirtualFunctions() (int64, bool) {
	if p.numberOfVirtualFunctions != nil {
		return *p.numberOfVirtualFunctions, true
	}
	var zero int64
	return zero, false
}

func (p *HostNicVirtualFunctionsConfiguration) MustNumberOfVirtualFunctions() int64 {
	if p.numberOfVirtualFunctions == nil {
		panic("the numberOfVirtualFunctions must not be nil, please use NumberOfVirtualFunctions() function instead")
	}
	return *p.numberOfVirtualFunctions
}

type HostStorage struct {
	Struct
	address                *string
	comment                *string
	description            *string
	driverOptions          *PropertySlice
	driverSensitiveOptions *PropertySlice
	host                   *Host
	id                     *string
	logicalUnits           *LogicalUnitSlice
	mountOptions           *string
	name                   *string
	nfsRetrans             *int64
	nfsTimeo               *int64
	nfsVersion             *NfsVersion
	overrideLuns           *bool
	password               *string
	path                   *string
	port                   *int64
	portal                 *string
	target                 *string
	type_                  *StorageType
	username               *string
	vfsType                *string
	volumeGroup            *VolumeGroup
}

func (p *HostStorage) SetAddress(attr string) {
	p.address = &attr
}

func (p *HostStorage) Address() (string, bool) {
	if p.address != nil {
		return *p.address, true
	}
	var zero string
	return zero, false
}

func (p *HostStorage) MustAddress() string {
	if p.address == nil {
		panic("the address must not be nil, please use Address() function instead")
	}
	return *p.address
}

func (p *HostStorage) SetComment(attr string) {
	p.comment = &attr
}

func (p *HostStorage) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *HostStorage) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *HostStorage) SetDescription(attr string) {
	p.description = &attr
}

func (p *HostStorage) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *HostStorage) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *HostStorage) SetDriverOptions(attr *PropertySlice) {
	p.driverOptions = attr
}

func (p *HostStorage) DriverOptions() (*PropertySlice, bool) {
	if p.driverOptions != nil {
		return p.driverOptions, true
	}
	return nil, false
}

func (p *HostStorage) MustDriverOptions() *PropertySlice {
	if p.driverOptions == nil {
		panic("the driverOptions must not be nil, please use DriverOptions() function instead")
	}
	return p.driverOptions
}

func (p *HostStorage) SetDriverSensitiveOptions(attr *PropertySlice) {
	p.driverSensitiveOptions = attr
}

func (p *HostStorage) DriverSensitiveOptions() (*PropertySlice, bool) {
	if p.driverSensitiveOptions != nil {
		return p.driverSensitiveOptions, true
	}
	return nil, false
}

func (p *HostStorage) MustDriverSensitiveOptions() *PropertySlice {
	if p.driverSensitiveOptions == nil {
		panic("the driverSensitiveOptions must not be nil, please use DriverSensitiveOptions() function instead")
	}
	return p.driverSensitiveOptions
}

// SetHost Type representing a host.
func (p *HostStorage) SetHost(attr *Host) {
	p.host = attr
}

// Host Type representing a host.
func (p *HostStorage) Host() (*Host, bool) {
	if p.host != nil {
		return p.host, true
	}
	return nil, false
}

// MustHost Type representing a host.
func (p *HostStorage) MustHost() *Host {
	if p.host == nil {
		panic("the host must not be nil, please use Host() function instead")
	}
	return p.host
}

func (p *HostStorage) SetId(attr string) {
	p.id = &attr
}

func (p *HostStorage) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *HostStorage) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *HostStorage) SetLogicalUnits(attr *LogicalUnitSlice) {
	p.logicalUnits = attr
}

func (p *HostStorage) LogicalUnits() (*LogicalUnitSlice, bool) {
	if p.logicalUnits != nil {
		return p.logicalUnits, true
	}
	return nil, false
}

func (p *HostStorage) MustLogicalUnits() *LogicalUnitSlice {
	if p.logicalUnits == nil {
		panic("the logicalUnits must not be nil, please use LogicalUnits() function instead")
	}
	return p.logicalUnits
}

func (p *HostStorage) SetMountOptions(attr string) {
	p.mountOptions = &attr
}

func (p *HostStorage) MountOptions() (string, bool) {
	if p.mountOptions != nil {
		return *p.mountOptions, true
	}
	var zero string
	return zero, false
}

func (p *HostStorage) MustMountOptions() string {
	if p.mountOptions == nil {
		panic("the mountOptions must not be nil, please use MountOptions() function instead")
	}
	return *p.mountOptions
}

func (p *HostStorage) SetName(attr string) {
	p.name = &attr
}

func (p *HostStorage) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *HostStorage) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *HostStorage) SetNfsRetrans(attr int64) {
	p.nfsRetrans = &attr
}

func (p *HostStorage) NfsRetrans() (int64, bool) {
	if p.nfsRetrans != nil {
		return *p.nfsRetrans, true
	}
	var zero int64
	return zero, false
}

func (p *HostStorage) MustNfsRetrans() int64 {
	if p.nfsRetrans == nil {
		panic("the nfsRetrans must not be nil, please use NfsRetrans() function instead")
	}
	return *p.nfsRetrans
}

func (p *HostStorage) SetNfsTimeo(attr int64) {
	p.nfsTimeo = &attr
}

func (p *HostStorage) NfsTimeo() (int64, bool) {
	if p.nfsTimeo != nil {
		return *p.nfsTimeo, true
	}
	var zero int64
	return zero, false
}

func (p *HostStorage) MustNfsTimeo() int64 {
	if p.nfsTimeo == nil {
		panic("the nfsTimeo must not be nil, please use NfsTimeo() function instead")
	}
	return *p.nfsTimeo
}

func (p *HostStorage) SetNfsVersion(attr NfsVersion) {
	p.nfsVersion = &attr
}

func (p *HostStorage) NfsVersion() (NfsVersion, bool) {
	if p.nfsVersion != nil {
		return *p.nfsVersion, true
	}
	var zero NfsVersion
	return zero, false
}

func (p *HostStorage) MustNfsVersion() NfsVersion {
	if p.nfsVersion == nil {
		panic("the nfsVersion must not be nil, please use NfsVersion() function instead")
	}
	return *p.nfsVersion
}

func (p *HostStorage) SetOverrideLuns(attr bool) {
	p.overrideLuns = &attr
}

func (p *HostStorage) OverrideLuns() (bool, bool) {
	if p.overrideLuns != nil {
		return *p.overrideLuns, true
	}
	var zero bool
	return zero, false
}

func (p *HostStorage) MustOverrideLuns() bool {
	if p.overrideLuns == nil {
		panic("the overrideLuns must not be nil, please use OverrideLuns() function instead")
	}
	return *p.overrideLuns
}

func (p *HostStorage) SetPassword(attr string) {
	p.password = &attr
}

func (p *HostStorage) Password() (string, bool) {
	if p.password != nil {
		return *p.password, true
	}
	var zero string
	return zero, false
}

func (p *HostStorage) MustPassword() string {
	if p.password == nil {
		panic("the password must not be nil, please use Password() function instead")
	}
	return *p.password
}

func (p *HostStorage) SetPath(attr string) {
	p.path = &attr
}

func (p *HostStorage) Path() (string, bool) {
	if p.path != nil {
		return *p.path, true
	}
	var zero string
	return zero, false
}

func (p *HostStorage) MustPath() string {
	if p.path == nil {
		panic("the path must not be nil, please use Path() function instead")
	}
	return *p.path
}

func (p *HostStorage) SetPort(attr int64) {
	p.port = &attr
}

func (p *HostStorage) Port() (int64, bool) {
	if p.port != nil {
		return *p.port, true
	}
	var zero int64
	return zero, false
}

func (p *HostStorage) MustPort() int64 {
	if p.port == nil {
		panic("the port must not be nil, please use Port() function instead")
	}
	return *p.port
}

func (p *HostStorage) SetPortal(attr string) {
	p.portal = &attr
}

func (p *HostStorage) Portal() (string, bool) {
	if p.portal != nil {
		return *p.portal, true
	}
	var zero string
	return zero, false
}

func (p *HostStorage) MustPortal() string {
	if p.portal == nil {
		panic("the portal must not be nil, please use Portal() function instead")
	}
	return *p.portal
}

func (p *HostStorage) SetTarget(attr string) {
	p.target = &attr
}

func (p *HostStorage) Target() (string, bool) {
	if p.target != nil {
		return *p.target, true
	}
	var zero string
	return zero, false
}

func (p *HostStorage) MustTarget() string {
	if p.target == nil {
		panic("the target must not be nil, please use Target() function instead")
	}
	return *p.target
}

// SetType Type representing a storage domain type.
func (p *HostStorage) SetType(attr StorageType) {
	p.type_ = &attr
}

// Type Type representing a storage domain type.
func (p *HostStorage) Type() (StorageType, bool) {
	if p.type_ != nil {
		return *p.type_, true
	}
	var zero StorageType
	return zero, false
}

// MustType Type representing a storage domain type.
func (p *HostStorage) MustType() StorageType {
	if p.type_ == nil {
		panic("the type_ must not be nil, please use Type() function instead")
	}
	return *p.type_
}

func (p *HostStorage) SetUsername(attr string) {
	p.username = &attr
}

func (p *HostStorage) Username() (string, bool) {
	if p.username != nil {
		return *p.username, true
	}
	var zero string
	return zero, false
}

func (p *HostStorage) MustUsername() string {
	if p.username == nil {
		panic("the username must not be nil, please use Username() function instead")
	}
	return *p.username
}

func (p *HostStorage) SetVfsType(attr string) {
	p.vfsType = &attr
}

func (p *HostStorage) VfsType() (string, bool) {
	if p.vfsType != nil {
		return *p.vfsType, true
	}
	var zero string
	return zero, false
}

func (p *HostStorage) MustVfsType() string {
	if p.vfsType == nil {
		panic("the vfsType must not be nil, please use VfsType() function instead")
	}
	return *p.vfsType
}

func (p *HostStorage) SetVolumeGroup(attr *VolumeGroup) {
	p.volumeGroup = attr
}

func (p *HostStorage) VolumeGroup() (*VolumeGroup, bool) {
	if p.volumeGroup != nil {
		return p.volumeGroup, true
	}
	return nil, false
}

func (p *HostStorage) MustVolumeGroup() *VolumeGroup {
	if p.volumeGroup == nil {
		panic("the volumeGroup must not be nil, please use VolumeGroup() function instead")
	}
	return p.volumeGroup
}

type HostedEngine struct {
	Struct
	active            *bool
	configured        *bool
	globalMaintenance *bool
	localMaintenance  *bool
	score             *int64
}

func (p *HostedEngine) SetActive(attr bool) {
	p.active = &attr
}

func (p *HostedEngine) Active() (bool, bool) {
	if p.active != nil {
		return *p.active, true
	}
	var zero bool
	return zero, false
}

func (p *HostedEngine) MustActive() bool {
	if p.active == nil {
		panic("the active must not be nil, please use Active() function instead")
	}
	return *p.active
}

func (p *HostedEngine) SetConfigured(attr bool) {
	p.configured = &attr
}

func (p *HostedEngine) Configured() (bool, bool) {
	if p.configured != nil {
		return *p.configured, true
	}
	var zero bool
	return zero, false
}

func (p *HostedEngine) MustConfigured() bool {
	if p.configured == nil {
		panic("the configured must not be nil, please use Configured() function instead")
	}
	return *p.configured
}

func (p *HostedEngine) SetGlobalMaintenance(attr bool) {
	p.globalMaintenance = &attr
}

func (p *HostedEngine) GlobalMaintenance() (bool, bool) {
	if p.globalMaintenance != nil {
		return *p.globalMaintenance, true
	}
	var zero bool
	return zero, false
}

func (p *HostedEngine) MustGlobalMaintenance() bool {
	if p.globalMaintenance == nil {
		panic("the globalMaintenance must not be nil, please use GlobalMaintenance() function instead")
	}
	return *p.globalMaintenance
}

func (p *HostedEngine) SetLocalMaintenance(attr bool) {
	p.localMaintenance = &attr
}

func (p *HostedEngine) LocalMaintenance() (bool, bool) {
	if p.localMaintenance != nil {
		return *p.localMaintenance, true
	}
	var zero bool
	return zero, false
}

func (p *HostedEngine) MustLocalMaintenance() bool {
	if p.localMaintenance == nil {
		panic("the localMaintenance must not be nil, please use LocalMaintenance() function instead")
	}
	return *p.localMaintenance
}

func (p *HostedEngine) SetScore(attr int64) {
	p.score = &attr
}

func (p *HostedEngine) Score() (int64, bool) {
	if p.score != nil {
		return *p.score, true
	}
	var zero int64
	return zero, false
}

func (p *HostedEngine) MustScore() int64 {
	if p.score == nil {
		panic("the score must not be nil, please use Score() function instead")
	}
	return *p.score
}

// Icon Icon of virtual machine or template.
type Icon struct {
	Struct
	comment     *string
	data        *string
	description *string
	id          *string
	mediaType   *string
	name        *string
}

func (p *Icon) SetComment(attr string) {
	p.comment = &attr
}

func (p *Icon) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *Icon) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *Icon) SetData(attr string) {
	p.data = &attr
}

func (p *Icon) Data() (string, bool) {
	if p.data != nil {
		return *p.data, true
	}
	var zero string
	return zero, false
}

func (p *Icon) MustData() string {
	if p.data == nil {
		panic("the data must not be nil, please use Data() function instead")
	}
	return *p.data
}

func (p *Icon) SetDescription(attr string) {
	p.description = &attr
}

func (p *Icon) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *Icon) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *Icon) SetId(attr string) {
	p.id = &attr
}

func (p *Icon) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *Icon) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *Icon) SetMediaType(attr string) {
	p.mediaType = &attr
}

func (p *Icon) MediaType() (string, bool) {
	if p.mediaType != nil {
		return *p.mediaType, true
	}
	var zero string
	return zero, false
}

func (p *Icon) MustMediaType() string {
	if p.mediaType == nil {
		panic("the mediaType must not be nil, please use MediaType() function instead")
	}
	return *p.mediaType
}

func (p *Icon) SetName(attr string) {
	p.name = &attr
}

func (p *Icon) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *Icon) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

// Identified This interface is the base model for all types that represent objects with an identifier.
type Identified struct {
	Struct
	comment     *string
	description *string
	id          *string
	name        *string
}

func (p *Identified) SetComment(attr string) {
	p.comment = &attr
}

func (p *Identified) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *Identified) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *Identified) SetDescription(attr string) {
	p.description = &attr
}

func (p *Identified) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *Identified) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *Identified) SetId(attr string) {
	p.id = &attr
}

func (p *Identified) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *Identified) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *Identified) SetName(attr string) {
	p.name = &attr
}

func (p *Identified) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *Identified) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

// Image Represents an image entity.
type Image struct {
	Struct
	comment       *string
	description   *string
	id            *string
	name          *string
	size          *int64
	storageDomain *StorageDomain
	type_         *ImageFileType
}

func (p *Image) SetComment(attr string) {
	p.comment = &attr
}

func (p *Image) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *Image) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *Image) SetDescription(attr string) {
	p.description = &attr
}

func (p *Image) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *Image) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *Image) SetId(attr string) {
	p.id = &attr
}

func (p *Image) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *Image) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *Image) SetName(attr string) {
	p.name = &attr
}

func (p *Image) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *Image) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *Image) SetSize(attr int64) {
	p.size = &attr
}

func (p *Image) Size() (int64, bool) {
	if p.size != nil {
		return *p.size, true
	}
	var zero int64
	return zero, false
}

func (p *Image) MustSize() int64 {
	if p.size == nil {
		panic("the size must not be nil, please use Size() function instead")
	}
	return *p.size
}

// SetStorageDomain Storage domain.
//
// An XML representation of a NFS storage domain with identifier `123`:
//
// [source,xml]
// ----
// <storage_domain href="/ovirt-engine/api/storagedomains/123" id="123">
//   <name>mydata</name>
//   <description>My data</description>
//   <available>38654705664</available>
//   <committed>1073741824</committed>
//   <critical_space_action_blocker>5</critical_space_action_blocker>
//   <external_status>ok</external_status>
//   <master>true</master>
//   <storage>
//     <address>mynfs.example.com</address>
//     <nfs_version>v3</nfs_version>
//     <path>/exports/mydata</path>
//     <type>nfs</type>
//   </storage>
//   <storage_format>v3</storage_format>
//   <type>data</type>
//   <used>13958643712</used>
//   <warning_low_space_indicator>10</warning_low_space_indicator>
//   <wipe_after_delete>false</wipe_after_delete>
//   <data_centers>
//     <data_center href="/ovirt-engine/api/datacenters/456" id="456"/>
//   </data_centers>
// </storage_domain>
// ----
func (p *Image) SetStorageDomain(attr *StorageDomain) {
	p.storageDomain = attr
}

// StorageDomain Storage domain.
//
// An XML representation of a NFS storage domain with identifier `123`:
//
// [source,xml]
// ----
// <storage_domain href="/ovirt-engine/api/storagedomains/123" id="123">
//   <name>mydata</name>
//   <description>My data</description>
//   <available>38654705664</available>
//   <committed>1073741824</committed>
//   <critical_space_action_blocker>5</critical_space_action_blocker>
//   <external_status>ok</external_status>
//   <master>true</master>
//   <storage>
//     <address>mynfs.example.com</address>
//     <nfs_version>v3</nfs_version>
//     <path>/exports/mydata</path>
//     <type>nfs</type>
//   </storage>
//   <storage_format>v3</storage_format>
//   <type>data</type>
//   <used>13958643712</used>
//   <warning_low_space_indicator>10</warning_low_space_indicator>
//   <wipe_after_delete>false</wipe_after_delete>
//   <data_centers>
//     <data_center href="/ovirt-engine/api/datacenters/456" id="456"/>
//   </data_centers>
// </storage_domain>
// ----
func (p *Image) StorageDomain() (*StorageDomain, bool) {
	if p.storageDomain != nil {
		return p.storageDomain, true
	}
	return nil, false
}

// MustStorageDomain Storage domain.
//
// An XML representation of a NFS storage domain with identifier `123`:
//
// [source,xml]
// ----
// <storage_domain href="/ovirt-engine/api/storagedomains/123" id="123">
//   <name>mydata</name>
//   <description>My data</description>
//   <available>38654705664</available>
//   <committed>1073741824</committed>
//   <critical_space_action_blocker>5</critical_space_action_blocker>
//   <external_status>ok</external_status>
//   <master>true</master>
//   <storage>
//     <address>mynfs.example.com</address>
//     <nfs_version>v3</nfs_version>
//     <path>/exports/mydata</path>
//     <type>nfs</type>
//   </storage>
//   <storage_format>v3</storage_format>
//   <type>data</type>
//   <used>13958643712</used>
//   <warning_low_space_indicator>10</warning_low_space_indicator>
//   <wipe_after_delete>false</wipe_after_delete>
//   <data_centers>
//     <data_center href="/ovirt-engine/api/datacenters/456" id="456"/>
//   </data_centers>
// </storage_domain>
// ----
func (p *Image) MustStorageDomain() *StorageDomain {
	if p.storageDomain == nil {
		panic("the storageDomain must not be nil, please use StorageDomain() function instead")
	}
	return p.storageDomain
}

// SetType Represents the file type of an image.
func (p *Image) SetType(attr ImageFileType) {
	p.type_ = &attr
}

// Type Represents the file type of an image.
func (p *Image) Type() (ImageFileType, bool) {
	if p.type_ != nil {
		return *p.type_, true
	}
	var zero ImageFileType
	return zero, false
}

// MustType Represents the file type of an image.
func (p *Image) MustType() ImageFileType {
	if p.type_ == nil {
		panic("the type_ must not be nil, please use Type() function instead")
	}
	return *p.type_
}

// ImageTransfer This type contains information regarding an image transfer being performed.
type ImageTransfer struct {
	Struct
	active            *bool
	backup            *Backup
	comment           *string
	description       *string
	direction         *ImageTransferDirection
	disk              *Disk
	format            *DiskFormat
	host              *Host
	id                *string
	image             *Image
	inactivityTimeout *int64
	name              *string
	phase             *ImageTransferPhase
	proxyUrl          *string
	shallow           *bool
	snapshot          *DiskSnapshot
	timeoutPolicy     *ImageTransferTimeoutPolicy
	transferUrl       *string
	transferred       *int64
}

func (p *ImageTransfer) SetActive(attr bool) {
	p.active = &attr
}

func (p *ImageTransfer) Active() (bool, bool) {
	if p.active != nil {
		return *p.active, true
	}
	var zero bool
	return zero, false
}

func (p *ImageTransfer) MustActive() bool {
	if p.active == nil {
		panic("the active must not be nil, please use Active() function instead")
	}
	return *p.active
}

func (p *ImageTransfer) SetBackup(attr *Backup) {
	p.backup = attr
}

func (p *ImageTransfer) Backup() (*Backup, bool) {
	if p.backup != nil {
		return p.backup, true
	}
	return nil, false
}

func (p *ImageTransfer) MustBackup() *Backup {
	if p.backup == nil {
		panic("the backup must not be nil, please use Backup() function instead")
	}
	return p.backup
}

func (p *ImageTransfer) SetComment(attr string) {
	p.comment = &attr
}

func (p *ImageTransfer) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *ImageTransfer) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *ImageTransfer) SetDescription(attr string) {
	p.description = &attr
}

func (p *ImageTransfer) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *ImageTransfer) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

// SetDirection The <<types/image_transfer, image transfer>> direction for a transfer.
//
// When adding a new transfer, the user can choose whether the transfer will be to an image, choosing `upload`,
// or to transfer from an image- choosing `download` as an ImageTransferDirection.
//
// Please refer to <<services/image_transfer, image transfer>> for further
// documentation.
func (p *ImageTransfer) SetDirection(attr ImageTransferDirection) {
	p.direction = &attr
}

// Direction The <<types/image_transfer, image transfer>> direction for a transfer.
//
// When adding a new transfer, the user can choose whether the transfer will be to an image, choosing `upload`,
// or to transfer from an image- choosing `download` as an ImageTransferDirection.
//
// Please refer to <<services/image_transfer, image transfer>> for further
// documentation.
func (p *ImageTransfer) Direction() (ImageTransferDirection, bool) {
	if p.direction != nil {
		return *p.direction, true
	}
	var zero ImageTransferDirection
	return zero, false
}

// MustDirection The <<types/image_transfer, image transfer>> direction for a transfer.
//
// When adding a new transfer, the user can choose whether the transfer will be to an image, choosing `upload`,
// or to transfer from an image- choosing `download` as an ImageTransferDirection.
//
// Please refer to <<services/image_transfer, image transfer>> for further
// documentation.
func (p *ImageTransfer) MustDirection() ImageTransferDirection {
	if p.direction == nil {
		panic("the direction must not be nil, please use Direction() function instead")
	}
	return *p.direction
}

// SetDisk Represents a virtual disk device.
func (p *ImageTransfer) SetDisk(attr *Disk) {
	p.disk = attr
}

// Disk Represents a virtual disk device.
func (p *ImageTransfer) Disk() (*Disk, bool) {
	if p.disk != nil {
		return p.disk, true
	}
	return nil, false
}

// MustDisk Represents a virtual disk device.
func (p *ImageTransfer) MustDisk() *Disk {
	if p.disk == nil {
		panic("the disk must not be nil, please use Disk() function instead")
	}
	return p.disk
}

// SetFormat The underlying storage format of disks.
func (p *ImageTransfer) SetFormat(attr DiskFormat) {
	p.format = &attr
}

// Format The underlying storage format of disks.
func (p *ImageTransfer) Format() (DiskFormat, bool) {
	if p.format != nil {
		return *p.format, true
	}
	var zero DiskFormat
	return zero, false
}

// MustFormat The underlying storage format of disks.
func (p *ImageTransfer) MustFormat() DiskFormat {
	if p.format == nil {
		panic("the format must not be nil, please use Format() function instead")
	}
	return *p.format
}

// SetHost Type representing a host.
func (p *ImageTransfer) SetHost(attr *Host) {
	p.host = attr
}

// Host Type representing a host.
func (p *ImageTransfer) Host() (*Host, bool) {
	if p.host != nil {
		return p.host, true
	}
	return nil, false
}

// MustHost Type representing a host.
func (p *ImageTransfer) MustHost() *Host {
	if p.host == nil {
		panic("the host must not be nil, please use Host() function instead")
	}
	return p.host
}

func (p *ImageTransfer) SetId(attr string) {
	p.id = &attr
}

func (p *ImageTransfer) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *ImageTransfer) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

// SetImage Represents an image entity.
func (p *ImageTransfer) SetImage(attr *Image) {
	p.image = attr
}

// Image Represents an image entity.
func (p *ImageTransfer) Image() (*Image, bool) {
	if p.image != nil {
		return p.image, true
	}
	return nil, false
}

// MustImage Represents an image entity.
func (p *ImageTransfer) MustImage() *Image {
	if p.image == nil {
		panic("the image must not be nil, please use Image() function instead")
	}
	return p.image
}

func (p *ImageTransfer) SetInactivityTimeout(attr int64) {
	p.inactivityTimeout = &attr
}

func (p *ImageTransfer) InactivityTimeout() (int64, bool) {
	if p.inactivityTimeout != nil {
		return *p.inactivityTimeout, true
	}
	var zero int64
	return zero, false
}

func (p *ImageTransfer) MustInactivityTimeout() int64 {
	if p.inactivityTimeout == nil {
		panic("the inactivityTimeout must not be nil, please use InactivityTimeout() function instead")
	}
	return *p.inactivityTimeout
}

func (p *ImageTransfer) SetName(attr string) {
	p.name = &attr
}

func (p *ImageTransfer) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *ImageTransfer) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

// SetPhase A list of possible phases for an <<types/image_transfer, image transfer>> entity. Each of these values
// defines a specific point in a transfer flow.
//
// Please refer to <<services/image_transfer, image transfer>> for more
// information.
func (p *ImageTransfer) SetPhase(attr ImageTransferPhase) {
	p.phase = &attr
}

// Phase A list of possible phases for an <<types/image_transfer, image transfer>> entity. Each of these values
// defines a specific point in a transfer flow.
//
// Please refer to <<services/image_transfer, image transfer>> for more
// information.
func (p *ImageTransfer) Phase() (ImageTransferPhase, bool) {
	if p.phase != nil {
		return *p.phase, true
	}
	var zero ImageTransferPhase
	return zero, false
}

// MustPhase A list of possible phases for an <<types/image_transfer, image transfer>> entity. Each of these values
// defines a specific point in a transfer flow.
//
// Please refer to <<services/image_transfer, image transfer>> for more
// information.
func (p *ImageTransfer) MustPhase() ImageTransferPhase {
	if p.phase == nil {
		panic("the phase must not be nil, please use Phase() function instead")
	}
	return *p.phase
}

func (p *ImageTransfer) SetProxyUrl(attr string) {
	p.proxyUrl = &attr
}

func (p *ImageTransfer) ProxyUrl() (string, bool) {
	if p.proxyUrl != nil {
		return *p.proxyUrl, true
	}
	var zero string
	return zero, false
}

func (p *ImageTransfer) MustProxyUrl() string {
	if p.proxyUrl == nil {
		panic("the proxyUrl must not be nil, please use ProxyUrl() function instead")
	}
	return *p.proxyUrl
}

func (p *ImageTransfer) SetShallow(attr bool) {
	p.shallow = &attr
}

func (p *ImageTransfer) Shallow() (bool, bool) {
	if p.shallow != nil {
		return *p.shallow, true
	}
	var zero bool
	return zero, false
}

func (p *ImageTransfer) MustShallow() bool {
	if p.shallow == nil {
		panic("the shallow must not be nil, please use Shallow() function instead")
	}
	return *p.shallow
}

func (p *ImageTransfer) SetSnapshot(attr *DiskSnapshot) {
	p.snapshot = attr
}

func (p *ImageTransfer) Snapshot() (*DiskSnapshot, bool) {
	if p.snapshot != nil {
		return p.snapshot, true
	}
	return nil, false
}

func (p *ImageTransfer) MustSnapshot() *DiskSnapshot {
	if p.snapshot == nil {
		panic("the snapshot must not be nil, please use Snapshot() function instead")
	}
	return p.snapshot
}

// SetTimeoutPolicy The <<types/image_transfer, image transfer>> timeout policy.
//
// Define how the system handles a transfer when the client is inactive
// for inactivityTimeout seconds.
//
// Please refer to <<services/image_transfer, image transfer>> for further
// documentation.
func (p *ImageTransfer) SetTimeoutPolicy(attr ImageTransferTimeoutPolicy) {
	p.timeoutPolicy = &attr
}

// TimeoutPolicy The <<types/image_transfer, image transfer>> timeout policy.
//
// Define how the system handles a transfer when the client is inactive
// for inactivityTimeout seconds.
//
// Please refer to <<services/image_transfer, image transfer>> for further
// documentation.
func (p *ImageTransfer) TimeoutPolicy() (ImageTransferTimeoutPolicy, bool) {
	if p.timeoutPolicy != nil {
		return *p.timeoutPolicy, true
	}
	var zero ImageTransferTimeoutPolicy
	return zero, false
}

// MustTimeoutPolicy The <<types/image_transfer, image transfer>> timeout policy.
//
// Define how the system handles a transfer when the client is inactive
// for inactivityTimeout seconds.
//
// Please refer to <<services/image_transfer, image transfer>> for further
// documentation.
func (p *ImageTransfer) MustTimeoutPolicy() ImageTransferTimeoutPolicy {
	if p.timeoutPolicy == nil {
		panic("the timeoutPolicy must not be nil, please use TimeoutPolicy() function instead")
	}
	return *p.timeoutPolicy
}

func (p *ImageTransfer) SetTransferUrl(attr string) {
	p.transferUrl = &attr
}

func (p *ImageTransfer) TransferUrl() (string, bool) {
	if p.transferUrl != nil {
		return *p.transferUrl, true
	}
	var zero string
	return zero, false
}

func (p *ImageTransfer) MustTransferUrl() string {
	if p.transferUrl == nil {
		panic("the transferUrl must not be nil, please use TransferUrl() function instead")
	}
	return *p.transferUrl
}

func (p *ImageTransfer) SetTransferred(attr int64) {
	p.transferred = &attr
}

func (p *ImageTransfer) Transferred() (int64, bool) {
	if p.transferred != nil {
		return *p.transferred, true
	}
	var zero int64
	return zero, false
}

func (p *ImageTransfer) MustTransferred() int64 {
	if p.transferred == nil {
		panic("the transferred must not be nil, please use Transferred() function instead")
	}
	return *p.transferred
}

type Initialization struct {
	Struct
	activeDirectoryOu        *string
	authorizedSshKeys        *string
	cloudInit                *CloudInit
	cloudInitNetworkProtocol *CloudInitNetworkProtocol
	configuration            *Configuration
	customScript             *string
	dnsSearch                *string
	dnsServers               *string
	domain                   *string
	hostName                 *string
	inputLocale              *string
	nicConfigurations        *NicConfigurationSlice
	orgName                  *string
	regenerateIds            *bool
	regenerateSshKeys        *bool
	rootPassword             *string
	systemLocale             *string
	timezone                 *string
	uiLanguage               *string
	userLocale               *string
	userName                 *string
	windowsLicenseKey        *string
}

func (p *Initialization) SetActiveDirectoryOu(attr string) {
	p.activeDirectoryOu = &attr
}

func (p *Initialization) ActiveDirectoryOu() (string, bool) {
	if p.activeDirectoryOu != nil {
		return *p.activeDirectoryOu, true
	}
	var zero string
	return zero, false
}

func (p *Initialization) MustActiveDirectoryOu() string {
	if p.activeDirectoryOu == nil {
		panic("the activeDirectoryOu must not be nil, please use ActiveDirectoryOu() function instead")
	}
	return *p.activeDirectoryOu
}

func (p *Initialization) SetAuthorizedSshKeys(attr string) {
	p.authorizedSshKeys = &attr
}

func (p *Initialization) AuthorizedSshKeys() (string, bool) {
	if p.authorizedSshKeys != nil {
		return *p.authorizedSshKeys, true
	}
	var zero string
	return zero, false
}

func (p *Initialization) MustAuthorizedSshKeys() string {
	if p.authorizedSshKeys == nil {
		panic("the authorizedSshKeys must not be nil, please use AuthorizedSshKeys() function instead")
	}
	return *p.authorizedSshKeys
}

// SetCloudInit Deprecated type to specify _cloud-init_ configuration.
//
// This type has been deprecated and replaced by alternative attributes inside the
// <<types/initialization, Initialization>> type. See the
// <<types/initialization/attributes/cloud_init, cloud_init>> attribute documentation for details.
func (p *Initialization) SetCloudInit(attr *CloudInit) {
	p.cloudInit = attr
}

// CloudInit Deprecated type to specify _cloud-init_ configuration.
//
// This type has been deprecated and replaced by alternative attributes inside the
// <<types/initialization, Initialization>> type. See the
// <<types/initialization/attributes/cloud_init, cloud_init>> attribute documentation for details.
func (p *Initialization) CloudInit() (*CloudInit, bool) {
	if p.cloudInit != nil {
		return p.cloudInit, true
	}
	return nil, false
}

// MustCloudInit Deprecated type to specify _cloud-init_ configuration.
//
// This type has been deprecated and replaced by alternative attributes inside the
// <<types/initialization, Initialization>> type. See the
// <<types/initialization/attributes/cloud_init, cloud_init>> attribute documentation for details.
func (p *Initialization) MustCloudInit() *CloudInit {
	if p.cloudInit == nil {
		panic("the cloudInit must not be nil, please use CloudInit() function instead")
	}
	return p.cloudInit
}

// SetCloudInitNetworkProtocol Defines the values for the cloud-init protocol.
// This protocol decides how the cloud-init network
// parameters are formatted before being passed to
// the virtual machine in order to be processed by cloud-init.
//
// Protocols supported are cloud-init version dependent.
// For more information, see
// http://cloudinit.readthedocs.io/en/latest/topics/network-config.html#network-configuration-sources[Network Configuration Sources]
func (p *Initialization) SetCloudInitNetworkProtocol(attr CloudInitNetworkProtocol) {
	p.cloudInitNetworkProtocol = &attr
}

// CloudInitNetworkProtocol Defines the values for the cloud-init protocol.
// This protocol decides how the cloud-init network
// parameters are formatted before being passed to
// the virtual machine in order to be processed by cloud-init.
//
// Protocols supported are cloud-init version dependent.
// For more information, see
// http://cloudinit.readthedocs.io/en/latest/topics/network-config.html#network-configuration-sources[Network Configuration Sources]
func (p *Initialization) CloudInitNetworkProtocol() (CloudInitNetworkProtocol, bool) {
	if p.cloudInitNetworkProtocol != nil {
		return *p.cloudInitNetworkProtocol, true
	}
	var zero CloudInitNetworkProtocol
	return zero, false
}

// MustCloudInitNetworkProtocol Defines the values for the cloud-init protocol.
// This protocol decides how the cloud-init network
// parameters are formatted before being passed to
// the virtual machine in order to be processed by cloud-init.
//
// Protocols supported are cloud-init version dependent.
// For more information, see
// http://cloudinit.readthedocs.io/en/latest/topics/network-config.html#network-configuration-sources[Network Configuration Sources]
func (p *Initialization) MustCloudInitNetworkProtocol() CloudInitNetworkProtocol {
	if p.cloudInitNetworkProtocol == nil {
		panic("the cloudInitNetworkProtocol must not be nil, please use CloudInitNetworkProtocol() function instead")
	}
	return *p.cloudInitNetworkProtocol
}

func (p *Initialization) SetConfiguration(attr *Configuration) {
	p.configuration = attr
}

func (p *Initialization) Configuration() (*Configuration, bool) {
	if p.configuration != nil {
		return p.configuration, true
	}
	return nil, false
}

func (p *Initialization) MustConfiguration() *Configuration {
	if p.configuration == nil {
		panic("the configuration must not be nil, please use Configuration() function instead")
	}
	return p.configuration
}

func (p *Initialization) SetCustomScript(attr string) {
	p.customScript = &attr
}

func (p *Initialization) CustomScript() (string, bool) {
	if p.customScript != nil {
		return *p.customScript, true
	}
	var zero string
	return zero, false
}

func (p *Initialization) MustCustomScript() string {
	if p.customScript == nil {
		panic("the customScript must not be nil, please use CustomScript() function instead")
	}
	return *p.customScript
}

func (p *Initialization) SetDnsSearch(attr string) {
	p.dnsSearch = &attr
}

func (p *Initialization) DnsSearch() (string, bool) {
	if p.dnsSearch != nil {
		return *p.dnsSearch, true
	}
	var zero string
	return zero, false
}

func (p *Initialization) MustDnsSearch() string {
	if p.dnsSearch == nil {
		panic("the dnsSearch must not be nil, please use DnsSearch() function instead")
	}
	return *p.dnsSearch
}

func (p *Initialization) SetDnsServers(attr string) {
	p.dnsServers = &attr
}

func (p *Initialization) DnsServers() (string, bool) {
	if p.dnsServers != nil {
		return *p.dnsServers, true
	}
	var zero string
	return zero, false
}

func (p *Initialization) MustDnsServers() string {
	if p.dnsServers == nil {
		panic("the dnsServers must not be nil, please use DnsServers() function instead")
	}
	return *p.dnsServers
}

func (p *Initialization) SetDomain(attr string) {
	p.domain = &attr
}

func (p *Initialization) Domain() (string, bool) {
	if p.domain != nil {
		return *p.domain, true
	}
	var zero string
	return zero, false
}

func (p *Initialization) MustDomain() string {
	if p.domain == nil {
		panic("the domain must not be nil, please use Domain() function instead")
	}
	return *p.domain
}

func (p *Initialization) SetHostName(attr string) {
	p.hostName = &attr
}

func (p *Initialization) HostName() (string, bool) {
	if p.hostName != nil {
		return *p.hostName, true
	}
	var zero string
	return zero, false
}

func (p *Initialization) MustHostName() string {
	if p.hostName == nil {
		panic("the hostName must not be nil, please use HostName() function instead")
	}
	return *p.hostName
}

func (p *Initialization) SetInputLocale(attr string) {
	p.inputLocale = &attr
}

func (p *Initialization) InputLocale() (string, bool) {
	if p.inputLocale != nil {
		return *p.inputLocale, true
	}
	var zero string
	return zero, false
}

func (p *Initialization) MustInputLocale() string {
	if p.inputLocale == nil {
		panic("the inputLocale must not be nil, please use InputLocale() function instead")
	}
	return *p.inputLocale
}

func (p *Initialization) SetNicConfigurations(attr *NicConfigurationSlice) {
	p.nicConfigurations = attr
}

func (p *Initialization) NicConfigurations() (*NicConfigurationSlice, bool) {
	if p.nicConfigurations != nil {
		return p.nicConfigurations, true
	}
	return nil, false
}

func (p *Initialization) MustNicConfigurations() *NicConfigurationSlice {
	if p.nicConfigurations == nil {
		panic("the nicConfigurations must not be nil, please use NicConfigurations() function instead")
	}
	return p.nicConfigurations
}

func (p *Initialization) SetOrgName(attr string) {
	p.orgName = &attr
}

func (p *Initialization) OrgName() (string, bool) {
	if p.orgName != nil {
		return *p.orgName, true
	}
	var zero string
	return zero, false
}

func (p *Initialization) MustOrgName() string {
	if p.orgName == nil {
		panic("the orgName must not be nil, please use OrgName() function instead")
	}
	return *p.orgName
}

func (p *Initialization) SetRegenerateIds(attr bool) {
	p.regenerateIds = &attr
}

func (p *Initialization) RegenerateIds() (bool, bool) {
	if p.regenerateIds != nil {
		return *p.regenerateIds, true
	}
	var zero bool
	return zero, false
}

func (p *Initialization) MustRegenerateIds() bool {
	if p.regenerateIds == nil {
		panic("the regenerateIds must not be nil, please use RegenerateIds() function instead")
	}
	return *p.regenerateIds
}

func (p *Initialization) SetRegenerateSshKeys(attr bool) {
	p.regenerateSshKeys = &attr
}

func (p *Initialization) RegenerateSshKeys() (bool, bool) {
	if p.regenerateSshKeys != nil {
		return *p.regenerateSshKeys, true
	}
	var zero bool
	return zero, false
}

func (p *Initialization) MustRegenerateSshKeys() bool {
	if p.regenerateSshKeys == nil {
		panic("the regenerateSshKeys must not be nil, please use RegenerateSshKeys() function instead")
	}
	return *p.regenerateSshKeys
}

func (p *Initialization) SetRootPassword(attr string) {
	p.rootPassword = &attr
}

func (p *Initialization) RootPassword() (string, bool) {
	if p.rootPassword != nil {
		return *p.rootPassword, true
	}
	var zero string
	return zero, false
}

func (p *Initialization) MustRootPassword() string {
	if p.rootPassword == nil {
		panic("the rootPassword must not be nil, please use RootPassword() function instead")
	}
	return *p.rootPassword
}

func (p *Initialization) SetSystemLocale(attr string) {
	p.systemLocale = &attr
}

func (p *Initialization) SystemLocale() (string, bool) {
	if p.systemLocale != nil {
		return *p.systemLocale, true
	}
	var zero string
	return zero, false
}

func (p *Initialization) MustSystemLocale() string {
	if p.systemLocale == nil {
		panic("the systemLocale must not be nil, please use SystemLocale() function instead")
	}
	return *p.systemLocale
}

func (p *Initialization) SetTimezone(attr string) {
	p.timezone = &attr
}

func (p *Initialization) Timezone() (string, bool) {
	if p.timezone != nil {
		return *p.timezone, true
	}
	var zero string
	return zero, false
}

func (p *Initialization) MustTimezone() string {
	if p.timezone == nil {
		panic("the timezone must not be nil, please use Timezone() function instead")
	}
	return *p.timezone
}

func (p *Initialization) SetUiLanguage(attr string) {
	p.uiLanguage = &attr
}

func (p *Initialization) UiLanguage() (string, bool) {
	if p.uiLanguage != nil {
		return *p.uiLanguage, true
	}
	var zero string
	return zero, false
}

func (p *Initialization) MustUiLanguage() string {
	if p.uiLanguage == nil {
		panic("the uiLanguage must not be nil, please use UiLanguage() function instead")
	}
	return *p.uiLanguage
}

func (p *Initialization) SetUserLocale(attr string) {
	p.userLocale = &attr
}

func (p *Initialization) UserLocale() (string, bool) {
	if p.userLocale != nil {
		return *p.userLocale, true
	}
	var zero string
	return zero, false
}

func (p *Initialization) MustUserLocale() string {
	if p.userLocale == nil {
		panic("the userLocale must not be nil, please use UserLocale() function instead")
	}
	return *p.userLocale
}

func (p *Initialization) SetUserName(attr string) {
	p.userName = &attr
}

func (p *Initialization) UserName() (string, bool) {
	if p.userName != nil {
		return *p.userName, true
	}
	var zero string
	return zero, false
}

func (p *Initialization) MustUserName() string {
	if p.userName == nil {
		panic("the userName must not be nil, please use UserName() function instead")
	}
	return *p.userName
}

func (p *Initialization) SetWindowsLicenseKey(attr string) {
	p.windowsLicenseKey = &attr
}

func (p *Initialization) WindowsLicenseKey() (string, bool) {
	if p.windowsLicenseKey != nil {
		return *p.windowsLicenseKey, true
	}
	var zero string
	return zero, false
}

func (p *Initialization) MustWindowsLicenseKey() string {
	if p.windowsLicenseKey == nil {
		panic("the windowsLicenseKey must not be nil, please use WindowsLicenseKey() function instead")
	}
	return *p.windowsLicenseKey
}

// InstanceType Describes the hardware configuration of virtual machines.
//
// For example `medium` instance type includes 1 virtual CPU and 4 GiB of memory. It is a top-level
// entity (e.g. not bound to any data center or cluster). The attributes that are used for instance
// types and are common to virtual machine and template types are:
//
// - `console`
// - `cpu`
// - `custom_cpu_model`
// - `custom_emulated_machine`
// - `display`
// - `high_availability`
// - `io`
// - `memory`
// - `memory_policy`
// - `migration`
// - `migration_downtime`
// - `os`
// - `rng_device`
// - `soundcard_enabled`
// - `usb`
// - `virtio_scsi`
//
// When creating a virtual machine from both an instance type and a template, the virtual machine
// will inherit the hardware configurations from the instance type
//
// NOTE: An instance type inherits it's attributes from the template entity although most template
// attributes are not used in instance types.
type InstanceType struct {
	Struct
	bios                         *Bios
	cdroms                       *CdromSlice
	cluster                      *Cluster
	comment                      *string
	console                      *Console
	cpu                          *Cpu
	cpuProfile                   *CpuProfile
	cpuShares                    *int64
	creationTime                 *time.Time
	customCompatibilityVersion   *Version
	customCpuModel               *string
	customEmulatedMachine        *string
	customProperties             *CustomPropertySlice
	deleteProtected              *bool
	description                  *string
	diskAttachments              *DiskAttachmentSlice
	display                      *Display
	domain                       *Domain
	graphicsConsoles             *GraphicsConsoleSlice
	highAvailability             *HighAvailability
	id                           *string
	initialization               *Initialization
	io                           *Io
	largeIcon                    *Icon
	lease                        *StorageDomainLease
	memory                       *int64
	memoryPolicy                 *MemoryPolicy
	migration                    *MigrationOptions
	migrationDowntime            *int64
	multiQueuesEnabled           *bool
	name                         *string
	nics                         *NicSlice
	origin                       *string
	os                           *OperatingSystem
	permissions                  *PermissionSlice
	placementPolicy              *VmPlacementPolicy
	quota                        *Quota
	rngDevice                    *RngDevice
	serialNumber                 *SerialNumber
	smallIcon                    *Icon
	soundcardEnabled             *bool
	sso                          *Sso
	startPaused                  *bool
	stateless                    *bool
	status                       *TemplateStatus
	storageDomain                *StorageDomain
	storageErrorResumeBehaviour  *VmStorageErrorResumeBehaviour
	tags                         *TagSlice
	timeZone                     *TimeZone
	tpmEnabled                   *bool
	tunnelMigration              *bool
	type_                        *VmType
	usb                          *Usb
	version                      *TemplateVersion
	virtioScsi                   *VirtioScsi
	virtioScsiMultiQueuesEnabled *bool
	vm                           *Vm
	watchdogs                    *WatchdogSlice
}

func (p *InstanceType) SetBios(attr *Bios) {
	p.bios = attr
}

func (p *InstanceType) Bios() (*Bios, bool) {
	if p.bios != nil {
		return p.bios, true
	}
	return nil, false
}

func (p *InstanceType) MustBios() *Bios {
	if p.bios == nil {
		panic("the bios must not be nil, please use Bios() function instead")
	}
	return p.bios
}

func (p *InstanceType) SetCdroms(attr *CdromSlice) {
	p.cdroms = attr
}

func (p *InstanceType) Cdroms() (*CdromSlice, bool) {
	if p.cdroms != nil {
		return p.cdroms, true
	}
	return nil, false
}

func (p *InstanceType) MustCdroms() *CdromSlice {
	if p.cdroms == nil {
		panic("the cdroms must not be nil, please use Cdroms() function instead")
	}
	return p.cdroms
}

// SetCluster Type representation of a cluster.
//
// A JSON representation of a cluster:
//
// [source]
// ----
// {
//   "cluster" : [ {
//     "ballooning_enabled" : "false",
//     "cpu" : {
//       "architecture" : "x86_64",
//       "type" : "Intel SandyBridge Family"
//     },
//     "custom_scheduling_policy_properties" : {
//       "property" : [ {
//         "name" : "HighUtilization",
//         "value" : "80"
//       }, {
//         "name" : "CpuOverCommitDurationMinutes",
//         "value" : "2"
//       } ]
//     },
//     "error_handling" : {
//       "on_error" : "migrate"
//     },
//     "fencing_policy" : {
//       "enabled" : "true",
//       "skip_if_connectivity_broken" : {
//         "enabled" : "false",
//         "threshold" : "50"
//       },
//       "skip_if_gluster_bricks_up" : "false",
//       "skip_if_gluster_quorum_not_met" : "false",
//       "skip_if_sd_active" : {
//         "enabled" : "false"
//       }
//     },
//     "gluster_service" : "false",
//     "firewall_type" : "iptables",
//     "ha_reservation" : "false",
//     "ksm" : {
//       "enabled" : "true",
//       "merge_across_nodes" : "true"
//     },
//     "memory_policy" : {
//       "over_commit" : {
//         "percent" : "100"
//       },
//       "transparent_hugepages" : {
//         "enabled" : "true"
//       }
//     },
//     "migration" : {
//       "auto_converge" : "inherit",
//       "bandwidth" : {
//         "assignment_method" : "auto"
//       },
//       "compressed" : "inherit",
//       "policy" : {
//         "id" : "00000000-0000-0000-0000-000000000000"
//       }
//     },
//     "required_rng_sources" : {
//       "required_rng_source" : [ "random" ]
//     },
//     "switch_type" : "legacy",
//     "threads_as_cores" : "false",
//     "trusted_service" : "false",
//     "tunnel_migration" : "false",
//     "version" : {
//       "major" : "4",
//       "minor" : "1"
//     },
//     "virt_service" : "true",
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "mac_pool" : {
//       "href" : "/ovirt-engine/api/macpools/456",
//       "id" : "456"
//     },
//     "scheduling_policy" : {
//       "href" : "/ovirt-engine/api/schedulingpolicies/789",
//       "id" : "789"
//     },
//     "actions" : {
//       "link" : [ {
//         "href" : "/ovirt-engine/api/clusters/234/resetemulatedmachine",
//         "rel" : "resetemulatedmachine"
//       } ]
//     },
//     "name" : "Default",
//     "description" : "The default server cluster",
//     "href" : "/ovirt-engine/api/clusters/234",
//     "id" : "234",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/clusters/234/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/cpuprofiles",
//       "rel" : "cpuprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networkfilters",
//       "rel" : "networkfilters"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networks",
//       "rel" : "networks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/affinitygroups",
//       "rel" : "affinitygroups"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glusterhooks",
//       "rel" : "glusterhooks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glustervolumes",
//       "rel" : "glustervolumes"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/enabledfeatures",
//       "rel" : "enabledfeatures"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/externalnetworkproviders",
//       "rel" : "externalnetworkproviders"
//     } ]
//   } ]
// }
// ----
func (p *InstanceType) SetCluster(attr *Cluster) {
	p.cluster = attr
}

// Cluster Type representation of a cluster.
//
// A JSON representation of a cluster:
//
// [source]
// ----
// {
//   "cluster" : [ {
//     "ballooning_enabled" : "false",
//     "cpu" : {
//       "architecture" : "x86_64",
//       "type" : "Intel SandyBridge Family"
//     },
//     "custom_scheduling_policy_properties" : {
//       "property" : [ {
//         "name" : "HighUtilization",
//         "value" : "80"
//       }, {
//         "name" : "CpuOverCommitDurationMinutes",
//         "value" : "2"
//       } ]
//     },
//     "error_handling" : {
//       "on_error" : "migrate"
//     },
//     "fencing_policy" : {
//       "enabled" : "true",
//       "skip_if_connectivity_broken" : {
//         "enabled" : "false",
//         "threshold" : "50"
//       },
//       "skip_if_gluster_bricks_up" : "false",
//       "skip_if_gluster_quorum_not_met" : "false",
//       "skip_if_sd_active" : {
//         "enabled" : "false"
//       }
//     },
//     "gluster_service" : "false",
//     "firewall_type" : "iptables",
//     "ha_reservation" : "false",
//     "ksm" : {
//       "enabled" : "true",
//       "merge_across_nodes" : "true"
//     },
//     "memory_policy" : {
//       "over_commit" : {
//         "percent" : "100"
//       },
//       "transparent_hugepages" : {
//         "enabled" : "true"
//       }
//     },
//     "migration" : {
//       "auto_converge" : "inherit",
//       "bandwidth" : {
//         "assignment_method" : "auto"
//       },
//       "compressed" : "inherit",
//       "policy" : {
//         "id" : "00000000-0000-0000-0000-000000000000"
//       }
//     },
//     "required_rng_sources" : {
//       "required_rng_source" : [ "random" ]
//     },
//     "switch_type" : "legacy",
//     "threads_as_cores" : "false",
//     "trusted_service" : "false",
//     "tunnel_migration" : "false",
//     "version" : {
//       "major" : "4",
//       "minor" : "1"
//     },
//     "virt_service" : "true",
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "mac_pool" : {
//       "href" : "/ovirt-engine/api/macpools/456",
//       "id" : "456"
//     },
//     "scheduling_policy" : {
//       "href" : "/ovirt-engine/api/schedulingpolicies/789",
//       "id" : "789"
//     },
//     "actions" : {
//       "link" : [ {
//         "href" : "/ovirt-engine/api/clusters/234/resetemulatedmachine",
//         "rel" : "resetemulatedmachine"
//       } ]
//     },
//     "name" : "Default",
//     "description" : "The default server cluster",
//     "href" : "/ovirt-engine/api/clusters/234",
//     "id" : "234",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/clusters/234/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/cpuprofiles",
//       "rel" : "cpuprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networkfilters",
//       "rel" : "networkfilters"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networks",
//       "rel" : "networks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/affinitygroups",
//       "rel" : "affinitygroups"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glusterhooks",
//       "rel" : "glusterhooks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glustervolumes",
//       "rel" : "glustervolumes"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/enabledfeatures",
//       "rel" : "enabledfeatures"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/externalnetworkproviders",
//       "rel" : "externalnetworkproviders"
//     } ]
//   } ]
// }
// ----
func (p *InstanceType) Cluster() (*Cluster, bool) {
	if p.cluster != nil {
		return p.cluster, true
	}
	return nil, false
}

// MustCluster Type representation of a cluster.
//
// A JSON representation of a cluster:
//
// [source]
// ----
// {
//   "cluster" : [ {
//     "ballooning_enabled" : "false",
//     "cpu" : {
//       "architecture" : "x86_64",
//       "type" : "Intel SandyBridge Family"
//     },
//     "custom_scheduling_policy_properties" : {
//       "property" : [ {
//         "name" : "HighUtilization",
//         "value" : "80"
//       }, {
//         "name" : "CpuOverCommitDurationMinutes",
//         "value" : "2"
//       } ]
//     },
//     "error_handling" : {
//       "on_error" : "migrate"
//     },
//     "fencing_policy" : {
//       "enabled" : "true",
//       "skip_if_connectivity_broken" : {
//         "enabled" : "false",
//         "threshold" : "50"
//       },
//       "skip_if_gluster_bricks_up" : "false",
//       "skip_if_gluster_quorum_not_met" : "false",
//       "skip_if_sd_active" : {
//         "enabled" : "false"
//       }
//     },
//     "gluster_service" : "false",
//     "firewall_type" : "iptables",
//     "ha_reservation" : "false",
//     "ksm" : {
//       "enabled" : "true",
//       "merge_across_nodes" : "true"
//     },
//     "memory_policy" : {
//       "over_commit" : {
//         "percent" : "100"
//       },
//       "transparent_hugepages" : {
//         "enabled" : "true"
//       }
//     },
//     "migration" : {
//       "auto_converge" : "inherit",
//       "bandwidth" : {
//         "assignment_method" : "auto"
//       },
//       "compressed" : "inherit",
//       "policy" : {
//         "id" : "00000000-0000-0000-0000-000000000000"
//       }
//     },
//     "required_rng_sources" : {
//       "required_rng_source" : [ "random" ]
//     },
//     "switch_type" : "legacy",
//     "threads_as_cores" : "false",
//     "trusted_service" : "false",
//     "tunnel_migration" : "false",
//     "version" : {
//       "major" : "4",
//       "minor" : "1"
//     },
//     "virt_service" : "true",
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "mac_pool" : {
//       "href" : "/ovirt-engine/api/macpools/456",
//       "id" : "456"
//     },
//     "scheduling_policy" : {
//       "href" : "/ovirt-engine/api/schedulingpolicies/789",
//       "id" : "789"
//     },
//     "actions" : {
//       "link" : [ {
//         "href" : "/ovirt-engine/api/clusters/234/resetemulatedmachine",
//         "rel" : "resetemulatedmachine"
//       } ]
//     },
//     "name" : "Default",
//     "description" : "The default server cluster",
//     "href" : "/ovirt-engine/api/clusters/234",
//     "id" : "234",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/clusters/234/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/cpuprofiles",
//       "rel" : "cpuprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networkfilters",
//       "rel" : "networkfilters"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networks",
//       "rel" : "networks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/affinitygroups",
//       "rel" : "affinitygroups"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glusterhooks",
//       "rel" : "glusterhooks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glustervolumes",
//       "rel" : "glustervolumes"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/enabledfeatures",
//       "rel" : "enabledfeatures"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/externalnetworkproviders",
//       "rel" : "externalnetworkproviders"
//     } ]
//   } ]
// }
// ----
func (p *InstanceType) MustCluster() *Cluster {
	if p.cluster == nil {
		panic("the cluster must not be nil, please use Cluster() function instead")
	}
	return p.cluster
}

func (p *InstanceType) SetComment(attr string) {
	p.comment = &attr
}

func (p *InstanceType) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *InstanceType) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

// SetConsole Representation for serial console device.
func (p *InstanceType) SetConsole(attr *Console) {
	p.console = attr
}

// Console Representation for serial console device.
func (p *InstanceType) Console() (*Console, bool) {
	if p.console != nil {
		return p.console, true
	}
	return nil, false
}

// MustConsole Representation for serial console device.
func (p *InstanceType) MustConsole() *Console {
	if p.console == nil {
		panic("the console must not be nil, please use Console() function instead")
	}
	return p.console
}

func (p *InstanceType) SetCpu(attr *Cpu) {
	p.cpu = attr
}

func (p *InstanceType) Cpu() (*Cpu, bool) {
	if p.cpu != nil {
		return p.cpu, true
	}
	return nil, false
}

func (p *InstanceType) MustCpu() *Cpu {
	if p.cpu == nil {
		panic("the cpu must not be nil, please use Cpu() function instead")
	}
	return p.cpu
}

func (p *InstanceType) SetCpuProfile(attr *CpuProfile) {
	p.cpuProfile = attr
}

func (p *InstanceType) CpuProfile() (*CpuProfile, bool) {
	if p.cpuProfile != nil {
		return p.cpuProfile, true
	}
	return nil, false
}

func (p *InstanceType) MustCpuProfile() *CpuProfile {
	if p.cpuProfile == nil {
		panic("the cpuProfile must not be nil, please use CpuProfile() function instead")
	}
	return p.cpuProfile
}

func (p *InstanceType) SetCpuShares(attr int64) {
	p.cpuShares = &attr
}

func (p *InstanceType) CpuShares() (int64, bool) {
	if p.cpuShares != nil {
		return *p.cpuShares, true
	}
	var zero int64
	return zero, false
}

func (p *InstanceType) MustCpuShares() int64 {
	if p.cpuShares == nil {
		panic("the cpuShares must not be nil, please use CpuShares() function instead")
	}
	return *p.cpuShares
}

func (p *InstanceType) SetCreationTime(attr time.Time) {
	p.creationTime = &attr
}

func (p *InstanceType) CreationTime() (time.Time, bool) {
	if p.creationTime != nil {
		return *p.creationTime, true
	}
	var zero time.Time
	return zero, false
}

func (p *InstanceType) MustCreationTime() time.Time {
	if p.creationTime == nil {
		panic("the creationTime must not be nil, please use CreationTime() function instead")
	}
	return *p.creationTime
}

func (p *InstanceType) SetCustomCompatibilityVersion(attr *Version) {
	p.customCompatibilityVersion = attr
}

func (p *InstanceType) CustomCompatibilityVersion() (*Version, bool) {
	if p.customCompatibilityVersion != nil {
		return p.customCompatibilityVersion, true
	}
	return nil, false
}

func (p *InstanceType) MustCustomCompatibilityVersion() *Version {
	if p.customCompatibilityVersion == nil {
		panic("the customCompatibilityVersion must not be nil, please use CustomCompatibilityVersion() function instead")
	}
	return p.customCompatibilityVersion
}

func (p *InstanceType) SetCustomCpuModel(attr string) {
	p.customCpuModel = &attr
}

func (p *InstanceType) CustomCpuModel() (string, bool) {
	if p.customCpuModel != nil {
		return *p.customCpuModel, true
	}
	var zero string
	return zero, false
}

func (p *InstanceType) MustCustomCpuModel() string {
	if p.customCpuModel == nil {
		panic("the customCpuModel must not be nil, please use CustomCpuModel() function instead")
	}
	return *p.customCpuModel
}

func (p *InstanceType) SetCustomEmulatedMachine(attr string) {
	p.customEmulatedMachine = &attr
}

func (p *InstanceType) CustomEmulatedMachine() (string, bool) {
	if p.customEmulatedMachine != nil {
		return *p.customEmulatedMachine, true
	}
	var zero string
	return zero, false
}

func (p *InstanceType) MustCustomEmulatedMachine() string {
	if p.customEmulatedMachine == nil {
		panic("the customEmulatedMachine must not be nil, please use CustomEmulatedMachine() function instead")
	}
	return *p.customEmulatedMachine
}

func (p *InstanceType) SetCustomProperties(attr *CustomPropertySlice) {
	p.customProperties = attr
}

func (p *InstanceType) CustomProperties() (*CustomPropertySlice, bool) {
	if p.customProperties != nil {
		return p.customProperties, true
	}
	return nil, false
}

func (p *InstanceType) MustCustomProperties() *CustomPropertySlice {
	if p.customProperties == nil {
		panic("the customProperties must not be nil, please use CustomProperties() function instead")
	}
	return p.customProperties
}

func (p *InstanceType) SetDeleteProtected(attr bool) {
	p.deleteProtected = &attr
}

func (p *InstanceType) DeleteProtected() (bool, bool) {
	if p.deleteProtected != nil {
		return *p.deleteProtected, true
	}
	var zero bool
	return zero, false
}

func (p *InstanceType) MustDeleteProtected() bool {
	if p.deleteProtected == nil {
		panic("the deleteProtected must not be nil, please use DeleteProtected() function instead")
	}
	return *p.deleteProtected
}

func (p *InstanceType) SetDescription(attr string) {
	p.description = &attr
}

func (p *InstanceType) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *InstanceType) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *InstanceType) SetDiskAttachments(attr *DiskAttachmentSlice) {
	p.diskAttachments = attr
}

func (p *InstanceType) DiskAttachments() (*DiskAttachmentSlice, bool) {
	if p.diskAttachments != nil {
		return p.diskAttachments, true
	}
	return nil, false
}

func (p *InstanceType) MustDiskAttachments() *DiskAttachmentSlice {
	if p.diskAttachments == nil {
		panic("the diskAttachments must not be nil, please use DiskAttachments() function instead")
	}
	return p.diskAttachments
}

// SetDisplay Represents a graphic console configuration.
func (p *InstanceType) SetDisplay(attr *Display) {
	p.display = attr
}

// Display Represents a graphic console configuration.
func (p *InstanceType) Display() (*Display, bool) {
	if p.display != nil {
		return p.display, true
	}
	return nil, false
}

// MustDisplay Represents a graphic console configuration.
func (p *InstanceType) MustDisplay() *Display {
	if p.display == nil {
		panic("the display must not be nil, please use Display() function instead")
	}
	return p.display
}

// SetDomain This type represents a directory service domain.
func (p *InstanceType) SetDomain(attr *Domain) {
	p.domain = attr
}

// Domain This type represents a directory service domain.
func (p *InstanceType) Domain() (*Domain, bool) {
	if p.domain != nil {
		return p.domain, true
	}
	return nil, false
}

// MustDomain This type represents a directory service domain.
func (p *InstanceType) MustDomain() *Domain {
	if p.domain == nil {
		panic("the domain must not be nil, please use Domain() function instead")
	}
	return p.domain
}

func (p *InstanceType) SetGraphicsConsoles(attr *GraphicsConsoleSlice) {
	p.graphicsConsoles = attr
}

func (p *InstanceType) GraphicsConsoles() (*GraphicsConsoleSlice, bool) {
	if p.graphicsConsoles != nil {
		return p.graphicsConsoles, true
	}
	return nil, false
}

func (p *InstanceType) MustGraphicsConsoles() *GraphicsConsoleSlice {
	if p.graphicsConsoles == nil {
		panic("the graphicsConsoles must not be nil, please use GraphicsConsoles() function instead")
	}
	return p.graphicsConsoles
}

// SetHighAvailability Type representing high availability of a virtual machine.
func (p *InstanceType) SetHighAvailability(attr *HighAvailability) {
	p.highAvailability = attr
}

// HighAvailability Type representing high availability of a virtual machine.
func (p *InstanceType) HighAvailability() (*HighAvailability, bool) {
	if p.highAvailability != nil {
		return p.highAvailability, true
	}
	return nil, false
}

// MustHighAvailability Type representing high availability of a virtual machine.
func (p *InstanceType) MustHighAvailability() *HighAvailability {
	if p.highAvailability == nil {
		panic("the highAvailability must not be nil, please use HighAvailability() function instead")
	}
	return p.highAvailability
}

func (p *InstanceType) SetId(attr string) {
	p.id = &attr
}

func (p *InstanceType) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *InstanceType) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *InstanceType) SetInitialization(attr *Initialization) {
	p.initialization = attr
}

func (p *InstanceType) Initialization() (*Initialization, bool) {
	if p.initialization != nil {
		return p.initialization, true
	}
	return nil, false
}

func (p *InstanceType) MustInitialization() *Initialization {
	if p.initialization == nil {
		panic("the initialization must not be nil, please use Initialization() function instead")
	}
	return p.initialization
}

func (p *InstanceType) SetIo(attr *Io) {
	p.io = attr
}

func (p *InstanceType) Io() (*Io, bool) {
	if p.io != nil {
		return p.io, true
	}
	return nil, false
}

func (p *InstanceType) MustIo() *Io {
	if p.io == nil {
		panic("the io must not be nil, please use Io() function instead")
	}
	return p.io
}

// SetLargeIcon Icon of virtual machine or template.
func (p *InstanceType) SetLargeIcon(attr *Icon) {
	p.largeIcon = attr
}

// LargeIcon Icon of virtual machine or template.
func (p *InstanceType) LargeIcon() (*Icon, bool) {
	if p.largeIcon != nil {
		return p.largeIcon, true
	}
	return nil, false
}

// MustLargeIcon Icon of virtual machine or template.
func (p *InstanceType) MustLargeIcon() *Icon {
	if p.largeIcon == nil {
		panic("the largeIcon must not be nil, please use LargeIcon() function instead")
	}
	return p.largeIcon
}

// SetLease Represents a lease residing on a storage domain.
//
// A lease is a http://www.ovirt.org/develop/developer-guide/vdsm/sanlock[Sanlock] resource residing on a special
// volume on the storage domain, this Sanlock resource is used to provide storage base locking.
func (p *InstanceType) SetLease(attr *StorageDomainLease) {
	p.lease = attr
}

// Lease Represents a lease residing on a storage domain.
//
// A lease is a http://www.ovirt.org/develop/developer-guide/vdsm/sanlock[Sanlock] resource residing on a special
// volume on the storage domain, this Sanlock resource is used to provide storage base locking.
func (p *InstanceType) Lease() (*StorageDomainLease, bool) {
	if p.lease != nil {
		return p.lease, true
	}
	return nil, false
}

// MustLease Represents a lease residing on a storage domain.
//
// A lease is a http://www.ovirt.org/develop/developer-guide/vdsm/sanlock[Sanlock] resource residing on a special
// volume on the storage domain, this Sanlock resource is used to provide storage base locking.
func (p *InstanceType) MustLease() *StorageDomainLease {
	if p.lease == nil {
		panic("the lease must not be nil, please use Lease() function instead")
	}
	return p.lease
}

func (p *InstanceType) SetMemory(attr int64) {
	p.memory = &attr
}

func (p *InstanceType) Memory() (int64, bool) {
	if p.memory != nil {
		return *p.memory, true
	}
	var zero int64
	return zero, false
}

func (p *InstanceType) MustMemory() int64 {
	if p.memory == nil {
		panic("the memory must not be nil, please use Memory() function instead")
	}
	return *p.memory
}

// SetMemoryPolicy Logical grouping of memory-related properties of virtual machine-like entities.
func (p *InstanceType) SetMemoryPolicy(attr *MemoryPolicy) {
	p.memoryPolicy = attr
}

// MemoryPolicy Logical grouping of memory-related properties of virtual machine-like entities.
func (p *InstanceType) MemoryPolicy() (*MemoryPolicy, bool) {
	if p.memoryPolicy != nil {
		return p.memoryPolicy, true
	}
	return nil, false
}

// MustMemoryPolicy Logical grouping of memory-related properties of virtual machine-like entities.
func (p *InstanceType) MustMemoryPolicy() *MemoryPolicy {
	if p.memoryPolicy == nil {
		panic("the memoryPolicy must not be nil, please use MemoryPolicy() function instead")
	}
	return p.memoryPolicy
}

// SetMigration The type for migration options.
func (p *InstanceType) SetMigration(attr *MigrationOptions) {
	p.migration = attr
}

// Migration The type for migration options.
func (p *InstanceType) Migration() (*MigrationOptions, bool) {
	if p.migration != nil {
		return p.migration, true
	}
	return nil, false
}

// MustMigration The type for migration options.
func (p *InstanceType) MustMigration() *MigrationOptions {
	if p.migration == nil {
		panic("the migration must not be nil, please use Migration() function instead")
	}
	return p.migration
}

func (p *InstanceType) SetMigrationDowntime(attr int64) {
	p.migrationDowntime = &attr
}

func (p *InstanceType) MigrationDowntime() (int64, bool) {
	if p.migrationDowntime != nil {
		return *p.migrationDowntime, true
	}
	var zero int64
	return zero, false
}

func (p *InstanceType) MustMigrationDowntime() int64 {
	if p.migrationDowntime == nil {
		panic("the migrationDowntime must not be nil, please use MigrationDowntime() function instead")
	}
	return *p.migrationDowntime
}

func (p *InstanceType) SetMultiQueuesEnabled(attr bool) {
	p.multiQueuesEnabled = &attr
}

func (p *InstanceType) MultiQueuesEnabled() (bool, bool) {
	if p.multiQueuesEnabled != nil {
		return *p.multiQueuesEnabled, true
	}
	var zero bool
	return zero, false
}

func (p *InstanceType) MustMultiQueuesEnabled() bool {
	if p.multiQueuesEnabled == nil {
		panic("the multiQueuesEnabled must not be nil, please use MultiQueuesEnabled() function instead")
	}
	return *p.multiQueuesEnabled
}

func (p *InstanceType) SetName(attr string) {
	p.name = &attr
}

func (p *InstanceType) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *InstanceType) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *InstanceType) SetNics(attr *NicSlice) {
	p.nics = attr
}

func (p *InstanceType) Nics() (*NicSlice, bool) {
	if p.nics != nil {
		return p.nics, true
	}
	return nil, false
}

func (p *InstanceType) MustNics() *NicSlice {
	if p.nics == nil {
		panic("the nics must not be nil, please use Nics() function instead")
	}
	return p.nics
}

func (p *InstanceType) SetOrigin(attr string) {
	p.origin = &attr
}

func (p *InstanceType) Origin() (string, bool) {
	if p.origin != nil {
		return *p.origin, true
	}
	var zero string
	return zero, false
}

func (p *InstanceType) MustOrigin() string {
	if p.origin == nil {
		panic("the origin must not be nil, please use Origin() function instead")
	}
	return *p.origin
}

// SetOs Information describing the operating system. This is used for both virtual machines and hosts.
func (p *InstanceType) SetOs(attr *OperatingSystem) {
	p.os = attr
}

// Os Information describing the operating system. This is used for both virtual machines and hosts.
func (p *InstanceType) Os() (*OperatingSystem, bool) {
	if p.os != nil {
		return p.os, true
	}
	return nil, false
}

// MustOs Information describing the operating system. This is used for both virtual machines and hosts.
func (p *InstanceType) MustOs() *OperatingSystem {
	if p.os == nil {
		panic("the os must not be nil, please use Os() function instead")
	}
	return p.os
}

func (p *InstanceType) SetPermissions(attr *PermissionSlice) {
	p.permissions = attr
}

func (p *InstanceType) Permissions() (*PermissionSlice, bool) {
	if p.permissions != nil {
		return p.permissions, true
	}
	return nil, false
}

func (p *InstanceType) MustPermissions() *PermissionSlice {
	if p.permissions == nil {
		panic("the permissions must not be nil, please use Permissions() function instead")
	}
	return p.permissions
}

func (p *InstanceType) SetPlacementPolicy(attr *VmPlacementPolicy) {
	p.placementPolicy = attr
}

func (p *InstanceType) PlacementPolicy() (*VmPlacementPolicy, bool) {
	if p.placementPolicy != nil {
		return p.placementPolicy, true
	}
	return nil, false
}

func (p *InstanceType) MustPlacementPolicy() *VmPlacementPolicy {
	if p.placementPolicy == nil {
		panic("the placementPolicy must not be nil, please use PlacementPolicy() function instead")
	}
	return p.placementPolicy
}

// SetQuota Represents a quota object.
//
// An example XML representation of a quota:
//
// [source,xml]
// ----
// <quota href="/ovirt-engine/api/datacenters/7044934e/quotas/dcad5ddc" id="dcad5ddc">
//   <name>My Quota</name>
//   <description>A quota for my oVirt environment</description>
//   <cluster_hard_limit_pct>0</cluster_hard_limit_pct>
//   <cluster_soft_limit_pct>0</cluster_soft_limit_pct>
//   <data_center href="/ovirt-engine/api/datacenters/7044934e" id="7044934e"/>
//   <storage_hard_limit_pct>0</storage_hard_limit_pct>
//   <storage_soft_limit_pct>0</storage_soft_limit_pct>
// </quota>
// ----
func (p *InstanceType) SetQuota(attr *Quota) {
	p.quota = attr
}

// Quota Represents a quota object.
//
// An example XML representation of a quota:
//
// [source,xml]
// ----
// <quota href="/ovirt-engine/api/datacenters/7044934e/quotas/dcad5ddc" id="dcad5ddc">
//   <name>My Quota</name>
//   <description>A quota for my oVirt environment</description>
//   <cluster_hard_limit_pct>0</cluster_hard_limit_pct>
//   <cluster_soft_limit_pct>0</cluster_soft_limit_pct>
//   <data_center href="/ovirt-engine/api/datacenters/7044934e" id="7044934e"/>
//   <storage_hard_limit_pct>0</storage_hard_limit_pct>
//   <storage_soft_limit_pct>0</storage_soft_limit_pct>
// </quota>
// ----
func (p *InstanceType) Quota() (*Quota, bool) {
	if p.quota != nil {
		return p.quota, true
	}
	return nil, false
}

// MustQuota Represents a quota object.
//
// An example XML representation of a quota:
//
// [source,xml]
// ----
// <quota href="/ovirt-engine/api/datacenters/7044934e/quotas/dcad5ddc" id="dcad5ddc">
//   <name>My Quota</name>
//   <description>A quota for my oVirt environment</description>
//   <cluster_hard_limit_pct>0</cluster_hard_limit_pct>
//   <cluster_soft_limit_pct>0</cluster_soft_limit_pct>
//   <data_center href="/ovirt-engine/api/datacenters/7044934e" id="7044934e"/>
//   <storage_hard_limit_pct>0</storage_hard_limit_pct>
//   <storage_soft_limit_pct>0</storage_soft_limit_pct>
// </quota>
// ----
func (p *InstanceType) MustQuota() *Quota {
	if p.quota == nil {
		panic("the quota must not be nil, please use Quota() function instead")
	}
	return p.quota
}

// SetRngDevice Random number generator (RNG) device model.
func (p *InstanceType) SetRngDevice(attr *RngDevice) {
	p.rngDevice = attr
}

// RngDevice Random number generator (RNG) device model.
func (p *InstanceType) RngDevice() (*RngDevice, bool) {
	if p.rngDevice != nil {
		return p.rngDevice, true
	}
	return nil, false
}

// MustRngDevice Random number generator (RNG) device model.
func (p *InstanceType) MustRngDevice() *RngDevice {
	if p.rngDevice == nil {
		panic("the rngDevice must not be nil, please use RngDevice() function instead")
	}
	return p.rngDevice
}

func (p *InstanceType) SetSerialNumber(attr *SerialNumber) {
	p.serialNumber = attr
}

func (p *InstanceType) SerialNumber() (*SerialNumber, bool) {
	if p.serialNumber != nil {
		return p.serialNumber, true
	}
	return nil, false
}

func (p *InstanceType) MustSerialNumber() *SerialNumber {
	if p.serialNumber == nil {
		panic("the serialNumber must not be nil, please use SerialNumber() function instead")
	}
	return p.serialNumber
}

// SetSmallIcon Icon of virtual machine or template.
func (p *InstanceType) SetSmallIcon(attr *Icon) {
	p.smallIcon = attr
}

// SmallIcon Icon of virtual machine or template.
func (p *InstanceType) SmallIcon() (*Icon, bool) {
	if p.smallIcon != nil {
		return p.smallIcon, true
	}
	return nil, false
}

// MustSmallIcon Icon of virtual machine or template.
func (p *InstanceType) MustSmallIcon() *Icon {
	if p.smallIcon == nil {
		panic("the smallIcon must not be nil, please use SmallIcon() function instead")
	}
	return p.smallIcon
}

func (p *InstanceType) SetSoundcardEnabled(attr bool) {
	p.soundcardEnabled = &attr
}

func (p *InstanceType) SoundcardEnabled() (bool, bool) {
	if p.soundcardEnabled != nil {
		return *p.soundcardEnabled, true
	}
	var zero bool
	return zero, false
}

func (p *InstanceType) MustSoundcardEnabled() bool {
	if p.soundcardEnabled == nil {
		panic("the soundcardEnabled must not be nil, please use SoundcardEnabled() function instead")
	}
	return *p.soundcardEnabled
}

func (p *InstanceType) SetSso(attr *Sso) {
	p.sso = attr
}

func (p *InstanceType) Sso() (*Sso, bool) {
	if p.sso != nil {
		return p.sso, true
	}
	return nil, false
}

func (p *InstanceType) MustSso() *Sso {
	if p.sso == nil {
		panic("the sso must not be nil, please use Sso() function instead")
	}
	return p.sso
}

func (p *InstanceType) SetStartPaused(attr bool) {
	p.startPaused = &attr
}

func (p *InstanceType) StartPaused() (bool, bool) {
	if p.startPaused != nil {
		return *p.startPaused, true
	}
	var zero bool
	return zero, false
}

func (p *InstanceType) MustStartPaused() bool {
	if p.startPaused == nil {
		panic("the startPaused must not be nil, please use StartPaused() function instead")
	}
	return *p.startPaused
}

func (p *InstanceType) SetStateless(attr bool) {
	p.stateless = &attr
}

func (p *InstanceType) Stateless() (bool, bool) {
	if p.stateless != nil {
		return *p.stateless, true
	}
	var zero bool
	return zero, false
}

func (p *InstanceType) MustStateless() bool {
	if p.stateless == nil {
		panic("the stateless must not be nil, please use Stateless() function instead")
	}
	return *p.stateless
}

// SetStatus Type representing a status of a virtual machine template.
func (p *InstanceType) SetStatus(attr TemplateStatus) {
	p.status = &attr
}

// Status Type representing a status of a virtual machine template.
func (p *InstanceType) Status() (TemplateStatus, bool) {
	if p.status != nil {
		return *p.status, true
	}
	var zero TemplateStatus
	return zero, false
}

// MustStatus Type representing a status of a virtual machine template.
func (p *InstanceType) MustStatus() TemplateStatus {
	if p.status == nil {
		panic("the status must not be nil, please use Status() function instead")
	}
	return *p.status
}

// SetStorageDomain Storage domain.
//
// An XML representation of a NFS storage domain with identifier `123`:
//
// [source,xml]
// ----
// <storage_domain href="/ovirt-engine/api/storagedomains/123" id="123">
//   <name>mydata</name>
//   <description>My data</description>
//   <available>38654705664</available>
//   <committed>1073741824</committed>
//   <critical_space_action_blocker>5</critical_space_action_blocker>
//   <external_status>ok</external_status>
//   <master>true</master>
//   <storage>
//     <address>mynfs.example.com</address>
//     <nfs_version>v3</nfs_version>
//     <path>/exports/mydata</path>
//     <type>nfs</type>
//   </storage>
//   <storage_format>v3</storage_format>
//   <type>data</type>
//   <used>13958643712</used>
//   <warning_low_space_indicator>10</warning_low_space_indicator>
//   <wipe_after_delete>false</wipe_after_delete>
//   <data_centers>
//     <data_center href="/ovirt-engine/api/datacenters/456" id="456"/>
//   </data_centers>
// </storage_domain>
// ----
func (p *InstanceType) SetStorageDomain(attr *StorageDomain) {
	p.storageDomain = attr
}

// StorageDomain Storage domain.
//
// An XML representation of a NFS storage domain with identifier `123`:
//
// [source,xml]
// ----
// <storage_domain href="/ovirt-engine/api/storagedomains/123" id="123">
//   <name>mydata</name>
//   <description>My data</description>
//   <available>38654705664</available>
//   <committed>1073741824</committed>
//   <critical_space_action_blocker>5</critical_space_action_blocker>
//   <external_status>ok</external_status>
//   <master>true</master>
//   <storage>
//     <address>mynfs.example.com</address>
//     <nfs_version>v3</nfs_version>
//     <path>/exports/mydata</path>
//     <type>nfs</type>
//   </storage>
//   <storage_format>v3</storage_format>
//   <type>data</type>
//   <used>13958643712</used>
//   <warning_low_space_indicator>10</warning_low_space_indicator>
//   <wipe_after_delete>false</wipe_after_delete>
//   <data_centers>
//     <data_center href="/ovirt-engine/api/datacenters/456" id="456"/>
//   </data_centers>
// </storage_domain>
// ----
func (p *InstanceType) StorageDomain() (*StorageDomain, bool) {
	if p.storageDomain != nil {
		return p.storageDomain, true
	}
	return nil, false
}

// MustStorageDomain Storage domain.
//
// An XML representation of a NFS storage domain with identifier `123`:
//
// [source,xml]
// ----
// <storage_domain href="/ovirt-engine/api/storagedomains/123" id="123">
//   <name>mydata</name>
//   <description>My data</description>
//   <available>38654705664</available>
//   <committed>1073741824</committed>
//   <critical_space_action_blocker>5</critical_space_action_blocker>
//   <external_status>ok</external_status>
//   <master>true</master>
//   <storage>
//     <address>mynfs.example.com</address>
//     <nfs_version>v3</nfs_version>
//     <path>/exports/mydata</path>
//     <type>nfs</type>
//   </storage>
//   <storage_format>v3</storage_format>
//   <type>data</type>
//   <used>13958643712</used>
//   <warning_low_space_indicator>10</warning_low_space_indicator>
//   <wipe_after_delete>false</wipe_after_delete>
//   <data_centers>
//     <data_center href="/ovirt-engine/api/datacenters/456" id="456"/>
//   </data_centers>
// </storage_domain>
// ----
func (p *InstanceType) MustStorageDomain() *StorageDomain {
	if p.storageDomain == nil {
		panic("the storageDomain must not be nil, please use StorageDomain() function instead")
	}
	return p.storageDomain
}

// SetStorageErrorResumeBehaviour If the storage, on which this virtual machine has some disks gets
// unresponsive, the virtual machine gets paused.
//
// This are the possible options, what should happen with the virtual machine
// in the moment the storage gets available again.
func (p *InstanceType) SetStorageErrorResumeBehaviour(attr VmStorageErrorResumeBehaviour) {
	p.storageErrorResumeBehaviour = &attr
}

// StorageErrorResumeBehaviour If the storage, on which this virtual machine has some disks gets
// unresponsive, the virtual machine gets paused.
//
// This are the possible options, what should happen with the virtual machine
// in the moment the storage gets available again.
func (p *InstanceType) StorageErrorResumeBehaviour() (VmStorageErrorResumeBehaviour, bool) {
	if p.storageErrorResumeBehaviour != nil {
		return *p.storageErrorResumeBehaviour, true
	}
	var zero VmStorageErrorResumeBehaviour
	return zero, false
}

// MustStorageErrorResumeBehaviour If the storage, on which this virtual machine has some disks gets
// unresponsive, the virtual machine gets paused.
//
// This are the possible options, what should happen with the virtual machine
// in the moment the storage gets available again.
func (p *InstanceType) MustStorageErrorResumeBehaviour() VmStorageErrorResumeBehaviour {
	if p.storageErrorResumeBehaviour == nil {
		panic("the storageErrorResumeBehaviour must not be nil, please use StorageErrorResumeBehaviour() function instead")
	}
	return *p.storageErrorResumeBehaviour
}

func (p *InstanceType) SetTags(attr *TagSlice) {
	p.tags = attr
}

func (p *InstanceType) Tags() (*TagSlice, bool) {
	if p.tags != nil {
		return p.tags, true
	}
	return nil, false
}

func (p *InstanceType) MustTags() *TagSlice {
	if p.tags == nil {
		panic("the tags must not be nil, please use Tags() function instead")
	}
	return p.tags
}

// SetTimeZone Time zone representation.
func (p *InstanceType) SetTimeZone(attr *TimeZone) {
	p.timeZone = attr
}

// TimeZone Time zone representation.
func (p *InstanceType) TimeZone() (*TimeZone, bool) {
	if p.timeZone != nil {
		return p.timeZone, true
	}
	return nil, false
}

// MustTimeZone Time zone representation.
func (p *InstanceType) MustTimeZone() *TimeZone {
	if p.timeZone == nil {
		panic("the timeZone must not be nil, please use TimeZone() function instead")
	}
	return p.timeZone
}

func (p *InstanceType) SetTpmEnabled(attr bool) {
	p.tpmEnabled = &attr
}

func (p *InstanceType) TpmEnabled() (bool, bool) {
	if p.tpmEnabled != nil {
		return *p.tpmEnabled, true
	}
	var zero bool
	return zero, false
}

func (p *InstanceType) MustTpmEnabled() bool {
	if p.tpmEnabled == nil {
		panic("the tpmEnabled must not be nil, please use TpmEnabled() function instead")
	}
	return *p.tpmEnabled
}

func (p *InstanceType) SetTunnelMigration(attr bool) {
	p.tunnelMigration = &attr
}

func (p *InstanceType) TunnelMigration() (bool, bool) {
	if p.tunnelMigration != nil {
		return *p.tunnelMigration, true
	}
	var zero bool
	return zero, false
}

func (p *InstanceType) MustTunnelMigration() bool {
	if p.tunnelMigration == nil {
		panic("the tunnelMigration must not be nil, please use TunnelMigration() function instead")
	}
	return *p.tunnelMigration
}

// SetType Type representing what the virtual machine is optimized for.
func (p *InstanceType) SetType(attr VmType) {
	p.type_ = &attr
}

// Type Type representing what the virtual machine is optimized for.
func (p *InstanceType) Type() (VmType, bool) {
	if p.type_ != nil {
		return *p.type_, true
	}
	var zero VmType
	return zero, false
}

// MustType Type representing what the virtual machine is optimized for.
func (p *InstanceType) MustType() VmType {
	if p.type_ == nil {
		panic("the type_ must not be nil, please use Type() function instead")
	}
	return *p.type_
}

// SetUsb Configuration of the USB device of a virtual machine.
func (p *InstanceType) SetUsb(attr *Usb) {
	p.usb = attr
}

// Usb Configuration of the USB device of a virtual machine.
func (p *InstanceType) Usb() (*Usb, bool) {
	if p.usb != nil {
		return p.usb, true
	}
	return nil, false
}

// MustUsb Configuration of the USB device of a virtual machine.
func (p *InstanceType) MustUsb() *Usb {
	if p.usb == nil {
		panic("the usb must not be nil, please use Usb() function instead")
	}
	return p.usb
}

// SetVersion Type representing a version of a virtual machine template.
func (p *InstanceType) SetVersion(attr *TemplateVersion) {
	p.version = attr
}

// Version Type representing a version of a virtual machine template.
func (p *InstanceType) Version() (*TemplateVersion, bool) {
	if p.version != nil {
		return p.version, true
	}
	return nil, false
}

// MustVersion Type representing a version of a virtual machine template.
func (p *InstanceType) MustVersion() *TemplateVersion {
	if p.version == nil {
		panic("the version must not be nil, please use Version() function instead")
	}
	return p.version
}

// SetVirtioScsi Type representing the support of virtio-SCSI.
// If it supported we use virtio driver for SCSI guest device.
func (p *InstanceType) SetVirtioScsi(attr *VirtioScsi) {
	p.virtioScsi = attr
}

// VirtioScsi Type representing the support of virtio-SCSI.
// If it supported we use virtio driver for SCSI guest device.
func (p *InstanceType) VirtioScsi() (*VirtioScsi, bool) {
	if p.virtioScsi != nil {
		return p.virtioScsi, true
	}
	return nil, false
}

// MustVirtioScsi Type representing the support of virtio-SCSI.
// If it supported we use virtio driver for SCSI guest device.
func (p *InstanceType) MustVirtioScsi() *VirtioScsi {
	if p.virtioScsi == nil {
		panic("the virtioScsi must not be nil, please use VirtioScsi() function instead")
	}
	return p.virtioScsi
}

func (p *InstanceType) SetVirtioScsiMultiQueuesEnabled(attr bool) {
	p.virtioScsiMultiQueuesEnabled = &attr
}

func (p *InstanceType) VirtioScsiMultiQueuesEnabled() (bool, bool) {
	if p.virtioScsiMultiQueuesEnabled != nil {
		return *p.virtioScsiMultiQueuesEnabled, true
	}
	var zero bool
	return zero, false
}

func (p *InstanceType) MustVirtioScsiMultiQueuesEnabled() bool {
	if p.virtioScsiMultiQueuesEnabled == nil {
		panic("the virtioScsiMultiQueuesEnabled must not be nil, please use VirtioScsiMultiQueuesEnabled() function instead")
	}
	return *p.virtioScsiMultiQueuesEnabled
}

// SetVm Represents a virtual machine.
func (p *InstanceType) SetVm(attr *Vm) {
	p.vm = attr
}

// Vm Represents a virtual machine.
func (p *InstanceType) Vm() (*Vm, bool) {
	if p.vm != nil {
		return p.vm, true
	}
	return nil, false
}

// MustVm Represents a virtual machine.
func (p *InstanceType) MustVm() *Vm {
	if p.vm == nil {
		panic("the vm must not be nil, please use Vm() function instead")
	}
	return p.vm
}

func (p *InstanceType) SetWatchdogs(attr *WatchdogSlice) {
	p.watchdogs = attr
}

func (p *InstanceType) Watchdogs() (*WatchdogSlice, bool) {
	if p.watchdogs != nil {
		return p.watchdogs, true
	}
	return nil, false
}

func (p *InstanceType) MustWatchdogs() *WatchdogSlice {
	if p.watchdogs == nil {
		panic("the watchdogs must not be nil, please use Watchdogs() function instead")
	}
	return p.watchdogs
}

type Io struct {
	Struct
	threads *int64
}

func (p *Io) SetThreads(attr int64) {
	p.threads = &attr
}

func (p *Io) Threads() (int64, bool) {
	if p.threads != nil {
		return *p.threads, true
	}
	var zero int64
	return zero, false
}

func (p *Io) MustThreads() int64 {
	if p.threads == nil {
		panic("the threads must not be nil, please use Threads() function instead")
	}
	return *p.threads
}

// Ip Represents the IP configuration of a network interface.
type Ip struct {
	Struct
	address *string
	gateway *string
	netmask *string
	version *IpVersion
}

func (p *Ip) SetAddress(attr string) {
	p.address = &attr
}

func (p *Ip) Address() (string, bool) {
	if p.address != nil {
		return *p.address, true
	}
	var zero string
	return zero, false
}

func (p *Ip) MustAddress() string {
	if p.address == nil {
		panic("the address must not be nil, please use Address() function instead")
	}
	return *p.address
}

func (p *Ip) SetGateway(attr string) {
	p.gateway = &attr
}

func (p *Ip) Gateway() (string, bool) {
	if p.gateway != nil {
		return *p.gateway, true
	}
	var zero string
	return zero, false
}

func (p *Ip) MustGateway() string {
	if p.gateway == nil {
		panic("the gateway must not be nil, please use Gateway() function instead")
	}
	return *p.gateway
}

func (p *Ip) SetNetmask(attr string) {
	p.netmask = &attr
}

func (p *Ip) Netmask() (string, bool) {
	if p.netmask != nil {
		return *p.netmask, true
	}
	var zero string
	return zero, false
}

func (p *Ip) MustNetmask() string {
	if p.netmask == nil {
		panic("the netmask must not be nil, please use Netmask() function instead")
	}
	return *p.netmask
}

// SetVersion Defines the values for the IP protocol version.
func (p *Ip) SetVersion(attr IpVersion) {
	p.version = &attr
}

// Version Defines the values for the IP protocol version.
func (p *Ip) Version() (IpVersion, bool) {
	if p.version != nil {
		return *p.version, true
	}
	var zero IpVersion
	return zero, false
}

// MustVersion Defines the values for the IP protocol version.
func (p *Ip) MustVersion() IpVersion {
	if p.version == nil {
		panic("the version must not be nil, please use Version() function instead")
	}
	return *p.version
}

// IpAddressAssignment Represents an IP address assignment for a network device.
//
// For a static boot protocol assignment, subnet mask and IP address
// (and optinally default gateway) must be provided in the IP configuration.
type IpAddressAssignment struct {
	Struct
	assignmentMethod *BootProtocol
	ip               *Ip
}

// SetAssignmentMethod Defines the options of the IP address assignment method to a NIC.
func (p *IpAddressAssignment) SetAssignmentMethod(attr BootProtocol) {
	p.assignmentMethod = &attr
}

// AssignmentMethod Defines the options of the IP address assignment method to a NIC.
func (p *IpAddressAssignment) AssignmentMethod() (BootProtocol, bool) {
	if p.assignmentMethod != nil {
		return *p.assignmentMethod, true
	}
	var zero BootProtocol
	return zero, false
}

// MustAssignmentMethod Defines the options of the IP address assignment method to a NIC.
func (p *IpAddressAssignment) MustAssignmentMethod() BootProtocol {
	if p.assignmentMethod == nil {
		panic("the assignmentMethod must not be nil, please use AssignmentMethod() function instead")
	}
	return *p.assignmentMethod
}

// SetIp Represents the IP configuration of a network interface.
func (p *IpAddressAssignment) SetIp(attr *Ip) {
	p.ip = attr
}

// Ip Represents the IP configuration of a network interface.
func (p *IpAddressAssignment) Ip() (*Ip, bool) {
	if p.ip != nil {
		return p.ip, true
	}
	return nil, false
}

// MustIp Represents the IP configuration of a network interface.
func (p *IpAddressAssignment) MustIp() *Ip {
	if p.ip == nil {
		panic("the ip must not be nil, please use Ip() function instead")
	}
	return p.ip
}

type IscsiBond struct {
	Struct
	comment            *string
	dataCenter         *DataCenter
	description        *string
	id                 *string
	name               *string
	networks           *NetworkSlice
	storageConnections *StorageConnectionSlice
}

func (p *IscsiBond) SetComment(attr string) {
	p.comment = &attr
}

func (p *IscsiBond) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *IscsiBond) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *IscsiBond) SetDataCenter(attr *DataCenter) {
	p.dataCenter = attr
}

func (p *IscsiBond) DataCenter() (*DataCenter, bool) {
	if p.dataCenter != nil {
		return p.dataCenter, true
	}
	return nil, false
}

func (p *IscsiBond) MustDataCenter() *DataCenter {
	if p.dataCenter == nil {
		panic("the dataCenter must not be nil, please use DataCenter() function instead")
	}
	return p.dataCenter
}

func (p *IscsiBond) SetDescription(attr string) {
	p.description = &attr
}

func (p *IscsiBond) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *IscsiBond) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *IscsiBond) SetId(attr string) {
	p.id = &attr
}

func (p *IscsiBond) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *IscsiBond) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *IscsiBond) SetName(attr string) {
	p.name = &attr
}

func (p *IscsiBond) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *IscsiBond) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *IscsiBond) SetNetworks(attr *NetworkSlice) {
	p.networks = attr
}

func (p *IscsiBond) Networks() (*NetworkSlice, bool) {
	if p.networks != nil {
		return p.networks, true
	}
	return nil, false
}

func (p *IscsiBond) MustNetworks() *NetworkSlice {
	if p.networks == nil {
		panic("the networks must not be nil, please use Networks() function instead")
	}
	return p.networks
}

func (p *IscsiBond) SetStorageConnections(attr *StorageConnectionSlice) {
	p.storageConnections = attr
}

func (p *IscsiBond) StorageConnections() (*StorageConnectionSlice, bool) {
	if p.storageConnections != nil {
		return p.storageConnections, true
	}
	return nil, false
}

func (p *IscsiBond) MustStorageConnections() *StorageConnectionSlice {
	if p.storageConnections == nil {
		panic("the storageConnections must not be nil, please use StorageConnections() function instead")
	}
	return p.storageConnections
}

type IscsiDetails struct {
	Struct
	address         *string
	diskId          *string
	initiator       *string
	lunMapping      *int64
	password        *string
	paths           *int64
	port            *int64
	portal          *string
	productId       *string
	serial          *string
	size            *int64
	status          *string
	storageDomainId *string
	target          *string
	username        *string
	vendorId        *string
	volumeGroupId   *string
}

func (p *IscsiDetails) SetAddress(attr string) {
	p.address = &attr
}

func (p *IscsiDetails) Address() (string, bool) {
	if p.address != nil {
		return *p.address, true
	}
	var zero string
	return zero, false
}

func (p *IscsiDetails) MustAddress() string {
	if p.address == nil {
		panic("the address must not be nil, please use Address() function instead")
	}
	return *p.address
}

func (p *IscsiDetails) SetDiskId(attr string) {
	p.diskId = &attr
}

func (p *IscsiDetails) DiskId() (string, bool) {
	if p.diskId != nil {
		return *p.diskId, true
	}
	var zero string
	return zero, false
}

func (p *IscsiDetails) MustDiskId() string {
	if p.diskId == nil {
		panic("the diskId must not be nil, please use DiskId() function instead")
	}
	return *p.diskId
}

func (p *IscsiDetails) SetInitiator(attr string) {
	p.initiator = &attr
}

func (p *IscsiDetails) Initiator() (string, bool) {
	if p.initiator != nil {
		return *p.initiator, true
	}
	var zero string
	return zero, false
}

func (p *IscsiDetails) MustInitiator() string {
	if p.initiator == nil {
		panic("the initiator must not be nil, please use Initiator() function instead")
	}
	return *p.initiator
}

func (p *IscsiDetails) SetLunMapping(attr int64) {
	p.lunMapping = &attr
}

func (p *IscsiDetails) LunMapping() (int64, bool) {
	if p.lunMapping != nil {
		return *p.lunMapping, true
	}
	var zero int64
	return zero, false
}

func (p *IscsiDetails) MustLunMapping() int64 {
	if p.lunMapping == nil {
		panic("the lunMapping must not be nil, please use LunMapping() function instead")
	}
	return *p.lunMapping
}

func (p *IscsiDetails) SetPassword(attr string) {
	p.password = &attr
}

func (p *IscsiDetails) Password() (string, bool) {
	if p.password != nil {
		return *p.password, true
	}
	var zero string
	return zero, false
}

func (p *IscsiDetails) MustPassword() string {
	if p.password == nil {
		panic("the password must not be nil, please use Password() function instead")
	}
	return *p.password
}

func (p *IscsiDetails) SetPaths(attr int64) {
	p.paths = &attr
}

func (p *IscsiDetails) Paths() (int64, bool) {
	if p.paths != nil {
		return *p.paths, true
	}
	var zero int64
	return zero, false
}

func (p *IscsiDetails) MustPaths() int64 {
	if p.paths == nil {
		panic("the paths must not be nil, please use Paths() function instead")
	}
	return *p.paths
}

func (p *IscsiDetails) SetPort(attr int64) {
	p.port = &attr
}

func (p *IscsiDetails) Port() (int64, bool) {
	if p.port != nil {
		return *p.port, true
	}
	var zero int64
	return zero, false
}

func (p *IscsiDetails) MustPort() int64 {
	if p.port == nil {
		panic("the port must not be nil, please use Port() function instead")
	}
	return *p.port
}

func (p *IscsiDetails) SetPortal(attr string) {
	p.portal = &attr
}

func (p *IscsiDetails) Portal() (string, bool) {
	if p.portal != nil {
		return *p.portal, true
	}
	var zero string
	return zero, false
}

func (p *IscsiDetails) MustPortal() string {
	if p.portal == nil {
		panic("the portal must not be nil, please use Portal() function instead")
	}
	return *p.portal
}

func (p *IscsiDetails) SetProductId(attr string) {
	p.productId = &attr
}

func (p *IscsiDetails) ProductId() (string, bool) {
	if p.productId != nil {
		return *p.productId, true
	}
	var zero string
	return zero, false
}

func (p *IscsiDetails) MustProductId() string {
	if p.productId == nil {
		panic("the productId must not be nil, please use ProductId() function instead")
	}
	return *p.productId
}

func (p *IscsiDetails) SetSerial(attr string) {
	p.serial = &attr
}

func (p *IscsiDetails) Serial() (string, bool) {
	if p.serial != nil {
		return *p.serial, true
	}
	var zero string
	return zero, false
}

func (p *IscsiDetails) MustSerial() string {
	if p.serial == nil {
		panic("the serial must not be nil, please use Serial() function instead")
	}
	return *p.serial
}

func (p *IscsiDetails) SetSize(attr int64) {
	p.size = &attr
}

func (p *IscsiDetails) Size() (int64, bool) {
	if p.size != nil {
		return *p.size, true
	}
	var zero int64
	return zero, false
}

func (p *IscsiDetails) MustSize() int64 {
	if p.size == nil {
		panic("the size must not be nil, please use Size() function instead")
	}
	return *p.size
}

func (p *IscsiDetails) SetStatus(attr string) {
	p.status = &attr
}

func (p *IscsiDetails) Status() (string, bool) {
	if p.status != nil {
		return *p.status, true
	}
	var zero string
	return zero, false
}

func (p *IscsiDetails) MustStatus() string {
	if p.status == nil {
		panic("the status must not be nil, please use Status() function instead")
	}
	return *p.status
}

func (p *IscsiDetails) SetStorageDomainId(attr string) {
	p.storageDomainId = &attr
}

func (p *IscsiDetails) StorageDomainId() (string, bool) {
	if p.storageDomainId != nil {
		return *p.storageDomainId, true
	}
	var zero string
	return zero, false
}

func (p *IscsiDetails) MustStorageDomainId() string {
	if p.storageDomainId == nil {
		panic("the storageDomainId must not be nil, please use StorageDomainId() function instead")
	}
	return *p.storageDomainId
}

func (p *IscsiDetails) SetTarget(attr string) {
	p.target = &attr
}

func (p *IscsiDetails) Target() (string, bool) {
	if p.target != nil {
		return *p.target, true
	}
	var zero string
	return zero, false
}

func (p *IscsiDetails) MustTarget() string {
	if p.target == nil {
		panic("the target must not be nil, please use Target() function instead")
	}
	return *p.target
}

func (p *IscsiDetails) SetUsername(attr string) {
	p.username = &attr
}

func (p *IscsiDetails) Username() (string, bool) {
	if p.username != nil {
		return *p.username, true
	}
	var zero string
	return zero, false
}

func (p *IscsiDetails) MustUsername() string {
	if p.username == nil {
		panic("the username must not be nil, please use Username() function instead")
	}
	return *p.username
}

func (p *IscsiDetails) SetVendorId(attr string) {
	p.vendorId = &attr
}

func (p *IscsiDetails) VendorId() (string, bool) {
	if p.vendorId != nil {
		return *p.vendorId, true
	}
	var zero string
	return zero, false
}

func (p *IscsiDetails) MustVendorId() string {
	if p.vendorId == nil {
		panic("the vendorId must not be nil, please use VendorId() function instead")
	}
	return *p.vendorId
}

func (p *IscsiDetails) SetVolumeGroupId(attr string) {
	p.volumeGroupId = &attr
}

func (p *IscsiDetails) VolumeGroupId() (string, bool) {
	if p.volumeGroupId != nil {
		return *p.volumeGroupId, true
	}
	var zero string
	return zero, false
}

func (p *IscsiDetails) MustVolumeGroupId() string {
	if p.volumeGroupId == nil {
		panic("the volumeGroupId must not be nil, please use VolumeGroupId() function instead")
	}
	return *p.volumeGroupId
}

// Job Represents a job, which monitors execution of a flow in the system.
// A job can contain multiple steps in a hierarchic structure.
// The steps can be processed in parallel, depends on the implementation of the flow.
type Job struct {
	Struct
	autoCleared *bool
	comment     *string
	description *string
	endTime     *time.Time
	external    *bool
	id          *string
	lastUpdated *time.Time
	name        *string
	owner       *User
	startTime   *time.Time
	status      *JobStatus
	steps       *StepSlice
}

func (p *Job) SetAutoCleared(attr bool) {
	p.autoCleared = &attr
}

func (p *Job) AutoCleared() (bool, bool) {
	if p.autoCleared != nil {
		return *p.autoCleared, true
	}
	var zero bool
	return zero, false
}

func (p *Job) MustAutoCleared() bool {
	if p.autoCleared == nil {
		panic("the autoCleared must not be nil, please use AutoCleared() function instead")
	}
	return *p.autoCleared
}

func (p *Job) SetComment(attr string) {
	p.comment = &attr
}

func (p *Job) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *Job) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *Job) SetDescription(attr string) {
	p.description = &attr
}

func (p *Job) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *Job) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *Job) SetEndTime(attr time.Time) {
	p.endTime = &attr
}

func (p *Job) EndTime() (time.Time, bool) {
	if p.endTime != nil {
		return *p.endTime, true
	}
	var zero time.Time
	return zero, false
}

func (p *Job) MustEndTime() time.Time {
	if p.endTime == nil {
		panic("the endTime must not be nil, please use EndTime() function instead")
	}
	return *p.endTime
}

func (p *Job) SetExternal(attr bool) {
	p.external = &attr
}

func (p *Job) External() (bool, bool) {
	if p.external != nil {
		return *p.external, true
	}
	var zero bool
	return zero, false
}

func (p *Job) MustExternal() bool {
	if p.external == nil {
		panic("the external must not be nil, please use External() function instead")
	}
	return *p.external
}

func (p *Job) SetId(attr string) {
	p.id = &attr
}

func (p *Job) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *Job) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *Job) SetLastUpdated(attr time.Time) {
	p.lastUpdated = &attr
}

func (p *Job) LastUpdated() (time.Time, bool) {
	if p.lastUpdated != nil {
		return *p.lastUpdated, true
	}
	var zero time.Time
	return zero, false
}

func (p *Job) MustLastUpdated() time.Time {
	if p.lastUpdated == nil {
		panic("the lastUpdated must not be nil, please use LastUpdated() function instead")
	}
	return *p.lastUpdated
}

func (p *Job) SetName(attr string) {
	p.name = &attr
}

func (p *Job) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *Job) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

// SetOwner Represents a user in the system.
func (p *Job) SetOwner(attr *User) {
	p.owner = attr
}

// Owner Represents a user in the system.
func (p *Job) Owner() (*User, bool) {
	if p.owner != nil {
		return p.owner, true
	}
	return nil, false
}

// MustOwner Represents a user in the system.
func (p *Job) MustOwner() *User {
	if p.owner == nil {
		panic("the owner must not be nil, please use Owner() function instead")
	}
	return p.owner
}

func (p *Job) SetStartTime(attr time.Time) {
	p.startTime = &attr
}

func (p *Job) StartTime() (time.Time, bool) {
	if p.startTime != nil {
		return *p.startTime, true
	}
	var zero time.Time
	return zero, false
}

func (p *Job) MustStartTime() time.Time {
	if p.startTime == nil {
		panic("the startTime must not be nil, please use StartTime() function instead")
	}
	return *p.startTime
}

// SetStatus Represents the status of the job.
func (p *Job) SetStatus(attr JobStatus) {
	p.status = &attr
}

// Status Represents the status of the job.
func (p *Job) Status() (JobStatus, bool) {
	if p.status != nil {
		return *p.status, true
	}
	var zero JobStatus
	return zero, false
}

// MustStatus Represents the status of the job.
func (p *Job) MustStatus() JobStatus {
	if p.status == nil {
		panic("the status must not be nil, please use Status() function instead")
	}
	return *p.status
}

func (p *Job) SetSteps(attr *StepSlice) {
	p.steps = attr
}

func (p *Job) Steps() (*StepSlice, bool) {
	if p.steps != nil {
		return p.steps, true
	}
	return nil, false
}

func (p *Job) MustSteps() *StepSlice {
	if p.steps == nil {
		panic("the steps must not be nil, please use Steps() function instead")
	}
	return p.steps
}

// KatelloErratum Type representing a Katello erratum.
type KatelloErratum struct {
	Struct
	comment     *string
	description *string
	host        *Host
	id          *string
	issued      *time.Time
	name        *string
	packages    *PackageSlice
	severity    *string
	solution    *string
	summary     *string
	title       *string
	type_       *string
	vm          *Vm
}

func (p *KatelloErratum) SetComment(attr string) {
	p.comment = &attr
}

func (p *KatelloErratum) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *KatelloErratum) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *KatelloErratum) SetDescription(attr string) {
	p.description = &attr
}

func (p *KatelloErratum) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *KatelloErratum) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

// SetHost Type representing a host.
func (p *KatelloErratum) SetHost(attr *Host) {
	p.host = attr
}

// Host Type representing a host.
func (p *KatelloErratum) Host() (*Host, bool) {
	if p.host != nil {
		return p.host, true
	}
	return nil, false
}

// MustHost Type representing a host.
func (p *KatelloErratum) MustHost() *Host {
	if p.host == nil {
		panic("the host must not be nil, please use Host() function instead")
	}
	return p.host
}

func (p *KatelloErratum) SetId(attr string) {
	p.id = &attr
}

func (p *KatelloErratum) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *KatelloErratum) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *KatelloErratum) SetIssued(attr time.Time) {
	p.issued = &attr
}

func (p *KatelloErratum) Issued() (time.Time, bool) {
	if p.issued != nil {
		return *p.issued, true
	}
	var zero time.Time
	return zero, false
}

func (p *KatelloErratum) MustIssued() time.Time {
	if p.issued == nil {
		panic("the issued must not be nil, please use Issued() function instead")
	}
	return *p.issued
}

func (p *KatelloErratum) SetName(attr string) {
	p.name = &attr
}

func (p *KatelloErratum) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *KatelloErratum) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *KatelloErratum) SetPackages(attr *PackageSlice) {
	p.packages = attr
}

func (p *KatelloErratum) Packages() (*PackageSlice, bool) {
	if p.packages != nil {
		return p.packages, true
	}
	return nil, false
}

func (p *KatelloErratum) MustPackages() *PackageSlice {
	if p.packages == nil {
		panic("the packages must not be nil, please use Packages() function instead")
	}
	return p.packages
}

func (p *KatelloErratum) SetSeverity(attr string) {
	p.severity = &attr
}

func (p *KatelloErratum) Severity() (string, bool) {
	if p.severity != nil {
		return *p.severity, true
	}
	var zero string
	return zero, false
}

func (p *KatelloErratum) MustSeverity() string {
	if p.severity == nil {
		panic("the severity must not be nil, please use Severity() function instead")
	}
	return *p.severity
}

func (p *KatelloErratum) SetSolution(attr string) {
	p.solution = &attr
}

func (p *KatelloErratum) Solution() (string, bool) {
	if p.solution != nil {
		return *p.solution, true
	}
	var zero string
	return zero, false
}

func (p *KatelloErratum) MustSolution() string {
	if p.solution == nil {
		panic("the solution must not be nil, please use Solution() function instead")
	}
	return *p.solution
}

func (p *KatelloErratum) SetSummary(attr string) {
	p.summary = &attr
}

func (p *KatelloErratum) Summary() (string, bool) {
	if p.summary != nil {
		return *p.summary, true
	}
	var zero string
	return zero, false
}

func (p *KatelloErratum) MustSummary() string {
	if p.summary == nil {
		panic("the summary must not be nil, please use Summary() function instead")
	}
	return *p.summary
}

func (p *KatelloErratum) SetTitle(attr string) {
	p.title = &attr
}

func (p *KatelloErratum) Title() (string, bool) {
	if p.title != nil {
		return *p.title, true
	}
	var zero string
	return zero, false
}

func (p *KatelloErratum) MustTitle() string {
	if p.title == nil {
		panic("the title must not be nil, please use Title() function instead")
	}
	return *p.title
}

func (p *KatelloErratum) SetType(attr string) {
	p.type_ = &attr
}

func (p *KatelloErratum) Type() (string, bool) {
	if p.type_ != nil {
		return *p.type_, true
	}
	var zero string
	return zero, false
}

func (p *KatelloErratum) MustType() string {
	if p.type_ == nil {
		panic("the type_ must not be nil, please use Type() function instead")
	}
	return *p.type_
}

// SetVm Represents a virtual machine.
func (p *KatelloErratum) SetVm(attr *Vm) {
	p.vm = attr
}

// Vm Represents a virtual machine.
func (p *KatelloErratum) Vm() (*Vm, bool) {
	if p.vm != nil {
		return p.vm, true
	}
	return nil, false
}

// MustVm Represents a virtual machine.
func (p *KatelloErratum) MustVm() *Vm {
	if p.vm == nil {
		panic("the vm must not be nil, please use Vm() function instead")
	}
	return p.vm
}

type Kernel struct {
	Struct
	version *Version
}

func (p *Kernel) SetVersion(attr *Version) {
	p.version = attr
}

func (p *Kernel) Version() (*Version, bool) {
	if p.version != nil {
		return p.version, true
	}
	return nil, false
}

func (p *Kernel) MustVersion() *Version {
	if p.version == nil {
		panic("the version must not be nil, please use Version() function instead")
	}
	return p.version
}

type Ksm struct {
	Struct
	enabled          *bool
	mergeAcrossNodes *bool
}

func (p *Ksm) SetEnabled(attr bool) {
	p.enabled = &attr
}

func (p *Ksm) Enabled() (bool, bool) {
	if p.enabled != nil {
		return *p.enabled, true
	}
	var zero bool
	return zero, false
}

func (p *Ksm) MustEnabled() bool {
	if p.enabled == nil {
		panic("the enabled must not be nil, please use Enabled() function instead")
	}
	return *p.enabled
}

func (p *Ksm) SetMergeAcrossNodes(attr bool) {
	p.mergeAcrossNodes = &attr
}

func (p *Ksm) MergeAcrossNodes() (bool, bool) {
	if p.mergeAcrossNodes != nil {
		return *p.mergeAcrossNodes, true
	}
	var zero bool
	return zero, false
}

func (p *Ksm) MustMergeAcrossNodes() bool {
	if p.mergeAcrossNodes == nil {
		panic("the mergeAcrossNodes must not be nil, please use MergeAcrossNodes() function instead")
	}
	return *p.mergeAcrossNodes
}

// LinkLayerDiscoveryProtocolElement Represents an information element received by Link Layer Discovery Protocol (LLDP).
// IEEE 802.1AB defines type, length, value (TLV) as a "short, variable length encoding of an information element".
// This type represents such an information element.
//
// The attribute `name` is a human-readable string used to describe what the value is about, and may not be unique.
// The name is redundant, because it could be created from `type` and the optional `oui` and `subtype`.
// The purpose of `name` is to simplify the reading of the information element.
// The `name` of a property is exactly the same string which is used in IEEE 802.1AB chapter 8.
//
// Organizationally-specific information elements have the `type` of `127` and the attributes
// `oui` and `subtype`.
//
// For example, the XML representation of an information element may look like this:
//
// [source,xml]
// ----
// <link_layer_discovery_protocol_element>
//   <name>Port VLAN Id</name>
//   <oui>32962</oui>
//   <properties>
//     <property>
//       <name>vlan id</name>
//       <value>488</value>
//     </property>
//     <property>
//       <name>vlan name</name>
//       <value>v2-0488-03-0505</value>
//     </property>
//   </properties>
//   <subtype>3</subtype>
//   <type>127</type>
// </link_layer_discovery_protocol_element>
// ----
type LinkLayerDiscoveryProtocolElement struct {
	Struct
	comment     *string
	description *string
	id          *string
	name        *string
	oui         *int64
	properties  *PropertySlice
	subtype     *int64
	type_       *int64
}

func (p *LinkLayerDiscoveryProtocolElement) SetComment(attr string) {
	p.comment = &attr
}

func (p *LinkLayerDiscoveryProtocolElement) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *LinkLayerDiscoveryProtocolElement) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *LinkLayerDiscoveryProtocolElement) SetDescription(attr string) {
	p.description = &attr
}

func (p *LinkLayerDiscoveryProtocolElement) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *LinkLayerDiscoveryProtocolElement) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *LinkLayerDiscoveryProtocolElement) SetId(attr string) {
	p.id = &attr
}

func (p *LinkLayerDiscoveryProtocolElement) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *LinkLayerDiscoveryProtocolElement) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *LinkLayerDiscoveryProtocolElement) SetName(attr string) {
	p.name = &attr
}

func (p *LinkLayerDiscoveryProtocolElement) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *LinkLayerDiscoveryProtocolElement) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *LinkLayerDiscoveryProtocolElement) SetOui(attr int64) {
	p.oui = &attr
}

func (p *LinkLayerDiscoveryProtocolElement) Oui() (int64, bool) {
	if p.oui != nil {
		return *p.oui, true
	}
	var zero int64
	return zero, false
}

func (p *LinkLayerDiscoveryProtocolElement) MustOui() int64 {
	if p.oui == nil {
		panic("the oui must not be nil, please use Oui() function instead")
	}
	return *p.oui
}

func (p *LinkLayerDiscoveryProtocolElement) SetProperties(attr *PropertySlice) {
	p.properties = attr
}

func (p *LinkLayerDiscoveryProtocolElement) Properties() (*PropertySlice, bool) {
	if p.properties != nil {
		return p.properties, true
	}
	return nil, false
}

func (p *LinkLayerDiscoveryProtocolElement) MustProperties() *PropertySlice {
	if p.properties == nil {
		panic("the properties must not be nil, please use Properties() function instead")
	}
	return p.properties
}

func (p *LinkLayerDiscoveryProtocolElement) SetSubtype(attr int64) {
	p.subtype = &attr
}

func (p *LinkLayerDiscoveryProtocolElement) Subtype() (int64, bool) {
	if p.subtype != nil {
		return *p.subtype, true
	}
	var zero int64
	return zero, false
}

func (p *LinkLayerDiscoveryProtocolElement) MustSubtype() int64 {
	if p.subtype == nil {
		panic("the subtype must not be nil, please use Subtype() function instead")
	}
	return *p.subtype
}

func (p *LinkLayerDiscoveryProtocolElement) SetType(attr int64) {
	p.type_ = &attr
}

func (p *LinkLayerDiscoveryProtocolElement) Type() (int64, bool) {
	if p.type_ != nil {
		return *p.type_, true
	}
	var zero int64
	return zero, false
}

func (p *LinkLayerDiscoveryProtocolElement) MustType() int64 {
	if p.type_ == nil {
		panic("the type_ must not be nil, please use Type() function instead")
	}
	return *p.type_
}

type LogicalUnit struct {
	Struct
	address           *string
	discardMaxSize    *int64
	discardZeroesData *bool
	diskId            *string
	id                *string
	lunMapping        *int64
	password          *string
	paths             *int64
	port              *int64
	portal            *string
	productId         *string
	serial            *string
	size              *int64
	status            *LunStatus
	storageDomainId   *string
	target            *string
	username          *string
	vendorId          *string
	volumeGroupId     *string
}

func (p *LogicalUnit) SetAddress(attr string) {
	p.address = &attr
}

func (p *LogicalUnit) Address() (string, bool) {
	if p.address != nil {
		return *p.address, true
	}
	var zero string
	return zero, false
}

func (p *LogicalUnit) MustAddress() string {
	if p.address == nil {
		panic("the address must not be nil, please use Address() function instead")
	}
	return *p.address
}

func (p *LogicalUnit) SetDiscardMaxSize(attr int64) {
	p.discardMaxSize = &attr
}

func (p *LogicalUnit) DiscardMaxSize() (int64, bool) {
	if p.discardMaxSize != nil {
		return *p.discardMaxSize, true
	}
	var zero int64
	return zero, false
}

func (p *LogicalUnit) MustDiscardMaxSize() int64 {
	if p.discardMaxSize == nil {
		panic("the discardMaxSize must not be nil, please use DiscardMaxSize() function instead")
	}
	return *p.discardMaxSize
}

func (p *LogicalUnit) SetDiscardZeroesData(attr bool) {
	p.discardZeroesData = &attr
}

func (p *LogicalUnit) DiscardZeroesData() (bool, bool) {
	if p.discardZeroesData != nil {
		return *p.discardZeroesData, true
	}
	var zero bool
	return zero, false
}

func (p *LogicalUnit) MustDiscardZeroesData() bool {
	if p.discardZeroesData == nil {
		panic("the discardZeroesData must not be nil, please use DiscardZeroesData() function instead")
	}
	return *p.discardZeroesData
}

func (p *LogicalUnit) SetDiskId(attr string) {
	p.diskId = &attr
}

func (p *LogicalUnit) DiskId() (string, bool) {
	if p.diskId != nil {
		return *p.diskId, true
	}
	var zero string
	return zero, false
}

func (p *LogicalUnit) MustDiskId() string {
	if p.diskId == nil {
		panic("the diskId must not be nil, please use DiskId() function instead")
	}
	return *p.diskId
}

func (p *LogicalUnit) SetId(attr string) {
	p.id = &attr
}

func (p *LogicalUnit) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *LogicalUnit) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *LogicalUnit) SetLunMapping(attr int64) {
	p.lunMapping = &attr
}

func (p *LogicalUnit) LunMapping() (int64, bool) {
	if p.lunMapping != nil {
		return *p.lunMapping, true
	}
	var zero int64
	return zero, false
}

func (p *LogicalUnit) MustLunMapping() int64 {
	if p.lunMapping == nil {
		panic("the lunMapping must not be nil, please use LunMapping() function instead")
	}
	return *p.lunMapping
}

func (p *LogicalUnit) SetPassword(attr string) {
	p.password = &attr
}

func (p *LogicalUnit) Password() (string, bool) {
	if p.password != nil {
		return *p.password, true
	}
	var zero string
	return zero, false
}

func (p *LogicalUnit) MustPassword() string {
	if p.password == nil {
		panic("the password must not be nil, please use Password() function instead")
	}
	return *p.password
}

func (p *LogicalUnit) SetPaths(attr int64) {
	p.paths = &attr
}

func (p *LogicalUnit) Paths() (int64, bool) {
	if p.paths != nil {
		return *p.paths, true
	}
	var zero int64
	return zero, false
}

func (p *LogicalUnit) MustPaths() int64 {
	if p.paths == nil {
		panic("the paths must not be nil, please use Paths() function instead")
	}
	return *p.paths
}

func (p *LogicalUnit) SetPort(attr int64) {
	p.port = &attr
}

func (p *LogicalUnit) Port() (int64, bool) {
	if p.port != nil {
		return *p.port, true
	}
	var zero int64
	return zero, false
}

func (p *LogicalUnit) MustPort() int64 {
	if p.port == nil {
		panic("the port must not be nil, please use Port() function instead")
	}
	return *p.port
}

func (p *LogicalUnit) SetPortal(attr string) {
	p.portal = &attr
}

func (p *LogicalUnit) Portal() (string, bool) {
	if p.portal != nil {
		return *p.portal, true
	}
	var zero string
	return zero, false
}

func (p *LogicalUnit) MustPortal() string {
	if p.portal == nil {
		panic("the portal must not be nil, please use Portal() function instead")
	}
	return *p.portal
}

func (p *LogicalUnit) SetProductId(attr string) {
	p.productId = &attr
}

func (p *LogicalUnit) ProductId() (string, bool) {
	if p.productId != nil {
		return *p.productId, true
	}
	var zero string
	return zero, false
}

func (p *LogicalUnit) MustProductId() string {
	if p.productId == nil {
		panic("the productId must not be nil, please use ProductId() function instead")
	}
	return *p.productId
}

func (p *LogicalUnit) SetSerial(attr string) {
	p.serial = &attr
}

func (p *LogicalUnit) Serial() (string, bool) {
	if p.serial != nil {
		return *p.serial, true
	}
	var zero string
	return zero, false
}

func (p *LogicalUnit) MustSerial() string {
	if p.serial == nil {
		panic("the serial must not be nil, please use Serial() function instead")
	}
	return *p.serial
}

func (p *LogicalUnit) SetSize(attr int64) {
	p.size = &attr
}

func (p *LogicalUnit) Size() (int64, bool) {
	if p.size != nil {
		return *p.size, true
	}
	var zero int64
	return zero, false
}

func (p *LogicalUnit) MustSize() int64 {
	if p.size == nil {
		panic("the size must not be nil, please use Size() function instead")
	}
	return *p.size
}

func (p *LogicalUnit) SetStatus(attr LunStatus) {
	p.status = &attr
}

func (p *LogicalUnit) Status() (LunStatus, bool) {
	if p.status != nil {
		return *p.status, true
	}
	var zero LunStatus
	return zero, false
}

func (p *LogicalUnit) MustStatus() LunStatus {
	if p.status == nil {
		panic("the status must not be nil, please use Status() function instead")
	}
	return *p.status
}

func (p *LogicalUnit) SetStorageDomainId(attr string) {
	p.storageDomainId = &attr
}

func (p *LogicalUnit) StorageDomainId() (string, bool) {
	if p.storageDomainId != nil {
		return *p.storageDomainId, true
	}
	var zero string
	return zero, false
}

func (p *LogicalUnit) MustStorageDomainId() string {
	if p.storageDomainId == nil {
		panic("the storageDomainId must not be nil, please use StorageDomainId() function instead")
	}
	return *p.storageDomainId
}

func (p *LogicalUnit) SetTarget(attr string) {
	p.target = &attr
}

func (p *LogicalUnit) Target() (string, bool) {
	if p.target != nil {
		return *p.target, true
	}
	var zero string
	return zero, false
}

func (p *LogicalUnit) MustTarget() string {
	if p.target == nil {
		panic("the target must not be nil, please use Target() function instead")
	}
	return *p.target
}

func (p *LogicalUnit) SetUsername(attr string) {
	p.username = &attr
}

func (p *LogicalUnit) Username() (string, bool) {
	if p.username != nil {
		return *p.username, true
	}
	var zero string
	return zero, false
}

func (p *LogicalUnit) MustUsername() string {
	if p.username == nil {
		panic("the username must not be nil, please use Username() function instead")
	}
	return *p.username
}

func (p *LogicalUnit) SetVendorId(attr string) {
	p.vendorId = &attr
}

func (p *LogicalUnit) VendorId() (string, bool) {
	if p.vendorId != nil {
		return *p.vendorId, true
	}
	var zero string
	return zero, false
}

func (p *LogicalUnit) MustVendorId() string {
	if p.vendorId == nil {
		panic("the vendorId must not be nil, please use VendorId() function instead")
	}
	return *p.vendorId
}

func (p *LogicalUnit) SetVolumeGroupId(attr string) {
	p.volumeGroupId = &attr
}

func (p *LogicalUnit) VolumeGroupId() (string, bool) {
	if p.volumeGroupId != nil {
		return *p.volumeGroupId, true
	}
	var zero string
	return zero, false
}

func (p *LogicalUnit) MustVolumeGroupId() string {
	if p.volumeGroupId == nil {
		panic("the volumeGroupId must not be nil, please use VolumeGroupId() function instead")
	}
	return *p.volumeGroupId
}

// MDevType Mediated device is a software device that allows to divide physical device's resources.
//
// See https://libvirt.org/drvnodedev.html#MDEV[Libvirt-MDEV] for further details.
type MDevType struct {
	Struct
	availableInstances *int64
	description        *string
	humanReadableName  *string
	name               *string
}

func (p *MDevType) SetAvailableInstances(attr int64) {
	p.availableInstances = &attr
}

func (p *MDevType) AvailableInstances() (int64, bool) {
	if p.availableInstances != nil {
		return *p.availableInstances, true
	}
	var zero int64
	return zero, false
}

func (p *MDevType) MustAvailableInstances() int64 {
	if p.availableInstances == nil {
		panic("the availableInstances must not be nil, please use AvailableInstances() function instead")
	}
	return *p.availableInstances
}

func (p *MDevType) SetDescription(attr string) {
	p.description = &attr
}

func (p *MDevType) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *MDevType) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *MDevType) SetHumanReadableName(attr string) {
	p.humanReadableName = &attr
}

func (p *MDevType) HumanReadableName() (string, bool) {
	if p.humanReadableName != nil {
		return *p.humanReadableName, true
	}
	var zero string
	return zero, false
}

func (p *MDevType) MustHumanReadableName() string {
	if p.humanReadableName == nil {
		panic("the humanReadableName must not be nil, please use HumanReadableName() function instead")
	}
	return *p.humanReadableName
}

func (p *MDevType) SetName(attr string) {
	p.name = &attr
}

func (p *MDevType) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *MDevType) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

// Mac Represents a MAC address of a virtual network interface.
type Mac struct {
	Struct
	address *string
}

func (p *Mac) SetAddress(attr string) {
	p.address = &attr
}

func (p *Mac) Address() (string, bool) {
	if p.address != nil {
		return *p.address, true
	}
	var zero string
	return zero, false
}

func (p *Mac) MustAddress() string {
	if p.address == nil {
		panic("the address must not be nil, please use Address() function instead")
	}
	return *p.address
}

// MacPool Represents a MAC address pool.
//
// Example of an XML representation of a MAC address pool:
//
// [source,xml]
// ----
// <mac_pool href="/ovirt-engine/api/macpools/123" id="123">
//   <name>Default</name>
//   <description>Default MAC pool</description>
//   <allow_duplicates>false</allow_duplicates>
//   <default_pool>true</default_pool>
//   <ranges>
//     <range>
//       <from>00:1A:4A:16:01:51</from>
//       <to>00:1A:4A:16:01:E6</to>
//     </range>
//   </ranges>
// </mac_pool>
// ----
type MacPool struct {
	Struct
	allowDuplicates *bool
	comment         *string
	defaultPool     *bool
	description     *string
	id              *string
	name            *string
	permissions     *PermissionSlice
	ranges          *RangeSlice
}

func (p *MacPool) SetAllowDuplicates(attr bool) {
	p.allowDuplicates = &attr
}

func (p *MacPool) AllowDuplicates() (bool, bool) {
	if p.allowDuplicates != nil {
		return *p.allowDuplicates, true
	}
	var zero bool
	return zero, false
}

func (p *MacPool) MustAllowDuplicates() bool {
	if p.allowDuplicates == nil {
		panic("the allowDuplicates must not be nil, please use AllowDuplicates() function instead")
	}
	return *p.allowDuplicates
}

func (p *MacPool) SetComment(attr string) {
	p.comment = &attr
}

func (p *MacPool) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *MacPool) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *MacPool) SetDefaultPool(attr bool) {
	p.defaultPool = &attr
}

func (p *MacPool) DefaultPool() (bool, bool) {
	if p.defaultPool != nil {
		return *p.defaultPool, true
	}
	var zero bool
	return zero, false
}

func (p *MacPool) MustDefaultPool() bool {
	if p.defaultPool == nil {
		panic("the defaultPool must not be nil, please use DefaultPool() function instead")
	}
	return *p.defaultPool
}

func (p *MacPool) SetDescription(attr string) {
	p.description = &attr
}

func (p *MacPool) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *MacPool) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *MacPool) SetId(attr string) {
	p.id = &attr
}

func (p *MacPool) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *MacPool) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *MacPool) SetName(attr string) {
	p.name = &attr
}

func (p *MacPool) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *MacPool) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *MacPool) SetPermissions(attr *PermissionSlice) {
	p.permissions = attr
}

func (p *MacPool) Permissions() (*PermissionSlice, bool) {
	if p.permissions != nil {
		return p.permissions, true
	}
	return nil, false
}

func (p *MacPool) MustPermissions() *PermissionSlice {
	if p.permissions == nil {
		panic("the permissions must not be nil, please use Permissions() function instead")
	}
	return p.permissions
}

func (p *MacPool) SetRanges(attr *RangeSlice) {
	p.ranges = attr
}

func (p *MacPool) Ranges() (*RangeSlice, bool) {
	if p.ranges != nil {
		return p.ranges, true
	}
	return nil, false
}

func (p *MacPool) MustRanges() *RangeSlice {
	if p.ranges == nil {
		panic("the ranges must not be nil, please use Ranges() function instead")
	}
	return p.ranges
}

type MemoryOverCommit struct {
	Struct
	percent *int64
}

func (p *MemoryOverCommit) SetPercent(attr int64) {
	p.percent = &attr
}

func (p *MemoryOverCommit) Percent() (int64, bool) {
	if p.percent != nil {
		return *p.percent, true
	}
	var zero int64
	return zero, false
}

func (p *MemoryOverCommit) MustPercent() int64 {
	if p.percent == nil {
		panic("the percent must not be nil, please use Percent() function instead")
	}
	return *p.percent
}

// MemoryPolicy Logical grouping of memory-related properties of virtual machine-like entities.
type MemoryPolicy struct {
	Struct
	ballooning           *bool
	guaranteed           *int64
	max                  *int64
	overCommit           *MemoryOverCommit
	transparentHugePages *TransparentHugePages
}

func (p *MemoryPolicy) SetBallooning(attr bool) {
	p.ballooning = &attr
}

func (p *MemoryPolicy) Ballooning() (bool, bool) {
	if p.ballooning != nil {
		return *p.ballooning, true
	}
	var zero bool
	return zero, false
}

func (p *MemoryPolicy) MustBallooning() bool {
	if p.ballooning == nil {
		panic("the ballooning must not be nil, please use Ballooning() function instead")
	}
	return *p.ballooning
}

func (p *MemoryPolicy) SetGuaranteed(attr int64) {
	p.guaranteed = &attr
}

func (p *MemoryPolicy) Guaranteed() (int64, bool) {
	if p.guaranteed != nil {
		return *p.guaranteed, true
	}
	var zero int64
	return zero, false
}

func (p *MemoryPolicy) MustGuaranteed() int64 {
	if p.guaranteed == nil {
		panic("the guaranteed must not be nil, please use Guaranteed() function instead")
	}
	return *p.guaranteed
}

func (p *MemoryPolicy) SetMax(attr int64) {
	p.max = &attr
}

func (p *MemoryPolicy) Max() (int64, bool) {
	if p.max != nil {
		return *p.max, true
	}
	var zero int64
	return zero, false
}

func (p *MemoryPolicy) MustMax() int64 {
	if p.max == nil {
		panic("the max must not be nil, please use Max() function instead")
	}
	return *p.max
}

func (p *MemoryPolicy) SetOverCommit(attr *MemoryOverCommit) {
	p.overCommit = attr
}

func (p *MemoryPolicy) OverCommit() (*MemoryOverCommit, bool) {
	if p.overCommit != nil {
		return p.overCommit, true
	}
	return nil, false
}

func (p *MemoryPolicy) MustOverCommit() *MemoryOverCommit {
	if p.overCommit == nil {
		panic("the overCommit must not be nil, please use OverCommit() function instead")
	}
	return p.overCommit
}

// SetTransparentHugePages Type representing a transparent huge pages (THP) support.
func (p *MemoryPolicy) SetTransparentHugePages(attr *TransparentHugePages) {
	p.transparentHugePages = attr
}

// TransparentHugePages Type representing a transparent huge pages (THP) support.
func (p *MemoryPolicy) TransparentHugePages() (*TransparentHugePages, bool) {
	if p.transparentHugePages != nil {
		return p.transparentHugePages, true
	}
	return nil, false
}

// MustTransparentHugePages Type representing a transparent huge pages (THP) support.
func (p *MemoryPolicy) MustTransparentHugePages() *TransparentHugePages {
	if p.transparentHugePages == nil {
		panic("the transparentHugePages must not be nil, please use TransparentHugePages() function instead")
	}
	return p.transparentHugePages
}

type Method struct {
	Struct
	id *SsoMethod
}

func (p *Method) SetId(attr SsoMethod) {
	p.id = &attr
}

func (p *Method) Id() (SsoMethod, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero SsoMethod
	return zero, false
}

func (p *Method) MustId() SsoMethod {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

// MigrationBandwidth Defines the bandwidth used by migration.
type MigrationBandwidth struct {
	Struct
	assignmentMethod *MigrationBandwidthAssignmentMethod
	customValue      *int64
}

// SetAssignmentMethod Defines how the migration bandwidth is assigned.
func (p *MigrationBandwidth) SetAssignmentMethod(attr MigrationBandwidthAssignmentMethod) {
	p.assignmentMethod = &attr
}

// AssignmentMethod Defines how the migration bandwidth is assigned.
func (p *MigrationBandwidth) AssignmentMethod() (MigrationBandwidthAssignmentMethod, bool) {
	if p.assignmentMethod != nil {
		return *p.assignmentMethod, true
	}
	var zero MigrationBandwidthAssignmentMethod
	return zero, false
}

// MustAssignmentMethod Defines how the migration bandwidth is assigned.
func (p *MigrationBandwidth) MustAssignmentMethod() MigrationBandwidthAssignmentMethod {
	if p.assignmentMethod == nil {
		panic("the assignmentMethod must not be nil, please use AssignmentMethod() function instead")
	}
	return *p.assignmentMethod
}

func (p *MigrationBandwidth) SetCustomValue(attr int64) {
	p.customValue = &attr
}

func (p *MigrationBandwidth) CustomValue() (int64, bool) {
	if p.customValue != nil {
		return *p.customValue, true
	}
	var zero int64
	return zero, false
}

func (p *MigrationBandwidth) MustCustomValue() int64 {
	if p.customValue == nil {
		panic("the customValue must not be nil, please use CustomValue() function instead")
	}
	return *p.customValue
}

// MigrationOptions The type for migration options.
type MigrationOptions struct {
	Struct
	autoConverge *InheritableBoolean
	bandwidth    *MigrationBandwidth
	compressed   *InheritableBoolean
	encrypted    *InheritableBoolean
	policy       *MigrationPolicy
}

// SetAutoConverge Enum representing the boolean value that can be either set, or inherited from a higher level.
// The inheritance order is virtual machine -> cluster -> engine-config.
func (p *MigrationOptions) SetAutoConverge(attr InheritableBoolean) {
	p.autoConverge = &attr
}

// AutoConverge Enum representing the boolean value that can be either set, or inherited from a higher level.
// The inheritance order is virtual machine -> cluster -> engine-config.
func (p *MigrationOptions) AutoConverge() (InheritableBoolean, bool) {
	if p.autoConverge != nil {
		return *p.autoConverge, true
	}
	var zero InheritableBoolean
	return zero, false
}

// MustAutoConverge Enum representing the boolean value that can be either set, or inherited from a higher level.
// The inheritance order is virtual machine -> cluster -> engine-config.
func (p *MigrationOptions) MustAutoConverge() InheritableBoolean {
	if p.autoConverge == nil {
		panic("the autoConverge must not be nil, please use AutoConverge() function instead")
	}
	return *p.autoConverge
}

// SetBandwidth Defines the bandwidth used by migration.
func (p *MigrationOptions) SetBandwidth(attr *MigrationBandwidth) {
	p.bandwidth = attr
}

// Bandwidth Defines the bandwidth used by migration.
func (p *MigrationOptions) Bandwidth() (*MigrationBandwidth, bool) {
	if p.bandwidth != nil {
		return p.bandwidth, true
	}
	return nil, false
}

// MustBandwidth Defines the bandwidth used by migration.
func (p *MigrationOptions) MustBandwidth() *MigrationBandwidth {
	if p.bandwidth == nil {
		panic("the bandwidth must not be nil, please use Bandwidth() function instead")
	}
	return p.bandwidth
}

// SetCompressed Enum representing the boolean value that can be either set, or inherited from a higher level.
// The inheritance order is virtual machine -> cluster -> engine-config.
func (p *MigrationOptions) SetCompressed(attr InheritableBoolean) {
	p.compressed = &attr
}

// Compressed Enum representing the boolean value that can be either set, or inherited from a higher level.
// The inheritance order is virtual machine -> cluster -> engine-config.
func (p *MigrationOptions) Compressed() (InheritableBoolean, bool) {
	if p.compressed != nil {
		return *p.compressed, true
	}
	var zero InheritableBoolean
	return zero, false
}

// MustCompressed Enum representing the boolean value that can be either set, or inherited from a higher level.
// The inheritance order is virtual machine -> cluster -> engine-config.
func (p *MigrationOptions) MustCompressed() InheritableBoolean {
	if p.compressed == nil {
		panic("the compressed must not be nil, please use Compressed() function instead")
	}
	return *p.compressed
}

// SetEncrypted Enum representing the boolean value that can be either set, or inherited from a higher level.
// The inheritance order is virtual machine -> cluster -> engine-config.
func (p *MigrationOptions) SetEncrypted(attr InheritableBoolean) {
	p.encrypted = &attr
}

// Encrypted Enum representing the boolean value that can be either set, or inherited from a higher level.
// The inheritance order is virtual machine -> cluster -> engine-config.
func (p *MigrationOptions) Encrypted() (InheritableBoolean, bool) {
	if p.encrypted != nil {
		return *p.encrypted, true
	}
	var zero InheritableBoolean
	return zero, false
}

// MustEncrypted Enum representing the boolean value that can be either set, or inherited from a higher level.
// The inheritance order is virtual machine -> cluster -> engine-config.
func (p *MigrationOptions) MustEncrypted() InheritableBoolean {
	if p.encrypted == nil {
		panic("the encrypted must not be nil, please use Encrypted() function instead")
	}
	return *p.encrypted
}

// SetPolicy A policy describing how the migration is treated, such as convergence or
// how many parallel migrations are allowed.
func (p *MigrationOptions) SetPolicy(attr *MigrationPolicy) {
	p.policy = attr
}

// Policy A policy describing how the migration is treated, such as convergence or
// how many parallel migrations are allowed.
func (p *MigrationOptions) Policy() (*MigrationPolicy, bool) {
	if p.policy != nil {
		return p.policy, true
	}
	return nil, false
}

// MustPolicy A policy describing how the migration is treated, such as convergence or
// how many parallel migrations are allowed.
func (p *MigrationOptions) MustPolicy() *MigrationPolicy {
	if p.policy == nil {
		panic("the policy must not be nil, please use Policy() function instead")
	}
	return p.policy
}

// MigrationPolicy A policy describing how the migration is treated, such as convergence or
// how many parallel migrations are allowed.
type MigrationPolicy struct {
	Struct
	comment     *string
	description *string
	id          *string
	name        *string
}

func (p *MigrationPolicy) SetComment(attr string) {
	p.comment = &attr
}

func (p *MigrationPolicy) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *MigrationPolicy) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *MigrationPolicy) SetDescription(attr string) {
	p.description = &attr
}

func (p *MigrationPolicy) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *MigrationPolicy) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *MigrationPolicy) SetId(attr string) {
	p.id = &attr
}

func (p *MigrationPolicy) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *MigrationPolicy) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *MigrationPolicy) SetName(attr string) {
	p.name = &attr
}

func (p *MigrationPolicy) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *MigrationPolicy) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

// Network The type for a logical network.
//
// An example of the JSON representation of a logical network:
//
// [source,json]
// ----
// {
//   "network" : [ {
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "stp" : "false",
//     "mtu" : "0",
//     "usages" : {
//       "usage" : [ "vm" ]
//     },
//     "name" : "ovirtmgmt",
//     "description" : "Management Network",
//     "href" : "/ovirt-engine/api/networks/456",
//     "id" : "456",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/networks/456/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/networks/456/vnicprofiles",
//       "rel" : "vnicprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/networks/456/labels",
//       "rel" : "labels"
//     } ]
//   } ]
// }
// ----
//
// An example of the XML representation of the same logical network:
//
// [source,xml]
// ----
// <network href="/ovirt-engine/api/networks/456" id="456">
//   <name>ovirtmgmt</name>
//   <description>Management Network</description>
//   <link href="/ovirt-engine/api/networks/456/permissions" rel="permissions"/>
//   <link href="/ovirt-engine/api/networks/456/vnicprofiles" rel="vnicprofiles"/>
//   <link href="/ovirt-engine/api/networks/456/labels" rel="labels"/>
//   <data_center href="/ovirt-engine/api/datacenters/123" id="123"/>
//   <stp>false</stp>
//   <mtu>0</mtu>
//   <usages>
//     <usage>vm</usage>
//   </usages>
// </network>
// ----
type Network struct {
	Struct
	cluster                         *Cluster
	comment                         *string
	dataCenter                      *DataCenter
	description                     *string
	display                         *bool
	dnsResolverConfiguration        *DnsResolverConfiguration
	externalProvider                *OpenStackNetworkProvider
	externalProviderPhysicalNetwork *Network
	id                              *string
	ip                              *Ip
	mtu                             *int64
	name                            *string
	networkLabels                   *NetworkLabelSlice
	permissions                     *PermissionSlice
	portIsolation                   *bool
	profileRequired                 *bool
	qos                             *Qos
	required                        *bool
	status                          *NetworkStatus
	stp                             *bool
	usages                          []NetworkUsage
	vdsmName                        *string
	vlan                            *Vlan
	vnicProfiles                    *VnicProfileSlice
}

// SetCluster Type representation of a cluster.
//
// A JSON representation of a cluster:
//
// [source]
// ----
// {
//   "cluster" : [ {
//     "ballooning_enabled" : "false",
//     "cpu" : {
//       "architecture" : "x86_64",
//       "type" : "Intel SandyBridge Family"
//     },
//     "custom_scheduling_policy_properties" : {
//       "property" : [ {
//         "name" : "HighUtilization",
//         "value" : "80"
//       }, {
//         "name" : "CpuOverCommitDurationMinutes",
//         "value" : "2"
//       } ]
//     },
//     "error_handling" : {
//       "on_error" : "migrate"
//     },
//     "fencing_policy" : {
//       "enabled" : "true",
//       "skip_if_connectivity_broken" : {
//         "enabled" : "false",
//         "threshold" : "50"
//       },
//       "skip_if_gluster_bricks_up" : "false",
//       "skip_if_gluster_quorum_not_met" : "false",
//       "skip_if_sd_active" : {
//         "enabled" : "false"
//       }
//     },
//     "gluster_service" : "false",
//     "firewall_type" : "iptables",
//     "ha_reservation" : "false",
//     "ksm" : {
//       "enabled" : "true",
//       "merge_across_nodes" : "true"
//     },
//     "memory_policy" : {
//       "over_commit" : {
//         "percent" : "100"
//       },
//       "transparent_hugepages" : {
//         "enabled" : "true"
//       }
//     },
//     "migration" : {
//       "auto_converge" : "inherit",
//       "bandwidth" : {
//         "assignment_method" : "auto"
//       },
//       "compressed" : "inherit",
//       "policy" : {
//         "id" : "00000000-0000-0000-0000-000000000000"
//       }
//     },
//     "required_rng_sources" : {
//       "required_rng_source" : [ "random" ]
//     },
//     "switch_type" : "legacy",
//     "threads_as_cores" : "false",
//     "trusted_service" : "false",
//     "tunnel_migration" : "false",
//     "version" : {
//       "major" : "4",
//       "minor" : "1"
//     },
//     "virt_service" : "true",
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "mac_pool" : {
//       "href" : "/ovirt-engine/api/macpools/456",
//       "id" : "456"
//     },
//     "scheduling_policy" : {
//       "href" : "/ovirt-engine/api/schedulingpolicies/789",
//       "id" : "789"
//     },
//     "actions" : {
//       "link" : [ {
//         "href" : "/ovirt-engine/api/clusters/234/resetemulatedmachine",
//         "rel" : "resetemulatedmachine"
//       } ]
//     },
//     "name" : "Default",
//     "description" : "The default server cluster",
//     "href" : "/ovirt-engine/api/clusters/234",
//     "id" : "234",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/clusters/234/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/cpuprofiles",
//       "rel" : "cpuprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networkfilters",
//       "rel" : "networkfilters"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networks",
//       "rel" : "networks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/affinitygroups",
//       "rel" : "affinitygroups"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glusterhooks",
//       "rel" : "glusterhooks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glustervolumes",
//       "rel" : "glustervolumes"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/enabledfeatures",
//       "rel" : "enabledfeatures"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/externalnetworkproviders",
//       "rel" : "externalnetworkproviders"
//     } ]
//   } ]
// }
// ----
func (p *Network) SetCluster(attr *Cluster) {
	p.cluster = attr
}

// Cluster Type representation of a cluster.
//
// A JSON representation of a cluster:
//
// [source]
// ----
// {
//   "cluster" : [ {
//     "ballooning_enabled" : "false",
//     "cpu" : {
//       "architecture" : "x86_64",
//       "type" : "Intel SandyBridge Family"
//     },
//     "custom_scheduling_policy_properties" : {
//       "property" : [ {
//         "name" : "HighUtilization",
//         "value" : "80"
//       }, {
//         "name" : "CpuOverCommitDurationMinutes",
//         "value" : "2"
//       } ]
//     },
//     "error_handling" : {
//       "on_error" : "migrate"
//     },
//     "fencing_policy" : {
//       "enabled" : "true",
//       "skip_if_connectivity_broken" : {
//         "enabled" : "false",
//         "threshold" : "50"
//       },
//       "skip_if_gluster_bricks_up" : "false",
//       "skip_if_gluster_quorum_not_met" : "false",
//       "skip_if_sd_active" : {
//         "enabled" : "false"
//       }
//     },
//     "gluster_service" : "false",
//     "firewall_type" : "iptables",
//     "ha_reservation" : "false",
//     "ksm" : {
//       "enabled" : "true",
//       "merge_across_nodes" : "true"
//     },
//     "memory_policy" : {
//       "over_commit" : {
//         "percent" : "100"
//       },
//       "transparent_hugepages" : {
//         "enabled" : "true"
//       }
//     },
//     "migration" : {
//       "auto_converge" : "inherit",
//       "bandwidth" : {
//         "assignment_method" : "auto"
//       },
//       "compressed" : "inherit",
//       "policy" : {
//         "id" : "00000000-0000-0000-0000-000000000000"
//       }
//     },
//     "required_rng_sources" : {
//       "required_rng_source" : [ "random" ]
//     },
//     "switch_type" : "legacy",
//     "threads_as_cores" : "false",
//     "trusted_service" : "false",
//     "tunnel_migration" : "false",
//     "version" : {
//       "major" : "4",
//       "minor" : "1"
//     },
//     "virt_service" : "true",
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "mac_pool" : {
//       "href" : "/ovirt-engine/api/macpools/456",
//       "id" : "456"
//     },
//     "scheduling_policy" : {
//       "href" : "/ovirt-engine/api/schedulingpolicies/789",
//       "id" : "789"
//     },
//     "actions" : {
//       "link" : [ {
//         "href" : "/ovirt-engine/api/clusters/234/resetemulatedmachine",
//         "rel" : "resetemulatedmachine"
//       } ]
//     },
//     "name" : "Default",
//     "description" : "The default server cluster",
//     "href" : "/ovirt-engine/api/clusters/234",
//     "id" : "234",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/clusters/234/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/cpuprofiles",
//       "rel" : "cpuprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networkfilters",
//       "rel" : "networkfilters"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networks",
//       "rel" : "networks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/affinitygroups",
//       "rel" : "affinitygroups"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glusterhooks",
//       "rel" : "glusterhooks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glustervolumes",
//       "rel" : "glustervolumes"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/enabledfeatures",
//       "rel" : "enabledfeatures"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/externalnetworkproviders",
//       "rel" : "externalnetworkproviders"
//     } ]
//   } ]
// }
// ----
func (p *Network) Cluster() (*Cluster, bool) {
	if p.cluster != nil {
		return p.cluster, true
	}
	return nil, false
}

// MustCluster Type representation of a cluster.
//
// A JSON representation of a cluster:
//
// [source]
// ----
// {
//   "cluster" : [ {
//     "ballooning_enabled" : "false",
//     "cpu" : {
//       "architecture" : "x86_64",
//       "type" : "Intel SandyBridge Family"
//     },
//     "custom_scheduling_policy_properties" : {
//       "property" : [ {
//         "name" : "HighUtilization",
//         "value" : "80"
//       }, {
//         "name" : "CpuOverCommitDurationMinutes",
//         "value" : "2"
//       } ]
//     },
//     "error_handling" : {
//       "on_error" : "migrate"
//     },
//     "fencing_policy" : {
//       "enabled" : "true",
//       "skip_if_connectivity_broken" : {
//         "enabled" : "false",
//         "threshold" : "50"
//       },
//       "skip_if_gluster_bricks_up" : "false",
//       "skip_if_gluster_quorum_not_met" : "false",
//       "skip_if_sd_active" : {
//         "enabled" : "false"
//       }
//     },
//     "gluster_service" : "false",
//     "firewall_type" : "iptables",
//     "ha_reservation" : "false",
//     "ksm" : {
//       "enabled" : "true",
//       "merge_across_nodes" : "true"
//     },
//     "memory_policy" : {
//       "over_commit" : {
//         "percent" : "100"
//       },
//       "transparent_hugepages" : {
//         "enabled" : "true"
//       }
//     },
//     "migration" : {
//       "auto_converge" : "inherit",
//       "bandwidth" : {
//         "assignment_method" : "auto"
//       },
//       "compressed" : "inherit",
//       "policy" : {
//         "id" : "00000000-0000-0000-0000-000000000000"
//       }
//     },
//     "required_rng_sources" : {
//       "required_rng_source" : [ "random" ]
//     },
//     "switch_type" : "legacy",
//     "threads_as_cores" : "false",
//     "trusted_service" : "false",
//     "tunnel_migration" : "false",
//     "version" : {
//       "major" : "4",
//       "minor" : "1"
//     },
//     "virt_service" : "true",
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "mac_pool" : {
//       "href" : "/ovirt-engine/api/macpools/456",
//       "id" : "456"
//     },
//     "scheduling_policy" : {
//       "href" : "/ovirt-engine/api/schedulingpolicies/789",
//       "id" : "789"
//     },
//     "actions" : {
//       "link" : [ {
//         "href" : "/ovirt-engine/api/clusters/234/resetemulatedmachine",
//         "rel" : "resetemulatedmachine"
//       } ]
//     },
//     "name" : "Default",
//     "description" : "The default server cluster",
//     "href" : "/ovirt-engine/api/clusters/234",
//     "id" : "234",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/clusters/234/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/cpuprofiles",
//       "rel" : "cpuprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networkfilters",
//       "rel" : "networkfilters"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networks",
//       "rel" : "networks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/affinitygroups",
//       "rel" : "affinitygroups"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glusterhooks",
//       "rel" : "glusterhooks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glustervolumes",
//       "rel" : "glustervolumes"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/enabledfeatures",
//       "rel" : "enabledfeatures"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/externalnetworkproviders",
//       "rel" : "externalnetworkproviders"
//     } ]
//   } ]
// }
// ----
func (p *Network) MustCluster() *Cluster {
	if p.cluster == nil {
		panic("the cluster must not be nil, please use Cluster() function instead")
	}
	return p.cluster
}

func (p *Network) SetComment(attr string) {
	p.comment = &attr
}

func (p *Network) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *Network) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *Network) SetDataCenter(attr *DataCenter) {
	p.dataCenter = attr
}

func (p *Network) DataCenter() (*DataCenter, bool) {
	if p.dataCenter != nil {
		return p.dataCenter, true
	}
	return nil, false
}

func (p *Network) MustDataCenter() *DataCenter {
	if p.dataCenter == nil {
		panic("the dataCenter must not be nil, please use DataCenter() function instead")
	}
	return p.dataCenter
}

func (p *Network) SetDescription(attr string) {
	p.description = &attr
}

func (p *Network) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *Network) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *Network) SetDisplay(attr bool) {
	p.display = &attr
}

func (p *Network) Display() (bool, bool) {
	if p.display != nil {
		return *p.display, true
	}
	var zero bool
	return zero, false
}

func (p *Network) MustDisplay() bool {
	if p.display == nil {
		panic("the display must not be nil, please use Display() function instead")
	}
	return *p.display
}

// SetDnsResolverConfiguration Represents the DNS resolver configuration.
func (p *Network) SetDnsResolverConfiguration(attr *DnsResolverConfiguration) {
	p.dnsResolverConfiguration = attr
}

// DnsResolverConfiguration Represents the DNS resolver configuration.
func (p *Network) DnsResolverConfiguration() (*DnsResolverConfiguration, bool) {
	if p.dnsResolverConfiguration != nil {
		return p.dnsResolverConfiguration, true
	}
	return nil, false
}

// MustDnsResolverConfiguration Represents the DNS resolver configuration.
func (p *Network) MustDnsResolverConfiguration() *DnsResolverConfiguration {
	if p.dnsResolverConfiguration == nil {
		panic("the dnsResolverConfiguration must not be nil, please use DnsResolverConfiguration() function instead")
	}
	return p.dnsResolverConfiguration
}

func (p *Network) SetExternalProvider(attr *OpenStackNetworkProvider) {
	p.externalProvider = attr
}

func (p *Network) ExternalProvider() (*OpenStackNetworkProvider, bool) {
	if p.externalProvider != nil {
		return p.externalProvider, true
	}
	return nil, false
}

func (p *Network) MustExternalProvider() *OpenStackNetworkProvider {
	if p.externalProvider == nil {
		panic("the externalProvider must not be nil, please use ExternalProvider() function instead")
	}
	return p.externalProvider
}

// SetExternalProviderPhysicalNetwork The type for a logical network.
//
// An example of the JSON representation of a logical network:
//
// [source,json]
// ----
// {
//   "network" : [ {
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "stp" : "false",
//     "mtu" : "0",
//     "usages" : {
//       "usage" : [ "vm" ]
//     },
//     "name" : "ovirtmgmt",
//     "description" : "Management Network",
//     "href" : "/ovirt-engine/api/networks/456",
//     "id" : "456",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/networks/456/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/networks/456/vnicprofiles",
//       "rel" : "vnicprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/networks/456/labels",
//       "rel" : "labels"
//     } ]
//   } ]
// }
// ----
//
// An example of the XML representation of the same logical network:
//
// [source,xml]
// ----
// <network href="/ovirt-engine/api/networks/456" id="456">
//   <name>ovirtmgmt</name>
//   <description>Management Network</description>
//   <link href="/ovirt-engine/api/networks/456/permissions" rel="permissions"/>
//   <link href="/ovirt-engine/api/networks/456/vnicprofiles" rel="vnicprofiles"/>
//   <link href="/ovirt-engine/api/networks/456/labels" rel="labels"/>
//   <data_center href="/ovirt-engine/api/datacenters/123" id="123"/>
//   <stp>false</stp>
//   <mtu>0</mtu>
//   <usages>
//     <usage>vm</usage>
//   </usages>
// </network>
// ----
func (p *Network) SetExternalProviderPhysicalNetwork(attr *Network) {
	p.externalProviderPhysicalNetwork = attr
}

// ExternalProviderPhysicalNetwork The type for a logical network.
//
// An example of the JSON representation of a logical network:
//
// [source,json]
// ----
// {
//   "network" : [ {
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "stp" : "false",
//     "mtu" : "0",
//     "usages" : {
//       "usage" : [ "vm" ]
//     },
//     "name" : "ovirtmgmt",
//     "description" : "Management Network",
//     "href" : "/ovirt-engine/api/networks/456",
//     "id" : "456",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/networks/456/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/networks/456/vnicprofiles",
//       "rel" : "vnicprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/networks/456/labels",
//       "rel" : "labels"
//     } ]
//   } ]
// }
// ----
//
// An example of the XML representation of the same logical network:
//
// [source,xml]
// ----
// <network href="/ovirt-engine/api/networks/456" id="456">
//   <name>ovirtmgmt</name>
//   <description>Management Network</description>
//   <link href="/ovirt-engine/api/networks/456/permissions" rel="permissions"/>
//   <link href="/ovirt-engine/api/networks/456/vnicprofiles" rel="vnicprofiles"/>
//   <link href="/ovirt-engine/api/networks/456/labels" rel="labels"/>
//   <data_center href="/ovirt-engine/api/datacenters/123" id="123"/>
//   <stp>false</stp>
//   <mtu>0</mtu>
//   <usages>
//     <usage>vm</usage>
//   </usages>
// </network>
// ----
func (p *Network) ExternalProviderPhysicalNetwork() (*Network, bool) {
	if p.externalProviderPhysicalNetwork != nil {
		return p.externalProviderPhysicalNetwork, true
	}
	return nil, false
}

// MustExternalProviderPhysicalNetwork The type for a logical network.
//
// An example of the JSON representation of a logical network:
//
// [source,json]
// ----
// {
//   "network" : [ {
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "stp" : "false",
//     "mtu" : "0",
//     "usages" : {
//       "usage" : [ "vm" ]
//     },
//     "name" : "ovirtmgmt",
//     "description" : "Management Network",
//     "href" : "/ovirt-engine/api/networks/456",
//     "id" : "456",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/networks/456/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/networks/456/vnicprofiles",
//       "rel" : "vnicprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/networks/456/labels",
//       "rel" : "labels"
//     } ]
//   } ]
// }
// ----
//
// An example of the XML representation of the same logical network:
//
// [source,xml]
// ----
// <network href="/ovirt-engine/api/networks/456" id="456">
//   <name>ovirtmgmt</name>
//   <description>Management Network</description>
//   <link href="/ovirt-engine/api/networks/456/permissions" rel="permissions"/>
//   <link href="/ovirt-engine/api/networks/456/vnicprofiles" rel="vnicprofiles"/>
//   <link href="/ovirt-engine/api/networks/456/labels" rel="labels"/>
//   <data_center href="/ovirt-engine/api/datacenters/123" id="123"/>
//   <stp>false</stp>
//   <mtu>0</mtu>
//   <usages>
//     <usage>vm</usage>
//   </usages>
// </network>
// ----
func (p *Network) MustExternalProviderPhysicalNetwork() *Network {
	if p.externalProviderPhysicalNetwork == nil {
		panic("the externalProviderPhysicalNetwork must not be nil, please use ExternalProviderPhysicalNetwork() function instead")
	}
	return p.externalProviderPhysicalNetwork
}

func (p *Network) SetId(attr string) {
	p.id = &attr
}

func (p *Network) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *Network) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

// SetIp Represents the IP configuration of a network interface.
func (p *Network) SetIp(attr *Ip) {
	p.ip = attr
}

// Ip Represents the IP configuration of a network interface.
func (p *Network) Ip() (*Ip, bool) {
	if p.ip != nil {
		return p.ip, true
	}
	return nil, false
}

// MustIp Represents the IP configuration of a network interface.
func (p *Network) MustIp() *Ip {
	if p.ip == nil {
		panic("the ip must not be nil, please use Ip() function instead")
	}
	return p.ip
}

func (p *Network) SetMtu(attr int64) {
	p.mtu = &attr
}

func (p *Network) Mtu() (int64, bool) {
	if p.mtu != nil {
		return *p.mtu, true
	}
	var zero int64
	return zero, false
}

func (p *Network) MustMtu() int64 {
	if p.mtu == nil {
		panic("the mtu must not be nil, please use Mtu() function instead")
	}
	return *p.mtu
}

func (p *Network) SetName(attr string) {
	p.name = &attr
}

func (p *Network) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *Network) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *Network) SetNetworkLabels(attr *NetworkLabelSlice) {
	p.networkLabels = attr
}

func (p *Network) NetworkLabels() (*NetworkLabelSlice, bool) {
	if p.networkLabels != nil {
		return p.networkLabels, true
	}
	return nil, false
}

func (p *Network) MustNetworkLabels() *NetworkLabelSlice {
	if p.networkLabels == nil {
		panic("the networkLabels must not be nil, please use NetworkLabels() function instead")
	}
	return p.networkLabels
}

func (p *Network) SetPermissions(attr *PermissionSlice) {
	p.permissions = attr
}

func (p *Network) Permissions() (*PermissionSlice, bool) {
	if p.permissions != nil {
		return p.permissions, true
	}
	return nil, false
}

func (p *Network) MustPermissions() *PermissionSlice {
	if p.permissions == nil {
		panic("the permissions must not be nil, please use Permissions() function instead")
	}
	return p.permissions
}

func (p *Network) SetPortIsolation(attr bool) {
	p.portIsolation = &attr
}

func (p *Network) PortIsolation() (bool, bool) {
	if p.portIsolation != nil {
		return *p.portIsolation, true
	}
	var zero bool
	return zero, false
}

func (p *Network) MustPortIsolation() bool {
	if p.portIsolation == nil {
		panic("the portIsolation must not be nil, please use PortIsolation() function instead")
	}
	return *p.portIsolation
}

func (p *Network) SetProfileRequired(attr bool) {
	p.profileRequired = &attr
}

func (p *Network) ProfileRequired() (bool, bool) {
	if p.profileRequired != nil {
		return *p.profileRequired, true
	}
	var zero bool
	return zero, false
}

func (p *Network) MustProfileRequired() bool {
	if p.profileRequired == nil {
		panic("the profileRequired must not be nil, please use ProfileRequired() function instead")
	}
	return *p.profileRequired
}

// SetQos This type represents the attributes to define Quality of service (QoS).
//
// For storage the `type` is <<types/qos_type, storage>>, the attributes `max_throughput`, `max_read_throughput`,
// `max_write_throughput`, `max_iops`, `max_read_iops` and `max_write_iops` are relevant.
//
// For resources with computing capabilities the `type` is <<types/qos_type, cpu>>, the attribute `cpu_limit` is
// relevant.
//
// For virtual machines networks the `type` is <<types/qos_type, network>>, the attributes `inbound_average`,
// `inbound_peak`, `inbound_burst`, `outbound_average`, `outbound_peak` and `outbound_burst` are relevant.
//
// For host networks the `type` is <<types/qos_type, hostnetwork>>, the attributes `outbound_average_linkshare`,
// `outbound_average_upperlimit` and `outbound_average_realtime` are relevant.
func (p *Network) SetQos(attr *Qos) {
	p.qos = attr
}

// Qos This type represents the attributes to define Quality of service (QoS).
//
// For storage the `type` is <<types/qos_type, storage>>, the attributes `max_throughput`, `max_read_throughput`,
// `max_write_throughput`, `max_iops`, `max_read_iops` and `max_write_iops` are relevant.
//
// For resources with computing capabilities the `type` is <<types/qos_type, cpu>>, the attribute `cpu_limit` is
// relevant.
//
// For virtual machines networks the `type` is <<types/qos_type, network>>, the attributes `inbound_average`,
// `inbound_peak`, `inbound_burst`, `outbound_average`, `outbound_peak` and `outbound_burst` are relevant.
//
// For host networks the `type` is <<types/qos_type, hostnetwork>>, the attributes `outbound_average_linkshare`,
// `outbound_average_upperlimit` and `outbound_average_realtime` are relevant.
func (p *Network) Qos() (*Qos, bool) {
	if p.qos != nil {
		return p.qos, true
	}
	return nil, false
}

// MustQos This type represents the attributes to define Quality of service (QoS).
//
// For storage the `type` is <<types/qos_type, storage>>, the attributes `max_throughput`, `max_read_throughput`,
// `max_write_throughput`, `max_iops`, `max_read_iops` and `max_write_iops` are relevant.
//
// For resources with computing capabilities the `type` is <<types/qos_type, cpu>>, the attribute `cpu_limit` is
// relevant.
//
// For virtual machines networks the `type` is <<types/qos_type, network>>, the attributes `inbound_average`,
// `inbound_peak`, `inbound_burst`, `outbound_average`, `outbound_peak` and `outbound_burst` are relevant.
//
// For host networks the `type` is <<types/qos_type, hostnetwork>>, the attributes `outbound_average_linkshare`,
// `outbound_average_upperlimit` and `outbound_average_realtime` are relevant.
func (p *Network) MustQos() *Qos {
	if p.qos == nil {
		panic("the qos must not be nil, please use Qos() function instead")
	}
	return p.qos
}

func (p *Network) SetRequired(attr bool) {
	p.required = &attr
}

func (p *Network) Required() (bool, bool) {
	if p.required != nil {
		return *p.required, true
	}
	var zero bool
	return zero, false
}

func (p *Network) MustRequired() bool {
	if p.required == nil {
		panic("the required must not be nil, please use Required() function instead")
	}
	return *p.required
}

func (p *Network) SetStatus(attr NetworkStatus) {
	p.status = &attr
}

func (p *Network) Status() (NetworkStatus, bool) {
	if p.status != nil {
		return *p.status, true
	}
	var zero NetworkStatus
	return zero, false
}

func (p *Network) MustStatus() NetworkStatus {
	if p.status == nil {
		panic("the status must not be nil, please use Status() function instead")
	}
	return *p.status
}

func (p *Network) SetStp(attr bool) {
	p.stp = &attr
}

func (p *Network) Stp() (bool, bool) {
	if p.stp != nil {
		return *p.stp, true
	}
	var zero bool
	return zero, false
}

func (p *Network) MustStp() bool {
	if p.stp == nil {
		panic("the stp must not be nil, please use Stp() function instead")
	}
	return *p.stp
}

func (p *Network) SetUsages(attr []NetworkUsage) {
	p.usages = attr
}

func (p *Network) Usages() ([]NetworkUsage, bool) {
	if p.usages != nil {
		return p.usages, true
	}
	return nil, false
}

func (p *Network) MustUsages() []NetworkUsage {
	if p.usages == nil {
		panic("the usages must not be nil, please use Usages() function instead")
	}
	return p.usages
}

func (p *Network) SetVdsmName(attr string) {
	p.vdsmName = &attr
}

func (p *Network) VdsmName() (string, bool) {
	if p.vdsmName != nil {
		return *p.vdsmName, true
	}
	var zero string
	return zero, false
}

func (p *Network) MustVdsmName() string {
	if p.vdsmName == nil {
		panic("the vdsmName must not be nil, please use VdsmName() function instead")
	}
	return *p.vdsmName
}

// SetVlan Type representing a Virtual LAN (VLAN) type.
func (p *Network) SetVlan(attr *Vlan) {
	p.vlan = attr
}

// Vlan Type representing a Virtual LAN (VLAN) type.
func (p *Network) Vlan() (*Vlan, bool) {
	if p.vlan != nil {
		return p.vlan, true
	}
	return nil, false
}

// MustVlan Type representing a Virtual LAN (VLAN) type.
func (p *Network) MustVlan() *Vlan {
	if p.vlan == nil {
		panic("the vlan must not be nil, please use Vlan() function instead")
	}
	return p.vlan
}

func (p *Network) SetVnicProfiles(attr *VnicProfileSlice) {
	p.vnicProfiles = attr
}

func (p *Network) VnicProfiles() (*VnicProfileSlice, bool) {
	if p.vnicProfiles != nil {
		return p.vnicProfiles, true
	}
	return nil, false
}

func (p *Network) MustVnicProfiles() *VnicProfileSlice {
	if p.vnicProfiles == nil {
		panic("the vnicProfiles must not be nil, please use VnicProfiles() function instead")
	}
	return p.vnicProfiles
}

// NetworkAttachment Describes how a host connects to a network.
//
// An XML representation of a network attachment on a host:
//
// [source,xml]
// ----
// <network_attachment href="/ovirt-engine/api/hosts/123/nics/456/networkattachments/789" id="789">
//   <network href="/ovirt-engine/api/networks/234" id="234"/>
//   <host_nic href="/ovirt-engine/api/hosts/123/nics/123" id="123"/>
//   <in_sync>true</in_sync>
//   <ip_address_assignments>
//     <ip_address_assignment>
//       <assignment_method>static</assignment_method>
//       <ip>
//         <address>192.168.122.39</address>
//         <gateway>192.168.122.1</gateway>
//         <netmask>255.255.255.0</netmask>
//         <version>v4</version>
//       </ip>
//     </ip_address_assignment>
//   </ip_address_assignments>
//   <reported_configurations>
//     <reported_configuration>
//       <name>mtu</name>
//       <expected_value>1500</expected_value>
//       <actual_value>1500</actual_value>
//       <in_sync>true</in_sync>
//     </reported_configuration>
//     <reported_configuration>
//       <name>bridged</name>
//       <expected_value>true</expected_value>
//       <actual_value>true</actual_value>
//       <in_sync>true</in_sync>
//     </reported_configuration>
//     ...
//   </reported_configurations>
// </network_attachment>
// ----
//
// The network element, with either a `name` or an `id`, is required in order to attach a network
// to a network interface card (NIC).
//
// For example, to attach a network to a host network interface card, send a request like this:
//
// [source]
// ----
// POST /ovirt-engine/api/hosts/123/nics/456/networkattachments
// ----
//
// With a request body like this:
//
// [source,xml]
// ----
// <networkattachment>
//   <network id="234"/>
// </networkattachment>
// ----
//
// To attach a network to a host, send a request like this:
//
// [source]
// ----
// POST /ovirt-engine/api/hosts/123/networkattachments
// ----
//
// With a request body like this:
//
// [source,xml]
// ----
// <network_attachment>
//   <network id="234"/>
//   <host_nic id="456"/>
// </network_attachment>
// ----
//
// The `ip_address_assignments` and `properties` elements are updatable post-creation.
//
// For example, to update a network attachment, send a request like this:
//
// [source]
// ----
// PUT /ovirt-engine/api/hosts/123/nics/456/networkattachments/789
// ----
//
// With a request body like this:
//
// [source,xml]
// ----
// <network_attachment>
//   <ip_address_assignments>
//     <ip_address_assignment>
//       <assignment_method>static</assignment_method>
//       <ip>
//         <address>7.1.1.1</address>
//         <gateway>7.1.1.2</gateway>
//         <netmask>255.255.255.0</netmask>
//         <version>v4</version>
//       </ip>
//     </ip_address_assignment>
//   </ip_address_assignments>
// </network_attachment>
// ----
//
// To detach a network from the network interface card send a request like this:
//
// [source]
// ----
// DELETE /ovirt-engine/api/hosts/123/nics/456/networkattachments/789
// ----
//
// IMPORTANT: Changes to network attachment configuration must be explicitly committed.
//
// An XML representation of a network attachment's `properties` sub-collection:
//
// [source, xml]
// ----
// <network_attachment>
//   <properties>
//     <property>
//       <name>bridge_opts</name>
//       <value>
//         forward_delay=1500 group_fwd_mask=0x0 multicast_snooping=1
//       </value>
//     </property>
//   </properties>
//   ...
// </network_attachment>
// ----
type NetworkAttachment struct {
	Struct
	comment                  *string
	description              *string
	dnsResolverConfiguration *DnsResolverConfiguration
	host                     *Host
	hostNic                  *HostNic
	id                       *string
	inSync                   *bool
	ipAddressAssignments     *IpAddressAssignmentSlice
	name                     *string
	network                  *Network
	properties               *PropertySlice
	qos                      *Qos
	reportedConfigurations   *ReportedConfigurationSlice
}

func (p *NetworkAttachment) SetComment(attr string) {
	p.comment = &attr
}

func (p *NetworkAttachment) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *NetworkAttachment) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *NetworkAttachment) SetDescription(attr string) {
	p.description = &attr
}

func (p *NetworkAttachment) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *NetworkAttachment) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

// SetDnsResolverConfiguration Represents the DNS resolver configuration.
func (p *NetworkAttachment) SetDnsResolverConfiguration(attr *DnsResolverConfiguration) {
	p.dnsResolverConfiguration = attr
}

// DnsResolverConfiguration Represents the DNS resolver configuration.
func (p *NetworkAttachment) DnsResolverConfiguration() (*DnsResolverConfiguration, bool) {
	if p.dnsResolverConfiguration != nil {
		return p.dnsResolverConfiguration, true
	}
	return nil, false
}

// MustDnsResolverConfiguration Represents the DNS resolver configuration.
func (p *NetworkAttachment) MustDnsResolverConfiguration() *DnsResolverConfiguration {
	if p.dnsResolverConfiguration == nil {
		panic("the dnsResolverConfiguration must not be nil, please use DnsResolverConfiguration() function instead")
	}
	return p.dnsResolverConfiguration
}

// SetHost Type representing a host.
func (p *NetworkAttachment) SetHost(attr *Host) {
	p.host = attr
}

// Host Type representing a host.
func (p *NetworkAttachment) Host() (*Host, bool) {
	if p.host != nil {
		return p.host, true
	}
	return nil, false
}

// MustHost Type representing a host.
func (p *NetworkAttachment) MustHost() *Host {
	if p.host == nil {
		panic("the host must not be nil, please use Host() function instead")
	}
	return p.host
}

// SetHostNic Represents a host NIC.
//
// For example, the XML representation of a host NIC looks like this:
//
// [source,xml]
// ----
// <host_nic href="/ovirt-engine/api/hosts/123/nics/456" id="456">
//   <name>eth0</name>
//   <boot_protocol>static</boot_protocol>
//   <bridged>true</bridged>
//   <custom_configuration>true</custom_configuration>
//   <ip>
//     <address>192.168.122.39</address>
//     <gateway>192.168.122.1</gateway>
//     <netmask>255.255.255.0</netmask>
//     <version>v4</version>
//   </ip>
//   <ipv6>
//     <gateway>::</gateway>
//     <version>v6</version>
//   </ipv6>
//   <ipv6_boot_protocol>none</ipv6_boot_protocol>
//   <mac>
//     <address>52:54:00:0c:79:1d</address>
//   </mac>
//   <mtu>1500</mtu>
//   <status>up</status>
// </host_nic>
// ----
//
// A bonded interface is represented as a <<types/host_nic, HostNic>> object
// containing the `bonding` and `slaves` attributes.
//
// For example, the XML representation of a bonded host NIC looks like this:
//
// [source,xml]
// ----
// <host_nic href="/ovirt-engine/api/hosts/123/nics/456" id="456">
//   <name>bond0</name>
//   <mac address="00:00:00:00:00:00"/>
//   <ip>
//     <address>192.168.122.39</address>
//     <gateway>192.168.122.1</gateway>
//     <netmask>255.255.255.0</netmask>
//     <version>v4</version>
//   </ip>
//   <boot_protocol>dhcp</boot_protocol>
//   <bonding>
//     <options>
//       <option>
//         <name>mode</name>
//         <value>4</value>
//         <type>Dynamic link aggregation (802.3ad)</type>
//       </option>
//       <option>
//         <name>miimon</name>
//         <value>100</value>
//       </option>
//     </options>
//     <slaves>
//       <host_nic id="123"/>
//       <host_nic id="456"/>
//     </slaves>
//   </bonding>
//   <mtu>1500</mtu>
//   <bridged>true</bridged>
//   <custom_configuration>false</custom_configuration>
// </host_nic>
// ----
func (p *NetworkAttachment) SetHostNic(attr *HostNic) {
	p.hostNic = attr
}

// HostNic Represents a host NIC.
//
// For example, the XML representation of a host NIC looks like this:
//
// [source,xml]
// ----
// <host_nic href="/ovirt-engine/api/hosts/123/nics/456" id="456">
//   <name>eth0</name>
//   <boot_protocol>static</boot_protocol>
//   <bridged>true</bridged>
//   <custom_configuration>true</custom_configuration>
//   <ip>
//     <address>192.168.122.39</address>
//     <gateway>192.168.122.1</gateway>
//     <netmask>255.255.255.0</netmask>
//     <version>v4</version>
//   </ip>
//   <ipv6>
//     <gateway>::</gateway>
//     <version>v6</version>
//   </ipv6>
//   <ipv6_boot_protocol>none</ipv6_boot_protocol>
//   <mac>
//     <address>52:54:00:0c:79:1d</address>
//   </mac>
//   <mtu>1500</mtu>
//   <status>up</status>
// </host_nic>
// ----
//
// A bonded interface is represented as a <<types/host_nic, HostNic>> object
// containing the `bonding` and `slaves` attributes.
//
// For example, the XML representation of a bonded host NIC looks like this:
//
// [source,xml]
// ----
// <host_nic href="/ovirt-engine/api/hosts/123/nics/456" id="456">
//   <name>bond0</name>
//   <mac address="00:00:00:00:00:00"/>
//   <ip>
//     <address>192.168.122.39</address>
//     <gateway>192.168.122.1</gateway>
//     <netmask>255.255.255.0</netmask>
//     <version>v4</version>
//   </ip>
//   <boot_protocol>dhcp</boot_protocol>
//   <bonding>
//     <options>
//       <option>
//         <name>mode</name>
//         <value>4</value>
//         <type>Dynamic link aggregation (802.3ad)</type>
//       </option>
//       <option>
//         <name>miimon</name>
//         <value>100</value>
//       </option>
//     </options>
//     <slaves>
//       <host_nic id="123"/>
//       <host_nic id="456"/>
//     </slaves>
//   </bonding>
//   <mtu>1500</mtu>
//   <bridged>true</bridged>
//   <custom_configuration>false</custom_configuration>
// </host_nic>
// ----
func (p *NetworkAttachment) HostNic() (*HostNic, bool) {
	if p.hostNic != nil {
		return p.hostNic, true
	}
	return nil, false
}

// MustHostNic Represents a host NIC.
//
// For example, the XML representation of a host NIC looks like this:
//
// [source,xml]
// ----
// <host_nic href="/ovirt-engine/api/hosts/123/nics/456" id="456">
//   <name>eth0</name>
//   <boot_protocol>static</boot_protocol>
//   <bridged>true</bridged>
//   <custom_configuration>true</custom_configuration>
//   <ip>
//     <address>192.168.122.39</address>
//     <gateway>192.168.122.1</gateway>
//     <netmask>255.255.255.0</netmask>
//     <version>v4</version>
//   </ip>
//   <ipv6>
//     <gateway>::</gateway>
//     <version>v6</version>
//   </ipv6>
//   <ipv6_boot_protocol>none</ipv6_boot_protocol>
//   <mac>
//     <address>52:54:00:0c:79:1d</address>
//   </mac>
//   <mtu>1500</mtu>
//   <status>up</status>
// </host_nic>
// ----
//
// A bonded interface is represented as a <<types/host_nic, HostNic>> object
// containing the `bonding` and `slaves` attributes.
//
// For example, the XML representation of a bonded host NIC looks like this:
//
// [source,xml]
// ----
// <host_nic href="/ovirt-engine/api/hosts/123/nics/456" id="456">
//   <name>bond0</name>
//   <mac address="00:00:00:00:00:00"/>
//   <ip>
//     <address>192.168.122.39</address>
//     <gateway>192.168.122.1</gateway>
//     <netmask>255.255.255.0</netmask>
//     <version>v4</version>
//   </ip>
//   <boot_protocol>dhcp</boot_protocol>
//   <bonding>
//     <options>
//       <option>
//         <name>mode</name>
//         <value>4</value>
//         <type>Dynamic link aggregation (802.3ad)</type>
//       </option>
//       <option>
//         <name>miimon</name>
//         <value>100</value>
//       </option>
//     </options>
//     <slaves>
//       <host_nic id="123"/>
//       <host_nic id="456"/>
//     </slaves>
//   </bonding>
//   <mtu>1500</mtu>
//   <bridged>true</bridged>
//   <custom_configuration>false</custom_configuration>
// </host_nic>
// ----
func (p *NetworkAttachment) MustHostNic() *HostNic {
	if p.hostNic == nil {
		panic("the hostNic must not be nil, please use HostNic() function instead")
	}
	return p.hostNic
}

func (p *NetworkAttachment) SetId(attr string) {
	p.id = &attr
}

func (p *NetworkAttachment) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *NetworkAttachment) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *NetworkAttachment) SetInSync(attr bool) {
	p.inSync = &attr
}

func (p *NetworkAttachment) InSync() (bool, bool) {
	if p.inSync != nil {
		return *p.inSync, true
	}
	var zero bool
	return zero, false
}

func (p *NetworkAttachment) MustInSync() bool {
	if p.inSync == nil {
		panic("the inSync must not be nil, please use InSync() function instead")
	}
	return *p.inSync
}

func (p *NetworkAttachment) SetIpAddressAssignments(attr *IpAddressAssignmentSlice) {
	p.ipAddressAssignments = attr
}

func (p *NetworkAttachment) IpAddressAssignments() (*IpAddressAssignmentSlice, bool) {
	if p.ipAddressAssignments != nil {
		return p.ipAddressAssignments, true
	}
	return nil, false
}

func (p *NetworkAttachment) MustIpAddressAssignments() *IpAddressAssignmentSlice {
	if p.ipAddressAssignments == nil {
		panic("the ipAddressAssignments must not be nil, please use IpAddressAssignments() function instead")
	}
	return p.ipAddressAssignments
}

func (p *NetworkAttachment) SetName(attr string) {
	p.name = &attr
}

func (p *NetworkAttachment) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *NetworkAttachment) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

// SetNetwork The type for a logical network.
//
// An example of the JSON representation of a logical network:
//
// [source,json]
// ----
// {
//   "network" : [ {
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "stp" : "false",
//     "mtu" : "0",
//     "usages" : {
//       "usage" : [ "vm" ]
//     },
//     "name" : "ovirtmgmt",
//     "description" : "Management Network",
//     "href" : "/ovirt-engine/api/networks/456",
//     "id" : "456",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/networks/456/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/networks/456/vnicprofiles",
//       "rel" : "vnicprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/networks/456/labels",
//       "rel" : "labels"
//     } ]
//   } ]
// }
// ----
//
// An example of the XML representation of the same logical network:
//
// [source,xml]
// ----
// <network href="/ovirt-engine/api/networks/456" id="456">
//   <name>ovirtmgmt</name>
//   <description>Management Network</description>
//   <link href="/ovirt-engine/api/networks/456/permissions" rel="permissions"/>
//   <link href="/ovirt-engine/api/networks/456/vnicprofiles" rel="vnicprofiles"/>
//   <link href="/ovirt-engine/api/networks/456/labels" rel="labels"/>
//   <data_center href="/ovirt-engine/api/datacenters/123" id="123"/>
//   <stp>false</stp>
//   <mtu>0</mtu>
//   <usages>
//     <usage>vm</usage>
//   </usages>
// </network>
// ----
func (p *NetworkAttachment) SetNetwork(attr *Network) {
	p.network = attr
}

// Network The type for a logical network.
//
// An example of the JSON representation of a logical network:
//
// [source,json]
// ----
// {
//   "network" : [ {
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "stp" : "false",
//     "mtu" : "0",
//     "usages" : {
//       "usage" : [ "vm" ]
//     },
//     "name" : "ovirtmgmt",
//     "description" : "Management Network",
//     "href" : "/ovirt-engine/api/networks/456",
//     "id" : "456",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/networks/456/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/networks/456/vnicprofiles",
//       "rel" : "vnicprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/networks/456/labels",
//       "rel" : "labels"
//     } ]
//   } ]
// }
// ----
//
// An example of the XML representation of the same logical network:
//
// [source,xml]
// ----
// <network href="/ovirt-engine/api/networks/456" id="456">
//   <name>ovirtmgmt</name>
//   <description>Management Network</description>
//   <link href="/ovirt-engine/api/networks/456/permissions" rel="permissions"/>
//   <link href="/ovirt-engine/api/networks/456/vnicprofiles" rel="vnicprofiles"/>
//   <link href="/ovirt-engine/api/networks/456/labels" rel="labels"/>
//   <data_center href="/ovirt-engine/api/datacenters/123" id="123"/>
//   <stp>false</stp>
//   <mtu>0</mtu>
//   <usages>
//     <usage>vm</usage>
//   </usages>
// </network>
// ----
func (p *NetworkAttachment) Network() (*Network, bool) {
	if p.network != nil {
		return p.network, true
	}
	return nil, false
}

// MustNetwork The type for a logical network.
//
// An example of the JSON representation of a logical network:
//
// [source,json]
// ----
// {
//   "network" : [ {
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "stp" : "false",
//     "mtu" : "0",
//     "usages" : {
//       "usage" : [ "vm" ]
//     },
//     "name" : "ovirtmgmt",
//     "description" : "Management Network",
//     "href" : "/ovirt-engine/api/networks/456",
//     "id" : "456",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/networks/456/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/networks/456/vnicprofiles",
//       "rel" : "vnicprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/networks/456/labels",
//       "rel" : "labels"
//     } ]
//   } ]
// }
// ----
//
// An example of the XML representation of the same logical network:
//
// [source,xml]
// ----
// <network href="/ovirt-engine/api/networks/456" id="456">
//   <name>ovirtmgmt</name>
//   <description>Management Network</description>
//   <link href="/ovirt-engine/api/networks/456/permissions" rel="permissions"/>
//   <link href="/ovirt-engine/api/networks/456/vnicprofiles" rel="vnicprofiles"/>
//   <link href="/ovirt-engine/api/networks/456/labels" rel="labels"/>
//   <data_center href="/ovirt-engine/api/datacenters/123" id="123"/>
//   <stp>false</stp>
//   <mtu>0</mtu>
//   <usages>
//     <usage>vm</usage>
//   </usages>
// </network>
// ----
func (p *NetworkAttachment) MustNetwork() *Network {
	if p.network == nil {
		panic("the network must not be nil, please use Network() function instead")
	}
	return p.network
}

func (p *NetworkAttachment) SetProperties(attr *PropertySlice) {
	p.properties = attr
}

func (p *NetworkAttachment) Properties() (*PropertySlice, bool) {
	if p.properties != nil {
		return p.properties, true
	}
	return nil, false
}

func (p *NetworkAttachment) MustProperties() *PropertySlice {
	if p.properties == nil {
		panic("the properties must not be nil, please use Properties() function instead")
	}
	return p.properties
}

// SetQos This type represents the attributes to define Quality of service (QoS).
//
// For storage the `type` is <<types/qos_type, storage>>, the attributes `max_throughput`, `max_read_throughput`,
// `max_write_throughput`, `max_iops`, `max_read_iops` and `max_write_iops` are relevant.
//
// For resources with computing capabilities the `type` is <<types/qos_type, cpu>>, the attribute `cpu_limit` is
// relevant.
//
// For virtual machines networks the `type` is <<types/qos_type, network>>, the attributes `inbound_average`,
// `inbound_peak`, `inbound_burst`, `outbound_average`, `outbound_peak` and `outbound_burst` are relevant.
//
// For host networks the `type` is <<types/qos_type, hostnetwork>>, the attributes `outbound_average_linkshare`,
// `outbound_average_upperlimit` and `outbound_average_realtime` are relevant.
func (p *NetworkAttachment) SetQos(attr *Qos) {
	p.qos = attr
}

// Qos This type represents the attributes to define Quality of service (QoS).
//
// For storage the `type` is <<types/qos_type, storage>>, the attributes `max_throughput`, `max_read_throughput`,
// `max_write_throughput`, `max_iops`, `max_read_iops` and `max_write_iops` are relevant.
//
// For resources with computing capabilities the `type` is <<types/qos_type, cpu>>, the attribute `cpu_limit` is
// relevant.
//
// For virtual machines networks the `type` is <<types/qos_type, network>>, the attributes `inbound_average`,
// `inbound_peak`, `inbound_burst`, `outbound_average`, `outbound_peak` and `outbound_burst` are relevant.
//
// For host networks the `type` is <<types/qos_type, hostnetwork>>, the attributes `outbound_average_linkshare`,
// `outbound_average_upperlimit` and `outbound_average_realtime` are relevant.
func (p *NetworkAttachment) Qos() (*Qos, bool) {
	if p.qos != nil {
		return p.qos, true
	}
	return nil, false
}

// MustQos This type represents the attributes to define Quality of service (QoS).
//
// For storage the `type` is <<types/qos_type, storage>>, the attributes `max_throughput`, `max_read_throughput`,
// `max_write_throughput`, `max_iops`, `max_read_iops` and `max_write_iops` are relevant.
//
// For resources with computing capabilities the `type` is <<types/qos_type, cpu>>, the attribute `cpu_limit` is
// relevant.
//
// For virtual machines networks the `type` is <<types/qos_type, network>>, the attributes `inbound_average`,
// `inbound_peak`, `inbound_burst`, `outbound_average`, `outbound_peak` and `outbound_burst` are relevant.
//
// For host networks the `type` is <<types/qos_type, hostnetwork>>, the attributes `outbound_average_linkshare`,
// `outbound_average_upperlimit` and `outbound_average_realtime` are relevant.
func (p *NetworkAttachment) MustQos() *Qos {
	if p.qos == nil {
		panic("the qos must not be nil, please use Qos() function instead")
	}
	return p.qos
}

func (p *NetworkAttachment) SetReportedConfigurations(attr *ReportedConfigurationSlice) {
	p.reportedConfigurations = attr
}

func (p *NetworkAttachment) ReportedConfigurations() (*ReportedConfigurationSlice, bool) {
	if p.reportedConfigurations != nil {
		return p.reportedConfigurations, true
	}
	return nil, false
}

func (p *NetworkAttachment) MustReportedConfigurations() *ReportedConfigurationSlice {
	if p.reportedConfigurations == nil {
		panic("the reportedConfigurations must not be nil, please use ReportedConfigurations() function instead")
	}
	return p.reportedConfigurations
}

type NetworkConfiguration struct {
	Struct
	dns  *Dns
	nics *NicSlice
}

// SetDns Represents the DNS resolver configuration.
func (p *NetworkConfiguration) SetDns(attr *Dns) {
	p.dns = attr
}

// Dns Represents the DNS resolver configuration.
func (p *NetworkConfiguration) Dns() (*Dns, bool) {
	if p.dns != nil {
		return p.dns, true
	}
	return nil, false
}

// MustDns Represents the DNS resolver configuration.
func (p *NetworkConfiguration) MustDns() *Dns {
	if p.dns == nil {
		panic("the dns must not be nil, please use Dns() function instead")
	}
	return p.dns
}

func (p *NetworkConfiguration) SetNics(attr *NicSlice) {
	p.nics = attr
}

func (p *NetworkConfiguration) Nics() (*NicSlice, bool) {
	if p.nics != nil {
		return p.nics, true
	}
	return nil, false
}

func (p *NetworkConfiguration) MustNics() *NicSlice {
	if p.nics == nil {
		panic("the nics must not be nil, please use Nics() function instead")
	}
	return p.nics
}

// NetworkFilter Network filters filter packets sent to and from the virtual machine's NIC according to defined rules.
//
// There are several types of network filters supported based on libvirt.
// For more details about the different network filters see https://libvirt.org/firewall.html[here].
//
// In addition to libvirt's network filters, there are two additional network filters:
// The first is called `vdsm-no-mac-spoofing` and is composed of `no-mac-spoofing` and `no-arp-mac-spoofing`.
// The second is called `ovirt-no-filter` and is used when no network filter is to be defined for the virtual machine's NIC.
// The `ovirt-no-filter` network filter is only used for internal implementation, and
// does not exist on the NICs.
//
// This is a example of the XML representation:
//
// [source,xml]
// ----
// <network_filter id="00000019-0019-0019-0019-00000000026c">
//   <name>example-filter</name>
//   <version>
//     <major>4</major>
//     <minor>0</minor>
//     <build>-1</build>
//     <revision>-1</revision>
//   </version>
// </network_filter>
// ----
//
// If any part of the version is not present, it is represented by -1.
type NetworkFilter struct {
	Struct
	comment     *string
	description *string
	id          *string
	name        *string
	version     *Version
}

func (p *NetworkFilter) SetComment(attr string) {
	p.comment = &attr
}

func (p *NetworkFilter) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *NetworkFilter) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *NetworkFilter) SetDescription(attr string) {
	p.description = &attr
}

func (p *NetworkFilter) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *NetworkFilter) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *NetworkFilter) SetId(attr string) {
	p.id = &attr
}

func (p *NetworkFilter) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *NetworkFilter) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *NetworkFilter) SetName(attr string) {
	p.name = &attr
}

func (p *NetworkFilter) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *NetworkFilter) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *NetworkFilter) SetVersion(attr *Version) {
	p.version = attr
}

func (p *NetworkFilter) Version() (*Version, bool) {
	if p.version != nil {
		return p.version, true
	}
	return nil, false
}

func (p *NetworkFilter) MustVersion() *Version {
	if p.version == nil {
		panic("the version must not be nil, please use Version() function instead")
	}
	return p.version
}

// NetworkFilterParameter Parameter for the <<types/network_filter,network filter>>.
//
// See https://libvirt.org/formatnwfilter.html#nwfconceptsvars[Libvirt-Filters] for further details.
// This is a example of the XML representation:
//
// [source,xml]
// ----
// <network_filter_parameter id="123">
//   <name>IP</name>
//   <value>10.0.1.2</value>
// </network_filter_parameter>
// ----
type NetworkFilterParameter struct {
	Struct
	comment     *string
	description *string
	id          *string
	name        *string
	nic         *Nic
	value       *string
}

func (p *NetworkFilterParameter) SetComment(attr string) {
	p.comment = &attr
}

func (p *NetworkFilterParameter) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *NetworkFilterParameter) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *NetworkFilterParameter) SetDescription(attr string) {
	p.description = &attr
}

func (p *NetworkFilterParameter) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *NetworkFilterParameter) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *NetworkFilterParameter) SetId(attr string) {
	p.id = &attr
}

func (p *NetworkFilterParameter) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *NetworkFilterParameter) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *NetworkFilterParameter) SetName(attr string) {
	p.name = &attr
}

func (p *NetworkFilterParameter) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *NetworkFilterParameter) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

// SetNic Represents a virtual machine NIC.
//
// For example, the XML representation of a NIC will look like this:
//
// [source,xml]
// ----
// <nic href="/ovirt-engine/api/vms/123/nics/456" id="456">
//   <name>nic1</name>
//   <vm href="/ovirt-engine/api/vms/123" id="123"/>
//   <interface>virtio</interface>
//   <linked>true</linked>
//   <mac>
//     <address>02:00:00:00:00:00</address>
//   </mac>
//   <plugged>true</plugged>
//   <vnic_profile href="/ovirt-engine/api/vnicprofiles/789" id="789"/>
// </nic>
// ----
func (p *NetworkFilterParameter) SetNic(attr *Nic) {
	p.nic = attr
}

// Nic Represents a virtual machine NIC.
//
// For example, the XML representation of a NIC will look like this:
//
// [source,xml]
// ----
// <nic href="/ovirt-engine/api/vms/123/nics/456" id="456">
//   <name>nic1</name>
//   <vm href="/ovirt-engine/api/vms/123" id="123"/>
//   <interface>virtio</interface>
//   <linked>true</linked>
//   <mac>
//     <address>02:00:00:00:00:00</address>
//   </mac>
//   <plugged>true</plugged>
//   <vnic_profile href="/ovirt-engine/api/vnicprofiles/789" id="789"/>
// </nic>
// ----
func (p *NetworkFilterParameter) Nic() (*Nic, bool) {
	if p.nic != nil {
		return p.nic, true
	}
	return nil, false
}

// MustNic Represents a virtual machine NIC.
//
// For example, the XML representation of a NIC will look like this:
//
// [source,xml]
// ----
// <nic href="/ovirt-engine/api/vms/123/nics/456" id="456">
//   <name>nic1</name>
//   <vm href="/ovirt-engine/api/vms/123" id="123"/>
//   <interface>virtio</interface>
//   <linked>true</linked>
//   <mac>
//     <address>02:00:00:00:00:00</address>
//   </mac>
//   <plugged>true</plugged>
//   <vnic_profile href="/ovirt-engine/api/vnicprofiles/789" id="789"/>
// </nic>
// ----
func (p *NetworkFilterParameter) MustNic() *Nic {
	if p.nic == nil {
		panic("the nic must not be nil, please use Nic() function instead")
	}
	return p.nic
}

func (p *NetworkFilterParameter) SetValue(attr string) {
	p.value = &attr
}

func (p *NetworkFilterParameter) Value() (string, bool) {
	if p.value != nil {
		return *p.value, true
	}
	var zero string
	return zero, false
}

func (p *NetworkFilterParameter) MustValue() string {
	if p.value == nil {
		panic("the value must not be nil, please use Value() function instead")
	}
	return *p.value
}

// NetworkLabel Represents a label which can be added to a host network interface and to a network.
// The label binds the network to the host network interface by the label `id`.
type NetworkLabel struct {
	Struct
	comment     *string
	description *string
	hostNic     *HostNic
	id          *string
	name        *string
	network     *Network
}

func (p *NetworkLabel) SetComment(attr string) {
	p.comment = &attr
}

func (p *NetworkLabel) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *NetworkLabel) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *NetworkLabel) SetDescription(attr string) {
	p.description = &attr
}

func (p *NetworkLabel) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *NetworkLabel) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

// SetHostNic Represents a host NIC.
//
// For example, the XML representation of a host NIC looks like this:
//
// [source,xml]
// ----
// <host_nic href="/ovirt-engine/api/hosts/123/nics/456" id="456">
//   <name>eth0</name>
//   <boot_protocol>static</boot_protocol>
//   <bridged>true</bridged>
//   <custom_configuration>true</custom_configuration>
//   <ip>
//     <address>192.168.122.39</address>
//     <gateway>192.168.122.1</gateway>
//     <netmask>255.255.255.0</netmask>
//     <version>v4</version>
//   </ip>
//   <ipv6>
//     <gateway>::</gateway>
//     <version>v6</version>
//   </ipv6>
//   <ipv6_boot_protocol>none</ipv6_boot_protocol>
//   <mac>
//     <address>52:54:00:0c:79:1d</address>
//   </mac>
//   <mtu>1500</mtu>
//   <status>up</status>
// </host_nic>
// ----
//
// A bonded interface is represented as a <<types/host_nic, HostNic>> object
// containing the `bonding` and `slaves` attributes.
//
// For example, the XML representation of a bonded host NIC looks like this:
//
// [source,xml]
// ----
// <host_nic href="/ovirt-engine/api/hosts/123/nics/456" id="456">
//   <name>bond0</name>
//   <mac address="00:00:00:00:00:00"/>
//   <ip>
//     <address>192.168.122.39</address>
//     <gateway>192.168.122.1</gateway>
//     <netmask>255.255.255.0</netmask>
//     <version>v4</version>
//   </ip>
//   <boot_protocol>dhcp</boot_protocol>
//   <bonding>
//     <options>
//       <option>
//         <name>mode</name>
//         <value>4</value>
//         <type>Dynamic link aggregation (802.3ad)</type>
//       </option>
//       <option>
//         <name>miimon</name>
//         <value>100</value>
//       </option>
//     </options>
//     <slaves>
//       <host_nic id="123"/>
//       <host_nic id="456"/>
//     </slaves>
//   </bonding>
//   <mtu>1500</mtu>
//   <bridged>true</bridged>
//   <custom_configuration>false</custom_configuration>
// </host_nic>
// ----
func (p *NetworkLabel) SetHostNic(attr *HostNic) {
	p.hostNic = attr
}

// HostNic Represents a host NIC.
//
// For example, the XML representation of a host NIC looks like this:
//
// [source,xml]
// ----
// <host_nic href="/ovirt-engine/api/hosts/123/nics/456" id="456">
//   <name>eth0</name>
//   <boot_protocol>static</boot_protocol>
//   <bridged>true</bridged>
//   <custom_configuration>true</custom_configuration>
//   <ip>
//     <address>192.168.122.39</address>
//     <gateway>192.168.122.1</gateway>
//     <netmask>255.255.255.0</netmask>
//     <version>v4</version>
//   </ip>
//   <ipv6>
//     <gateway>::</gateway>
//     <version>v6</version>
//   </ipv6>
//   <ipv6_boot_protocol>none</ipv6_boot_protocol>
//   <mac>
//     <address>52:54:00:0c:79:1d</address>
//   </mac>
//   <mtu>1500</mtu>
//   <status>up</status>
// </host_nic>
// ----
//
// A bonded interface is represented as a <<types/host_nic, HostNic>> object
// containing the `bonding` and `slaves` attributes.
//
// For example, the XML representation of a bonded host NIC looks like this:
//
// [source,xml]
// ----
// <host_nic href="/ovirt-engine/api/hosts/123/nics/456" id="456">
//   <name>bond0</name>
//   <mac address="00:00:00:00:00:00"/>
//   <ip>
//     <address>192.168.122.39</address>
//     <gateway>192.168.122.1</gateway>
//     <netmask>255.255.255.0</netmask>
//     <version>v4</version>
//   </ip>
//   <boot_protocol>dhcp</boot_protocol>
//   <bonding>
//     <options>
//       <option>
//         <name>mode</name>
//         <value>4</value>
//         <type>Dynamic link aggregation (802.3ad)</type>
//       </option>
//       <option>
//         <name>miimon</name>
//         <value>100</value>
//       </option>
//     </options>
//     <slaves>
//       <host_nic id="123"/>
//       <host_nic id="456"/>
//     </slaves>
//   </bonding>
//   <mtu>1500</mtu>
//   <bridged>true</bridged>
//   <custom_configuration>false</custom_configuration>
// </host_nic>
// ----
func (p *NetworkLabel) HostNic() (*HostNic, bool) {
	if p.hostNic != nil {
		return p.hostNic, true
	}
	return nil, false
}

// MustHostNic Represents a host NIC.
//
// For example, the XML representation of a host NIC looks like this:
//
// [source,xml]
// ----
// <host_nic href="/ovirt-engine/api/hosts/123/nics/456" id="456">
//   <name>eth0</name>
//   <boot_protocol>static</boot_protocol>
//   <bridged>true</bridged>
//   <custom_configuration>true</custom_configuration>
//   <ip>
//     <address>192.168.122.39</address>
//     <gateway>192.168.122.1</gateway>
//     <netmask>255.255.255.0</netmask>
//     <version>v4</version>
//   </ip>
//   <ipv6>
//     <gateway>::</gateway>
//     <version>v6</version>
//   </ipv6>
//   <ipv6_boot_protocol>none</ipv6_boot_protocol>
//   <mac>
//     <address>52:54:00:0c:79:1d</address>
//   </mac>
//   <mtu>1500</mtu>
//   <status>up</status>
// </host_nic>
// ----
//
// A bonded interface is represented as a <<types/host_nic, HostNic>> object
// containing the `bonding` and `slaves` attributes.
//
// For example, the XML representation of a bonded host NIC looks like this:
//
// [source,xml]
// ----
// <host_nic href="/ovirt-engine/api/hosts/123/nics/456" id="456">
//   <name>bond0</name>
//   <mac address="00:00:00:00:00:00"/>
//   <ip>
//     <address>192.168.122.39</address>
//     <gateway>192.168.122.1</gateway>
//     <netmask>255.255.255.0</netmask>
//     <version>v4</version>
//   </ip>
//   <boot_protocol>dhcp</boot_protocol>
//   <bonding>
//     <options>
//       <option>
//         <name>mode</name>
//         <value>4</value>
//         <type>Dynamic link aggregation (802.3ad)</type>
//       </option>
//       <option>
//         <name>miimon</name>
//         <value>100</value>
//       </option>
//     </options>
//     <slaves>
//       <host_nic id="123"/>
//       <host_nic id="456"/>
//     </slaves>
//   </bonding>
//   <mtu>1500</mtu>
//   <bridged>true</bridged>
//   <custom_configuration>false</custom_configuration>
// </host_nic>
// ----
func (p *NetworkLabel) MustHostNic() *HostNic {
	if p.hostNic == nil {
		panic("the hostNic must not be nil, please use HostNic() function instead")
	}
	return p.hostNic
}

func (p *NetworkLabel) SetId(attr string) {
	p.id = &attr
}

func (p *NetworkLabel) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *NetworkLabel) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *NetworkLabel) SetName(attr string) {
	p.name = &attr
}

func (p *NetworkLabel) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *NetworkLabel) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

// SetNetwork The type for a logical network.
//
// An example of the JSON representation of a logical network:
//
// [source,json]
// ----
// {
//   "network" : [ {
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "stp" : "false",
//     "mtu" : "0",
//     "usages" : {
//       "usage" : [ "vm" ]
//     },
//     "name" : "ovirtmgmt",
//     "description" : "Management Network",
//     "href" : "/ovirt-engine/api/networks/456",
//     "id" : "456",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/networks/456/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/networks/456/vnicprofiles",
//       "rel" : "vnicprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/networks/456/labels",
//       "rel" : "labels"
//     } ]
//   } ]
// }
// ----
//
// An example of the XML representation of the same logical network:
//
// [source,xml]
// ----
// <network href="/ovirt-engine/api/networks/456" id="456">
//   <name>ovirtmgmt</name>
//   <description>Management Network</description>
//   <link href="/ovirt-engine/api/networks/456/permissions" rel="permissions"/>
//   <link href="/ovirt-engine/api/networks/456/vnicprofiles" rel="vnicprofiles"/>
//   <link href="/ovirt-engine/api/networks/456/labels" rel="labels"/>
//   <data_center href="/ovirt-engine/api/datacenters/123" id="123"/>
//   <stp>false</stp>
//   <mtu>0</mtu>
//   <usages>
//     <usage>vm</usage>
//   </usages>
// </network>
// ----
func (p *NetworkLabel) SetNetwork(attr *Network) {
	p.network = attr
}

// Network The type for a logical network.
//
// An example of the JSON representation of a logical network:
//
// [source,json]
// ----
// {
//   "network" : [ {
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "stp" : "false",
//     "mtu" : "0",
//     "usages" : {
//       "usage" : [ "vm" ]
//     },
//     "name" : "ovirtmgmt",
//     "description" : "Management Network",
//     "href" : "/ovirt-engine/api/networks/456",
//     "id" : "456",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/networks/456/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/networks/456/vnicprofiles",
//       "rel" : "vnicprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/networks/456/labels",
//       "rel" : "labels"
//     } ]
//   } ]
// }
// ----
//
// An example of the XML representation of the same logical network:
//
// [source,xml]
// ----
// <network href="/ovirt-engine/api/networks/456" id="456">
//   <name>ovirtmgmt</name>
//   <description>Management Network</description>
//   <link href="/ovirt-engine/api/networks/456/permissions" rel="permissions"/>
//   <link href="/ovirt-engine/api/networks/456/vnicprofiles" rel="vnicprofiles"/>
//   <link href="/ovirt-engine/api/networks/456/labels" rel="labels"/>
//   <data_center href="/ovirt-engine/api/datacenters/123" id="123"/>
//   <stp>false</stp>
//   <mtu>0</mtu>
//   <usages>
//     <usage>vm</usage>
//   </usages>
// </network>
// ----
func (p *NetworkLabel) Network() (*Network, bool) {
	if p.network != nil {
		return p.network, true
	}
	return nil, false
}

// MustNetwork The type for a logical network.
//
// An example of the JSON representation of a logical network:
//
// [source,json]
// ----
// {
//   "network" : [ {
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "stp" : "false",
//     "mtu" : "0",
//     "usages" : {
//       "usage" : [ "vm" ]
//     },
//     "name" : "ovirtmgmt",
//     "description" : "Management Network",
//     "href" : "/ovirt-engine/api/networks/456",
//     "id" : "456",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/networks/456/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/networks/456/vnicprofiles",
//       "rel" : "vnicprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/networks/456/labels",
//       "rel" : "labels"
//     } ]
//   } ]
// }
// ----
//
// An example of the XML representation of the same logical network:
//
// [source,xml]
// ----
// <network href="/ovirt-engine/api/networks/456" id="456">
//   <name>ovirtmgmt</name>
//   <description>Management Network</description>
//   <link href="/ovirt-engine/api/networks/456/permissions" rel="permissions"/>
//   <link href="/ovirt-engine/api/networks/456/vnicprofiles" rel="vnicprofiles"/>
//   <link href="/ovirt-engine/api/networks/456/labels" rel="labels"/>
//   <data_center href="/ovirt-engine/api/datacenters/123" id="123"/>
//   <stp>false</stp>
//   <mtu>0</mtu>
//   <usages>
//     <usage>vm</usage>
//   </usages>
// </network>
// ----
func (p *NetworkLabel) MustNetwork() *Network {
	if p.network == nil {
		panic("the network must not be nil, please use Network() function instead")
	}
	return p.network
}

type NfsProfileDetail struct {
	Struct
	nfsServerIp    *string
	profileDetails *ProfileDetailSlice
}

func (p *NfsProfileDetail) SetNfsServerIp(attr string) {
	p.nfsServerIp = &attr
}

func (p *NfsProfileDetail) NfsServerIp() (string, bool) {
	if p.nfsServerIp != nil {
		return *p.nfsServerIp, true
	}
	var zero string
	return zero, false
}

func (p *NfsProfileDetail) MustNfsServerIp() string {
	if p.nfsServerIp == nil {
		panic("the nfsServerIp must not be nil, please use NfsServerIp() function instead")
	}
	return *p.nfsServerIp
}

func (p *NfsProfileDetail) SetProfileDetails(attr *ProfileDetailSlice) {
	p.profileDetails = attr
}

func (p *NfsProfileDetail) ProfileDetails() (*ProfileDetailSlice, bool) {
	if p.profileDetails != nil {
		return p.profileDetails, true
	}
	return nil, false
}

func (p *NfsProfileDetail) MustProfileDetails() *ProfileDetailSlice {
	if p.profileDetails == nil {
		panic("the profileDetails must not be nil, please use ProfileDetails() function instead")
	}
	return p.profileDetails
}

// Nic Represents a virtual machine NIC.
//
// For example, the XML representation of a NIC will look like this:
//
// [source,xml]
// ----
// <nic href="/ovirt-engine/api/vms/123/nics/456" id="456">
//   <name>nic1</name>
//   <vm href="/ovirt-engine/api/vms/123" id="123"/>
//   <interface>virtio</interface>
//   <linked>true</linked>
//   <mac>
//     <address>02:00:00:00:00:00</address>
//   </mac>
//   <plugged>true</plugged>
//   <vnic_profile href="/ovirt-engine/api/vnicprofiles/789" id="789"/>
// </nic>
// ----
type Nic struct {
	Struct
	bootProtocol                   *BootProtocol
	comment                        *string
	description                    *string
	id                             *string
	instanceType                   *InstanceType
	interface_                     *NicInterface
	linked                         *bool
	mac                            *Mac
	name                           *string
	network                        *Network
	networkAttachments             *NetworkAttachmentSlice
	networkFilterParameters        *NetworkFilterParameterSlice
	networkLabels                  *NetworkLabelSlice
	onBoot                         *bool
	plugged                        *bool
	reportedDevices                *ReportedDeviceSlice
	statistics                     *StatisticSlice
	synced                         *bool
	template                       *Template
	virtualFunctionAllowedLabels   *NetworkLabelSlice
	virtualFunctionAllowedNetworks *NetworkSlice
	vm                             *Vm
	vms                            *VmSlice
	vnicProfile                    *VnicProfile
}

// SetBootProtocol Defines the options of the IP address assignment method to a NIC.
func (p *Nic) SetBootProtocol(attr BootProtocol) {
	p.bootProtocol = &attr
}

// BootProtocol Defines the options of the IP address assignment method to a NIC.
func (p *Nic) BootProtocol() (BootProtocol, bool) {
	if p.bootProtocol != nil {
		return *p.bootProtocol, true
	}
	var zero BootProtocol
	return zero, false
}

// MustBootProtocol Defines the options of the IP address assignment method to a NIC.
func (p *Nic) MustBootProtocol() BootProtocol {
	if p.bootProtocol == nil {
		panic("the bootProtocol must not be nil, please use BootProtocol() function instead")
	}
	return *p.bootProtocol
}

func (p *Nic) SetComment(attr string) {
	p.comment = &attr
}

func (p *Nic) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *Nic) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *Nic) SetDescription(attr string) {
	p.description = &attr
}

func (p *Nic) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *Nic) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *Nic) SetId(attr string) {
	p.id = &attr
}

func (p *Nic) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *Nic) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

// SetInstanceType Describes the hardware configuration of virtual machines.
//
// For example `medium` instance type includes 1 virtual CPU and 4 GiB of memory. It is a top-level
// entity (e.g. not bound to any data center or cluster). The attributes that are used for instance
// types and are common to virtual machine and template types are:
//
// - `console`
// - `cpu`
// - `custom_cpu_model`
// - `custom_emulated_machine`
// - `display`
// - `high_availability`
// - `io`
// - `memory`
// - `memory_policy`
// - `migration`
// - `migration_downtime`
// - `os`
// - `rng_device`
// - `soundcard_enabled`
// - `usb`
// - `virtio_scsi`
//
// When creating a virtual machine from both an instance type and a template, the virtual machine
// will inherit the hardware configurations from the instance type
//
// NOTE: An instance type inherits it's attributes from the template entity although most template
// attributes are not used in instance types.
func (p *Nic) SetInstanceType(attr *InstanceType) {
	p.instanceType = attr
}

// InstanceType Describes the hardware configuration of virtual machines.
//
// For example `medium` instance type includes 1 virtual CPU and 4 GiB of memory. It is a top-level
// entity (e.g. not bound to any data center or cluster). The attributes that are used for instance
// types and are common to virtual machine and template types are:
//
// - `console`
// - `cpu`
// - `custom_cpu_model`
// - `custom_emulated_machine`
// - `display`
// - `high_availability`
// - `io`
// - `memory`
// - `memory_policy`
// - `migration`
// - `migration_downtime`
// - `os`
// - `rng_device`
// - `soundcard_enabled`
// - `usb`
// - `virtio_scsi`
//
// When creating a virtual machine from both an instance type and a template, the virtual machine
// will inherit the hardware configurations from the instance type
//
// NOTE: An instance type inherits it's attributes from the template entity although most template
// attributes are not used in instance types.
func (p *Nic) InstanceType() (*InstanceType, bool) {
	if p.instanceType != nil {
		return p.instanceType, true
	}
	return nil, false
}

// MustInstanceType Describes the hardware configuration of virtual machines.
//
// For example `medium` instance type includes 1 virtual CPU and 4 GiB of memory. It is a top-level
// entity (e.g. not bound to any data center or cluster). The attributes that are used for instance
// types and are common to virtual machine and template types are:
//
// - `console`
// - `cpu`
// - `custom_cpu_model`
// - `custom_emulated_machine`
// - `display`
// - `high_availability`
// - `io`
// - `memory`
// - `memory_policy`
// - `migration`
// - `migration_downtime`
// - `os`
// - `rng_device`
// - `soundcard_enabled`
// - `usb`
// - `virtio_scsi`
//
// When creating a virtual machine from both an instance type and a template, the virtual machine
// will inherit the hardware configurations from the instance type
//
// NOTE: An instance type inherits it's attributes from the template entity although most template
// attributes are not used in instance types.
func (p *Nic) MustInstanceType() *InstanceType {
	if p.instanceType == nil {
		panic("the instanceType must not be nil, please use InstanceType() function instead")
	}
	return p.instanceType
}

// SetInterface Defines the options for an emulated virtual network interface device model.
func (p *Nic) SetInterface(attr NicInterface) {
	p.interface_ = &attr
}

// Interface Defines the options for an emulated virtual network interface device model.
func (p *Nic) Interface() (NicInterface, bool) {
	if p.interface_ != nil {
		return *p.interface_, true
	}
	var zero NicInterface
	return zero, false
}

// MustInterface Defines the options for an emulated virtual network interface device model.
func (p *Nic) MustInterface() NicInterface {
	if p.interface_ == nil {
		panic("the interface_ must not be nil, please use Interface() function instead")
	}
	return *p.interface_
}

func (p *Nic) SetLinked(attr bool) {
	p.linked = &attr
}

func (p *Nic) Linked() (bool, bool) {
	if p.linked != nil {
		return *p.linked, true
	}
	var zero bool
	return zero, false
}

func (p *Nic) MustLinked() bool {
	if p.linked == nil {
		panic("the linked must not be nil, please use Linked() function instead")
	}
	return *p.linked
}

// SetMac Represents a MAC address of a virtual network interface.
func (p *Nic) SetMac(attr *Mac) {
	p.mac = attr
}

// Mac Represents a MAC address of a virtual network interface.
func (p *Nic) Mac() (*Mac, bool) {
	if p.mac != nil {
		return p.mac, true
	}
	return nil, false
}

// MustMac Represents a MAC address of a virtual network interface.
func (p *Nic) MustMac() *Mac {
	if p.mac == nil {
		panic("the mac must not be nil, please use Mac() function instead")
	}
	return p.mac
}

func (p *Nic) SetName(attr string) {
	p.name = &attr
}

func (p *Nic) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *Nic) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

// SetNetwork The type for a logical network.
//
// An example of the JSON representation of a logical network:
//
// [source,json]
// ----
// {
//   "network" : [ {
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "stp" : "false",
//     "mtu" : "0",
//     "usages" : {
//       "usage" : [ "vm" ]
//     },
//     "name" : "ovirtmgmt",
//     "description" : "Management Network",
//     "href" : "/ovirt-engine/api/networks/456",
//     "id" : "456",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/networks/456/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/networks/456/vnicprofiles",
//       "rel" : "vnicprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/networks/456/labels",
//       "rel" : "labels"
//     } ]
//   } ]
// }
// ----
//
// An example of the XML representation of the same logical network:
//
// [source,xml]
// ----
// <network href="/ovirt-engine/api/networks/456" id="456">
//   <name>ovirtmgmt</name>
//   <description>Management Network</description>
//   <link href="/ovirt-engine/api/networks/456/permissions" rel="permissions"/>
//   <link href="/ovirt-engine/api/networks/456/vnicprofiles" rel="vnicprofiles"/>
//   <link href="/ovirt-engine/api/networks/456/labels" rel="labels"/>
//   <data_center href="/ovirt-engine/api/datacenters/123" id="123"/>
//   <stp>false</stp>
//   <mtu>0</mtu>
//   <usages>
//     <usage>vm</usage>
//   </usages>
// </network>
// ----
func (p *Nic) SetNetwork(attr *Network) {
	p.network = attr
}

// Network The type for a logical network.
//
// An example of the JSON representation of a logical network:
//
// [source,json]
// ----
// {
//   "network" : [ {
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "stp" : "false",
//     "mtu" : "0",
//     "usages" : {
//       "usage" : [ "vm" ]
//     },
//     "name" : "ovirtmgmt",
//     "description" : "Management Network",
//     "href" : "/ovirt-engine/api/networks/456",
//     "id" : "456",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/networks/456/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/networks/456/vnicprofiles",
//       "rel" : "vnicprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/networks/456/labels",
//       "rel" : "labels"
//     } ]
//   } ]
// }
// ----
//
// An example of the XML representation of the same logical network:
//
// [source,xml]
// ----
// <network href="/ovirt-engine/api/networks/456" id="456">
//   <name>ovirtmgmt</name>
//   <description>Management Network</description>
//   <link href="/ovirt-engine/api/networks/456/permissions" rel="permissions"/>
//   <link href="/ovirt-engine/api/networks/456/vnicprofiles" rel="vnicprofiles"/>
//   <link href="/ovirt-engine/api/networks/456/labels" rel="labels"/>
//   <data_center href="/ovirt-engine/api/datacenters/123" id="123"/>
//   <stp>false</stp>
//   <mtu>0</mtu>
//   <usages>
//     <usage>vm</usage>
//   </usages>
// </network>
// ----
func (p *Nic) Network() (*Network, bool) {
	if p.network != nil {
		return p.network, true
	}
	return nil, false
}

// MustNetwork The type for a logical network.
//
// An example of the JSON representation of a logical network:
//
// [source,json]
// ----
// {
//   "network" : [ {
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "stp" : "false",
//     "mtu" : "0",
//     "usages" : {
//       "usage" : [ "vm" ]
//     },
//     "name" : "ovirtmgmt",
//     "description" : "Management Network",
//     "href" : "/ovirt-engine/api/networks/456",
//     "id" : "456",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/networks/456/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/networks/456/vnicprofiles",
//       "rel" : "vnicprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/networks/456/labels",
//       "rel" : "labels"
//     } ]
//   } ]
// }
// ----
//
// An example of the XML representation of the same logical network:
//
// [source,xml]
// ----
// <network href="/ovirt-engine/api/networks/456" id="456">
//   <name>ovirtmgmt</name>
//   <description>Management Network</description>
//   <link href="/ovirt-engine/api/networks/456/permissions" rel="permissions"/>
//   <link href="/ovirt-engine/api/networks/456/vnicprofiles" rel="vnicprofiles"/>
//   <link href="/ovirt-engine/api/networks/456/labels" rel="labels"/>
//   <data_center href="/ovirt-engine/api/datacenters/123" id="123"/>
//   <stp>false</stp>
//   <mtu>0</mtu>
//   <usages>
//     <usage>vm</usage>
//   </usages>
// </network>
// ----
func (p *Nic) MustNetwork() *Network {
	if p.network == nil {
		panic("the network must not be nil, please use Network() function instead")
	}
	return p.network
}

func (p *Nic) SetNetworkAttachments(attr *NetworkAttachmentSlice) {
	p.networkAttachments = attr
}

func (p *Nic) NetworkAttachments() (*NetworkAttachmentSlice, bool) {
	if p.networkAttachments != nil {
		return p.networkAttachments, true
	}
	return nil, false
}

func (p *Nic) MustNetworkAttachments() *NetworkAttachmentSlice {
	if p.networkAttachments == nil {
		panic("the networkAttachments must not be nil, please use NetworkAttachments() function instead")
	}
	return p.networkAttachments
}

func (p *Nic) SetNetworkFilterParameters(attr *NetworkFilterParameterSlice) {
	p.networkFilterParameters = attr
}

func (p *Nic) NetworkFilterParameters() (*NetworkFilterParameterSlice, bool) {
	if p.networkFilterParameters != nil {
		return p.networkFilterParameters, true
	}
	return nil, false
}

func (p *Nic) MustNetworkFilterParameters() *NetworkFilterParameterSlice {
	if p.networkFilterParameters == nil {
		panic("the networkFilterParameters must not be nil, please use NetworkFilterParameters() function instead")
	}
	return p.networkFilterParameters
}

func (p *Nic) SetNetworkLabels(attr *NetworkLabelSlice) {
	p.networkLabels = attr
}

func (p *Nic) NetworkLabels() (*NetworkLabelSlice, bool) {
	if p.networkLabels != nil {
		return p.networkLabels, true
	}
	return nil, false
}

func (p *Nic) MustNetworkLabels() *NetworkLabelSlice {
	if p.networkLabels == nil {
		panic("the networkLabels must not be nil, please use NetworkLabels() function instead")
	}
	return p.networkLabels
}

func (p *Nic) SetOnBoot(attr bool) {
	p.onBoot = &attr
}

func (p *Nic) OnBoot() (bool, bool) {
	if p.onBoot != nil {
		return *p.onBoot, true
	}
	var zero bool
	return zero, false
}

func (p *Nic) MustOnBoot() bool {
	if p.onBoot == nil {
		panic("the onBoot must not be nil, please use OnBoot() function instead")
	}
	return *p.onBoot
}

func (p *Nic) SetPlugged(attr bool) {
	p.plugged = &attr
}

func (p *Nic) Plugged() (bool, bool) {
	if p.plugged != nil {
		return *p.plugged, true
	}
	var zero bool
	return zero, false
}

func (p *Nic) MustPlugged() bool {
	if p.plugged == nil {
		panic("the plugged must not be nil, please use Plugged() function instead")
	}
	return *p.plugged
}

func (p *Nic) SetReportedDevices(attr *ReportedDeviceSlice) {
	p.reportedDevices = attr
}

func (p *Nic) ReportedDevices() (*ReportedDeviceSlice, bool) {
	if p.reportedDevices != nil {
		return p.reportedDevices, true
	}
	return nil, false
}

func (p *Nic) MustReportedDevices() *ReportedDeviceSlice {
	if p.reportedDevices == nil {
		panic("the reportedDevices must not be nil, please use ReportedDevices() function instead")
	}
	return p.reportedDevices
}

func (p *Nic) SetStatistics(attr *StatisticSlice) {
	p.statistics = attr
}

func (p *Nic) Statistics() (*StatisticSlice, bool) {
	if p.statistics != nil {
		return p.statistics, true
	}
	return nil, false
}

func (p *Nic) MustStatistics() *StatisticSlice {
	if p.statistics == nil {
		panic("the statistics must not be nil, please use Statistics() function instead")
	}
	return p.statistics
}

func (p *Nic) SetSynced(attr bool) {
	p.synced = &attr
}

func (p *Nic) Synced() (bool, bool) {
	if p.synced != nil {
		return *p.synced, true
	}
	var zero bool
	return zero, false
}

func (p *Nic) MustSynced() bool {
	if p.synced == nil {
		panic("the synced must not be nil, please use Synced() function instead")
	}
	return *p.synced
}

// SetTemplate The type that represents a virtual machine template.
// Templates allow for a rapid instantiation of virtual machines with common configuration and disk states.
func (p *Nic) SetTemplate(attr *Template) {
	p.template = attr
}

// Template The type that represents a virtual machine template.
// Templates allow for a rapid instantiation of virtual machines with common configuration and disk states.
func (p *Nic) Template() (*Template, bool) {
	if p.template != nil {
		return p.template, true
	}
	return nil, false
}

// MustTemplate The type that represents a virtual machine template.
// Templates allow for a rapid instantiation of virtual machines with common configuration and disk states.
func (p *Nic) MustTemplate() *Template {
	if p.template == nil {
		panic("the template must not be nil, please use Template() function instead")
	}
	return p.template
}

func (p *Nic) SetVirtualFunctionAllowedLabels(attr *NetworkLabelSlice) {
	p.virtualFunctionAllowedLabels = attr
}

func (p *Nic) VirtualFunctionAllowedLabels() (*NetworkLabelSlice, bool) {
	if p.virtualFunctionAllowedLabels != nil {
		return p.virtualFunctionAllowedLabels, true
	}
	return nil, false
}

func (p *Nic) MustVirtualFunctionAllowedLabels() *NetworkLabelSlice {
	if p.virtualFunctionAllowedLabels == nil {
		panic("the virtualFunctionAllowedLabels must not be nil, please use VirtualFunctionAllowedLabels() function instead")
	}
	return p.virtualFunctionAllowedLabels
}

func (p *Nic) SetVirtualFunctionAllowedNetworks(attr *NetworkSlice) {
	p.virtualFunctionAllowedNetworks = attr
}

func (p *Nic) VirtualFunctionAllowedNetworks() (*NetworkSlice, bool) {
	if p.virtualFunctionAllowedNetworks != nil {
		return p.virtualFunctionAllowedNetworks, true
	}
	return nil, false
}

func (p *Nic) MustVirtualFunctionAllowedNetworks() *NetworkSlice {
	if p.virtualFunctionAllowedNetworks == nil {
		panic("the virtualFunctionAllowedNetworks must not be nil, please use VirtualFunctionAllowedNetworks() function instead")
	}
	return p.virtualFunctionAllowedNetworks
}

// SetVm Represents a virtual machine.
func (p *Nic) SetVm(attr *Vm) {
	p.vm = attr
}

// Vm Represents a virtual machine.
func (p *Nic) Vm() (*Vm, bool) {
	if p.vm != nil {
		return p.vm, true
	}
	return nil, false
}

// MustVm Represents a virtual machine.
func (p *Nic) MustVm() *Vm {
	if p.vm == nil {
		panic("the vm must not be nil, please use Vm() function instead")
	}
	return p.vm
}

func (p *Nic) SetVms(attr *VmSlice) {
	p.vms = attr
}

func (p *Nic) Vms() (*VmSlice, bool) {
	if p.vms != nil {
		return p.vms, true
	}
	return nil, false
}

func (p *Nic) MustVms() *VmSlice {
	if p.vms == nil {
		panic("the vms must not be nil, please use Vms() function instead")
	}
	return p.vms
}

// SetVnicProfile A vNIC profile is a collection of settings that can be applied to individual <<types/nic,NIC>>.
func (p *Nic) SetVnicProfile(attr *VnicProfile) {
	p.vnicProfile = attr
}

// VnicProfile A vNIC profile is a collection of settings that can be applied to individual <<types/nic,NIC>>.
func (p *Nic) VnicProfile() (*VnicProfile, bool) {
	if p.vnicProfile != nil {
		return p.vnicProfile, true
	}
	return nil, false
}

// MustVnicProfile A vNIC profile is a collection of settings that can be applied to individual <<types/nic,NIC>>.
func (p *Nic) MustVnicProfile() *VnicProfile {
	if p.vnicProfile == nil {
		panic("the vnicProfile must not be nil, please use VnicProfile() function instead")
	}
	return p.vnicProfile
}

// NicConfiguration The type describes the configuration of a virtual network interface.
type NicConfiguration struct {
	Struct
	bootProtocol     *BootProtocol
	ip               *Ip
	ipv6             *Ip
	ipv6BootProtocol *BootProtocol
	name             *string
	onBoot           *bool
}

// SetBootProtocol Defines the options of the IP address assignment method to a NIC.
func (p *NicConfiguration) SetBootProtocol(attr BootProtocol) {
	p.bootProtocol = &attr
}

// BootProtocol Defines the options of the IP address assignment method to a NIC.
func (p *NicConfiguration) BootProtocol() (BootProtocol, bool) {
	if p.bootProtocol != nil {
		return *p.bootProtocol, true
	}
	var zero BootProtocol
	return zero, false
}

// MustBootProtocol Defines the options of the IP address assignment method to a NIC.
func (p *NicConfiguration) MustBootProtocol() BootProtocol {
	if p.bootProtocol == nil {
		panic("the bootProtocol must not be nil, please use BootProtocol() function instead")
	}
	return *p.bootProtocol
}

// SetIp Represents the IP configuration of a network interface.
func (p *NicConfiguration) SetIp(attr *Ip) {
	p.ip = attr
}

// Ip Represents the IP configuration of a network interface.
func (p *NicConfiguration) Ip() (*Ip, bool) {
	if p.ip != nil {
		return p.ip, true
	}
	return nil, false
}

// MustIp Represents the IP configuration of a network interface.
func (p *NicConfiguration) MustIp() *Ip {
	if p.ip == nil {
		panic("the ip must not be nil, please use Ip() function instead")
	}
	return p.ip
}

// SetIpv6 Represents the IP configuration of a network interface.
func (p *NicConfiguration) SetIpv6(attr *Ip) {
	p.ipv6 = attr
}

// Ipv6 Represents the IP configuration of a network interface.
func (p *NicConfiguration) Ipv6() (*Ip, bool) {
	if p.ipv6 != nil {
		return p.ipv6, true
	}
	return nil, false
}

// MustIpv6 Represents the IP configuration of a network interface.
func (p *NicConfiguration) MustIpv6() *Ip {
	if p.ipv6 == nil {
		panic("the ipv6 must not be nil, please use Ipv6() function instead")
	}
	return p.ipv6
}

// SetIpv6BootProtocol Defines the options of the IP address assignment method to a NIC.
func (p *NicConfiguration) SetIpv6BootProtocol(attr BootProtocol) {
	p.ipv6BootProtocol = &attr
}

// Ipv6BootProtocol Defines the options of the IP address assignment method to a NIC.
func (p *NicConfiguration) Ipv6BootProtocol() (BootProtocol, bool) {
	if p.ipv6BootProtocol != nil {
		return *p.ipv6BootProtocol, true
	}
	var zero BootProtocol
	return zero, false
}

// MustIpv6BootProtocol Defines the options of the IP address assignment method to a NIC.
func (p *NicConfiguration) MustIpv6BootProtocol() BootProtocol {
	if p.ipv6BootProtocol == nil {
		panic("the ipv6BootProtocol must not be nil, please use Ipv6BootProtocol() function instead")
	}
	return *p.ipv6BootProtocol
}

func (p *NicConfiguration) SetName(attr string) {
	p.name = &attr
}

func (p *NicConfiguration) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *NicConfiguration) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *NicConfiguration) SetOnBoot(attr bool) {
	p.onBoot = &attr
}

func (p *NicConfiguration) OnBoot() (bool, bool) {
	if p.onBoot != nil {
		return *p.onBoot, true
	}
	var zero bool
	return zero, false
}

func (p *NicConfiguration) MustOnBoot() bool {
	if p.onBoot == nil {
		panic("the onBoot must not be nil, please use OnBoot() function instead")
	}
	return *p.onBoot
}

// NumaNode Represents a physical NUMA node.
//
// Example XML representation:
//
// [source,xml]
// ----
// <host_numa_node href="/ovirt-engine/api/hosts/0923f1ea/numanodes/007cf1ab" id="007cf1ab">
//   <cpu>
//     <cores>
//       <core>
//         <index>0</index>
//       </core>
//     </cores>
//   </cpu>
//   <index>0</index>
//   <memory>65536</memory>
//   <node_distance>40 20 40 10</node_distance>
//   <host href="/ovirt-engine/api/hosts/0923f1ea" id="0923f1ea"/>
// </host_numa_node>
// ----
type NumaNode struct {
	Struct
	comment      *string
	cpu          *Cpu
	description  *string
	host         *Host
	id           *string
	index        *int64
	memory       *int64
	name         *string
	nodeDistance *string
	statistics   *StatisticSlice
}

func (p *NumaNode) SetComment(attr string) {
	p.comment = &attr
}

func (p *NumaNode) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *NumaNode) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *NumaNode) SetCpu(attr *Cpu) {
	p.cpu = attr
}

func (p *NumaNode) Cpu() (*Cpu, bool) {
	if p.cpu != nil {
		return p.cpu, true
	}
	return nil, false
}

func (p *NumaNode) MustCpu() *Cpu {
	if p.cpu == nil {
		panic("the cpu must not be nil, please use Cpu() function instead")
	}
	return p.cpu
}

func (p *NumaNode) SetDescription(attr string) {
	p.description = &attr
}

func (p *NumaNode) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *NumaNode) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

// SetHost Type representing a host.
func (p *NumaNode) SetHost(attr *Host) {
	p.host = attr
}

// Host Type representing a host.
func (p *NumaNode) Host() (*Host, bool) {
	if p.host != nil {
		return p.host, true
	}
	return nil, false
}

// MustHost Type representing a host.
func (p *NumaNode) MustHost() *Host {
	if p.host == nil {
		panic("the host must not be nil, please use Host() function instead")
	}
	return p.host
}

func (p *NumaNode) SetId(attr string) {
	p.id = &attr
}

func (p *NumaNode) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *NumaNode) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *NumaNode) SetIndex(attr int64) {
	p.index = &attr
}

func (p *NumaNode) Index() (int64, bool) {
	if p.index != nil {
		return *p.index, true
	}
	var zero int64
	return zero, false
}

func (p *NumaNode) MustIndex() int64 {
	if p.index == nil {
		panic("the index must not be nil, please use Index() function instead")
	}
	return *p.index
}

func (p *NumaNode) SetMemory(attr int64) {
	p.memory = &attr
}

func (p *NumaNode) Memory() (int64, bool) {
	if p.memory != nil {
		return *p.memory, true
	}
	var zero int64
	return zero, false
}

func (p *NumaNode) MustMemory() int64 {
	if p.memory == nil {
		panic("the memory must not be nil, please use Memory() function instead")
	}
	return *p.memory
}

func (p *NumaNode) SetName(attr string) {
	p.name = &attr
}

func (p *NumaNode) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *NumaNode) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *NumaNode) SetNodeDistance(attr string) {
	p.nodeDistance = &attr
}

func (p *NumaNode) NodeDistance() (string, bool) {
	if p.nodeDistance != nil {
		return *p.nodeDistance, true
	}
	var zero string
	return zero, false
}

func (p *NumaNode) MustNodeDistance() string {
	if p.nodeDistance == nil {
		panic("the nodeDistance must not be nil, please use NodeDistance() function instead")
	}
	return *p.nodeDistance
}

func (p *NumaNode) SetStatistics(attr *StatisticSlice) {
	p.statistics = attr
}

func (p *NumaNode) Statistics() (*StatisticSlice, bool) {
	if p.statistics != nil {
		return p.statistics, true
	}
	return nil, false
}

func (p *NumaNode) MustStatistics() *StatisticSlice {
	if p.statistics == nil {
		panic("the statistics must not be nil, please use Statistics() function instead")
	}
	return p.statistics
}

// NumaNodePin Represents the pinning of a virtual NUMA node to a physical NUMA node.
type NumaNodePin struct {
	Struct
	hostNumaNode *NumaNode
	index        *int64
	pinned       *bool
}

// SetHostNumaNode Represents a physical NUMA node.
//
// Example XML representation:
//
// [source,xml]
// ----
// <host_numa_node href="/ovirt-engine/api/hosts/0923f1ea/numanodes/007cf1ab" id="007cf1ab">
//   <cpu>
//     <cores>
//       <core>
//         <index>0</index>
//       </core>
//     </cores>
//   </cpu>
//   <index>0</index>
//   <memory>65536</memory>
//   <node_distance>40 20 40 10</node_distance>
//   <host href="/ovirt-engine/api/hosts/0923f1ea" id="0923f1ea"/>
// </host_numa_node>
// ----
func (p *NumaNodePin) SetHostNumaNode(attr *NumaNode) {
	p.hostNumaNode = attr
}

// HostNumaNode Represents a physical NUMA node.
//
// Example XML representation:
//
// [source,xml]
// ----
// <host_numa_node href="/ovirt-engine/api/hosts/0923f1ea/numanodes/007cf1ab" id="007cf1ab">
//   <cpu>
//     <cores>
//       <core>
//         <index>0</index>
//       </core>
//     </cores>
//   </cpu>
//   <index>0</index>
//   <memory>65536</memory>
//   <node_distance>40 20 40 10</node_distance>
//   <host href="/ovirt-engine/api/hosts/0923f1ea" id="0923f1ea"/>
// </host_numa_node>
// ----
func (p *NumaNodePin) HostNumaNode() (*NumaNode, bool) {
	if p.hostNumaNode != nil {
		return p.hostNumaNode, true
	}
	return nil, false
}

// MustHostNumaNode Represents a physical NUMA node.
//
// Example XML representation:
//
// [source,xml]
// ----
// <host_numa_node href="/ovirt-engine/api/hosts/0923f1ea/numanodes/007cf1ab" id="007cf1ab">
//   <cpu>
//     <cores>
//       <core>
//         <index>0</index>
//       </core>
//     </cores>
//   </cpu>
//   <index>0</index>
//   <memory>65536</memory>
//   <node_distance>40 20 40 10</node_distance>
//   <host href="/ovirt-engine/api/hosts/0923f1ea" id="0923f1ea"/>
// </host_numa_node>
// ----
func (p *NumaNodePin) MustHostNumaNode() *NumaNode {
	if p.hostNumaNode == nil {
		panic("the hostNumaNode must not be nil, please use HostNumaNode() function instead")
	}
	return p.hostNumaNode
}

func (p *NumaNodePin) SetIndex(attr int64) {
	p.index = &attr
}

func (p *NumaNodePin) Index() (int64, bool) {
	if p.index != nil {
		return *p.index, true
	}
	var zero int64
	return zero, false
}

func (p *NumaNodePin) MustIndex() int64 {
	if p.index == nil {
		panic("the index must not be nil, please use Index() function instead")
	}
	return *p.index
}

func (p *NumaNodePin) SetPinned(attr bool) {
	p.pinned = &attr
}

func (p *NumaNodePin) Pinned() (bool, bool) {
	if p.pinned != nil {
		return *p.pinned, true
	}
	var zero bool
	return zero, false
}

func (p *NumaNodePin) MustPinned() bool {
	if p.pinned == nil {
		panic("the pinned must not be nil, please use Pinned() function instead")
	}
	return *p.pinned
}

type OpenStackImage struct {
	Struct
	comment                *string
	description            *string
	id                     *string
	name                   *string
	openstackImageProvider *OpenStackImageProvider
}

func (p *OpenStackImage) SetComment(attr string) {
	p.comment = &attr
}

func (p *OpenStackImage) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *OpenStackImage) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *OpenStackImage) SetDescription(attr string) {
	p.description = &attr
}

func (p *OpenStackImage) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *OpenStackImage) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *OpenStackImage) SetId(attr string) {
	p.id = &attr
}

func (p *OpenStackImage) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *OpenStackImage) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *OpenStackImage) SetName(attr string) {
	p.name = &attr
}

func (p *OpenStackImage) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *OpenStackImage) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *OpenStackImage) SetOpenstackImageProvider(attr *OpenStackImageProvider) {
	p.openstackImageProvider = attr
}

func (p *OpenStackImage) OpenstackImageProvider() (*OpenStackImageProvider, bool) {
	if p.openstackImageProvider != nil {
		return p.openstackImageProvider, true
	}
	return nil, false
}

func (p *OpenStackImage) MustOpenstackImageProvider() *OpenStackImageProvider {
	if p.openstackImageProvider == nil {
		panic("the openstackImageProvider must not be nil, please use OpenstackImageProvider() function instead")
	}
	return p.openstackImageProvider
}

type OpenStackImageProvider struct {
	Struct
	authenticationUrl      *string
	certificates           *CertificateSlice
	comment                *string
	description            *string
	id                     *string
	images                 *OpenStackImageSlice
	name                   *string
	password               *string
	properties             *PropertySlice
	requiresAuthentication *bool
	tenantName             *string
	url                    *string
	username               *string
}

func (p *OpenStackImageProvider) SetAuthenticationUrl(attr string) {
	p.authenticationUrl = &attr
}

func (p *OpenStackImageProvider) AuthenticationUrl() (string, bool) {
	if p.authenticationUrl != nil {
		return *p.authenticationUrl, true
	}
	var zero string
	return zero, false
}

func (p *OpenStackImageProvider) MustAuthenticationUrl() string {
	if p.authenticationUrl == nil {
		panic("the authenticationUrl must not be nil, please use AuthenticationUrl() function instead")
	}
	return *p.authenticationUrl
}

func (p *OpenStackImageProvider) SetCertificates(attr *CertificateSlice) {
	p.certificates = attr
}

func (p *OpenStackImageProvider) Certificates() (*CertificateSlice, bool) {
	if p.certificates != nil {
		return p.certificates, true
	}
	return nil, false
}

func (p *OpenStackImageProvider) MustCertificates() *CertificateSlice {
	if p.certificates == nil {
		panic("the certificates must not be nil, please use Certificates() function instead")
	}
	return p.certificates
}

func (p *OpenStackImageProvider) SetComment(attr string) {
	p.comment = &attr
}

func (p *OpenStackImageProvider) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *OpenStackImageProvider) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *OpenStackImageProvider) SetDescription(attr string) {
	p.description = &attr
}

func (p *OpenStackImageProvider) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *OpenStackImageProvider) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *OpenStackImageProvider) SetId(attr string) {
	p.id = &attr
}

func (p *OpenStackImageProvider) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *OpenStackImageProvider) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *OpenStackImageProvider) SetImages(attr *OpenStackImageSlice) {
	p.images = attr
}

func (p *OpenStackImageProvider) Images() (*OpenStackImageSlice, bool) {
	if p.images != nil {
		return p.images, true
	}
	return nil, false
}

func (p *OpenStackImageProvider) MustImages() *OpenStackImageSlice {
	if p.images == nil {
		panic("the images must not be nil, please use Images() function instead")
	}
	return p.images
}

func (p *OpenStackImageProvider) SetName(attr string) {
	p.name = &attr
}

func (p *OpenStackImageProvider) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *OpenStackImageProvider) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *OpenStackImageProvider) SetPassword(attr string) {
	p.password = &attr
}

func (p *OpenStackImageProvider) Password() (string, bool) {
	if p.password != nil {
		return *p.password, true
	}
	var zero string
	return zero, false
}

func (p *OpenStackImageProvider) MustPassword() string {
	if p.password == nil {
		panic("the password must not be nil, please use Password() function instead")
	}
	return *p.password
}

func (p *OpenStackImageProvider) SetProperties(attr *PropertySlice) {
	p.properties = attr
}

func (p *OpenStackImageProvider) Properties() (*PropertySlice, bool) {
	if p.properties != nil {
		return p.properties, true
	}
	return nil, false
}

func (p *OpenStackImageProvider) MustProperties() *PropertySlice {
	if p.properties == nil {
		panic("the properties must not be nil, please use Properties() function instead")
	}
	return p.properties
}

func (p *OpenStackImageProvider) SetRequiresAuthentication(attr bool) {
	p.requiresAuthentication = &attr
}

func (p *OpenStackImageProvider) RequiresAuthentication() (bool, bool) {
	if p.requiresAuthentication != nil {
		return *p.requiresAuthentication, true
	}
	var zero bool
	return zero, false
}

func (p *OpenStackImageProvider) MustRequiresAuthentication() bool {
	if p.requiresAuthentication == nil {
		panic("the requiresAuthentication must not be nil, please use RequiresAuthentication() function instead")
	}
	return *p.requiresAuthentication
}

func (p *OpenStackImageProvider) SetTenantName(attr string) {
	p.tenantName = &attr
}

func (p *OpenStackImageProvider) TenantName() (string, bool) {
	if p.tenantName != nil {
		return *p.tenantName, true
	}
	var zero string
	return zero, false
}

func (p *OpenStackImageProvider) MustTenantName() string {
	if p.tenantName == nil {
		panic("the tenantName must not be nil, please use TenantName() function instead")
	}
	return *p.tenantName
}

func (p *OpenStackImageProvider) SetUrl(attr string) {
	p.url = &attr
}

func (p *OpenStackImageProvider) Url() (string, bool) {
	if p.url != nil {
		return *p.url, true
	}
	var zero string
	return zero, false
}

func (p *OpenStackImageProvider) MustUrl() string {
	if p.url == nil {
		panic("the url must not be nil, please use Url() function instead")
	}
	return *p.url
}

func (p *OpenStackImageProvider) SetUsername(attr string) {
	p.username = &attr
}

func (p *OpenStackImageProvider) Username() (string, bool) {
	if p.username != nil {
		return *p.username, true
	}
	var zero string
	return zero, false
}

func (p *OpenStackImageProvider) MustUsername() string {
	if p.username == nil {
		panic("the username must not be nil, please use Username() function instead")
	}
	return *p.username
}

type OpenStackNetwork struct {
	Struct
	comment                  *string
	description              *string
	id                       *string
	name                     *string
	openstackNetworkProvider *OpenStackNetworkProvider
}

func (p *OpenStackNetwork) SetComment(attr string) {
	p.comment = &attr
}

func (p *OpenStackNetwork) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *OpenStackNetwork) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *OpenStackNetwork) SetDescription(attr string) {
	p.description = &attr
}

func (p *OpenStackNetwork) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *OpenStackNetwork) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *OpenStackNetwork) SetId(attr string) {
	p.id = &attr
}

func (p *OpenStackNetwork) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *OpenStackNetwork) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *OpenStackNetwork) SetName(attr string) {
	p.name = &attr
}

func (p *OpenStackNetwork) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *OpenStackNetwork) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *OpenStackNetwork) SetOpenstackNetworkProvider(attr *OpenStackNetworkProvider) {
	p.openstackNetworkProvider = attr
}

func (p *OpenStackNetwork) OpenstackNetworkProvider() (*OpenStackNetworkProvider, bool) {
	if p.openstackNetworkProvider != nil {
		return p.openstackNetworkProvider, true
	}
	return nil, false
}

func (p *OpenStackNetwork) MustOpenstackNetworkProvider() *OpenStackNetworkProvider {
	if p.openstackNetworkProvider == nil {
		panic("the openstackNetworkProvider must not be nil, please use OpenstackNetworkProvider() function instead")
	}
	return p.openstackNetworkProvider
}

type OpenStackNetworkProvider struct {
	Struct
	agentConfiguration     *AgentConfiguration
	authenticationUrl      *string
	autoSync               *bool
	certificates           *CertificateSlice
	comment                *string
	description            *string
	externalPluginType     *string
	id                     *string
	name                   *string
	networks               *OpenStackNetworkSlice
	password               *string
	pluginType             *NetworkPluginType
	projectDomainName      *string
	projectName            *string
	properties             *PropertySlice
	readOnly               *bool
	requiresAuthentication *bool
	subnets                *OpenStackSubnetSlice
	tenantName             *string
	type_                  *OpenStackNetworkProviderType
	unmanaged              *bool
	url                    *string
	userDomainName         *string
	username               *string
}

// SetAgentConfiguration Deprecated Agent configuration settings.
//
// Ignored, because the deployment of OpenStack Neutron agent is dropped since {product-name} 4.4.0.
// The deployment of OpenStack hosts can be done by Red Hat OpenStack Platform Director or TripleO.
func (p *OpenStackNetworkProvider) SetAgentConfiguration(attr *AgentConfiguration) {
	p.agentConfiguration = attr
}

// AgentConfiguration Deprecated Agent configuration settings.
//
// Ignored, because the deployment of OpenStack Neutron agent is dropped since {product-name} 4.4.0.
// The deployment of OpenStack hosts can be done by Red Hat OpenStack Platform Director or TripleO.
func (p *OpenStackNetworkProvider) AgentConfiguration() (*AgentConfiguration, bool) {
	if p.agentConfiguration != nil {
		return p.agentConfiguration, true
	}
	return nil, false
}

// MustAgentConfiguration Deprecated Agent configuration settings.
//
// Ignored, because the deployment of OpenStack Neutron agent is dropped since {product-name} 4.4.0.
// The deployment of OpenStack hosts can be done by Red Hat OpenStack Platform Director or TripleO.
func (p *OpenStackNetworkProvider) MustAgentConfiguration() *AgentConfiguration {
	if p.agentConfiguration == nil {
		panic("the agentConfiguration must not be nil, please use AgentConfiguration() function instead")
	}
	return p.agentConfiguration
}

func (p *OpenStackNetworkProvider) SetAuthenticationUrl(attr string) {
	p.authenticationUrl = &attr
}

func (p *OpenStackNetworkProvider) AuthenticationUrl() (string, bool) {
	if p.authenticationUrl != nil {
		return *p.authenticationUrl, true
	}
	var zero string
	return zero, false
}

func (p *OpenStackNetworkProvider) MustAuthenticationUrl() string {
	if p.authenticationUrl == nil {
		panic("the authenticationUrl must not be nil, please use AuthenticationUrl() function instead")
	}
	return *p.authenticationUrl
}

func (p *OpenStackNetworkProvider) SetAutoSync(attr bool) {
	p.autoSync = &attr
}

func (p *OpenStackNetworkProvider) AutoSync() (bool, bool) {
	if p.autoSync != nil {
		return *p.autoSync, true
	}
	var zero bool
	return zero, false
}

func (p *OpenStackNetworkProvider) MustAutoSync() bool {
	if p.autoSync == nil {
		panic("the autoSync must not be nil, please use AutoSync() function instead")
	}
	return *p.autoSync
}

func (p *OpenStackNetworkProvider) SetCertificates(attr *CertificateSlice) {
	p.certificates = attr
}

func (p *OpenStackNetworkProvider) Certificates() (*CertificateSlice, bool) {
	if p.certificates != nil {
		return p.certificates, true
	}
	return nil, false
}

func (p *OpenStackNetworkProvider) MustCertificates() *CertificateSlice {
	if p.certificates == nil {
		panic("the certificates must not be nil, please use Certificates() function instead")
	}
	return p.certificates
}

func (p *OpenStackNetworkProvider) SetComment(attr string) {
	p.comment = &attr
}

func (p *OpenStackNetworkProvider) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *OpenStackNetworkProvider) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *OpenStackNetworkProvider) SetDescription(attr string) {
	p.description = &attr
}

func (p *OpenStackNetworkProvider) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *OpenStackNetworkProvider) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *OpenStackNetworkProvider) SetExternalPluginType(attr string) {
	p.externalPluginType = &attr
}

func (p *OpenStackNetworkProvider) ExternalPluginType() (string, bool) {
	if p.externalPluginType != nil {
		return *p.externalPluginType, true
	}
	var zero string
	return zero, false
}

func (p *OpenStackNetworkProvider) MustExternalPluginType() string {
	if p.externalPluginType == nil {
		panic("the externalPluginType must not be nil, please use ExternalPluginType() function instead")
	}
	return *p.externalPluginType
}

func (p *OpenStackNetworkProvider) SetId(attr string) {
	p.id = &attr
}

func (p *OpenStackNetworkProvider) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *OpenStackNetworkProvider) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *OpenStackNetworkProvider) SetName(attr string) {
	p.name = &attr
}

func (p *OpenStackNetworkProvider) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *OpenStackNetworkProvider) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *OpenStackNetworkProvider) SetNetworks(attr *OpenStackNetworkSlice) {
	p.networks = attr
}

func (p *OpenStackNetworkProvider) Networks() (*OpenStackNetworkSlice, bool) {
	if p.networks != nil {
		return p.networks, true
	}
	return nil, false
}

func (p *OpenStackNetworkProvider) MustNetworks() *OpenStackNetworkSlice {
	if p.networks == nil {
		panic("the networks must not be nil, please use Networks() function instead")
	}
	return p.networks
}

func (p *OpenStackNetworkProvider) SetPassword(attr string) {
	p.password = &attr
}

func (p *OpenStackNetworkProvider) Password() (string, bool) {
	if p.password != nil {
		return *p.password, true
	}
	var zero string
	return zero, false
}

func (p *OpenStackNetworkProvider) MustPassword() string {
	if p.password == nil {
		panic("the password must not be nil, please use Password() function instead")
	}
	return *p.password
}

// SetPluginType Network plug-in type.
//
// Specifies the provider driver implementation on the host.
//
// Since version 4.2 of the {engine-name}, this type has been deprecated in favour of the `external_plugin_type`
// attribute of the `OpenStackNetworkProvider` type.
func (p *OpenStackNetworkProvider) SetPluginType(attr NetworkPluginType) {
	p.pluginType = &attr
}

// PluginType Network plug-in type.
//
// Specifies the provider driver implementation on the host.
//
// Since version 4.2 of the {engine-name}, this type has been deprecated in favour of the `external_plugin_type`
// attribute of the `OpenStackNetworkProvider` type.
func (p *OpenStackNetworkProvider) PluginType() (NetworkPluginType, bool) {
	if p.pluginType != nil {
		return *p.pluginType, true
	}
	var zero NetworkPluginType
	return zero, false
}

// MustPluginType Network plug-in type.
//
// Specifies the provider driver implementation on the host.
//
// Since version 4.2 of the {engine-name}, this type has been deprecated in favour of the `external_plugin_type`
// attribute of the `OpenStackNetworkProvider` type.
func (p *OpenStackNetworkProvider) MustPluginType() NetworkPluginType {
	if p.pluginType == nil {
		panic("the pluginType must not be nil, please use PluginType() function instead")
	}
	return *p.pluginType
}

func (p *OpenStackNetworkProvider) SetProjectDomainName(attr string) {
	p.projectDomainName = &attr
}

func (p *OpenStackNetworkProvider) ProjectDomainName() (string, bool) {
	if p.projectDomainName != nil {
		return *p.projectDomainName, true
	}
	var zero string
	return zero, false
}

func (p *OpenStackNetworkProvider) MustProjectDomainName() string {
	if p.projectDomainName == nil {
		panic("the projectDomainName must not be nil, please use ProjectDomainName() function instead")
	}
	return *p.projectDomainName
}

func (p *OpenStackNetworkProvider) SetProjectName(attr string) {
	p.projectName = &attr
}

func (p *OpenStackNetworkProvider) ProjectName() (string, bool) {
	if p.projectName != nil {
		return *p.projectName, true
	}
	var zero string
	return zero, false
}

func (p *OpenStackNetworkProvider) MustProjectName() string {
	if p.projectName == nil {
		panic("the projectName must not be nil, please use ProjectName() function instead")
	}
	return *p.projectName
}

func (p *OpenStackNetworkProvider) SetProperties(attr *PropertySlice) {
	p.properties = attr
}

func (p *OpenStackNetworkProvider) Properties() (*PropertySlice, bool) {
	if p.properties != nil {
		return p.properties, true
	}
	return nil, false
}

func (p *OpenStackNetworkProvider) MustProperties() *PropertySlice {
	if p.properties == nil {
		panic("the properties must not be nil, please use Properties() function instead")
	}
	return p.properties
}

func (p *OpenStackNetworkProvider) SetReadOnly(attr bool) {
	p.readOnly = &attr
}

func (p *OpenStackNetworkProvider) ReadOnly() (bool, bool) {
	if p.readOnly != nil {
		return *p.readOnly, true
	}
	var zero bool
	return zero, false
}

func (p *OpenStackNetworkProvider) MustReadOnly() bool {
	if p.readOnly == nil {
		panic("the readOnly must not be nil, please use ReadOnly() function instead")
	}
	return *p.readOnly
}

func (p *OpenStackNetworkProvider) SetRequiresAuthentication(attr bool) {
	p.requiresAuthentication = &attr
}

func (p *OpenStackNetworkProvider) RequiresAuthentication() (bool, bool) {
	if p.requiresAuthentication != nil {
		return *p.requiresAuthentication, true
	}
	var zero bool
	return zero, false
}

func (p *OpenStackNetworkProvider) MustRequiresAuthentication() bool {
	if p.requiresAuthentication == nil {
		panic("the requiresAuthentication must not be nil, please use RequiresAuthentication() function instead")
	}
	return *p.requiresAuthentication
}

func (p *OpenStackNetworkProvider) SetSubnets(attr *OpenStackSubnetSlice) {
	p.subnets = attr
}

func (p *OpenStackNetworkProvider) Subnets() (*OpenStackSubnetSlice, bool) {
	if p.subnets != nil {
		return p.subnets, true
	}
	return nil, false
}

func (p *OpenStackNetworkProvider) MustSubnets() *OpenStackSubnetSlice {
	if p.subnets == nil {
		panic("the subnets must not be nil, please use Subnets() function instead")
	}
	return p.subnets
}

func (p *OpenStackNetworkProvider) SetTenantName(attr string) {
	p.tenantName = &attr
}

func (p *OpenStackNetworkProvider) TenantName() (string, bool) {
	if p.tenantName != nil {
		return *p.tenantName, true
	}
	var zero string
	return zero, false
}

func (p *OpenStackNetworkProvider) MustTenantName() string {
	if p.tenantName == nil {
		panic("the tenantName must not be nil, please use TenantName() function instead")
	}
	return *p.tenantName
}

// SetType The OpenStack network provider can either be implemented by OpenStack Neutron, in which case the Neutron
// agent is automatically installed on the hosts, or it can be an external provider implementing the
// OpenStack API, in which case the virtual interface driver is a custom solution installed manually.
func (p *OpenStackNetworkProvider) SetType(attr OpenStackNetworkProviderType) {
	p.type_ = &attr
}

// Type The OpenStack network provider can either be implemented by OpenStack Neutron, in which case the Neutron
// agent is automatically installed on the hosts, or it can be an external provider implementing the
// OpenStack API, in which case the virtual interface driver is a custom solution installed manually.
func (p *OpenStackNetworkProvider) Type() (OpenStackNetworkProviderType, bool) {
	if p.type_ != nil {
		return *p.type_, true
	}
	var zero OpenStackNetworkProviderType
	return zero, false
}

// MustType The OpenStack network provider can either be implemented by OpenStack Neutron, in which case the Neutron
// agent is automatically installed on the hosts, or it can be an external provider implementing the
// OpenStack API, in which case the virtual interface driver is a custom solution installed manually.
func (p *OpenStackNetworkProvider) MustType() OpenStackNetworkProviderType {
	if p.type_ == nil {
		panic("the type_ must not be nil, please use Type() function instead")
	}
	return *p.type_
}

func (p *OpenStackNetworkProvider) SetUnmanaged(attr bool) {
	p.unmanaged = &attr
}

func (p *OpenStackNetworkProvider) Unmanaged() (bool, bool) {
	if p.unmanaged != nil {
		return *p.unmanaged, true
	}
	var zero bool
	return zero, false
}

func (p *OpenStackNetworkProvider) MustUnmanaged() bool {
	if p.unmanaged == nil {
		panic("the unmanaged must not be nil, please use Unmanaged() function instead")
	}
	return *p.unmanaged
}

func (p *OpenStackNetworkProvider) SetUrl(attr string) {
	p.url = &attr
}

func (p *OpenStackNetworkProvider) Url() (string, bool) {
	if p.url != nil {
		return *p.url, true
	}
	var zero string
	return zero, false
}

func (p *OpenStackNetworkProvider) MustUrl() string {
	if p.url == nil {
		panic("the url must not be nil, please use Url() function instead")
	}
	return *p.url
}

func (p *OpenStackNetworkProvider) SetUserDomainName(attr string) {
	p.userDomainName = &attr
}

func (p *OpenStackNetworkProvider) UserDomainName() (string, bool) {
	if p.userDomainName != nil {
		return *p.userDomainName, true
	}
	var zero string
	return zero, false
}

func (p *OpenStackNetworkProvider) MustUserDomainName() string {
	if p.userDomainName == nil {
		panic("the userDomainName must not be nil, please use UserDomainName() function instead")
	}
	return *p.userDomainName
}

func (p *OpenStackNetworkProvider) SetUsername(attr string) {
	p.username = &attr
}

func (p *OpenStackNetworkProvider) Username() (string, bool) {
	if p.username != nil {
		return *p.username, true
	}
	var zero string
	return zero, false
}

func (p *OpenStackNetworkProvider) MustUsername() string {
	if p.username == nil {
		panic("the username must not be nil, please use Username() function instead")
	}
	return *p.username
}

type OpenStackProvider struct {
	Struct
	authenticationUrl      *string
	comment                *string
	description            *string
	id                     *string
	name                   *string
	password               *string
	properties             *PropertySlice
	requiresAuthentication *bool
	tenantName             *string
	url                    *string
	username               *string
}

func (p *OpenStackProvider) SetAuthenticationUrl(attr string) {
	p.authenticationUrl = &attr
}

func (p *OpenStackProvider) AuthenticationUrl() (string, bool) {
	if p.authenticationUrl != nil {
		return *p.authenticationUrl, true
	}
	var zero string
	return zero, false
}

func (p *OpenStackProvider) MustAuthenticationUrl() string {
	if p.authenticationUrl == nil {
		panic("the authenticationUrl must not be nil, please use AuthenticationUrl() function instead")
	}
	return *p.authenticationUrl
}

func (p *OpenStackProvider) SetComment(attr string) {
	p.comment = &attr
}

func (p *OpenStackProvider) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *OpenStackProvider) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *OpenStackProvider) SetDescription(attr string) {
	p.description = &attr
}

func (p *OpenStackProvider) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *OpenStackProvider) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *OpenStackProvider) SetId(attr string) {
	p.id = &attr
}

func (p *OpenStackProvider) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *OpenStackProvider) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *OpenStackProvider) SetName(attr string) {
	p.name = &attr
}

func (p *OpenStackProvider) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *OpenStackProvider) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *OpenStackProvider) SetPassword(attr string) {
	p.password = &attr
}

func (p *OpenStackProvider) Password() (string, bool) {
	if p.password != nil {
		return *p.password, true
	}
	var zero string
	return zero, false
}

func (p *OpenStackProvider) MustPassword() string {
	if p.password == nil {
		panic("the password must not be nil, please use Password() function instead")
	}
	return *p.password
}

func (p *OpenStackProvider) SetProperties(attr *PropertySlice) {
	p.properties = attr
}

func (p *OpenStackProvider) Properties() (*PropertySlice, bool) {
	if p.properties != nil {
		return p.properties, true
	}
	return nil, false
}

func (p *OpenStackProvider) MustProperties() *PropertySlice {
	if p.properties == nil {
		panic("the properties must not be nil, please use Properties() function instead")
	}
	return p.properties
}

func (p *OpenStackProvider) SetRequiresAuthentication(attr bool) {
	p.requiresAuthentication = &attr
}

func (p *OpenStackProvider) RequiresAuthentication() (bool, bool) {
	if p.requiresAuthentication != nil {
		return *p.requiresAuthentication, true
	}
	var zero bool
	return zero, false
}

func (p *OpenStackProvider) MustRequiresAuthentication() bool {
	if p.requiresAuthentication == nil {
		panic("the requiresAuthentication must not be nil, please use RequiresAuthentication() function instead")
	}
	return *p.requiresAuthentication
}

func (p *OpenStackProvider) SetTenantName(attr string) {
	p.tenantName = &attr
}

func (p *OpenStackProvider) TenantName() (string, bool) {
	if p.tenantName != nil {
		return *p.tenantName, true
	}
	var zero string
	return zero, false
}

func (p *OpenStackProvider) MustTenantName() string {
	if p.tenantName == nil {
		panic("the tenantName must not be nil, please use TenantName() function instead")
	}
	return *p.tenantName
}

func (p *OpenStackProvider) SetUrl(attr string) {
	p.url = &attr
}

func (p *OpenStackProvider) Url() (string, bool) {
	if p.url != nil {
		return *p.url, true
	}
	var zero string
	return zero, false
}

func (p *OpenStackProvider) MustUrl() string {
	if p.url == nil {
		panic("the url must not be nil, please use Url() function instead")
	}
	return *p.url
}

func (p *OpenStackProvider) SetUsername(attr string) {
	p.username = &attr
}

func (p *OpenStackProvider) Username() (string, bool) {
	if p.username != nil {
		return *p.username, true
	}
	var zero string
	return zero, false
}

func (p *OpenStackProvider) MustUsername() string {
	if p.username == nil {
		panic("the username must not be nil, please use Username() function instead")
	}
	return *p.username
}

type OpenStackSubnet struct {
	Struct
	cidr             *string
	comment          *string
	description      *string
	dnsServers       []string
	gateway          *string
	id               *string
	ipVersion        *string
	name             *string
	openstackNetwork *OpenStackNetwork
}

func (p *OpenStackSubnet) SetCidr(attr string) {
	p.cidr = &attr
}

func (p *OpenStackSubnet) Cidr() (string, bool) {
	if p.cidr != nil {
		return *p.cidr, true
	}
	var zero string
	return zero, false
}

func (p *OpenStackSubnet) MustCidr() string {
	if p.cidr == nil {
		panic("the cidr must not be nil, please use Cidr() function instead")
	}
	return *p.cidr
}

func (p *OpenStackSubnet) SetComment(attr string) {
	p.comment = &attr
}

func (p *OpenStackSubnet) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *OpenStackSubnet) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *OpenStackSubnet) SetDescription(attr string) {
	p.description = &attr
}

func (p *OpenStackSubnet) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *OpenStackSubnet) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *OpenStackSubnet) SetDnsServers(attr []string) {
	p.dnsServers = attr
}

func (p *OpenStackSubnet) DnsServers() ([]string, bool) {
	if p.dnsServers != nil {
		return p.dnsServers, true
	}
	return nil, false
}

func (p *OpenStackSubnet) MustDnsServers() []string {
	if p.dnsServers == nil {
		panic("the dnsServers must not be nil, please use DnsServers() function instead")
	}
	return p.dnsServers
}

func (p *OpenStackSubnet) SetGateway(attr string) {
	p.gateway = &attr
}

func (p *OpenStackSubnet) Gateway() (string, bool) {
	if p.gateway != nil {
		return *p.gateway, true
	}
	var zero string
	return zero, false
}

func (p *OpenStackSubnet) MustGateway() string {
	if p.gateway == nil {
		panic("the gateway must not be nil, please use Gateway() function instead")
	}
	return *p.gateway
}

func (p *OpenStackSubnet) SetId(attr string) {
	p.id = &attr
}

func (p *OpenStackSubnet) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *OpenStackSubnet) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *OpenStackSubnet) SetIpVersion(attr string) {
	p.ipVersion = &attr
}

func (p *OpenStackSubnet) IpVersion() (string, bool) {
	if p.ipVersion != nil {
		return *p.ipVersion, true
	}
	var zero string
	return zero, false
}

func (p *OpenStackSubnet) MustIpVersion() string {
	if p.ipVersion == nil {
		panic("the ipVersion must not be nil, please use IpVersion() function instead")
	}
	return *p.ipVersion
}

func (p *OpenStackSubnet) SetName(attr string) {
	p.name = &attr
}

func (p *OpenStackSubnet) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *OpenStackSubnet) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *OpenStackSubnet) SetOpenstackNetwork(attr *OpenStackNetwork) {
	p.openstackNetwork = attr
}

func (p *OpenStackSubnet) OpenstackNetwork() (*OpenStackNetwork, bool) {
	if p.openstackNetwork != nil {
		return p.openstackNetwork, true
	}
	return nil, false
}

func (p *OpenStackSubnet) MustOpenstackNetwork() *OpenStackNetwork {
	if p.openstackNetwork == nil {
		panic("the openstackNetwork must not be nil, please use OpenstackNetwork() function instead")
	}
	return p.openstackNetwork
}

type OpenStackVolumeProvider struct {
	Struct
	authenticationKeys     *OpenstackVolumeAuthenticationKeySlice
	authenticationUrl      *string
	certificates           *CertificateSlice
	comment                *string
	dataCenter             *DataCenter
	description            *string
	id                     *string
	name                   *string
	password               *string
	properties             *PropertySlice
	requiresAuthentication *bool
	tenantName             *string
	url                    *string
	username               *string
	volumeTypes            *OpenStackVolumeTypeSlice
}

func (p *OpenStackVolumeProvider) SetAuthenticationKeys(attr *OpenstackVolumeAuthenticationKeySlice) {
	p.authenticationKeys = attr
}

func (p *OpenStackVolumeProvider) AuthenticationKeys() (*OpenstackVolumeAuthenticationKeySlice, bool) {
	if p.authenticationKeys != nil {
		return p.authenticationKeys, true
	}
	return nil, false
}

func (p *OpenStackVolumeProvider) MustAuthenticationKeys() *OpenstackVolumeAuthenticationKeySlice {
	if p.authenticationKeys == nil {
		panic("the authenticationKeys must not be nil, please use AuthenticationKeys() function instead")
	}
	return p.authenticationKeys
}

func (p *OpenStackVolumeProvider) SetAuthenticationUrl(attr string) {
	p.authenticationUrl = &attr
}

func (p *OpenStackVolumeProvider) AuthenticationUrl() (string, bool) {
	if p.authenticationUrl != nil {
		return *p.authenticationUrl, true
	}
	var zero string
	return zero, false
}

func (p *OpenStackVolumeProvider) MustAuthenticationUrl() string {
	if p.authenticationUrl == nil {
		panic("the authenticationUrl must not be nil, please use AuthenticationUrl() function instead")
	}
	return *p.authenticationUrl
}

func (p *OpenStackVolumeProvider) SetCertificates(attr *CertificateSlice) {
	p.certificates = attr
}

func (p *OpenStackVolumeProvider) Certificates() (*CertificateSlice, bool) {
	if p.certificates != nil {
		return p.certificates, true
	}
	return nil, false
}

func (p *OpenStackVolumeProvider) MustCertificates() *CertificateSlice {
	if p.certificates == nil {
		panic("the certificates must not be nil, please use Certificates() function instead")
	}
	return p.certificates
}

func (p *OpenStackVolumeProvider) SetComment(attr string) {
	p.comment = &attr
}

func (p *OpenStackVolumeProvider) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *OpenStackVolumeProvider) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *OpenStackVolumeProvider) SetDataCenter(attr *DataCenter) {
	p.dataCenter = attr
}

func (p *OpenStackVolumeProvider) DataCenter() (*DataCenter, bool) {
	if p.dataCenter != nil {
		return p.dataCenter, true
	}
	return nil, false
}

func (p *OpenStackVolumeProvider) MustDataCenter() *DataCenter {
	if p.dataCenter == nil {
		panic("the dataCenter must not be nil, please use DataCenter() function instead")
	}
	return p.dataCenter
}

func (p *OpenStackVolumeProvider) SetDescription(attr string) {
	p.description = &attr
}

func (p *OpenStackVolumeProvider) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *OpenStackVolumeProvider) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *OpenStackVolumeProvider) SetId(attr string) {
	p.id = &attr
}

func (p *OpenStackVolumeProvider) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *OpenStackVolumeProvider) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *OpenStackVolumeProvider) SetName(attr string) {
	p.name = &attr
}

func (p *OpenStackVolumeProvider) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *OpenStackVolumeProvider) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *OpenStackVolumeProvider) SetPassword(attr string) {
	p.password = &attr
}

func (p *OpenStackVolumeProvider) Password() (string, bool) {
	if p.password != nil {
		return *p.password, true
	}
	var zero string
	return zero, false
}

func (p *OpenStackVolumeProvider) MustPassword() string {
	if p.password == nil {
		panic("the password must not be nil, please use Password() function instead")
	}
	return *p.password
}

func (p *OpenStackVolumeProvider) SetProperties(attr *PropertySlice) {
	p.properties = attr
}

func (p *OpenStackVolumeProvider) Properties() (*PropertySlice, bool) {
	if p.properties != nil {
		return p.properties, true
	}
	return nil, false
}

func (p *OpenStackVolumeProvider) MustProperties() *PropertySlice {
	if p.properties == nil {
		panic("the properties must not be nil, please use Properties() function instead")
	}
	return p.properties
}

func (p *OpenStackVolumeProvider) SetRequiresAuthentication(attr bool) {
	p.requiresAuthentication = &attr
}

func (p *OpenStackVolumeProvider) RequiresAuthentication() (bool, bool) {
	if p.requiresAuthentication != nil {
		return *p.requiresAuthentication, true
	}
	var zero bool
	return zero, false
}

func (p *OpenStackVolumeProvider) MustRequiresAuthentication() bool {
	if p.requiresAuthentication == nil {
		panic("the requiresAuthentication must not be nil, please use RequiresAuthentication() function instead")
	}
	return *p.requiresAuthentication
}

func (p *OpenStackVolumeProvider) SetTenantName(attr string) {
	p.tenantName = &attr
}

func (p *OpenStackVolumeProvider) TenantName() (string, bool) {
	if p.tenantName != nil {
		return *p.tenantName, true
	}
	var zero string
	return zero, false
}

func (p *OpenStackVolumeProvider) MustTenantName() string {
	if p.tenantName == nil {
		panic("the tenantName must not be nil, please use TenantName() function instead")
	}
	return *p.tenantName
}

func (p *OpenStackVolumeProvider) SetUrl(attr string) {
	p.url = &attr
}

func (p *OpenStackVolumeProvider) Url() (string, bool) {
	if p.url != nil {
		return *p.url, true
	}
	var zero string
	return zero, false
}

func (p *OpenStackVolumeProvider) MustUrl() string {
	if p.url == nil {
		panic("the url must not be nil, please use Url() function instead")
	}
	return *p.url
}

func (p *OpenStackVolumeProvider) SetUsername(attr string) {
	p.username = &attr
}

func (p *OpenStackVolumeProvider) Username() (string, bool) {
	if p.username != nil {
		return *p.username, true
	}
	var zero string
	return zero, false
}

func (p *OpenStackVolumeProvider) MustUsername() string {
	if p.username == nil {
		panic("the username must not be nil, please use Username() function instead")
	}
	return *p.username
}

func (p *OpenStackVolumeProvider) SetVolumeTypes(attr *OpenStackVolumeTypeSlice) {
	p.volumeTypes = attr
}

func (p *OpenStackVolumeProvider) VolumeTypes() (*OpenStackVolumeTypeSlice, bool) {
	if p.volumeTypes != nil {
		return p.volumeTypes, true
	}
	return nil, false
}

func (p *OpenStackVolumeProvider) MustVolumeTypes() *OpenStackVolumeTypeSlice {
	if p.volumeTypes == nil {
		panic("the volumeTypes must not be nil, please use VolumeTypes() function instead")
	}
	return p.volumeTypes
}

type OpenStackVolumeType struct {
	Struct
	comment                 *string
	description             *string
	id                      *string
	name                    *string
	openstackVolumeProvider *OpenStackVolumeProvider
	properties              *PropertySlice
}

func (p *OpenStackVolumeType) SetComment(attr string) {
	p.comment = &attr
}

func (p *OpenStackVolumeType) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *OpenStackVolumeType) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *OpenStackVolumeType) SetDescription(attr string) {
	p.description = &attr
}

func (p *OpenStackVolumeType) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *OpenStackVolumeType) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *OpenStackVolumeType) SetId(attr string) {
	p.id = &attr
}

func (p *OpenStackVolumeType) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *OpenStackVolumeType) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *OpenStackVolumeType) SetName(attr string) {
	p.name = &attr
}

func (p *OpenStackVolumeType) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *OpenStackVolumeType) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *OpenStackVolumeType) SetOpenstackVolumeProvider(attr *OpenStackVolumeProvider) {
	p.openstackVolumeProvider = attr
}

func (p *OpenStackVolumeType) OpenstackVolumeProvider() (*OpenStackVolumeProvider, bool) {
	if p.openstackVolumeProvider != nil {
		return p.openstackVolumeProvider, true
	}
	return nil, false
}

func (p *OpenStackVolumeType) MustOpenstackVolumeProvider() *OpenStackVolumeProvider {
	if p.openstackVolumeProvider == nil {
		panic("the openstackVolumeProvider must not be nil, please use OpenstackVolumeProvider() function instead")
	}
	return p.openstackVolumeProvider
}

func (p *OpenStackVolumeType) SetProperties(attr *PropertySlice) {
	p.properties = attr
}

func (p *OpenStackVolumeType) Properties() (*PropertySlice, bool) {
	if p.properties != nil {
		return p.properties, true
	}
	return nil, false
}

func (p *OpenStackVolumeType) MustProperties() *PropertySlice {
	if p.properties == nil {
		panic("the properties must not be nil, please use Properties() function instead")
	}
	return p.properties
}

type OpenstackVolumeAuthenticationKey struct {
	Struct
	comment                 *string
	creationDate            *time.Time
	description             *string
	id                      *string
	name                    *string
	openstackVolumeProvider *OpenStackVolumeProvider
	usageType               *OpenstackVolumeAuthenticationKeyUsageType
	uuid                    *string
	value                   *string
}

func (p *OpenstackVolumeAuthenticationKey) SetComment(attr string) {
	p.comment = &attr
}

func (p *OpenstackVolumeAuthenticationKey) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *OpenstackVolumeAuthenticationKey) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *OpenstackVolumeAuthenticationKey) SetCreationDate(attr time.Time) {
	p.creationDate = &attr
}

func (p *OpenstackVolumeAuthenticationKey) CreationDate() (time.Time, bool) {
	if p.creationDate != nil {
		return *p.creationDate, true
	}
	var zero time.Time
	return zero, false
}

func (p *OpenstackVolumeAuthenticationKey) MustCreationDate() time.Time {
	if p.creationDate == nil {
		panic("the creationDate must not be nil, please use CreationDate() function instead")
	}
	return *p.creationDate
}

func (p *OpenstackVolumeAuthenticationKey) SetDescription(attr string) {
	p.description = &attr
}

func (p *OpenstackVolumeAuthenticationKey) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *OpenstackVolumeAuthenticationKey) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *OpenstackVolumeAuthenticationKey) SetId(attr string) {
	p.id = &attr
}

func (p *OpenstackVolumeAuthenticationKey) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *OpenstackVolumeAuthenticationKey) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *OpenstackVolumeAuthenticationKey) SetName(attr string) {
	p.name = &attr
}

func (p *OpenstackVolumeAuthenticationKey) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *OpenstackVolumeAuthenticationKey) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *OpenstackVolumeAuthenticationKey) SetOpenstackVolumeProvider(attr *OpenStackVolumeProvider) {
	p.openstackVolumeProvider = attr
}

func (p *OpenstackVolumeAuthenticationKey) OpenstackVolumeProvider() (*OpenStackVolumeProvider, bool) {
	if p.openstackVolumeProvider != nil {
		return p.openstackVolumeProvider, true
	}
	return nil, false
}

func (p *OpenstackVolumeAuthenticationKey) MustOpenstackVolumeProvider() *OpenStackVolumeProvider {
	if p.openstackVolumeProvider == nil {
		panic("the openstackVolumeProvider must not be nil, please use OpenstackVolumeProvider() function instead")
	}
	return p.openstackVolumeProvider
}

func (p *OpenstackVolumeAuthenticationKey) SetUsageType(attr OpenstackVolumeAuthenticationKeyUsageType) {
	p.usageType = &attr
}

func (p *OpenstackVolumeAuthenticationKey) UsageType() (OpenstackVolumeAuthenticationKeyUsageType, bool) {
	if p.usageType != nil {
		return *p.usageType, true
	}
	var zero OpenstackVolumeAuthenticationKeyUsageType
	return zero, false
}

func (p *OpenstackVolumeAuthenticationKey) MustUsageType() OpenstackVolumeAuthenticationKeyUsageType {
	if p.usageType == nil {
		panic("the usageType must not be nil, please use UsageType() function instead")
	}
	return *p.usageType
}

func (p *OpenstackVolumeAuthenticationKey) SetUuid(attr string) {
	p.uuid = &attr
}

func (p *OpenstackVolumeAuthenticationKey) Uuid() (string, bool) {
	if p.uuid != nil {
		return *p.uuid, true
	}
	var zero string
	return zero, false
}

func (p *OpenstackVolumeAuthenticationKey) MustUuid() string {
	if p.uuid == nil {
		panic("the uuid must not be nil, please use Uuid() function instead")
	}
	return *p.uuid
}

func (p *OpenstackVolumeAuthenticationKey) SetValue(attr string) {
	p.value = &attr
}

func (p *OpenstackVolumeAuthenticationKey) Value() (string, bool) {
	if p.value != nil {
		return *p.value, true
	}
	var zero string
	return zero, false
}

func (p *OpenstackVolumeAuthenticationKey) MustValue() string {
	if p.value == nil {
		panic("the value must not be nil, please use Value() function instead")
	}
	return *p.value
}

// OperatingSystem Information describing the operating system. This is used for both virtual machines and hosts.
type OperatingSystem struct {
	Struct
	boot                  *Boot
	cmdline               *string
	customKernelCmdline   *string
	initrd                *string
	kernel                *string
	reportedKernelCmdline *string
	type_                 *string
	version               *Version
}

// SetBoot Configuration of the boot sequence of a virtual machine.
func (p *OperatingSystem) SetBoot(attr *Boot) {
	p.boot = attr
}

// Boot Configuration of the boot sequence of a virtual machine.
func (p *OperatingSystem) Boot() (*Boot, bool) {
	if p.boot != nil {
		return p.boot, true
	}
	return nil, false
}

// MustBoot Configuration of the boot sequence of a virtual machine.
func (p *OperatingSystem) MustBoot() *Boot {
	if p.boot == nil {
		panic("the boot must not be nil, please use Boot() function instead")
	}
	return p.boot
}

func (p *OperatingSystem) SetCmdline(attr string) {
	p.cmdline = &attr
}

func (p *OperatingSystem) Cmdline() (string, bool) {
	if p.cmdline != nil {
		return *p.cmdline, true
	}
	var zero string
	return zero, false
}

func (p *OperatingSystem) MustCmdline() string {
	if p.cmdline == nil {
		panic("the cmdline must not be nil, please use Cmdline() function instead")
	}
	return *p.cmdline
}

func (p *OperatingSystem) SetCustomKernelCmdline(attr string) {
	p.customKernelCmdline = &attr
}

func (p *OperatingSystem) CustomKernelCmdline() (string, bool) {
	if p.customKernelCmdline != nil {
		return *p.customKernelCmdline, true
	}
	var zero string
	return zero, false
}

func (p *OperatingSystem) MustCustomKernelCmdline() string {
	if p.customKernelCmdline == nil {
		panic("the customKernelCmdline must not be nil, please use CustomKernelCmdline() function instead")
	}
	return *p.customKernelCmdline
}

func (p *OperatingSystem) SetInitrd(attr string) {
	p.initrd = &attr
}

func (p *OperatingSystem) Initrd() (string, bool) {
	if p.initrd != nil {
		return *p.initrd, true
	}
	var zero string
	return zero, false
}

func (p *OperatingSystem) MustInitrd() string {
	if p.initrd == nil {
		panic("the initrd must not be nil, please use Initrd() function instead")
	}
	return *p.initrd
}

func (p *OperatingSystem) SetKernel(attr string) {
	p.kernel = &attr
}

func (p *OperatingSystem) Kernel() (string, bool) {
	if p.kernel != nil {
		return *p.kernel, true
	}
	var zero string
	return zero, false
}

func (p *OperatingSystem) MustKernel() string {
	if p.kernel == nil {
		panic("the kernel must not be nil, please use Kernel() function instead")
	}
	return *p.kernel
}

func (p *OperatingSystem) SetReportedKernelCmdline(attr string) {
	p.reportedKernelCmdline = &attr
}

func (p *OperatingSystem) ReportedKernelCmdline() (string, bool) {
	if p.reportedKernelCmdline != nil {
		return *p.reportedKernelCmdline, true
	}
	var zero string
	return zero, false
}

func (p *OperatingSystem) MustReportedKernelCmdline() string {
	if p.reportedKernelCmdline == nil {
		panic("the reportedKernelCmdline must not be nil, please use ReportedKernelCmdline() function instead")
	}
	return *p.reportedKernelCmdline
}

func (p *OperatingSystem) SetType(attr string) {
	p.type_ = &attr
}

func (p *OperatingSystem) Type() (string, bool) {
	if p.type_ != nil {
		return *p.type_, true
	}
	var zero string
	return zero, false
}

func (p *OperatingSystem) MustType() string {
	if p.type_ == nil {
		panic("the type_ must not be nil, please use Type() function instead")
	}
	return *p.type_
}

func (p *OperatingSystem) SetVersion(attr *Version) {
	p.version = attr
}

func (p *OperatingSystem) Version() (*Version, bool) {
	if p.version != nil {
		return p.version, true
	}
	return nil, false
}

func (p *OperatingSystem) MustVersion() *Version {
	if p.version == nil {
		panic("the version must not be nil, please use Version() function instead")
	}
	return p.version
}

// OperatingSystemInfo Represents a guest operating system.
type OperatingSystemInfo struct {
	Struct
	architecture *Architecture
	comment      *string
	description  *string
	id           *string
	largeIcon    *Icon
	name         *string
	smallIcon    *Icon
}

func (p *OperatingSystemInfo) SetArchitecture(attr Architecture) {
	p.architecture = &attr
}

func (p *OperatingSystemInfo) Architecture() (Architecture, bool) {
	if p.architecture != nil {
		return *p.architecture, true
	}
	var zero Architecture
	return zero, false
}

func (p *OperatingSystemInfo) MustArchitecture() Architecture {
	if p.architecture == nil {
		panic("the architecture must not be nil, please use Architecture() function instead")
	}
	return *p.architecture
}

func (p *OperatingSystemInfo) SetComment(attr string) {
	p.comment = &attr
}

func (p *OperatingSystemInfo) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *OperatingSystemInfo) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *OperatingSystemInfo) SetDescription(attr string) {
	p.description = &attr
}

func (p *OperatingSystemInfo) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *OperatingSystemInfo) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *OperatingSystemInfo) SetId(attr string) {
	p.id = &attr
}

func (p *OperatingSystemInfo) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *OperatingSystemInfo) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

// SetLargeIcon Icon of virtual machine or template.
func (p *OperatingSystemInfo) SetLargeIcon(attr *Icon) {
	p.largeIcon = attr
}

// LargeIcon Icon of virtual machine or template.
func (p *OperatingSystemInfo) LargeIcon() (*Icon, bool) {
	if p.largeIcon != nil {
		return p.largeIcon, true
	}
	return nil, false
}

// MustLargeIcon Icon of virtual machine or template.
func (p *OperatingSystemInfo) MustLargeIcon() *Icon {
	if p.largeIcon == nil {
		panic("the largeIcon must not be nil, please use LargeIcon() function instead")
	}
	return p.largeIcon
}

func (p *OperatingSystemInfo) SetName(attr string) {
	p.name = &attr
}

func (p *OperatingSystemInfo) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *OperatingSystemInfo) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

// SetSmallIcon Icon of virtual machine or template.
func (p *OperatingSystemInfo) SetSmallIcon(attr *Icon) {
	p.smallIcon = attr
}

// SmallIcon Icon of virtual machine or template.
func (p *OperatingSystemInfo) SmallIcon() (*Icon, bool) {
	if p.smallIcon != nil {
		return p.smallIcon, true
	}
	return nil, false
}

// MustSmallIcon Icon of virtual machine or template.
func (p *OperatingSystemInfo) MustSmallIcon() *Icon {
	if p.smallIcon == nil {
		panic("the smallIcon must not be nil, please use SmallIcon() function instead")
	}
	return p.smallIcon
}

type Option struct {
	Struct
	name  *string
	type_ *string
	value *string
}

func (p *Option) SetName(attr string) {
	p.name = &attr
}

func (p *Option) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *Option) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *Option) SetType(attr string) {
	p.type_ = &attr
}

func (p *Option) Type() (string, bool) {
	if p.type_ != nil {
		return *p.type_, true
	}
	var zero string
	return zero, false
}

func (p *Option) MustType() string {
	if p.type_ == nil {
		panic("the type_ must not be nil, please use Type() function instead")
	}
	return *p.type_
}

func (p *Option) SetValue(attr string) {
	p.value = &attr
}

func (p *Option) Value() (string, bool) {
	if p.value != nil {
		return *p.value, true
	}
	var zero string
	return zero, false
}

func (p *Option) MustValue() string {
	if p.value == nil {
		panic("the value must not be nil, please use Value() function instead")
	}
	return *p.value
}

// Package Type representing a package.
//
// This is an example of the package element:
//
// [source,xml]
// ----
// <package>
//   <name>libipa_hbac-1.9.2-82.11.el6_4.i686</name>
// </package>
// ----
type Package struct {
	Struct
	name *string
}

func (p *Package) SetName(attr string) {
	p.name = &attr
}

func (p *Package) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *Package) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

type Payload struct {
	Struct
	files    *FileSlice
	type_    *VmDeviceType
	volumeId *string
}

func (p *Payload) SetFiles(attr *FileSlice) {
	p.files = attr
}

func (p *Payload) Files() (*FileSlice, bool) {
	if p.files != nil {
		return p.files, true
	}
	return nil, false
}

func (p *Payload) MustFiles() *FileSlice {
	if p.files == nil {
		panic("the files must not be nil, please use Files() function instead")
	}
	return p.files
}

func (p *Payload) SetType(attr VmDeviceType) {
	p.type_ = &attr
}

func (p *Payload) Type() (VmDeviceType, bool) {
	if p.type_ != nil {
		return *p.type_, true
	}
	var zero VmDeviceType
	return zero, false
}

func (p *Payload) MustType() VmDeviceType {
	if p.type_ == nil {
		panic("the type_ must not be nil, please use Type() function instead")
	}
	return *p.type_
}

func (p *Payload) SetVolumeId(attr string) {
	p.volumeId = &attr
}

func (p *Payload) VolumeId() (string, bool) {
	if p.volumeId != nil {
		return *p.volumeId, true
	}
	var zero string
	return zero, false
}

func (p *Payload) MustVolumeId() string {
	if p.volumeId == nil {
		panic("the volumeId must not be nil, please use VolumeId() function instead")
	}
	return *p.volumeId
}

// Permission Type represents a permission.
type Permission struct {
	Struct
	cluster       *Cluster
	comment       *string
	dataCenter    *DataCenter
	description   *string
	disk          *Disk
	group         *Group
	host          *Host
	id            *string
	name          *string
	role          *Role
	storageDomain *StorageDomain
	template      *Template
	user          *User
	vm            *Vm
	vmPool        *VmPool
}

// SetCluster Type representation of a cluster.
//
// A JSON representation of a cluster:
//
// [source]
// ----
// {
//   "cluster" : [ {
//     "ballooning_enabled" : "false",
//     "cpu" : {
//       "architecture" : "x86_64",
//       "type" : "Intel SandyBridge Family"
//     },
//     "custom_scheduling_policy_properties" : {
//       "property" : [ {
//         "name" : "HighUtilization",
//         "value" : "80"
//       }, {
//         "name" : "CpuOverCommitDurationMinutes",
//         "value" : "2"
//       } ]
//     },
//     "error_handling" : {
//       "on_error" : "migrate"
//     },
//     "fencing_policy" : {
//       "enabled" : "true",
//       "skip_if_connectivity_broken" : {
//         "enabled" : "false",
//         "threshold" : "50"
//       },
//       "skip_if_gluster_bricks_up" : "false",
//       "skip_if_gluster_quorum_not_met" : "false",
//       "skip_if_sd_active" : {
//         "enabled" : "false"
//       }
//     },
//     "gluster_service" : "false",
//     "firewall_type" : "iptables",
//     "ha_reservation" : "false",
//     "ksm" : {
//       "enabled" : "true",
//       "merge_across_nodes" : "true"
//     },
//     "memory_policy" : {
//       "over_commit" : {
//         "percent" : "100"
//       },
//       "transparent_hugepages" : {
//         "enabled" : "true"
//       }
//     },
//     "migration" : {
//       "auto_converge" : "inherit",
//       "bandwidth" : {
//         "assignment_method" : "auto"
//       },
//       "compressed" : "inherit",
//       "policy" : {
//         "id" : "00000000-0000-0000-0000-000000000000"
//       }
//     },
//     "required_rng_sources" : {
//       "required_rng_source" : [ "random" ]
//     },
//     "switch_type" : "legacy",
//     "threads_as_cores" : "false",
//     "trusted_service" : "false",
//     "tunnel_migration" : "false",
//     "version" : {
//       "major" : "4",
//       "minor" : "1"
//     },
//     "virt_service" : "true",
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "mac_pool" : {
//       "href" : "/ovirt-engine/api/macpools/456",
//       "id" : "456"
//     },
//     "scheduling_policy" : {
//       "href" : "/ovirt-engine/api/schedulingpolicies/789",
//       "id" : "789"
//     },
//     "actions" : {
//       "link" : [ {
//         "href" : "/ovirt-engine/api/clusters/234/resetemulatedmachine",
//         "rel" : "resetemulatedmachine"
//       } ]
//     },
//     "name" : "Default",
//     "description" : "The default server cluster",
//     "href" : "/ovirt-engine/api/clusters/234",
//     "id" : "234",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/clusters/234/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/cpuprofiles",
//       "rel" : "cpuprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networkfilters",
//       "rel" : "networkfilters"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networks",
//       "rel" : "networks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/affinitygroups",
//       "rel" : "affinitygroups"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glusterhooks",
//       "rel" : "glusterhooks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glustervolumes",
//       "rel" : "glustervolumes"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/enabledfeatures",
//       "rel" : "enabledfeatures"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/externalnetworkproviders",
//       "rel" : "externalnetworkproviders"
//     } ]
//   } ]
// }
// ----
func (p *Permission) SetCluster(attr *Cluster) {
	p.cluster = attr
}

// Cluster Type representation of a cluster.
//
// A JSON representation of a cluster:
//
// [source]
// ----
// {
//   "cluster" : [ {
//     "ballooning_enabled" : "false",
//     "cpu" : {
//       "architecture" : "x86_64",
//       "type" : "Intel SandyBridge Family"
//     },
//     "custom_scheduling_policy_properties" : {
//       "property" : [ {
//         "name" : "HighUtilization",
//         "value" : "80"
//       }, {
//         "name" : "CpuOverCommitDurationMinutes",
//         "value" : "2"
//       } ]
//     },
//     "error_handling" : {
//       "on_error" : "migrate"
//     },
//     "fencing_policy" : {
//       "enabled" : "true",
//       "skip_if_connectivity_broken" : {
//         "enabled" : "false",
//         "threshold" : "50"
//       },
//       "skip_if_gluster_bricks_up" : "false",
//       "skip_if_gluster_quorum_not_met" : "false",
//       "skip_if_sd_active" : {
//         "enabled" : "false"
//       }
//     },
//     "gluster_service" : "false",
//     "firewall_type" : "iptables",
//     "ha_reservation" : "false",
//     "ksm" : {
//       "enabled" : "true",
//       "merge_across_nodes" : "true"
//     },
//     "memory_policy" : {
//       "over_commit" : {
//         "percent" : "100"
//       },
//       "transparent_hugepages" : {
//         "enabled" : "true"
//       }
//     },
//     "migration" : {
//       "auto_converge" : "inherit",
//       "bandwidth" : {
//         "assignment_method" : "auto"
//       },
//       "compressed" : "inherit",
//       "policy" : {
//         "id" : "00000000-0000-0000-0000-000000000000"
//       }
//     },
//     "required_rng_sources" : {
//       "required_rng_source" : [ "random" ]
//     },
//     "switch_type" : "legacy",
//     "threads_as_cores" : "false",
//     "trusted_service" : "false",
//     "tunnel_migration" : "false",
//     "version" : {
//       "major" : "4",
//       "minor" : "1"
//     },
//     "virt_service" : "true",
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "mac_pool" : {
//       "href" : "/ovirt-engine/api/macpools/456",
//       "id" : "456"
//     },
//     "scheduling_policy" : {
//       "href" : "/ovirt-engine/api/schedulingpolicies/789",
//       "id" : "789"
//     },
//     "actions" : {
//       "link" : [ {
//         "href" : "/ovirt-engine/api/clusters/234/resetemulatedmachine",
//         "rel" : "resetemulatedmachine"
//       } ]
//     },
//     "name" : "Default",
//     "description" : "The default server cluster",
//     "href" : "/ovirt-engine/api/clusters/234",
//     "id" : "234",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/clusters/234/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/cpuprofiles",
//       "rel" : "cpuprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networkfilters",
//       "rel" : "networkfilters"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networks",
//       "rel" : "networks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/affinitygroups",
//       "rel" : "affinitygroups"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glusterhooks",
//       "rel" : "glusterhooks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glustervolumes",
//       "rel" : "glustervolumes"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/enabledfeatures",
//       "rel" : "enabledfeatures"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/externalnetworkproviders",
//       "rel" : "externalnetworkproviders"
//     } ]
//   } ]
// }
// ----
func (p *Permission) Cluster() (*Cluster, bool) {
	if p.cluster != nil {
		return p.cluster, true
	}
	return nil, false
}

// MustCluster Type representation of a cluster.
//
// A JSON representation of a cluster:
//
// [source]
// ----
// {
//   "cluster" : [ {
//     "ballooning_enabled" : "false",
//     "cpu" : {
//       "architecture" : "x86_64",
//       "type" : "Intel SandyBridge Family"
//     },
//     "custom_scheduling_policy_properties" : {
//       "property" : [ {
//         "name" : "HighUtilization",
//         "value" : "80"
//       }, {
//         "name" : "CpuOverCommitDurationMinutes",
//         "value" : "2"
//       } ]
//     },
//     "error_handling" : {
//       "on_error" : "migrate"
//     },
//     "fencing_policy" : {
//       "enabled" : "true",
//       "skip_if_connectivity_broken" : {
//         "enabled" : "false",
//         "threshold" : "50"
//       },
//       "skip_if_gluster_bricks_up" : "false",
//       "skip_if_gluster_quorum_not_met" : "false",
//       "skip_if_sd_active" : {
//         "enabled" : "false"
//       }
//     },
//     "gluster_service" : "false",
//     "firewall_type" : "iptables",
//     "ha_reservation" : "false",
//     "ksm" : {
//       "enabled" : "true",
//       "merge_across_nodes" : "true"
//     },
//     "memory_policy" : {
//       "over_commit" : {
//         "percent" : "100"
//       },
//       "transparent_hugepages" : {
//         "enabled" : "true"
//       }
//     },
//     "migration" : {
//       "auto_converge" : "inherit",
//       "bandwidth" : {
//         "assignment_method" : "auto"
//       },
//       "compressed" : "inherit",
//       "policy" : {
//         "id" : "00000000-0000-0000-0000-000000000000"
//       }
//     },
//     "required_rng_sources" : {
//       "required_rng_source" : [ "random" ]
//     },
//     "switch_type" : "legacy",
//     "threads_as_cores" : "false",
//     "trusted_service" : "false",
//     "tunnel_migration" : "false",
//     "version" : {
//       "major" : "4",
//       "minor" : "1"
//     },
//     "virt_service" : "true",
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "mac_pool" : {
//       "href" : "/ovirt-engine/api/macpools/456",
//       "id" : "456"
//     },
//     "scheduling_policy" : {
//       "href" : "/ovirt-engine/api/schedulingpolicies/789",
//       "id" : "789"
//     },
//     "actions" : {
//       "link" : [ {
//         "href" : "/ovirt-engine/api/clusters/234/resetemulatedmachine",
//         "rel" : "resetemulatedmachine"
//       } ]
//     },
//     "name" : "Default",
//     "description" : "The default server cluster",
//     "href" : "/ovirt-engine/api/clusters/234",
//     "id" : "234",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/clusters/234/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/cpuprofiles",
//       "rel" : "cpuprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networkfilters",
//       "rel" : "networkfilters"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networks",
//       "rel" : "networks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/affinitygroups",
//       "rel" : "affinitygroups"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glusterhooks",
//       "rel" : "glusterhooks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glustervolumes",
//       "rel" : "glustervolumes"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/enabledfeatures",
//       "rel" : "enabledfeatures"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/externalnetworkproviders",
//       "rel" : "externalnetworkproviders"
//     } ]
//   } ]
// }
// ----
func (p *Permission) MustCluster() *Cluster {
	if p.cluster == nil {
		panic("the cluster must not be nil, please use Cluster() function instead")
	}
	return p.cluster
}

func (p *Permission) SetComment(attr string) {
	p.comment = &attr
}

func (p *Permission) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *Permission) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *Permission) SetDataCenter(attr *DataCenter) {
	p.dataCenter = attr
}

func (p *Permission) DataCenter() (*DataCenter, bool) {
	if p.dataCenter != nil {
		return p.dataCenter, true
	}
	return nil, false
}

func (p *Permission) MustDataCenter() *DataCenter {
	if p.dataCenter == nil {
		panic("the dataCenter must not be nil, please use DataCenter() function instead")
	}
	return p.dataCenter
}

func (p *Permission) SetDescription(attr string) {
	p.description = &attr
}

func (p *Permission) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *Permission) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

// SetDisk Represents a virtual disk device.
func (p *Permission) SetDisk(attr *Disk) {
	p.disk = attr
}

// Disk Represents a virtual disk device.
func (p *Permission) Disk() (*Disk, bool) {
	if p.disk != nil {
		return p.disk, true
	}
	return nil, false
}

// MustDisk Represents a virtual disk device.
func (p *Permission) MustDisk() *Disk {
	if p.disk == nil {
		panic("the disk must not be nil, please use Disk() function instead")
	}
	return p.disk
}

// SetGroup This type represents all groups in the directory service.
func (p *Permission) SetGroup(attr *Group) {
	p.group = attr
}

// Group This type represents all groups in the directory service.
func (p *Permission) Group() (*Group, bool) {
	if p.group != nil {
		return p.group, true
	}
	return nil, false
}

// MustGroup This type represents all groups in the directory service.
func (p *Permission) MustGroup() *Group {
	if p.group == nil {
		panic("the group must not be nil, please use Group() function instead")
	}
	return p.group
}

// SetHost Type representing a host.
func (p *Permission) SetHost(attr *Host) {
	p.host = attr
}

// Host Type representing a host.
func (p *Permission) Host() (*Host, bool) {
	if p.host != nil {
		return p.host, true
	}
	return nil, false
}

// MustHost Type representing a host.
func (p *Permission) MustHost() *Host {
	if p.host == nil {
		panic("the host must not be nil, please use Host() function instead")
	}
	return p.host
}

func (p *Permission) SetId(attr string) {
	p.id = &attr
}

func (p *Permission) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *Permission) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *Permission) SetName(attr string) {
	p.name = &attr
}

func (p *Permission) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *Permission) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

// SetRole Represents a system role.
func (p *Permission) SetRole(attr *Role) {
	p.role = attr
}

// Role Represents a system role.
func (p *Permission) Role() (*Role, bool) {
	if p.role != nil {
		return p.role, true
	}
	return nil, false
}

// MustRole Represents a system role.
func (p *Permission) MustRole() *Role {
	if p.role == nil {
		panic("the role must not be nil, please use Role() function instead")
	}
	return p.role
}

// SetStorageDomain Storage domain.
//
// An XML representation of a NFS storage domain with identifier `123`:
//
// [source,xml]
// ----
// <storage_domain href="/ovirt-engine/api/storagedomains/123" id="123">
//   <name>mydata</name>
//   <description>My data</description>
//   <available>38654705664</available>
//   <committed>1073741824</committed>
//   <critical_space_action_blocker>5</critical_space_action_blocker>
//   <external_status>ok</external_status>
//   <master>true</master>
//   <storage>
//     <address>mynfs.example.com</address>
//     <nfs_version>v3</nfs_version>
//     <path>/exports/mydata</path>
//     <type>nfs</type>
//   </storage>
//   <storage_format>v3</storage_format>
//   <type>data</type>
//   <used>13958643712</used>
//   <warning_low_space_indicator>10</warning_low_space_indicator>
//   <wipe_after_delete>false</wipe_after_delete>
//   <data_centers>
//     <data_center href="/ovirt-engine/api/datacenters/456" id="456"/>
//   </data_centers>
// </storage_domain>
// ----
func (p *Permission) SetStorageDomain(attr *StorageDomain) {
	p.storageDomain = attr
}

// StorageDomain Storage domain.
//
// An XML representation of a NFS storage domain with identifier `123`:
//
// [source,xml]
// ----
// <storage_domain href="/ovirt-engine/api/storagedomains/123" id="123">
//   <name>mydata</name>
//   <description>My data</description>
//   <available>38654705664</available>
//   <committed>1073741824</committed>
//   <critical_space_action_blocker>5</critical_space_action_blocker>
//   <external_status>ok</external_status>
//   <master>true</master>
//   <storage>
//     <address>mynfs.example.com</address>
//     <nfs_version>v3</nfs_version>
//     <path>/exports/mydata</path>
//     <type>nfs</type>
//   </storage>
//   <storage_format>v3</storage_format>
//   <type>data</type>
//   <used>13958643712</used>
//   <warning_low_space_indicator>10</warning_low_space_indicator>
//   <wipe_after_delete>false</wipe_after_delete>
//   <data_centers>
//     <data_center href="/ovirt-engine/api/datacenters/456" id="456"/>
//   </data_centers>
// </storage_domain>
// ----
func (p *Permission) StorageDomain() (*StorageDomain, bool) {
	if p.storageDomain != nil {
		return p.storageDomain, true
	}
	return nil, false
}

// MustStorageDomain Storage domain.
//
// An XML representation of a NFS storage domain with identifier `123`:
//
// [source,xml]
// ----
// <storage_domain href="/ovirt-engine/api/storagedomains/123" id="123">
//   <name>mydata</name>
//   <description>My data</description>
//   <available>38654705664</available>
//   <committed>1073741824</committed>
//   <critical_space_action_blocker>5</critical_space_action_blocker>
//   <external_status>ok</external_status>
//   <master>true</master>
//   <storage>
//     <address>mynfs.example.com</address>
//     <nfs_version>v3</nfs_version>
//     <path>/exports/mydata</path>
//     <type>nfs</type>
//   </storage>
//   <storage_format>v3</storage_format>
//   <type>data</type>
//   <used>13958643712</used>
//   <warning_low_space_indicator>10</warning_low_space_indicator>
//   <wipe_after_delete>false</wipe_after_delete>
//   <data_centers>
//     <data_center href="/ovirt-engine/api/datacenters/456" id="456"/>
//   </data_centers>
// </storage_domain>
// ----
func (p *Permission) MustStorageDomain() *StorageDomain {
	if p.storageDomain == nil {
		panic("the storageDomain must not be nil, please use StorageDomain() function instead")
	}
	return p.storageDomain
}

// SetTemplate The type that represents a virtual machine template.
// Templates allow for a rapid instantiation of virtual machines with common configuration and disk states.
func (p *Permission) SetTemplate(attr *Template) {
	p.template = attr
}

// Template The type that represents a virtual machine template.
// Templates allow for a rapid instantiation of virtual machines with common configuration and disk states.
func (p *Permission) Template() (*Template, bool) {
	if p.template != nil {
		return p.template, true
	}
	return nil, false
}

// MustTemplate The type that represents a virtual machine template.
// Templates allow for a rapid instantiation of virtual machines with common configuration and disk states.
func (p *Permission) MustTemplate() *Template {
	if p.template == nil {
		panic("the template must not be nil, please use Template() function instead")
	}
	return p.template
}

// SetUser Represents a user in the system.
func (p *Permission) SetUser(attr *User) {
	p.user = attr
}

// User Represents a user in the system.
func (p *Permission) User() (*User, bool) {
	if p.user != nil {
		return p.user, true
	}
	return nil, false
}

// MustUser Represents a user in the system.
func (p *Permission) MustUser() *User {
	if p.user == nil {
		panic("the user must not be nil, please use User() function instead")
	}
	return p.user
}

// SetVm Represents a virtual machine.
func (p *Permission) SetVm(attr *Vm) {
	p.vm = attr
}

// Vm Represents a virtual machine.
func (p *Permission) Vm() (*Vm, bool) {
	if p.vm != nil {
		return p.vm, true
	}
	return nil, false
}

// MustVm Represents a virtual machine.
func (p *Permission) MustVm() *Vm {
	if p.vm == nil {
		panic("the vm must not be nil, please use Vm() function instead")
	}
	return p.vm
}

// SetVmPool Type represeting a virtual machines pool.
func (p *Permission) SetVmPool(attr *VmPool) {
	p.vmPool = attr
}

// VmPool Type represeting a virtual machines pool.
func (p *Permission) VmPool() (*VmPool, bool) {
	if p.vmPool != nil {
		return p.vmPool, true
	}
	return nil, false
}

// MustVmPool Type represeting a virtual machines pool.
func (p *Permission) MustVmPool() *VmPool {
	if p.vmPool == nil {
		panic("the vmPool must not be nil, please use VmPool() function instead")
	}
	return p.vmPool
}

// Permit Type represents a permit.
type Permit struct {
	Struct
	administrative *bool
	comment        *string
	description    *string
	id             *string
	name           *string
	role           *Role
}

func (p *Permit) SetAdministrative(attr bool) {
	p.administrative = &attr
}

func (p *Permit) Administrative() (bool, bool) {
	if p.administrative != nil {
		return *p.administrative, true
	}
	var zero bool
	return zero, false
}

func (p *Permit) MustAdministrative() bool {
	if p.administrative == nil {
		panic("the administrative must not be nil, please use Administrative() function instead")
	}
	return *p.administrative
}

func (p *Permit) SetComment(attr string) {
	p.comment = &attr
}

func (p *Permit) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *Permit) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *Permit) SetDescription(attr string) {
	p.description = &attr
}

func (p *Permit) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *Permit) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *Permit) SetId(attr string) {
	p.id = &attr
}

func (p *Permit) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *Permit) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *Permit) SetName(attr string) {
	p.name = &attr
}

func (p *Permit) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *Permit) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

// SetRole Represents a system role.
func (p *Permit) SetRole(attr *Role) {
	p.role = attr
}

// Role Represents a system role.
func (p *Permit) Role() (*Role, bool) {
	if p.role != nil {
		return p.role, true
	}
	return nil, false
}

// MustRole Represents a system role.
func (p *Permit) MustRole() *Role {
	if p.role == nil {
		panic("the role must not be nil, please use Role() function instead")
	}
	return p.role
}

type PmProxy struct {
	Struct
	type_ *PmProxyType
}

func (p *PmProxy) SetType(attr PmProxyType) {
	p.type_ = &attr
}

func (p *PmProxy) Type() (PmProxyType, bool) {
	if p.type_ != nil {
		return *p.type_, true
	}
	var zero PmProxyType
	return zero, false
}

func (p *PmProxy) MustType() PmProxyType {
	if p.type_ == nil {
		panic("the type_ must not be nil, please use Type() function instead")
	}
	return *p.type_
}

type PortMirroring struct {
	Struct
}

type PowerManagement struct {
	Struct
	address            *string
	agents             *AgentSlice
	automaticPmEnabled *bool
	enabled            *bool
	kdumpDetection     *bool
	options            *OptionSlice
	password           *string
	pmProxies          *PmProxySlice
	status             *PowerManagementStatus
	type_              *string
	username           *string
}

func (p *PowerManagement) SetAddress(attr string) {
	p.address = &attr
}

func (p *PowerManagement) Address() (string, bool) {
	if p.address != nil {
		return *p.address, true
	}
	var zero string
	return zero, false
}

func (p *PowerManagement) MustAddress() string {
	if p.address == nil {
		panic("the address must not be nil, please use Address() function instead")
	}
	return *p.address
}

func (p *PowerManagement) SetAgents(attr *AgentSlice) {
	p.agents = attr
}

func (p *PowerManagement) Agents() (*AgentSlice, bool) {
	if p.agents != nil {
		return p.agents, true
	}
	return nil, false
}

func (p *PowerManagement) MustAgents() *AgentSlice {
	if p.agents == nil {
		panic("the agents must not be nil, please use Agents() function instead")
	}
	return p.agents
}

func (p *PowerManagement) SetAutomaticPmEnabled(attr bool) {
	p.automaticPmEnabled = &attr
}

func (p *PowerManagement) AutomaticPmEnabled() (bool, bool) {
	if p.automaticPmEnabled != nil {
		return *p.automaticPmEnabled, true
	}
	var zero bool
	return zero, false
}

func (p *PowerManagement) MustAutomaticPmEnabled() bool {
	if p.automaticPmEnabled == nil {
		panic("the automaticPmEnabled must not be nil, please use AutomaticPmEnabled() function instead")
	}
	return *p.automaticPmEnabled
}

func (p *PowerManagement) SetEnabled(attr bool) {
	p.enabled = &attr
}

func (p *PowerManagement) Enabled() (bool, bool) {
	if p.enabled != nil {
		return *p.enabled, true
	}
	var zero bool
	return zero, false
}

func (p *PowerManagement) MustEnabled() bool {
	if p.enabled == nil {
		panic("the enabled must not be nil, please use Enabled() function instead")
	}
	return *p.enabled
}

func (p *PowerManagement) SetKdumpDetection(attr bool) {
	p.kdumpDetection = &attr
}

func (p *PowerManagement) KdumpDetection() (bool, bool) {
	if p.kdumpDetection != nil {
		return *p.kdumpDetection, true
	}
	var zero bool
	return zero, false
}

func (p *PowerManagement) MustKdumpDetection() bool {
	if p.kdumpDetection == nil {
		panic("the kdumpDetection must not be nil, please use KdumpDetection() function instead")
	}
	return *p.kdumpDetection
}

func (p *PowerManagement) SetOptions(attr *OptionSlice) {
	p.options = attr
}

func (p *PowerManagement) Options() (*OptionSlice, bool) {
	if p.options != nil {
		return p.options, true
	}
	return nil, false
}

func (p *PowerManagement) MustOptions() *OptionSlice {
	if p.options == nil {
		panic("the options must not be nil, please use Options() function instead")
	}
	return p.options
}

func (p *PowerManagement) SetPassword(attr string) {
	p.password = &attr
}

func (p *PowerManagement) Password() (string, bool) {
	if p.password != nil {
		return *p.password, true
	}
	var zero string
	return zero, false
}

func (p *PowerManagement) MustPassword() string {
	if p.password == nil {
		panic("the password must not be nil, please use Password() function instead")
	}
	return *p.password
}

func (p *PowerManagement) SetPmProxies(attr *PmProxySlice) {
	p.pmProxies = attr
}

func (p *PowerManagement) PmProxies() (*PmProxySlice, bool) {
	if p.pmProxies != nil {
		return p.pmProxies, true
	}
	return nil, false
}

func (p *PowerManagement) MustPmProxies() *PmProxySlice {
	if p.pmProxies == nil {
		panic("the pmProxies must not be nil, please use PmProxies() function instead")
	}
	return p.pmProxies
}

func (p *PowerManagement) SetStatus(attr PowerManagementStatus) {
	p.status = &attr
}

func (p *PowerManagement) Status() (PowerManagementStatus, bool) {
	if p.status != nil {
		return *p.status, true
	}
	var zero PowerManagementStatus
	return zero, false
}

func (p *PowerManagement) MustStatus() PowerManagementStatus {
	if p.status == nil {
		panic("the status must not be nil, please use Status() function instead")
	}
	return *p.status
}

func (p *PowerManagement) SetType(attr string) {
	p.type_ = &attr
}

func (p *PowerManagement) Type() (string, bool) {
	if p.type_ != nil {
		return *p.type_, true
	}
	var zero string
	return zero, false
}

func (p *PowerManagement) MustType() string {
	if p.type_ == nil {
		panic("the type_ must not be nil, please use Type() function instead")
	}
	return *p.type_
}

func (p *PowerManagement) SetUsername(attr string) {
	p.username = &attr
}

func (p *PowerManagement) Username() (string, bool) {
	if p.username != nil {
		return *p.username, true
	}
	var zero string
	return zero, false
}

func (p *PowerManagement) MustUsername() string {
	if p.username == nil {
		panic("the username must not be nil, please use Username() function instead")
	}
	return *p.username
}

type Product struct {
	Struct
	comment     *string
	description *string
	id          *string
	name        *string
}

func (p *Product) SetComment(attr string) {
	p.comment = &attr
}

func (p *Product) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *Product) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *Product) SetDescription(attr string) {
	p.description = &attr
}

func (p *Product) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *Product) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *Product) SetId(attr string) {
	p.id = &attr
}

func (p *Product) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *Product) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *Product) SetName(attr string) {
	p.name = &attr
}

func (p *Product) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *Product) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

// ProductInfo Product information.
//
// The entry point contains a `product_info` element to help an API user determine the legitimacy of the
// {product-name} environment. This includes the name of the product, the `vendor` and the `version`.
//
// Verify a genuine {product-name} environment
//
// The follow elements identify a genuine {product-name} environment:
//
// [source]
// ----
// <api>
// ...
// <product_info>
//   <name>oVirt Engine</name>
//   <vendor>ovirt.org</vendor>
//   <version>
//     <build>0</build>
//     <full_version>4.1.0_master</full_version>
//     <major>4</major>
//     <minor>1</minor>
//     <revision>0</revision>
//   </version>
// </product_info>
// ...
// </api>
// ----
type ProductInfo struct {
	Struct
	instanceId *string
	name       *string
	vendor     *string
	version    *Version
}

func (p *ProductInfo) SetInstanceId(attr string) {
	p.instanceId = &attr
}

func (p *ProductInfo) InstanceId() (string, bool) {
	if p.instanceId != nil {
		return *p.instanceId, true
	}
	var zero string
	return zero, false
}

func (p *ProductInfo) MustInstanceId() string {
	if p.instanceId == nil {
		panic("the instanceId must not be nil, please use InstanceId() function instead")
	}
	return *p.instanceId
}

func (p *ProductInfo) SetName(attr string) {
	p.name = &attr
}

func (p *ProductInfo) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *ProductInfo) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *ProductInfo) SetVendor(attr string) {
	p.vendor = &attr
}

func (p *ProductInfo) Vendor() (string, bool) {
	if p.vendor != nil {
		return *p.vendor, true
	}
	var zero string
	return zero, false
}

func (p *ProductInfo) MustVendor() string {
	if p.vendor == nil {
		panic("the vendor must not be nil, please use Vendor() function instead")
	}
	return *p.vendor
}

func (p *ProductInfo) SetVersion(attr *Version) {
	p.version = attr
}

func (p *ProductInfo) Version() (*Version, bool) {
	if p.version != nil {
		return p.version, true
	}
	return nil, false
}

func (p *ProductInfo) MustVersion() *Version {
	if p.version == nil {
		panic("the version must not be nil, please use Version() function instead")
	}
	return p.version
}

type ProfileDetail struct {
	Struct
	blockStatistics *BlockStatisticSlice
	duration        *int64
	fopStatistics   *FopStatisticSlice
	profileType     *string
	statistics      *StatisticSlice
}

func (p *ProfileDetail) SetBlockStatistics(attr *BlockStatisticSlice) {
	p.blockStatistics = attr
}

func (p *ProfileDetail) BlockStatistics() (*BlockStatisticSlice, bool) {
	if p.blockStatistics != nil {
		return p.blockStatistics, true
	}
	return nil, false
}

func (p *ProfileDetail) MustBlockStatistics() *BlockStatisticSlice {
	if p.blockStatistics == nil {
		panic("the blockStatistics must not be nil, please use BlockStatistics() function instead")
	}
	return p.blockStatistics
}

func (p *ProfileDetail) SetDuration(attr int64) {
	p.duration = &attr
}

func (p *ProfileDetail) Duration() (int64, bool) {
	if p.duration != nil {
		return *p.duration, true
	}
	var zero int64
	return zero, false
}

func (p *ProfileDetail) MustDuration() int64 {
	if p.duration == nil {
		panic("the duration must not be nil, please use Duration() function instead")
	}
	return *p.duration
}

func (p *ProfileDetail) SetFopStatistics(attr *FopStatisticSlice) {
	p.fopStatistics = attr
}

func (p *ProfileDetail) FopStatistics() (*FopStatisticSlice, bool) {
	if p.fopStatistics != nil {
		return p.fopStatistics, true
	}
	return nil, false
}

func (p *ProfileDetail) MustFopStatistics() *FopStatisticSlice {
	if p.fopStatistics == nil {
		panic("the fopStatistics must not be nil, please use FopStatistics() function instead")
	}
	return p.fopStatistics
}

func (p *ProfileDetail) SetProfileType(attr string) {
	p.profileType = &attr
}

func (p *ProfileDetail) ProfileType() (string, bool) {
	if p.profileType != nil {
		return *p.profileType, true
	}
	var zero string
	return zero, false
}

func (p *ProfileDetail) MustProfileType() string {
	if p.profileType == nil {
		panic("the profileType must not be nil, please use ProfileType() function instead")
	}
	return *p.profileType
}

func (p *ProfileDetail) SetStatistics(attr *StatisticSlice) {
	p.statistics = attr
}

func (p *ProfileDetail) Statistics() (*StatisticSlice, bool) {
	if p.statistics != nil {
		return p.statistics, true
	}
	return nil, false
}

func (p *ProfileDetail) MustStatistics() *StatisticSlice {
	if p.statistics == nil {
		panic("the statistics must not be nil, please use Statistics() function instead")
	}
	return p.statistics
}

type Property struct {
	Struct
	name  *string
	value *string
}

func (p *Property) SetName(attr string) {
	p.name = &attr
}

func (p *Property) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *Property) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *Property) SetValue(attr string) {
	p.value = &attr
}

func (p *Property) Value() (string, bool) {
	if p.value != nil {
		return *p.value, true
	}
	var zero string
	return zero, false
}

func (p *Property) MustValue() string {
	if p.value == nil {
		panic("the value must not be nil, please use Value() function instead")
	}
	return *p.value
}

type ProxyTicket struct {
	Struct
	value *string
}

func (p *ProxyTicket) SetValue(attr string) {
	p.value = &attr
}

func (p *ProxyTicket) Value() (string, bool) {
	if p.value != nil {
		return *p.value, true
	}
	var zero string
	return zero, false
}

func (p *ProxyTicket) MustValue() string {
	if p.value == nil {
		panic("the value must not be nil, please use Value() function instead")
	}
	return *p.value
}

// Qos This type represents the attributes to define Quality of service (QoS).
//
// For storage the `type` is <<types/qos_type, storage>>, the attributes `max_throughput`, `max_read_throughput`,
// `max_write_throughput`, `max_iops`, `max_read_iops` and `max_write_iops` are relevant.
//
// For resources with computing capabilities the `type` is <<types/qos_type, cpu>>, the attribute `cpu_limit` is
// relevant.
//
// For virtual machines networks the `type` is <<types/qos_type, network>>, the attributes `inbound_average`,
// `inbound_peak`, `inbound_burst`, `outbound_average`, `outbound_peak` and `outbound_burst` are relevant.
//
// For host networks the `type` is <<types/qos_type, hostnetwork>>, the attributes `outbound_average_linkshare`,
// `outbound_average_upperlimit` and `outbound_average_realtime` are relevant.
type Qos struct {
	Struct
	comment                   *string
	cpuLimit                  *int64
	dataCenter                *DataCenter
	description               *string
	id                        *string
	inboundAverage            *int64
	inboundBurst              *int64
	inboundPeak               *int64
	maxIops                   *int64
	maxReadIops               *int64
	maxReadThroughput         *int64
	maxThroughput             *int64
	maxWriteIops              *int64
	maxWriteThroughput        *int64
	name                      *string
	outboundAverage           *int64
	outboundAverageLinkshare  *int64
	outboundAverageRealtime   *int64
	outboundAverageUpperlimit *int64
	outboundBurst             *int64
	outboundPeak              *int64
	type_                     *QosType
}

func (p *Qos) SetComment(attr string) {
	p.comment = &attr
}

func (p *Qos) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *Qos) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *Qos) SetCpuLimit(attr int64) {
	p.cpuLimit = &attr
}

func (p *Qos) CpuLimit() (int64, bool) {
	if p.cpuLimit != nil {
		return *p.cpuLimit, true
	}
	var zero int64
	return zero, false
}

func (p *Qos) MustCpuLimit() int64 {
	if p.cpuLimit == nil {
		panic("the cpuLimit must not be nil, please use CpuLimit() function instead")
	}
	return *p.cpuLimit
}

func (p *Qos) SetDataCenter(attr *DataCenter) {
	p.dataCenter = attr
}

func (p *Qos) DataCenter() (*DataCenter, bool) {
	if p.dataCenter != nil {
		return p.dataCenter, true
	}
	return nil, false
}

func (p *Qos) MustDataCenter() *DataCenter {
	if p.dataCenter == nil {
		panic("the dataCenter must not be nil, please use DataCenter() function instead")
	}
	return p.dataCenter
}

func (p *Qos) SetDescription(attr string) {
	p.description = &attr
}

func (p *Qos) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *Qos) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *Qos) SetId(attr string) {
	p.id = &attr
}

func (p *Qos) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *Qos) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *Qos) SetInboundAverage(attr int64) {
	p.inboundAverage = &attr
}

func (p *Qos) InboundAverage() (int64, bool) {
	if p.inboundAverage != nil {
		return *p.inboundAverage, true
	}
	var zero int64
	return zero, false
}

func (p *Qos) MustInboundAverage() int64 {
	if p.inboundAverage == nil {
		panic("the inboundAverage must not be nil, please use InboundAverage() function instead")
	}
	return *p.inboundAverage
}

func (p *Qos) SetInboundBurst(attr int64) {
	p.inboundBurst = &attr
}

func (p *Qos) InboundBurst() (int64, bool) {
	if p.inboundBurst != nil {
		return *p.inboundBurst, true
	}
	var zero int64
	return zero, false
}

func (p *Qos) MustInboundBurst() int64 {
	if p.inboundBurst == nil {
		panic("the inboundBurst must not be nil, please use InboundBurst() function instead")
	}
	return *p.inboundBurst
}

func (p *Qos) SetInboundPeak(attr int64) {
	p.inboundPeak = &attr
}

func (p *Qos) InboundPeak() (int64, bool) {
	if p.inboundPeak != nil {
		return *p.inboundPeak, true
	}
	var zero int64
	return zero, false
}

func (p *Qos) MustInboundPeak() int64 {
	if p.inboundPeak == nil {
		panic("the inboundPeak must not be nil, please use InboundPeak() function instead")
	}
	return *p.inboundPeak
}

func (p *Qos) SetMaxIops(attr int64) {
	p.maxIops = &attr
}

func (p *Qos) MaxIops() (int64, bool) {
	if p.maxIops != nil {
		return *p.maxIops, true
	}
	var zero int64
	return zero, false
}

func (p *Qos) MustMaxIops() int64 {
	if p.maxIops == nil {
		panic("the maxIops must not be nil, please use MaxIops() function instead")
	}
	return *p.maxIops
}

func (p *Qos) SetMaxReadIops(attr int64) {
	p.maxReadIops = &attr
}

func (p *Qos) MaxReadIops() (int64, bool) {
	if p.maxReadIops != nil {
		return *p.maxReadIops, true
	}
	var zero int64
	return zero, false
}

func (p *Qos) MustMaxReadIops() int64 {
	if p.maxReadIops == nil {
		panic("the maxReadIops must not be nil, please use MaxReadIops() function instead")
	}
	return *p.maxReadIops
}

func (p *Qos) SetMaxReadThroughput(attr int64) {
	p.maxReadThroughput = &attr
}

func (p *Qos) MaxReadThroughput() (int64, bool) {
	if p.maxReadThroughput != nil {
		return *p.maxReadThroughput, true
	}
	var zero int64
	return zero, false
}

func (p *Qos) MustMaxReadThroughput() int64 {
	if p.maxReadThroughput == nil {
		panic("the maxReadThroughput must not be nil, please use MaxReadThroughput() function instead")
	}
	return *p.maxReadThroughput
}

func (p *Qos) SetMaxThroughput(attr int64) {
	p.maxThroughput = &attr
}

func (p *Qos) MaxThroughput() (int64, bool) {
	if p.maxThroughput != nil {
		return *p.maxThroughput, true
	}
	var zero int64
	return zero, false
}

func (p *Qos) MustMaxThroughput() int64 {
	if p.maxThroughput == nil {
		panic("the maxThroughput must not be nil, please use MaxThroughput() function instead")
	}
	return *p.maxThroughput
}

func (p *Qos) SetMaxWriteIops(attr int64) {
	p.maxWriteIops = &attr
}

func (p *Qos) MaxWriteIops() (int64, bool) {
	if p.maxWriteIops != nil {
		return *p.maxWriteIops, true
	}
	var zero int64
	return zero, false
}

func (p *Qos) MustMaxWriteIops() int64 {
	if p.maxWriteIops == nil {
		panic("the maxWriteIops must not be nil, please use MaxWriteIops() function instead")
	}
	return *p.maxWriteIops
}

func (p *Qos) SetMaxWriteThroughput(attr int64) {
	p.maxWriteThroughput = &attr
}

func (p *Qos) MaxWriteThroughput() (int64, bool) {
	if p.maxWriteThroughput != nil {
		return *p.maxWriteThroughput, true
	}
	var zero int64
	return zero, false
}

func (p *Qos) MustMaxWriteThroughput() int64 {
	if p.maxWriteThroughput == nil {
		panic("the maxWriteThroughput must not be nil, please use MaxWriteThroughput() function instead")
	}
	return *p.maxWriteThroughput
}

func (p *Qos) SetName(attr string) {
	p.name = &attr
}

func (p *Qos) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *Qos) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *Qos) SetOutboundAverage(attr int64) {
	p.outboundAverage = &attr
}

func (p *Qos) OutboundAverage() (int64, bool) {
	if p.outboundAverage != nil {
		return *p.outboundAverage, true
	}
	var zero int64
	return zero, false
}

func (p *Qos) MustOutboundAverage() int64 {
	if p.outboundAverage == nil {
		panic("the outboundAverage must not be nil, please use OutboundAverage() function instead")
	}
	return *p.outboundAverage
}

func (p *Qos) SetOutboundAverageLinkshare(attr int64) {
	p.outboundAverageLinkshare = &attr
}

func (p *Qos) OutboundAverageLinkshare() (int64, bool) {
	if p.outboundAverageLinkshare != nil {
		return *p.outboundAverageLinkshare, true
	}
	var zero int64
	return zero, false
}

func (p *Qos) MustOutboundAverageLinkshare() int64 {
	if p.outboundAverageLinkshare == nil {
		panic("the outboundAverageLinkshare must not be nil, please use OutboundAverageLinkshare() function instead")
	}
	return *p.outboundAverageLinkshare
}

func (p *Qos) SetOutboundAverageRealtime(attr int64) {
	p.outboundAverageRealtime = &attr
}

func (p *Qos) OutboundAverageRealtime() (int64, bool) {
	if p.outboundAverageRealtime != nil {
		return *p.outboundAverageRealtime, true
	}
	var zero int64
	return zero, false
}

func (p *Qos) MustOutboundAverageRealtime() int64 {
	if p.outboundAverageRealtime == nil {
		panic("the outboundAverageRealtime must not be nil, please use OutboundAverageRealtime() function instead")
	}
	return *p.outboundAverageRealtime
}

func (p *Qos) SetOutboundAverageUpperlimit(attr int64) {
	p.outboundAverageUpperlimit = &attr
}

func (p *Qos) OutboundAverageUpperlimit() (int64, bool) {
	if p.outboundAverageUpperlimit != nil {
		return *p.outboundAverageUpperlimit, true
	}
	var zero int64
	return zero, false
}

func (p *Qos) MustOutboundAverageUpperlimit() int64 {
	if p.outboundAverageUpperlimit == nil {
		panic("the outboundAverageUpperlimit must not be nil, please use OutboundAverageUpperlimit() function instead")
	}
	return *p.outboundAverageUpperlimit
}

func (p *Qos) SetOutboundBurst(attr int64) {
	p.outboundBurst = &attr
}

func (p *Qos) OutboundBurst() (int64, bool) {
	if p.outboundBurst != nil {
		return *p.outboundBurst, true
	}
	var zero int64
	return zero, false
}

func (p *Qos) MustOutboundBurst() int64 {
	if p.outboundBurst == nil {
		panic("the outboundBurst must not be nil, please use OutboundBurst() function instead")
	}
	return *p.outboundBurst
}

func (p *Qos) SetOutboundPeak(attr int64) {
	p.outboundPeak = &attr
}

func (p *Qos) OutboundPeak() (int64, bool) {
	if p.outboundPeak != nil {
		return *p.outboundPeak, true
	}
	var zero int64
	return zero, false
}

func (p *Qos) MustOutboundPeak() int64 {
	if p.outboundPeak == nil {
		panic("the outboundPeak must not be nil, please use OutboundPeak() function instead")
	}
	return *p.outboundPeak
}

// SetType This type represents the kind of resource the <<types/qos,Quality of service (QoS)>> can be assigned to.
func (p *Qos) SetType(attr QosType) {
	p.type_ = &attr
}

// Type This type represents the kind of resource the <<types/qos,Quality of service (QoS)>> can be assigned to.
func (p *Qos) Type() (QosType, bool) {
	if p.type_ != nil {
		return *p.type_, true
	}
	var zero QosType
	return zero, false
}

// MustType This type represents the kind of resource the <<types/qos,Quality of service (QoS)>> can be assigned to.
func (p *Qos) MustType() QosType {
	if p.type_ == nil {
		panic("the type_ must not be nil, please use Type() function instead")
	}
	return *p.type_
}

// Quota Represents a quota object.
//
// An example XML representation of a quota:
//
// [source,xml]
// ----
// <quota href="/ovirt-engine/api/datacenters/7044934e/quotas/dcad5ddc" id="dcad5ddc">
//   <name>My Quota</name>
//   <description>A quota for my oVirt environment</description>
//   <cluster_hard_limit_pct>0</cluster_hard_limit_pct>
//   <cluster_soft_limit_pct>0</cluster_soft_limit_pct>
//   <data_center href="/ovirt-engine/api/datacenters/7044934e" id="7044934e"/>
//   <storage_hard_limit_pct>0</storage_hard_limit_pct>
//   <storage_soft_limit_pct>0</storage_soft_limit_pct>
// </quota>
// ----
type Quota struct {
	Struct
	clusterHardLimitPct *int64
	clusterSoftLimitPct *int64
	comment             *string
	dataCenter          *DataCenter
	description         *string
	disks               *DiskSlice
	id                  *string
	name                *string
	permissions         *PermissionSlice
	quotaClusterLimits  *QuotaClusterLimitSlice
	quotaStorageLimits  *QuotaStorageLimitSlice
	storageHardLimitPct *int64
	storageSoftLimitPct *int64
	users               *UserSlice
	vms                 *VmSlice
}

func (p *Quota) SetClusterHardLimitPct(attr int64) {
	p.clusterHardLimitPct = &attr
}

func (p *Quota) ClusterHardLimitPct() (int64, bool) {
	if p.clusterHardLimitPct != nil {
		return *p.clusterHardLimitPct, true
	}
	var zero int64
	return zero, false
}

func (p *Quota) MustClusterHardLimitPct() int64 {
	if p.clusterHardLimitPct == nil {
		panic("the clusterHardLimitPct must not be nil, please use ClusterHardLimitPct() function instead")
	}
	return *p.clusterHardLimitPct
}

func (p *Quota) SetClusterSoftLimitPct(attr int64) {
	p.clusterSoftLimitPct = &attr
}

func (p *Quota) ClusterSoftLimitPct() (int64, bool) {
	if p.clusterSoftLimitPct != nil {
		return *p.clusterSoftLimitPct, true
	}
	var zero int64
	return zero, false
}

func (p *Quota) MustClusterSoftLimitPct() int64 {
	if p.clusterSoftLimitPct == nil {
		panic("the clusterSoftLimitPct must not be nil, please use ClusterSoftLimitPct() function instead")
	}
	return *p.clusterSoftLimitPct
}

func (p *Quota) SetComment(attr string) {
	p.comment = &attr
}

func (p *Quota) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *Quota) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *Quota) SetDataCenter(attr *DataCenter) {
	p.dataCenter = attr
}

func (p *Quota) DataCenter() (*DataCenter, bool) {
	if p.dataCenter != nil {
		return p.dataCenter, true
	}
	return nil, false
}

func (p *Quota) MustDataCenter() *DataCenter {
	if p.dataCenter == nil {
		panic("the dataCenter must not be nil, please use DataCenter() function instead")
	}
	return p.dataCenter
}

func (p *Quota) SetDescription(attr string) {
	p.description = &attr
}

func (p *Quota) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *Quota) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *Quota) SetDisks(attr *DiskSlice) {
	p.disks = attr
}

func (p *Quota) Disks() (*DiskSlice, bool) {
	if p.disks != nil {
		return p.disks, true
	}
	return nil, false
}

func (p *Quota) MustDisks() *DiskSlice {
	if p.disks == nil {
		panic("the disks must not be nil, please use Disks() function instead")
	}
	return p.disks
}

func (p *Quota) SetId(attr string) {
	p.id = &attr
}

func (p *Quota) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *Quota) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *Quota) SetName(attr string) {
	p.name = &attr
}

func (p *Quota) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *Quota) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *Quota) SetPermissions(attr *PermissionSlice) {
	p.permissions = attr
}

func (p *Quota) Permissions() (*PermissionSlice, bool) {
	if p.permissions != nil {
		return p.permissions, true
	}
	return nil, false
}

func (p *Quota) MustPermissions() *PermissionSlice {
	if p.permissions == nil {
		panic("the permissions must not be nil, please use Permissions() function instead")
	}
	return p.permissions
}

func (p *Quota) SetQuotaClusterLimits(attr *QuotaClusterLimitSlice) {
	p.quotaClusterLimits = attr
}

func (p *Quota) QuotaClusterLimits() (*QuotaClusterLimitSlice, bool) {
	if p.quotaClusterLimits != nil {
		return p.quotaClusterLimits, true
	}
	return nil, false
}

func (p *Quota) MustQuotaClusterLimits() *QuotaClusterLimitSlice {
	if p.quotaClusterLimits == nil {
		panic("the quotaClusterLimits must not be nil, please use QuotaClusterLimits() function instead")
	}
	return p.quotaClusterLimits
}

func (p *Quota) SetQuotaStorageLimits(attr *QuotaStorageLimitSlice) {
	p.quotaStorageLimits = attr
}

func (p *Quota) QuotaStorageLimits() (*QuotaStorageLimitSlice, bool) {
	if p.quotaStorageLimits != nil {
		return p.quotaStorageLimits, true
	}
	return nil, false
}

func (p *Quota) MustQuotaStorageLimits() *QuotaStorageLimitSlice {
	if p.quotaStorageLimits == nil {
		panic("the quotaStorageLimits must not be nil, please use QuotaStorageLimits() function instead")
	}
	return p.quotaStorageLimits
}

func (p *Quota) SetStorageHardLimitPct(attr int64) {
	p.storageHardLimitPct = &attr
}

func (p *Quota) StorageHardLimitPct() (int64, bool) {
	if p.storageHardLimitPct != nil {
		return *p.storageHardLimitPct, true
	}
	var zero int64
	return zero, false
}

func (p *Quota) MustStorageHardLimitPct() int64 {
	if p.storageHardLimitPct == nil {
		panic("the storageHardLimitPct must not be nil, please use StorageHardLimitPct() function instead")
	}
	return *p.storageHardLimitPct
}

func (p *Quota) SetStorageSoftLimitPct(attr int64) {
	p.storageSoftLimitPct = &attr
}

func (p *Quota) StorageSoftLimitPct() (int64, bool) {
	if p.storageSoftLimitPct != nil {
		return *p.storageSoftLimitPct, true
	}
	var zero int64
	return zero, false
}

func (p *Quota) MustStorageSoftLimitPct() int64 {
	if p.storageSoftLimitPct == nil {
		panic("the storageSoftLimitPct must not be nil, please use StorageSoftLimitPct() function instead")
	}
	return *p.storageSoftLimitPct
}

func (p *Quota) SetUsers(attr *UserSlice) {
	p.users = attr
}

func (p *Quota) Users() (*UserSlice, bool) {
	if p.users != nil {
		return p.users, true
	}
	return nil, false
}

func (p *Quota) MustUsers() *UserSlice {
	if p.users == nil {
		panic("the users must not be nil, please use Users() function instead")
	}
	return p.users
}

func (p *Quota) SetVms(attr *VmSlice) {
	p.vms = attr
}

func (p *Quota) Vms() (*VmSlice, bool) {
	if p.vms != nil {
		return p.vms, true
	}
	return nil, false
}

func (p *Quota) MustVms() *VmSlice {
	if p.vms == nil {
		panic("the vms must not be nil, please use Vms() function instead")
	}
	return p.vms
}

type QuotaClusterLimit struct {
	Struct
	cluster     *Cluster
	comment     *string
	description *string
	id          *string
	memoryLimit *float64
	memoryUsage *float64
	name        *string
	quota       *Quota
	vcpuLimit   *int64
	vcpuUsage   *int64
}

// SetCluster Type representation of a cluster.
//
// A JSON representation of a cluster:
//
// [source]
// ----
// {
//   "cluster" : [ {
//     "ballooning_enabled" : "false",
//     "cpu" : {
//       "architecture" : "x86_64",
//       "type" : "Intel SandyBridge Family"
//     },
//     "custom_scheduling_policy_properties" : {
//       "property" : [ {
//         "name" : "HighUtilization",
//         "value" : "80"
//       }, {
//         "name" : "CpuOverCommitDurationMinutes",
//         "value" : "2"
//       } ]
//     },
//     "error_handling" : {
//       "on_error" : "migrate"
//     },
//     "fencing_policy" : {
//       "enabled" : "true",
//       "skip_if_connectivity_broken" : {
//         "enabled" : "false",
//         "threshold" : "50"
//       },
//       "skip_if_gluster_bricks_up" : "false",
//       "skip_if_gluster_quorum_not_met" : "false",
//       "skip_if_sd_active" : {
//         "enabled" : "false"
//       }
//     },
//     "gluster_service" : "false",
//     "firewall_type" : "iptables",
//     "ha_reservation" : "false",
//     "ksm" : {
//       "enabled" : "true",
//       "merge_across_nodes" : "true"
//     },
//     "memory_policy" : {
//       "over_commit" : {
//         "percent" : "100"
//       },
//       "transparent_hugepages" : {
//         "enabled" : "true"
//       }
//     },
//     "migration" : {
//       "auto_converge" : "inherit",
//       "bandwidth" : {
//         "assignment_method" : "auto"
//       },
//       "compressed" : "inherit",
//       "policy" : {
//         "id" : "00000000-0000-0000-0000-000000000000"
//       }
//     },
//     "required_rng_sources" : {
//       "required_rng_source" : [ "random" ]
//     },
//     "switch_type" : "legacy",
//     "threads_as_cores" : "false",
//     "trusted_service" : "false",
//     "tunnel_migration" : "false",
//     "version" : {
//       "major" : "4",
//       "minor" : "1"
//     },
//     "virt_service" : "true",
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "mac_pool" : {
//       "href" : "/ovirt-engine/api/macpools/456",
//       "id" : "456"
//     },
//     "scheduling_policy" : {
//       "href" : "/ovirt-engine/api/schedulingpolicies/789",
//       "id" : "789"
//     },
//     "actions" : {
//       "link" : [ {
//         "href" : "/ovirt-engine/api/clusters/234/resetemulatedmachine",
//         "rel" : "resetemulatedmachine"
//       } ]
//     },
//     "name" : "Default",
//     "description" : "The default server cluster",
//     "href" : "/ovirt-engine/api/clusters/234",
//     "id" : "234",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/clusters/234/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/cpuprofiles",
//       "rel" : "cpuprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networkfilters",
//       "rel" : "networkfilters"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networks",
//       "rel" : "networks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/affinitygroups",
//       "rel" : "affinitygroups"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glusterhooks",
//       "rel" : "glusterhooks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glustervolumes",
//       "rel" : "glustervolumes"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/enabledfeatures",
//       "rel" : "enabledfeatures"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/externalnetworkproviders",
//       "rel" : "externalnetworkproviders"
//     } ]
//   } ]
// }
// ----
func (p *QuotaClusterLimit) SetCluster(attr *Cluster) {
	p.cluster = attr
}

// Cluster Type representation of a cluster.
//
// A JSON representation of a cluster:
//
// [source]
// ----
// {
//   "cluster" : [ {
//     "ballooning_enabled" : "false",
//     "cpu" : {
//       "architecture" : "x86_64",
//       "type" : "Intel SandyBridge Family"
//     },
//     "custom_scheduling_policy_properties" : {
//       "property" : [ {
//         "name" : "HighUtilization",
//         "value" : "80"
//       }, {
//         "name" : "CpuOverCommitDurationMinutes",
//         "value" : "2"
//       } ]
//     },
//     "error_handling" : {
//       "on_error" : "migrate"
//     },
//     "fencing_policy" : {
//       "enabled" : "true",
//       "skip_if_connectivity_broken" : {
//         "enabled" : "false",
//         "threshold" : "50"
//       },
//       "skip_if_gluster_bricks_up" : "false",
//       "skip_if_gluster_quorum_not_met" : "false",
//       "skip_if_sd_active" : {
//         "enabled" : "false"
//       }
//     },
//     "gluster_service" : "false",
//     "firewall_type" : "iptables",
//     "ha_reservation" : "false",
//     "ksm" : {
//       "enabled" : "true",
//       "merge_across_nodes" : "true"
//     },
//     "memory_policy" : {
//       "over_commit" : {
//         "percent" : "100"
//       },
//       "transparent_hugepages" : {
//         "enabled" : "true"
//       }
//     },
//     "migration" : {
//       "auto_converge" : "inherit",
//       "bandwidth" : {
//         "assignment_method" : "auto"
//       },
//       "compressed" : "inherit",
//       "policy" : {
//         "id" : "00000000-0000-0000-0000-000000000000"
//       }
//     },
//     "required_rng_sources" : {
//       "required_rng_source" : [ "random" ]
//     },
//     "switch_type" : "legacy",
//     "threads_as_cores" : "false",
//     "trusted_service" : "false",
//     "tunnel_migration" : "false",
//     "version" : {
//       "major" : "4",
//       "minor" : "1"
//     },
//     "virt_service" : "true",
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "mac_pool" : {
//       "href" : "/ovirt-engine/api/macpools/456",
//       "id" : "456"
//     },
//     "scheduling_policy" : {
//       "href" : "/ovirt-engine/api/schedulingpolicies/789",
//       "id" : "789"
//     },
//     "actions" : {
//       "link" : [ {
//         "href" : "/ovirt-engine/api/clusters/234/resetemulatedmachine",
//         "rel" : "resetemulatedmachine"
//       } ]
//     },
//     "name" : "Default",
//     "description" : "The default server cluster",
//     "href" : "/ovirt-engine/api/clusters/234",
//     "id" : "234",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/clusters/234/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/cpuprofiles",
//       "rel" : "cpuprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networkfilters",
//       "rel" : "networkfilters"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networks",
//       "rel" : "networks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/affinitygroups",
//       "rel" : "affinitygroups"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glusterhooks",
//       "rel" : "glusterhooks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glustervolumes",
//       "rel" : "glustervolumes"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/enabledfeatures",
//       "rel" : "enabledfeatures"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/externalnetworkproviders",
//       "rel" : "externalnetworkproviders"
//     } ]
//   } ]
// }
// ----
func (p *QuotaClusterLimit) Cluster() (*Cluster, bool) {
	if p.cluster != nil {
		return p.cluster, true
	}
	return nil, false
}

// MustCluster Type representation of a cluster.
//
// A JSON representation of a cluster:
//
// [source]
// ----
// {
//   "cluster" : [ {
//     "ballooning_enabled" : "false",
//     "cpu" : {
//       "architecture" : "x86_64",
//       "type" : "Intel SandyBridge Family"
//     },
//     "custom_scheduling_policy_properties" : {
//       "property" : [ {
//         "name" : "HighUtilization",
//         "value" : "80"
//       }, {
//         "name" : "CpuOverCommitDurationMinutes",
//         "value" : "2"
//       } ]
//     },
//     "error_handling" : {
//       "on_error" : "migrate"
//     },
//     "fencing_policy" : {
//       "enabled" : "true",
//       "skip_if_connectivity_broken" : {
//         "enabled" : "false",
//         "threshold" : "50"
//       },
//       "skip_if_gluster_bricks_up" : "false",
//       "skip_if_gluster_quorum_not_met" : "false",
//       "skip_if_sd_active" : {
//         "enabled" : "false"
//       }
//     },
//     "gluster_service" : "false",
//     "firewall_type" : "iptables",
//     "ha_reservation" : "false",
//     "ksm" : {
//       "enabled" : "true",
//       "merge_across_nodes" : "true"
//     },
//     "memory_policy" : {
//       "over_commit" : {
//         "percent" : "100"
//       },
//       "transparent_hugepages" : {
//         "enabled" : "true"
//       }
//     },
//     "migration" : {
//       "auto_converge" : "inherit",
//       "bandwidth" : {
//         "assignment_method" : "auto"
//       },
//       "compressed" : "inherit",
//       "policy" : {
//         "id" : "00000000-0000-0000-0000-000000000000"
//       }
//     },
//     "required_rng_sources" : {
//       "required_rng_source" : [ "random" ]
//     },
//     "switch_type" : "legacy",
//     "threads_as_cores" : "false",
//     "trusted_service" : "false",
//     "tunnel_migration" : "false",
//     "version" : {
//       "major" : "4",
//       "minor" : "1"
//     },
//     "virt_service" : "true",
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "mac_pool" : {
//       "href" : "/ovirt-engine/api/macpools/456",
//       "id" : "456"
//     },
//     "scheduling_policy" : {
//       "href" : "/ovirt-engine/api/schedulingpolicies/789",
//       "id" : "789"
//     },
//     "actions" : {
//       "link" : [ {
//         "href" : "/ovirt-engine/api/clusters/234/resetemulatedmachine",
//         "rel" : "resetemulatedmachine"
//       } ]
//     },
//     "name" : "Default",
//     "description" : "The default server cluster",
//     "href" : "/ovirt-engine/api/clusters/234",
//     "id" : "234",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/clusters/234/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/cpuprofiles",
//       "rel" : "cpuprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networkfilters",
//       "rel" : "networkfilters"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networks",
//       "rel" : "networks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/affinitygroups",
//       "rel" : "affinitygroups"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glusterhooks",
//       "rel" : "glusterhooks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glustervolumes",
//       "rel" : "glustervolumes"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/enabledfeatures",
//       "rel" : "enabledfeatures"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/externalnetworkproviders",
//       "rel" : "externalnetworkproviders"
//     } ]
//   } ]
// }
// ----
func (p *QuotaClusterLimit) MustCluster() *Cluster {
	if p.cluster == nil {
		panic("the cluster must not be nil, please use Cluster() function instead")
	}
	return p.cluster
}

func (p *QuotaClusterLimit) SetComment(attr string) {
	p.comment = &attr
}

func (p *QuotaClusterLimit) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *QuotaClusterLimit) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *QuotaClusterLimit) SetDescription(attr string) {
	p.description = &attr
}

func (p *QuotaClusterLimit) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *QuotaClusterLimit) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *QuotaClusterLimit) SetId(attr string) {
	p.id = &attr
}

func (p *QuotaClusterLimit) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *QuotaClusterLimit) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *QuotaClusterLimit) SetMemoryLimit(attr float64) {
	p.memoryLimit = &attr
}

func (p *QuotaClusterLimit) MemoryLimit() (float64, bool) {
	if p.memoryLimit != nil {
		return *p.memoryLimit, true
	}
	var zero float64
	return zero, false
}

func (p *QuotaClusterLimit) MustMemoryLimit() float64 {
	if p.memoryLimit == nil {
		panic("the memoryLimit must not be nil, please use MemoryLimit() function instead")
	}
	return *p.memoryLimit
}

func (p *QuotaClusterLimit) SetMemoryUsage(attr float64) {
	p.memoryUsage = &attr
}

func (p *QuotaClusterLimit) MemoryUsage() (float64, bool) {
	if p.memoryUsage != nil {
		return *p.memoryUsage, true
	}
	var zero float64
	return zero, false
}

func (p *QuotaClusterLimit) MustMemoryUsage() float64 {
	if p.memoryUsage == nil {
		panic("the memoryUsage must not be nil, please use MemoryUsage() function instead")
	}
	return *p.memoryUsage
}

func (p *QuotaClusterLimit) SetName(attr string) {
	p.name = &attr
}

func (p *QuotaClusterLimit) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *QuotaClusterLimit) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

// SetQuota Represents a quota object.
//
// An example XML representation of a quota:
//
// [source,xml]
// ----
// <quota href="/ovirt-engine/api/datacenters/7044934e/quotas/dcad5ddc" id="dcad5ddc">
//   <name>My Quota</name>
//   <description>A quota for my oVirt environment</description>
//   <cluster_hard_limit_pct>0</cluster_hard_limit_pct>
//   <cluster_soft_limit_pct>0</cluster_soft_limit_pct>
//   <data_center href="/ovirt-engine/api/datacenters/7044934e" id="7044934e"/>
//   <storage_hard_limit_pct>0</storage_hard_limit_pct>
//   <storage_soft_limit_pct>0</storage_soft_limit_pct>
// </quota>
// ----
func (p *QuotaClusterLimit) SetQuota(attr *Quota) {
	p.quota = attr
}

// Quota Represents a quota object.
//
// An example XML representation of a quota:
//
// [source,xml]
// ----
// <quota href="/ovirt-engine/api/datacenters/7044934e/quotas/dcad5ddc" id="dcad5ddc">
//   <name>My Quota</name>
//   <description>A quota for my oVirt environment</description>
//   <cluster_hard_limit_pct>0</cluster_hard_limit_pct>
//   <cluster_soft_limit_pct>0</cluster_soft_limit_pct>
//   <data_center href="/ovirt-engine/api/datacenters/7044934e" id="7044934e"/>
//   <storage_hard_limit_pct>0</storage_hard_limit_pct>
//   <storage_soft_limit_pct>0</storage_soft_limit_pct>
// </quota>
// ----
func (p *QuotaClusterLimit) Quota() (*Quota, bool) {
	if p.quota != nil {
		return p.quota, true
	}
	return nil, false
}

// MustQuota Represents a quota object.
//
// An example XML representation of a quota:
//
// [source,xml]
// ----
// <quota href="/ovirt-engine/api/datacenters/7044934e/quotas/dcad5ddc" id="dcad5ddc">
//   <name>My Quota</name>
//   <description>A quota for my oVirt environment</description>
//   <cluster_hard_limit_pct>0</cluster_hard_limit_pct>
//   <cluster_soft_limit_pct>0</cluster_soft_limit_pct>
//   <data_center href="/ovirt-engine/api/datacenters/7044934e" id="7044934e"/>
//   <storage_hard_limit_pct>0</storage_hard_limit_pct>
//   <storage_soft_limit_pct>0</storage_soft_limit_pct>
// </quota>
// ----
func (p *QuotaClusterLimit) MustQuota() *Quota {
	if p.quota == nil {
		panic("the quota must not be nil, please use Quota() function instead")
	}
	return p.quota
}

func (p *QuotaClusterLimit) SetVcpuLimit(attr int64) {
	p.vcpuLimit = &attr
}

func (p *QuotaClusterLimit) VcpuLimit() (int64, bool) {
	if p.vcpuLimit != nil {
		return *p.vcpuLimit, true
	}
	var zero int64
	return zero, false
}

func (p *QuotaClusterLimit) MustVcpuLimit() int64 {
	if p.vcpuLimit == nil {
		panic("the vcpuLimit must not be nil, please use VcpuLimit() function instead")
	}
	return *p.vcpuLimit
}

func (p *QuotaClusterLimit) SetVcpuUsage(attr int64) {
	p.vcpuUsage = &attr
}

func (p *QuotaClusterLimit) VcpuUsage() (int64, bool) {
	if p.vcpuUsage != nil {
		return *p.vcpuUsage, true
	}
	var zero int64
	return zero, false
}

func (p *QuotaClusterLimit) MustVcpuUsage() int64 {
	if p.vcpuUsage == nil {
		panic("the vcpuUsage must not be nil, please use VcpuUsage() function instead")
	}
	return *p.vcpuUsage
}

type QuotaStorageLimit struct {
	Struct
	comment       *string
	description   *string
	id            *string
	limit         *int64
	name          *string
	quota         *Quota
	storageDomain *StorageDomain
	usage         *float64
}

func (p *QuotaStorageLimit) SetComment(attr string) {
	p.comment = &attr
}

func (p *QuotaStorageLimit) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *QuotaStorageLimit) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *QuotaStorageLimit) SetDescription(attr string) {
	p.description = &attr
}

func (p *QuotaStorageLimit) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *QuotaStorageLimit) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *QuotaStorageLimit) SetId(attr string) {
	p.id = &attr
}

func (p *QuotaStorageLimit) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *QuotaStorageLimit) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *QuotaStorageLimit) SetLimit(attr int64) {
	p.limit = &attr
}

func (p *QuotaStorageLimit) Limit() (int64, bool) {
	if p.limit != nil {
		return *p.limit, true
	}
	var zero int64
	return zero, false
}

func (p *QuotaStorageLimit) MustLimit() int64 {
	if p.limit == nil {
		panic("the limit must not be nil, please use Limit() function instead")
	}
	return *p.limit
}

func (p *QuotaStorageLimit) SetName(attr string) {
	p.name = &attr
}

func (p *QuotaStorageLimit) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *QuotaStorageLimit) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

// SetQuota Represents a quota object.
//
// An example XML representation of a quota:
//
// [source,xml]
// ----
// <quota href="/ovirt-engine/api/datacenters/7044934e/quotas/dcad5ddc" id="dcad5ddc">
//   <name>My Quota</name>
//   <description>A quota for my oVirt environment</description>
//   <cluster_hard_limit_pct>0</cluster_hard_limit_pct>
//   <cluster_soft_limit_pct>0</cluster_soft_limit_pct>
//   <data_center href="/ovirt-engine/api/datacenters/7044934e" id="7044934e"/>
//   <storage_hard_limit_pct>0</storage_hard_limit_pct>
//   <storage_soft_limit_pct>0</storage_soft_limit_pct>
// </quota>
// ----
func (p *QuotaStorageLimit) SetQuota(attr *Quota) {
	p.quota = attr
}

// Quota Represents a quota object.
//
// An example XML representation of a quota:
//
// [source,xml]
// ----
// <quota href="/ovirt-engine/api/datacenters/7044934e/quotas/dcad5ddc" id="dcad5ddc">
//   <name>My Quota</name>
//   <description>A quota for my oVirt environment</description>
//   <cluster_hard_limit_pct>0</cluster_hard_limit_pct>
//   <cluster_soft_limit_pct>0</cluster_soft_limit_pct>
//   <data_center href="/ovirt-engine/api/datacenters/7044934e" id="7044934e"/>
//   <storage_hard_limit_pct>0</storage_hard_limit_pct>
//   <storage_soft_limit_pct>0</storage_soft_limit_pct>
// </quota>
// ----
func (p *QuotaStorageLimit) Quota() (*Quota, bool) {
	if p.quota != nil {
		return p.quota, true
	}
	return nil, false
}

// MustQuota Represents a quota object.
//
// An example XML representation of a quota:
//
// [source,xml]
// ----
// <quota href="/ovirt-engine/api/datacenters/7044934e/quotas/dcad5ddc" id="dcad5ddc">
//   <name>My Quota</name>
//   <description>A quota for my oVirt environment</description>
//   <cluster_hard_limit_pct>0</cluster_hard_limit_pct>
//   <cluster_soft_limit_pct>0</cluster_soft_limit_pct>
//   <data_center href="/ovirt-engine/api/datacenters/7044934e" id="7044934e"/>
//   <storage_hard_limit_pct>0</storage_hard_limit_pct>
//   <storage_soft_limit_pct>0</storage_soft_limit_pct>
// </quota>
// ----
func (p *QuotaStorageLimit) MustQuota() *Quota {
	if p.quota == nil {
		panic("the quota must not be nil, please use Quota() function instead")
	}
	return p.quota
}

// SetStorageDomain Storage domain.
//
// An XML representation of a NFS storage domain with identifier `123`:
//
// [source,xml]
// ----
// <storage_domain href="/ovirt-engine/api/storagedomains/123" id="123">
//   <name>mydata</name>
//   <description>My data</description>
//   <available>38654705664</available>
//   <committed>1073741824</committed>
//   <critical_space_action_blocker>5</critical_space_action_blocker>
//   <external_status>ok</external_status>
//   <master>true</master>
//   <storage>
//     <address>mynfs.example.com</address>
//     <nfs_version>v3</nfs_version>
//     <path>/exports/mydata</path>
//     <type>nfs</type>
//   </storage>
//   <storage_format>v3</storage_format>
//   <type>data</type>
//   <used>13958643712</used>
//   <warning_low_space_indicator>10</warning_low_space_indicator>
//   <wipe_after_delete>false</wipe_after_delete>
//   <data_centers>
//     <data_center href="/ovirt-engine/api/datacenters/456" id="456"/>
//   </data_centers>
// </storage_domain>
// ----
func (p *QuotaStorageLimit) SetStorageDomain(attr *StorageDomain) {
	p.storageDomain = attr
}

// StorageDomain Storage domain.
//
// An XML representation of a NFS storage domain with identifier `123`:
//
// [source,xml]
// ----
// <storage_domain href="/ovirt-engine/api/storagedomains/123" id="123">
//   <name>mydata</name>
//   <description>My data</description>
//   <available>38654705664</available>
//   <committed>1073741824</committed>
//   <critical_space_action_blocker>5</critical_space_action_blocker>
//   <external_status>ok</external_status>
//   <master>true</master>
//   <storage>
//     <address>mynfs.example.com</address>
//     <nfs_version>v3</nfs_version>
//     <path>/exports/mydata</path>
//     <type>nfs</type>
//   </storage>
//   <storage_format>v3</storage_format>
//   <type>data</type>
//   <used>13958643712</used>
//   <warning_low_space_indicator>10</warning_low_space_indicator>
//   <wipe_after_delete>false</wipe_after_delete>
//   <data_centers>
//     <data_center href="/ovirt-engine/api/datacenters/456" id="456"/>
//   </data_centers>
// </storage_domain>
// ----
func (p *QuotaStorageLimit) StorageDomain() (*StorageDomain, bool) {
	if p.storageDomain != nil {
		return p.storageDomain, true
	}
	return nil, false
}

// MustStorageDomain Storage domain.
//
// An XML representation of a NFS storage domain with identifier `123`:
//
// [source,xml]
// ----
// <storage_domain href="/ovirt-engine/api/storagedomains/123" id="123">
//   <name>mydata</name>
//   <description>My data</description>
//   <available>38654705664</available>
//   <committed>1073741824</committed>
//   <critical_space_action_blocker>5</critical_space_action_blocker>
//   <external_status>ok</external_status>
//   <master>true</master>
//   <storage>
//     <address>mynfs.example.com</address>
//     <nfs_version>v3</nfs_version>
//     <path>/exports/mydata</path>
//     <type>nfs</type>
//   </storage>
//   <storage_format>v3</storage_format>
//   <type>data</type>
//   <used>13958643712</used>
//   <warning_low_space_indicator>10</warning_low_space_indicator>
//   <wipe_after_delete>false</wipe_after_delete>
//   <data_centers>
//     <data_center href="/ovirt-engine/api/datacenters/456" id="456"/>
//   </data_centers>
// </storage_domain>
// ----
func (p *QuotaStorageLimit) MustStorageDomain() *StorageDomain {
	if p.storageDomain == nil {
		panic("the storageDomain must not be nil, please use StorageDomain() function instead")
	}
	return p.storageDomain
}

func (p *QuotaStorageLimit) SetUsage(attr float64) {
	p.usage = &attr
}

func (p *QuotaStorageLimit) Usage() (float64, bool) {
	if p.usage != nil {
		return *p.usage, true
	}
	var zero float64
	return zero, false
}

func (p *QuotaStorageLimit) MustUsage() float64 {
	if p.usage == nil {
		panic("the usage must not be nil, please use Usage() function instead")
	}
	return *p.usage
}

type Range struct {
	Struct
	from *string
	to   *string
}

func (p *Range) SetFrom(attr string) {
	p.from = &attr
}

func (p *Range) From() (string, bool) {
	if p.from != nil {
		return *p.from, true
	}
	var zero string
	return zero, false
}

func (p *Range) MustFrom() string {
	if p.from == nil {
		panic("the from must not be nil, please use From() function instead")
	}
	return *p.from
}

func (p *Range) SetTo(attr string) {
	p.to = &attr
}

func (p *Range) To() (string, bool) {
	if p.to != nil {
		return *p.to, true
	}
	var zero string
	return zero, false
}

func (p *Range) MustTo() string {
	if p.to == nil {
		panic("the to must not be nil, please use To() function instead")
	}
	return *p.to
}

// Rate Determines maximum speed of consumption of bytes from random number generator device.
type Rate struct {
	Struct
	bytes  *int64
	period *int64
}

func (p *Rate) SetBytes(attr int64) {
	p.bytes = &attr
}

func (p *Rate) Bytes() (int64, bool) {
	if p.bytes != nil {
		return *p.bytes, true
	}
	var zero int64
	return zero, false
}

func (p *Rate) MustBytes() int64 {
	if p.bytes == nil {
		panic("the bytes must not be nil, please use Bytes() function instead")
	}
	return *p.bytes
}

func (p *Rate) SetPeriod(attr int64) {
	p.period = &attr
}

func (p *Rate) Period() (int64, bool) {
	if p.period != nil {
		return *p.period, true
	}
	var zero int64
	return zero, false
}

func (p *Rate) MustPeriod() int64 {
	if p.period == nil {
		panic("the period must not be nil, please use Period() function instead")
	}
	return *p.period
}

// RegistrationAffinityGroupMapping This type describes how to map affinity groups as part of the object registration. An object can be
// a virtual machine, template, etc.
//
// An example of an XML representation using this mapping:
//
// [source,xml]
// ----
// <action>
//   <registration_configuration>
//     <affinity_group_mappings>
//      <registration_affinity_group_mapping>
//        <from>
//          <name>affinity</name>
//        </from>
//        <to>
//          <name>affinity2</name>
//        </to>
//      </registration_affinity_group_mapping>
//     </affinity_group_mappings>
//   </registration_configuration>
// </action>
// ----
type RegistrationAffinityGroupMapping struct {
	Struct
	from *AffinityGroup
	to   *AffinityGroup
}

// SetFrom An affinity group represents a group of virtual machines with a defined relationship.
func (p *RegistrationAffinityGroupMapping) SetFrom(attr *AffinityGroup) {
	p.from = attr
}

// From An affinity group represents a group of virtual machines with a defined relationship.
func (p *RegistrationAffinityGroupMapping) From() (*AffinityGroup, bool) {
	if p.from != nil {
		return p.from, true
	}
	return nil, false
}

// MustFrom An affinity group represents a group of virtual machines with a defined relationship.
func (p *RegistrationAffinityGroupMapping) MustFrom() *AffinityGroup {
	if p.from == nil {
		panic("the from must not be nil, please use From() function instead")
	}
	return p.from
}

// SetTo An affinity group represents a group of virtual machines with a defined relationship.
func (p *RegistrationAffinityGroupMapping) SetTo(attr *AffinityGroup) {
	p.to = attr
}

// To An affinity group represents a group of virtual machines with a defined relationship.
func (p *RegistrationAffinityGroupMapping) To() (*AffinityGroup, bool) {
	if p.to != nil {
		return p.to, true
	}
	return nil, false
}

// MustTo An affinity group represents a group of virtual machines with a defined relationship.
func (p *RegistrationAffinityGroupMapping) MustTo() *AffinityGroup {
	if p.to == nil {
		panic("the to must not be nil, please use To() function instead")
	}
	return p.to
}

// RegistrationAffinityLabelMapping This type describes how to map affinity labels as part of the object registration. An object can be
// a virtual machine, template, etc.
//
// An example of an XML representation using mapping:
//
// [source,xml]
// ----
// <action>
//   <registration_configuration>
//     <affinity_label_mappings>
//      <registration_affinity_label_mapping>
//        <from>
//          <name>affinity_label</name>
//        </from>
//        <to>
//          <name>affinity_label2</name>
//        </to>
//      </registration_affinity_label_mapping>
//     </affinity_label_mappings>
//   </registration_configuration>
// </action>
// ----
type RegistrationAffinityLabelMapping struct {
	Struct
	from *AffinityLabel
	to   *AffinityLabel
}

// SetFrom The affinity label can influence virtual machine scheduling.
// It is most frequently used to create a sub-cluster from the available hosts.
func (p *RegistrationAffinityLabelMapping) SetFrom(attr *AffinityLabel) {
	p.from = attr
}

// From The affinity label can influence virtual machine scheduling.
// It is most frequently used to create a sub-cluster from the available hosts.
func (p *RegistrationAffinityLabelMapping) From() (*AffinityLabel, bool) {
	if p.from != nil {
		return p.from, true
	}
	return nil, false
}

// MustFrom The affinity label can influence virtual machine scheduling.
// It is most frequently used to create a sub-cluster from the available hosts.
func (p *RegistrationAffinityLabelMapping) MustFrom() *AffinityLabel {
	if p.from == nil {
		panic("the from must not be nil, please use From() function instead")
	}
	return p.from
}

// SetTo The affinity label can influence virtual machine scheduling.
// It is most frequently used to create a sub-cluster from the available hosts.
func (p *RegistrationAffinityLabelMapping) SetTo(attr *AffinityLabel) {
	p.to = attr
}

// To The affinity label can influence virtual machine scheduling.
// It is most frequently used to create a sub-cluster from the available hosts.
func (p *RegistrationAffinityLabelMapping) To() (*AffinityLabel, bool) {
	if p.to != nil {
		return p.to, true
	}
	return nil, false
}

// MustTo The affinity label can influence virtual machine scheduling.
// It is most frequently used to create a sub-cluster from the available hosts.
func (p *RegistrationAffinityLabelMapping) MustTo() *AffinityLabel {
	if p.to == nil {
		panic("the to must not be nil, please use To() function instead")
	}
	return p.to
}

// RegistrationClusterMapping This type describes how to map clusters as part of the object registration. An object can be
// a virtual machine, template, etc.
//
// An example of an XML representation using this mapping:
//
// [source,xml]
// ----
// <action>
//   <registration_configuration>
//     <cluster_mappings>
//       <registration_cluster_mapping>
//         <from>
//           <name>myoriginalcluster</name>
//         </from>
//         <to>
//           <name>mynewcluster</name>
//         </to>
//       </registration_cluster_mapping>
//     </cluster_mappings>
//   </registration_configuration>
// </action>
// ----
type RegistrationClusterMapping struct {
	Struct
	from *Cluster
	to   *Cluster
}

// SetFrom Type representation of a cluster.
//
// A JSON representation of a cluster:
//
// [source]
// ----
// {
//   "cluster" : [ {
//     "ballooning_enabled" : "false",
//     "cpu" : {
//       "architecture" : "x86_64",
//       "type" : "Intel SandyBridge Family"
//     },
//     "custom_scheduling_policy_properties" : {
//       "property" : [ {
//         "name" : "HighUtilization",
//         "value" : "80"
//       }, {
//         "name" : "CpuOverCommitDurationMinutes",
//         "value" : "2"
//       } ]
//     },
//     "error_handling" : {
//       "on_error" : "migrate"
//     },
//     "fencing_policy" : {
//       "enabled" : "true",
//       "skip_if_connectivity_broken" : {
//         "enabled" : "false",
//         "threshold" : "50"
//       },
//       "skip_if_gluster_bricks_up" : "false",
//       "skip_if_gluster_quorum_not_met" : "false",
//       "skip_if_sd_active" : {
//         "enabled" : "false"
//       }
//     },
//     "gluster_service" : "false",
//     "firewall_type" : "iptables",
//     "ha_reservation" : "false",
//     "ksm" : {
//       "enabled" : "true",
//       "merge_across_nodes" : "true"
//     },
//     "memory_policy" : {
//       "over_commit" : {
//         "percent" : "100"
//       },
//       "transparent_hugepages" : {
//         "enabled" : "true"
//       }
//     },
//     "migration" : {
//       "auto_converge" : "inherit",
//       "bandwidth" : {
//         "assignment_method" : "auto"
//       },
//       "compressed" : "inherit",
//       "policy" : {
//         "id" : "00000000-0000-0000-0000-000000000000"
//       }
//     },
//     "required_rng_sources" : {
//       "required_rng_source" : [ "random" ]
//     },
//     "switch_type" : "legacy",
//     "threads_as_cores" : "false",
//     "trusted_service" : "false",
//     "tunnel_migration" : "false",
//     "version" : {
//       "major" : "4",
//       "minor" : "1"
//     },
//     "virt_service" : "true",
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "mac_pool" : {
//       "href" : "/ovirt-engine/api/macpools/456",
//       "id" : "456"
//     },
//     "scheduling_policy" : {
//       "href" : "/ovirt-engine/api/schedulingpolicies/789",
//       "id" : "789"
//     },
//     "actions" : {
//       "link" : [ {
//         "href" : "/ovirt-engine/api/clusters/234/resetemulatedmachine",
//         "rel" : "resetemulatedmachine"
//       } ]
//     },
//     "name" : "Default",
//     "description" : "The default server cluster",
//     "href" : "/ovirt-engine/api/clusters/234",
//     "id" : "234",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/clusters/234/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/cpuprofiles",
//       "rel" : "cpuprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networkfilters",
//       "rel" : "networkfilters"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networks",
//       "rel" : "networks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/affinitygroups",
//       "rel" : "affinitygroups"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glusterhooks",
//       "rel" : "glusterhooks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glustervolumes",
//       "rel" : "glustervolumes"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/enabledfeatures",
//       "rel" : "enabledfeatures"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/externalnetworkproviders",
//       "rel" : "externalnetworkproviders"
//     } ]
//   } ]
// }
// ----
func (p *RegistrationClusterMapping) SetFrom(attr *Cluster) {
	p.from = attr
}

// From Type representation of a cluster.
//
// A JSON representation of a cluster:
//
// [source]
// ----
// {
//   "cluster" : [ {
//     "ballooning_enabled" : "false",
//     "cpu" : {
//       "architecture" : "x86_64",
//       "type" : "Intel SandyBridge Family"
//     },
//     "custom_scheduling_policy_properties" : {
//       "property" : [ {
//         "name" : "HighUtilization",
//         "value" : "80"
//       }, {
//         "name" : "CpuOverCommitDurationMinutes",
//         "value" : "2"
//       } ]
//     },
//     "error_handling" : {
//       "on_error" : "migrate"
//     },
//     "fencing_policy" : {
//       "enabled" : "true",
//       "skip_if_connectivity_broken" : {
//         "enabled" : "false",
//         "threshold" : "50"
//       },
//       "skip_if_gluster_bricks_up" : "false",
//       "skip_if_gluster_quorum_not_met" : "false",
//       "skip_if_sd_active" : {
//         "enabled" : "false"
//       }
//     },
//     "gluster_service" : "false",
//     "firewall_type" : "iptables",
//     "ha_reservation" : "false",
//     "ksm" : {
//       "enabled" : "true",
//       "merge_across_nodes" : "true"
//     },
//     "memory_policy" : {
//       "over_commit" : {
//         "percent" : "100"
//       },
//       "transparent_hugepages" : {
//         "enabled" : "true"
//       }
//     },
//     "migration" : {
//       "auto_converge" : "inherit",
//       "bandwidth" : {
//         "assignment_method" : "auto"
//       },
//       "compressed" : "inherit",
//       "policy" : {
//         "id" : "00000000-0000-0000-0000-000000000000"
//       }
//     },
//     "required_rng_sources" : {
//       "required_rng_source" : [ "random" ]
//     },
//     "switch_type" : "legacy",
//     "threads_as_cores" : "false",
//     "trusted_service" : "false",
//     "tunnel_migration" : "false",
//     "version" : {
//       "major" : "4",
//       "minor" : "1"
//     },
//     "virt_service" : "true",
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "mac_pool" : {
//       "href" : "/ovirt-engine/api/macpools/456",
//       "id" : "456"
//     },
//     "scheduling_policy" : {
//       "href" : "/ovirt-engine/api/schedulingpolicies/789",
//       "id" : "789"
//     },
//     "actions" : {
//       "link" : [ {
//         "href" : "/ovirt-engine/api/clusters/234/resetemulatedmachine",
//         "rel" : "resetemulatedmachine"
//       } ]
//     },
//     "name" : "Default",
//     "description" : "The default server cluster",
//     "href" : "/ovirt-engine/api/clusters/234",
//     "id" : "234",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/clusters/234/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/cpuprofiles",
//       "rel" : "cpuprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networkfilters",
//       "rel" : "networkfilters"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networks",
//       "rel" : "networks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/affinitygroups",
//       "rel" : "affinitygroups"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glusterhooks",
//       "rel" : "glusterhooks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glustervolumes",
//       "rel" : "glustervolumes"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/enabledfeatures",
//       "rel" : "enabledfeatures"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/externalnetworkproviders",
//       "rel" : "externalnetworkproviders"
//     } ]
//   } ]
// }
// ----
func (p *RegistrationClusterMapping) From() (*Cluster, bool) {
	if p.from != nil {
		return p.from, true
	}
	return nil, false
}

// MustFrom Type representation of a cluster.
//
// A JSON representation of a cluster:
//
// [source]
// ----
// {
//   "cluster" : [ {
//     "ballooning_enabled" : "false",
//     "cpu" : {
//       "architecture" : "x86_64",
//       "type" : "Intel SandyBridge Family"
//     },
//     "custom_scheduling_policy_properties" : {
//       "property" : [ {
//         "name" : "HighUtilization",
//         "value" : "80"
//       }, {
//         "name" : "CpuOverCommitDurationMinutes",
//         "value" : "2"
//       } ]
//     },
//     "error_handling" : {
//       "on_error" : "migrate"
//     },
//     "fencing_policy" : {
//       "enabled" : "true",
//       "skip_if_connectivity_broken" : {
//         "enabled" : "false",
//         "threshold" : "50"
//       },
//       "skip_if_gluster_bricks_up" : "false",
//       "skip_if_gluster_quorum_not_met" : "false",
//       "skip_if_sd_active" : {
//         "enabled" : "false"
//       }
//     },
//     "gluster_service" : "false",
//     "firewall_type" : "iptables",
//     "ha_reservation" : "false",
//     "ksm" : {
//       "enabled" : "true",
//       "merge_across_nodes" : "true"
//     },
//     "memory_policy" : {
//       "over_commit" : {
//         "percent" : "100"
//       },
//       "transparent_hugepages" : {
//         "enabled" : "true"
//       }
//     },
//     "migration" : {
//       "auto_converge" : "inherit",
//       "bandwidth" : {
//         "assignment_method" : "auto"
//       },
//       "compressed" : "inherit",
//       "policy" : {
//         "id" : "00000000-0000-0000-0000-000000000000"
//       }
//     },
//     "required_rng_sources" : {
//       "required_rng_source" : [ "random" ]
//     },
//     "switch_type" : "legacy",
//     "threads_as_cores" : "false",
//     "trusted_service" : "false",
//     "tunnel_migration" : "false",
//     "version" : {
//       "major" : "4",
//       "minor" : "1"
//     },
//     "virt_service" : "true",
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "mac_pool" : {
//       "href" : "/ovirt-engine/api/macpools/456",
//       "id" : "456"
//     },
//     "scheduling_policy" : {
//       "href" : "/ovirt-engine/api/schedulingpolicies/789",
//       "id" : "789"
//     },
//     "actions" : {
//       "link" : [ {
//         "href" : "/ovirt-engine/api/clusters/234/resetemulatedmachine",
//         "rel" : "resetemulatedmachine"
//       } ]
//     },
//     "name" : "Default",
//     "description" : "The default server cluster",
//     "href" : "/ovirt-engine/api/clusters/234",
//     "id" : "234",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/clusters/234/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/cpuprofiles",
//       "rel" : "cpuprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networkfilters",
//       "rel" : "networkfilters"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networks",
//       "rel" : "networks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/affinitygroups",
//       "rel" : "affinitygroups"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glusterhooks",
//       "rel" : "glusterhooks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glustervolumes",
//       "rel" : "glustervolumes"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/enabledfeatures",
//       "rel" : "enabledfeatures"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/externalnetworkproviders",
//       "rel" : "externalnetworkproviders"
//     } ]
//   } ]
// }
// ----
func (p *RegistrationClusterMapping) MustFrom() *Cluster {
	if p.from == nil {
		panic("the from must not be nil, please use From() function instead")
	}
	return p.from
}

// SetTo Type representation of a cluster.
//
// A JSON representation of a cluster:
//
// [source]
// ----
// {
//   "cluster" : [ {
//     "ballooning_enabled" : "false",
//     "cpu" : {
//       "architecture" : "x86_64",
//       "type" : "Intel SandyBridge Family"
//     },
//     "custom_scheduling_policy_properties" : {
//       "property" : [ {
//         "name" : "HighUtilization",
//         "value" : "80"
//       }, {
//         "name" : "CpuOverCommitDurationMinutes",
//         "value" : "2"
//       } ]
//     },
//     "error_handling" : {
//       "on_error" : "migrate"
//     },
//     "fencing_policy" : {
//       "enabled" : "true",
//       "skip_if_connectivity_broken" : {
//         "enabled" : "false",
//         "threshold" : "50"
//       },
//       "skip_if_gluster_bricks_up" : "false",
//       "skip_if_gluster_quorum_not_met" : "false",
//       "skip_if_sd_active" : {
//         "enabled" : "false"
//       }
//     },
//     "gluster_service" : "false",
//     "firewall_type" : "iptables",
//     "ha_reservation" : "false",
//     "ksm" : {
//       "enabled" : "true",
//       "merge_across_nodes" : "true"
//     },
//     "memory_policy" : {
//       "over_commit" : {
//         "percent" : "100"
//       },
//       "transparent_hugepages" : {
//         "enabled" : "true"
//       }
//     },
//     "migration" : {
//       "auto_converge" : "inherit",
//       "bandwidth" : {
//         "assignment_method" : "auto"
//       },
//       "compressed" : "inherit",
//       "policy" : {
//         "id" : "00000000-0000-0000-0000-000000000000"
//       }
//     },
//     "required_rng_sources" : {
//       "required_rng_source" : [ "random" ]
//     },
//     "switch_type" : "legacy",
//     "threads_as_cores" : "false",
//     "trusted_service" : "false",
//     "tunnel_migration" : "false",
//     "version" : {
//       "major" : "4",
//       "minor" : "1"
//     },
//     "virt_service" : "true",
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "mac_pool" : {
//       "href" : "/ovirt-engine/api/macpools/456",
//       "id" : "456"
//     },
//     "scheduling_policy" : {
//       "href" : "/ovirt-engine/api/schedulingpolicies/789",
//       "id" : "789"
//     },
//     "actions" : {
//       "link" : [ {
//         "href" : "/ovirt-engine/api/clusters/234/resetemulatedmachine",
//         "rel" : "resetemulatedmachine"
//       } ]
//     },
//     "name" : "Default",
//     "description" : "The default server cluster",
//     "href" : "/ovirt-engine/api/clusters/234",
//     "id" : "234",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/clusters/234/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/cpuprofiles",
//       "rel" : "cpuprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networkfilters",
//       "rel" : "networkfilters"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networks",
//       "rel" : "networks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/affinitygroups",
//       "rel" : "affinitygroups"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glusterhooks",
//       "rel" : "glusterhooks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glustervolumes",
//       "rel" : "glustervolumes"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/enabledfeatures",
//       "rel" : "enabledfeatures"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/externalnetworkproviders",
//       "rel" : "externalnetworkproviders"
//     } ]
//   } ]
// }
// ----
func (p *RegistrationClusterMapping) SetTo(attr *Cluster) {
	p.to = attr
}

// To Type representation of a cluster.
//
// A JSON representation of a cluster:
//
// [source]
// ----
// {
//   "cluster" : [ {
//     "ballooning_enabled" : "false",
//     "cpu" : {
//       "architecture" : "x86_64",
//       "type" : "Intel SandyBridge Family"
//     },
//     "custom_scheduling_policy_properties" : {
//       "property" : [ {
//         "name" : "HighUtilization",
//         "value" : "80"
//       }, {
//         "name" : "CpuOverCommitDurationMinutes",
//         "value" : "2"
//       } ]
//     },
//     "error_handling" : {
//       "on_error" : "migrate"
//     },
//     "fencing_policy" : {
//       "enabled" : "true",
//       "skip_if_connectivity_broken" : {
//         "enabled" : "false",
//         "threshold" : "50"
//       },
//       "skip_if_gluster_bricks_up" : "false",
//       "skip_if_gluster_quorum_not_met" : "false",
//       "skip_if_sd_active" : {
//         "enabled" : "false"
//       }
//     },
//     "gluster_service" : "false",
//     "firewall_type" : "iptables",
//     "ha_reservation" : "false",
//     "ksm" : {
//       "enabled" : "true",
//       "merge_across_nodes" : "true"
//     },
//     "memory_policy" : {
//       "over_commit" : {
//         "percent" : "100"
//       },
//       "transparent_hugepages" : {
//         "enabled" : "true"
//       }
//     },
//     "migration" : {
//       "auto_converge" : "inherit",
//       "bandwidth" : {
//         "assignment_method" : "auto"
//       },
//       "compressed" : "inherit",
//       "policy" : {
//         "id" : "00000000-0000-0000-0000-000000000000"
//       }
//     },
//     "required_rng_sources" : {
//       "required_rng_source" : [ "random" ]
//     },
//     "switch_type" : "legacy",
//     "threads_as_cores" : "false",
//     "trusted_service" : "false",
//     "tunnel_migration" : "false",
//     "version" : {
//       "major" : "4",
//       "minor" : "1"
//     },
//     "virt_service" : "true",
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "mac_pool" : {
//       "href" : "/ovirt-engine/api/macpools/456",
//       "id" : "456"
//     },
//     "scheduling_policy" : {
//       "href" : "/ovirt-engine/api/schedulingpolicies/789",
//       "id" : "789"
//     },
//     "actions" : {
//       "link" : [ {
//         "href" : "/ovirt-engine/api/clusters/234/resetemulatedmachine",
//         "rel" : "resetemulatedmachine"
//       } ]
//     },
//     "name" : "Default",
//     "description" : "The default server cluster",
//     "href" : "/ovirt-engine/api/clusters/234",
//     "id" : "234",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/clusters/234/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/cpuprofiles",
//       "rel" : "cpuprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networkfilters",
//       "rel" : "networkfilters"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networks",
//       "rel" : "networks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/affinitygroups",
//       "rel" : "affinitygroups"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glusterhooks",
//       "rel" : "glusterhooks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glustervolumes",
//       "rel" : "glustervolumes"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/enabledfeatures",
//       "rel" : "enabledfeatures"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/externalnetworkproviders",
//       "rel" : "externalnetworkproviders"
//     } ]
//   } ]
// }
// ----
func (p *RegistrationClusterMapping) To() (*Cluster, bool) {
	if p.to != nil {
		return p.to, true
	}
	return nil, false
}

// MustTo Type representation of a cluster.
//
// A JSON representation of a cluster:
//
// [source]
// ----
// {
//   "cluster" : [ {
//     "ballooning_enabled" : "false",
//     "cpu" : {
//       "architecture" : "x86_64",
//       "type" : "Intel SandyBridge Family"
//     },
//     "custom_scheduling_policy_properties" : {
//       "property" : [ {
//         "name" : "HighUtilization",
//         "value" : "80"
//       }, {
//         "name" : "CpuOverCommitDurationMinutes",
//         "value" : "2"
//       } ]
//     },
//     "error_handling" : {
//       "on_error" : "migrate"
//     },
//     "fencing_policy" : {
//       "enabled" : "true",
//       "skip_if_connectivity_broken" : {
//         "enabled" : "false",
//         "threshold" : "50"
//       },
//       "skip_if_gluster_bricks_up" : "false",
//       "skip_if_gluster_quorum_not_met" : "false",
//       "skip_if_sd_active" : {
//         "enabled" : "false"
//       }
//     },
//     "gluster_service" : "false",
//     "firewall_type" : "iptables",
//     "ha_reservation" : "false",
//     "ksm" : {
//       "enabled" : "true",
//       "merge_across_nodes" : "true"
//     },
//     "memory_policy" : {
//       "over_commit" : {
//         "percent" : "100"
//       },
//       "transparent_hugepages" : {
//         "enabled" : "true"
//       }
//     },
//     "migration" : {
//       "auto_converge" : "inherit",
//       "bandwidth" : {
//         "assignment_method" : "auto"
//       },
//       "compressed" : "inherit",
//       "policy" : {
//         "id" : "00000000-0000-0000-0000-000000000000"
//       }
//     },
//     "required_rng_sources" : {
//       "required_rng_source" : [ "random" ]
//     },
//     "switch_type" : "legacy",
//     "threads_as_cores" : "false",
//     "trusted_service" : "false",
//     "tunnel_migration" : "false",
//     "version" : {
//       "major" : "4",
//       "minor" : "1"
//     },
//     "virt_service" : "true",
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "mac_pool" : {
//       "href" : "/ovirt-engine/api/macpools/456",
//       "id" : "456"
//     },
//     "scheduling_policy" : {
//       "href" : "/ovirt-engine/api/schedulingpolicies/789",
//       "id" : "789"
//     },
//     "actions" : {
//       "link" : [ {
//         "href" : "/ovirt-engine/api/clusters/234/resetemulatedmachine",
//         "rel" : "resetemulatedmachine"
//       } ]
//     },
//     "name" : "Default",
//     "description" : "The default server cluster",
//     "href" : "/ovirt-engine/api/clusters/234",
//     "id" : "234",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/clusters/234/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/cpuprofiles",
//       "rel" : "cpuprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networkfilters",
//       "rel" : "networkfilters"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networks",
//       "rel" : "networks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/affinitygroups",
//       "rel" : "affinitygroups"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glusterhooks",
//       "rel" : "glusterhooks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glustervolumes",
//       "rel" : "glustervolumes"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/enabledfeatures",
//       "rel" : "enabledfeatures"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/externalnetworkproviders",
//       "rel" : "externalnetworkproviders"
//     } ]
//   } ]
// }
// ----
func (p *RegistrationClusterMapping) MustTo() *Cluster {
	if p.to == nil {
		panic("the to must not be nil, please use To() function instead")
	}
	return p.to
}

// RegistrationConfiguration This type describes how an object (virtual machine, template,
// etc) is registered, and is used for the implementation of disaster recovery solutions.
//
// Each mapping contained in this type can be used to map
// objects in the original system to corresponding objects
// in the system where the virtual machine or template is being registered.
// For example, there could be a primary setup with a virtual machine
// configured on cluster A, and an active secondary setup with cluster B.
// Cluster B is compatible with that virtual machine, and in case of a
// disaster recovery scenario the storage domain can be
// imported to the secondary setup, and the user can register the
// virtual machine to cluster B.
//
// In that case, we can automate the recovery process by defining a cluster mapping.
// After the entity is registered, its OVF will indicate it belongs to
// cluster A, but the mapping will indicate that cluster A will
// be replaced with cluster B.
// {engine-name} should do the switch and register the virtual machine to cluster B
// in the secondary site.
//
// Cluster mapping is just one example, there are different types of mappings:
//
// - Cluster mapping.
// - LUN mapping.
// - Role mapping.
// - Domain mapping.
// - Permissions mapping.
// - Affinity Group mapping.
// - Affinity Label mapping.
// - Virtual NIC profile mapping.
//
// Each mapping will be used for its specific OVF's data once the register operation
// takes place in the {engine-name}.
//
// An example of an XML representation using the mapping:
//
// [source,xml]
// ----
// <action>
//   <registration_configuration>
//     <cluster_mappings>
//       <registration_cluster_mapping>
//         <from>
//           <name>myoriginalcluster</name>
//         </from>
//         <to>
//           <name>mynewcluster</name>
//         </to>
//       </registration_cluster_mapping>
//     </cluster_mappings>
//     <role_mappings>
//       <registration_role_mapping>
//         <from>
//           <name>SuperUser</name>
//         </from>
//         <to>
//           <name>UserVmRunTimeManager</name>
//         </to>
//       </registration_role_mapping>
//     </role_mappings>
//     <domain_mappings>
//       <registration_domain_mapping>
//         <from>
//           <name>redhat</name>
//         </from>
//         <to>
//           <name>internal</name>
//         </to>
//       </registration_domain_mapping>
//     </domain_mappings>
//     <lun_mappings>
//      <registration_lun_mapping>
//        <from id="111">
//        </from>
//        <to id="222">
//          <alias>weTestLun</alias>
//          <lun_storage>
//            <type>iscsi</type>
//            <logical_units>
//               <logical_unit id="36001405fb1ddb4b91e44078f1fffcfef">
//                  <address>44.33.11.22</address>
//                  <port>3260</port>
//                  <portal>1</portal>
//                  <target>iqn.2017-11.com.name.redhat:444</target>
//               </logical_unit>
//            </logical_units>
//          </lun_storage>
//        </to>
//      </registration_lun_mapping>
//     </lun_mappings>
//     <affinity_group_mappings>
//      <registration_affinity_group_mapping>
//        <from>
//          <name>affinity</name>
//        </from>
//        <to>
//          <name>affinity2</name>
//        </to>
//      </registration_affinity_group_mapping>
//     </affinity_group_mappings>
//     <affinity_label_mappings>
//      <registration_affinity_label_mapping>
//        <from>
//          <name>affinity_label</name>
//        </from>
//        <to>
//          <name>affinity_label2</name>
//        </to>
//      </registration_affinity_label_mapping>
//     </affinity_label_mappings>
//     <vnic_profile_mappings>
//       <registration_vnic_profile_mapping>
//         <from>
//           <name>gold</name>
//           <network>
//             <name>red</name>
//           </network>
//         </from>
//         <to id="738dd914-8ec8-4a8b-8628-34672a5d449b"/>
//       </registration_vnic_profile_mapping>
//       <registration_vnic_profile_mapping>
//         <from>
//           <name>silver</name>
//           <network>
//             <name>blue</name>
//           </network>
//         </from>
//         <to>
//           <name>copper</name>
//           <network>
//             <name>orange</name>
//           </network>
//         </to>
//       </registration_vnic_profile_mapping>
//     </vnic_profile_mappings>
//   </registration_configuration>
// </action>
// ----
type RegistrationConfiguration struct {
	Struct
	affinityGroupMappings *RegistrationAffinityGroupMappingSlice
	affinityLabelMappings *RegistrationAffinityLabelMappingSlice
	clusterMappings       *RegistrationClusterMappingSlice
	domainMappings        *RegistrationDomainMappingSlice
	lunMappings           *RegistrationLunMappingSlice
	roleMappings          *RegistrationRoleMappingSlice
	vnicProfileMappings   *RegistrationVnicProfileMappingSlice
}

func (p *RegistrationConfiguration) SetAffinityGroupMappings(attr *RegistrationAffinityGroupMappingSlice) {
	p.affinityGroupMappings = attr
}

func (p *RegistrationConfiguration) AffinityGroupMappings() (*RegistrationAffinityGroupMappingSlice, bool) {
	if p.affinityGroupMappings != nil {
		return p.affinityGroupMappings, true
	}
	return nil, false
}

func (p *RegistrationConfiguration) MustAffinityGroupMappings() *RegistrationAffinityGroupMappingSlice {
	if p.affinityGroupMappings == nil {
		panic("the affinityGroupMappings must not be nil, please use AffinityGroupMappings() function instead")
	}
	return p.affinityGroupMappings
}

func (p *RegistrationConfiguration) SetAffinityLabelMappings(attr *RegistrationAffinityLabelMappingSlice) {
	p.affinityLabelMappings = attr
}

func (p *RegistrationConfiguration) AffinityLabelMappings() (*RegistrationAffinityLabelMappingSlice, bool) {
	if p.affinityLabelMappings != nil {
		return p.affinityLabelMappings, true
	}
	return nil, false
}

func (p *RegistrationConfiguration) MustAffinityLabelMappings() *RegistrationAffinityLabelMappingSlice {
	if p.affinityLabelMappings == nil {
		panic("the affinityLabelMappings must not be nil, please use AffinityLabelMappings() function instead")
	}
	return p.affinityLabelMappings
}

func (p *RegistrationConfiguration) SetClusterMappings(attr *RegistrationClusterMappingSlice) {
	p.clusterMappings = attr
}

func (p *RegistrationConfiguration) ClusterMappings() (*RegistrationClusterMappingSlice, bool) {
	if p.clusterMappings != nil {
		return p.clusterMappings, true
	}
	return nil, false
}

func (p *RegistrationConfiguration) MustClusterMappings() *RegistrationClusterMappingSlice {
	if p.clusterMappings == nil {
		panic("the clusterMappings must not be nil, please use ClusterMappings() function instead")
	}
	return p.clusterMappings
}

func (p *RegistrationConfiguration) SetDomainMappings(attr *RegistrationDomainMappingSlice) {
	p.domainMappings = attr
}

func (p *RegistrationConfiguration) DomainMappings() (*RegistrationDomainMappingSlice, bool) {
	if p.domainMappings != nil {
		return p.domainMappings, true
	}
	return nil, false
}

func (p *RegistrationConfiguration) MustDomainMappings() *RegistrationDomainMappingSlice {
	if p.domainMappings == nil {
		panic("the domainMappings must not be nil, please use DomainMappings() function instead")
	}
	return p.domainMappings
}

func (p *RegistrationConfiguration) SetLunMappings(attr *RegistrationLunMappingSlice) {
	p.lunMappings = attr
}

func (p *RegistrationConfiguration) LunMappings() (*RegistrationLunMappingSlice, bool) {
	if p.lunMappings != nil {
		return p.lunMappings, true
	}
	return nil, false
}

func (p *RegistrationConfiguration) MustLunMappings() *RegistrationLunMappingSlice {
	if p.lunMappings == nil {
		panic("the lunMappings must not be nil, please use LunMappings() function instead")
	}
	return p.lunMappings
}

func (p *RegistrationConfiguration) SetRoleMappings(attr *RegistrationRoleMappingSlice) {
	p.roleMappings = attr
}

func (p *RegistrationConfiguration) RoleMappings() (*RegistrationRoleMappingSlice, bool) {
	if p.roleMappings != nil {
		return p.roleMappings, true
	}
	return nil, false
}

func (p *RegistrationConfiguration) MustRoleMappings() *RegistrationRoleMappingSlice {
	if p.roleMappings == nil {
		panic("the roleMappings must not be nil, please use RoleMappings() function instead")
	}
	return p.roleMappings
}

func (p *RegistrationConfiguration) SetVnicProfileMappings(attr *RegistrationVnicProfileMappingSlice) {
	p.vnicProfileMappings = attr
}

func (p *RegistrationConfiguration) VnicProfileMappings() (*RegistrationVnicProfileMappingSlice, bool) {
	if p.vnicProfileMappings != nil {
		return p.vnicProfileMappings, true
	}
	return nil, false
}

func (p *RegistrationConfiguration) MustVnicProfileMappings() *RegistrationVnicProfileMappingSlice {
	if p.vnicProfileMappings == nil {
		panic("the vnicProfileMappings must not be nil, please use VnicProfileMappings() function instead")
	}
	return p.vnicProfileMappings
}

// RegistrationDomainMapping This type describes how to map the users' domain as part of the object registration. An object can be
// a virtual machine, template, etc.
// NOTE: This is based on the assumption that user names will be the same, and that only
// the domain name will be changed.
//
// An example of an XML representation using this mapping:
//
// [source,xml]
// ----
// <action>
//   <registration_configuration>
//     <domain_mappings>
//       <registration_domain_mapping>
//         <from>
//           <name>redhat</name>
//         </from>
//         <to>
//           <name>internal</name>
//         </to>
//       </registration_domain_mapping>
//     </domain_mappings>
//   </registration_configuration>
// </action>
// ----
type RegistrationDomainMapping struct {
	Struct
	from *Domain
	to   *Domain
}

// SetFrom This type represents a directory service domain.
func (p *RegistrationDomainMapping) SetFrom(attr *Domain) {
	p.from = attr
}

// From This type represents a directory service domain.
func (p *RegistrationDomainMapping) From() (*Domain, bool) {
	if p.from != nil {
		return p.from, true
	}
	return nil, false
}

// MustFrom This type represents a directory service domain.
func (p *RegistrationDomainMapping) MustFrom() *Domain {
	if p.from == nil {
		panic("the from must not be nil, please use From() function instead")
	}
	return p.from
}

// SetTo This type represents a directory service domain.
func (p *RegistrationDomainMapping) SetTo(attr *Domain) {
	p.to = attr
}

// To This type represents a directory service domain.
func (p *RegistrationDomainMapping) To() (*Domain, bool) {
	if p.to != nil {
		return p.to, true
	}
	return nil, false
}

// MustTo This type represents a directory service domain.
func (p *RegistrationDomainMapping) MustTo() *Domain {
	if p.to == nil {
		panic("the to must not be nil, please use To() function instead")
	}
	return p.to
}

// RegistrationLunMapping This type describes how to map LUNs as part of the object registration. An object can be
// a virtual machine, template, etc.
//
// An external LUN disk is an entity which does not reside on a storage domain.
// It must be specified because it doesn't need to exist in the
// environment where the object is registered.
// An example of an XML representation using this mapping:
//
// [source,xml]
// ----
// <action>
//   <registration_configuration>
//     <lun_mappings>
//       <registration_lun_mapping>
//     <lun_mappings>
//      <registration_lun_mapping>
//        <from id="111">
//        </from>
//        <to id="222">
//          <alias>weTestLun</alias>
//          <lun_storage>
//            <type>iscsi</type>
//            <logical_units>
//               <logical_unit id="36001405fb1ddb4b91e44078f1fffcfef">
//                  <address>44.33.11.22</address>
//                  <port>3260</port>
//                  <portal>1</portal>
//                  <target>iqn.2017-11.com.name.redhat:444</target>
//               </logical_unit>
//            </logical_units>
//          </lun_storage>
//        </to>
//      </registration_lun_mapping>
//     </lun_mappings>
//   </registration_configuration>
// </action>
// ----
type RegistrationLunMapping struct {
	Struct
	from *Disk
	to   *Disk
}

// SetFrom Represents a virtual disk device.
func (p *RegistrationLunMapping) SetFrom(attr *Disk) {
	p.from = attr
}

// From Represents a virtual disk device.
func (p *RegistrationLunMapping) From() (*Disk, bool) {
	if p.from != nil {
		return p.from, true
	}
	return nil, false
}

// MustFrom Represents a virtual disk device.
func (p *RegistrationLunMapping) MustFrom() *Disk {
	if p.from == nil {
		panic("the from must not be nil, please use From() function instead")
	}
	return p.from
}

// SetTo Represents a virtual disk device.
func (p *RegistrationLunMapping) SetTo(attr *Disk) {
	p.to = attr
}

// To Represents a virtual disk device.
func (p *RegistrationLunMapping) To() (*Disk, bool) {
	if p.to != nil {
		return p.to, true
	}
	return nil, false
}

// MustTo Represents a virtual disk device.
func (p *RegistrationLunMapping) MustTo() *Disk {
	if p.to == nil {
		panic("the to must not be nil, please use To() function instead")
	}
	return p.to
}

// RegistrationRoleMapping This type describes how to map roles as part of the object registration. An object can be
// a virtual machine, template, etc.
//
// A role mapping is intended to map correlating roles between the primary site
// and the secondary site.
// For example, there may be permissions with role `UserVmRunTimeManager` for the virtual machine that
// is being registered.
// Therefore we can send a mapping that will register the virtual machine in the secondary setup
// using the `SuperUser` role instead of `UserVmRunTimeManager`
// An example of an XML representation using this mapping:
//
// [source,xml]
// ----
// <action>
//   <registration_configuration>
//     <role_mappings>
//       <registration_eole_mapping>
//         <from>
//           <name>SuperUser</name>
//         </from>
//         <to>
//           <name>UserVmRunTimeManager</name>
//         </to>
//       </registration_role_mapping>
//     </role_mappings>
//   </registration_configuration>
// </action>
// ----
type RegistrationRoleMapping struct {
	Struct
	from *Role
	to   *Role
}

// SetFrom Represents a system role.
func (p *RegistrationRoleMapping) SetFrom(attr *Role) {
	p.from = attr
}

// From Represents a system role.
func (p *RegistrationRoleMapping) From() (*Role, bool) {
	if p.from != nil {
		return p.from, true
	}
	return nil, false
}

// MustFrom Represents a system role.
func (p *RegistrationRoleMapping) MustFrom() *Role {
	if p.from == nil {
		panic("the from must not be nil, please use From() function instead")
	}
	return p.from
}

// SetTo Represents a system role.
func (p *RegistrationRoleMapping) SetTo(attr *Role) {
	p.to = attr
}

// To Represents a system role.
func (p *RegistrationRoleMapping) To() (*Role, bool) {
	if p.to != nil {
		return p.to, true
	}
	return nil, false
}

// MustTo Represents a system role.
func (p *RegistrationRoleMapping) MustTo() *Role {
	if p.to == nil {
		panic("the to must not be nil, please use To() function instead")
	}
	return p.to
}

// RegistrationVnicProfileMapping Maps an external virtual NIC profile to one that exists in the {engine-name}.
// The target may be specified as a profile ID or a pair of profile name and network name.
//
// If, for example, the desired virtual NIC profile mapping includes the following lines:
//
// [cols="25,35,40"]
// |===
// |Source network name|Source network profile name|Target virtual NIC profile ID\names
//
// |`red`
// |`gold`
// |`738dd914-8ec8-4a8b-8628-34672a5d449b`
//
// |`<empty>` (no network name)
// |`<empty>` (no network profile name)
// |`892a12ec-2028-4451-80aa-ff3bf55d6bac`
//
// |`blue`
// |`silver`
// |`orange\copper`
//
// |`yellow`
// |`platinum`
// |`<empty>` (no profile)
//
// |`green`
// |`bronze`
// |
//
// |===
//
// Then the following snippet should be added to <<types/registration_configuration, RegistrationConfiguration>>
//
// [source,xml]
// ----
// <vnic_profile_mappings>
//   <registration_vnic_profile_mapping>
//     <from>
//       <name>gold</name>
//       <network>
//         <name>red</name>
//       </network>
//     </from>
//     <to id="738dd914-8ec8-4a8b-8628-34672a5d449b"/>
//   </registration_vnic_profile_mapping>
//   <registration_vnic_profile_mapping>
//     <from>
//       <name></name>
//       <network>
//         <name></name>
//       </network>
//     </from>
//     <to id="892a12ec-2028-4451-80aa-ff3bf55d6bac"/>
//   </registration_vnic_profile_mapping>
//   <registration_vnic_profile_mapping>
//     <from>
//       <name>silver</name>
//       <network>
//         <name>blue</name>
//       </network>
//     </from>
//     <to>
//       <name>copper</name>
//       <network>
//         <name>orange</name>
//       </network>
//     </to>
//   </registration_vnic_profile_mapping>
//   <registration_vnic_profile_mapping>
//     <from>
//       <name>platinum</name>
//       <network>
//         <name>yellow</name>
//       </network>
//     </from>
//     <to>
//       <name></name>
//       <network>
//         <name></name>
//       </network>
//     </to>
//   </registration_vnic_profile_mapping>
//   <registration_vnic_profile_mapping>
//     <from>
//       <name>bronze</name>
//       <network>
//         <name>green</name>
//       </network>
//     </from>
//   </registration_vnic_profile_mapping>
// </vnic_profile_mappings>
// ----
type RegistrationVnicProfileMapping struct {
	Struct
	from *VnicProfile
	to   *VnicProfile
}

// SetFrom A vNIC profile is a collection of settings that can be applied to individual <<types/nic,NIC>>.
func (p *RegistrationVnicProfileMapping) SetFrom(attr *VnicProfile) {
	p.from = attr
}

// From A vNIC profile is a collection of settings that can be applied to individual <<types/nic,NIC>>.
func (p *RegistrationVnicProfileMapping) From() (*VnicProfile, bool) {
	if p.from != nil {
		return p.from, true
	}
	return nil, false
}

// MustFrom A vNIC profile is a collection of settings that can be applied to individual <<types/nic,NIC>>.
func (p *RegistrationVnicProfileMapping) MustFrom() *VnicProfile {
	if p.from == nil {
		panic("the from must not be nil, please use From() function instead")
	}
	return p.from
}

// SetTo A vNIC profile is a collection of settings that can be applied to individual <<types/nic,NIC>>.
func (p *RegistrationVnicProfileMapping) SetTo(attr *VnicProfile) {
	p.to = attr
}

// To A vNIC profile is a collection of settings that can be applied to individual <<types/nic,NIC>>.
func (p *RegistrationVnicProfileMapping) To() (*VnicProfile, bool) {
	if p.to != nil {
		return p.to, true
	}
	return nil, false
}

// MustTo A vNIC profile is a collection of settings that can be applied to individual <<types/nic,NIC>>.
func (p *RegistrationVnicProfileMapping) MustTo() *VnicProfile {
	if p.to == nil {
		panic("the to must not be nil, please use To() function instead")
	}
	return p.to
}

type ReportedConfiguration struct {
	Struct
	actualValue   *string
	expectedValue *string
	inSync        *bool
	name          *string
}

func (p *ReportedConfiguration) SetActualValue(attr string) {
	p.actualValue = &attr
}

func (p *ReportedConfiguration) ActualValue() (string, bool) {
	if p.actualValue != nil {
		return *p.actualValue, true
	}
	var zero string
	return zero, false
}

func (p *ReportedConfiguration) MustActualValue() string {
	if p.actualValue == nil {
		panic("the actualValue must not be nil, please use ActualValue() function instead")
	}
	return *p.actualValue
}

func (p *ReportedConfiguration) SetExpectedValue(attr string) {
	p.expectedValue = &attr
}

func (p *ReportedConfiguration) ExpectedValue() (string, bool) {
	if p.expectedValue != nil {
		return *p.expectedValue, true
	}
	var zero string
	return zero, false
}

func (p *ReportedConfiguration) MustExpectedValue() string {
	if p.expectedValue == nil {
		panic("the expectedValue must not be nil, please use ExpectedValue() function instead")
	}
	return *p.expectedValue
}

func (p *ReportedConfiguration) SetInSync(attr bool) {
	p.inSync = &attr
}

func (p *ReportedConfiguration) InSync() (bool, bool) {
	if p.inSync != nil {
		return *p.inSync, true
	}
	var zero bool
	return zero, false
}

func (p *ReportedConfiguration) MustInSync() bool {
	if p.inSync == nil {
		panic("the inSync must not be nil, please use InSync() function instead")
	}
	return *p.inSync
}

func (p *ReportedConfiguration) SetName(attr string) {
	p.name = &attr
}

func (p *ReportedConfiguration) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *ReportedConfiguration) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

type ReportedDevice struct {
	Struct
	comment     *string
	description *string
	id          *string
	ips         *IpSlice
	mac         *Mac
	name        *string
	type_       *ReportedDeviceType
	vm          *Vm
}

func (p *ReportedDevice) SetComment(attr string) {
	p.comment = &attr
}

func (p *ReportedDevice) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *ReportedDevice) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *ReportedDevice) SetDescription(attr string) {
	p.description = &attr
}

func (p *ReportedDevice) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *ReportedDevice) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *ReportedDevice) SetId(attr string) {
	p.id = &attr
}

func (p *ReportedDevice) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *ReportedDevice) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *ReportedDevice) SetIps(attr *IpSlice) {
	p.ips = attr
}

func (p *ReportedDevice) Ips() (*IpSlice, bool) {
	if p.ips != nil {
		return p.ips, true
	}
	return nil, false
}

func (p *ReportedDevice) MustIps() *IpSlice {
	if p.ips == nil {
		panic("the ips must not be nil, please use Ips() function instead")
	}
	return p.ips
}

// SetMac Represents a MAC address of a virtual network interface.
func (p *ReportedDevice) SetMac(attr *Mac) {
	p.mac = attr
}

// Mac Represents a MAC address of a virtual network interface.
func (p *ReportedDevice) Mac() (*Mac, bool) {
	if p.mac != nil {
		return p.mac, true
	}
	return nil, false
}

// MustMac Represents a MAC address of a virtual network interface.
func (p *ReportedDevice) MustMac() *Mac {
	if p.mac == nil {
		panic("the mac must not be nil, please use Mac() function instead")
	}
	return p.mac
}

func (p *ReportedDevice) SetName(attr string) {
	p.name = &attr
}

func (p *ReportedDevice) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *ReportedDevice) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *ReportedDevice) SetType(attr ReportedDeviceType) {
	p.type_ = &attr
}

func (p *ReportedDevice) Type() (ReportedDeviceType, bool) {
	if p.type_ != nil {
		return *p.type_, true
	}
	var zero ReportedDeviceType
	return zero, false
}

func (p *ReportedDevice) MustType() ReportedDeviceType {
	if p.type_ == nil {
		panic("the type_ must not be nil, please use Type() function instead")
	}
	return *p.type_
}

// SetVm Represents a virtual machine.
func (p *ReportedDevice) SetVm(attr *Vm) {
	p.vm = attr
}

// Vm Represents a virtual machine.
func (p *ReportedDevice) Vm() (*Vm, bool) {
	if p.vm != nil {
		return p.vm, true
	}
	return nil, false
}

// MustVm Represents a virtual machine.
func (p *ReportedDevice) MustVm() *Vm {
	if p.vm == nil {
		panic("the vm must not be nil, please use Vm() function instead")
	}
	return p.vm
}

// RngDevice Random number generator (RNG) device model.
type RngDevice struct {
	Struct
	rate   *Rate
	source *RngSource
}

// SetRate Determines maximum speed of consumption of bytes from random number generator device.
func (p *RngDevice) SetRate(attr *Rate) {
	p.rate = attr
}

// Rate Determines maximum speed of consumption of bytes from random number generator device.
func (p *RngDevice) Rate() (*Rate, bool) {
	if p.rate != nil {
		return p.rate, true
	}
	return nil, false
}

// MustRate Determines maximum speed of consumption of bytes from random number generator device.
func (p *RngDevice) MustRate() *Rate {
	if p.rate == nil {
		panic("the rate must not be nil, please use Rate() function instead")
	}
	return p.rate
}

// SetSource Representing the random generator backend types.
func (p *RngDevice) SetSource(attr RngSource) {
	p.source = &attr
}

// Source Representing the random generator backend types.
func (p *RngDevice) Source() (RngSource, bool) {
	if p.source != nil {
		return *p.source, true
	}
	var zero RngSource
	return zero, false
}

// MustSource Representing the random generator backend types.
func (p *RngDevice) MustSource() RngSource {
	if p.source == nil {
		panic("the source must not be nil, please use Source() function instead")
	}
	return *p.source
}

// Role Represents a system role.
type Role struct {
	Struct
	administrative *bool
	comment        *string
	description    *string
	id             *string
	mutable        *bool
	name           *string
	permits        *PermitSlice
	user           *User
}

func (p *Role) SetAdministrative(attr bool) {
	p.administrative = &attr
}

func (p *Role) Administrative() (bool, bool) {
	if p.administrative != nil {
		return *p.administrative, true
	}
	var zero bool
	return zero, false
}

func (p *Role) MustAdministrative() bool {
	if p.administrative == nil {
		panic("the administrative must not be nil, please use Administrative() function instead")
	}
	return *p.administrative
}

func (p *Role) SetComment(attr string) {
	p.comment = &attr
}

func (p *Role) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *Role) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *Role) SetDescription(attr string) {
	p.description = &attr
}

func (p *Role) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *Role) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *Role) SetId(attr string) {
	p.id = &attr
}

func (p *Role) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *Role) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *Role) SetMutable(attr bool) {
	p.mutable = &attr
}

func (p *Role) Mutable() (bool, bool) {
	if p.mutable != nil {
		return *p.mutable, true
	}
	var zero bool
	return zero, false
}

func (p *Role) MustMutable() bool {
	if p.mutable == nil {
		panic("the mutable must not be nil, please use Mutable() function instead")
	}
	return *p.mutable
}

func (p *Role) SetName(attr string) {
	p.name = &attr
}

func (p *Role) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *Role) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *Role) SetPermits(attr *PermitSlice) {
	p.permits = attr
}

func (p *Role) Permits() (*PermitSlice, bool) {
	if p.permits != nil {
		return p.permits, true
	}
	return nil, false
}

func (p *Role) MustPermits() *PermitSlice {
	if p.permits == nil {
		panic("the permits must not be nil, please use Permits() function instead")
	}
	return p.permits
}

// SetUser Represents a user in the system.
func (p *Role) SetUser(attr *User) {
	p.user = attr
}

// User Represents a user in the system.
func (p *Role) User() (*User, bool) {
	if p.user != nil {
		return p.user, true
	}
	return nil, false
}

// MustUser Represents a user in the system.
func (p *Role) MustUser() *User {
	if p.user == nil {
		panic("the user must not be nil, please use User() function instead")
	}
	return p.user
}

type SchedulingPolicy struct {
	Struct
	balances      *BalanceSlice
	comment       *string
	defaultPolicy *bool
	description   *string
	filters       *FilterSlice
	id            *string
	locked        *bool
	name          *string
	properties    *PropertySlice
	weight        *WeightSlice
}

func (p *SchedulingPolicy) SetBalances(attr *BalanceSlice) {
	p.balances = attr
}

func (p *SchedulingPolicy) Balances() (*BalanceSlice, bool) {
	if p.balances != nil {
		return p.balances, true
	}
	return nil, false
}

func (p *SchedulingPolicy) MustBalances() *BalanceSlice {
	if p.balances == nil {
		panic("the balances must not be nil, please use Balances() function instead")
	}
	return p.balances
}

func (p *SchedulingPolicy) SetComment(attr string) {
	p.comment = &attr
}

func (p *SchedulingPolicy) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *SchedulingPolicy) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *SchedulingPolicy) SetDefaultPolicy(attr bool) {
	p.defaultPolicy = &attr
}

func (p *SchedulingPolicy) DefaultPolicy() (bool, bool) {
	if p.defaultPolicy != nil {
		return *p.defaultPolicy, true
	}
	var zero bool
	return zero, false
}

func (p *SchedulingPolicy) MustDefaultPolicy() bool {
	if p.defaultPolicy == nil {
		panic("the defaultPolicy must not be nil, please use DefaultPolicy() function instead")
	}
	return *p.defaultPolicy
}

func (p *SchedulingPolicy) SetDescription(attr string) {
	p.description = &attr
}

func (p *SchedulingPolicy) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *SchedulingPolicy) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *SchedulingPolicy) SetFilters(attr *FilterSlice) {
	p.filters = attr
}

func (p *SchedulingPolicy) Filters() (*FilterSlice, bool) {
	if p.filters != nil {
		return p.filters, true
	}
	return nil, false
}

func (p *SchedulingPolicy) MustFilters() *FilterSlice {
	if p.filters == nil {
		panic("the filters must not be nil, please use Filters() function instead")
	}
	return p.filters
}

func (p *SchedulingPolicy) SetId(attr string) {
	p.id = &attr
}

func (p *SchedulingPolicy) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *SchedulingPolicy) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *SchedulingPolicy) SetLocked(attr bool) {
	p.locked = &attr
}

func (p *SchedulingPolicy) Locked() (bool, bool) {
	if p.locked != nil {
		return *p.locked, true
	}
	var zero bool
	return zero, false
}

func (p *SchedulingPolicy) MustLocked() bool {
	if p.locked == nil {
		panic("the locked must not be nil, please use Locked() function instead")
	}
	return *p.locked
}

func (p *SchedulingPolicy) SetName(attr string) {
	p.name = &attr
}

func (p *SchedulingPolicy) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *SchedulingPolicy) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *SchedulingPolicy) SetProperties(attr *PropertySlice) {
	p.properties = attr
}

func (p *SchedulingPolicy) Properties() (*PropertySlice, bool) {
	if p.properties != nil {
		return p.properties, true
	}
	return nil, false
}

func (p *SchedulingPolicy) MustProperties() *PropertySlice {
	if p.properties == nil {
		panic("the properties must not be nil, please use Properties() function instead")
	}
	return p.properties
}

func (p *SchedulingPolicy) SetWeight(attr *WeightSlice) {
	p.weight = attr
}

func (p *SchedulingPolicy) Weight() (*WeightSlice, bool) {
	if p.weight != nil {
		return p.weight, true
	}
	return nil, false
}

func (p *SchedulingPolicy) MustWeight() *WeightSlice {
	if p.weight == nil {
		panic("the weight must not be nil, please use Weight() function instead")
	}
	return p.weight
}

type SchedulingPolicyUnit struct {
	Struct
	comment     *string
	description *string
	enabled     *bool
	id          *string
	internal    *bool
	name        *string
	properties  *PropertySlice
	type_       *PolicyUnitType
}

func (p *SchedulingPolicyUnit) SetComment(attr string) {
	p.comment = &attr
}

func (p *SchedulingPolicyUnit) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *SchedulingPolicyUnit) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *SchedulingPolicyUnit) SetDescription(attr string) {
	p.description = &attr
}

func (p *SchedulingPolicyUnit) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *SchedulingPolicyUnit) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *SchedulingPolicyUnit) SetEnabled(attr bool) {
	p.enabled = &attr
}

func (p *SchedulingPolicyUnit) Enabled() (bool, bool) {
	if p.enabled != nil {
		return *p.enabled, true
	}
	var zero bool
	return zero, false
}

func (p *SchedulingPolicyUnit) MustEnabled() bool {
	if p.enabled == nil {
		panic("the enabled must not be nil, please use Enabled() function instead")
	}
	return *p.enabled
}

func (p *SchedulingPolicyUnit) SetId(attr string) {
	p.id = &attr
}

func (p *SchedulingPolicyUnit) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *SchedulingPolicyUnit) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *SchedulingPolicyUnit) SetInternal(attr bool) {
	p.internal = &attr
}

func (p *SchedulingPolicyUnit) Internal() (bool, bool) {
	if p.internal != nil {
		return *p.internal, true
	}
	var zero bool
	return zero, false
}

func (p *SchedulingPolicyUnit) MustInternal() bool {
	if p.internal == nil {
		panic("the internal must not be nil, please use Internal() function instead")
	}
	return *p.internal
}

func (p *SchedulingPolicyUnit) SetName(attr string) {
	p.name = &attr
}

func (p *SchedulingPolicyUnit) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *SchedulingPolicyUnit) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *SchedulingPolicyUnit) SetProperties(attr *PropertySlice) {
	p.properties = attr
}

func (p *SchedulingPolicyUnit) Properties() (*PropertySlice, bool) {
	if p.properties != nil {
		return p.properties, true
	}
	return nil, false
}

func (p *SchedulingPolicyUnit) MustProperties() *PropertySlice {
	if p.properties == nil {
		panic("the properties must not be nil, please use Properties() function instead")
	}
	return p.properties
}

// SetType Holds the types of all internal policy unit types.
func (p *SchedulingPolicyUnit) SetType(attr PolicyUnitType) {
	p.type_ = &attr
}

// Type Holds the types of all internal policy unit types.
func (p *SchedulingPolicyUnit) Type() (PolicyUnitType, bool) {
	if p.type_ != nil {
		return *p.type_, true
	}
	var zero PolicyUnitType
	return zero, false
}

// MustType Holds the types of all internal policy unit types.
func (p *SchedulingPolicyUnit) MustType() PolicyUnitType {
	if p.type_ == nil {
		panic("the type_ must not be nil, please use Type() function instead")
	}
	return *p.type_
}

// SeLinux Represents SELinux in the system.
type SeLinux struct {
	Struct
	mode *SeLinuxMode
}

// SetMode Represents an SELinux enforcement mode.
func (p *SeLinux) SetMode(attr SeLinuxMode) {
	p.mode = &attr
}

// Mode Represents an SELinux enforcement mode.
func (p *SeLinux) Mode() (SeLinuxMode, bool) {
	if p.mode != nil {
		return *p.mode, true
	}
	var zero SeLinuxMode
	return zero, false
}

// MustMode Represents an SELinux enforcement mode.
func (p *SeLinux) MustMode() SeLinuxMode {
	if p.mode == nil {
		panic("the mode must not be nil, please use Mode() function instead")
	}
	return *p.mode
}

type SerialNumber struct {
	Struct
	policy *SerialNumberPolicy
	value  *string
}

// SetPolicy Type representing the policy of a Serial Number.
func (p *SerialNumber) SetPolicy(attr SerialNumberPolicy) {
	p.policy = &attr
}

// Policy Type representing the policy of a Serial Number.
func (p *SerialNumber) Policy() (SerialNumberPolicy, bool) {
	if p.policy != nil {
		return *p.policy, true
	}
	var zero SerialNumberPolicy
	return zero, false
}

// MustPolicy Type representing the policy of a Serial Number.
func (p *SerialNumber) MustPolicy() SerialNumberPolicy {
	if p.policy == nil {
		panic("the policy must not be nil, please use Policy() function instead")
	}
	return *p.policy
}

func (p *SerialNumber) SetValue(attr string) {
	p.value = &attr
}

func (p *SerialNumber) Value() (string, bool) {
	if p.value != nil {
		return *p.value, true
	}
	var zero string
	return zero, false
}

func (p *SerialNumber) MustValue() string {
	if p.value == nil {
		panic("the value must not be nil, please use Value() function instead")
	}
	return *p.value
}

// Session Describes a user session to a virtual machine.
type Session struct {
	Struct
	comment     *string
	consoleUser *bool
	description *string
	id          *string
	ip          *Ip
	name        *string
	protocol    *string
	user        *User
	vm          *Vm
}

func (p *Session) SetComment(attr string) {
	p.comment = &attr
}

func (p *Session) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *Session) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *Session) SetConsoleUser(attr bool) {
	p.consoleUser = &attr
}

func (p *Session) ConsoleUser() (bool, bool) {
	if p.consoleUser != nil {
		return *p.consoleUser, true
	}
	var zero bool
	return zero, false
}

func (p *Session) MustConsoleUser() bool {
	if p.consoleUser == nil {
		panic("the consoleUser must not be nil, please use ConsoleUser() function instead")
	}
	return *p.consoleUser
}

func (p *Session) SetDescription(attr string) {
	p.description = &attr
}

func (p *Session) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *Session) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *Session) SetId(attr string) {
	p.id = &attr
}

func (p *Session) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *Session) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

// SetIp Represents the IP configuration of a network interface.
func (p *Session) SetIp(attr *Ip) {
	p.ip = attr
}

// Ip Represents the IP configuration of a network interface.
func (p *Session) Ip() (*Ip, bool) {
	if p.ip != nil {
		return p.ip, true
	}
	return nil, false
}

// MustIp Represents the IP configuration of a network interface.
func (p *Session) MustIp() *Ip {
	if p.ip == nil {
		panic("the ip must not be nil, please use Ip() function instead")
	}
	return p.ip
}

func (p *Session) SetName(attr string) {
	p.name = &attr
}

func (p *Session) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *Session) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *Session) SetProtocol(attr string) {
	p.protocol = &attr
}

func (p *Session) Protocol() (string, bool) {
	if p.protocol != nil {
		return *p.protocol, true
	}
	var zero string
	return zero, false
}

func (p *Session) MustProtocol() string {
	if p.protocol == nil {
		panic("the protocol must not be nil, please use Protocol() function instead")
	}
	return *p.protocol
}

// SetUser Represents a user in the system.
func (p *Session) SetUser(attr *User) {
	p.user = attr
}

// User Represents a user in the system.
func (p *Session) User() (*User, bool) {
	if p.user != nil {
		return p.user, true
	}
	return nil, false
}

// MustUser Represents a user in the system.
func (p *Session) MustUser() *User {
	if p.user == nil {
		panic("the user must not be nil, please use User() function instead")
	}
	return p.user
}

// SetVm Represents a virtual machine.
func (p *Session) SetVm(attr *Vm) {
	p.vm = attr
}

// Vm Represents a virtual machine.
func (p *Session) Vm() (*Vm, bool) {
	if p.vm != nil {
		return p.vm, true
	}
	return nil, false
}

// MustVm Represents a virtual machine.
func (p *Session) MustVm() *Vm {
	if p.vm == nil {
		panic("the vm must not be nil, please use Vm() function instead")
	}
	return p.vm
}

type SkipIfConnectivityBroken struct {
	Struct
	enabled   *bool
	threshold *int64
}

func (p *SkipIfConnectivityBroken) SetEnabled(attr bool) {
	p.enabled = &attr
}

func (p *SkipIfConnectivityBroken) Enabled() (bool, bool) {
	if p.enabled != nil {
		return *p.enabled, true
	}
	var zero bool
	return zero, false
}

func (p *SkipIfConnectivityBroken) MustEnabled() bool {
	if p.enabled == nil {
		panic("the enabled must not be nil, please use Enabled() function instead")
	}
	return *p.enabled
}

func (p *SkipIfConnectivityBroken) SetThreshold(attr int64) {
	p.threshold = &attr
}

func (p *SkipIfConnectivityBroken) Threshold() (int64, bool) {
	if p.threshold != nil {
		return *p.threshold, true
	}
	var zero int64
	return zero, false
}

func (p *SkipIfConnectivityBroken) MustThreshold() int64 {
	if p.threshold == nil {
		panic("the threshold must not be nil, please use Threshold() function instead")
	}
	return *p.threshold
}

// SkipIfSdActive This type represents the storage related
// configuration in the fencing policy.
type SkipIfSdActive struct {
	Struct
	enabled *bool
}

func (p *SkipIfSdActive) SetEnabled(attr bool) {
	p.enabled = &attr
}

func (p *SkipIfSdActive) Enabled() (bool, bool) {
	if p.enabled != nil {
		return *p.enabled, true
	}
	var zero bool
	return zero, false
}

func (p *SkipIfSdActive) MustEnabled() bool {
	if p.enabled == nil {
		panic("the enabled must not be nil, please use Enabled() function instead")
	}
	return *p.enabled
}

// Snapshot Represents a snapshot object.
//
// Example XML representation:
//
// [source,xml]
// ----
// <snapshot id="456" href="/ovirt-engine/api/vms/123/snapshots/456">
//   <actions>
//     <link rel="restore" href="/ovirt-engine/api/vms/123/snapshots/456/restore"/>
//   </actions>
//   <vm id="123" href="/ovirt-engine/api/vms/123"/>
//   <description>Virtual Machine 1 - Snapshot A</description>
//   <type>active</type>
//   <date>2010-08-16T14:24:29</date>
//   <persist_memorystate>false</persist_memorystate>
// </snapshot>
// ----
type Snapshot struct {
	Struct
	affinityLabels               *AffinityLabelSlice
	applications                 *ApplicationSlice
	bios                         *Bios
	cdroms                       *CdromSlice
	cluster                      *Cluster
	comment                      *string
	console                      *Console
	cpu                          *Cpu
	cpuProfile                   *CpuProfile
	cpuShares                    *int64
	creationTime                 *time.Time
	customCompatibilityVersion   *Version
	customCpuModel               *string
	customEmulatedMachine        *string
	customProperties             *CustomPropertySlice
	date                         *time.Time
	deleteProtected              *bool
	description                  *string
	diskAttachments              *DiskAttachmentSlice
	disks                        *DiskSlice
	display                      *Display
	domain                       *Domain
	externalHostProvider         *ExternalHostProvider
	floppies                     *FloppySlice
	fqdn                         *string
	graphicsConsoles             *GraphicsConsoleSlice
	guestOperatingSystem         *GuestOperatingSystem
	guestTimeZone                *TimeZone
	hasIllegalImages             *bool
	highAvailability             *HighAvailability
	host                         *Host
	hostDevices                  *HostDeviceSlice
	id                           *string
	initialization               *Initialization
	instanceType                 *InstanceType
	io                           *Io
	katelloErrata                *KatelloErratumSlice
	largeIcon                    *Icon
	lease                        *StorageDomainLease
	memory                       *int64
	memoryPolicy                 *MemoryPolicy
	migration                    *MigrationOptions
	migrationDowntime            *int64
	multiQueuesEnabled           *bool
	name                         *string
	nextRunConfigurationExists   *bool
	nics                         *NicSlice
	numaNodes                    *NumaNodeSlice
	numaTuneMode                 *NumaTuneMode
	origin                       *string
	originalTemplate             *Template
	os                           *OperatingSystem
	payloads                     *PayloadSlice
	permissions                  *PermissionSlice
	persistMemorystate           *bool
	placementPolicy              *VmPlacementPolicy
	quota                        *Quota
	reportedDevices              *ReportedDeviceSlice
	rngDevice                    *RngDevice
	runOnce                      *bool
	serialNumber                 *SerialNumber
	sessions                     *SessionSlice
	smallIcon                    *Icon
	snapshotStatus               *SnapshotStatus
	snapshotType                 *SnapshotType
	snapshots                    *SnapshotSlice
	soundcardEnabled             *bool
	sso                          *Sso
	startPaused                  *bool
	startTime                    *time.Time
	stateless                    *bool
	statistics                   *StatisticSlice
	status                       *VmStatus
	statusDetail                 *string
	stopReason                   *string
	stopTime                     *time.Time
	storageDomain                *StorageDomain
	storageErrorResumeBehaviour  *VmStorageErrorResumeBehaviour
	tags                         *TagSlice
	template                     *Template
	timeZone                     *TimeZone
	tpmEnabled                   *bool
	tunnelMigration              *bool
	type_                        *VmType
	usb                          *Usb
	useLatestTemplateVersion     *bool
	virtioScsi                   *VirtioScsi
	virtioScsiMultiQueuesEnabled *bool
	vm                           *Vm
	vmPool                       *VmPool
	watchdogs                    *WatchdogSlice
}

func (p *Snapshot) SetAffinityLabels(attr *AffinityLabelSlice) {
	p.affinityLabels = attr
}

func (p *Snapshot) AffinityLabels() (*AffinityLabelSlice, bool) {
	if p.affinityLabels != nil {
		return p.affinityLabels, true
	}
	return nil, false
}

func (p *Snapshot) MustAffinityLabels() *AffinityLabelSlice {
	if p.affinityLabels == nil {
		panic("the affinityLabels must not be nil, please use AffinityLabels() function instead")
	}
	return p.affinityLabels
}

func (p *Snapshot) SetApplications(attr *ApplicationSlice) {
	p.applications = attr
}

func (p *Snapshot) Applications() (*ApplicationSlice, bool) {
	if p.applications != nil {
		return p.applications, true
	}
	return nil, false
}

func (p *Snapshot) MustApplications() *ApplicationSlice {
	if p.applications == nil {
		panic("the applications must not be nil, please use Applications() function instead")
	}
	return p.applications
}

func (p *Snapshot) SetBios(attr *Bios) {
	p.bios = attr
}

func (p *Snapshot) Bios() (*Bios, bool) {
	if p.bios != nil {
		return p.bios, true
	}
	return nil, false
}

func (p *Snapshot) MustBios() *Bios {
	if p.bios == nil {
		panic("the bios must not be nil, please use Bios() function instead")
	}
	return p.bios
}

func (p *Snapshot) SetCdroms(attr *CdromSlice) {
	p.cdroms = attr
}

func (p *Snapshot) Cdroms() (*CdromSlice, bool) {
	if p.cdroms != nil {
		return p.cdroms, true
	}
	return nil, false
}

func (p *Snapshot) MustCdroms() *CdromSlice {
	if p.cdroms == nil {
		panic("the cdroms must not be nil, please use Cdroms() function instead")
	}
	return p.cdroms
}

// SetCluster Type representation of a cluster.
//
// A JSON representation of a cluster:
//
// [source]
// ----
// {
//   "cluster" : [ {
//     "ballooning_enabled" : "false",
//     "cpu" : {
//       "architecture" : "x86_64",
//       "type" : "Intel SandyBridge Family"
//     },
//     "custom_scheduling_policy_properties" : {
//       "property" : [ {
//         "name" : "HighUtilization",
//         "value" : "80"
//       }, {
//         "name" : "CpuOverCommitDurationMinutes",
//         "value" : "2"
//       } ]
//     },
//     "error_handling" : {
//       "on_error" : "migrate"
//     },
//     "fencing_policy" : {
//       "enabled" : "true",
//       "skip_if_connectivity_broken" : {
//         "enabled" : "false",
//         "threshold" : "50"
//       },
//       "skip_if_gluster_bricks_up" : "false",
//       "skip_if_gluster_quorum_not_met" : "false",
//       "skip_if_sd_active" : {
//         "enabled" : "false"
//       }
//     },
//     "gluster_service" : "false",
//     "firewall_type" : "iptables",
//     "ha_reservation" : "false",
//     "ksm" : {
//       "enabled" : "true",
//       "merge_across_nodes" : "true"
//     },
//     "memory_policy" : {
//       "over_commit" : {
//         "percent" : "100"
//       },
//       "transparent_hugepages" : {
//         "enabled" : "true"
//       }
//     },
//     "migration" : {
//       "auto_converge" : "inherit",
//       "bandwidth" : {
//         "assignment_method" : "auto"
//       },
//       "compressed" : "inherit",
//       "policy" : {
//         "id" : "00000000-0000-0000-0000-000000000000"
//       }
//     },
//     "required_rng_sources" : {
//       "required_rng_source" : [ "random" ]
//     },
//     "switch_type" : "legacy",
//     "threads_as_cores" : "false",
//     "trusted_service" : "false",
//     "tunnel_migration" : "false",
//     "version" : {
//       "major" : "4",
//       "minor" : "1"
//     },
//     "virt_service" : "true",
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "mac_pool" : {
//       "href" : "/ovirt-engine/api/macpools/456",
//       "id" : "456"
//     },
//     "scheduling_policy" : {
//       "href" : "/ovirt-engine/api/schedulingpolicies/789",
//       "id" : "789"
//     },
//     "actions" : {
//       "link" : [ {
//         "href" : "/ovirt-engine/api/clusters/234/resetemulatedmachine",
//         "rel" : "resetemulatedmachine"
//       } ]
//     },
//     "name" : "Default",
//     "description" : "The default server cluster",
//     "href" : "/ovirt-engine/api/clusters/234",
//     "id" : "234",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/clusters/234/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/cpuprofiles",
//       "rel" : "cpuprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networkfilters",
//       "rel" : "networkfilters"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networks",
//       "rel" : "networks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/affinitygroups",
//       "rel" : "affinitygroups"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glusterhooks",
//       "rel" : "glusterhooks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glustervolumes",
//       "rel" : "glustervolumes"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/enabledfeatures",
//       "rel" : "enabledfeatures"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/externalnetworkproviders",
//       "rel" : "externalnetworkproviders"
//     } ]
//   } ]
// }
// ----
func (p *Snapshot) SetCluster(attr *Cluster) {
	p.cluster = attr
}

// Cluster Type representation of a cluster.
//
// A JSON representation of a cluster:
//
// [source]
// ----
// {
//   "cluster" : [ {
//     "ballooning_enabled" : "false",
//     "cpu" : {
//       "architecture" : "x86_64",
//       "type" : "Intel SandyBridge Family"
//     },
//     "custom_scheduling_policy_properties" : {
//       "property" : [ {
//         "name" : "HighUtilization",
//         "value" : "80"
//       }, {
//         "name" : "CpuOverCommitDurationMinutes",
//         "value" : "2"
//       } ]
//     },
//     "error_handling" : {
//       "on_error" : "migrate"
//     },
//     "fencing_policy" : {
//       "enabled" : "true",
//       "skip_if_connectivity_broken" : {
//         "enabled" : "false",
//         "threshold" : "50"
//       },
//       "skip_if_gluster_bricks_up" : "false",
//       "skip_if_gluster_quorum_not_met" : "false",
//       "skip_if_sd_active" : {
//         "enabled" : "false"
//       }
//     },
//     "gluster_service" : "false",
//     "firewall_type" : "iptables",
//     "ha_reservation" : "false",
//     "ksm" : {
//       "enabled" : "true",
//       "merge_across_nodes" : "true"
//     },
//     "memory_policy" : {
//       "over_commit" : {
//         "percent" : "100"
//       },
//       "transparent_hugepages" : {
//         "enabled" : "true"
//       }
//     },
//     "migration" : {
//       "auto_converge" : "inherit",
//       "bandwidth" : {
//         "assignment_method" : "auto"
//       },
//       "compressed" : "inherit",
//       "policy" : {
//         "id" : "00000000-0000-0000-0000-000000000000"
//       }
//     },
//     "required_rng_sources" : {
//       "required_rng_source" : [ "random" ]
//     },
//     "switch_type" : "legacy",
//     "threads_as_cores" : "false",
//     "trusted_service" : "false",
//     "tunnel_migration" : "false",
//     "version" : {
//       "major" : "4",
//       "minor" : "1"
//     },
//     "virt_service" : "true",
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "mac_pool" : {
//       "href" : "/ovirt-engine/api/macpools/456",
//       "id" : "456"
//     },
//     "scheduling_policy" : {
//       "href" : "/ovirt-engine/api/schedulingpolicies/789",
//       "id" : "789"
//     },
//     "actions" : {
//       "link" : [ {
//         "href" : "/ovirt-engine/api/clusters/234/resetemulatedmachine",
//         "rel" : "resetemulatedmachine"
//       } ]
//     },
//     "name" : "Default",
//     "description" : "The default server cluster",
//     "href" : "/ovirt-engine/api/clusters/234",
//     "id" : "234",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/clusters/234/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/cpuprofiles",
//       "rel" : "cpuprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networkfilters",
//       "rel" : "networkfilters"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networks",
//       "rel" : "networks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/affinitygroups",
//       "rel" : "affinitygroups"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glusterhooks",
//       "rel" : "glusterhooks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glustervolumes",
//       "rel" : "glustervolumes"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/enabledfeatures",
//       "rel" : "enabledfeatures"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/externalnetworkproviders",
//       "rel" : "externalnetworkproviders"
//     } ]
//   } ]
// }
// ----
func (p *Snapshot) Cluster() (*Cluster, bool) {
	if p.cluster != nil {
		return p.cluster, true
	}
	return nil, false
}

// MustCluster Type representation of a cluster.
//
// A JSON representation of a cluster:
//
// [source]
// ----
// {
//   "cluster" : [ {
//     "ballooning_enabled" : "false",
//     "cpu" : {
//       "architecture" : "x86_64",
//       "type" : "Intel SandyBridge Family"
//     },
//     "custom_scheduling_policy_properties" : {
//       "property" : [ {
//         "name" : "HighUtilization",
//         "value" : "80"
//       }, {
//         "name" : "CpuOverCommitDurationMinutes",
//         "value" : "2"
//       } ]
//     },
//     "error_handling" : {
//       "on_error" : "migrate"
//     },
//     "fencing_policy" : {
//       "enabled" : "true",
//       "skip_if_connectivity_broken" : {
//         "enabled" : "false",
//         "threshold" : "50"
//       },
//       "skip_if_gluster_bricks_up" : "false",
//       "skip_if_gluster_quorum_not_met" : "false",
//       "skip_if_sd_active" : {
//         "enabled" : "false"
//       }
//     },
//     "gluster_service" : "false",
//     "firewall_type" : "iptables",
//     "ha_reservation" : "false",
//     "ksm" : {
//       "enabled" : "true",
//       "merge_across_nodes" : "true"
//     },
//     "memory_policy" : {
//       "over_commit" : {
//         "percent" : "100"
//       },
//       "transparent_hugepages" : {
//         "enabled" : "true"
//       }
//     },
//     "migration" : {
//       "auto_converge" : "inherit",
//       "bandwidth" : {
//         "assignment_method" : "auto"
//       },
//       "compressed" : "inherit",
//       "policy" : {
//         "id" : "00000000-0000-0000-0000-000000000000"
//       }
//     },
//     "required_rng_sources" : {
//       "required_rng_source" : [ "random" ]
//     },
//     "switch_type" : "legacy",
//     "threads_as_cores" : "false",
//     "trusted_service" : "false",
//     "tunnel_migration" : "false",
//     "version" : {
//       "major" : "4",
//       "minor" : "1"
//     },
//     "virt_service" : "true",
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "mac_pool" : {
//       "href" : "/ovirt-engine/api/macpools/456",
//       "id" : "456"
//     },
//     "scheduling_policy" : {
//       "href" : "/ovirt-engine/api/schedulingpolicies/789",
//       "id" : "789"
//     },
//     "actions" : {
//       "link" : [ {
//         "href" : "/ovirt-engine/api/clusters/234/resetemulatedmachine",
//         "rel" : "resetemulatedmachine"
//       } ]
//     },
//     "name" : "Default",
//     "description" : "The default server cluster",
//     "href" : "/ovirt-engine/api/clusters/234",
//     "id" : "234",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/clusters/234/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/cpuprofiles",
//       "rel" : "cpuprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networkfilters",
//       "rel" : "networkfilters"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networks",
//       "rel" : "networks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/affinitygroups",
//       "rel" : "affinitygroups"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glusterhooks",
//       "rel" : "glusterhooks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glustervolumes",
//       "rel" : "glustervolumes"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/enabledfeatures",
//       "rel" : "enabledfeatures"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/externalnetworkproviders",
//       "rel" : "externalnetworkproviders"
//     } ]
//   } ]
// }
// ----
func (p *Snapshot) MustCluster() *Cluster {
	if p.cluster == nil {
		panic("the cluster must not be nil, please use Cluster() function instead")
	}
	return p.cluster
}

func (p *Snapshot) SetComment(attr string) {
	p.comment = &attr
}

func (p *Snapshot) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *Snapshot) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

// SetConsole Representation for serial console device.
func (p *Snapshot) SetConsole(attr *Console) {
	p.console = attr
}

// Console Representation for serial console device.
func (p *Snapshot) Console() (*Console, bool) {
	if p.console != nil {
		return p.console, true
	}
	return nil, false
}

// MustConsole Representation for serial console device.
func (p *Snapshot) MustConsole() *Console {
	if p.console == nil {
		panic("the console must not be nil, please use Console() function instead")
	}
	return p.console
}

func (p *Snapshot) SetCpu(attr *Cpu) {
	p.cpu = attr
}

func (p *Snapshot) Cpu() (*Cpu, bool) {
	if p.cpu != nil {
		return p.cpu, true
	}
	return nil, false
}

func (p *Snapshot) MustCpu() *Cpu {
	if p.cpu == nil {
		panic("the cpu must not be nil, please use Cpu() function instead")
	}
	return p.cpu
}

func (p *Snapshot) SetCpuProfile(attr *CpuProfile) {
	p.cpuProfile = attr
}

func (p *Snapshot) CpuProfile() (*CpuProfile, bool) {
	if p.cpuProfile != nil {
		return p.cpuProfile, true
	}
	return nil, false
}

func (p *Snapshot) MustCpuProfile() *CpuProfile {
	if p.cpuProfile == nil {
		panic("the cpuProfile must not be nil, please use CpuProfile() function instead")
	}
	return p.cpuProfile
}

func (p *Snapshot) SetCpuShares(attr int64) {
	p.cpuShares = &attr
}

func (p *Snapshot) CpuShares() (int64, bool) {
	if p.cpuShares != nil {
		return *p.cpuShares, true
	}
	var zero int64
	return zero, false
}

func (p *Snapshot) MustCpuShares() int64 {
	if p.cpuShares == nil {
		panic("the cpuShares must not be nil, please use CpuShares() function instead")
	}
	return *p.cpuShares
}

func (p *Snapshot) SetCreationTime(attr time.Time) {
	p.creationTime = &attr
}

func (p *Snapshot) CreationTime() (time.Time, bool) {
	if p.creationTime != nil {
		return *p.creationTime, true
	}
	var zero time.Time
	return zero, false
}

func (p *Snapshot) MustCreationTime() time.Time {
	if p.creationTime == nil {
		panic("the creationTime must not be nil, please use CreationTime() function instead")
	}
	return *p.creationTime
}

func (p *Snapshot) SetCustomCompatibilityVersion(attr *Version) {
	p.customCompatibilityVersion = attr
}

func (p *Snapshot) CustomCompatibilityVersion() (*Version, bool) {
	if p.customCompatibilityVersion != nil {
		return p.customCompatibilityVersion, true
	}
	return nil, false
}

func (p *Snapshot) MustCustomCompatibilityVersion() *Version {
	if p.customCompatibilityVersion == nil {
		panic("the customCompatibilityVersion must not be nil, please use CustomCompatibilityVersion() function instead")
	}
	return p.customCompatibilityVersion
}

func (p *Snapshot) SetCustomCpuModel(attr string) {
	p.customCpuModel = &attr
}

func (p *Snapshot) CustomCpuModel() (string, bool) {
	if p.customCpuModel != nil {
		return *p.customCpuModel, true
	}
	var zero string
	return zero, false
}

func (p *Snapshot) MustCustomCpuModel() string {
	if p.customCpuModel == nil {
		panic("the customCpuModel must not be nil, please use CustomCpuModel() function instead")
	}
	return *p.customCpuModel
}

func (p *Snapshot) SetCustomEmulatedMachine(attr string) {
	p.customEmulatedMachine = &attr
}

func (p *Snapshot) CustomEmulatedMachine() (string, bool) {
	if p.customEmulatedMachine != nil {
		return *p.customEmulatedMachine, true
	}
	var zero string
	return zero, false
}

func (p *Snapshot) MustCustomEmulatedMachine() string {
	if p.customEmulatedMachine == nil {
		panic("the customEmulatedMachine must not be nil, please use CustomEmulatedMachine() function instead")
	}
	return *p.customEmulatedMachine
}

func (p *Snapshot) SetCustomProperties(attr *CustomPropertySlice) {
	p.customProperties = attr
}

func (p *Snapshot) CustomProperties() (*CustomPropertySlice, bool) {
	if p.customProperties != nil {
		return p.customProperties, true
	}
	return nil, false
}

func (p *Snapshot) MustCustomProperties() *CustomPropertySlice {
	if p.customProperties == nil {
		panic("the customProperties must not be nil, please use CustomProperties() function instead")
	}
	return p.customProperties
}

func (p *Snapshot) SetDate(attr time.Time) {
	p.date = &attr
}

func (p *Snapshot) Date() (time.Time, bool) {
	if p.date != nil {
		return *p.date, true
	}
	var zero time.Time
	return zero, false
}

func (p *Snapshot) MustDate() time.Time {
	if p.date == nil {
		panic("the date must not be nil, please use Date() function instead")
	}
	return *p.date
}

func (p *Snapshot) SetDeleteProtected(attr bool) {
	p.deleteProtected = &attr
}

func (p *Snapshot) DeleteProtected() (bool, bool) {
	if p.deleteProtected != nil {
		return *p.deleteProtected, true
	}
	var zero bool
	return zero, false
}

func (p *Snapshot) MustDeleteProtected() bool {
	if p.deleteProtected == nil {
		panic("the deleteProtected must not be nil, please use DeleteProtected() function instead")
	}
	return *p.deleteProtected
}

func (p *Snapshot) SetDescription(attr string) {
	p.description = &attr
}

func (p *Snapshot) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *Snapshot) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *Snapshot) SetDiskAttachments(attr *DiskAttachmentSlice) {
	p.diskAttachments = attr
}

func (p *Snapshot) DiskAttachments() (*DiskAttachmentSlice, bool) {
	if p.diskAttachments != nil {
		return p.diskAttachments, true
	}
	return nil, false
}

func (p *Snapshot) MustDiskAttachments() *DiskAttachmentSlice {
	if p.diskAttachments == nil {
		panic("the diskAttachments must not be nil, please use DiskAttachments() function instead")
	}
	return p.diskAttachments
}

func (p *Snapshot) SetDisks(attr *DiskSlice) {
	p.disks = attr
}

func (p *Snapshot) Disks() (*DiskSlice, bool) {
	if p.disks != nil {
		return p.disks, true
	}
	return nil, false
}

func (p *Snapshot) MustDisks() *DiskSlice {
	if p.disks == nil {
		panic("the disks must not be nil, please use Disks() function instead")
	}
	return p.disks
}

// SetDisplay Represents a graphic console configuration.
func (p *Snapshot) SetDisplay(attr *Display) {
	p.display = attr
}

// Display Represents a graphic console configuration.
func (p *Snapshot) Display() (*Display, bool) {
	if p.display != nil {
		return p.display, true
	}
	return nil, false
}

// MustDisplay Represents a graphic console configuration.
func (p *Snapshot) MustDisplay() *Display {
	if p.display == nil {
		panic("the display must not be nil, please use Display() function instead")
	}
	return p.display
}

// SetDomain This type represents a directory service domain.
func (p *Snapshot) SetDomain(attr *Domain) {
	p.domain = attr
}

// Domain This type represents a directory service domain.
func (p *Snapshot) Domain() (*Domain, bool) {
	if p.domain != nil {
		return p.domain, true
	}
	return nil, false
}

// MustDomain This type represents a directory service domain.
func (p *Snapshot) MustDomain() *Domain {
	if p.domain == nil {
		panic("the domain must not be nil, please use Domain() function instead")
	}
	return p.domain
}

// SetExternalHostProvider Represents an external host provider,
// such as Foreman or Satellite.
//
// See https://www.theforeman.org/ for more details on Foreman.
// See https://access.redhat.com/products/red-hat-satellite
// for more details on Red Hat Satellite.
func (p *Snapshot) SetExternalHostProvider(attr *ExternalHostProvider) {
	p.externalHostProvider = attr
}

// ExternalHostProvider Represents an external host provider,
// such as Foreman or Satellite.
//
// See https://www.theforeman.org/ for more details on Foreman.
// See https://access.redhat.com/products/red-hat-satellite
// for more details on Red Hat Satellite.
func (p *Snapshot) ExternalHostProvider() (*ExternalHostProvider, bool) {
	if p.externalHostProvider != nil {
		return p.externalHostProvider, true
	}
	return nil, false
}

// MustExternalHostProvider Represents an external host provider,
// such as Foreman or Satellite.
//
// See https://www.theforeman.org/ for more details on Foreman.
// See https://access.redhat.com/products/red-hat-satellite
// for more details on Red Hat Satellite.
func (p *Snapshot) MustExternalHostProvider() *ExternalHostProvider {
	if p.externalHostProvider == nil {
		panic("the externalHostProvider must not be nil, please use ExternalHostProvider() function instead")
	}
	return p.externalHostProvider
}

func (p *Snapshot) SetFloppies(attr *FloppySlice) {
	p.floppies = attr
}

func (p *Snapshot) Floppies() (*FloppySlice, bool) {
	if p.floppies != nil {
		return p.floppies, true
	}
	return nil, false
}

func (p *Snapshot) MustFloppies() *FloppySlice {
	if p.floppies == nil {
		panic("the floppies must not be nil, please use Floppies() function instead")
	}
	return p.floppies
}

func (p *Snapshot) SetFqdn(attr string) {
	p.fqdn = &attr
}

func (p *Snapshot) Fqdn() (string, bool) {
	if p.fqdn != nil {
		return *p.fqdn, true
	}
	var zero string
	return zero, false
}

func (p *Snapshot) MustFqdn() string {
	if p.fqdn == nil {
		panic("the fqdn must not be nil, please use Fqdn() function instead")
	}
	return *p.fqdn
}

func (p *Snapshot) SetGraphicsConsoles(attr *GraphicsConsoleSlice) {
	p.graphicsConsoles = attr
}

func (p *Snapshot) GraphicsConsoles() (*GraphicsConsoleSlice, bool) {
	if p.graphicsConsoles != nil {
		return p.graphicsConsoles, true
	}
	return nil, false
}

func (p *Snapshot) MustGraphicsConsoles() *GraphicsConsoleSlice {
	if p.graphicsConsoles == nil {
		panic("the graphicsConsoles must not be nil, please use GraphicsConsoles() function instead")
	}
	return p.graphicsConsoles
}

// SetGuestOperatingSystem Represents an operating system installed on the virtual machine.
//
// To get that information send a request like this:
//
// ....
// GET /ovirt-engine/api/vms/123
// ....
//
// The result will be like this:
//
// [source,xml]
// ----
// <vm href="/ovirt-engine/api/vms/123" id="123">
// ...
//   <guest_operating_system>
//     <architecture>x86_64</architecture>
//     <codename>Maipo</codename>
//     <distribution>Red Hat Enterprise Linux Server</distribution>
//     <family>Linux</family>
//     <kernel>
//       <version>
//         <build>0</build>
//         <full_version>3.10.0-514.10.2.el7.x86_64</full_version>
//         <major>3</major>
//         <minor>10</minor>
//         <revision>514</revision>
//       </version>
//     </kernel>
//     <version>
//       <full_version>7.3</full_version>
//       <major>7</major>
//       <minor>3</minor>
//     </version>
//   </guest_operating_system>
// </vm>
// ----
func (p *Snapshot) SetGuestOperatingSystem(attr *GuestOperatingSystem) {
	p.guestOperatingSystem = attr
}

// GuestOperatingSystem Represents an operating system installed on the virtual machine.
//
// To get that information send a request like this:
//
// ....
// GET /ovirt-engine/api/vms/123
// ....
//
// The result will be like this:
//
// [source,xml]
// ----
// <vm href="/ovirt-engine/api/vms/123" id="123">
// ...
//   <guest_operating_system>
//     <architecture>x86_64</architecture>
//     <codename>Maipo</codename>
//     <distribution>Red Hat Enterprise Linux Server</distribution>
//     <family>Linux</family>
//     <kernel>
//       <version>
//         <build>0</build>
//         <full_version>3.10.0-514.10.2.el7.x86_64</full_version>
//         <major>3</major>
//         <minor>10</minor>
//         <revision>514</revision>
//       </version>
//     </kernel>
//     <version>
//       <full_version>7.3</full_version>
//       <major>7</major>
//       <minor>3</minor>
//     </version>
//   </guest_operating_system>
// </vm>
// ----
func (p *Snapshot) GuestOperatingSystem() (*GuestOperatingSystem, bool) {
	if p.guestOperatingSystem != nil {
		return p.guestOperatingSystem, true
	}
	return nil, false
}

// MustGuestOperatingSystem Represents an operating system installed on the virtual machine.
//
// To get that information send a request like this:
//
// ....
// GET /ovirt-engine/api/vms/123
// ....
//
// The result will be like this:
//
// [source,xml]
// ----
// <vm href="/ovirt-engine/api/vms/123" id="123">
// ...
//   <guest_operating_system>
//     <architecture>x86_64</architecture>
//     <codename>Maipo</codename>
//     <distribution>Red Hat Enterprise Linux Server</distribution>
//     <family>Linux</family>
//     <kernel>
//       <version>
//         <build>0</build>
//         <full_version>3.10.0-514.10.2.el7.x86_64</full_version>
//         <major>3</major>
//         <minor>10</minor>
//         <revision>514</revision>
//       </version>
//     </kernel>
//     <version>
//       <full_version>7.3</full_version>
//       <major>7</major>
//       <minor>3</minor>
//     </version>
//   </guest_operating_system>
// </vm>
// ----
func (p *Snapshot) MustGuestOperatingSystem() *GuestOperatingSystem {
	if p.guestOperatingSystem == nil {
		panic("the guestOperatingSystem must not be nil, please use GuestOperatingSystem() function instead")
	}
	return p.guestOperatingSystem
}

// SetGuestTimeZone Time zone representation.
func (p *Snapshot) SetGuestTimeZone(attr *TimeZone) {
	p.guestTimeZone = attr
}

// GuestTimeZone Time zone representation.
func (p *Snapshot) GuestTimeZone() (*TimeZone, bool) {
	if p.guestTimeZone != nil {
		return p.guestTimeZone, true
	}
	return nil, false
}

// MustGuestTimeZone Time zone representation.
func (p *Snapshot) MustGuestTimeZone() *TimeZone {
	if p.guestTimeZone == nil {
		panic("the guestTimeZone must not be nil, please use GuestTimeZone() function instead")
	}
	return p.guestTimeZone
}

func (p *Snapshot) SetHasIllegalImages(attr bool) {
	p.hasIllegalImages = &attr
}

func (p *Snapshot) HasIllegalImages() (bool, bool) {
	if p.hasIllegalImages != nil {
		return *p.hasIllegalImages, true
	}
	var zero bool
	return zero, false
}

func (p *Snapshot) MustHasIllegalImages() bool {
	if p.hasIllegalImages == nil {
		panic("the hasIllegalImages must not be nil, please use HasIllegalImages() function instead")
	}
	return *p.hasIllegalImages
}

// SetHighAvailability Type representing high availability of a virtual machine.
func (p *Snapshot) SetHighAvailability(attr *HighAvailability) {
	p.highAvailability = attr
}

// HighAvailability Type representing high availability of a virtual machine.
func (p *Snapshot) HighAvailability() (*HighAvailability, bool) {
	if p.highAvailability != nil {
		return p.highAvailability, true
	}
	return nil, false
}

// MustHighAvailability Type representing high availability of a virtual machine.
func (p *Snapshot) MustHighAvailability() *HighAvailability {
	if p.highAvailability == nil {
		panic("the highAvailability must not be nil, please use HighAvailability() function instead")
	}
	return p.highAvailability
}

// SetHost Type representing a host.
func (p *Snapshot) SetHost(attr *Host) {
	p.host = attr
}

// Host Type representing a host.
func (p *Snapshot) Host() (*Host, bool) {
	if p.host != nil {
		return p.host, true
	}
	return nil, false
}

// MustHost Type representing a host.
func (p *Snapshot) MustHost() *Host {
	if p.host == nil {
		panic("the host must not be nil, please use Host() function instead")
	}
	return p.host
}

func (p *Snapshot) SetHostDevices(attr *HostDeviceSlice) {
	p.hostDevices = attr
}

func (p *Snapshot) HostDevices() (*HostDeviceSlice, bool) {
	if p.hostDevices != nil {
		return p.hostDevices, true
	}
	return nil, false
}

func (p *Snapshot) MustHostDevices() *HostDeviceSlice {
	if p.hostDevices == nil {
		panic("the hostDevices must not be nil, please use HostDevices() function instead")
	}
	return p.hostDevices
}

func (p *Snapshot) SetId(attr string) {
	p.id = &attr
}

func (p *Snapshot) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *Snapshot) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *Snapshot) SetInitialization(attr *Initialization) {
	p.initialization = attr
}

func (p *Snapshot) Initialization() (*Initialization, bool) {
	if p.initialization != nil {
		return p.initialization, true
	}
	return nil, false
}

func (p *Snapshot) MustInitialization() *Initialization {
	if p.initialization == nil {
		panic("the initialization must not be nil, please use Initialization() function instead")
	}
	return p.initialization
}

// SetInstanceType Describes the hardware configuration of virtual machines.
//
// For example `medium` instance type includes 1 virtual CPU and 4 GiB of memory. It is a top-level
// entity (e.g. not bound to any data center or cluster). The attributes that are used for instance
// types and are common to virtual machine and template types are:
//
// - `console`
// - `cpu`
// - `custom_cpu_model`
// - `custom_emulated_machine`
// - `display`
// - `high_availability`
// - `io`
// - `memory`
// - `memory_policy`
// - `migration`
// - `migration_downtime`
// - `os`
// - `rng_device`
// - `soundcard_enabled`
// - `usb`
// - `virtio_scsi`
//
// When creating a virtual machine from both an instance type and a template, the virtual machine
// will inherit the hardware configurations from the instance type
//
// NOTE: An instance type inherits it's attributes from the template entity although most template
// attributes are not used in instance types.
func (p *Snapshot) SetInstanceType(attr *InstanceType) {
	p.instanceType = attr
}

// InstanceType Describes the hardware configuration of virtual machines.
//
// For example `medium` instance type includes 1 virtual CPU and 4 GiB of memory. It is a top-level
// entity (e.g. not bound to any data center or cluster). The attributes that are used for instance
// types and are common to virtual machine and template types are:
//
// - `console`
// - `cpu`
// - `custom_cpu_model`
// - `custom_emulated_machine`
// - `display`
// - `high_availability`
// - `io`
// - `memory`
// - `memory_policy`
// - `migration`
// - `migration_downtime`
// - `os`
// - `rng_device`
// - `soundcard_enabled`
// - `usb`
// - `virtio_scsi`
//
// When creating a virtual machine from both an instance type and a template, the virtual machine
// will inherit the hardware configurations from the instance type
//
// NOTE: An instance type inherits it's attributes from the template entity although most template
// attributes are not used in instance types.
func (p *Snapshot) InstanceType() (*InstanceType, bool) {
	if p.instanceType != nil {
		return p.instanceType, true
	}
	return nil, false
}

// MustInstanceType Describes the hardware configuration of virtual machines.
//
// For example `medium` instance type includes 1 virtual CPU and 4 GiB of memory. It is a top-level
// entity (e.g. not bound to any data center or cluster). The attributes that are used for instance
// types and are common to virtual machine and template types are:
//
// - `console`
// - `cpu`
// - `custom_cpu_model`
// - `custom_emulated_machine`
// - `display`
// - `high_availability`
// - `io`
// - `memory`
// - `memory_policy`
// - `migration`
// - `migration_downtime`
// - `os`
// - `rng_device`
// - `soundcard_enabled`
// - `usb`
// - `virtio_scsi`
//
// When creating a virtual machine from both an instance type and a template, the virtual machine
// will inherit the hardware configurations from the instance type
//
// NOTE: An instance type inherits it's attributes from the template entity although most template
// attributes are not used in instance types.
func (p *Snapshot) MustInstanceType() *InstanceType {
	if p.instanceType == nil {
		panic("the instanceType must not be nil, please use InstanceType() function instead")
	}
	return p.instanceType
}

func (p *Snapshot) SetIo(attr *Io) {
	p.io = attr
}

func (p *Snapshot) Io() (*Io, bool) {
	if p.io != nil {
		return p.io, true
	}
	return nil, false
}

func (p *Snapshot) MustIo() *Io {
	if p.io == nil {
		panic("the io must not be nil, please use Io() function instead")
	}
	return p.io
}

func (p *Snapshot) SetKatelloErrata(attr *KatelloErratumSlice) {
	p.katelloErrata = attr
}

func (p *Snapshot) KatelloErrata() (*KatelloErratumSlice, bool) {
	if p.katelloErrata != nil {
		return p.katelloErrata, true
	}
	return nil, false
}

func (p *Snapshot) MustKatelloErrata() *KatelloErratumSlice {
	if p.katelloErrata == nil {
		panic("the katelloErrata must not be nil, please use KatelloErrata() function instead")
	}
	return p.katelloErrata
}

// SetLargeIcon Icon of virtual machine or template.
func (p *Snapshot) SetLargeIcon(attr *Icon) {
	p.largeIcon = attr
}

// LargeIcon Icon of virtual machine or template.
func (p *Snapshot) LargeIcon() (*Icon, bool) {
	if p.largeIcon != nil {
		return p.largeIcon, true
	}
	return nil, false
}

// MustLargeIcon Icon of virtual machine or template.
func (p *Snapshot) MustLargeIcon() *Icon {
	if p.largeIcon == nil {
		panic("the largeIcon must not be nil, please use LargeIcon() function instead")
	}
	return p.largeIcon
}

// SetLease Represents a lease residing on a storage domain.
//
// A lease is a http://www.ovirt.org/develop/developer-guide/vdsm/sanlock[Sanlock] resource residing on a special
// volume on the storage domain, this Sanlock resource is used to provide storage base locking.
func (p *Snapshot) SetLease(attr *StorageDomainLease) {
	p.lease = attr
}

// Lease Represents a lease residing on a storage domain.
//
// A lease is a http://www.ovirt.org/develop/developer-guide/vdsm/sanlock[Sanlock] resource residing on a special
// volume on the storage domain, this Sanlock resource is used to provide storage base locking.
func (p *Snapshot) Lease() (*StorageDomainLease, bool) {
	if p.lease != nil {
		return p.lease, true
	}
	return nil, false
}

// MustLease Represents a lease residing on a storage domain.
//
// A lease is a http://www.ovirt.org/develop/developer-guide/vdsm/sanlock[Sanlock] resource residing on a special
// volume on the storage domain, this Sanlock resource is used to provide storage base locking.
func (p *Snapshot) MustLease() *StorageDomainLease {
	if p.lease == nil {
		panic("the lease must not be nil, please use Lease() function instead")
	}
	return p.lease
}

func (p *Snapshot) SetMemory(attr int64) {
	p.memory = &attr
}

func (p *Snapshot) Memory() (int64, bool) {
	if p.memory != nil {
		return *p.memory, true
	}
	var zero int64
	return zero, false
}

func (p *Snapshot) MustMemory() int64 {
	if p.memory == nil {
		panic("the memory must not be nil, please use Memory() function instead")
	}
	return *p.memory
}

// SetMemoryPolicy Logical grouping of memory-related properties of virtual machine-like entities.
func (p *Snapshot) SetMemoryPolicy(attr *MemoryPolicy) {
	p.memoryPolicy = attr
}

// MemoryPolicy Logical grouping of memory-related properties of virtual machine-like entities.
func (p *Snapshot) MemoryPolicy() (*MemoryPolicy, bool) {
	if p.memoryPolicy != nil {
		return p.memoryPolicy, true
	}
	return nil, false
}

// MustMemoryPolicy Logical grouping of memory-related properties of virtual machine-like entities.
func (p *Snapshot) MustMemoryPolicy() *MemoryPolicy {
	if p.memoryPolicy == nil {
		panic("the memoryPolicy must not be nil, please use MemoryPolicy() function instead")
	}
	return p.memoryPolicy
}

// SetMigration The type for migration options.
func (p *Snapshot) SetMigration(attr *MigrationOptions) {
	p.migration = attr
}

// Migration The type for migration options.
func (p *Snapshot) Migration() (*MigrationOptions, bool) {
	if p.migration != nil {
		return p.migration, true
	}
	return nil, false
}

// MustMigration The type for migration options.
func (p *Snapshot) MustMigration() *MigrationOptions {
	if p.migration == nil {
		panic("the migration must not be nil, please use Migration() function instead")
	}
	return p.migration
}

func (p *Snapshot) SetMigrationDowntime(attr int64) {
	p.migrationDowntime = &attr
}

func (p *Snapshot) MigrationDowntime() (int64, bool) {
	if p.migrationDowntime != nil {
		return *p.migrationDowntime, true
	}
	var zero int64
	return zero, false
}

func (p *Snapshot) MustMigrationDowntime() int64 {
	if p.migrationDowntime == nil {
		panic("the migrationDowntime must not be nil, please use MigrationDowntime() function instead")
	}
	return *p.migrationDowntime
}

func (p *Snapshot) SetMultiQueuesEnabled(attr bool) {
	p.multiQueuesEnabled = &attr
}

func (p *Snapshot) MultiQueuesEnabled() (bool, bool) {
	if p.multiQueuesEnabled != nil {
		return *p.multiQueuesEnabled, true
	}
	var zero bool
	return zero, false
}

func (p *Snapshot) MustMultiQueuesEnabled() bool {
	if p.multiQueuesEnabled == nil {
		panic("the multiQueuesEnabled must not be nil, please use MultiQueuesEnabled() function instead")
	}
	return *p.multiQueuesEnabled
}

func (p *Snapshot) SetName(attr string) {
	p.name = &attr
}

func (p *Snapshot) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *Snapshot) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *Snapshot) SetNextRunConfigurationExists(attr bool) {
	p.nextRunConfigurationExists = &attr
}

func (p *Snapshot) NextRunConfigurationExists() (bool, bool) {
	if p.nextRunConfigurationExists != nil {
		return *p.nextRunConfigurationExists, true
	}
	var zero bool
	return zero, false
}

func (p *Snapshot) MustNextRunConfigurationExists() bool {
	if p.nextRunConfigurationExists == nil {
		panic("the nextRunConfigurationExists must not be nil, please use NextRunConfigurationExists() function instead")
	}
	return *p.nextRunConfigurationExists
}

func (p *Snapshot) SetNics(attr *NicSlice) {
	p.nics = attr
}

func (p *Snapshot) Nics() (*NicSlice, bool) {
	if p.nics != nil {
		return p.nics, true
	}
	return nil, false
}

func (p *Snapshot) MustNics() *NicSlice {
	if p.nics == nil {
		panic("the nics must not be nil, please use Nics() function instead")
	}
	return p.nics
}

func (p *Snapshot) SetNumaNodes(attr *NumaNodeSlice) {
	p.numaNodes = attr
}

func (p *Snapshot) NumaNodes() (*NumaNodeSlice, bool) {
	if p.numaNodes != nil {
		return p.numaNodes, true
	}
	return nil, false
}

func (p *Snapshot) MustNumaNodes() *NumaNodeSlice {
	if p.numaNodes == nil {
		panic("the numaNodes must not be nil, please use NumaNodes() function instead")
	}
	return p.numaNodes
}

func (p *Snapshot) SetNumaTuneMode(attr NumaTuneMode) {
	p.numaTuneMode = &attr
}

func (p *Snapshot) NumaTuneMode() (NumaTuneMode, bool) {
	if p.numaTuneMode != nil {
		return *p.numaTuneMode, true
	}
	var zero NumaTuneMode
	return zero, false
}

func (p *Snapshot) MustNumaTuneMode() NumaTuneMode {
	if p.numaTuneMode == nil {
		panic("the numaTuneMode must not be nil, please use NumaTuneMode() function instead")
	}
	return *p.numaTuneMode
}

func (p *Snapshot) SetOrigin(attr string) {
	p.origin = &attr
}

func (p *Snapshot) Origin() (string, bool) {
	if p.origin != nil {
		return *p.origin, true
	}
	var zero string
	return zero, false
}

func (p *Snapshot) MustOrigin() string {
	if p.origin == nil {
		panic("the origin must not be nil, please use Origin() function instead")
	}
	return *p.origin
}

// SetOriginalTemplate The type that represents a virtual machine template.
// Templates allow for a rapid instantiation of virtual machines with common configuration and disk states.
func (p *Snapshot) SetOriginalTemplate(attr *Template) {
	p.originalTemplate = attr
}

// OriginalTemplate The type that represents a virtual machine template.
// Templates allow for a rapid instantiation of virtual machines with common configuration and disk states.
func (p *Snapshot) OriginalTemplate() (*Template, bool) {
	if p.originalTemplate != nil {
		return p.originalTemplate, true
	}
	return nil, false
}

// MustOriginalTemplate The type that represents a virtual machine template.
// Templates allow for a rapid instantiation of virtual machines with common configuration and disk states.
func (p *Snapshot) MustOriginalTemplate() *Template {
	if p.originalTemplate == nil {
		panic("the originalTemplate must not be nil, please use OriginalTemplate() function instead")
	}
	return p.originalTemplate
}

// SetOs Information describing the operating system. This is used for both virtual machines and hosts.
func (p *Snapshot) SetOs(attr *OperatingSystem) {
	p.os = attr
}

// Os Information describing the operating system. This is used for both virtual machines and hosts.
func (p *Snapshot) Os() (*OperatingSystem, bool) {
	if p.os != nil {
		return p.os, true
	}
	return nil, false
}

// MustOs Information describing the operating system. This is used for both virtual machines and hosts.
func (p *Snapshot) MustOs() *OperatingSystem {
	if p.os == nil {
		panic("the os must not be nil, please use Os() function instead")
	}
	return p.os
}

func (p *Snapshot) SetPayloads(attr *PayloadSlice) {
	p.payloads = attr
}

func (p *Snapshot) Payloads() (*PayloadSlice, bool) {
	if p.payloads != nil {
		return p.payloads, true
	}
	return nil, false
}

func (p *Snapshot) MustPayloads() *PayloadSlice {
	if p.payloads == nil {
		panic("the payloads must not be nil, please use Payloads() function instead")
	}
	return p.payloads
}

func (p *Snapshot) SetPermissions(attr *PermissionSlice) {
	p.permissions = attr
}

func (p *Snapshot) Permissions() (*PermissionSlice, bool) {
	if p.permissions != nil {
		return p.permissions, true
	}
	return nil, false
}

func (p *Snapshot) MustPermissions() *PermissionSlice {
	if p.permissions == nil {
		panic("the permissions must not be nil, please use Permissions() function instead")
	}
	return p.permissions
}

func (p *Snapshot) SetPersistMemorystate(attr bool) {
	p.persistMemorystate = &attr
}

func (p *Snapshot) PersistMemorystate() (bool, bool) {
	if p.persistMemorystate != nil {
		return *p.persistMemorystate, true
	}
	var zero bool
	return zero, false
}

func (p *Snapshot) MustPersistMemorystate() bool {
	if p.persistMemorystate == nil {
		panic("the persistMemorystate must not be nil, please use PersistMemorystate() function instead")
	}
	return *p.persistMemorystate
}

func (p *Snapshot) SetPlacementPolicy(attr *VmPlacementPolicy) {
	p.placementPolicy = attr
}

func (p *Snapshot) PlacementPolicy() (*VmPlacementPolicy, bool) {
	if p.placementPolicy != nil {
		return p.placementPolicy, true
	}
	return nil, false
}

func (p *Snapshot) MustPlacementPolicy() *VmPlacementPolicy {
	if p.placementPolicy == nil {
		panic("the placementPolicy must not be nil, please use PlacementPolicy() function instead")
	}
	return p.placementPolicy
}

// SetQuota Represents a quota object.
//
// An example XML representation of a quota:
//
// [source,xml]
// ----
// <quota href="/ovirt-engine/api/datacenters/7044934e/quotas/dcad5ddc" id="dcad5ddc">
//   <name>My Quota</name>
//   <description>A quota for my oVirt environment</description>
//   <cluster_hard_limit_pct>0</cluster_hard_limit_pct>
//   <cluster_soft_limit_pct>0</cluster_soft_limit_pct>
//   <data_center href="/ovirt-engine/api/datacenters/7044934e" id="7044934e"/>
//   <storage_hard_limit_pct>0</storage_hard_limit_pct>
//   <storage_soft_limit_pct>0</storage_soft_limit_pct>
// </quota>
// ----
func (p *Snapshot) SetQuota(attr *Quota) {
	p.quota = attr
}

// Quota Represents a quota object.
//
// An example XML representation of a quota:
//
// [source,xml]
// ----
// <quota href="/ovirt-engine/api/datacenters/7044934e/quotas/dcad5ddc" id="dcad5ddc">
//   <name>My Quota</name>
//   <description>A quota for my oVirt environment</description>
//   <cluster_hard_limit_pct>0</cluster_hard_limit_pct>
//   <cluster_soft_limit_pct>0</cluster_soft_limit_pct>
//   <data_center href="/ovirt-engine/api/datacenters/7044934e" id="7044934e"/>
//   <storage_hard_limit_pct>0</storage_hard_limit_pct>
//   <storage_soft_limit_pct>0</storage_soft_limit_pct>
// </quota>
// ----
func (p *Snapshot) Quota() (*Quota, bool) {
	if p.quota != nil {
		return p.quota, true
	}
	return nil, false
}

// MustQuota Represents a quota object.
//
// An example XML representation of a quota:
//
// [source,xml]
// ----
// <quota href="/ovirt-engine/api/datacenters/7044934e/quotas/dcad5ddc" id="dcad5ddc">
//   <name>My Quota</name>
//   <description>A quota for my oVirt environment</description>
//   <cluster_hard_limit_pct>0</cluster_hard_limit_pct>
//   <cluster_soft_limit_pct>0</cluster_soft_limit_pct>
//   <data_center href="/ovirt-engine/api/datacenters/7044934e" id="7044934e"/>
//   <storage_hard_limit_pct>0</storage_hard_limit_pct>
//   <storage_soft_limit_pct>0</storage_soft_limit_pct>
// </quota>
// ----
func (p *Snapshot) MustQuota() *Quota {
	if p.quota == nil {
		panic("the quota must not be nil, please use Quota() function instead")
	}
	return p.quota
}

func (p *Snapshot) SetReportedDevices(attr *ReportedDeviceSlice) {
	p.reportedDevices = attr
}

func (p *Snapshot) ReportedDevices() (*ReportedDeviceSlice, bool) {
	if p.reportedDevices != nil {
		return p.reportedDevices, true
	}
	return nil, false
}

func (p *Snapshot) MustReportedDevices() *ReportedDeviceSlice {
	if p.reportedDevices == nil {
		panic("the reportedDevices must not be nil, please use ReportedDevices() function instead")
	}
	return p.reportedDevices
}

// SetRngDevice Random number generator (RNG) device model.
func (p *Snapshot) SetRngDevice(attr *RngDevice) {
	p.rngDevice = attr
}

// RngDevice Random number generator (RNG) device model.
func (p *Snapshot) RngDevice() (*RngDevice, bool) {
	if p.rngDevice != nil {
		return p.rngDevice, true
	}
	return nil, false
}

// MustRngDevice Random number generator (RNG) device model.
func (p *Snapshot) MustRngDevice() *RngDevice {
	if p.rngDevice == nil {
		panic("the rngDevice must not be nil, please use RngDevice() function instead")
	}
	return p.rngDevice
}

func (p *Snapshot) SetRunOnce(attr bool) {
	p.runOnce = &attr
}

func (p *Snapshot) RunOnce() (bool, bool) {
	if p.runOnce != nil {
		return *p.runOnce, true
	}
	var zero bool
	return zero, false
}

func (p *Snapshot) MustRunOnce() bool {
	if p.runOnce == nil {
		panic("the runOnce must not be nil, please use RunOnce() function instead")
	}
	return *p.runOnce
}

func (p *Snapshot) SetSerialNumber(attr *SerialNumber) {
	p.serialNumber = attr
}

func (p *Snapshot) SerialNumber() (*SerialNumber, bool) {
	if p.serialNumber != nil {
		return p.serialNumber, true
	}
	return nil, false
}

func (p *Snapshot) MustSerialNumber() *SerialNumber {
	if p.serialNumber == nil {
		panic("the serialNumber must not be nil, please use SerialNumber() function instead")
	}
	return p.serialNumber
}

func (p *Snapshot) SetSessions(attr *SessionSlice) {
	p.sessions = attr
}

func (p *Snapshot) Sessions() (*SessionSlice, bool) {
	if p.sessions != nil {
		return p.sessions, true
	}
	return nil, false
}

func (p *Snapshot) MustSessions() *SessionSlice {
	if p.sessions == nil {
		panic("the sessions must not be nil, please use Sessions() function instead")
	}
	return p.sessions
}

// SetSmallIcon Icon of virtual machine or template.
func (p *Snapshot) SetSmallIcon(attr *Icon) {
	p.smallIcon = attr
}

// SmallIcon Icon of virtual machine or template.
func (p *Snapshot) SmallIcon() (*Icon, bool) {
	if p.smallIcon != nil {
		return p.smallIcon, true
	}
	return nil, false
}

// MustSmallIcon Icon of virtual machine or template.
func (p *Snapshot) MustSmallIcon() *Icon {
	if p.smallIcon == nil {
		panic("the smallIcon must not be nil, please use SmallIcon() function instead")
	}
	return p.smallIcon
}

// SetSnapshotStatus Represents the current status of the snapshot.
func (p *Snapshot) SetSnapshotStatus(attr SnapshotStatus) {
	p.snapshotStatus = &attr
}

// SnapshotStatus Represents the current status of the snapshot.
func (p *Snapshot) SnapshotStatus() (SnapshotStatus, bool) {
	if p.snapshotStatus != nil {
		return *p.snapshotStatus, true
	}
	var zero SnapshotStatus
	return zero, false
}

// MustSnapshotStatus Represents the current status of the snapshot.
func (p *Snapshot) MustSnapshotStatus() SnapshotStatus {
	if p.snapshotStatus == nil {
		panic("the snapshotStatus must not be nil, please use SnapshotStatus() function instead")
	}
	return *p.snapshotStatus
}

// SetSnapshotType Represents the type of the snapshot.
func (p *Snapshot) SetSnapshotType(attr SnapshotType) {
	p.snapshotType = &attr
}

// SnapshotType Represents the type of the snapshot.
func (p *Snapshot) SnapshotType() (SnapshotType, bool) {
	if p.snapshotType != nil {
		return *p.snapshotType, true
	}
	var zero SnapshotType
	return zero, false
}

// MustSnapshotType Represents the type of the snapshot.
func (p *Snapshot) MustSnapshotType() SnapshotType {
	if p.snapshotType == nil {
		panic("the snapshotType must not be nil, please use SnapshotType() function instead")
	}
	return *p.snapshotType
}

func (p *Snapshot) SetSnapshots(attr *SnapshotSlice) {
	p.snapshots = attr
}

func (p *Snapshot) Snapshots() (*SnapshotSlice, bool) {
	if p.snapshots != nil {
		return p.snapshots, true
	}
	return nil, false
}

func (p *Snapshot) MustSnapshots() *SnapshotSlice {
	if p.snapshots == nil {
		panic("the snapshots must not be nil, please use Snapshots() function instead")
	}
	return p.snapshots
}

func (p *Snapshot) SetSoundcardEnabled(attr bool) {
	p.soundcardEnabled = &attr
}

func (p *Snapshot) SoundcardEnabled() (bool, bool) {
	if p.soundcardEnabled != nil {
		return *p.soundcardEnabled, true
	}
	var zero bool
	return zero, false
}

func (p *Snapshot) MustSoundcardEnabled() bool {
	if p.soundcardEnabled == nil {
		panic("the soundcardEnabled must not be nil, please use SoundcardEnabled() function instead")
	}
	return *p.soundcardEnabled
}

func (p *Snapshot) SetSso(attr *Sso) {
	p.sso = attr
}

func (p *Snapshot) Sso() (*Sso, bool) {
	if p.sso != nil {
		return p.sso, true
	}
	return nil, false
}

func (p *Snapshot) MustSso() *Sso {
	if p.sso == nil {
		panic("the sso must not be nil, please use Sso() function instead")
	}
	return p.sso
}

func (p *Snapshot) SetStartPaused(attr bool) {
	p.startPaused = &attr
}

func (p *Snapshot) StartPaused() (bool, bool) {
	if p.startPaused != nil {
		return *p.startPaused, true
	}
	var zero bool
	return zero, false
}

func (p *Snapshot) MustStartPaused() bool {
	if p.startPaused == nil {
		panic("the startPaused must not be nil, please use StartPaused() function instead")
	}
	return *p.startPaused
}

func (p *Snapshot) SetStartTime(attr time.Time) {
	p.startTime = &attr
}

func (p *Snapshot) StartTime() (time.Time, bool) {
	if p.startTime != nil {
		return *p.startTime, true
	}
	var zero time.Time
	return zero, false
}

func (p *Snapshot) MustStartTime() time.Time {
	if p.startTime == nil {
		panic("the startTime must not be nil, please use StartTime() function instead")
	}
	return *p.startTime
}

func (p *Snapshot) SetStateless(attr bool) {
	p.stateless = &attr
}

func (p *Snapshot) Stateless() (bool, bool) {
	if p.stateless != nil {
		return *p.stateless, true
	}
	var zero bool
	return zero, false
}

func (p *Snapshot) MustStateless() bool {
	if p.stateless == nil {
		panic("the stateless must not be nil, please use Stateless() function instead")
	}
	return *p.stateless
}

func (p *Snapshot) SetStatistics(attr *StatisticSlice) {
	p.statistics = attr
}

func (p *Snapshot) Statistics() (*StatisticSlice, bool) {
	if p.statistics != nil {
		return p.statistics, true
	}
	return nil, false
}

func (p *Snapshot) MustStatistics() *StatisticSlice {
	if p.statistics == nil {
		panic("the statistics must not be nil, please use Statistics() function instead")
	}
	return p.statistics
}

// SetStatus Type represeting a status of a virtual machine.
func (p *Snapshot) SetStatus(attr VmStatus) {
	p.status = &attr
}

// Status Type represeting a status of a virtual machine.
func (p *Snapshot) Status() (VmStatus, bool) {
	if p.status != nil {
		return *p.status, true
	}
	var zero VmStatus
	return zero, false
}

// MustStatus Type represeting a status of a virtual machine.
func (p *Snapshot) MustStatus() VmStatus {
	if p.status == nil {
		panic("the status must not be nil, please use Status() function instead")
	}
	return *p.status
}

func (p *Snapshot) SetStatusDetail(attr string) {
	p.statusDetail = &attr
}

func (p *Snapshot) StatusDetail() (string, bool) {
	if p.statusDetail != nil {
		return *p.statusDetail, true
	}
	var zero string
	return zero, false
}

func (p *Snapshot) MustStatusDetail() string {
	if p.statusDetail == nil {
		panic("the statusDetail must not be nil, please use StatusDetail() function instead")
	}
	return *p.statusDetail
}

func (p *Snapshot) SetStopReason(attr string) {
	p.stopReason = &attr
}

func (p *Snapshot) StopReason() (string, bool) {
	if p.stopReason != nil {
		return *p.stopReason, true
	}
	var zero string
	return zero, false
}

func (p *Snapshot) MustStopReason() string {
	if p.stopReason == nil {
		panic("the stopReason must not be nil, please use StopReason() function instead")
	}
	return *p.stopReason
}

func (p *Snapshot) SetStopTime(attr time.Time) {
	p.stopTime = &attr
}

func (p *Snapshot) StopTime() (time.Time, bool) {
	if p.stopTime != nil {
		return *p.stopTime, true
	}
	var zero time.Time
	return zero, false
}

func (p *Snapshot) MustStopTime() time.Time {
	if p.stopTime == nil {
		panic("the stopTime must not be nil, please use StopTime() function instead")
	}
	return *p.stopTime
}

// SetStorageDomain Storage domain.
//
// An XML representation of a NFS storage domain with identifier `123`:
//
// [source,xml]
// ----
// <storage_domain href="/ovirt-engine/api/storagedomains/123" id="123">
//   <name>mydata</name>
//   <description>My data</description>
//   <available>38654705664</available>
//   <committed>1073741824</committed>
//   <critical_space_action_blocker>5</critical_space_action_blocker>
//   <external_status>ok</external_status>
//   <master>true</master>
//   <storage>
//     <address>mynfs.example.com</address>
//     <nfs_version>v3</nfs_version>
//     <path>/exports/mydata</path>
//     <type>nfs</type>
//   </storage>
//   <storage_format>v3</storage_format>
//   <type>data</type>
//   <used>13958643712</used>
//   <warning_low_space_indicator>10</warning_low_space_indicator>
//   <wipe_after_delete>false</wipe_after_delete>
//   <data_centers>
//     <data_center href="/ovirt-engine/api/datacenters/456" id="456"/>
//   </data_centers>
// </storage_domain>
// ----
func (p *Snapshot) SetStorageDomain(attr *StorageDomain) {
	p.storageDomain = attr
}

// StorageDomain Storage domain.
//
// An XML representation of a NFS storage domain with identifier `123`:
//
// [source,xml]
// ----
// <storage_domain href="/ovirt-engine/api/storagedomains/123" id="123">
//   <name>mydata</name>
//   <description>My data</description>
//   <available>38654705664</available>
//   <committed>1073741824</committed>
//   <critical_space_action_blocker>5</critical_space_action_blocker>
//   <external_status>ok</external_status>
//   <master>true</master>
//   <storage>
//     <address>mynfs.example.com</address>
//     <nfs_version>v3</nfs_version>
//     <path>/exports/mydata</path>
//     <type>nfs</type>
//   </storage>
//   <storage_format>v3</storage_format>
//   <type>data</type>
//   <used>13958643712</used>
//   <warning_low_space_indicator>10</warning_low_space_indicator>
//   <wipe_after_delete>false</wipe_after_delete>
//   <data_centers>
//     <data_center href="/ovirt-engine/api/datacenters/456" id="456"/>
//   </data_centers>
// </storage_domain>
// ----
func (p *Snapshot) StorageDomain() (*StorageDomain, bool) {
	if p.storageDomain != nil {
		return p.storageDomain, true
	}
	return nil, false
}

// MustStorageDomain Storage domain.
//
// An XML representation of a NFS storage domain with identifier `123`:
//
// [source,xml]
// ----
// <storage_domain href="/ovirt-engine/api/storagedomains/123" id="123">
//   <name>mydata</name>
//   <description>My data</description>
//   <available>38654705664</available>
//   <committed>1073741824</committed>
//   <critical_space_action_blocker>5</critical_space_action_blocker>
//   <external_status>ok</external_status>
//   <master>true</master>
//   <storage>
//     <address>mynfs.example.com</address>
//     <nfs_version>v3</nfs_version>
//     <path>/exports/mydata</path>
//     <type>nfs</type>
//   </storage>
//   <storage_format>v3</storage_format>
//   <type>data</type>
//   <used>13958643712</used>
//   <warning_low_space_indicator>10</warning_low_space_indicator>
//   <wipe_after_delete>false</wipe_after_delete>
//   <data_centers>
//     <data_center href="/ovirt-engine/api/datacenters/456" id="456"/>
//   </data_centers>
// </storage_domain>
// ----
func (p *Snapshot) MustStorageDomain() *StorageDomain {
	if p.storageDomain == nil {
		panic("the storageDomain must not be nil, please use StorageDomain() function instead")
	}
	return p.storageDomain
}

// SetStorageErrorResumeBehaviour If the storage, on which this virtual machine has some disks gets
// unresponsive, the virtual machine gets paused.
//
// This are the possible options, what should happen with the virtual machine
// in the moment the storage gets available again.
func (p *Snapshot) SetStorageErrorResumeBehaviour(attr VmStorageErrorResumeBehaviour) {
	p.storageErrorResumeBehaviour = &attr
}

// StorageErrorResumeBehaviour If the storage, on which this virtual machine has some disks gets
// unresponsive, the virtual machine gets paused.
//
// This are the possible options, what should happen with the virtual machine
// in the moment the storage gets available again.
func (p *Snapshot) StorageErrorResumeBehaviour() (VmStorageErrorResumeBehaviour, bool) {
	if p.storageErrorResumeBehaviour != nil {
		return *p.storageErrorResumeBehaviour, true
	}
	var zero VmStorageErrorResumeBehaviour
	return zero, false
}

// MustStorageErrorResumeBehaviour If the storage, on which this virtual machine has some disks gets
// unresponsive, the virtual machine gets paused.
//
// This are the possible options, what should happen with the virtual machine
// in the moment the storage gets available again.
func (p *Snapshot) MustStorageErrorResumeBehaviour() VmStorageErrorResumeBehaviour {
	if p.storageErrorResumeBehaviour == nil {
		panic("the storageErrorResumeBehaviour must not be nil, please use StorageErrorResumeBehaviour() function instead")
	}
	return *p.storageErrorResumeBehaviour
}

func (p *Snapshot) SetTags(attr *TagSlice) {
	p.tags = attr
}

func (p *Snapshot) Tags() (*TagSlice, bool) {
	if p.tags != nil {
		return p.tags, true
	}
	return nil, false
}

func (p *Snapshot) MustTags() *TagSlice {
	if p.tags == nil {
		panic("the tags must not be nil, please use Tags() function instead")
	}
	return p.tags
}

// SetTemplate The type that represents a virtual machine template.
// Templates allow for a rapid instantiation of virtual machines with common configuration and disk states.
func (p *Snapshot) SetTemplate(attr *Template) {
	p.template = attr
}

// Template The type that represents a virtual machine template.
// Templates allow for a rapid instantiation of virtual machines with common configuration and disk states.
func (p *Snapshot) Template() (*Template, bool) {
	if p.template != nil {
		return p.template, true
	}
	return nil, false
}

// MustTemplate The type that represents a virtual machine template.
// Templates allow for a rapid instantiation of virtual machines with common configuration and disk states.
func (p *Snapshot) MustTemplate() *Template {
	if p.template == nil {
		panic("the template must not be nil, please use Template() function instead")
	}
	return p.template
}

// SetTimeZone Time zone representation.
func (p *Snapshot) SetTimeZone(attr *TimeZone) {
	p.timeZone = attr
}

// TimeZone Time zone representation.
func (p *Snapshot) TimeZone() (*TimeZone, bool) {
	if p.timeZone != nil {
		return p.timeZone, true
	}
	return nil, false
}

// MustTimeZone Time zone representation.
func (p *Snapshot) MustTimeZone() *TimeZone {
	if p.timeZone == nil {
		panic("the timeZone must not be nil, please use TimeZone() function instead")
	}
	return p.timeZone
}

func (p *Snapshot) SetTpmEnabled(attr bool) {
	p.tpmEnabled = &attr
}

func (p *Snapshot) TpmEnabled() (bool, bool) {
	if p.tpmEnabled != nil {
		return *p.tpmEnabled, true
	}
	var zero bool
	return zero, false
}

func (p *Snapshot) MustTpmEnabled() bool {
	if p.tpmEnabled == nil {
		panic("the tpmEnabled must not be nil, please use TpmEnabled() function instead")
	}
	return *p.tpmEnabled
}

func (p *Snapshot) SetTunnelMigration(attr bool) {
	p.tunnelMigration = &attr
}

func (p *Snapshot) TunnelMigration() (bool, bool) {
	if p.tunnelMigration != nil {
		return *p.tunnelMigration, true
	}
	var zero bool
	return zero, false
}

func (p *Snapshot) MustTunnelMigration() bool {
	if p.tunnelMigration == nil {
		panic("the tunnelMigration must not be nil, please use TunnelMigration() function instead")
	}
	return *p.tunnelMigration
}

// SetType Type representing what the virtual machine is optimized for.
func (p *Snapshot) SetType(attr VmType) {
	p.type_ = &attr
}

// Type Type representing what the virtual machine is optimized for.
func (p *Snapshot) Type() (VmType, bool) {
	if p.type_ != nil {
		return *p.type_, true
	}
	var zero VmType
	return zero, false
}

// MustType Type representing what the virtual machine is optimized for.
func (p *Snapshot) MustType() VmType {
	if p.type_ == nil {
		panic("the type_ must not be nil, please use Type() function instead")
	}
	return *p.type_
}

// SetUsb Configuration of the USB device of a virtual machine.
func (p *Snapshot) SetUsb(attr *Usb) {
	p.usb = attr
}

// Usb Configuration of the USB device of a virtual machine.
func (p *Snapshot) Usb() (*Usb, bool) {
	if p.usb != nil {
		return p.usb, true
	}
	return nil, false
}

// MustUsb Configuration of the USB device of a virtual machine.
func (p *Snapshot) MustUsb() *Usb {
	if p.usb == nil {
		panic("the usb must not be nil, please use Usb() function instead")
	}
	return p.usb
}

func (p *Snapshot) SetUseLatestTemplateVersion(attr bool) {
	p.useLatestTemplateVersion = &attr
}

func (p *Snapshot) UseLatestTemplateVersion() (bool, bool) {
	if p.useLatestTemplateVersion != nil {
		return *p.useLatestTemplateVersion, true
	}
	var zero bool
	return zero, false
}

func (p *Snapshot) MustUseLatestTemplateVersion() bool {
	if p.useLatestTemplateVersion == nil {
		panic("the useLatestTemplateVersion must not be nil, please use UseLatestTemplateVersion() function instead")
	}
	return *p.useLatestTemplateVersion
}

// SetVirtioScsi Type representing the support of virtio-SCSI.
// If it supported we use virtio driver for SCSI guest device.
func (p *Snapshot) SetVirtioScsi(attr *VirtioScsi) {
	p.virtioScsi = attr
}

// VirtioScsi Type representing the support of virtio-SCSI.
// If it supported we use virtio driver for SCSI guest device.
func (p *Snapshot) VirtioScsi() (*VirtioScsi, bool) {
	if p.virtioScsi != nil {
		return p.virtioScsi, true
	}
	return nil, false
}

// MustVirtioScsi Type representing the support of virtio-SCSI.
// If it supported we use virtio driver for SCSI guest device.
func (p *Snapshot) MustVirtioScsi() *VirtioScsi {
	if p.virtioScsi == nil {
		panic("the virtioScsi must not be nil, please use VirtioScsi() function instead")
	}
	return p.virtioScsi
}

func (p *Snapshot) SetVirtioScsiMultiQueuesEnabled(attr bool) {
	p.virtioScsiMultiQueuesEnabled = &attr
}

func (p *Snapshot) VirtioScsiMultiQueuesEnabled() (bool, bool) {
	if p.virtioScsiMultiQueuesEnabled != nil {
		return *p.virtioScsiMultiQueuesEnabled, true
	}
	var zero bool
	return zero, false
}

func (p *Snapshot) MustVirtioScsiMultiQueuesEnabled() bool {
	if p.virtioScsiMultiQueuesEnabled == nil {
		panic("the virtioScsiMultiQueuesEnabled must not be nil, please use VirtioScsiMultiQueuesEnabled() function instead")
	}
	return *p.virtioScsiMultiQueuesEnabled
}

// SetVm Represents a virtual machine.
func (p *Snapshot) SetVm(attr *Vm) {
	p.vm = attr
}

// Vm Represents a virtual machine.
func (p *Snapshot) Vm() (*Vm, bool) {
	if p.vm != nil {
		return p.vm, true
	}
	return nil, false
}

// MustVm Represents a virtual machine.
func (p *Snapshot) MustVm() *Vm {
	if p.vm == nil {
		panic("the vm must not be nil, please use Vm() function instead")
	}
	return p.vm
}

// SetVmPool Type represeting a virtual machines pool.
func (p *Snapshot) SetVmPool(attr *VmPool) {
	p.vmPool = attr
}

// VmPool Type represeting a virtual machines pool.
func (p *Snapshot) VmPool() (*VmPool, bool) {
	if p.vmPool != nil {
		return p.vmPool, true
	}
	return nil, false
}

// MustVmPool Type represeting a virtual machines pool.
func (p *Snapshot) MustVmPool() *VmPool {
	if p.vmPool == nil {
		panic("the vmPool must not be nil, please use VmPool() function instead")
	}
	return p.vmPool
}

func (p *Snapshot) SetWatchdogs(attr *WatchdogSlice) {
	p.watchdogs = attr
}

func (p *Snapshot) Watchdogs() (*WatchdogSlice, bool) {
	if p.watchdogs != nil {
		return p.watchdogs, true
	}
	return nil, false
}

func (p *Snapshot) MustWatchdogs() *WatchdogSlice {
	if p.watchdogs == nil {
		panic("the watchdogs must not be nil, please use Watchdogs() function instead")
	}
	return p.watchdogs
}

// SpecialObjects This type contains references to special objects, such as blank templates and the root of a hierarchy of tags.
type SpecialObjects struct {
	Struct
	blankTemplate *Template
	rootTag       *Tag
}

// SetBlankTemplate The type that represents a virtual machine template.
// Templates allow for a rapid instantiation of virtual machines with common configuration and disk states.
func (p *SpecialObjects) SetBlankTemplate(attr *Template) {
	p.blankTemplate = attr
}

// BlankTemplate The type that represents a virtual machine template.
// Templates allow for a rapid instantiation of virtual machines with common configuration and disk states.
func (p *SpecialObjects) BlankTemplate() (*Template, bool) {
	if p.blankTemplate != nil {
		return p.blankTemplate, true
	}
	return nil, false
}

// MustBlankTemplate The type that represents a virtual machine template.
// Templates allow for a rapid instantiation of virtual machines with common configuration and disk states.
func (p *SpecialObjects) MustBlankTemplate() *Template {
	if p.blankTemplate == nil {
		panic("the blankTemplate must not be nil, please use BlankTemplate() function instead")
	}
	return p.blankTemplate
}

// SetRootTag Represents a tag in the system.
func (p *SpecialObjects) SetRootTag(attr *Tag) {
	p.rootTag = attr
}

// RootTag Represents a tag in the system.
func (p *SpecialObjects) RootTag() (*Tag, bool) {
	if p.rootTag != nil {
		return p.rootTag, true
	}
	return nil, false
}

// MustRootTag Represents a tag in the system.
func (p *SpecialObjects) MustRootTag() *Tag {
	if p.rootTag == nil {
		panic("the rootTag must not be nil, please use RootTag() function instead")
	}
	return p.rootTag
}

type Spm struct {
	Struct
	priority *int64
	status   *SpmStatus
}

func (p *Spm) SetPriority(attr int64) {
	p.priority = &attr
}

func (p *Spm) Priority() (int64, bool) {
	if p.priority != nil {
		return *p.priority, true
	}
	var zero int64
	return zero, false
}

func (p *Spm) MustPriority() int64 {
	if p.priority == nil {
		panic("the priority must not be nil, please use Priority() function instead")
	}
	return *p.priority
}

func (p *Spm) SetStatus(attr SpmStatus) {
	p.status = &attr
}

func (p *Spm) Status() (SpmStatus, bool) {
	if p.status != nil {
		return *p.status, true
	}
	var zero SpmStatus
	return zero, false
}

func (p *Spm) MustStatus() SpmStatus {
	if p.status == nil {
		panic("the status must not be nil, please use Status() function instead")
	}
	return *p.status
}

type Ssh struct {
	Struct
	authenticationMethod *SshAuthenticationMethod
	comment              *string
	description          *string
	fingerprint          *string
	id                   *string
	name                 *string
	port                 *int64
	publicKey            *string
	user                 *User
}

func (p *Ssh) SetAuthenticationMethod(attr SshAuthenticationMethod) {
	p.authenticationMethod = &attr
}

func (p *Ssh) AuthenticationMethod() (SshAuthenticationMethod, bool) {
	if p.authenticationMethod != nil {
		return *p.authenticationMethod, true
	}
	var zero SshAuthenticationMethod
	return zero, false
}

func (p *Ssh) MustAuthenticationMethod() SshAuthenticationMethod {
	if p.authenticationMethod == nil {
		panic("the authenticationMethod must not be nil, please use AuthenticationMethod() function instead")
	}
	return *p.authenticationMethod
}

func (p *Ssh) SetComment(attr string) {
	p.comment = &attr
}

func (p *Ssh) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *Ssh) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *Ssh) SetDescription(attr string) {
	p.description = &attr
}

func (p *Ssh) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *Ssh) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *Ssh) SetFingerprint(attr string) {
	p.fingerprint = &attr
}

func (p *Ssh) Fingerprint() (string, bool) {
	if p.fingerprint != nil {
		return *p.fingerprint, true
	}
	var zero string
	return zero, false
}

func (p *Ssh) MustFingerprint() string {
	if p.fingerprint == nil {
		panic("the fingerprint must not be nil, please use Fingerprint() function instead")
	}
	return *p.fingerprint
}

func (p *Ssh) SetId(attr string) {
	p.id = &attr
}

func (p *Ssh) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *Ssh) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *Ssh) SetName(attr string) {
	p.name = &attr
}

func (p *Ssh) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *Ssh) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *Ssh) SetPort(attr int64) {
	p.port = &attr
}

func (p *Ssh) Port() (int64, bool) {
	if p.port != nil {
		return *p.port, true
	}
	var zero int64
	return zero, false
}

func (p *Ssh) MustPort() int64 {
	if p.port == nil {
		panic("the port must not be nil, please use Port() function instead")
	}
	return *p.port
}

func (p *Ssh) SetPublicKey(attr string) {
	p.publicKey = &attr
}

func (p *Ssh) PublicKey() (string, bool) {
	if p.publicKey != nil {
		return *p.publicKey, true
	}
	var zero string
	return zero, false
}

func (p *Ssh) MustPublicKey() string {
	if p.publicKey == nil {
		panic("the publicKey must not be nil, please use PublicKey() function instead")
	}
	return *p.publicKey
}

// SetUser Represents a user in the system.
func (p *Ssh) SetUser(attr *User) {
	p.user = attr
}

// User Represents a user in the system.
func (p *Ssh) User() (*User, bool) {
	if p.user != nil {
		return p.user, true
	}
	return nil, false
}

// MustUser Represents a user in the system.
func (p *Ssh) MustUser() *User {
	if p.user == nil {
		panic("the user must not be nil, please use User() function instead")
	}
	return p.user
}

type SshPublicKey struct {
	Struct
	comment     *string
	content     *string
	description *string
	id          *string
	name        *string
	user        *User
}

func (p *SshPublicKey) SetComment(attr string) {
	p.comment = &attr
}

func (p *SshPublicKey) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *SshPublicKey) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *SshPublicKey) SetContent(attr string) {
	p.content = &attr
}

func (p *SshPublicKey) Content() (string, bool) {
	if p.content != nil {
		return *p.content, true
	}
	var zero string
	return zero, false
}

func (p *SshPublicKey) MustContent() string {
	if p.content == nil {
		panic("the content must not be nil, please use Content() function instead")
	}
	return *p.content
}

func (p *SshPublicKey) SetDescription(attr string) {
	p.description = &attr
}

func (p *SshPublicKey) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *SshPublicKey) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *SshPublicKey) SetId(attr string) {
	p.id = &attr
}

func (p *SshPublicKey) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *SshPublicKey) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *SshPublicKey) SetName(attr string) {
	p.name = &attr
}

func (p *SshPublicKey) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *SshPublicKey) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

// SetUser Represents a user in the system.
func (p *SshPublicKey) SetUser(attr *User) {
	p.user = attr
}

// User Represents a user in the system.
func (p *SshPublicKey) User() (*User, bool) {
	if p.user != nil {
		return p.user, true
	}
	return nil, false
}

// MustUser Represents a user in the system.
func (p *SshPublicKey) MustUser() *User {
	if p.user == nil {
		panic("the user must not be nil, please use User() function instead")
	}
	return p.user
}

type Sso struct {
	Struct
	methods *MethodSlice
}

func (p *Sso) SetMethods(attr *MethodSlice) {
	p.methods = attr
}

func (p *Sso) Methods() (*MethodSlice, bool) {
	if p.methods != nil {
		return p.methods, true
	}
	return nil, false
}

func (p *Sso) MustMethods() *MethodSlice {
	if p.methods == nil {
		panic("the methods must not be nil, please use Methods() function instead")
	}
	return p.methods
}

// Statistic A generic type used for all kinds of statistics.
//
// Statistic contains the statistics values for various entities.
// The following object contain statistics:
//
// * Disk
// * Host
// * HostNic
// * NumaNode
// * Nic
// * Vm
// * GlusterBrick
// * Step
// * GlusterVolume
//
// An example of a XML representation:
//
// [source,xml]
// ----
// <statistics>
//   <statistic id="1234" href="/ovirt-engine/api/hosts/1234/nics/1234/statistics/1234">
//     <name>data.current.rx</name>
//     <description>Receive data rate</description>
//     <values type="DECIMAL">
//       <value>
//         <datum>0</datum>
//       </value>
//     </values>
//     <type>GAUGE</type>
//     <unit>BYTES_PER_SECOND</unit>
//     <host_nic id="1234" href="/ovirt-engine/api/hosts/1234/nics/1234"/>
//   </statistic>
//   ...
// </statistics>
// ----
//
// NOTE: This statistics sub-collection is read-only.
type Statistic struct {
	Struct
	brick         *GlusterBrick
	comment       *string
	description   *string
	disk          *Disk
	glusterVolume *GlusterVolume
	host          *Host
	hostNic       *HostNic
	hostNumaNode  *NumaNode
	id            *string
	kind          *StatisticKind
	name          *string
	nic           *Nic
	step          *Step
	type_         *ValueType
	unit          *StatisticUnit
	values        *ValueSlice
	vm            *Vm
}

func (p *Statistic) SetBrick(attr *GlusterBrick) {
	p.brick = attr
}

func (p *Statistic) Brick() (*GlusterBrick, bool) {
	if p.brick != nil {
		return p.brick, true
	}
	return nil, false
}

func (p *Statistic) MustBrick() *GlusterBrick {
	if p.brick == nil {
		panic("the brick must not be nil, please use Brick() function instead")
	}
	return p.brick
}

func (p *Statistic) SetComment(attr string) {
	p.comment = &attr
}

func (p *Statistic) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *Statistic) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *Statistic) SetDescription(attr string) {
	p.description = &attr
}

func (p *Statistic) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *Statistic) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

// SetDisk Represents a virtual disk device.
func (p *Statistic) SetDisk(attr *Disk) {
	p.disk = attr
}

// Disk Represents a virtual disk device.
func (p *Statistic) Disk() (*Disk, bool) {
	if p.disk != nil {
		return p.disk, true
	}
	return nil, false
}

// MustDisk Represents a virtual disk device.
func (p *Statistic) MustDisk() *Disk {
	if p.disk == nil {
		panic("the disk must not be nil, please use Disk() function instead")
	}
	return p.disk
}

func (p *Statistic) SetGlusterVolume(attr *GlusterVolume) {
	p.glusterVolume = attr
}

func (p *Statistic) GlusterVolume() (*GlusterVolume, bool) {
	if p.glusterVolume != nil {
		return p.glusterVolume, true
	}
	return nil, false
}

func (p *Statistic) MustGlusterVolume() *GlusterVolume {
	if p.glusterVolume == nil {
		panic("the glusterVolume must not be nil, please use GlusterVolume() function instead")
	}
	return p.glusterVolume
}

// SetHost Type representing a host.
func (p *Statistic) SetHost(attr *Host) {
	p.host = attr
}

// Host Type representing a host.
func (p *Statistic) Host() (*Host, bool) {
	if p.host != nil {
		return p.host, true
	}
	return nil, false
}

// MustHost Type representing a host.
func (p *Statistic) MustHost() *Host {
	if p.host == nil {
		panic("the host must not be nil, please use Host() function instead")
	}
	return p.host
}

// SetHostNic Represents a host NIC.
//
// For example, the XML representation of a host NIC looks like this:
//
// [source,xml]
// ----
// <host_nic href="/ovirt-engine/api/hosts/123/nics/456" id="456">
//   <name>eth0</name>
//   <boot_protocol>static</boot_protocol>
//   <bridged>true</bridged>
//   <custom_configuration>true</custom_configuration>
//   <ip>
//     <address>192.168.122.39</address>
//     <gateway>192.168.122.1</gateway>
//     <netmask>255.255.255.0</netmask>
//     <version>v4</version>
//   </ip>
//   <ipv6>
//     <gateway>::</gateway>
//     <version>v6</version>
//   </ipv6>
//   <ipv6_boot_protocol>none</ipv6_boot_protocol>
//   <mac>
//     <address>52:54:00:0c:79:1d</address>
//   </mac>
//   <mtu>1500</mtu>
//   <status>up</status>
// </host_nic>
// ----
//
// A bonded interface is represented as a <<types/host_nic, HostNic>> object
// containing the `bonding` and `slaves` attributes.
//
// For example, the XML representation of a bonded host NIC looks like this:
//
// [source,xml]
// ----
// <host_nic href="/ovirt-engine/api/hosts/123/nics/456" id="456">
//   <name>bond0</name>
//   <mac address="00:00:00:00:00:00"/>
//   <ip>
//     <address>192.168.122.39</address>
//     <gateway>192.168.122.1</gateway>
//     <netmask>255.255.255.0</netmask>
//     <version>v4</version>
//   </ip>
//   <boot_protocol>dhcp</boot_protocol>
//   <bonding>
//     <options>
//       <option>
//         <name>mode</name>
//         <value>4</value>
//         <type>Dynamic link aggregation (802.3ad)</type>
//       </option>
//       <option>
//         <name>miimon</name>
//         <value>100</value>
//       </option>
//     </options>
//     <slaves>
//       <host_nic id="123"/>
//       <host_nic id="456"/>
//     </slaves>
//   </bonding>
//   <mtu>1500</mtu>
//   <bridged>true</bridged>
//   <custom_configuration>false</custom_configuration>
// </host_nic>
// ----
func (p *Statistic) SetHostNic(attr *HostNic) {
	p.hostNic = attr
}

// HostNic Represents a host NIC.
//
// For example, the XML representation of a host NIC looks like this:
//
// [source,xml]
// ----
// <host_nic href="/ovirt-engine/api/hosts/123/nics/456" id="456">
//   <name>eth0</name>
//   <boot_protocol>static</boot_protocol>
//   <bridged>true</bridged>
//   <custom_configuration>true</custom_configuration>
//   <ip>
//     <address>192.168.122.39</address>
//     <gateway>192.168.122.1</gateway>
//     <netmask>255.255.255.0</netmask>
//     <version>v4</version>
//   </ip>
//   <ipv6>
//     <gateway>::</gateway>
//     <version>v6</version>
//   </ipv6>
//   <ipv6_boot_protocol>none</ipv6_boot_protocol>
//   <mac>
//     <address>52:54:00:0c:79:1d</address>
//   </mac>
//   <mtu>1500</mtu>
//   <status>up</status>
// </host_nic>
// ----
//
// A bonded interface is represented as a <<types/host_nic, HostNic>> object
// containing the `bonding` and `slaves` attributes.
//
// For example, the XML representation of a bonded host NIC looks like this:
//
// [source,xml]
// ----
// <host_nic href="/ovirt-engine/api/hosts/123/nics/456" id="456">
//   <name>bond0</name>
//   <mac address="00:00:00:00:00:00"/>
//   <ip>
//     <address>192.168.122.39</address>
//     <gateway>192.168.122.1</gateway>
//     <netmask>255.255.255.0</netmask>
//     <version>v4</version>
//   </ip>
//   <boot_protocol>dhcp</boot_protocol>
//   <bonding>
//     <options>
//       <option>
//         <name>mode</name>
//         <value>4</value>
//         <type>Dynamic link aggregation (802.3ad)</type>
//       </option>
//       <option>
//         <name>miimon</name>
//         <value>100</value>
//       </option>
//     </options>
//     <slaves>
//       <host_nic id="123"/>
//       <host_nic id="456"/>
//     </slaves>
//   </bonding>
//   <mtu>1500</mtu>
//   <bridged>true</bridged>
//   <custom_configuration>false</custom_configuration>
// </host_nic>
// ----
func (p *Statistic) HostNic() (*HostNic, bool) {
	if p.hostNic != nil {
		return p.hostNic, true
	}
	return nil, false
}

// MustHostNic Represents a host NIC.
//
// For example, the XML representation of a host NIC looks like this:
//
// [source,xml]
// ----
// <host_nic href="/ovirt-engine/api/hosts/123/nics/456" id="456">
//   <name>eth0</name>
//   <boot_protocol>static</boot_protocol>
//   <bridged>true</bridged>
//   <custom_configuration>true</custom_configuration>
//   <ip>
//     <address>192.168.122.39</address>
//     <gateway>192.168.122.1</gateway>
//     <netmask>255.255.255.0</netmask>
//     <version>v4</version>
//   </ip>
//   <ipv6>
//     <gateway>::</gateway>
//     <version>v6</version>
//   </ipv6>
//   <ipv6_boot_protocol>none</ipv6_boot_protocol>
//   <mac>
//     <address>52:54:00:0c:79:1d</address>
//   </mac>
//   <mtu>1500</mtu>
//   <status>up</status>
// </host_nic>
// ----
//
// A bonded interface is represented as a <<types/host_nic, HostNic>> object
// containing the `bonding` and `slaves` attributes.
//
// For example, the XML representation of a bonded host NIC looks like this:
//
// [source,xml]
// ----
// <host_nic href="/ovirt-engine/api/hosts/123/nics/456" id="456">
//   <name>bond0</name>
//   <mac address="00:00:00:00:00:00"/>
//   <ip>
//     <address>192.168.122.39</address>
//     <gateway>192.168.122.1</gateway>
//     <netmask>255.255.255.0</netmask>
//     <version>v4</version>
//   </ip>
//   <boot_protocol>dhcp</boot_protocol>
//   <bonding>
//     <options>
//       <option>
//         <name>mode</name>
//         <value>4</value>
//         <type>Dynamic link aggregation (802.3ad)</type>
//       </option>
//       <option>
//         <name>miimon</name>
//         <value>100</value>
//       </option>
//     </options>
//     <slaves>
//       <host_nic id="123"/>
//       <host_nic id="456"/>
//     </slaves>
//   </bonding>
//   <mtu>1500</mtu>
//   <bridged>true</bridged>
//   <custom_configuration>false</custom_configuration>
// </host_nic>
// ----
func (p *Statistic) MustHostNic() *HostNic {
	if p.hostNic == nil {
		panic("the hostNic must not be nil, please use HostNic() function instead")
	}
	return p.hostNic
}

// SetHostNumaNode Represents a physical NUMA node.
//
// Example XML representation:
//
// [source,xml]
// ----
// <host_numa_node href="/ovirt-engine/api/hosts/0923f1ea/numanodes/007cf1ab" id="007cf1ab">
//   <cpu>
//     <cores>
//       <core>
//         <index>0</index>
//       </core>
//     </cores>
//   </cpu>
//   <index>0</index>
//   <memory>65536</memory>
//   <node_distance>40 20 40 10</node_distance>
//   <host href="/ovirt-engine/api/hosts/0923f1ea" id="0923f1ea"/>
// </host_numa_node>
// ----
func (p *Statistic) SetHostNumaNode(attr *NumaNode) {
	p.hostNumaNode = attr
}

// HostNumaNode Represents a physical NUMA node.
//
// Example XML representation:
//
// [source,xml]
// ----
// <host_numa_node href="/ovirt-engine/api/hosts/0923f1ea/numanodes/007cf1ab" id="007cf1ab">
//   <cpu>
//     <cores>
//       <core>
//         <index>0</index>
//       </core>
//     </cores>
//   </cpu>
//   <index>0</index>
//   <memory>65536</memory>
//   <node_distance>40 20 40 10</node_distance>
//   <host href="/ovirt-engine/api/hosts/0923f1ea" id="0923f1ea"/>
// </host_numa_node>
// ----
func (p *Statistic) HostNumaNode() (*NumaNode, bool) {
	if p.hostNumaNode != nil {
		return p.hostNumaNode, true
	}
	return nil, false
}

// MustHostNumaNode Represents a physical NUMA node.
//
// Example XML representation:
//
// [source,xml]
// ----
// <host_numa_node href="/ovirt-engine/api/hosts/0923f1ea/numanodes/007cf1ab" id="007cf1ab">
//   <cpu>
//     <cores>
//       <core>
//         <index>0</index>
//       </core>
//     </cores>
//   </cpu>
//   <index>0</index>
//   <memory>65536</memory>
//   <node_distance>40 20 40 10</node_distance>
//   <host href="/ovirt-engine/api/hosts/0923f1ea" id="0923f1ea"/>
// </host_numa_node>
// ----
func (p *Statistic) MustHostNumaNode() *NumaNode {
	if p.hostNumaNode == nil {
		panic("the hostNumaNode must not be nil, please use HostNumaNode() function instead")
	}
	return p.hostNumaNode
}

func (p *Statistic) SetId(attr string) {
	p.id = &attr
}

func (p *Statistic) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *Statistic) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *Statistic) SetKind(attr StatisticKind) {
	p.kind = &attr
}

func (p *Statistic) Kind() (StatisticKind, bool) {
	if p.kind != nil {
		return *p.kind, true
	}
	var zero StatisticKind
	return zero, false
}

func (p *Statistic) MustKind() StatisticKind {
	if p.kind == nil {
		panic("the kind must not be nil, please use Kind() function instead")
	}
	return *p.kind
}

func (p *Statistic) SetName(attr string) {
	p.name = &attr
}

func (p *Statistic) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *Statistic) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

// SetNic Represents a virtual machine NIC.
//
// For example, the XML representation of a NIC will look like this:
//
// [source,xml]
// ----
// <nic href="/ovirt-engine/api/vms/123/nics/456" id="456">
//   <name>nic1</name>
//   <vm href="/ovirt-engine/api/vms/123" id="123"/>
//   <interface>virtio</interface>
//   <linked>true</linked>
//   <mac>
//     <address>02:00:00:00:00:00</address>
//   </mac>
//   <plugged>true</plugged>
//   <vnic_profile href="/ovirt-engine/api/vnicprofiles/789" id="789"/>
// </nic>
// ----
func (p *Statistic) SetNic(attr *Nic) {
	p.nic = attr
}

// Nic Represents a virtual machine NIC.
//
// For example, the XML representation of a NIC will look like this:
//
// [source,xml]
// ----
// <nic href="/ovirt-engine/api/vms/123/nics/456" id="456">
//   <name>nic1</name>
//   <vm href="/ovirt-engine/api/vms/123" id="123"/>
//   <interface>virtio</interface>
//   <linked>true</linked>
//   <mac>
//     <address>02:00:00:00:00:00</address>
//   </mac>
//   <plugged>true</plugged>
//   <vnic_profile href="/ovirt-engine/api/vnicprofiles/789" id="789"/>
// </nic>
// ----
func (p *Statistic) Nic() (*Nic, bool) {
	if p.nic != nil {
		return p.nic, true
	}
	return nil, false
}

// MustNic Represents a virtual machine NIC.
//
// For example, the XML representation of a NIC will look like this:
//
// [source,xml]
// ----
// <nic href="/ovirt-engine/api/vms/123/nics/456" id="456">
//   <name>nic1</name>
//   <vm href="/ovirt-engine/api/vms/123" id="123"/>
//   <interface>virtio</interface>
//   <linked>true</linked>
//   <mac>
//     <address>02:00:00:00:00:00</address>
//   </mac>
//   <plugged>true</plugged>
//   <vnic_profile href="/ovirt-engine/api/vnicprofiles/789" id="789"/>
// </nic>
// ----
func (p *Statistic) MustNic() *Nic {
	if p.nic == nil {
		panic("the nic must not be nil, please use Nic() function instead")
	}
	return p.nic
}

// SetStep Represents a step, which is part of `job` execution.
// Step is used to describe and track a specific execution unit which is part of a wider sequence.
// Some steps support reporting their progress.
func (p *Statistic) SetStep(attr *Step) {
	p.step = attr
}

// Step Represents a step, which is part of `job` execution.
// Step is used to describe and track a specific execution unit which is part of a wider sequence.
// Some steps support reporting their progress.
func (p *Statistic) Step() (*Step, bool) {
	if p.step != nil {
		return p.step, true
	}
	return nil, false
}

// MustStep Represents a step, which is part of `job` execution.
// Step is used to describe and track a specific execution unit which is part of a wider sequence.
// Some steps support reporting their progress.
func (p *Statistic) MustStep() *Step {
	if p.step == nil {
		panic("the step must not be nil, please use Step() function instead")
	}
	return p.step
}

func (p *Statistic) SetType(attr ValueType) {
	p.type_ = &attr
}

func (p *Statistic) Type() (ValueType, bool) {
	if p.type_ != nil {
		return *p.type_, true
	}
	var zero ValueType
	return zero, false
}

func (p *Statistic) MustType() ValueType {
	if p.type_ == nil {
		panic("the type_ must not be nil, please use Type() function instead")
	}
	return *p.type_
}

func (p *Statistic) SetUnit(attr StatisticUnit) {
	p.unit = &attr
}

func (p *Statistic) Unit() (StatisticUnit, bool) {
	if p.unit != nil {
		return *p.unit, true
	}
	var zero StatisticUnit
	return zero, false
}

func (p *Statistic) MustUnit() StatisticUnit {
	if p.unit == nil {
		panic("the unit must not be nil, please use Unit() function instead")
	}
	return *p.unit
}

func (p *Statistic) SetValues(attr *ValueSlice) {
	p.values = attr
}

func (p *Statistic) Values() (*ValueSlice, bool) {
	if p.values != nil {
		return p.values, true
	}
	return nil, false
}

func (p *Statistic) MustValues() *ValueSlice {
	if p.values == nil {
		panic("the values must not be nil, please use Values() function instead")
	}
	return p.values
}

// SetVm Represents a virtual machine.
func (p *Statistic) SetVm(attr *Vm) {
	p.vm = attr
}

// Vm Represents a virtual machine.
func (p *Statistic) Vm() (*Vm, bool) {
	if p.vm != nil {
		return p.vm, true
	}
	return nil, false
}

// MustVm Represents a virtual machine.
func (p *Statistic) MustVm() *Vm {
	if p.vm == nil {
		panic("the vm must not be nil, please use Vm() function instead")
	}
	return p.vm
}

// Step Represents a step, which is part of `job` execution.
// Step is used to describe and track a specific execution unit which is part of a wider sequence.
// Some steps support reporting their progress.
type Step struct {
	Struct
	comment       *string
	description   *string
	endTime       *time.Time
	executionHost *Host
	external      *bool
	externalType  *ExternalSystemType
	id            *string
	job           *Job
	name          *string
	number        *int64
	parentStep    *Step
	progress      *int64
	startTime     *time.Time
	statistics    *StatisticSlice
	status        *StepStatus
	type_         *StepEnum
}

func (p *Step) SetComment(attr string) {
	p.comment = &attr
}

func (p *Step) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *Step) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *Step) SetDescription(attr string) {
	p.description = &attr
}

func (p *Step) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *Step) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *Step) SetEndTime(attr time.Time) {
	p.endTime = &attr
}

func (p *Step) EndTime() (time.Time, bool) {
	if p.endTime != nil {
		return *p.endTime, true
	}
	var zero time.Time
	return zero, false
}

func (p *Step) MustEndTime() time.Time {
	if p.endTime == nil {
		panic("the endTime must not be nil, please use EndTime() function instead")
	}
	return *p.endTime
}

// SetExecutionHost Type representing a host.
func (p *Step) SetExecutionHost(attr *Host) {
	p.executionHost = attr
}

// ExecutionHost Type representing a host.
func (p *Step) ExecutionHost() (*Host, bool) {
	if p.executionHost != nil {
		return p.executionHost, true
	}
	return nil, false
}

// MustExecutionHost Type representing a host.
func (p *Step) MustExecutionHost() *Host {
	if p.executionHost == nil {
		panic("the executionHost must not be nil, please use ExecutionHost() function instead")
	}
	return p.executionHost
}

func (p *Step) SetExternal(attr bool) {
	p.external = &attr
}

func (p *Step) External() (bool, bool) {
	if p.external != nil {
		return *p.external, true
	}
	var zero bool
	return zero, false
}

func (p *Step) MustExternal() bool {
	if p.external == nil {
		panic("the external must not be nil, please use External() function instead")
	}
	return *p.external
}

// SetExternalType Represents the type of the external system that is associated with the `step`.
func (p *Step) SetExternalType(attr ExternalSystemType) {
	p.externalType = &attr
}

// ExternalType Represents the type of the external system that is associated with the `step`.
func (p *Step) ExternalType() (ExternalSystemType, bool) {
	if p.externalType != nil {
		return *p.externalType, true
	}
	var zero ExternalSystemType
	return zero, false
}

// MustExternalType Represents the type of the external system that is associated with the `step`.
func (p *Step) MustExternalType() ExternalSystemType {
	if p.externalType == nil {
		panic("the externalType must not be nil, please use ExternalType() function instead")
	}
	return *p.externalType
}

func (p *Step) SetId(attr string) {
	p.id = &attr
}

func (p *Step) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *Step) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

// SetJob Represents a job, which monitors execution of a flow in the system.
// A job can contain multiple steps in a hierarchic structure.
// The steps can be processed in parallel, depends on the implementation of the flow.
func (p *Step) SetJob(attr *Job) {
	p.job = attr
}

// Job Represents a job, which monitors execution of a flow in the system.
// A job can contain multiple steps in a hierarchic structure.
// The steps can be processed in parallel, depends on the implementation of the flow.
func (p *Step) Job() (*Job, bool) {
	if p.job != nil {
		return p.job, true
	}
	return nil, false
}

// MustJob Represents a job, which monitors execution of a flow in the system.
// A job can contain multiple steps in a hierarchic structure.
// The steps can be processed in parallel, depends on the implementation of the flow.
func (p *Step) MustJob() *Job {
	if p.job == nil {
		panic("the job must not be nil, please use Job() function instead")
	}
	return p.job
}

func (p *Step) SetName(attr string) {
	p.name = &attr
}

func (p *Step) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *Step) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *Step) SetNumber(attr int64) {
	p.number = &attr
}

func (p *Step) Number() (int64, bool) {
	if p.number != nil {
		return *p.number, true
	}
	var zero int64
	return zero, false
}

func (p *Step) MustNumber() int64 {
	if p.number == nil {
		panic("the number must not be nil, please use Number() function instead")
	}
	return *p.number
}

// SetParentStep Represents a step, which is part of `job` execution.
// Step is used to describe and track a specific execution unit which is part of a wider sequence.
// Some steps support reporting their progress.
func (p *Step) SetParentStep(attr *Step) {
	p.parentStep = attr
}

// ParentStep Represents a step, which is part of `job` execution.
// Step is used to describe and track a specific execution unit which is part of a wider sequence.
// Some steps support reporting their progress.
func (p *Step) ParentStep() (*Step, bool) {
	if p.parentStep != nil {
		return p.parentStep, true
	}
	return nil, false
}

// MustParentStep Represents a step, which is part of `job` execution.
// Step is used to describe and track a specific execution unit which is part of a wider sequence.
// Some steps support reporting their progress.
func (p *Step) MustParentStep() *Step {
	if p.parentStep == nil {
		panic("the parentStep must not be nil, please use ParentStep() function instead")
	}
	return p.parentStep
}

func (p *Step) SetProgress(attr int64) {
	p.progress = &attr
}

func (p *Step) Progress() (int64, bool) {
	if p.progress != nil {
		return *p.progress, true
	}
	var zero int64
	return zero, false
}

func (p *Step) MustProgress() int64 {
	if p.progress == nil {
		panic("the progress must not be nil, please use Progress() function instead")
	}
	return *p.progress
}

func (p *Step) SetStartTime(attr time.Time) {
	p.startTime = &attr
}

func (p *Step) StartTime() (time.Time, bool) {
	if p.startTime != nil {
		return *p.startTime, true
	}
	var zero time.Time
	return zero, false
}

func (p *Step) MustStartTime() time.Time {
	if p.startTime == nil {
		panic("the startTime must not be nil, please use StartTime() function instead")
	}
	return *p.startTime
}

func (p *Step) SetStatistics(attr *StatisticSlice) {
	p.statistics = attr
}

func (p *Step) Statistics() (*StatisticSlice, bool) {
	if p.statistics != nil {
		return p.statistics, true
	}
	return nil, false
}

func (p *Step) MustStatistics() *StatisticSlice {
	if p.statistics == nil {
		panic("the statistics must not be nil, please use Statistics() function instead")
	}
	return p.statistics
}

// SetStatus Represents the status of the step.
func (p *Step) SetStatus(attr StepStatus) {
	p.status = &attr
}

// Status Represents the status of the step.
func (p *Step) Status() (StepStatus, bool) {
	if p.status != nil {
		return *p.status, true
	}
	var zero StepStatus
	return zero, false
}

// MustStatus Represents the status of the step.
func (p *Step) MustStatus() StepStatus {
	if p.status == nil {
		panic("the status must not be nil, please use Status() function instead")
	}
	return *p.status
}

// SetType Type representing a step type.
func (p *Step) SetType(attr StepEnum) {
	p.type_ = &attr
}

// Type Type representing a step type.
func (p *Step) Type() (StepEnum, bool) {
	if p.type_ != nil {
		return *p.type_, true
	}
	var zero StepEnum
	return zero, false
}

// MustType Type representing a step type.
func (p *Step) MustType() StepEnum {
	if p.type_ == nil {
		panic("the type_ must not be nil, please use Type() function instead")
	}
	return *p.type_
}

// StorageConnection Represents a storage server connection.
//
// Example XML representation:
//
// [source,xml]
// ----
// <storage_connection id="123">
//   <address>mynfs.example.com</address>
//   <type>nfs</type>
//   <path>/exports/mydata</path>
// </storage_connection>
// ----
type StorageConnection struct {
	Struct
	address       *string
	comment       *string
	description   *string
	glusterVolume *GlusterVolume
	host          *Host
	id            *string
	mountOptions  *string
	name          *string
	nfsRetrans    *int64
	nfsTimeo      *int64
	nfsVersion    *NfsVersion
	password      *string
	path          *string
	port          *int64
	portal        *string
	target        *string
	type_         *StorageType
	username      *string
	vfsType       *string
}

func (p *StorageConnection) SetAddress(attr string) {
	p.address = &attr
}

func (p *StorageConnection) Address() (string, bool) {
	if p.address != nil {
		return *p.address, true
	}
	var zero string
	return zero, false
}

func (p *StorageConnection) MustAddress() string {
	if p.address == nil {
		panic("the address must not be nil, please use Address() function instead")
	}
	return *p.address
}

func (p *StorageConnection) SetComment(attr string) {
	p.comment = &attr
}

func (p *StorageConnection) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *StorageConnection) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *StorageConnection) SetDescription(attr string) {
	p.description = &attr
}

func (p *StorageConnection) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *StorageConnection) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *StorageConnection) SetGlusterVolume(attr *GlusterVolume) {
	p.glusterVolume = attr
}

func (p *StorageConnection) GlusterVolume() (*GlusterVolume, bool) {
	if p.glusterVolume != nil {
		return p.glusterVolume, true
	}
	return nil, false
}

func (p *StorageConnection) MustGlusterVolume() *GlusterVolume {
	if p.glusterVolume == nil {
		panic("the glusterVolume must not be nil, please use GlusterVolume() function instead")
	}
	return p.glusterVolume
}

// SetHost Type representing a host.
func (p *StorageConnection) SetHost(attr *Host) {
	p.host = attr
}

// Host Type representing a host.
func (p *StorageConnection) Host() (*Host, bool) {
	if p.host != nil {
		return p.host, true
	}
	return nil, false
}

// MustHost Type representing a host.
func (p *StorageConnection) MustHost() *Host {
	if p.host == nil {
		panic("the host must not be nil, please use Host() function instead")
	}
	return p.host
}

func (p *StorageConnection) SetId(attr string) {
	p.id = &attr
}

func (p *StorageConnection) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *StorageConnection) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *StorageConnection) SetMountOptions(attr string) {
	p.mountOptions = &attr
}

func (p *StorageConnection) MountOptions() (string, bool) {
	if p.mountOptions != nil {
		return *p.mountOptions, true
	}
	var zero string
	return zero, false
}

func (p *StorageConnection) MustMountOptions() string {
	if p.mountOptions == nil {
		panic("the mountOptions must not be nil, please use MountOptions() function instead")
	}
	return *p.mountOptions
}

func (p *StorageConnection) SetName(attr string) {
	p.name = &attr
}

func (p *StorageConnection) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *StorageConnection) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *StorageConnection) SetNfsRetrans(attr int64) {
	p.nfsRetrans = &attr
}

func (p *StorageConnection) NfsRetrans() (int64, bool) {
	if p.nfsRetrans != nil {
		return *p.nfsRetrans, true
	}
	var zero int64
	return zero, false
}

func (p *StorageConnection) MustNfsRetrans() int64 {
	if p.nfsRetrans == nil {
		panic("the nfsRetrans must not be nil, please use NfsRetrans() function instead")
	}
	return *p.nfsRetrans
}

func (p *StorageConnection) SetNfsTimeo(attr int64) {
	p.nfsTimeo = &attr
}

func (p *StorageConnection) NfsTimeo() (int64, bool) {
	if p.nfsTimeo != nil {
		return *p.nfsTimeo, true
	}
	var zero int64
	return zero, false
}

func (p *StorageConnection) MustNfsTimeo() int64 {
	if p.nfsTimeo == nil {
		panic("the nfsTimeo must not be nil, please use NfsTimeo() function instead")
	}
	return *p.nfsTimeo
}

func (p *StorageConnection) SetNfsVersion(attr NfsVersion) {
	p.nfsVersion = &attr
}

func (p *StorageConnection) NfsVersion() (NfsVersion, bool) {
	if p.nfsVersion != nil {
		return *p.nfsVersion, true
	}
	var zero NfsVersion
	return zero, false
}

func (p *StorageConnection) MustNfsVersion() NfsVersion {
	if p.nfsVersion == nil {
		panic("the nfsVersion must not be nil, please use NfsVersion() function instead")
	}
	return *p.nfsVersion
}

func (p *StorageConnection) SetPassword(attr string) {
	p.password = &attr
}

func (p *StorageConnection) Password() (string, bool) {
	if p.password != nil {
		return *p.password, true
	}
	var zero string
	return zero, false
}

func (p *StorageConnection) MustPassword() string {
	if p.password == nil {
		panic("the password must not be nil, please use Password() function instead")
	}
	return *p.password
}

func (p *StorageConnection) SetPath(attr string) {
	p.path = &attr
}

func (p *StorageConnection) Path() (string, bool) {
	if p.path != nil {
		return *p.path, true
	}
	var zero string
	return zero, false
}

func (p *StorageConnection) MustPath() string {
	if p.path == nil {
		panic("the path must not be nil, please use Path() function instead")
	}
	return *p.path
}

func (p *StorageConnection) SetPort(attr int64) {
	p.port = &attr
}

func (p *StorageConnection) Port() (int64, bool) {
	if p.port != nil {
		return *p.port, true
	}
	var zero int64
	return zero, false
}

func (p *StorageConnection) MustPort() int64 {
	if p.port == nil {
		panic("the port must not be nil, please use Port() function instead")
	}
	return *p.port
}

func (p *StorageConnection) SetPortal(attr string) {
	p.portal = &attr
}

func (p *StorageConnection) Portal() (string, bool) {
	if p.portal != nil {
		return *p.portal, true
	}
	var zero string
	return zero, false
}

func (p *StorageConnection) MustPortal() string {
	if p.portal == nil {
		panic("the portal must not be nil, please use Portal() function instead")
	}
	return *p.portal
}

func (p *StorageConnection) SetTarget(attr string) {
	p.target = &attr
}

func (p *StorageConnection) Target() (string, bool) {
	if p.target != nil {
		return *p.target, true
	}
	var zero string
	return zero, false
}

func (p *StorageConnection) MustTarget() string {
	if p.target == nil {
		panic("the target must not be nil, please use Target() function instead")
	}
	return *p.target
}

// SetType Type representing a storage domain type.
func (p *StorageConnection) SetType(attr StorageType) {
	p.type_ = &attr
}

// Type Type representing a storage domain type.
func (p *StorageConnection) Type() (StorageType, bool) {
	if p.type_ != nil {
		return *p.type_, true
	}
	var zero StorageType
	return zero, false
}

// MustType Type representing a storage domain type.
func (p *StorageConnection) MustType() StorageType {
	if p.type_ == nil {
		panic("the type_ must not be nil, please use Type() function instead")
	}
	return *p.type_
}

func (p *StorageConnection) SetUsername(attr string) {
	p.username = &attr
}

func (p *StorageConnection) Username() (string, bool) {
	if p.username != nil {
		return *p.username, true
	}
	var zero string
	return zero, false
}

func (p *StorageConnection) MustUsername() string {
	if p.username == nil {
		panic("the username must not be nil, please use Username() function instead")
	}
	return *p.username
}

func (p *StorageConnection) SetVfsType(attr string) {
	p.vfsType = &attr
}

func (p *StorageConnection) VfsType() (string, bool) {
	if p.vfsType != nil {
		return *p.vfsType, true
	}
	var zero string
	return zero, false
}

func (p *StorageConnection) MustVfsType() string {
	if p.vfsType == nil {
		panic("the vfsType must not be nil, please use VfsType() function instead")
	}
	return *p.vfsType
}

type StorageConnectionExtension struct {
	Struct
	comment     *string
	description *string
	host        *Host
	id          *string
	name        *string
	password    *string
	target      *string
	username    *string
}

func (p *StorageConnectionExtension) SetComment(attr string) {
	p.comment = &attr
}

func (p *StorageConnectionExtension) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *StorageConnectionExtension) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *StorageConnectionExtension) SetDescription(attr string) {
	p.description = &attr
}

func (p *StorageConnectionExtension) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *StorageConnectionExtension) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

// SetHost Type representing a host.
func (p *StorageConnectionExtension) SetHost(attr *Host) {
	p.host = attr
}

// Host Type representing a host.
func (p *StorageConnectionExtension) Host() (*Host, bool) {
	if p.host != nil {
		return p.host, true
	}
	return nil, false
}

// MustHost Type representing a host.
func (p *StorageConnectionExtension) MustHost() *Host {
	if p.host == nil {
		panic("the host must not be nil, please use Host() function instead")
	}
	return p.host
}

func (p *StorageConnectionExtension) SetId(attr string) {
	p.id = &attr
}

func (p *StorageConnectionExtension) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *StorageConnectionExtension) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *StorageConnectionExtension) SetName(attr string) {
	p.name = &attr
}

func (p *StorageConnectionExtension) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *StorageConnectionExtension) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *StorageConnectionExtension) SetPassword(attr string) {
	p.password = &attr
}

func (p *StorageConnectionExtension) Password() (string, bool) {
	if p.password != nil {
		return *p.password, true
	}
	var zero string
	return zero, false
}

func (p *StorageConnectionExtension) MustPassword() string {
	if p.password == nil {
		panic("the password must not be nil, please use Password() function instead")
	}
	return *p.password
}

func (p *StorageConnectionExtension) SetTarget(attr string) {
	p.target = &attr
}

func (p *StorageConnectionExtension) Target() (string, bool) {
	if p.target != nil {
		return *p.target, true
	}
	var zero string
	return zero, false
}

func (p *StorageConnectionExtension) MustTarget() string {
	if p.target == nil {
		panic("the target must not be nil, please use Target() function instead")
	}
	return *p.target
}

func (p *StorageConnectionExtension) SetUsername(attr string) {
	p.username = &attr
}

func (p *StorageConnectionExtension) Username() (string, bool) {
	if p.username != nil {
		return *p.username, true
	}
	var zero string
	return zero, false
}

func (p *StorageConnectionExtension) MustUsername() string {
	if p.username == nil {
		panic("the username must not be nil, please use Username() function instead")
	}
	return *p.username
}

// StorageDomain Storage domain.
//
// An XML representation of a NFS storage domain with identifier `123`:
//
// [source,xml]
// ----
// <storage_domain href="/ovirt-engine/api/storagedomains/123" id="123">
//   <name>mydata</name>
//   <description>My data</description>
//   <available>38654705664</available>
//   <committed>1073741824</committed>
//   <critical_space_action_blocker>5</critical_space_action_blocker>
//   <external_status>ok</external_status>
//   <master>true</master>
//   <storage>
//     <address>mynfs.example.com</address>
//     <nfs_version>v3</nfs_version>
//     <path>/exports/mydata</path>
//     <type>nfs</type>
//   </storage>
//   <storage_format>v3</storage_format>
//   <type>data</type>
//   <used>13958643712</used>
//   <warning_low_space_indicator>10</warning_low_space_indicator>
//   <wipe_after_delete>false</wipe_after_delete>
//   <data_centers>
//     <data_center href="/ovirt-engine/api/datacenters/456" id="456"/>
//   </data_centers>
// </storage_domain>
// ----
type StorageDomain struct {
	Struct
	available                  *int64
	backup                     *bool
	blockSize                  *int64
	comment                    *string
	committed                  *int64
	criticalSpaceActionBlocker *int64
	dataCenter                 *DataCenter
	dataCenters                *DataCenterSlice
	description                *string
	discardAfterDelete         *bool
	diskProfiles               *DiskProfileSlice
	diskSnapshots              *DiskSnapshotSlice
	disks                      *DiskSlice
	externalStatus             *ExternalStatus
	files                      *FileSlice
	host                       *Host
	id                         *string
	images                     *ImageSlice
	import_                    *bool
	master                     *bool
	name                       *string
	permissions                *PermissionSlice
	status                     *StorageDomainStatus
	storage                    *HostStorage
	storageConnections         *StorageConnectionSlice
	storageFormat              *StorageFormat
	supportsDiscard            *bool
	supportsDiscardZeroesData  *bool
	templates                  *TemplateSlice
	type_                      *StorageDomainType
	used                       *int64
	vms                        *VmSlice
	warningLowSpaceIndicator   *int64
	wipeAfterDelete            *bool
}

func (p *StorageDomain) SetAvailable(attr int64) {
	p.available = &attr
}

func (p *StorageDomain) Available() (int64, bool) {
	if p.available != nil {
		return *p.available, true
	}
	var zero int64
	return zero, false
}

func (p *StorageDomain) MustAvailable() int64 {
	if p.available == nil {
		panic("the available must not be nil, please use Available() function instead")
	}
	return *p.available
}

func (p *StorageDomain) SetBackup(attr bool) {
	p.backup = &attr
}

func (p *StorageDomain) Backup() (bool, bool) {
	if p.backup != nil {
		return *p.backup, true
	}
	var zero bool
	return zero, false
}

func (p *StorageDomain) MustBackup() bool {
	if p.backup == nil {
		panic("the backup must not be nil, please use Backup() function instead")
	}
	return *p.backup
}

func (p *StorageDomain) SetBlockSize(attr int64) {
	p.blockSize = &attr
}

func (p *StorageDomain) BlockSize() (int64, bool) {
	if p.blockSize != nil {
		return *p.blockSize, true
	}
	var zero int64
	return zero, false
}

func (p *StorageDomain) MustBlockSize() int64 {
	if p.blockSize == nil {
		panic("the blockSize must not be nil, please use BlockSize() function instead")
	}
	return *p.blockSize
}

func (p *StorageDomain) SetComment(attr string) {
	p.comment = &attr
}

func (p *StorageDomain) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *StorageDomain) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *StorageDomain) SetCommitted(attr int64) {
	p.committed = &attr
}

func (p *StorageDomain) Committed() (int64, bool) {
	if p.committed != nil {
		return *p.committed, true
	}
	var zero int64
	return zero, false
}

func (p *StorageDomain) MustCommitted() int64 {
	if p.committed == nil {
		panic("the committed must not be nil, please use Committed() function instead")
	}
	return *p.committed
}

func (p *StorageDomain) SetCriticalSpaceActionBlocker(attr int64) {
	p.criticalSpaceActionBlocker = &attr
}

func (p *StorageDomain) CriticalSpaceActionBlocker() (int64, bool) {
	if p.criticalSpaceActionBlocker != nil {
		return *p.criticalSpaceActionBlocker, true
	}
	var zero int64
	return zero, false
}

func (p *StorageDomain) MustCriticalSpaceActionBlocker() int64 {
	if p.criticalSpaceActionBlocker == nil {
		panic("the criticalSpaceActionBlocker must not be nil, please use CriticalSpaceActionBlocker() function instead")
	}
	return *p.criticalSpaceActionBlocker
}

func (p *StorageDomain) SetDataCenter(attr *DataCenter) {
	p.dataCenter = attr
}

func (p *StorageDomain) DataCenter() (*DataCenter, bool) {
	if p.dataCenter != nil {
		return p.dataCenter, true
	}
	return nil, false
}

func (p *StorageDomain) MustDataCenter() *DataCenter {
	if p.dataCenter == nil {
		panic("the dataCenter must not be nil, please use DataCenter() function instead")
	}
	return p.dataCenter
}

func (p *StorageDomain) SetDataCenters(attr *DataCenterSlice) {
	p.dataCenters = attr
}

func (p *StorageDomain) DataCenters() (*DataCenterSlice, bool) {
	if p.dataCenters != nil {
		return p.dataCenters, true
	}
	return nil, false
}

func (p *StorageDomain) MustDataCenters() *DataCenterSlice {
	if p.dataCenters == nil {
		panic("the dataCenters must not be nil, please use DataCenters() function instead")
	}
	return p.dataCenters
}

func (p *StorageDomain) SetDescription(attr string) {
	p.description = &attr
}

func (p *StorageDomain) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *StorageDomain) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *StorageDomain) SetDiscardAfterDelete(attr bool) {
	p.discardAfterDelete = &attr
}

func (p *StorageDomain) DiscardAfterDelete() (bool, bool) {
	if p.discardAfterDelete != nil {
		return *p.discardAfterDelete, true
	}
	var zero bool
	return zero, false
}

func (p *StorageDomain) MustDiscardAfterDelete() bool {
	if p.discardAfterDelete == nil {
		panic("the discardAfterDelete must not be nil, please use DiscardAfterDelete() function instead")
	}
	return *p.discardAfterDelete
}

func (p *StorageDomain) SetDiskProfiles(attr *DiskProfileSlice) {
	p.diskProfiles = attr
}

func (p *StorageDomain) DiskProfiles() (*DiskProfileSlice, bool) {
	if p.diskProfiles != nil {
		return p.diskProfiles, true
	}
	return nil, false
}

func (p *StorageDomain) MustDiskProfiles() *DiskProfileSlice {
	if p.diskProfiles == nil {
		panic("the diskProfiles must not be nil, please use DiskProfiles() function instead")
	}
	return p.diskProfiles
}

func (p *StorageDomain) SetDiskSnapshots(attr *DiskSnapshotSlice) {
	p.diskSnapshots = attr
}

func (p *StorageDomain) DiskSnapshots() (*DiskSnapshotSlice, bool) {
	if p.diskSnapshots != nil {
		return p.diskSnapshots, true
	}
	return nil, false
}

func (p *StorageDomain) MustDiskSnapshots() *DiskSnapshotSlice {
	if p.diskSnapshots == nil {
		panic("the diskSnapshots must not be nil, please use DiskSnapshots() function instead")
	}
	return p.diskSnapshots
}

func (p *StorageDomain) SetDisks(attr *DiskSlice) {
	p.disks = attr
}

func (p *StorageDomain) Disks() (*DiskSlice, bool) {
	if p.disks != nil {
		return p.disks, true
	}
	return nil, false
}

func (p *StorageDomain) MustDisks() *DiskSlice {
	if p.disks == nil {
		panic("the disks must not be nil, please use Disks() function instead")
	}
	return p.disks
}

// SetExternalStatus Represents an external status.
// This status is currently used for <<types/host, hosts>>
// and <<types/storage_domain, storage domains>>, and allows an external
// system to update status of objects it is aware of.
func (p *StorageDomain) SetExternalStatus(attr ExternalStatus) {
	p.externalStatus = &attr
}

// ExternalStatus Represents an external status.
// This status is currently used for <<types/host, hosts>>
// and <<types/storage_domain, storage domains>>, and allows an external
// system to update status of objects it is aware of.
func (p *StorageDomain) ExternalStatus() (ExternalStatus, bool) {
	if p.externalStatus != nil {
		return *p.externalStatus, true
	}
	var zero ExternalStatus
	return zero, false
}

// MustExternalStatus Represents an external status.
// This status is currently used for <<types/host, hosts>>
// and <<types/storage_domain, storage domains>>, and allows an external
// system to update status of objects it is aware of.
func (p *StorageDomain) MustExternalStatus() ExternalStatus {
	if p.externalStatus == nil {
		panic("the externalStatus must not be nil, please use ExternalStatus() function instead")
	}
	return *p.externalStatus
}

func (p *StorageDomain) SetFiles(attr *FileSlice) {
	p.files = attr
}

func (p *StorageDomain) Files() (*FileSlice, bool) {
	if p.files != nil {
		return p.files, true
	}
	return nil, false
}

func (p *StorageDomain) MustFiles() *FileSlice {
	if p.files == nil {
		panic("the files must not be nil, please use Files() function instead")
	}
	return p.files
}

// SetHost Type representing a host.
func (p *StorageDomain) SetHost(attr *Host) {
	p.host = attr
}

// Host Type representing a host.
func (p *StorageDomain) Host() (*Host, bool) {
	if p.host != nil {
		return p.host, true
	}
	return nil, false
}

// MustHost Type representing a host.
func (p *StorageDomain) MustHost() *Host {
	if p.host == nil {
		panic("the host must not be nil, please use Host() function instead")
	}
	return p.host
}

func (p *StorageDomain) SetId(attr string) {
	p.id = &attr
}

func (p *StorageDomain) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *StorageDomain) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *StorageDomain) SetImages(attr *ImageSlice) {
	p.images = attr
}

func (p *StorageDomain) Images() (*ImageSlice, bool) {
	if p.images != nil {
		return p.images, true
	}
	return nil, false
}

func (p *StorageDomain) MustImages() *ImageSlice {
	if p.images == nil {
		panic("the images must not be nil, please use Images() function instead")
	}
	return p.images
}

func (p *StorageDomain) SetImport(attr bool) {
	p.import_ = &attr
}

func (p *StorageDomain) Import() (bool, bool) {
	if p.import_ != nil {
		return *p.import_, true
	}
	var zero bool
	return zero, false
}

func (p *StorageDomain) MustImport() bool {
	if p.import_ == nil {
		panic("the import_ must not be nil, please use Import() function instead")
	}
	return *p.import_
}

func (p *StorageDomain) SetMaster(attr bool) {
	p.master = &attr
}

func (p *StorageDomain) Master() (bool, bool) {
	if p.master != nil {
		return *p.master, true
	}
	var zero bool
	return zero, false
}

func (p *StorageDomain) MustMaster() bool {
	if p.master == nil {
		panic("the master must not be nil, please use Master() function instead")
	}
	return *p.master
}

func (p *StorageDomain) SetName(attr string) {
	p.name = &attr
}

func (p *StorageDomain) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *StorageDomain) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *StorageDomain) SetPermissions(attr *PermissionSlice) {
	p.permissions = attr
}

func (p *StorageDomain) Permissions() (*PermissionSlice, bool) {
	if p.permissions != nil {
		return p.permissions, true
	}
	return nil, false
}

func (p *StorageDomain) MustPermissions() *PermissionSlice {
	if p.permissions == nil {
		panic("the permissions must not be nil, please use Permissions() function instead")
	}
	return p.permissions
}

func (p *StorageDomain) SetStatus(attr StorageDomainStatus) {
	p.status = &attr
}

func (p *StorageDomain) Status() (StorageDomainStatus, bool) {
	if p.status != nil {
		return *p.status, true
	}
	var zero StorageDomainStatus
	return zero, false
}

func (p *StorageDomain) MustStatus() StorageDomainStatus {
	if p.status == nil {
		panic("the status must not be nil, please use Status() function instead")
	}
	return *p.status
}

func (p *StorageDomain) SetStorage(attr *HostStorage) {
	p.storage = attr
}

func (p *StorageDomain) Storage() (*HostStorage, bool) {
	if p.storage != nil {
		return p.storage, true
	}
	return nil, false
}

func (p *StorageDomain) MustStorage() *HostStorage {
	if p.storage == nil {
		panic("the storage must not be nil, please use Storage() function instead")
	}
	return p.storage
}

func (p *StorageDomain) SetStorageConnections(attr *StorageConnectionSlice) {
	p.storageConnections = attr
}

func (p *StorageDomain) StorageConnections() (*StorageConnectionSlice, bool) {
	if p.storageConnections != nil {
		return p.storageConnections, true
	}
	return nil, false
}

func (p *StorageDomain) MustStorageConnections() *StorageConnectionSlice {
	if p.storageConnections == nil {
		panic("the storageConnections must not be nil, please use StorageConnections() function instead")
	}
	return p.storageConnections
}

// SetStorageFormat Type which represents a format of <<types/storage_domain, storage domain>>.
func (p *StorageDomain) SetStorageFormat(attr StorageFormat) {
	p.storageFormat = &attr
}

// StorageFormat Type which represents a format of <<types/storage_domain, storage domain>>.
func (p *StorageDomain) StorageFormat() (StorageFormat, bool) {
	if p.storageFormat != nil {
		return *p.storageFormat, true
	}
	var zero StorageFormat
	return zero, false
}

// MustStorageFormat Type which represents a format of <<types/storage_domain, storage domain>>.
func (p *StorageDomain) MustStorageFormat() StorageFormat {
	if p.storageFormat == nil {
		panic("the storageFormat must not be nil, please use StorageFormat() function instead")
	}
	return *p.storageFormat
}

func (p *StorageDomain) SetSupportsDiscard(attr bool) {
	p.supportsDiscard = &attr
}

func (p *StorageDomain) SupportsDiscard() (bool, bool) {
	if p.supportsDiscard != nil {
		return *p.supportsDiscard, true
	}
	var zero bool
	return zero, false
}

func (p *StorageDomain) MustSupportsDiscard() bool {
	if p.supportsDiscard == nil {
		panic("the supportsDiscard must not be nil, please use SupportsDiscard() function instead")
	}
	return *p.supportsDiscard
}

func (p *StorageDomain) SetSupportsDiscardZeroesData(attr bool) {
	p.supportsDiscardZeroesData = &attr
}

func (p *StorageDomain) SupportsDiscardZeroesData() (bool, bool) {
	if p.supportsDiscardZeroesData != nil {
		return *p.supportsDiscardZeroesData, true
	}
	var zero bool
	return zero, false
}

func (p *StorageDomain) MustSupportsDiscardZeroesData() bool {
	if p.supportsDiscardZeroesData == nil {
		panic("the supportsDiscardZeroesData must not be nil, please use SupportsDiscardZeroesData() function instead")
	}
	return *p.supportsDiscardZeroesData
}

func (p *StorageDomain) SetTemplates(attr *TemplateSlice) {
	p.templates = attr
}

func (p *StorageDomain) Templates() (*TemplateSlice, bool) {
	if p.templates != nil {
		return p.templates, true
	}
	return nil, false
}

func (p *StorageDomain) MustTemplates() *TemplateSlice {
	if p.templates == nil {
		panic("the templates must not be nil, please use Templates() function instead")
	}
	return p.templates
}

// SetType Indicates the kind of data managed by a <<types/storage_domain, storage domain>>.
func (p *StorageDomain) SetType(attr StorageDomainType) {
	p.type_ = &attr
}

// Type Indicates the kind of data managed by a <<types/storage_domain, storage domain>>.
func (p *StorageDomain) Type() (StorageDomainType, bool) {
	if p.type_ != nil {
		return *p.type_, true
	}
	var zero StorageDomainType
	return zero, false
}

// MustType Indicates the kind of data managed by a <<types/storage_domain, storage domain>>.
func (p *StorageDomain) MustType() StorageDomainType {
	if p.type_ == nil {
		panic("the type_ must not be nil, please use Type() function instead")
	}
	return *p.type_
}

func (p *StorageDomain) SetUsed(attr int64) {
	p.used = &attr
}

func (p *StorageDomain) Used() (int64, bool) {
	if p.used != nil {
		return *p.used, true
	}
	var zero int64
	return zero, false
}

func (p *StorageDomain) MustUsed() int64 {
	if p.used == nil {
		panic("the used must not be nil, please use Used() function instead")
	}
	return *p.used
}

func (p *StorageDomain) SetVms(attr *VmSlice) {
	p.vms = attr
}

func (p *StorageDomain) Vms() (*VmSlice, bool) {
	if p.vms != nil {
		return p.vms, true
	}
	return nil, false
}

func (p *StorageDomain) MustVms() *VmSlice {
	if p.vms == nil {
		panic("the vms must not be nil, please use Vms() function instead")
	}
	return p.vms
}

func (p *StorageDomain) SetWarningLowSpaceIndicator(attr int64) {
	p.warningLowSpaceIndicator = &attr
}

func (p *StorageDomain) WarningLowSpaceIndicator() (int64, bool) {
	if p.warningLowSpaceIndicator != nil {
		return *p.warningLowSpaceIndicator, true
	}
	var zero int64
	return zero, false
}

func (p *StorageDomain) MustWarningLowSpaceIndicator() int64 {
	if p.warningLowSpaceIndicator == nil {
		panic("the warningLowSpaceIndicator must not be nil, please use WarningLowSpaceIndicator() function instead")
	}
	return *p.warningLowSpaceIndicator
}

func (p *StorageDomain) SetWipeAfterDelete(attr bool) {
	p.wipeAfterDelete = &attr
}

func (p *StorageDomain) WipeAfterDelete() (bool, bool) {
	if p.wipeAfterDelete != nil {
		return *p.wipeAfterDelete, true
	}
	var zero bool
	return zero, false
}

func (p *StorageDomain) MustWipeAfterDelete() bool {
	if p.wipeAfterDelete == nil {
		panic("the wipeAfterDelete must not be nil, please use WipeAfterDelete() function instead")
	}
	return *p.wipeAfterDelete
}

// StorageDomainLease Represents a lease residing on a storage domain.
//
// A lease is a http://www.ovirt.org/develop/developer-guide/vdsm/sanlock[Sanlock] resource residing on a special
// volume on the storage domain, this Sanlock resource is used to provide storage base locking.
type StorageDomainLease struct {
	Struct
	storageDomain *StorageDomain
}

// SetStorageDomain Storage domain.
//
// An XML representation of a NFS storage domain with identifier `123`:
//
// [source,xml]
// ----
// <storage_domain href="/ovirt-engine/api/storagedomains/123" id="123">
//   <name>mydata</name>
//   <description>My data</description>
//   <available>38654705664</available>
//   <committed>1073741824</committed>
//   <critical_space_action_blocker>5</critical_space_action_blocker>
//   <external_status>ok</external_status>
//   <master>true</master>
//   <storage>
//     <address>mynfs.example.com</address>
//     <nfs_version>v3</nfs_version>
//     <path>/exports/mydata</path>
//     <type>nfs</type>
//   </storage>
//   <storage_format>v3</storage_format>
//   <type>data</type>
//   <used>13958643712</used>
//   <warning_low_space_indicator>10</warning_low_space_indicator>
//   <wipe_after_delete>false</wipe_after_delete>
//   <data_centers>
//     <data_center href="/ovirt-engine/api/datacenters/456" id="456"/>
//   </data_centers>
// </storage_domain>
// ----
func (p *StorageDomainLease) SetStorageDomain(attr *StorageDomain) {
	p.storageDomain = attr
}

// StorageDomain Storage domain.
//
// An XML representation of a NFS storage domain with identifier `123`:
//
// [source,xml]
// ----
// <storage_domain href="/ovirt-engine/api/storagedomains/123" id="123">
//   <name>mydata</name>
//   <description>My data</description>
//   <available>38654705664</available>
//   <committed>1073741824</committed>
//   <critical_space_action_blocker>5</critical_space_action_blocker>
//   <external_status>ok</external_status>
//   <master>true</master>
//   <storage>
//     <address>mynfs.example.com</address>
//     <nfs_version>v3</nfs_version>
//     <path>/exports/mydata</path>
//     <type>nfs</type>
//   </storage>
//   <storage_format>v3</storage_format>
//   <type>data</type>
//   <used>13958643712</used>
//   <warning_low_space_indicator>10</warning_low_space_indicator>
//   <wipe_after_delete>false</wipe_after_delete>
//   <data_centers>
//     <data_center href="/ovirt-engine/api/datacenters/456" id="456"/>
//   </data_centers>
// </storage_domain>
// ----
func (p *StorageDomainLease) StorageDomain() (*StorageDomain, bool) {
	if p.storageDomain != nil {
		return p.storageDomain, true
	}
	return nil, false
}

// MustStorageDomain Storage domain.
//
// An XML representation of a NFS storage domain with identifier `123`:
//
// [source,xml]
// ----
// <storage_domain href="/ovirt-engine/api/storagedomains/123" id="123">
//   <name>mydata</name>
//   <description>My data</description>
//   <available>38654705664</available>
//   <committed>1073741824</committed>
//   <critical_space_action_blocker>5</critical_space_action_blocker>
//   <external_status>ok</external_status>
//   <master>true</master>
//   <storage>
//     <address>mynfs.example.com</address>
//     <nfs_version>v3</nfs_version>
//     <path>/exports/mydata</path>
//     <type>nfs</type>
//   </storage>
//   <storage_format>v3</storage_format>
//   <type>data</type>
//   <used>13958643712</used>
//   <warning_low_space_indicator>10</warning_low_space_indicator>
//   <wipe_after_delete>false</wipe_after_delete>
//   <data_centers>
//     <data_center href="/ovirt-engine/api/datacenters/456" id="456"/>
//   </data_centers>
// </storage_domain>
// ----
func (p *StorageDomainLease) MustStorageDomain() *StorageDomain {
	if p.storageDomain == nil {
		panic("the storageDomain must not be nil, please use StorageDomain() function instead")
	}
	return p.storageDomain
}

// SystemOption Type representing a configuration option of the system.
type SystemOption struct {
	Struct
	comment     *string
	description *string
	id          *string
	name        *string
	values      *SystemOptionValueSlice
}

func (p *SystemOption) SetComment(attr string) {
	p.comment = &attr
}

func (p *SystemOption) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *SystemOption) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *SystemOption) SetDescription(attr string) {
	p.description = &attr
}

func (p *SystemOption) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *SystemOption) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *SystemOption) SetId(attr string) {
	p.id = &attr
}

func (p *SystemOption) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *SystemOption) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *SystemOption) SetName(attr string) {
	p.name = &attr
}

func (p *SystemOption) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *SystemOption) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *SystemOption) SetValues(attr *SystemOptionValueSlice) {
	p.values = attr
}

func (p *SystemOption) Values() (*SystemOptionValueSlice, bool) {
	if p.values != nil {
		return p.values, true
	}
	return nil, false
}

func (p *SystemOption) MustValues() *SystemOptionValueSlice {
	if p.values == nil {
		panic("the values must not be nil, please use Values() function instead")
	}
	return p.values
}

// SystemOptionValue Type representing a pair of value and version of a configuration option.
type SystemOptionValue struct {
	Struct
	value   *string
	version *string
}

func (p *SystemOptionValue) SetValue(attr string) {
	p.value = &attr
}

func (p *SystemOptionValue) Value() (string, bool) {
	if p.value != nil {
		return *p.value, true
	}
	var zero string
	return zero, false
}

func (p *SystemOptionValue) MustValue() string {
	if p.value == nil {
		panic("the value must not be nil, please use Value() function instead")
	}
	return *p.value
}

func (p *SystemOptionValue) SetVersion(attr string) {
	p.version = &attr
}

func (p *SystemOptionValue) Version() (string, bool) {
	if p.version != nil {
		return *p.version, true
	}
	var zero string
	return zero, false
}

func (p *SystemOptionValue) MustVersion() string {
	if p.version == nil {
		panic("the version must not be nil, please use Version() function instead")
	}
	return *p.version
}

// Tag Represents a tag in the system.
type Tag struct {
	Struct
	comment     *string
	description *string
	group       *Group
	host        *Host
	id          *string
	name        *string
	parent      *Tag
	template    *Template
	user        *User
	vm          *Vm
}

func (p *Tag) SetComment(attr string) {
	p.comment = &attr
}

func (p *Tag) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *Tag) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *Tag) SetDescription(attr string) {
	p.description = &attr
}

func (p *Tag) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *Tag) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

// SetGroup This type represents all groups in the directory service.
func (p *Tag) SetGroup(attr *Group) {
	p.group = attr
}

// Group This type represents all groups in the directory service.
func (p *Tag) Group() (*Group, bool) {
	if p.group != nil {
		return p.group, true
	}
	return nil, false
}

// MustGroup This type represents all groups in the directory service.
func (p *Tag) MustGroup() *Group {
	if p.group == nil {
		panic("the group must not be nil, please use Group() function instead")
	}
	return p.group
}

// SetHost Type representing a host.
func (p *Tag) SetHost(attr *Host) {
	p.host = attr
}

// Host Type representing a host.
func (p *Tag) Host() (*Host, bool) {
	if p.host != nil {
		return p.host, true
	}
	return nil, false
}

// MustHost Type representing a host.
func (p *Tag) MustHost() *Host {
	if p.host == nil {
		panic("the host must not be nil, please use Host() function instead")
	}
	return p.host
}

func (p *Tag) SetId(attr string) {
	p.id = &attr
}

func (p *Tag) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *Tag) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *Tag) SetName(attr string) {
	p.name = &attr
}

func (p *Tag) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *Tag) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

// SetParent Represents a tag in the system.
func (p *Tag) SetParent(attr *Tag) {
	p.parent = attr
}

// Parent Represents a tag in the system.
func (p *Tag) Parent() (*Tag, bool) {
	if p.parent != nil {
		return p.parent, true
	}
	return nil, false
}

// MustParent Represents a tag in the system.
func (p *Tag) MustParent() *Tag {
	if p.parent == nil {
		panic("the parent must not be nil, please use Parent() function instead")
	}
	return p.parent
}

// SetTemplate The type that represents a virtual machine template.
// Templates allow for a rapid instantiation of virtual machines with common configuration and disk states.
func (p *Tag) SetTemplate(attr *Template) {
	p.template = attr
}

// Template The type that represents a virtual machine template.
// Templates allow for a rapid instantiation of virtual machines with common configuration and disk states.
func (p *Tag) Template() (*Template, bool) {
	if p.template != nil {
		return p.template, true
	}
	return nil, false
}

// MustTemplate The type that represents a virtual machine template.
// Templates allow for a rapid instantiation of virtual machines with common configuration and disk states.
func (p *Tag) MustTemplate() *Template {
	if p.template == nil {
		panic("the template must not be nil, please use Template() function instead")
	}
	return p.template
}

// SetUser Represents a user in the system.
func (p *Tag) SetUser(attr *User) {
	p.user = attr
}

// User Represents a user in the system.
func (p *Tag) User() (*User, bool) {
	if p.user != nil {
		return p.user, true
	}
	return nil, false
}

// MustUser Represents a user in the system.
func (p *Tag) MustUser() *User {
	if p.user == nil {
		panic("the user must not be nil, please use User() function instead")
	}
	return p.user
}

// SetVm Represents a virtual machine.
func (p *Tag) SetVm(attr *Vm) {
	p.vm = attr
}

// Vm Represents a virtual machine.
func (p *Tag) Vm() (*Vm, bool) {
	if p.vm != nil {
		return p.vm, true
	}
	return nil, false
}

// MustVm Represents a virtual machine.
func (p *Tag) MustVm() *Vm {
	if p.vm == nil {
		panic("the vm must not be nil, please use Vm() function instead")
	}
	return p.vm
}

// Template The type that represents a virtual machine template.
// Templates allow for a rapid instantiation of virtual machines with common configuration and disk states.
type Template struct {
	Struct
	bios                         *Bios
	cdroms                       *CdromSlice
	cluster                      *Cluster
	comment                      *string
	console                      *Console
	cpu                          *Cpu
	cpuProfile                   *CpuProfile
	cpuShares                    *int64
	creationTime                 *time.Time
	customCompatibilityVersion   *Version
	customCpuModel               *string
	customEmulatedMachine        *string
	customProperties             *CustomPropertySlice
	deleteProtected              *bool
	description                  *string
	diskAttachments              *DiskAttachmentSlice
	display                      *Display
	domain                       *Domain
	graphicsConsoles             *GraphicsConsoleSlice
	highAvailability             *HighAvailability
	id                           *string
	initialization               *Initialization
	io                           *Io
	largeIcon                    *Icon
	lease                        *StorageDomainLease
	memory                       *int64
	memoryPolicy                 *MemoryPolicy
	migration                    *MigrationOptions
	migrationDowntime            *int64
	multiQueuesEnabled           *bool
	name                         *string
	nics                         *NicSlice
	origin                       *string
	os                           *OperatingSystem
	permissions                  *PermissionSlice
	placementPolicy              *VmPlacementPolicy
	quota                        *Quota
	rngDevice                    *RngDevice
	serialNumber                 *SerialNumber
	smallIcon                    *Icon
	soundcardEnabled             *bool
	sso                          *Sso
	startPaused                  *bool
	stateless                    *bool
	status                       *TemplateStatus
	storageDomain                *StorageDomain
	storageErrorResumeBehaviour  *VmStorageErrorResumeBehaviour
	tags                         *TagSlice
	timeZone                     *TimeZone
	tpmEnabled                   *bool
	tunnelMigration              *bool
	type_                        *VmType
	usb                          *Usb
	version                      *TemplateVersion
	virtioScsi                   *VirtioScsi
	virtioScsiMultiQueuesEnabled *bool
	vm                           *Vm
	watchdogs                    *WatchdogSlice
}

func (p *Template) SetBios(attr *Bios) {
	p.bios = attr
}

func (p *Template) Bios() (*Bios, bool) {
	if p.bios != nil {
		return p.bios, true
	}
	return nil, false
}

func (p *Template) MustBios() *Bios {
	if p.bios == nil {
		panic("the bios must not be nil, please use Bios() function instead")
	}
	return p.bios
}

func (p *Template) SetCdroms(attr *CdromSlice) {
	p.cdroms = attr
}

func (p *Template) Cdroms() (*CdromSlice, bool) {
	if p.cdroms != nil {
		return p.cdroms, true
	}
	return nil, false
}

func (p *Template) MustCdroms() *CdromSlice {
	if p.cdroms == nil {
		panic("the cdroms must not be nil, please use Cdroms() function instead")
	}
	return p.cdroms
}

// SetCluster Type representation of a cluster.
//
// A JSON representation of a cluster:
//
// [source]
// ----
// {
//   "cluster" : [ {
//     "ballooning_enabled" : "false",
//     "cpu" : {
//       "architecture" : "x86_64",
//       "type" : "Intel SandyBridge Family"
//     },
//     "custom_scheduling_policy_properties" : {
//       "property" : [ {
//         "name" : "HighUtilization",
//         "value" : "80"
//       }, {
//         "name" : "CpuOverCommitDurationMinutes",
//         "value" : "2"
//       } ]
//     },
//     "error_handling" : {
//       "on_error" : "migrate"
//     },
//     "fencing_policy" : {
//       "enabled" : "true",
//       "skip_if_connectivity_broken" : {
//         "enabled" : "false",
//         "threshold" : "50"
//       },
//       "skip_if_gluster_bricks_up" : "false",
//       "skip_if_gluster_quorum_not_met" : "false",
//       "skip_if_sd_active" : {
//         "enabled" : "false"
//       }
//     },
//     "gluster_service" : "false",
//     "firewall_type" : "iptables",
//     "ha_reservation" : "false",
//     "ksm" : {
//       "enabled" : "true",
//       "merge_across_nodes" : "true"
//     },
//     "memory_policy" : {
//       "over_commit" : {
//         "percent" : "100"
//       },
//       "transparent_hugepages" : {
//         "enabled" : "true"
//       }
//     },
//     "migration" : {
//       "auto_converge" : "inherit",
//       "bandwidth" : {
//         "assignment_method" : "auto"
//       },
//       "compressed" : "inherit",
//       "policy" : {
//         "id" : "00000000-0000-0000-0000-000000000000"
//       }
//     },
//     "required_rng_sources" : {
//       "required_rng_source" : [ "random" ]
//     },
//     "switch_type" : "legacy",
//     "threads_as_cores" : "false",
//     "trusted_service" : "false",
//     "tunnel_migration" : "false",
//     "version" : {
//       "major" : "4",
//       "minor" : "1"
//     },
//     "virt_service" : "true",
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "mac_pool" : {
//       "href" : "/ovirt-engine/api/macpools/456",
//       "id" : "456"
//     },
//     "scheduling_policy" : {
//       "href" : "/ovirt-engine/api/schedulingpolicies/789",
//       "id" : "789"
//     },
//     "actions" : {
//       "link" : [ {
//         "href" : "/ovirt-engine/api/clusters/234/resetemulatedmachine",
//         "rel" : "resetemulatedmachine"
//       } ]
//     },
//     "name" : "Default",
//     "description" : "The default server cluster",
//     "href" : "/ovirt-engine/api/clusters/234",
//     "id" : "234",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/clusters/234/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/cpuprofiles",
//       "rel" : "cpuprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networkfilters",
//       "rel" : "networkfilters"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networks",
//       "rel" : "networks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/affinitygroups",
//       "rel" : "affinitygroups"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glusterhooks",
//       "rel" : "glusterhooks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glustervolumes",
//       "rel" : "glustervolumes"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/enabledfeatures",
//       "rel" : "enabledfeatures"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/externalnetworkproviders",
//       "rel" : "externalnetworkproviders"
//     } ]
//   } ]
// }
// ----
func (p *Template) SetCluster(attr *Cluster) {
	p.cluster = attr
}

// Cluster Type representation of a cluster.
//
// A JSON representation of a cluster:
//
// [source]
// ----
// {
//   "cluster" : [ {
//     "ballooning_enabled" : "false",
//     "cpu" : {
//       "architecture" : "x86_64",
//       "type" : "Intel SandyBridge Family"
//     },
//     "custom_scheduling_policy_properties" : {
//       "property" : [ {
//         "name" : "HighUtilization",
//         "value" : "80"
//       }, {
//         "name" : "CpuOverCommitDurationMinutes",
//         "value" : "2"
//       } ]
//     },
//     "error_handling" : {
//       "on_error" : "migrate"
//     },
//     "fencing_policy" : {
//       "enabled" : "true",
//       "skip_if_connectivity_broken" : {
//         "enabled" : "false",
//         "threshold" : "50"
//       },
//       "skip_if_gluster_bricks_up" : "false",
//       "skip_if_gluster_quorum_not_met" : "false",
//       "skip_if_sd_active" : {
//         "enabled" : "false"
//       }
//     },
//     "gluster_service" : "false",
//     "firewall_type" : "iptables",
//     "ha_reservation" : "false",
//     "ksm" : {
//       "enabled" : "true",
//       "merge_across_nodes" : "true"
//     },
//     "memory_policy" : {
//       "over_commit" : {
//         "percent" : "100"
//       },
//       "transparent_hugepages" : {
//         "enabled" : "true"
//       }
//     },
//     "migration" : {
//       "auto_converge" : "inherit",
//       "bandwidth" : {
//         "assignment_method" : "auto"
//       },
//       "compressed" : "inherit",
//       "policy" : {
//         "id" : "00000000-0000-0000-0000-000000000000"
//       }
//     },
//     "required_rng_sources" : {
//       "required_rng_source" : [ "random" ]
//     },
//     "switch_type" : "legacy",
//     "threads_as_cores" : "false",
//     "trusted_service" : "false",
//     "tunnel_migration" : "false",
//     "version" : {
//       "major" : "4",
//       "minor" : "1"
//     },
//     "virt_service" : "true",
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "mac_pool" : {
//       "href" : "/ovirt-engine/api/macpools/456",
//       "id" : "456"
//     },
//     "scheduling_policy" : {
//       "href" : "/ovirt-engine/api/schedulingpolicies/789",
//       "id" : "789"
//     },
//     "actions" : {
//       "link" : [ {
//         "href" : "/ovirt-engine/api/clusters/234/resetemulatedmachine",
//         "rel" : "resetemulatedmachine"
//       } ]
//     },
//     "name" : "Default",
//     "description" : "The default server cluster",
//     "href" : "/ovirt-engine/api/clusters/234",
//     "id" : "234",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/clusters/234/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/cpuprofiles",
//       "rel" : "cpuprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networkfilters",
//       "rel" : "networkfilters"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networks",
//       "rel" : "networks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/affinitygroups",
//       "rel" : "affinitygroups"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glusterhooks",
//       "rel" : "glusterhooks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glustervolumes",
//       "rel" : "glustervolumes"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/enabledfeatures",
//       "rel" : "enabledfeatures"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/externalnetworkproviders",
//       "rel" : "externalnetworkproviders"
//     } ]
//   } ]
// }
// ----
func (p *Template) Cluster() (*Cluster, bool) {
	if p.cluster != nil {
		return p.cluster, true
	}
	return nil, false
}

// MustCluster Type representation of a cluster.
//
// A JSON representation of a cluster:
//
// [source]
// ----
// {
//   "cluster" : [ {
//     "ballooning_enabled" : "false",
//     "cpu" : {
//       "architecture" : "x86_64",
//       "type" : "Intel SandyBridge Family"
//     },
//     "custom_scheduling_policy_properties" : {
//       "property" : [ {
//         "name" : "HighUtilization",
//         "value" : "80"
//       }, {
//         "name" : "CpuOverCommitDurationMinutes",
//         "value" : "2"
//       } ]
//     },
//     "error_handling" : {
//       "on_error" : "migrate"
//     },
//     "fencing_policy" : {
//       "enabled" : "true",
//       "skip_if_connectivity_broken" : {
//         "enabled" : "false",
//         "threshold" : "50"
//       },
//       "skip_if_gluster_bricks_up" : "false",
//       "skip_if_gluster_quorum_not_met" : "false",
//       "skip_if_sd_active" : {
//         "enabled" : "false"
//       }
//     },
//     "gluster_service" : "false",
//     "firewall_type" : "iptables",
//     "ha_reservation" : "false",
//     "ksm" : {
//       "enabled" : "true",
//       "merge_across_nodes" : "true"
//     },
//     "memory_policy" : {
//       "over_commit" : {
//         "percent" : "100"
//       },
//       "transparent_hugepages" : {
//         "enabled" : "true"
//       }
//     },
//     "migration" : {
//       "auto_converge" : "inherit",
//       "bandwidth" : {
//         "assignment_method" : "auto"
//       },
//       "compressed" : "inherit",
//       "policy" : {
//         "id" : "00000000-0000-0000-0000-000000000000"
//       }
//     },
//     "required_rng_sources" : {
//       "required_rng_source" : [ "random" ]
//     },
//     "switch_type" : "legacy",
//     "threads_as_cores" : "false",
//     "trusted_service" : "false",
//     "tunnel_migration" : "false",
//     "version" : {
//       "major" : "4",
//       "minor" : "1"
//     },
//     "virt_service" : "true",
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "mac_pool" : {
//       "href" : "/ovirt-engine/api/macpools/456",
//       "id" : "456"
//     },
//     "scheduling_policy" : {
//       "href" : "/ovirt-engine/api/schedulingpolicies/789",
//       "id" : "789"
//     },
//     "actions" : {
//       "link" : [ {
//         "href" : "/ovirt-engine/api/clusters/234/resetemulatedmachine",
//         "rel" : "resetemulatedmachine"
//       } ]
//     },
//     "name" : "Default",
//     "description" : "The default server cluster",
//     "href" : "/ovirt-engine/api/clusters/234",
//     "id" : "234",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/clusters/234/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/cpuprofiles",
//       "rel" : "cpuprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networkfilters",
//       "rel" : "networkfilters"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networks",
//       "rel" : "networks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/affinitygroups",
//       "rel" : "affinitygroups"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glusterhooks",
//       "rel" : "glusterhooks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glustervolumes",
//       "rel" : "glustervolumes"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/enabledfeatures",
//       "rel" : "enabledfeatures"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/externalnetworkproviders",
//       "rel" : "externalnetworkproviders"
//     } ]
//   } ]
// }
// ----
func (p *Template) MustCluster() *Cluster {
	if p.cluster == nil {
		panic("the cluster must not be nil, please use Cluster() function instead")
	}
	return p.cluster
}

func (p *Template) SetComment(attr string) {
	p.comment = &attr
}

func (p *Template) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *Template) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

// SetConsole Representation for serial console device.
func (p *Template) SetConsole(attr *Console) {
	p.console = attr
}

// Console Representation for serial console device.
func (p *Template) Console() (*Console, bool) {
	if p.console != nil {
		return p.console, true
	}
	return nil, false
}

// MustConsole Representation for serial console device.
func (p *Template) MustConsole() *Console {
	if p.console == nil {
		panic("the console must not be nil, please use Console() function instead")
	}
	return p.console
}

func (p *Template) SetCpu(attr *Cpu) {
	p.cpu = attr
}

func (p *Template) Cpu() (*Cpu, bool) {
	if p.cpu != nil {
		return p.cpu, true
	}
	return nil, false
}

func (p *Template) MustCpu() *Cpu {
	if p.cpu == nil {
		panic("the cpu must not be nil, please use Cpu() function instead")
	}
	return p.cpu
}

func (p *Template) SetCpuProfile(attr *CpuProfile) {
	p.cpuProfile = attr
}

func (p *Template) CpuProfile() (*CpuProfile, bool) {
	if p.cpuProfile != nil {
		return p.cpuProfile, true
	}
	return nil, false
}

func (p *Template) MustCpuProfile() *CpuProfile {
	if p.cpuProfile == nil {
		panic("the cpuProfile must not be nil, please use CpuProfile() function instead")
	}
	return p.cpuProfile
}

func (p *Template) SetCpuShares(attr int64) {
	p.cpuShares = &attr
}

func (p *Template) CpuShares() (int64, bool) {
	if p.cpuShares != nil {
		return *p.cpuShares, true
	}
	var zero int64
	return zero, false
}

func (p *Template) MustCpuShares() int64 {
	if p.cpuShares == nil {
		panic("the cpuShares must not be nil, please use CpuShares() function instead")
	}
	return *p.cpuShares
}

func (p *Template) SetCreationTime(attr time.Time) {
	p.creationTime = &attr
}

func (p *Template) CreationTime() (time.Time, bool) {
	if p.creationTime != nil {
		return *p.creationTime, true
	}
	var zero time.Time
	return zero, false
}

func (p *Template) MustCreationTime() time.Time {
	if p.creationTime == nil {
		panic("the creationTime must not be nil, please use CreationTime() function instead")
	}
	return *p.creationTime
}

func (p *Template) SetCustomCompatibilityVersion(attr *Version) {
	p.customCompatibilityVersion = attr
}

func (p *Template) CustomCompatibilityVersion() (*Version, bool) {
	if p.customCompatibilityVersion != nil {
		return p.customCompatibilityVersion, true
	}
	return nil, false
}

func (p *Template) MustCustomCompatibilityVersion() *Version {
	if p.customCompatibilityVersion == nil {
		panic("the customCompatibilityVersion must not be nil, please use CustomCompatibilityVersion() function instead")
	}
	return p.customCompatibilityVersion
}

func (p *Template) SetCustomCpuModel(attr string) {
	p.customCpuModel = &attr
}

func (p *Template) CustomCpuModel() (string, bool) {
	if p.customCpuModel != nil {
		return *p.customCpuModel, true
	}
	var zero string
	return zero, false
}

func (p *Template) MustCustomCpuModel() string {
	if p.customCpuModel == nil {
		panic("the customCpuModel must not be nil, please use CustomCpuModel() function instead")
	}
	return *p.customCpuModel
}

func (p *Template) SetCustomEmulatedMachine(attr string) {
	p.customEmulatedMachine = &attr
}

func (p *Template) CustomEmulatedMachine() (string, bool) {
	if p.customEmulatedMachine != nil {
		return *p.customEmulatedMachine, true
	}
	var zero string
	return zero, false
}

func (p *Template) MustCustomEmulatedMachine() string {
	if p.customEmulatedMachine == nil {
		panic("the customEmulatedMachine must not be nil, please use CustomEmulatedMachine() function instead")
	}
	return *p.customEmulatedMachine
}

func (p *Template) SetCustomProperties(attr *CustomPropertySlice) {
	p.customProperties = attr
}

func (p *Template) CustomProperties() (*CustomPropertySlice, bool) {
	if p.customProperties != nil {
		return p.customProperties, true
	}
	return nil, false
}

func (p *Template) MustCustomProperties() *CustomPropertySlice {
	if p.customProperties == nil {
		panic("the customProperties must not be nil, please use CustomProperties() function instead")
	}
	return p.customProperties
}

func (p *Template) SetDeleteProtected(attr bool) {
	p.deleteProtected = &attr
}

func (p *Template) DeleteProtected() (bool, bool) {
	if p.deleteProtected != nil {
		return *p.deleteProtected, true
	}
	var zero bool
	return zero, false
}

func (p *Template) MustDeleteProtected() bool {
	if p.deleteProtected == nil {
		panic("the deleteProtected must not be nil, please use DeleteProtected() function instead")
	}
	return *p.deleteProtected
}

func (p *Template) SetDescription(attr string) {
	p.description = &attr
}

func (p *Template) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *Template) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *Template) SetDiskAttachments(attr *DiskAttachmentSlice) {
	p.diskAttachments = attr
}

func (p *Template) DiskAttachments() (*DiskAttachmentSlice, bool) {
	if p.diskAttachments != nil {
		return p.diskAttachments, true
	}
	return nil, false
}

func (p *Template) MustDiskAttachments() *DiskAttachmentSlice {
	if p.diskAttachments == nil {
		panic("the diskAttachments must not be nil, please use DiskAttachments() function instead")
	}
	return p.diskAttachments
}

// SetDisplay Represents a graphic console configuration.
func (p *Template) SetDisplay(attr *Display) {
	p.display = attr
}

// Display Represents a graphic console configuration.
func (p *Template) Display() (*Display, bool) {
	if p.display != nil {
		return p.display, true
	}
	return nil, false
}

// MustDisplay Represents a graphic console configuration.
func (p *Template) MustDisplay() *Display {
	if p.display == nil {
		panic("the display must not be nil, please use Display() function instead")
	}
	return p.display
}

// SetDomain This type represents a directory service domain.
func (p *Template) SetDomain(attr *Domain) {
	p.domain = attr
}

// Domain This type represents a directory service domain.
func (p *Template) Domain() (*Domain, bool) {
	if p.domain != nil {
		return p.domain, true
	}
	return nil, false
}

// MustDomain This type represents a directory service domain.
func (p *Template) MustDomain() *Domain {
	if p.domain == nil {
		panic("the domain must not be nil, please use Domain() function instead")
	}
	return p.domain
}

func (p *Template) SetGraphicsConsoles(attr *GraphicsConsoleSlice) {
	p.graphicsConsoles = attr
}

func (p *Template) GraphicsConsoles() (*GraphicsConsoleSlice, bool) {
	if p.graphicsConsoles != nil {
		return p.graphicsConsoles, true
	}
	return nil, false
}

func (p *Template) MustGraphicsConsoles() *GraphicsConsoleSlice {
	if p.graphicsConsoles == nil {
		panic("the graphicsConsoles must not be nil, please use GraphicsConsoles() function instead")
	}
	return p.graphicsConsoles
}

// SetHighAvailability Type representing high availability of a virtual machine.
func (p *Template) SetHighAvailability(attr *HighAvailability) {
	p.highAvailability = attr
}

// HighAvailability Type representing high availability of a virtual machine.
func (p *Template) HighAvailability() (*HighAvailability, bool) {
	if p.highAvailability != nil {
		return p.highAvailability, true
	}
	return nil, false
}

// MustHighAvailability Type representing high availability of a virtual machine.
func (p *Template) MustHighAvailability() *HighAvailability {
	if p.highAvailability == nil {
		panic("the highAvailability must not be nil, please use HighAvailability() function instead")
	}
	return p.highAvailability
}

func (p *Template) SetId(attr string) {
	p.id = &attr
}

func (p *Template) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *Template) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *Template) SetInitialization(attr *Initialization) {
	p.initialization = attr
}

func (p *Template) Initialization() (*Initialization, bool) {
	if p.initialization != nil {
		return p.initialization, true
	}
	return nil, false
}

func (p *Template) MustInitialization() *Initialization {
	if p.initialization == nil {
		panic("the initialization must not be nil, please use Initialization() function instead")
	}
	return p.initialization
}

func (p *Template) SetIo(attr *Io) {
	p.io = attr
}

func (p *Template) Io() (*Io, bool) {
	if p.io != nil {
		return p.io, true
	}
	return nil, false
}

func (p *Template) MustIo() *Io {
	if p.io == nil {
		panic("the io must not be nil, please use Io() function instead")
	}
	return p.io
}

// SetLargeIcon Icon of virtual machine or template.
func (p *Template) SetLargeIcon(attr *Icon) {
	p.largeIcon = attr
}

// LargeIcon Icon of virtual machine or template.
func (p *Template) LargeIcon() (*Icon, bool) {
	if p.largeIcon != nil {
		return p.largeIcon, true
	}
	return nil, false
}

// MustLargeIcon Icon of virtual machine or template.
func (p *Template) MustLargeIcon() *Icon {
	if p.largeIcon == nil {
		panic("the largeIcon must not be nil, please use LargeIcon() function instead")
	}
	return p.largeIcon
}

// SetLease Represents a lease residing on a storage domain.
//
// A lease is a http://www.ovirt.org/develop/developer-guide/vdsm/sanlock[Sanlock] resource residing on a special
// volume on the storage domain, this Sanlock resource is used to provide storage base locking.
func (p *Template) SetLease(attr *StorageDomainLease) {
	p.lease = attr
}

// Lease Represents a lease residing on a storage domain.
//
// A lease is a http://www.ovirt.org/develop/developer-guide/vdsm/sanlock[Sanlock] resource residing on a special
// volume on the storage domain, this Sanlock resource is used to provide storage base locking.
func (p *Template) Lease() (*StorageDomainLease, bool) {
	if p.lease != nil {
		return p.lease, true
	}
	return nil, false
}

// MustLease Represents a lease residing on a storage domain.
//
// A lease is a http://www.ovirt.org/develop/developer-guide/vdsm/sanlock[Sanlock] resource residing on a special
// volume on the storage domain, this Sanlock resource is used to provide storage base locking.
func (p *Template) MustLease() *StorageDomainLease {
	if p.lease == nil {
		panic("the lease must not be nil, please use Lease() function instead")
	}
	return p.lease
}

func (p *Template) SetMemory(attr int64) {
	p.memory = &attr
}

func (p *Template) Memory() (int64, bool) {
	if p.memory != nil {
		return *p.memory, true
	}
	var zero int64
	return zero, false
}

func (p *Template) MustMemory() int64 {
	if p.memory == nil {
		panic("the memory must not be nil, please use Memory() function instead")
	}
	return *p.memory
}

// SetMemoryPolicy Logical grouping of memory-related properties of virtual machine-like entities.
func (p *Template) SetMemoryPolicy(attr *MemoryPolicy) {
	p.memoryPolicy = attr
}

// MemoryPolicy Logical grouping of memory-related properties of virtual machine-like entities.
func (p *Template) MemoryPolicy() (*MemoryPolicy, bool) {
	if p.memoryPolicy != nil {
		return p.memoryPolicy, true
	}
	return nil, false
}

// MustMemoryPolicy Logical grouping of memory-related properties of virtual machine-like entities.
func (p *Template) MustMemoryPolicy() *MemoryPolicy {
	if p.memoryPolicy == nil {
		panic("the memoryPolicy must not be nil, please use MemoryPolicy() function instead")
	}
	return p.memoryPolicy
}

// SetMigration The type for migration options.
func (p *Template) SetMigration(attr *MigrationOptions) {
	p.migration = attr
}

// Migration The type for migration options.
func (p *Template) Migration() (*MigrationOptions, bool) {
	if p.migration != nil {
		return p.migration, true
	}
	return nil, false
}

// MustMigration The type for migration options.
func (p *Template) MustMigration() *MigrationOptions {
	if p.migration == nil {
		panic("the migration must not be nil, please use Migration() function instead")
	}
	return p.migration
}

func (p *Template) SetMigrationDowntime(attr int64) {
	p.migrationDowntime = &attr
}

func (p *Template) MigrationDowntime() (int64, bool) {
	if p.migrationDowntime != nil {
		return *p.migrationDowntime, true
	}
	var zero int64
	return zero, false
}

func (p *Template) MustMigrationDowntime() int64 {
	if p.migrationDowntime == nil {
		panic("the migrationDowntime must not be nil, please use MigrationDowntime() function instead")
	}
	return *p.migrationDowntime
}

func (p *Template) SetMultiQueuesEnabled(attr bool) {
	p.multiQueuesEnabled = &attr
}

func (p *Template) MultiQueuesEnabled() (bool, bool) {
	if p.multiQueuesEnabled != nil {
		return *p.multiQueuesEnabled, true
	}
	var zero bool
	return zero, false
}

func (p *Template) MustMultiQueuesEnabled() bool {
	if p.multiQueuesEnabled == nil {
		panic("the multiQueuesEnabled must not be nil, please use MultiQueuesEnabled() function instead")
	}
	return *p.multiQueuesEnabled
}

func (p *Template) SetName(attr string) {
	p.name = &attr
}

func (p *Template) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *Template) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *Template) SetNics(attr *NicSlice) {
	p.nics = attr
}

func (p *Template) Nics() (*NicSlice, bool) {
	if p.nics != nil {
		return p.nics, true
	}
	return nil, false
}

func (p *Template) MustNics() *NicSlice {
	if p.nics == nil {
		panic("the nics must not be nil, please use Nics() function instead")
	}
	return p.nics
}

func (p *Template) SetOrigin(attr string) {
	p.origin = &attr
}

func (p *Template) Origin() (string, bool) {
	if p.origin != nil {
		return *p.origin, true
	}
	var zero string
	return zero, false
}

func (p *Template) MustOrigin() string {
	if p.origin == nil {
		panic("the origin must not be nil, please use Origin() function instead")
	}
	return *p.origin
}

// SetOs Information describing the operating system. This is used for both virtual machines and hosts.
func (p *Template) SetOs(attr *OperatingSystem) {
	p.os = attr
}

// Os Information describing the operating system. This is used for both virtual machines and hosts.
func (p *Template) Os() (*OperatingSystem, bool) {
	if p.os != nil {
		return p.os, true
	}
	return nil, false
}

// MustOs Information describing the operating system. This is used for both virtual machines and hosts.
func (p *Template) MustOs() *OperatingSystem {
	if p.os == nil {
		panic("the os must not be nil, please use Os() function instead")
	}
	return p.os
}

func (p *Template) SetPermissions(attr *PermissionSlice) {
	p.permissions = attr
}

func (p *Template) Permissions() (*PermissionSlice, bool) {
	if p.permissions != nil {
		return p.permissions, true
	}
	return nil, false
}

func (p *Template) MustPermissions() *PermissionSlice {
	if p.permissions == nil {
		panic("the permissions must not be nil, please use Permissions() function instead")
	}
	return p.permissions
}

func (p *Template) SetPlacementPolicy(attr *VmPlacementPolicy) {
	p.placementPolicy = attr
}

func (p *Template) PlacementPolicy() (*VmPlacementPolicy, bool) {
	if p.placementPolicy != nil {
		return p.placementPolicy, true
	}
	return nil, false
}

func (p *Template) MustPlacementPolicy() *VmPlacementPolicy {
	if p.placementPolicy == nil {
		panic("the placementPolicy must not be nil, please use PlacementPolicy() function instead")
	}
	return p.placementPolicy
}

// SetQuota Represents a quota object.
//
// An example XML representation of a quota:
//
// [source,xml]
// ----
// <quota href="/ovirt-engine/api/datacenters/7044934e/quotas/dcad5ddc" id="dcad5ddc">
//   <name>My Quota</name>
//   <description>A quota for my oVirt environment</description>
//   <cluster_hard_limit_pct>0</cluster_hard_limit_pct>
//   <cluster_soft_limit_pct>0</cluster_soft_limit_pct>
//   <data_center href="/ovirt-engine/api/datacenters/7044934e" id="7044934e"/>
//   <storage_hard_limit_pct>0</storage_hard_limit_pct>
//   <storage_soft_limit_pct>0</storage_soft_limit_pct>
// </quota>
// ----
func (p *Template) SetQuota(attr *Quota) {
	p.quota = attr
}

// Quota Represents a quota object.
//
// An example XML representation of a quota:
//
// [source,xml]
// ----
// <quota href="/ovirt-engine/api/datacenters/7044934e/quotas/dcad5ddc" id="dcad5ddc">
//   <name>My Quota</name>
//   <description>A quota for my oVirt environment</description>
//   <cluster_hard_limit_pct>0</cluster_hard_limit_pct>
//   <cluster_soft_limit_pct>0</cluster_soft_limit_pct>
//   <data_center href="/ovirt-engine/api/datacenters/7044934e" id="7044934e"/>
//   <storage_hard_limit_pct>0</storage_hard_limit_pct>
//   <storage_soft_limit_pct>0</storage_soft_limit_pct>
// </quota>
// ----
func (p *Template) Quota() (*Quota, bool) {
	if p.quota != nil {
		return p.quota, true
	}
	return nil, false
}

// MustQuota Represents a quota object.
//
// An example XML representation of a quota:
//
// [source,xml]
// ----
// <quota href="/ovirt-engine/api/datacenters/7044934e/quotas/dcad5ddc" id="dcad5ddc">
//   <name>My Quota</name>
//   <description>A quota for my oVirt environment</description>
//   <cluster_hard_limit_pct>0</cluster_hard_limit_pct>
//   <cluster_soft_limit_pct>0</cluster_soft_limit_pct>
//   <data_center href="/ovirt-engine/api/datacenters/7044934e" id="7044934e"/>
//   <storage_hard_limit_pct>0</storage_hard_limit_pct>
//   <storage_soft_limit_pct>0</storage_soft_limit_pct>
// </quota>
// ----
func (p *Template) MustQuota() *Quota {
	if p.quota == nil {
		panic("the quota must not be nil, please use Quota() function instead")
	}
	return p.quota
}

// SetRngDevice Random number generator (RNG) device model.
func (p *Template) SetRngDevice(attr *RngDevice) {
	p.rngDevice = attr
}

// RngDevice Random number generator (RNG) device model.
func (p *Template) RngDevice() (*RngDevice, bool) {
	if p.rngDevice != nil {
		return p.rngDevice, true
	}
	return nil, false
}

// MustRngDevice Random number generator (RNG) device model.
func (p *Template) MustRngDevice() *RngDevice {
	if p.rngDevice == nil {
		panic("the rngDevice must not be nil, please use RngDevice() function instead")
	}
	return p.rngDevice
}

func (p *Template) SetSerialNumber(attr *SerialNumber) {
	p.serialNumber = attr
}

func (p *Template) SerialNumber() (*SerialNumber, bool) {
	if p.serialNumber != nil {
		return p.serialNumber, true
	}
	return nil, false
}

func (p *Template) MustSerialNumber() *SerialNumber {
	if p.serialNumber == nil {
		panic("the serialNumber must not be nil, please use SerialNumber() function instead")
	}
	return p.serialNumber
}

// SetSmallIcon Icon of virtual machine or template.
func (p *Template) SetSmallIcon(attr *Icon) {
	p.smallIcon = attr
}

// SmallIcon Icon of virtual machine or template.
func (p *Template) SmallIcon() (*Icon, bool) {
	if p.smallIcon != nil {
		return p.smallIcon, true
	}
	return nil, false
}

// MustSmallIcon Icon of virtual machine or template.
func (p *Template) MustSmallIcon() *Icon {
	if p.smallIcon == nil {
		panic("the smallIcon must not be nil, please use SmallIcon() function instead")
	}
	return p.smallIcon
}

func (p *Template) SetSoundcardEnabled(attr bool) {
	p.soundcardEnabled = &attr
}

func (p *Template) SoundcardEnabled() (bool, bool) {
	if p.soundcardEnabled != nil {
		return *p.soundcardEnabled, true
	}
	var zero bool
	return zero, false
}

func (p *Template) MustSoundcardEnabled() bool {
	if p.soundcardEnabled == nil {
		panic("the soundcardEnabled must not be nil, please use SoundcardEnabled() function instead")
	}
	return *p.soundcardEnabled
}

func (p *Template) SetSso(attr *Sso) {
	p.sso = attr
}

func (p *Template) Sso() (*Sso, bool) {
	if p.sso != nil {
		return p.sso, true
	}
	return nil, false
}

func (p *Template) MustSso() *Sso {
	if p.sso == nil {
		panic("the sso must not be nil, please use Sso() function instead")
	}
	return p.sso
}

func (p *Template) SetStartPaused(attr bool) {
	p.startPaused = &attr
}

func (p *Template) StartPaused() (bool, bool) {
	if p.startPaused != nil {
		return *p.startPaused, true
	}
	var zero bool
	return zero, false
}

func (p *Template) MustStartPaused() bool {
	if p.startPaused == nil {
		panic("the startPaused must not be nil, please use StartPaused() function instead")
	}
	return *p.startPaused
}

func (p *Template) SetStateless(attr bool) {
	p.stateless = &attr
}

func (p *Template) Stateless() (bool, bool) {
	if p.stateless != nil {
		return *p.stateless, true
	}
	var zero bool
	return zero, false
}

func (p *Template) MustStateless() bool {
	if p.stateless == nil {
		panic("the stateless must not be nil, please use Stateless() function instead")
	}
	return *p.stateless
}

// SetStatus Type representing a status of a virtual machine template.
func (p *Template) SetStatus(attr TemplateStatus) {
	p.status = &attr
}

// Status Type representing a status of a virtual machine template.
func (p *Template) Status() (TemplateStatus, bool) {
	if p.status != nil {
		return *p.status, true
	}
	var zero TemplateStatus
	return zero, false
}

// MustStatus Type representing a status of a virtual machine template.
func (p *Template) MustStatus() TemplateStatus {
	if p.status == nil {
		panic("the status must not be nil, please use Status() function instead")
	}
	return *p.status
}

// SetStorageDomain Storage domain.
//
// An XML representation of a NFS storage domain with identifier `123`:
//
// [source,xml]
// ----
// <storage_domain href="/ovirt-engine/api/storagedomains/123" id="123">
//   <name>mydata</name>
//   <description>My data</description>
//   <available>38654705664</available>
//   <committed>1073741824</committed>
//   <critical_space_action_blocker>5</critical_space_action_blocker>
//   <external_status>ok</external_status>
//   <master>true</master>
//   <storage>
//     <address>mynfs.example.com</address>
//     <nfs_version>v3</nfs_version>
//     <path>/exports/mydata</path>
//     <type>nfs</type>
//   </storage>
//   <storage_format>v3</storage_format>
//   <type>data</type>
//   <used>13958643712</used>
//   <warning_low_space_indicator>10</warning_low_space_indicator>
//   <wipe_after_delete>false</wipe_after_delete>
//   <data_centers>
//     <data_center href="/ovirt-engine/api/datacenters/456" id="456"/>
//   </data_centers>
// </storage_domain>
// ----
func (p *Template) SetStorageDomain(attr *StorageDomain) {
	p.storageDomain = attr
}

// StorageDomain Storage domain.
//
// An XML representation of a NFS storage domain with identifier `123`:
//
// [source,xml]
// ----
// <storage_domain href="/ovirt-engine/api/storagedomains/123" id="123">
//   <name>mydata</name>
//   <description>My data</description>
//   <available>38654705664</available>
//   <committed>1073741824</committed>
//   <critical_space_action_blocker>5</critical_space_action_blocker>
//   <external_status>ok</external_status>
//   <master>true</master>
//   <storage>
//     <address>mynfs.example.com</address>
//     <nfs_version>v3</nfs_version>
//     <path>/exports/mydata</path>
//     <type>nfs</type>
//   </storage>
//   <storage_format>v3</storage_format>
//   <type>data</type>
//   <used>13958643712</used>
//   <warning_low_space_indicator>10</warning_low_space_indicator>
//   <wipe_after_delete>false</wipe_after_delete>
//   <data_centers>
//     <data_center href="/ovirt-engine/api/datacenters/456" id="456"/>
//   </data_centers>
// </storage_domain>
// ----
func (p *Template) StorageDomain() (*StorageDomain, bool) {
	if p.storageDomain != nil {
		return p.storageDomain, true
	}
	return nil, false
}

// MustStorageDomain Storage domain.
//
// An XML representation of a NFS storage domain with identifier `123`:
//
// [source,xml]
// ----
// <storage_domain href="/ovirt-engine/api/storagedomains/123" id="123">
//   <name>mydata</name>
//   <description>My data</description>
//   <available>38654705664</available>
//   <committed>1073741824</committed>
//   <critical_space_action_blocker>5</critical_space_action_blocker>
//   <external_status>ok</external_status>
//   <master>true</master>
//   <storage>
//     <address>mynfs.example.com</address>
//     <nfs_version>v3</nfs_version>
//     <path>/exports/mydata</path>
//     <type>nfs</type>
//   </storage>
//   <storage_format>v3</storage_format>
//   <type>data</type>
//   <used>13958643712</used>
//   <warning_low_space_indicator>10</warning_low_space_indicator>
//   <wipe_after_delete>false</wipe_after_delete>
//   <data_centers>
//     <data_center href="/ovirt-engine/api/datacenters/456" id="456"/>
//   </data_centers>
// </storage_domain>
// ----
func (p *Template) MustStorageDomain() *StorageDomain {
	if p.storageDomain == nil {
		panic("the storageDomain must not be nil, please use StorageDomain() function instead")
	}
	return p.storageDomain
}

// SetStorageErrorResumeBehaviour If the storage, on which this virtual machine has some disks gets
// unresponsive, the virtual machine gets paused.
//
// This are the possible options, what should happen with the virtual machine
// in the moment the storage gets available again.
func (p *Template) SetStorageErrorResumeBehaviour(attr VmStorageErrorResumeBehaviour) {
	p.storageErrorResumeBehaviour = &attr
}

// StorageErrorResumeBehaviour If the storage, on which this virtual machine has some disks gets
// unresponsive, the virtual machine gets paused.
//
// This are the possible options, what should happen with the virtual machine
// in the moment the storage gets available again.
func (p *Template) StorageErrorResumeBehaviour() (VmStorageErrorResumeBehaviour, bool) {
	if p.storageErrorResumeBehaviour != nil {
		return *p.storageErrorResumeBehaviour, true
	}
	var zero VmStorageErrorResumeBehaviour
	return zero, false
}

// MustStorageErrorResumeBehaviour If the storage, on which this virtual machine has some disks gets
// unresponsive, the virtual machine gets paused.
//
// This are the possible options, what should happen with the virtual machine
// in the moment the storage gets available again.
func (p *Template) MustStorageErrorResumeBehaviour() VmStorageErrorResumeBehaviour {
	if p.storageErrorResumeBehaviour == nil {
		panic("the storageErrorResumeBehaviour must not be nil, please use StorageErrorResumeBehaviour() function instead")
	}
	return *p.storageErrorResumeBehaviour
}

func (p *Template) SetTags(attr *TagSlice) {
	p.tags = attr
}

func (p *Template) Tags() (*TagSlice, bool) {
	if p.tags != nil {
		return p.tags, true
	}
	return nil, false
}

func (p *Template) MustTags() *TagSlice {
	if p.tags == nil {
		panic("the tags must not be nil, please use Tags() function instead")
	}
	return p.tags
}

// SetTimeZone Time zone representation.
func (p *Template) SetTimeZone(attr *TimeZone) {
	p.timeZone = attr
}

// TimeZone Time zone representation.
func (p *Template) TimeZone() (*TimeZone, bool) {
	if p.timeZone != nil {
		return p.timeZone, true
	}
	return nil, false
}

// MustTimeZone Time zone representation.
func (p *Template) MustTimeZone() *TimeZone {
	if p.timeZone == nil {
		panic("the timeZone must not be nil, please use TimeZone() function instead")
	}
	return p.timeZone
}

func (p *Template) SetTpmEnabled(attr bool) {
	p.tpmEnabled = &attr
}

func (p *Template) TpmEnabled() (bool, bool) {
	if p.tpmEnabled != nil {
		return *p.tpmEnabled, true
	}
	var zero bool
	return zero, false
}

func (p *Template) MustTpmEnabled() bool {
	if p.tpmEnabled == nil {
		panic("the tpmEnabled must not be nil, please use TpmEnabled() function instead")
	}
	return *p.tpmEnabled
}

func (p *Template) SetTunnelMigration(attr bool) {
	p.tunnelMigration = &attr
}

func (p *Template) TunnelMigration() (bool, bool) {
	if p.tunnelMigration != nil {
		return *p.tunnelMigration, true
	}
	var zero bool
	return zero, false
}

func (p *Template) MustTunnelMigration() bool {
	if p.tunnelMigration == nil {
		panic("the tunnelMigration must not be nil, please use TunnelMigration() function instead")
	}
	return *p.tunnelMigration
}

// SetType Type representing what the virtual machine is optimized for.
func (p *Template) SetType(attr VmType) {
	p.type_ = &attr
}

// Type Type representing what the virtual machine is optimized for.
func (p *Template) Type() (VmType, bool) {
	if p.type_ != nil {
		return *p.type_, true
	}
	var zero VmType
	return zero, false
}

// MustType Type representing what the virtual machine is optimized for.
func (p *Template) MustType() VmType {
	if p.type_ == nil {
		panic("the type_ must not be nil, please use Type() function instead")
	}
	return *p.type_
}

// SetUsb Configuration of the USB device of a virtual machine.
func (p *Template) SetUsb(attr *Usb) {
	p.usb = attr
}

// Usb Configuration of the USB device of a virtual machine.
func (p *Template) Usb() (*Usb, bool) {
	if p.usb != nil {
		return p.usb, true
	}
	return nil, false
}

// MustUsb Configuration of the USB device of a virtual machine.
func (p *Template) MustUsb() *Usb {
	if p.usb == nil {
		panic("the usb must not be nil, please use Usb() function instead")
	}
	return p.usb
}

// SetVersion Type representing a version of a virtual machine template.
func (p *Template) SetVersion(attr *TemplateVersion) {
	p.version = attr
}

// Version Type representing a version of a virtual machine template.
func (p *Template) Version() (*TemplateVersion, bool) {
	if p.version != nil {
		return p.version, true
	}
	return nil, false
}

// MustVersion Type representing a version of a virtual machine template.
func (p *Template) MustVersion() *TemplateVersion {
	if p.version == nil {
		panic("the version must not be nil, please use Version() function instead")
	}
	return p.version
}

// SetVirtioScsi Type representing the support of virtio-SCSI.
// If it supported we use virtio driver for SCSI guest device.
func (p *Template) SetVirtioScsi(attr *VirtioScsi) {
	p.virtioScsi = attr
}

// VirtioScsi Type representing the support of virtio-SCSI.
// If it supported we use virtio driver for SCSI guest device.
func (p *Template) VirtioScsi() (*VirtioScsi, bool) {
	if p.virtioScsi != nil {
		return p.virtioScsi, true
	}
	return nil, false
}

// MustVirtioScsi Type representing the support of virtio-SCSI.
// If it supported we use virtio driver for SCSI guest device.
func (p *Template) MustVirtioScsi() *VirtioScsi {
	if p.virtioScsi == nil {
		panic("the virtioScsi must not be nil, please use VirtioScsi() function instead")
	}
	return p.virtioScsi
}

func (p *Template) SetVirtioScsiMultiQueuesEnabled(attr bool) {
	p.virtioScsiMultiQueuesEnabled = &attr
}

func (p *Template) VirtioScsiMultiQueuesEnabled() (bool, bool) {
	if p.virtioScsiMultiQueuesEnabled != nil {
		return *p.virtioScsiMultiQueuesEnabled, true
	}
	var zero bool
	return zero, false
}

func (p *Template) MustVirtioScsiMultiQueuesEnabled() bool {
	if p.virtioScsiMultiQueuesEnabled == nil {
		panic("the virtioScsiMultiQueuesEnabled must not be nil, please use VirtioScsiMultiQueuesEnabled() function instead")
	}
	return *p.virtioScsiMultiQueuesEnabled
}

// SetVm Represents a virtual machine.
func (p *Template) SetVm(attr *Vm) {
	p.vm = attr
}

// Vm Represents a virtual machine.
func (p *Template) Vm() (*Vm, bool) {
	if p.vm != nil {
		return p.vm, true
	}
	return nil, false
}

// MustVm Represents a virtual machine.
func (p *Template) MustVm() *Vm {
	if p.vm == nil {
		panic("the vm must not be nil, please use Vm() function instead")
	}
	return p.vm
}

func (p *Template) SetWatchdogs(attr *WatchdogSlice) {
	p.watchdogs = attr
}

func (p *Template) Watchdogs() (*WatchdogSlice, bool) {
	if p.watchdogs != nil {
		return p.watchdogs, true
	}
	return nil, false
}

func (p *Template) MustWatchdogs() *WatchdogSlice {
	if p.watchdogs == nil {
		panic("the watchdogs must not be nil, please use Watchdogs() function instead")
	}
	return p.watchdogs
}

// TemplateVersion Type representing a version of a virtual machine template.
type TemplateVersion struct {
	Struct
	baseTemplate  *Template
	versionName   *string
	versionNumber *int64
}

// SetBaseTemplate The type that represents a virtual machine template.
// Templates allow for a rapid instantiation of virtual machines with common configuration and disk states.
func (p *TemplateVersion) SetBaseTemplate(attr *Template) {
	p.baseTemplate = attr
}

// BaseTemplate The type that represents a virtual machine template.
// Templates allow for a rapid instantiation of virtual machines with common configuration and disk states.
func (p *TemplateVersion) BaseTemplate() (*Template, bool) {
	if p.baseTemplate != nil {
		return p.baseTemplate, true
	}
	return nil, false
}

// MustBaseTemplate The type that represents a virtual machine template.
// Templates allow for a rapid instantiation of virtual machines with common configuration and disk states.
func (p *TemplateVersion) MustBaseTemplate() *Template {
	if p.baseTemplate == nil {
		panic("the baseTemplate must not be nil, please use BaseTemplate() function instead")
	}
	return p.baseTemplate
}

func (p *TemplateVersion) SetVersionName(attr string) {
	p.versionName = &attr
}

func (p *TemplateVersion) VersionName() (string, bool) {
	if p.versionName != nil {
		return *p.versionName, true
	}
	var zero string
	return zero, false
}

func (p *TemplateVersion) MustVersionName() string {
	if p.versionName == nil {
		panic("the versionName must not be nil, please use VersionName() function instead")
	}
	return *p.versionName
}

func (p *TemplateVersion) SetVersionNumber(attr int64) {
	p.versionNumber = &attr
}

func (p *TemplateVersion) VersionNumber() (int64, bool) {
	if p.versionNumber != nil {
		return *p.versionNumber, true
	}
	var zero int64
	return zero, false
}

func (p *TemplateVersion) MustVersionNumber() int64 {
	if p.versionNumber == nil {
		panic("the versionNumber must not be nil, please use VersionNumber() function instead")
	}
	return *p.versionNumber
}

// Ticket Type representing a ticket that allows virtual machine access.
type Ticket struct {
	Struct
	expiry *int64
	value  *string
}

func (p *Ticket) SetExpiry(attr int64) {
	p.expiry = &attr
}

func (p *Ticket) Expiry() (int64, bool) {
	if p.expiry != nil {
		return *p.expiry, true
	}
	var zero int64
	return zero, false
}

func (p *Ticket) MustExpiry() int64 {
	if p.expiry == nil {
		panic("the expiry must not be nil, please use Expiry() function instead")
	}
	return *p.expiry
}

func (p *Ticket) SetValue(attr string) {
	p.value = &attr
}

func (p *Ticket) Value() (string, bool) {
	if p.value != nil {
		return *p.value, true
	}
	var zero string
	return zero, false
}

func (p *Ticket) MustValue() string {
	if p.value == nil {
		panic("the value must not be nil, please use Value() function instead")
	}
	return *p.value
}

// TimeZone Time zone representation.
type TimeZone struct {
	Struct
	name      *string
	utcOffset *string
}

func (p *TimeZone) SetName(attr string) {
	p.name = &attr
}

func (p *TimeZone) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *TimeZone) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *TimeZone) SetUtcOffset(attr string) {
	p.utcOffset = &attr
}

func (p *TimeZone) UtcOffset() (string, bool) {
	if p.utcOffset != nil {
		return *p.utcOffset, true
	}
	var zero string
	return zero, false
}

func (p *TimeZone) MustUtcOffset() string {
	if p.utcOffset == nil {
		panic("the utcOffset must not be nil, please use UtcOffset() function instead")
	}
	return *p.utcOffset
}

// TransparentHugePages Type representing a transparent huge pages (THP) support.
type TransparentHugePages struct {
	Struct
	enabled *bool
}

func (p *TransparentHugePages) SetEnabled(attr bool) {
	p.enabled = &attr
}

func (p *TransparentHugePages) Enabled() (bool, bool) {
	if p.enabled != nil {
		return *p.enabled, true
	}
	var zero bool
	return zero, false
}

func (p *TransparentHugePages) MustEnabled() bool {
	if p.enabled == nil {
		panic("the enabled must not be nil, please use Enabled() function instead")
	}
	return *p.enabled
}

type UnmanagedNetwork struct {
	Struct
	comment     *string
	description *string
	host        *Host
	hostNic     *HostNic
	id          *string
	name        *string
}

func (p *UnmanagedNetwork) SetComment(attr string) {
	p.comment = &attr
}

func (p *UnmanagedNetwork) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *UnmanagedNetwork) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *UnmanagedNetwork) SetDescription(attr string) {
	p.description = &attr
}

func (p *UnmanagedNetwork) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *UnmanagedNetwork) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

// SetHost Type representing a host.
func (p *UnmanagedNetwork) SetHost(attr *Host) {
	p.host = attr
}

// Host Type representing a host.
func (p *UnmanagedNetwork) Host() (*Host, bool) {
	if p.host != nil {
		return p.host, true
	}
	return nil, false
}

// MustHost Type representing a host.
func (p *UnmanagedNetwork) MustHost() *Host {
	if p.host == nil {
		panic("the host must not be nil, please use Host() function instead")
	}
	return p.host
}

// SetHostNic Represents a host NIC.
//
// For example, the XML representation of a host NIC looks like this:
//
// [source,xml]
// ----
// <host_nic href="/ovirt-engine/api/hosts/123/nics/456" id="456">
//   <name>eth0</name>
//   <boot_protocol>static</boot_protocol>
//   <bridged>true</bridged>
//   <custom_configuration>true</custom_configuration>
//   <ip>
//     <address>192.168.122.39</address>
//     <gateway>192.168.122.1</gateway>
//     <netmask>255.255.255.0</netmask>
//     <version>v4</version>
//   </ip>
//   <ipv6>
//     <gateway>::</gateway>
//     <version>v6</version>
//   </ipv6>
//   <ipv6_boot_protocol>none</ipv6_boot_protocol>
//   <mac>
//     <address>52:54:00:0c:79:1d</address>
//   </mac>
//   <mtu>1500</mtu>
//   <status>up</status>
// </host_nic>
// ----
//
// A bonded interface is represented as a <<types/host_nic, HostNic>> object
// containing the `bonding` and `slaves` attributes.
//
// For example, the XML representation of a bonded host NIC looks like this:
//
// [source,xml]
// ----
// <host_nic href="/ovirt-engine/api/hosts/123/nics/456" id="456">
//   <name>bond0</name>
//   <mac address="00:00:00:00:00:00"/>
//   <ip>
//     <address>192.168.122.39</address>
//     <gateway>192.168.122.1</gateway>
//     <netmask>255.255.255.0</netmask>
//     <version>v4</version>
//   </ip>
//   <boot_protocol>dhcp</boot_protocol>
//   <bonding>
//     <options>
//       <option>
//         <name>mode</name>
//         <value>4</value>
//         <type>Dynamic link aggregation (802.3ad)</type>
//       </option>
//       <option>
//         <name>miimon</name>
//         <value>100</value>
//       </option>
//     </options>
//     <slaves>
//       <host_nic id="123"/>
//       <host_nic id="456"/>
//     </slaves>
//   </bonding>
//   <mtu>1500</mtu>
//   <bridged>true</bridged>
//   <custom_configuration>false</custom_configuration>
// </host_nic>
// ----
func (p *UnmanagedNetwork) SetHostNic(attr *HostNic) {
	p.hostNic = attr
}

// HostNic Represents a host NIC.
//
// For example, the XML representation of a host NIC looks like this:
//
// [source,xml]
// ----
// <host_nic href="/ovirt-engine/api/hosts/123/nics/456" id="456">
//   <name>eth0</name>
//   <boot_protocol>static</boot_protocol>
//   <bridged>true</bridged>
//   <custom_configuration>true</custom_configuration>
//   <ip>
//     <address>192.168.122.39</address>
//     <gateway>192.168.122.1</gateway>
//     <netmask>255.255.255.0</netmask>
//     <version>v4</version>
//   </ip>
//   <ipv6>
//     <gateway>::</gateway>
//     <version>v6</version>
//   </ipv6>
//   <ipv6_boot_protocol>none</ipv6_boot_protocol>
//   <mac>
//     <address>52:54:00:0c:79:1d</address>
//   </mac>
//   <mtu>1500</mtu>
//   <status>up</status>
// </host_nic>
// ----
//
// A bonded interface is represented as a <<types/host_nic, HostNic>> object
// containing the `bonding` and `slaves` attributes.
//
// For example, the XML representation of a bonded host NIC looks like this:
//
// [source,xml]
// ----
// <host_nic href="/ovirt-engine/api/hosts/123/nics/456" id="456">
//   <name>bond0</name>
//   <mac address="00:00:00:00:00:00"/>
//   <ip>
//     <address>192.168.122.39</address>
//     <gateway>192.168.122.1</gateway>
//     <netmask>255.255.255.0</netmask>
//     <version>v4</version>
//   </ip>
//   <boot_protocol>dhcp</boot_protocol>
//   <bonding>
//     <options>
//       <option>
//         <name>mode</name>
//         <value>4</value>
//         <type>Dynamic link aggregation (802.3ad)</type>
//       </option>
//       <option>
//         <name>miimon</name>
//         <value>100</value>
//       </option>
//     </options>
//     <slaves>
//       <host_nic id="123"/>
//       <host_nic id="456"/>
//     </slaves>
//   </bonding>
//   <mtu>1500</mtu>
//   <bridged>true</bridged>
//   <custom_configuration>false</custom_configuration>
// </host_nic>
// ----
func (p *UnmanagedNetwork) HostNic() (*HostNic, bool) {
	if p.hostNic != nil {
		return p.hostNic, true
	}
	return nil, false
}

// MustHostNic Represents a host NIC.
//
// For example, the XML representation of a host NIC looks like this:
//
// [source,xml]
// ----
// <host_nic href="/ovirt-engine/api/hosts/123/nics/456" id="456">
//   <name>eth0</name>
//   <boot_protocol>static</boot_protocol>
//   <bridged>true</bridged>
//   <custom_configuration>true</custom_configuration>
//   <ip>
//     <address>192.168.122.39</address>
//     <gateway>192.168.122.1</gateway>
//     <netmask>255.255.255.0</netmask>
//     <version>v4</version>
//   </ip>
//   <ipv6>
//     <gateway>::</gateway>
//     <version>v6</version>
//   </ipv6>
//   <ipv6_boot_protocol>none</ipv6_boot_protocol>
//   <mac>
//     <address>52:54:00:0c:79:1d</address>
//   </mac>
//   <mtu>1500</mtu>
//   <status>up</status>
// </host_nic>
// ----
//
// A bonded interface is represented as a <<types/host_nic, HostNic>> object
// containing the `bonding` and `slaves` attributes.
//
// For example, the XML representation of a bonded host NIC looks like this:
//
// [source,xml]
// ----
// <host_nic href="/ovirt-engine/api/hosts/123/nics/456" id="456">
//   <name>bond0</name>
//   <mac address="00:00:00:00:00:00"/>
//   <ip>
//     <address>192.168.122.39</address>
//     <gateway>192.168.122.1</gateway>
//     <netmask>255.255.255.0</netmask>
//     <version>v4</version>
//   </ip>
//   <boot_protocol>dhcp</boot_protocol>
//   <bonding>
//     <options>
//       <option>
//         <name>mode</name>
//         <value>4</value>
//         <type>Dynamic link aggregation (802.3ad)</type>
//       </option>
//       <option>
//         <name>miimon</name>
//         <value>100</value>
//       </option>
//     </options>
//     <slaves>
//       <host_nic id="123"/>
//       <host_nic id="456"/>
//     </slaves>
//   </bonding>
//   <mtu>1500</mtu>
//   <bridged>true</bridged>
//   <custom_configuration>false</custom_configuration>
// </host_nic>
// ----
func (p *UnmanagedNetwork) MustHostNic() *HostNic {
	if p.hostNic == nil {
		panic("the hostNic must not be nil, please use HostNic() function instead")
	}
	return p.hostNic
}

func (p *UnmanagedNetwork) SetId(attr string) {
	p.id = &attr
}

func (p *UnmanagedNetwork) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *UnmanagedNetwork) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *UnmanagedNetwork) SetName(attr string) {
	p.name = &attr
}

func (p *UnmanagedNetwork) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *UnmanagedNetwork) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

// Usb Configuration of the USB device of a virtual machine.
type Usb struct {
	Struct
	enabled *bool
	type_   *UsbType
}

func (p *Usb) SetEnabled(attr bool) {
	p.enabled = &attr
}

func (p *Usb) Enabled() (bool, bool) {
	if p.enabled != nil {
		return *p.enabled, true
	}
	var zero bool
	return zero, false
}

func (p *Usb) MustEnabled() bool {
	if p.enabled == nil {
		panic("the enabled must not be nil, please use Enabled() function instead")
	}
	return *p.enabled
}

// SetType Type of USB device redirection.
func (p *Usb) SetType(attr UsbType) {
	p.type_ = &attr
}

// Type Type of USB device redirection.
func (p *Usb) Type() (UsbType, bool) {
	if p.type_ != nil {
		return *p.type_, true
	}
	var zero UsbType
	return zero, false
}

// MustType Type of USB device redirection.
func (p *Usb) MustType() UsbType {
	if p.type_ == nil {
		panic("the type_ must not be nil, please use Type() function instead")
	}
	return *p.type_
}

// User Represents a user in the system.
type User struct {
	Struct
	comment       *string
	department    *string
	description   *string
	domain        *Domain
	domainEntryId *string
	email         *string
	groups        *GroupSlice
	id            *string
	lastName      *string
	loggedIn      *bool
	name          *string
	namespace     *string
	options       *UserOptionSlice
	password      *string
	permissions   *PermissionSlice
	principal     *string
	roles         *RoleSlice
	sshPublicKeys *SshPublicKeySlice
	tags          *TagSlice
	userName      *string
	userOptions   *PropertySlice
}

func (p *User) SetComment(attr string) {
	p.comment = &attr
}

func (p *User) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *User) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *User) SetDepartment(attr string) {
	p.department = &attr
}

func (p *User) Department() (string, bool) {
	if p.department != nil {
		return *p.department, true
	}
	var zero string
	return zero, false
}

func (p *User) MustDepartment() string {
	if p.department == nil {
		panic("the department must not be nil, please use Department() function instead")
	}
	return *p.department
}

func (p *User) SetDescription(attr string) {
	p.description = &attr
}

func (p *User) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *User) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

// SetDomain This type represents a directory service domain.
func (p *User) SetDomain(attr *Domain) {
	p.domain = attr
}

// Domain This type represents a directory service domain.
func (p *User) Domain() (*Domain, bool) {
	if p.domain != nil {
		return p.domain, true
	}
	return nil, false
}

// MustDomain This type represents a directory service domain.
func (p *User) MustDomain() *Domain {
	if p.domain == nil {
		panic("the domain must not be nil, please use Domain() function instead")
	}
	return p.domain
}

func (p *User) SetDomainEntryId(attr string) {
	p.domainEntryId = &attr
}

func (p *User) DomainEntryId() (string, bool) {
	if p.domainEntryId != nil {
		return *p.domainEntryId, true
	}
	var zero string
	return zero, false
}

func (p *User) MustDomainEntryId() string {
	if p.domainEntryId == nil {
		panic("the domainEntryId must not be nil, please use DomainEntryId() function instead")
	}
	return *p.domainEntryId
}

func (p *User) SetEmail(attr string) {
	p.email = &attr
}

func (p *User) Email() (string, bool) {
	if p.email != nil {
		return *p.email, true
	}
	var zero string
	return zero, false
}

func (p *User) MustEmail() string {
	if p.email == nil {
		panic("the email must not be nil, please use Email() function instead")
	}
	return *p.email
}

func (p *User) SetGroups(attr *GroupSlice) {
	p.groups = attr
}

func (p *User) Groups() (*GroupSlice, bool) {
	if p.groups != nil {
		return p.groups, true
	}
	return nil, false
}

func (p *User) MustGroups() *GroupSlice {
	if p.groups == nil {
		panic("the groups must not be nil, please use Groups() function instead")
	}
	return p.groups
}

func (p *User) SetId(attr string) {
	p.id = &attr
}

func (p *User) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *User) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *User) SetLastName(attr string) {
	p.lastName = &attr
}

func (p *User) LastName() (string, bool) {
	if p.lastName != nil {
		return *p.lastName, true
	}
	var zero string
	return zero, false
}

func (p *User) MustLastName() string {
	if p.lastName == nil {
		panic("the lastName must not be nil, please use LastName() function instead")
	}
	return *p.lastName
}

func (p *User) SetLoggedIn(attr bool) {
	p.loggedIn = &attr
}

func (p *User) LoggedIn() (bool, bool) {
	if p.loggedIn != nil {
		return *p.loggedIn, true
	}
	var zero bool
	return zero, false
}

func (p *User) MustLoggedIn() bool {
	if p.loggedIn == nil {
		panic("the loggedIn must not be nil, please use LoggedIn() function instead")
	}
	return *p.loggedIn
}

func (p *User) SetName(attr string) {
	p.name = &attr
}

func (p *User) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *User) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *User) SetNamespace(attr string) {
	p.namespace = &attr
}

func (p *User) Namespace() (string, bool) {
	if p.namespace != nil {
		return *p.namespace, true
	}
	var zero string
	return zero, false
}

func (p *User) MustNamespace() string {
	if p.namespace == nil {
		panic("the namespace must not be nil, please use Namespace() function instead")
	}
	return *p.namespace
}

func (p *User) SetOptions(attr *UserOptionSlice) {
	p.options = attr
}

func (p *User) Options() (*UserOptionSlice, bool) {
	if p.options != nil {
		return p.options, true
	}
	return nil, false
}

func (p *User) MustOptions() *UserOptionSlice {
	if p.options == nil {
		panic("the options must not be nil, please use Options() function instead")
	}
	return p.options
}

func (p *User) SetPassword(attr string) {
	p.password = &attr
}

func (p *User) Password() (string, bool) {
	if p.password != nil {
		return *p.password, true
	}
	var zero string
	return zero, false
}

func (p *User) MustPassword() string {
	if p.password == nil {
		panic("the password must not be nil, please use Password() function instead")
	}
	return *p.password
}

func (p *User) SetPermissions(attr *PermissionSlice) {
	p.permissions = attr
}

func (p *User) Permissions() (*PermissionSlice, bool) {
	if p.permissions != nil {
		return p.permissions, true
	}
	return nil, false
}

func (p *User) MustPermissions() *PermissionSlice {
	if p.permissions == nil {
		panic("the permissions must not be nil, please use Permissions() function instead")
	}
	return p.permissions
}

func (p *User) SetPrincipal(attr string) {
	p.principal = &attr
}

func (p *User) Principal() (string, bool) {
	if p.principal != nil {
		return *p.principal, true
	}
	var zero string
	return zero, false
}

func (p *User) MustPrincipal() string {
	if p.principal == nil {
		panic("the principal must not be nil, please use Principal() function instead")
	}
	return *p.principal
}

func (p *User) SetRoles(attr *RoleSlice) {
	p.roles = attr
}

func (p *User) Roles() (*RoleSlice, bool) {
	if p.roles != nil {
		return p.roles, true
	}
	return nil, false
}

func (p *User) MustRoles() *RoleSlice {
	if p.roles == nil {
		panic("the roles must not be nil, please use Roles() function instead")
	}
	return p.roles
}

func (p *User) SetSshPublicKeys(attr *SshPublicKeySlice) {
	p.sshPublicKeys = attr
}

func (p *User) SshPublicKeys() (*SshPublicKeySlice, bool) {
	if p.sshPublicKeys != nil {
		return p.sshPublicKeys, true
	}
	return nil, false
}

func (p *User) MustSshPublicKeys() *SshPublicKeySlice {
	if p.sshPublicKeys == nil {
		panic("the sshPublicKeys must not be nil, please use SshPublicKeys() function instead")
	}
	return p.sshPublicKeys
}

func (p *User) SetTags(attr *TagSlice) {
	p.tags = attr
}

func (p *User) Tags() (*TagSlice, bool) {
	if p.tags != nil {
		return p.tags, true
	}
	return nil, false
}

func (p *User) MustTags() *TagSlice {
	if p.tags == nil {
		panic("the tags must not be nil, please use Tags() function instead")
	}
	return p.tags
}

func (p *User) SetUserName(attr string) {
	p.userName = &attr
}

func (p *User) UserName() (string, bool) {
	if p.userName != nil {
		return *p.userName, true
	}
	var zero string
	return zero, false
}

func (p *User) MustUserName() string {
	if p.userName == nil {
		panic("the userName must not be nil, please use UserName() function instead")
	}
	return *p.userName
}

func (p *User) SetUserOptions(attr *PropertySlice) {
	p.userOptions = attr
}

func (p *User) UserOptions() (*PropertySlice, bool) {
	if p.userOptions != nil {
		return p.userOptions, true
	}
	return nil, false
}

func (p *User) MustUserOptions() *PropertySlice {
	if p.userOptions == nil {
		panic("the userOptions must not be nil, please use UserOptions() function instead")
	}
	return p.userOptions
}

// UserOption User options allow you to save key/value properties
// which are used to customize the settings per individual
// user.
type UserOption struct {
	Struct
	comment     *string
	content     *string
	description *string
	id          *string
	name        *string
	user        *User
}

func (p *UserOption) SetComment(attr string) {
	p.comment = &attr
}

func (p *UserOption) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *UserOption) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *UserOption) SetContent(attr string) {
	p.content = &attr
}

func (p *UserOption) Content() (string, bool) {
	if p.content != nil {
		return *p.content, true
	}
	var zero string
	return zero, false
}

func (p *UserOption) MustContent() string {
	if p.content == nil {
		panic("the content must not be nil, please use Content() function instead")
	}
	return *p.content
}

func (p *UserOption) SetDescription(attr string) {
	p.description = &attr
}

func (p *UserOption) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *UserOption) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *UserOption) SetId(attr string) {
	p.id = &attr
}

func (p *UserOption) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *UserOption) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *UserOption) SetName(attr string) {
	p.name = &attr
}

func (p *UserOption) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *UserOption) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

// SetUser Represents a user in the system.
func (p *UserOption) SetUser(attr *User) {
	p.user = attr
}

// User Represents a user in the system.
func (p *UserOption) User() (*User, bool) {
	if p.user != nil {
		return p.user, true
	}
	return nil, false
}

// MustUser Represents a user in the system.
func (p *UserOption) MustUser() *User {
	if p.user == nil {
		panic("the user must not be nil, please use User() function instead")
	}
	return p.user
}

type Value struct {
	Struct
	datum  *float64
	detail *string
}

func (p *Value) SetDatum(attr float64) {
	p.datum = &attr
}

func (p *Value) Datum() (float64, bool) {
	if p.datum != nil {
		return *p.datum, true
	}
	var zero float64
	return zero, false
}

func (p *Value) MustDatum() float64 {
	if p.datum == nil {
		panic("the datum must not be nil, please use Datum() function instead")
	}
	return *p.datum
}

func (p *Value) SetDetail(attr string) {
	p.detail = &attr
}

func (p *Value) Detail() (string, bool) {
	if p.detail != nil {
		return *p.detail, true
	}
	var zero string
	return zero, false
}

func (p *Value) MustDetail() string {
	if p.detail == nil {
		panic("the detail must not be nil, please use Detail() function instead")
	}
	return *p.detail
}

type VcpuPin struct {
	Struct
	cpuSet *string
	vcpu   *int64
}

func (p *VcpuPin) SetCpuSet(attr string) {
	p.cpuSet = &attr
}

func (p *VcpuPin) CpuSet() (string, bool) {
	if p.cpuSet != nil {
		return *p.cpuSet, true
	}
	var zero string
	return zero, false
}

func (p *VcpuPin) MustCpuSet() string {
	if p.cpuSet == nil {
		panic("the cpuSet must not be nil, please use CpuSet() function instead")
	}
	return *p.cpuSet
}

func (p *VcpuPin) SetVcpu(attr int64) {
	p.vcpu = &attr
}

func (p *VcpuPin) Vcpu() (int64, bool) {
	if p.vcpu != nil {
		return *p.vcpu, true
	}
	var zero int64
	return zero, false
}

func (p *VcpuPin) MustVcpu() int64 {
	if p.vcpu == nil {
		panic("the vcpu must not be nil, please use Vcpu() function instead")
	}
	return *p.vcpu
}

type Vendor struct {
	Struct
	comment     *string
	description *string
	id          *string
	name        *string
}

func (p *Vendor) SetComment(attr string) {
	p.comment = &attr
}

func (p *Vendor) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *Vendor) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *Vendor) SetDescription(attr string) {
	p.description = &attr
}

func (p *Vendor) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *Vendor) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *Vendor) SetId(attr string) {
	p.id = &attr
}

func (p *Vendor) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *Vendor) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *Vendor) SetName(attr string) {
	p.name = &attr
}

func (p *Vendor) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *Vendor) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

type Version struct {
	Struct
	build_      *int64
	comment     *string
	description *string
	fullVersion *string
	id          *string
	major       *int64
	minor       *int64
	name        *string
	revision    *int64
}

func (p *Version) SetBuild(attr int64) {
	p.build_ = &attr
}

func (p *Version) Build_() (int64, bool) {
	if p.build_ != nil {
		return *p.build_, true
	}
	var zero int64
	return zero, false
}

func (p *Version) MustBuild() int64 {
	if p.build_ == nil {
		panic("the build_ must not be nil, please use Build_() function instead")
	}
	return *p.build_
}

func (p *Version) SetComment(attr string) {
	p.comment = &attr
}

func (p *Version) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *Version) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *Version) SetDescription(attr string) {
	p.description = &attr
}

func (p *Version) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *Version) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *Version) SetFullVersion(attr string) {
	p.fullVersion = &attr
}

func (p *Version) FullVersion() (string, bool) {
	if p.fullVersion != nil {
		return *p.fullVersion, true
	}
	var zero string
	return zero, false
}

func (p *Version) MustFullVersion() string {
	if p.fullVersion == nil {
		panic("the fullVersion must not be nil, please use FullVersion() function instead")
	}
	return *p.fullVersion
}

func (p *Version) SetId(attr string) {
	p.id = &attr
}

func (p *Version) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *Version) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *Version) SetMajor(attr int64) {
	p.major = &attr
}

func (p *Version) Major() (int64, bool) {
	if p.major != nil {
		return *p.major, true
	}
	var zero int64
	return zero, false
}

func (p *Version) MustMajor() int64 {
	if p.major == nil {
		panic("the major must not be nil, please use Major() function instead")
	}
	return *p.major
}

func (p *Version) SetMinor(attr int64) {
	p.minor = &attr
}

func (p *Version) Minor() (int64, bool) {
	if p.minor != nil {
		return *p.minor, true
	}
	var zero int64
	return zero, false
}

func (p *Version) MustMinor() int64 {
	if p.minor == nil {
		panic("the minor must not be nil, please use Minor() function instead")
	}
	return *p.minor
}

func (p *Version) SetName(attr string) {
	p.name = &attr
}

func (p *Version) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *Version) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *Version) SetRevision(attr int64) {
	p.revision = &attr
}

func (p *Version) Revision() (int64, bool) {
	if p.revision != nil {
		return *p.revision, true
	}
	var zero int64
	return zero, false
}

func (p *Version) MustRevision() int64 {
	if p.revision == nil {
		panic("the revision must not be nil, please use Revision() function instead")
	}
	return *p.revision
}

// VirtioScsi Type representing the support of virtio-SCSI.
// If it supported we use virtio driver for SCSI guest device.
type VirtioScsi struct {
	Struct
	enabled *bool
}

func (p *VirtioScsi) SetEnabled(attr bool) {
	p.enabled = &attr
}

func (p *VirtioScsi) Enabled() (bool, bool) {
	if p.enabled != nil {
		return *p.enabled, true
	}
	var zero bool
	return zero, false
}

func (p *VirtioScsi) MustEnabled() bool {
	if p.enabled == nil {
		panic("the enabled must not be nil, please use Enabled() function instead")
	}
	return *p.enabled
}

// VirtualNumaNode Represents the virtual NUMA node.
//
// An example XML representation:
//
// [source,xml]
// ----
// <vm_numa_node href="/ovirt-engine/api/vms/123/numanodes/456" id="456">
//   <cpu>
//     <cores>
//       <core>
//         <index>0</index>
//       </core>
//     </cores>
//   </cpu>
//   <index>0</index>
//   <memory>1024</memory>
//   <numa_node_pins>
//     <numa_node_pin>
//       <index>0</index>
//     </numa_node_pin>
//   </numa_node_pins>
//   <vm href="/ovirt-engine/api/vms/123" id="123" />
// </vm_numa_node>
// ----
type VirtualNumaNode struct {
	Struct
	comment      *string
	cpu          *Cpu
	description  *string
	host         *Host
	id           *string
	index        *int64
	memory       *int64
	name         *string
	nodeDistance *string
	numaNodePins *NumaNodePinSlice
	numaTuneMode *NumaTuneMode
	statistics   *StatisticSlice
	vm           *Vm
}

func (p *VirtualNumaNode) SetComment(attr string) {
	p.comment = &attr
}

func (p *VirtualNumaNode) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *VirtualNumaNode) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *VirtualNumaNode) SetCpu(attr *Cpu) {
	p.cpu = attr
}

func (p *VirtualNumaNode) Cpu() (*Cpu, bool) {
	if p.cpu != nil {
		return p.cpu, true
	}
	return nil, false
}

func (p *VirtualNumaNode) MustCpu() *Cpu {
	if p.cpu == nil {
		panic("the cpu must not be nil, please use Cpu() function instead")
	}
	return p.cpu
}

func (p *VirtualNumaNode) SetDescription(attr string) {
	p.description = &attr
}

func (p *VirtualNumaNode) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *VirtualNumaNode) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

// SetHost Type representing a host.
func (p *VirtualNumaNode) SetHost(attr *Host) {
	p.host = attr
}

// Host Type representing a host.
func (p *VirtualNumaNode) Host() (*Host, bool) {
	if p.host != nil {
		return p.host, true
	}
	return nil, false
}

// MustHost Type representing a host.
func (p *VirtualNumaNode) MustHost() *Host {
	if p.host == nil {
		panic("the host must not be nil, please use Host() function instead")
	}
	return p.host
}

func (p *VirtualNumaNode) SetId(attr string) {
	p.id = &attr
}

func (p *VirtualNumaNode) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *VirtualNumaNode) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *VirtualNumaNode) SetIndex(attr int64) {
	p.index = &attr
}

func (p *VirtualNumaNode) Index() (int64, bool) {
	if p.index != nil {
		return *p.index, true
	}
	var zero int64
	return zero, false
}

func (p *VirtualNumaNode) MustIndex() int64 {
	if p.index == nil {
		panic("the index must not be nil, please use Index() function instead")
	}
	return *p.index
}

func (p *VirtualNumaNode) SetMemory(attr int64) {
	p.memory = &attr
}

func (p *VirtualNumaNode) Memory() (int64, bool) {
	if p.memory != nil {
		return *p.memory, true
	}
	var zero int64
	return zero, false
}

func (p *VirtualNumaNode) MustMemory() int64 {
	if p.memory == nil {
		panic("the memory must not be nil, please use Memory() function instead")
	}
	return *p.memory
}

func (p *VirtualNumaNode) SetName(attr string) {
	p.name = &attr
}

func (p *VirtualNumaNode) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *VirtualNumaNode) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *VirtualNumaNode) SetNodeDistance(attr string) {
	p.nodeDistance = &attr
}

func (p *VirtualNumaNode) NodeDistance() (string, bool) {
	if p.nodeDistance != nil {
		return *p.nodeDistance, true
	}
	var zero string
	return zero, false
}

func (p *VirtualNumaNode) MustNodeDistance() string {
	if p.nodeDistance == nil {
		panic("the nodeDistance must not be nil, please use NodeDistance() function instead")
	}
	return *p.nodeDistance
}

func (p *VirtualNumaNode) SetNumaNodePins(attr *NumaNodePinSlice) {
	p.numaNodePins = attr
}

func (p *VirtualNumaNode) NumaNodePins() (*NumaNodePinSlice, bool) {
	if p.numaNodePins != nil {
		return p.numaNodePins, true
	}
	return nil, false
}

func (p *VirtualNumaNode) MustNumaNodePins() *NumaNodePinSlice {
	if p.numaNodePins == nil {
		panic("the numaNodePins must not be nil, please use NumaNodePins() function instead")
	}
	return p.numaNodePins
}

func (p *VirtualNumaNode) SetNumaTuneMode(attr NumaTuneMode) {
	p.numaTuneMode = &attr
}

func (p *VirtualNumaNode) NumaTuneMode() (NumaTuneMode, bool) {
	if p.numaTuneMode != nil {
		return *p.numaTuneMode, true
	}
	var zero NumaTuneMode
	return zero, false
}

func (p *VirtualNumaNode) MustNumaTuneMode() NumaTuneMode {
	if p.numaTuneMode == nil {
		panic("the numaTuneMode must not be nil, please use NumaTuneMode() function instead")
	}
	return *p.numaTuneMode
}

func (p *VirtualNumaNode) SetStatistics(attr *StatisticSlice) {
	p.statistics = attr
}

func (p *VirtualNumaNode) Statistics() (*StatisticSlice, bool) {
	if p.statistics != nil {
		return p.statistics, true
	}
	return nil, false
}

func (p *VirtualNumaNode) MustStatistics() *StatisticSlice {
	if p.statistics == nil {
		panic("the statistics must not be nil, please use Statistics() function instead")
	}
	return p.statistics
}

// SetVm Represents a virtual machine.
func (p *VirtualNumaNode) SetVm(attr *Vm) {
	p.vm = attr
}

// Vm Represents a virtual machine.
func (p *VirtualNumaNode) Vm() (*Vm, bool) {
	if p.vm != nil {
		return p.vm, true
	}
	return nil, false
}

// MustVm Represents a virtual machine.
func (p *VirtualNumaNode) MustVm() *Vm {
	if p.vm == nil {
		panic("the vm must not be nil, please use Vm() function instead")
	}
	return p.vm
}

// Vlan Type representing a Virtual LAN (VLAN) type.
type Vlan struct {
	Struct
	id *int64
}

func (p *Vlan) SetId(attr int64) {
	p.id = &attr
}

func (p *Vlan) Id() (int64, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero int64
	return zero, false
}

func (p *Vlan) MustId() int64 {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

// Vm Represents a virtual machine.
type Vm struct {
	Struct
	affinityLabels               *AffinityLabelSlice
	applications                 *ApplicationSlice
	bios                         *Bios
	cdroms                       *CdromSlice
	cluster                      *Cluster
	comment                      *string
	console                      *Console
	cpu                          *Cpu
	cpuProfile                   *CpuProfile
	cpuShares                    *int64
	creationTime                 *time.Time
	customCompatibilityVersion   *Version
	customCpuModel               *string
	customEmulatedMachine        *string
	customProperties             *CustomPropertySlice
	deleteProtected              *bool
	description                  *string
	diskAttachments              *DiskAttachmentSlice
	display                      *Display
	domain                       *Domain
	externalHostProvider         *ExternalHostProvider
	floppies                     *FloppySlice
	fqdn                         *string
	graphicsConsoles             *GraphicsConsoleSlice
	guestOperatingSystem         *GuestOperatingSystem
	guestTimeZone                *TimeZone
	hasIllegalImages             *bool
	highAvailability             *HighAvailability
	host                         *Host
	hostDevices                  *HostDeviceSlice
	id                           *string
	initialization               *Initialization
	instanceType                 *InstanceType
	io                           *Io
	katelloErrata                *KatelloErratumSlice
	largeIcon                    *Icon
	lease                        *StorageDomainLease
	memory                       *int64
	memoryPolicy                 *MemoryPolicy
	migration                    *MigrationOptions
	migrationDowntime            *int64
	multiQueuesEnabled           *bool
	name                         *string
	nextRunConfigurationExists   *bool
	nics                         *NicSlice
	numaNodes                    *NumaNodeSlice
	numaTuneMode                 *NumaTuneMode
	origin                       *string
	originalTemplate             *Template
	os                           *OperatingSystem
	payloads                     *PayloadSlice
	permissions                  *PermissionSlice
	placementPolicy              *VmPlacementPolicy
	quota                        *Quota
	reportedDevices              *ReportedDeviceSlice
	rngDevice                    *RngDevice
	runOnce                      *bool
	serialNumber                 *SerialNumber
	sessions                     *SessionSlice
	smallIcon                    *Icon
	snapshots                    *SnapshotSlice
	soundcardEnabled             *bool
	sso                          *Sso
	startPaused                  *bool
	startTime                    *time.Time
	stateless                    *bool
	statistics                   *StatisticSlice
	status                       *VmStatus
	statusDetail                 *string
	stopReason                   *string
	stopTime                     *time.Time
	storageDomain                *StorageDomain
	storageErrorResumeBehaviour  *VmStorageErrorResumeBehaviour
	tags                         *TagSlice
	template                     *Template
	timeZone                     *TimeZone
	tpmEnabled                   *bool
	tunnelMigration              *bool
	type_                        *VmType
	usb                          *Usb
	useLatestTemplateVersion     *bool
	virtioScsi                   *VirtioScsi
	virtioScsiMultiQueuesEnabled *bool
	vmPool                       *VmPool
	watchdogs                    *WatchdogSlice
}

func (p *Vm) SetAffinityLabels(attr *AffinityLabelSlice) {
	p.affinityLabels = attr
}

func (p *Vm) AffinityLabels() (*AffinityLabelSlice, bool) {
	if p.affinityLabels != nil {
		return p.affinityLabels, true
	}
	return nil, false
}

func (p *Vm) MustAffinityLabels() *AffinityLabelSlice {
	if p.affinityLabels == nil {
		panic("the affinityLabels must not be nil, please use AffinityLabels() function instead")
	}
	return p.affinityLabels
}

func (p *Vm) SetApplications(attr *ApplicationSlice) {
	p.applications = attr
}

func (p *Vm) Applications() (*ApplicationSlice, bool) {
	if p.applications != nil {
		return p.applications, true
	}
	return nil, false
}

func (p *Vm) MustApplications() *ApplicationSlice {
	if p.applications == nil {
		panic("the applications must not be nil, please use Applications() function instead")
	}
	return p.applications
}

func (p *Vm) SetBios(attr *Bios) {
	p.bios = attr
}

func (p *Vm) Bios() (*Bios, bool) {
	if p.bios != nil {
		return p.bios, true
	}
	return nil, false
}

func (p *Vm) MustBios() *Bios {
	if p.bios == nil {
		panic("the bios must not be nil, please use Bios() function instead")
	}
	return p.bios
}

func (p *Vm) SetCdroms(attr *CdromSlice) {
	p.cdroms = attr
}

func (p *Vm) Cdroms() (*CdromSlice, bool) {
	if p.cdroms != nil {
		return p.cdroms, true
	}
	return nil, false
}

func (p *Vm) MustCdroms() *CdromSlice {
	if p.cdroms == nil {
		panic("the cdroms must not be nil, please use Cdroms() function instead")
	}
	return p.cdroms
}

// SetCluster Type representation of a cluster.
//
// A JSON representation of a cluster:
//
// [source]
// ----
// {
//   "cluster" : [ {
//     "ballooning_enabled" : "false",
//     "cpu" : {
//       "architecture" : "x86_64",
//       "type" : "Intel SandyBridge Family"
//     },
//     "custom_scheduling_policy_properties" : {
//       "property" : [ {
//         "name" : "HighUtilization",
//         "value" : "80"
//       }, {
//         "name" : "CpuOverCommitDurationMinutes",
//         "value" : "2"
//       } ]
//     },
//     "error_handling" : {
//       "on_error" : "migrate"
//     },
//     "fencing_policy" : {
//       "enabled" : "true",
//       "skip_if_connectivity_broken" : {
//         "enabled" : "false",
//         "threshold" : "50"
//       },
//       "skip_if_gluster_bricks_up" : "false",
//       "skip_if_gluster_quorum_not_met" : "false",
//       "skip_if_sd_active" : {
//         "enabled" : "false"
//       }
//     },
//     "gluster_service" : "false",
//     "firewall_type" : "iptables",
//     "ha_reservation" : "false",
//     "ksm" : {
//       "enabled" : "true",
//       "merge_across_nodes" : "true"
//     },
//     "memory_policy" : {
//       "over_commit" : {
//         "percent" : "100"
//       },
//       "transparent_hugepages" : {
//         "enabled" : "true"
//       }
//     },
//     "migration" : {
//       "auto_converge" : "inherit",
//       "bandwidth" : {
//         "assignment_method" : "auto"
//       },
//       "compressed" : "inherit",
//       "policy" : {
//         "id" : "00000000-0000-0000-0000-000000000000"
//       }
//     },
//     "required_rng_sources" : {
//       "required_rng_source" : [ "random" ]
//     },
//     "switch_type" : "legacy",
//     "threads_as_cores" : "false",
//     "trusted_service" : "false",
//     "tunnel_migration" : "false",
//     "version" : {
//       "major" : "4",
//       "minor" : "1"
//     },
//     "virt_service" : "true",
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "mac_pool" : {
//       "href" : "/ovirt-engine/api/macpools/456",
//       "id" : "456"
//     },
//     "scheduling_policy" : {
//       "href" : "/ovirt-engine/api/schedulingpolicies/789",
//       "id" : "789"
//     },
//     "actions" : {
//       "link" : [ {
//         "href" : "/ovirt-engine/api/clusters/234/resetemulatedmachine",
//         "rel" : "resetemulatedmachine"
//       } ]
//     },
//     "name" : "Default",
//     "description" : "The default server cluster",
//     "href" : "/ovirt-engine/api/clusters/234",
//     "id" : "234",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/clusters/234/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/cpuprofiles",
//       "rel" : "cpuprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networkfilters",
//       "rel" : "networkfilters"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networks",
//       "rel" : "networks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/affinitygroups",
//       "rel" : "affinitygroups"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glusterhooks",
//       "rel" : "glusterhooks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glustervolumes",
//       "rel" : "glustervolumes"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/enabledfeatures",
//       "rel" : "enabledfeatures"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/externalnetworkproviders",
//       "rel" : "externalnetworkproviders"
//     } ]
//   } ]
// }
// ----
func (p *Vm) SetCluster(attr *Cluster) {
	p.cluster = attr
}

// Cluster Type representation of a cluster.
//
// A JSON representation of a cluster:
//
// [source]
// ----
// {
//   "cluster" : [ {
//     "ballooning_enabled" : "false",
//     "cpu" : {
//       "architecture" : "x86_64",
//       "type" : "Intel SandyBridge Family"
//     },
//     "custom_scheduling_policy_properties" : {
//       "property" : [ {
//         "name" : "HighUtilization",
//         "value" : "80"
//       }, {
//         "name" : "CpuOverCommitDurationMinutes",
//         "value" : "2"
//       } ]
//     },
//     "error_handling" : {
//       "on_error" : "migrate"
//     },
//     "fencing_policy" : {
//       "enabled" : "true",
//       "skip_if_connectivity_broken" : {
//         "enabled" : "false",
//         "threshold" : "50"
//       },
//       "skip_if_gluster_bricks_up" : "false",
//       "skip_if_gluster_quorum_not_met" : "false",
//       "skip_if_sd_active" : {
//         "enabled" : "false"
//       }
//     },
//     "gluster_service" : "false",
//     "firewall_type" : "iptables",
//     "ha_reservation" : "false",
//     "ksm" : {
//       "enabled" : "true",
//       "merge_across_nodes" : "true"
//     },
//     "memory_policy" : {
//       "over_commit" : {
//         "percent" : "100"
//       },
//       "transparent_hugepages" : {
//         "enabled" : "true"
//       }
//     },
//     "migration" : {
//       "auto_converge" : "inherit",
//       "bandwidth" : {
//         "assignment_method" : "auto"
//       },
//       "compressed" : "inherit",
//       "policy" : {
//         "id" : "00000000-0000-0000-0000-000000000000"
//       }
//     },
//     "required_rng_sources" : {
//       "required_rng_source" : [ "random" ]
//     },
//     "switch_type" : "legacy",
//     "threads_as_cores" : "false",
//     "trusted_service" : "false",
//     "tunnel_migration" : "false",
//     "version" : {
//       "major" : "4",
//       "minor" : "1"
//     },
//     "virt_service" : "true",
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "mac_pool" : {
//       "href" : "/ovirt-engine/api/macpools/456",
//       "id" : "456"
//     },
//     "scheduling_policy" : {
//       "href" : "/ovirt-engine/api/schedulingpolicies/789",
//       "id" : "789"
//     },
//     "actions" : {
//       "link" : [ {
//         "href" : "/ovirt-engine/api/clusters/234/resetemulatedmachine",
//         "rel" : "resetemulatedmachine"
//       } ]
//     },
//     "name" : "Default",
//     "description" : "The default server cluster",
//     "href" : "/ovirt-engine/api/clusters/234",
//     "id" : "234",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/clusters/234/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/cpuprofiles",
//       "rel" : "cpuprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networkfilters",
//       "rel" : "networkfilters"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networks",
//       "rel" : "networks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/affinitygroups",
//       "rel" : "affinitygroups"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glusterhooks",
//       "rel" : "glusterhooks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glustervolumes",
//       "rel" : "glustervolumes"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/enabledfeatures",
//       "rel" : "enabledfeatures"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/externalnetworkproviders",
//       "rel" : "externalnetworkproviders"
//     } ]
//   } ]
// }
// ----
func (p *Vm) Cluster() (*Cluster, bool) {
	if p.cluster != nil {
		return p.cluster, true
	}
	return nil, false
}

// MustCluster Type representation of a cluster.
//
// A JSON representation of a cluster:
//
// [source]
// ----
// {
//   "cluster" : [ {
//     "ballooning_enabled" : "false",
//     "cpu" : {
//       "architecture" : "x86_64",
//       "type" : "Intel SandyBridge Family"
//     },
//     "custom_scheduling_policy_properties" : {
//       "property" : [ {
//         "name" : "HighUtilization",
//         "value" : "80"
//       }, {
//         "name" : "CpuOverCommitDurationMinutes",
//         "value" : "2"
//       } ]
//     },
//     "error_handling" : {
//       "on_error" : "migrate"
//     },
//     "fencing_policy" : {
//       "enabled" : "true",
//       "skip_if_connectivity_broken" : {
//         "enabled" : "false",
//         "threshold" : "50"
//       },
//       "skip_if_gluster_bricks_up" : "false",
//       "skip_if_gluster_quorum_not_met" : "false",
//       "skip_if_sd_active" : {
//         "enabled" : "false"
//       }
//     },
//     "gluster_service" : "false",
//     "firewall_type" : "iptables",
//     "ha_reservation" : "false",
//     "ksm" : {
//       "enabled" : "true",
//       "merge_across_nodes" : "true"
//     },
//     "memory_policy" : {
//       "over_commit" : {
//         "percent" : "100"
//       },
//       "transparent_hugepages" : {
//         "enabled" : "true"
//       }
//     },
//     "migration" : {
//       "auto_converge" : "inherit",
//       "bandwidth" : {
//         "assignment_method" : "auto"
//       },
//       "compressed" : "inherit",
//       "policy" : {
//         "id" : "00000000-0000-0000-0000-000000000000"
//       }
//     },
//     "required_rng_sources" : {
//       "required_rng_source" : [ "random" ]
//     },
//     "switch_type" : "legacy",
//     "threads_as_cores" : "false",
//     "trusted_service" : "false",
//     "tunnel_migration" : "false",
//     "version" : {
//       "major" : "4",
//       "minor" : "1"
//     },
//     "virt_service" : "true",
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "mac_pool" : {
//       "href" : "/ovirt-engine/api/macpools/456",
//       "id" : "456"
//     },
//     "scheduling_policy" : {
//       "href" : "/ovirt-engine/api/schedulingpolicies/789",
//       "id" : "789"
//     },
//     "actions" : {
//       "link" : [ {
//         "href" : "/ovirt-engine/api/clusters/234/resetemulatedmachine",
//         "rel" : "resetemulatedmachine"
//       } ]
//     },
//     "name" : "Default",
//     "description" : "The default server cluster",
//     "href" : "/ovirt-engine/api/clusters/234",
//     "id" : "234",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/clusters/234/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/cpuprofiles",
//       "rel" : "cpuprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networkfilters",
//       "rel" : "networkfilters"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networks",
//       "rel" : "networks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/affinitygroups",
//       "rel" : "affinitygroups"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glusterhooks",
//       "rel" : "glusterhooks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glustervolumes",
//       "rel" : "glustervolumes"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/enabledfeatures",
//       "rel" : "enabledfeatures"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/externalnetworkproviders",
//       "rel" : "externalnetworkproviders"
//     } ]
//   } ]
// }
// ----
func (p *Vm) MustCluster() *Cluster {
	if p.cluster == nil {
		panic("the cluster must not be nil, please use Cluster() function instead")
	}
	return p.cluster
}

func (p *Vm) SetComment(attr string) {
	p.comment = &attr
}

func (p *Vm) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *Vm) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

// SetConsole Representation for serial console device.
func (p *Vm) SetConsole(attr *Console) {
	p.console = attr
}

// Console Representation for serial console device.
func (p *Vm) Console() (*Console, bool) {
	if p.console != nil {
		return p.console, true
	}
	return nil, false
}

// MustConsole Representation for serial console device.
func (p *Vm) MustConsole() *Console {
	if p.console == nil {
		panic("the console must not be nil, please use Console() function instead")
	}
	return p.console
}

func (p *Vm) SetCpu(attr *Cpu) {
	p.cpu = attr
}

func (p *Vm) Cpu() (*Cpu, bool) {
	if p.cpu != nil {
		return p.cpu, true
	}
	return nil, false
}

func (p *Vm) MustCpu() *Cpu {
	if p.cpu == nil {
		panic("the cpu must not be nil, please use Cpu() function instead")
	}
	return p.cpu
}

func (p *Vm) SetCpuProfile(attr *CpuProfile) {
	p.cpuProfile = attr
}

func (p *Vm) CpuProfile() (*CpuProfile, bool) {
	if p.cpuProfile != nil {
		return p.cpuProfile, true
	}
	return nil, false
}

func (p *Vm) MustCpuProfile() *CpuProfile {
	if p.cpuProfile == nil {
		panic("the cpuProfile must not be nil, please use CpuProfile() function instead")
	}
	return p.cpuProfile
}

func (p *Vm) SetCpuShares(attr int64) {
	p.cpuShares = &attr
}

func (p *Vm) CpuShares() (int64, bool) {
	if p.cpuShares != nil {
		return *p.cpuShares, true
	}
	var zero int64
	return zero, false
}

func (p *Vm) MustCpuShares() int64 {
	if p.cpuShares == nil {
		panic("the cpuShares must not be nil, please use CpuShares() function instead")
	}
	return *p.cpuShares
}

func (p *Vm) SetCreationTime(attr time.Time) {
	p.creationTime = &attr
}

func (p *Vm) CreationTime() (time.Time, bool) {
	if p.creationTime != nil {
		return *p.creationTime, true
	}
	var zero time.Time
	return zero, false
}

func (p *Vm) MustCreationTime() time.Time {
	if p.creationTime == nil {
		panic("the creationTime must not be nil, please use CreationTime() function instead")
	}
	return *p.creationTime
}

func (p *Vm) SetCustomCompatibilityVersion(attr *Version) {
	p.customCompatibilityVersion = attr
}

func (p *Vm) CustomCompatibilityVersion() (*Version, bool) {
	if p.customCompatibilityVersion != nil {
		return p.customCompatibilityVersion, true
	}
	return nil, false
}

func (p *Vm) MustCustomCompatibilityVersion() *Version {
	if p.customCompatibilityVersion == nil {
		panic("the customCompatibilityVersion must not be nil, please use CustomCompatibilityVersion() function instead")
	}
	return p.customCompatibilityVersion
}

func (p *Vm) SetCustomCpuModel(attr string) {
	p.customCpuModel = &attr
}

func (p *Vm) CustomCpuModel() (string, bool) {
	if p.customCpuModel != nil {
		return *p.customCpuModel, true
	}
	var zero string
	return zero, false
}

func (p *Vm) MustCustomCpuModel() string {
	if p.customCpuModel == nil {
		panic("the customCpuModel must not be nil, please use CustomCpuModel() function instead")
	}
	return *p.customCpuModel
}

func (p *Vm) SetCustomEmulatedMachine(attr string) {
	p.customEmulatedMachine = &attr
}

func (p *Vm) CustomEmulatedMachine() (string, bool) {
	if p.customEmulatedMachine != nil {
		return *p.customEmulatedMachine, true
	}
	var zero string
	return zero, false
}

func (p *Vm) MustCustomEmulatedMachine() string {
	if p.customEmulatedMachine == nil {
		panic("the customEmulatedMachine must not be nil, please use CustomEmulatedMachine() function instead")
	}
	return *p.customEmulatedMachine
}

func (p *Vm) SetCustomProperties(attr *CustomPropertySlice) {
	p.customProperties = attr
}

func (p *Vm) CustomProperties() (*CustomPropertySlice, bool) {
	if p.customProperties != nil {
		return p.customProperties, true
	}
	return nil, false
}

func (p *Vm) MustCustomProperties() *CustomPropertySlice {
	if p.customProperties == nil {
		panic("the customProperties must not be nil, please use CustomProperties() function instead")
	}
	return p.customProperties
}

func (p *Vm) SetDeleteProtected(attr bool) {
	p.deleteProtected = &attr
}

func (p *Vm) DeleteProtected() (bool, bool) {
	if p.deleteProtected != nil {
		return *p.deleteProtected, true
	}
	var zero bool
	return zero, false
}

func (p *Vm) MustDeleteProtected() bool {
	if p.deleteProtected == nil {
		panic("the deleteProtected must not be nil, please use DeleteProtected() function instead")
	}
	return *p.deleteProtected
}

func (p *Vm) SetDescription(attr string) {
	p.description = &attr
}

func (p *Vm) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *Vm) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *Vm) SetDiskAttachments(attr *DiskAttachmentSlice) {
	p.diskAttachments = attr
}

func (p *Vm) DiskAttachments() (*DiskAttachmentSlice, bool) {
	if p.diskAttachments != nil {
		return p.diskAttachments, true
	}
	return nil, false
}

func (p *Vm) MustDiskAttachments() *DiskAttachmentSlice {
	if p.diskAttachments == nil {
		panic("the diskAttachments must not be nil, please use DiskAttachments() function instead")
	}
	return p.diskAttachments
}

// SetDisplay Represents a graphic console configuration.
func (p *Vm) SetDisplay(attr *Display) {
	p.display = attr
}

// Display Represents a graphic console configuration.
func (p *Vm) Display() (*Display, bool) {
	if p.display != nil {
		return p.display, true
	}
	return nil, false
}

// MustDisplay Represents a graphic console configuration.
func (p *Vm) MustDisplay() *Display {
	if p.display == nil {
		panic("the display must not be nil, please use Display() function instead")
	}
	return p.display
}

// SetDomain This type represents a directory service domain.
func (p *Vm) SetDomain(attr *Domain) {
	p.domain = attr
}

// Domain This type represents a directory service domain.
func (p *Vm) Domain() (*Domain, bool) {
	if p.domain != nil {
		return p.domain, true
	}
	return nil, false
}

// MustDomain This type represents a directory service domain.
func (p *Vm) MustDomain() *Domain {
	if p.domain == nil {
		panic("the domain must not be nil, please use Domain() function instead")
	}
	return p.domain
}

// SetExternalHostProvider Represents an external host provider,
// such as Foreman or Satellite.
//
// See https://www.theforeman.org/ for more details on Foreman.
// See https://access.redhat.com/products/red-hat-satellite
// for more details on Red Hat Satellite.
func (p *Vm) SetExternalHostProvider(attr *ExternalHostProvider) {
	p.externalHostProvider = attr
}

// ExternalHostProvider Represents an external host provider,
// such as Foreman or Satellite.
//
// See https://www.theforeman.org/ for more details on Foreman.
// See https://access.redhat.com/products/red-hat-satellite
// for more details on Red Hat Satellite.
func (p *Vm) ExternalHostProvider() (*ExternalHostProvider, bool) {
	if p.externalHostProvider != nil {
		return p.externalHostProvider, true
	}
	return nil, false
}

// MustExternalHostProvider Represents an external host provider,
// such as Foreman or Satellite.
//
// See https://www.theforeman.org/ for more details on Foreman.
// See https://access.redhat.com/products/red-hat-satellite
// for more details on Red Hat Satellite.
func (p *Vm) MustExternalHostProvider() *ExternalHostProvider {
	if p.externalHostProvider == nil {
		panic("the externalHostProvider must not be nil, please use ExternalHostProvider() function instead")
	}
	return p.externalHostProvider
}

func (p *Vm) SetFloppies(attr *FloppySlice) {
	p.floppies = attr
}

func (p *Vm) Floppies() (*FloppySlice, bool) {
	if p.floppies != nil {
		return p.floppies, true
	}
	return nil, false
}

func (p *Vm) MustFloppies() *FloppySlice {
	if p.floppies == nil {
		panic("the floppies must not be nil, please use Floppies() function instead")
	}
	return p.floppies
}

func (p *Vm) SetFqdn(attr string) {
	p.fqdn = &attr
}

func (p *Vm) Fqdn() (string, bool) {
	if p.fqdn != nil {
		return *p.fqdn, true
	}
	var zero string
	return zero, false
}

func (p *Vm) MustFqdn() string {
	if p.fqdn == nil {
		panic("the fqdn must not be nil, please use Fqdn() function instead")
	}
	return *p.fqdn
}

func (p *Vm) SetGraphicsConsoles(attr *GraphicsConsoleSlice) {
	p.graphicsConsoles = attr
}

func (p *Vm) GraphicsConsoles() (*GraphicsConsoleSlice, bool) {
	if p.graphicsConsoles != nil {
		return p.graphicsConsoles, true
	}
	return nil, false
}

func (p *Vm) MustGraphicsConsoles() *GraphicsConsoleSlice {
	if p.graphicsConsoles == nil {
		panic("the graphicsConsoles must not be nil, please use GraphicsConsoles() function instead")
	}
	return p.graphicsConsoles
}

// SetGuestOperatingSystem Represents an operating system installed on the virtual machine.
//
// To get that information send a request like this:
//
// ....
// GET /ovirt-engine/api/vms/123
// ....
//
// The result will be like this:
//
// [source,xml]
// ----
// <vm href="/ovirt-engine/api/vms/123" id="123">
// ...
//   <guest_operating_system>
//     <architecture>x86_64</architecture>
//     <codename>Maipo</codename>
//     <distribution>Red Hat Enterprise Linux Server</distribution>
//     <family>Linux</family>
//     <kernel>
//       <version>
//         <build>0</build>
//         <full_version>3.10.0-514.10.2.el7.x86_64</full_version>
//         <major>3</major>
//         <minor>10</minor>
//         <revision>514</revision>
//       </version>
//     </kernel>
//     <version>
//       <full_version>7.3</full_version>
//       <major>7</major>
//       <minor>3</minor>
//     </version>
//   </guest_operating_system>
// </vm>
// ----
func (p *Vm) SetGuestOperatingSystem(attr *GuestOperatingSystem) {
	p.guestOperatingSystem = attr
}

// GuestOperatingSystem Represents an operating system installed on the virtual machine.
//
// To get that information send a request like this:
//
// ....
// GET /ovirt-engine/api/vms/123
// ....
//
// The result will be like this:
//
// [source,xml]
// ----
// <vm href="/ovirt-engine/api/vms/123" id="123">
// ...
//   <guest_operating_system>
//     <architecture>x86_64</architecture>
//     <codename>Maipo</codename>
//     <distribution>Red Hat Enterprise Linux Server</distribution>
//     <family>Linux</family>
//     <kernel>
//       <version>
//         <build>0</build>
//         <full_version>3.10.0-514.10.2.el7.x86_64</full_version>
//         <major>3</major>
//         <minor>10</minor>
//         <revision>514</revision>
//       </version>
//     </kernel>
//     <version>
//       <full_version>7.3</full_version>
//       <major>7</major>
//       <minor>3</minor>
//     </version>
//   </guest_operating_system>
// </vm>
// ----
func (p *Vm) GuestOperatingSystem() (*GuestOperatingSystem, bool) {
	if p.guestOperatingSystem != nil {
		return p.guestOperatingSystem, true
	}
	return nil, false
}

// MustGuestOperatingSystem Represents an operating system installed on the virtual machine.
//
// To get that information send a request like this:
//
// ....
// GET /ovirt-engine/api/vms/123
// ....
//
// The result will be like this:
//
// [source,xml]
// ----
// <vm href="/ovirt-engine/api/vms/123" id="123">
// ...
//   <guest_operating_system>
//     <architecture>x86_64</architecture>
//     <codename>Maipo</codename>
//     <distribution>Red Hat Enterprise Linux Server</distribution>
//     <family>Linux</family>
//     <kernel>
//       <version>
//         <build>0</build>
//         <full_version>3.10.0-514.10.2.el7.x86_64</full_version>
//         <major>3</major>
//         <minor>10</minor>
//         <revision>514</revision>
//       </version>
//     </kernel>
//     <version>
//       <full_version>7.3</full_version>
//       <major>7</major>
//       <minor>3</minor>
//     </version>
//   </guest_operating_system>
// </vm>
// ----
func (p *Vm) MustGuestOperatingSystem() *GuestOperatingSystem {
	if p.guestOperatingSystem == nil {
		panic("the guestOperatingSystem must not be nil, please use GuestOperatingSystem() function instead")
	}
	return p.guestOperatingSystem
}

// SetGuestTimeZone Time zone representation.
func (p *Vm) SetGuestTimeZone(attr *TimeZone) {
	p.guestTimeZone = attr
}

// GuestTimeZone Time zone representation.
func (p *Vm) GuestTimeZone() (*TimeZone, bool) {
	if p.guestTimeZone != nil {
		return p.guestTimeZone, true
	}
	return nil, false
}

// MustGuestTimeZone Time zone representation.
func (p *Vm) MustGuestTimeZone() *TimeZone {
	if p.guestTimeZone == nil {
		panic("the guestTimeZone must not be nil, please use GuestTimeZone() function instead")
	}
	return p.guestTimeZone
}

func (p *Vm) SetHasIllegalImages(attr bool) {
	p.hasIllegalImages = &attr
}

func (p *Vm) HasIllegalImages() (bool, bool) {
	if p.hasIllegalImages != nil {
		return *p.hasIllegalImages, true
	}
	var zero bool
	return zero, false
}

func (p *Vm) MustHasIllegalImages() bool {
	if p.hasIllegalImages == nil {
		panic("the hasIllegalImages must not be nil, please use HasIllegalImages() function instead")
	}
	return *p.hasIllegalImages
}

// SetHighAvailability Type representing high availability of a virtual machine.
func (p *Vm) SetHighAvailability(attr *HighAvailability) {
	p.highAvailability = attr
}

// HighAvailability Type representing high availability of a virtual machine.
func (p *Vm) HighAvailability() (*HighAvailability, bool) {
	if p.highAvailability != nil {
		return p.highAvailability, true
	}
	return nil, false
}

// MustHighAvailability Type representing high availability of a virtual machine.
func (p *Vm) MustHighAvailability() *HighAvailability {
	if p.highAvailability == nil {
		panic("the highAvailability must not be nil, please use HighAvailability() function instead")
	}
	return p.highAvailability
}

// SetHost Type representing a host.
func (p *Vm) SetHost(attr *Host) {
	p.host = attr
}

// Host Type representing a host.
func (p *Vm) Host() (*Host, bool) {
	if p.host != nil {
		return p.host, true
	}
	return nil, false
}

// MustHost Type representing a host.
func (p *Vm) MustHost() *Host {
	if p.host == nil {
		panic("the host must not be nil, please use Host() function instead")
	}
	return p.host
}

func (p *Vm) SetHostDevices(attr *HostDeviceSlice) {
	p.hostDevices = attr
}

func (p *Vm) HostDevices() (*HostDeviceSlice, bool) {
	if p.hostDevices != nil {
		return p.hostDevices, true
	}
	return nil, false
}

func (p *Vm) MustHostDevices() *HostDeviceSlice {
	if p.hostDevices == nil {
		panic("the hostDevices must not be nil, please use HostDevices() function instead")
	}
	return p.hostDevices
}

func (p *Vm) SetId(attr string) {
	p.id = &attr
}

func (p *Vm) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *Vm) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *Vm) SetInitialization(attr *Initialization) {
	p.initialization = attr
}

func (p *Vm) Initialization() (*Initialization, bool) {
	if p.initialization != nil {
		return p.initialization, true
	}
	return nil, false
}

func (p *Vm) MustInitialization() *Initialization {
	if p.initialization == nil {
		panic("the initialization must not be nil, please use Initialization() function instead")
	}
	return p.initialization
}

// SetInstanceType Describes the hardware configuration of virtual machines.
//
// For example `medium` instance type includes 1 virtual CPU and 4 GiB of memory. It is a top-level
// entity (e.g. not bound to any data center or cluster). The attributes that are used for instance
// types and are common to virtual machine and template types are:
//
// - `console`
// - `cpu`
// - `custom_cpu_model`
// - `custom_emulated_machine`
// - `display`
// - `high_availability`
// - `io`
// - `memory`
// - `memory_policy`
// - `migration`
// - `migration_downtime`
// - `os`
// - `rng_device`
// - `soundcard_enabled`
// - `usb`
// - `virtio_scsi`
//
// When creating a virtual machine from both an instance type and a template, the virtual machine
// will inherit the hardware configurations from the instance type
//
// NOTE: An instance type inherits it's attributes from the template entity although most template
// attributes are not used in instance types.
func (p *Vm) SetInstanceType(attr *InstanceType) {
	p.instanceType = attr
}

// InstanceType Describes the hardware configuration of virtual machines.
//
// For example `medium` instance type includes 1 virtual CPU and 4 GiB of memory. It is a top-level
// entity (e.g. not bound to any data center or cluster). The attributes that are used for instance
// types and are common to virtual machine and template types are:
//
// - `console`
// - `cpu`
// - `custom_cpu_model`
// - `custom_emulated_machine`
// - `display`
// - `high_availability`
// - `io`
// - `memory`
// - `memory_policy`
// - `migration`
// - `migration_downtime`
// - `os`
// - `rng_device`
// - `soundcard_enabled`
// - `usb`
// - `virtio_scsi`
//
// When creating a virtual machine from both an instance type and a template, the virtual machine
// will inherit the hardware configurations from the instance type
//
// NOTE: An instance type inherits it's attributes from the template entity although most template
// attributes are not used in instance types.
func (p *Vm) InstanceType() (*InstanceType, bool) {
	if p.instanceType != nil {
		return p.instanceType, true
	}
	return nil, false
}

// MustInstanceType Describes the hardware configuration of virtual machines.
//
// For example `medium` instance type includes 1 virtual CPU and 4 GiB of memory. It is a top-level
// entity (e.g. not bound to any data center or cluster). The attributes that are used for instance
// types and are common to virtual machine and template types are:
//
// - `console`
// - `cpu`
// - `custom_cpu_model`
// - `custom_emulated_machine`
// - `display`
// - `high_availability`
// - `io`
// - `memory`
// - `memory_policy`
// - `migration`
// - `migration_downtime`
// - `os`
// - `rng_device`
// - `soundcard_enabled`
// - `usb`
// - `virtio_scsi`
//
// When creating a virtual machine from both an instance type and a template, the virtual machine
// will inherit the hardware configurations from the instance type
//
// NOTE: An instance type inherits it's attributes from the template entity although most template
// attributes are not used in instance types.
func (p *Vm) MustInstanceType() *InstanceType {
	if p.instanceType == nil {
		panic("the instanceType must not be nil, please use InstanceType() function instead")
	}
	return p.instanceType
}

func (p *Vm) SetIo(attr *Io) {
	p.io = attr
}

func (p *Vm) Io() (*Io, bool) {
	if p.io != nil {
		return p.io, true
	}
	return nil, false
}

func (p *Vm) MustIo() *Io {
	if p.io == nil {
		panic("the io must not be nil, please use Io() function instead")
	}
	return p.io
}

func (p *Vm) SetKatelloErrata(attr *KatelloErratumSlice) {
	p.katelloErrata = attr
}

func (p *Vm) KatelloErrata() (*KatelloErratumSlice, bool) {
	if p.katelloErrata != nil {
		return p.katelloErrata, true
	}
	return nil, false
}

func (p *Vm) MustKatelloErrata() *KatelloErratumSlice {
	if p.katelloErrata == nil {
		panic("the katelloErrata must not be nil, please use KatelloErrata() function instead")
	}
	return p.katelloErrata
}

// SetLargeIcon Icon of virtual machine or template.
func (p *Vm) SetLargeIcon(attr *Icon) {
	p.largeIcon = attr
}

// LargeIcon Icon of virtual machine or template.
func (p *Vm) LargeIcon() (*Icon, bool) {
	if p.largeIcon != nil {
		return p.largeIcon, true
	}
	return nil, false
}

// MustLargeIcon Icon of virtual machine or template.
func (p *Vm) MustLargeIcon() *Icon {
	if p.largeIcon == nil {
		panic("the largeIcon must not be nil, please use LargeIcon() function instead")
	}
	return p.largeIcon
}

// SetLease Represents a lease residing on a storage domain.
//
// A lease is a http://www.ovirt.org/develop/developer-guide/vdsm/sanlock[Sanlock] resource residing on a special
// volume on the storage domain, this Sanlock resource is used to provide storage base locking.
func (p *Vm) SetLease(attr *StorageDomainLease) {
	p.lease = attr
}

// Lease Represents a lease residing on a storage domain.
//
// A lease is a http://www.ovirt.org/develop/developer-guide/vdsm/sanlock[Sanlock] resource residing on a special
// volume on the storage domain, this Sanlock resource is used to provide storage base locking.
func (p *Vm) Lease() (*StorageDomainLease, bool) {
	if p.lease != nil {
		return p.lease, true
	}
	return nil, false
}

// MustLease Represents a lease residing on a storage domain.
//
// A lease is a http://www.ovirt.org/develop/developer-guide/vdsm/sanlock[Sanlock] resource residing on a special
// volume on the storage domain, this Sanlock resource is used to provide storage base locking.
func (p *Vm) MustLease() *StorageDomainLease {
	if p.lease == nil {
		panic("the lease must not be nil, please use Lease() function instead")
	}
	return p.lease
}

func (p *Vm) SetMemory(attr int64) {
	p.memory = &attr
}

func (p *Vm) Memory() (int64, bool) {
	if p.memory != nil {
		return *p.memory, true
	}
	var zero int64
	return zero, false
}

func (p *Vm) MustMemory() int64 {
	if p.memory == nil {
		panic("the memory must not be nil, please use Memory() function instead")
	}
	return *p.memory
}

// SetMemoryPolicy Logical grouping of memory-related properties of virtual machine-like entities.
func (p *Vm) SetMemoryPolicy(attr *MemoryPolicy) {
	p.memoryPolicy = attr
}

// MemoryPolicy Logical grouping of memory-related properties of virtual machine-like entities.
func (p *Vm) MemoryPolicy() (*MemoryPolicy, bool) {
	if p.memoryPolicy != nil {
		return p.memoryPolicy, true
	}
	return nil, false
}

// MustMemoryPolicy Logical grouping of memory-related properties of virtual machine-like entities.
func (p *Vm) MustMemoryPolicy() *MemoryPolicy {
	if p.memoryPolicy == nil {
		panic("the memoryPolicy must not be nil, please use MemoryPolicy() function instead")
	}
	return p.memoryPolicy
}

// SetMigration The type for migration options.
func (p *Vm) SetMigration(attr *MigrationOptions) {
	p.migration = attr
}

// Migration The type for migration options.
func (p *Vm) Migration() (*MigrationOptions, bool) {
	if p.migration != nil {
		return p.migration, true
	}
	return nil, false
}

// MustMigration The type for migration options.
func (p *Vm) MustMigration() *MigrationOptions {
	if p.migration == nil {
		panic("the migration must not be nil, please use Migration() function instead")
	}
	return p.migration
}

func (p *Vm) SetMigrationDowntime(attr int64) {
	p.migrationDowntime = &attr
}

func (p *Vm) MigrationDowntime() (int64, bool) {
	if p.migrationDowntime != nil {
		return *p.migrationDowntime, true
	}
	var zero int64
	return zero, false
}

func (p *Vm) MustMigrationDowntime() int64 {
	if p.migrationDowntime == nil {
		panic("the migrationDowntime must not be nil, please use MigrationDowntime() function instead")
	}
	return *p.migrationDowntime
}

func (p *Vm) SetMultiQueuesEnabled(attr bool) {
	p.multiQueuesEnabled = &attr
}

func (p *Vm) MultiQueuesEnabled() (bool, bool) {
	if p.multiQueuesEnabled != nil {
		return *p.multiQueuesEnabled, true
	}
	var zero bool
	return zero, false
}

func (p *Vm) MustMultiQueuesEnabled() bool {
	if p.multiQueuesEnabled == nil {
		panic("the multiQueuesEnabled must not be nil, please use MultiQueuesEnabled() function instead")
	}
	return *p.multiQueuesEnabled
}

func (p *Vm) SetName(attr string) {
	p.name = &attr
}

func (p *Vm) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *Vm) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *Vm) SetNextRunConfigurationExists(attr bool) {
	p.nextRunConfigurationExists = &attr
}

func (p *Vm) NextRunConfigurationExists() (bool, bool) {
	if p.nextRunConfigurationExists != nil {
		return *p.nextRunConfigurationExists, true
	}
	var zero bool
	return zero, false
}

func (p *Vm) MustNextRunConfigurationExists() bool {
	if p.nextRunConfigurationExists == nil {
		panic("the nextRunConfigurationExists must not be nil, please use NextRunConfigurationExists() function instead")
	}
	return *p.nextRunConfigurationExists
}

func (p *Vm) SetNics(attr *NicSlice) {
	p.nics = attr
}

func (p *Vm) Nics() (*NicSlice, bool) {
	if p.nics != nil {
		return p.nics, true
	}
	return nil, false
}

func (p *Vm) MustNics() *NicSlice {
	if p.nics == nil {
		panic("the nics must not be nil, please use Nics() function instead")
	}
	return p.nics
}

func (p *Vm) SetNumaNodes(attr *NumaNodeSlice) {
	p.numaNodes = attr
}

func (p *Vm) NumaNodes() (*NumaNodeSlice, bool) {
	if p.numaNodes != nil {
		return p.numaNodes, true
	}
	return nil, false
}

func (p *Vm) MustNumaNodes() *NumaNodeSlice {
	if p.numaNodes == nil {
		panic("the numaNodes must not be nil, please use NumaNodes() function instead")
	}
	return p.numaNodes
}

func (p *Vm) SetNumaTuneMode(attr NumaTuneMode) {
	p.numaTuneMode = &attr
}

func (p *Vm) NumaTuneMode() (NumaTuneMode, bool) {
	if p.numaTuneMode != nil {
		return *p.numaTuneMode, true
	}
	var zero NumaTuneMode
	return zero, false
}

func (p *Vm) MustNumaTuneMode() NumaTuneMode {
	if p.numaTuneMode == nil {
		panic("the numaTuneMode must not be nil, please use NumaTuneMode() function instead")
	}
	return *p.numaTuneMode
}

func (p *Vm) SetOrigin(attr string) {
	p.origin = &attr
}

func (p *Vm) Origin() (string, bool) {
	if p.origin != nil {
		return *p.origin, true
	}
	var zero string
	return zero, false
}

func (p *Vm) MustOrigin() string {
	if p.origin == nil {
		panic("the origin must not be nil, please use Origin() function instead")
	}
	return *p.origin
}

// SetOriginalTemplate The type that represents a virtual machine template.
// Templates allow for a rapid instantiation of virtual machines with common configuration and disk states.
func (p *Vm) SetOriginalTemplate(attr *Template) {
	p.originalTemplate = attr
}

// OriginalTemplate The type that represents a virtual machine template.
// Templates allow for a rapid instantiation of virtual machines with common configuration and disk states.
func (p *Vm) OriginalTemplate() (*Template, bool) {
	if p.originalTemplate != nil {
		return p.originalTemplate, true
	}
	return nil, false
}

// MustOriginalTemplate The type that represents a virtual machine template.
// Templates allow for a rapid instantiation of virtual machines with common configuration and disk states.
func (p *Vm) MustOriginalTemplate() *Template {
	if p.originalTemplate == nil {
		panic("the originalTemplate must not be nil, please use OriginalTemplate() function instead")
	}
	return p.originalTemplate
}

// SetOs Information describing the operating system. This is used for both virtual machines and hosts.
func (p *Vm) SetOs(attr *OperatingSystem) {
	p.os = attr
}

// Os Information describing the operating system. This is used for both virtual machines and hosts.
func (p *Vm) Os() (*OperatingSystem, bool) {
	if p.os != nil {
		return p.os, true
	}
	return nil, false
}

// MustOs Information describing the operating system. This is used for both virtual machines and hosts.
func (p *Vm) MustOs() *OperatingSystem {
	if p.os == nil {
		panic("the os must not be nil, please use Os() function instead")
	}
	return p.os
}

func (p *Vm) SetPayloads(attr *PayloadSlice) {
	p.payloads = attr
}

func (p *Vm) Payloads() (*PayloadSlice, bool) {
	if p.payloads != nil {
		return p.payloads, true
	}
	return nil, false
}

func (p *Vm) MustPayloads() *PayloadSlice {
	if p.payloads == nil {
		panic("the payloads must not be nil, please use Payloads() function instead")
	}
	return p.payloads
}

func (p *Vm) SetPermissions(attr *PermissionSlice) {
	p.permissions = attr
}

func (p *Vm) Permissions() (*PermissionSlice, bool) {
	if p.permissions != nil {
		return p.permissions, true
	}
	return nil, false
}

func (p *Vm) MustPermissions() *PermissionSlice {
	if p.permissions == nil {
		panic("the permissions must not be nil, please use Permissions() function instead")
	}
	return p.permissions
}

func (p *Vm) SetPlacementPolicy(attr *VmPlacementPolicy) {
	p.placementPolicy = attr
}

func (p *Vm) PlacementPolicy() (*VmPlacementPolicy, bool) {
	if p.placementPolicy != nil {
		return p.placementPolicy, true
	}
	return nil, false
}

func (p *Vm) MustPlacementPolicy() *VmPlacementPolicy {
	if p.placementPolicy == nil {
		panic("the placementPolicy must not be nil, please use PlacementPolicy() function instead")
	}
	return p.placementPolicy
}

// SetQuota Represents a quota object.
//
// An example XML representation of a quota:
//
// [source,xml]
// ----
// <quota href="/ovirt-engine/api/datacenters/7044934e/quotas/dcad5ddc" id="dcad5ddc">
//   <name>My Quota</name>
//   <description>A quota for my oVirt environment</description>
//   <cluster_hard_limit_pct>0</cluster_hard_limit_pct>
//   <cluster_soft_limit_pct>0</cluster_soft_limit_pct>
//   <data_center href="/ovirt-engine/api/datacenters/7044934e" id="7044934e"/>
//   <storage_hard_limit_pct>0</storage_hard_limit_pct>
//   <storage_soft_limit_pct>0</storage_soft_limit_pct>
// </quota>
// ----
func (p *Vm) SetQuota(attr *Quota) {
	p.quota = attr
}

// Quota Represents a quota object.
//
// An example XML representation of a quota:
//
// [source,xml]
// ----
// <quota href="/ovirt-engine/api/datacenters/7044934e/quotas/dcad5ddc" id="dcad5ddc">
//   <name>My Quota</name>
//   <description>A quota for my oVirt environment</description>
//   <cluster_hard_limit_pct>0</cluster_hard_limit_pct>
//   <cluster_soft_limit_pct>0</cluster_soft_limit_pct>
//   <data_center href="/ovirt-engine/api/datacenters/7044934e" id="7044934e"/>
//   <storage_hard_limit_pct>0</storage_hard_limit_pct>
//   <storage_soft_limit_pct>0</storage_soft_limit_pct>
// </quota>
// ----
func (p *Vm) Quota() (*Quota, bool) {
	if p.quota != nil {
		return p.quota, true
	}
	return nil, false
}

// MustQuota Represents a quota object.
//
// An example XML representation of a quota:
//
// [source,xml]
// ----
// <quota href="/ovirt-engine/api/datacenters/7044934e/quotas/dcad5ddc" id="dcad5ddc">
//   <name>My Quota</name>
//   <description>A quota for my oVirt environment</description>
//   <cluster_hard_limit_pct>0</cluster_hard_limit_pct>
//   <cluster_soft_limit_pct>0</cluster_soft_limit_pct>
//   <data_center href="/ovirt-engine/api/datacenters/7044934e" id="7044934e"/>
//   <storage_hard_limit_pct>0</storage_hard_limit_pct>
//   <storage_soft_limit_pct>0</storage_soft_limit_pct>
// </quota>
// ----
func (p *Vm) MustQuota() *Quota {
	if p.quota == nil {
		panic("the quota must not be nil, please use Quota() function instead")
	}
	return p.quota
}

func (p *Vm) SetReportedDevices(attr *ReportedDeviceSlice) {
	p.reportedDevices = attr
}

func (p *Vm) ReportedDevices() (*ReportedDeviceSlice, bool) {
	if p.reportedDevices != nil {
		return p.reportedDevices, true
	}
	return nil, false
}

func (p *Vm) MustReportedDevices() *ReportedDeviceSlice {
	if p.reportedDevices == nil {
		panic("the reportedDevices must not be nil, please use ReportedDevices() function instead")
	}
	return p.reportedDevices
}

// SetRngDevice Random number generator (RNG) device model.
func (p *Vm) SetRngDevice(attr *RngDevice) {
	p.rngDevice = attr
}

// RngDevice Random number generator (RNG) device model.
func (p *Vm) RngDevice() (*RngDevice, bool) {
	if p.rngDevice != nil {
		return p.rngDevice, true
	}
	return nil, false
}

// MustRngDevice Random number generator (RNG) device model.
func (p *Vm) MustRngDevice() *RngDevice {
	if p.rngDevice == nil {
		panic("the rngDevice must not be nil, please use RngDevice() function instead")
	}
	return p.rngDevice
}

func (p *Vm) SetRunOnce(attr bool) {
	p.runOnce = &attr
}

func (p *Vm) RunOnce() (bool, bool) {
	if p.runOnce != nil {
		return *p.runOnce, true
	}
	var zero bool
	return zero, false
}

func (p *Vm) MustRunOnce() bool {
	if p.runOnce == nil {
		panic("the runOnce must not be nil, please use RunOnce() function instead")
	}
	return *p.runOnce
}

func (p *Vm) SetSerialNumber(attr *SerialNumber) {
	p.serialNumber = attr
}

func (p *Vm) SerialNumber() (*SerialNumber, bool) {
	if p.serialNumber != nil {
		return p.serialNumber, true
	}
	return nil, false
}

func (p *Vm) MustSerialNumber() *SerialNumber {
	if p.serialNumber == nil {
		panic("the serialNumber must not be nil, please use SerialNumber() function instead")
	}
	return p.serialNumber
}

func (p *Vm) SetSessions(attr *SessionSlice) {
	p.sessions = attr
}

func (p *Vm) Sessions() (*SessionSlice, bool) {
	if p.sessions != nil {
		return p.sessions, true
	}
	return nil, false
}

func (p *Vm) MustSessions() *SessionSlice {
	if p.sessions == nil {
		panic("the sessions must not be nil, please use Sessions() function instead")
	}
	return p.sessions
}

// SetSmallIcon Icon of virtual machine or template.
func (p *Vm) SetSmallIcon(attr *Icon) {
	p.smallIcon = attr
}

// SmallIcon Icon of virtual machine or template.
func (p *Vm) SmallIcon() (*Icon, bool) {
	if p.smallIcon != nil {
		return p.smallIcon, true
	}
	return nil, false
}

// MustSmallIcon Icon of virtual machine or template.
func (p *Vm) MustSmallIcon() *Icon {
	if p.smallIcon == nil {
		panic("the smallIcon must not be nil, please use SmallIcon() function instead")
	}
	return p.smallIcon
}

func (p *Vm) SetSnapshots(attr *SnapshotSlice) {
	p.snapshots = attr
}

func (p *Vm) Snapshots() (*SnapshotSlice, bool) {
	if p.snapshots != nil {
		return p.snapshots, true
	}
	return nil, false
}

func (p *Vm) MustSnapshots() *SnapshotSlice {
	if p.snapshots == nil {
		panic("the snapshots must not be nil, please use Snapshots() function instead")
	}
	return p.snapshots
}

func (p *Vm) SetSoundcardEnabled(attr bool) {
	p.soundcardEnabled = &attr
}

func (p *Vm) SoundcardEnabled() (bool, bool) {
	if p.soundcardEnabled != nil {
		return *p.soundcardEnabled, true
	}
	var zero bool
	return zero, false
}

func (p *Vm) MustSoundcardEnabled() bool {
	if p.soundcardEnabled == nil {
		panic("the soundcardEnabled must not be nil, please use SoundcardEnabled() function instead")
	}
	return *p.soundcardEnabled
}

func (p *Vm) SetSso(attr *Sso) {
	p.sso = attr
}

func (p *Vm) Sso() (*Sso, bool) {
	if p.sso != nil {
		return p.sso, true
	}
	return nil, false
}

func (p *Vm) MustSso() *Sso {
	if p.sso == nil {
		panic("the sso must not be nil, please use Sso() function instead")
	}
	return p.sso
}

func (p *Vm) SetStartPaused(attr bool) {
	p.startPaused = &attr
}

func (p *Vm) StartPaused() (bool, bool) {
	if p.startPaused != nil {
		return *p.startPaused, true
	}
	var zero bool
	return zero, false
}

func (p *Vm) MustStartPaused() bool {
	if p.startPaused == nil {
		panic("the startPaused must not be nil, please use StartPaused() function instead")
	}
	return *p.startPaused
}

func (p *Vm) SetStartTime(attr time.Time) {
	p.startTime = &attr
}

func (p *Vm) StartTime() (time.Time, bool) {
	if p.startTime != nil {
		return *p.startTime, true
	}
	var zero time.Time
	return zero, false
}

func (p *Vm) MustStartTime() time.Time {
	if p.startTime == nil {
		panic("the startTime must not be nil, please use StartTime() function instead")
	}
	return *p.startTime
}

func (p *Vm) SetStateless(attr bool) {
	p.stateless = &attr
}

func (p *Vm) Stateless() (bool, bool) {
	if p.stateless != nil {
		return *p.stateless, true
	}
	var zero bool
	return zero, false
}

func (p *Vm) MustStateless() bool {
	if p.stateless == nil {
		panic("the stateless must not be nil, please use Stateless() function instead")
	}
	return *p.stateless
}

func (p *Vm) SetStatistics(attr *StatisticSlice) {
	p.statistics = attr
}

func (p *Vm) Statistics() (*StatisticSlice, bool) {
	if p.statistics != nil {
		return p.statistics, true
	}
	return nil, false
}

func (p *Vm) MustStatistics() *StatisticSlice {
	if p.statistics == nil {
		panic("the statistics must not be nil, please use Statistics() function instead")
	}
	return p.statistics
}

// SetStatus Type represeting a status of a virtual machine.
func (p *Vm) SetStatus(attr VmStatus) {
	p.status = &attr
}

// Status Type represeting a status of a virtual machine.
func (p *Vm) Status() (VmStatus, bool) {
	if p.status != nil {
		return *p.status, true
	}
	var zero VmStatus
	return zero, false
}

// MustStatus Type represeting a status of a virtual machine.
func (p *Vm) MustStatus() VmStatus {
	if p.status == nil {
		panic("the status must not be nil, please use Status() function instead")
	}
	return *p.status
}

func (p *Vm) SetStatusDetail(attr string) {
	p.statusDetail = &attr
}

func (p *Vm) StatusDetail() (string, bool) {
	if p.statusDetail != nil {
		return *p.statusDetail, true
	}
	var zero string
	return zero, false
}

func (p *Vm) MustStatusDetail() string {
	if p.statusDetail == nil {
		panic("the statusDetail must not be nil, please use StatusDetail() function instead")
	}
	return *p.statusDetail
}

func (p *Vm) SetStopReason(attr string) {
	p.stopReason = &attr
}

func (p *Vm) StopReason() (string, bool) {
	if p.stopReason != nil {
		return *p.stopReason, true
	}
	var zero string
	return zero, false
}

func (p *Vm) MustStopReason() string {
	if p.stopReason == nil {
		panic("the stopReason must not be nil, please use StopReason() function instead")
	}
	return *p.stopReason
}

func (p *Vm) SetStopTime(attr time.Time) {
	p.stopTime = &attr
}

func (p *Vm) StopTime() (time.Time, bool) {
	if p.stopTime != nil {
		return *p.stopTime, true
	}
	var zero time.Time
	return zero, false
}

func (p *Vm) MustStopTime() time.Time {
	if p.stopTime == nil {
		panic("the stopTime must not be nil, please use StopTime() function instead")
	}
	return *p.stopTime
}

// SetStorageDomain Storage domain.
//
// An XML representation of a NFS storage domain with identifier `123`:
//
// [source,xml]
// ----
// <storage_domain href="/ovirt-engine/api/storagedomains/123" id="123">
//   <name>mydata</name>
//   <description>My data</description>
//   <available>38654705664</available>
//   <committed>1073741824</committed>
//   <critical_space_action_blocker>5</critical_space_action_blocker>
//   <external_status>ok</external_status>
//   <master>true</master>
//   <storage>
//     <address>mynfs.example.com</address>
//     <nfs_version>v3</nfs_version>
//     <path>/exports/mydata</path>
//     <type>nfs</type>
//   </storage>
//   <storage_format>v3</storage_format>
//   <type>data</type>
//   <used>13958643712</used>
//   <warning_low_space_indicator>10</warning_low_space_indicator>
//   <wipe_after_delete>false</wipe_after_delete>
//   <data_centers>
//     <data_center href="/ovirt-engine/api/datacenters/456" id="456"/>
//   </data_centers>
// </storage_domain>
// ----
func (p *Vm) SetStorageDomain(attr *StorageDomain) {
	p.storageDomain = attr
}

// StorageDomain Storage domain.
//
// An XML representation of a NFS storage domain with identifier `123`:
//
// [source,xml]
// ----
// <storage_domain href="/ovirt-engine/api/storagedomains/123" id="123">
//   <name>mydata</name>
//   <description>My data</description>
//   <available>38654705664</available>
//   <committed>1073741824</committed>
//   <critical_space_action_blocker>5</critical_space_action_blocker>
//   <external_status>ok</external_status>
//   <master>true</master>
//   <storage>
//     <address>mynfs.example.com</address>
//     <nfs_version>v3</nfs_version>
//     <path>/exports/mydata</path>
//     <type>nfs</type>
//   </storage>
//   <storage_format>v3</storage_format>
//   <type>data</type>
//   <used>13958643712</used>
//   <warning_low_space_indicator>10</warning_low_space_indicator>
//   <wipe_after_delete>false</wipe_after_delete>
//   <data_centers>
//     <data_center href="/ovirt-engine/api/datacenters/456" id="456"/>
//   </data_centers>
// </storage_domain>
// ----
func (p *Vm) StorageDomain() (*StorageDomain, bool) {
	if p.storageDomain != nil {
		return p.storageDomain, true
	}
	return nil, false
}

// MustStorageDomain Storage domain.
//
// An XML representation of a NFS storage domain with identifier `123`:
//
// [source,xml]
// ----
// <storage_domain href="/ovirt-engine/api/storagedomains/123" id="123">
//   <name>mydata</name>
//   <description>My data</description>
//   <available>38654705664</available>
//   <committed>1073741824</committed>
//   <critical_space_action_blocker>5</critical_space_action_blocker>
//   <external_status>ok</external_status>
//   <master>true</master>
//   <storage>
//     <address>mynfs.example.com</address>
//     <nfs_version>v3</nfs_version>
//     <path>/exports/mydata</path>
//     <type>nfs</type>
//   </storage>
//   <storage_format>v3</storage_format>
//   <type>data</type>
//   <used>13958643712</used>
//   <warning_low_space_indicator>10</warning_low_space_indicator>
//   <wipe_after_delete>false</wipe_after_delete>
//   <data_centers>
//     <data_center href="/ovirt-engine/api/datacenters/456" id="456"/>
//   </data_centers>
// </storage_domain>
// ----
func (p *Vm) MustStorageDomain() *StorageDomain {
	if p.storageDomain == nil {
		panic("the storageDomain must not be nil, please use StorageDomain() function instead")
	}
	return p.storageDomain
}

// SetStorageErrorResumeBehaviour If the storage, on which this virtual machine has some disks gets
// unresponsive, the virtual machine gets paused.
//
// This are the possible options, what should happen with the virtual machine
// in the moment the storage gets available again.
func (p *Vm) SetStorageErrorResumeBehaviour(attr VmStorageErrorResumeBehaviour) {
	p.storageErrorResumeBehaviour = &attr
}

// StorageErrorResumeBehaviour If the storage, on which this virtual machine has some disks gets
// unresponsive, the virtual machine gets paused.
//
// This are the possible options, what should happen with the virtual machine
// in the moment the storage gets available again.
func (p *Vm) StorageErrorResumeBehaviour() (VmStorageErrorResumeBehaviour, bool) {
	if p.storageErrorResumeBehaviour != nil {
		return *p.storageErrorResumeBehaviour, true
	}
	var zero VmStorageErrorResumeBehaviour
	return zero, false
}

// MustStorageErrorResumeBehaviour If the storage, on which this virtual machine has some disks gets
// unresponsive, the virtual machine gets paused.
//
// This are the possible options, what should happen with the virtual machine
// in the moment the storage gets available again.
func (p *Vm) MustStorageErrorResumeBehaviour() VmStorageErrorResumeBehaviour {
	if p.storageErrorResumeBehaviour == nil {
		panic("the storageErrorResumeBehaviour must not be nil, please use StorageErrorResumeBehaviour() function instead")
	}
	return *p.storageErrorResumeBehaviour
}

func (p *Vm) SetTags(attr *TagSlice) {
	p.tags = attr
}

func (p *Vm) Tags() (*TagSlice, bool) {
	if p.tags != nil {
		return p.tags, true
	}
	return nil, false
}

func (p *Vm) MustTags() *TagSlice {
	if p.tags == nil {
		panic("the tags must not be nil, please use Tags() function instead")
	}
	return p.tags
}

// SetTemplate The type that represents a virtual machine template.
// Templates allow for a rapid instantiation of virtual machines with common configuration and disk states.
func (p *Vm) SetTemplate(attr *Template) {
	p.template = attr
}

// Template The type that represents a virtual machine template.
// Templates allow for a rapid instantiation of virtual machines with common configuration and disk states.
func (p *Vm) Template() (*Template, bool) {
	if p.template != nil {
		return p.template, true
	}
	return nil, false
}

// MustTemplate The type that represents a virtual machine template.
// Templates allow for a rapid instantiation of virtual machines with common configuration and disk states.
func (p *Vm) MustTemplate() *Template {
	if p.template == nil {
		panic("the template must not be nil, please use Template() function instead")
	}
	return p.template
}

// SetTimeZone Time zone representation.
func (p *Vm) SetTimeZone(attr *TimeZone) {
	p.timeZone = attr
}

// TimeZone Time zone representation.
func (p *Vm) TimeZone() (*TimeZone, bool) {
	if p.timeZone != nil {
		return p.timeZone, true
	}
	return nil, false
}

// MustTimeZone Time zone representation.
func (p *Vm) MustTimeZone() *TimeZone {
	if p.timeZone == nil {
		panic("the timeZone must not be nil, please use TimeZone() function instead")
	}
	return p.timeZone
}

func (p *Vm) SetTpmEnabled(attr bool) {
	p.tpmEnabled = &attr
}

func (p *Vm) TpmEnabled() (bool, bool) {
	if p.tpmEnabled != nil {
		return *p.tpmEnabled, true
	}
	var zero bool
	return zero, false
}

func (p *Vm) MustTpmEnabled() bool {
	if p.tpmEnabled == nil {
		panic("the tpmEnabled must not be nil, please use TpmEnabled() function instead")
	}
	return *p.tpmEnabled
}

func (p *Vm) SetTunnelMigration(attr bool) {
	p.tunnelMigration = &attr
}

func (p *Vm) TunnelMigration() (bool, bool) {
	if p.tunnelMigration != nil {
		return *p.tunnelMigration, true
	}
	var zero bool
	return zero, false
}

func (p *Vm) MustTunnelMigration() bool {
	if p.tunnelMigration == nil {
		panic("the tunnelMigration must not be nil, please use TunnelMigration() function instead")
	}
	return *p.tunnelMigration
}

// SetType Type representing what the virtual machine is optimized for.
func (p *Vm) SetType(attr VmType) {
	p.type_ = &attr
}

// Type Type representing what the virtual machine is optimized for.
func (p *Vm) Type() (VmType, bool) {
	if p.type_ != nil {
		return *p.type_, true
	}
	var zero VmType
	return zero, false
}

// MustType Type representing what the virtual machine is optimized for.
func (p *Vm) MustType() VmType {
	if p.type_ == nil {
		panic("the type_ must not be nil, please use Type() function instead")
	}
	return *p.type_
}

// SetUsb Configuration of the USB device of a virtual machine.
func (p *Vm) SetUsb(attr *Usb) {
	p.usb = attr
}

// Usb Configuration of the USB device of a virtual machine.
func (p *Vm) Usb() (*Usb, bool) {
	if p.usb != nil {
		return p.usb, true
	}
	return nil, false
}

// MustUsb Configuration of the USB device of a virtual machine.
func (p *Vm) MustUsb() *Usb {
	if p.usb == nil {
		panic("the usb must not be nil, please use Usb() function instead")
	}
	return p.usb
}

func (p *Vm) SetUseLatestTemplateVersion(attr bool) {
	p.useLatestTemplateVersion = &attr
}

func (p *Vm) UseLatestTemplateVersion() (bool, bool) {
	if p.useLatestTemplateVersion != nil {
		return *p.useLatestTemplateVersion, true
	}
	var zero bool
	return zero, false
}

func (p *Vm) MustUseLatestTemplateVersion() bool {
	if p.useLatestTemplateVersion == nil {
		panic("the useLatestTemplateVersion must not be nil, please use UseLatestTemplateVersion() function instead")
	}
	return *p.useLatestTemplateVersion
}

// SetVirtioScsi Type representing the support of virtio-SCSI.
// If it supported we use virtio driver for SCSI guest device.
func (p *Vm) SetVirtioScsi(attr *VirtioScsi) {
	p.virtioScsi = attr
}

// VirtioScsi Type representing the support of virtio-SCSI.
// If it supported we use virtio driver for SCSI guest device.
func (p *Vm) VirtioScsi() (*VirtioScsi, bool) {
	if p.virtioScsi != nil {
		return p.virtioScsi, true
	}
	return nil, false
}

// MustVirtioScsi Type representing the support of virtio-SCSI.
// If it supported we use virtio driver for SCSI guest device.
func (p *Vm) MustVirtioScsi() *VirtioScsi {
	if p.virtioScsi == nil {
		panic("the virtioScsi must not be nil, please use VirtioScsi() function instead")
	}
	return p.virtioScsi
}

func (p *Vm) SetVirtioScsiMultiQueuesEnabled(attr bool) {
	p.virtioScsiMultiQueuesEnabled = &attr
}

func (p *Vm) VirtioScsiMultiQueuesEnabled() (bool, bool) {
	if p.virtioScsiMultiQueuesEnabled != nil {
		return *p.virtioScsiMultiQueuesEnabled, true
	}
	var zero bool
	return zero, false
}

func (p *Vm) MustVirtioScsiMultiQueuesEnabled() bool {
	if p.virtioScsiMultiQueuesEnabled == nil {
		panic("the virtioScsiMultiQueuesEnabled must not be nil, please use VirtioScsiMultiQueuesEnabled() function instead")
	}
	return *p.virtioScsiMultiQueuesEnabled
}

// SetVmPool Type represeting a virtual machines pool.
func (p *Vm) SetVmPool(attr *VmPool) {
	p.vmPool = attr
}

// VmPool Type represeting a virtual machines pool.
func (p *Vm) VmPool() (*VmPool, bool) {
	if p.vmPool != nil {
		return p.vmPool, true
	}
	return nil, false
}

// MustVmPool Type represeting a virtual machines pool.
func (p *Vm) MustVmPool() *VmPool {
	if p.vmPool == nil {
		panic("the vmPool must not be nil, please use VmPool() function instead")
	}
	return p.vmPool
}

func (p *Vm) SetWatchdogs(attr *WatchdogSlice) {
	p.watchdogs = attr
}

func (p *Vm) Watchdogs() (*WatchdogSlice, bool) {
	if p.watchdogs != nil {
		return p.watchdogs, true
	}
	return nil, false
}

func (p *Vm) MustWatchdogs() *WatchdogSlice {
	if p.watchdogs == nil {
		panic("the watchdogs must not be nil, please use Watchdogs() function instead")
	}
	return p.watchdogs
}

// VmBase Represents basic virtual machine configuration.
// This is used by virtual machines, templates and instance types.
type VmBase struct {
	Struct
	bios                         *Bios
	cluster                      *Cluster
	comment                      *string
	console                      *Console
	cpu                          *Cpu
	cpuProfile                   *CpuProfile
	cpuShares                    *int64
	creationTime                 *time.Time
	customCompatibilityVersion   *Version
	customCpuModel               *string
	customEmulatedMachine        *string
	customProperties             *CustomPropertySlice
	deleteProtected              *bool
	description                  *string
	display                      *Display
	domain                       *Domain
	highAvailability             *HighAvailability
	id                           *string
	initialization               *Initialization
	io                           *Io
	largeIcon                    *Icon
	lease                        *StorageDomainLease
	memory                       *int64
	memoryPolicy                 *MemoryPolicy
	migration                    *MigrationOptions
	migrationDowntime            *int64
	multiQueuesEnabled           *bool
	name                         *string
	origin                       *string
	os                           *OperatingSystem
	placementPolicy              *VmPlacementPolicy
	quota                        *Quota
	rngDevice                    *RngDevice
	serialNumber                 *SerialNumber
	smallIcon                    *Icon
	soundcardEnabled             *bool
	sso                          *Sso
	startPaused                  *bool
	stateless                    *bool
	storageDomain                *StorageDomain
	storageErrorResumeBehaviour  *VmStorageErrorResumeBehaviour
	timeZone                     *TimeZone
	tpmEnabled                   *bool
	tunnelMigration              *bool
	type_                        *VmType
	usb                          *Usb
	virtioScsi                   *VirtioScsi
	virtioScsiMultiQueuesEnabled *bool
}

func (p *VmBase) SetBios(attr *Bios) {
	p.bios = attr
}

func (p *VmBase) Bios() (*Bios, bool) {
	if p.bios != nil {
		return p.bios, true
	}
	return nil, false
}

func (p *VmBase) MustBios() *Bios {
	if p.bios == nil {
		panic("the bios must not be nil, please use Bios() function instead")
	}
	return p.bios
}

// SetCluster Type representation of a cluster.
//
// A JSON representation of a cluster:
//
// [source]
// ----
// {
//   "cluster" : [ {
//     "ballooning_enabled" : "false",
//     "cpu" : {
//       "architecture" : "x86_64",
//       "type" : "Intel SandyBridge Family"
//     },
//     "custom_scheduling_policy_properties" : {
//       "property" : [ {
//         "name" : "HighUtilization",
//         "value" : "80"
//       }, {
//         "name" : "CpuOverCommitDurationMinutes",
//         "value" : "2"
//       } ]
//     },
//     "error_handling" : {
//       "on_error" : "migrate"
//     },
//     "fencing_policy" : {
//       "enabled" : "true",
//       "skip_if_connectivity_broken" : {
//         "enabled" : "false",
//         "threshold" : "50"
//       },
//       "skip_if_gluster_bricks_up" : "false",
//       "skip_if_gluster_quorum_not_met" : "false",
//       "skip_if_sd_active" : {
//         "enabled" : "false"
//       }
//     },
//     "gluster_service" : "false",
//     "firewall_type" : "iptables",
//     "ha_reservation" : "false",
//     "ksm" : {
//       "enabled" : "true",
//       "merge_across_nodes" : "true"
//     },
//     "memory_policy" : {
//       "over_commit" : {
//         "percent" : "100"
//       },
//       "transparent_hugepages" : {
//         "enabled" : "true"
//       }
//     },
//     "migration" : {
//       "auto_converge" : "inherit",
//       "bandwidth" : {
//         "assignment_method" : "auto"
//       },
//       "compressed" : "inherit",
//       "policy" : {
//         "id" : "00000000-0000-0000-0000-000000000000"
//       }
//     },
//     "required_rng_sources" : {
//       "required_rng_source" : [ "random" ]
//     },
//     "switch_type" : "legacy",
//     "threads_as_cores" : "false",
//     "trusted_service" : "false",
//     "tunnel_migration" : "false",
//     "version" : {
//       "major" : "4",
//       "minor" : "1"
//     },
//     "virt_service" : "true",
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "mac_pool" : {
//       "href" : "/ovirt-engine/api/macpools/456",
//       "id" : "456"
//     },
//     "scheduling_policy" : {
//       "href" : "/ovirt-engine/api/schedulingpolicies/789",
//       "id" : "789"
//     },
//     "actions" : {
//       "link" : [ {
//         "href" : "/ovirt-engine/api/clusters/234/resetemulatedmachine",
//         "rel" : "resetemulatedmachine"
//       } ]
//     },
//     "name" : "Default",
//     "description" : "The default server cluster",
//     "href" : "/ovirt-engine/api/clusters/234",
//     "id" : "234",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/clusters/234/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/cpuprofiles",
//       "rel" : "cpuprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networkfilters",
//       "rel" : "networkfilters"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networks",
//       "rel" : "networks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/affinitygroups",
//       "rel" : "affinitygroups"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glusterhooks",
//       "rel" : "glusterhooks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glustervolumes",
//       "rel" : "glustervolumes"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/enabledfeatures",
//       "rel" : "enabledfeatures"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/externalnetworkproviders",
//       "rel" : "externalnetworkproviders"
//     } ]
//   } ]
// }
// ----
func (p *VmBase) SetCluster(attr *Cluster) {
	p.cluster = attr
}

// Cluster Type representation of a cluster.
//
// A JSON representation of a cluster:
//
// [source]
// ----
// {
//   "cluster" : [ {
//     "ballooning_enabled" : "false",
//     "cpu" : {
//       "architecture" : "x86_64",
//       "type" : "Intel SandyBridge Family"
//     },
//     "custom_scheduling_policy_properties" : {
//       "property" : [ {
//         "name" : "HighUtilization",
//         "value" : "80"
//       }, {
//         "name" : "CpuOverCommitDurationMinutes",
//         "value" : "2"
//       } ]
//     },
//     "error_handling" : {
//       "on_error" : "migrate"
//     },
//     "fencing_policy" : {
//       "enabled" : "true",
//       "skip_if_connectivity_broken" : {
//         "enabled" : "false",
//         "threshold" : "50"
//       },
//       "skip_if_gluster_bricks_up" : "false",
//       "skip_if_gluster_quorum_not_met" : "false",
//       "skip_if_sd_active" : {
//         "enabled" : "false"
//       }
//     },
//     "gluster_service" : "false",
//     "firewall_type" : "iptables",
//     "ha_reservation" : "false",
//     "ksm" : {
//       "enabled" : "true",
//       "merge_across_nodes" : "true"
//     },
//     "memory_policy" : {
//       "over_commit" : {
//         "percent" : "100"
//       },
//       "transparent_hugepages" : {
//         "enabled" : "true"
//       }
//     },
//     "migration" : {
//       "auto_converge" : "inherit",
//       "bandwidth" : {
//         "assignment_method" : "auto"
//       },
//       "compressed" : "inherit",
//       "policy" : {
//         "id" : "00000000-0000-0000-0000-000000000000"
//       }
//     },
//     "required_rng_sources" : {
//       "required_rng_source" : [ "random" ]
//     },
//     "switch_type" : "legacy",
//     "threads_as_cores" : "false",
//     "trusted_service" : "false",
//     "tunnel_migration" : "false",
//     "version" : {
//       "major" : "4",
//       "minor" : "1"
//     },
//     "virt_service" : "true",
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "mac_pool" : {
//       "href" : "/ovirt-engine/api/macpools/456",
//       "id" : "456"
//     },
//     "scheduling_policy" : {
//       "href" : "/ovirt-engine/api/schedulingpolicies/789",
//       "id" : "789"
//     },
//     "actions" : {
//       "link" : [ {
//         "href" : "/ovirt-engine/api/clusters/234/resetemulatedmachine",
//         "rel" : "resetemulatedmachine"
//       } ]
//     },
//     "name" : "Default",
//     "description" : "The default server cluster",
//     "href" : "/ovirt-engine/api/clusters/234",
//     "id" : "234",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/clusters/234/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/cpuprofiles",
//       "rel" : "cpuprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networkfilters",
//       "rel" : "networkfilters"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networks",
//       "rel" : "networks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/affinitygroups",
//       "rel" : "affinitygroups"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glusterhooks",
//       "rel" : "glusterhooks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glustervolumes",
//       "rel" : "glustervolumes"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/enabledfeatures",
//       "rel" : "enabledfeatures"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/externalnetworkproviders",
//       "rel" : "externalnetworkproviders"
//     } ]
//   } ]
// }
// ----
func (p *VmBase) Cluster() (*Cluster, bool) {
	if p.cluster != nil {
		return p.cluster, true
	}
	return nil, false
}

// MustCluster Type representation of a cluster.
//
// A JSON representation of a cluster:
//
// [source]
// ----
// {
//   "cluster" : [ {
//     "ballooning_enabled" : "false",
//     "cpu" : {
//       "architecture" : "x86_64",
//       "type" : "Intel SandyBridge Family"
//     },
//     "custom_scheduling_policy_properties" : {
//       "property" : [ {
//         "name" : "HighUtilization",
//         "value" : "80"
//       }, {
//         "name" : "CpuOverCommitDurationMinutes",
//         "value" : "2"
//       } ]
//     },
//     "error_handling" : {
//       "on_error" : "migrate"
//     },
//     "fencing_policy" : {
//       "enabled" : "true",
//       "skip_if_connectivity_broken" : {
//         "enabled" : "false",
//         "threshold" : "50"
//       },
//       "skip_if_gluster_bricks_up" : "false",
//       "skip_if_gluster_quorum_not_met" : "false",
//       "skip_if_sd_active" : {
//         "enabled" : "false"
//       }
//     },
//     "gluster_service" : "false",
//     "firewall_type" : "iptables",
//     "ha_reservation" : "false",
//     "ksm" : {
//       "enabled" : "true",
//       "merge_across_nodes" : "true"
//     },
//     "memory_policy" : {
//       "over_commit" : {
//         "percent" : "100"
//       },
//       "transparent_hugepages" : {
//         "enabled" : "true"
//       }
//     },
//     "migration" : {
//       "auto_converge" : "inherit",
//       "bandwidth" : {
//         "assignment_method" : "auto"
//       },
//       "compressed" : "inherit",
//       "policy" : {
//         "id" : "00000000-0000-0000-0000-000000000000"
//       }
//     },
//     "required_rng_sources" : {
//       "required_rng_source" : [ "random" ]
//     },
//     "switch_type" : "legacy",
//     "threads_as_cores" : "false",
//     "trusted_service" : "false",
//     "tunnel_migration" : "false",
//     "version" : {
//       "major" : "4",
//       "minor" : "1"
//     },
//     "virt_service" : "true",
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "mac_pool" : {
//       "href" : "/ovirt-engine/api/macpools/456",
//       "id" : "456"
//     },
//     "scheduling_policy" : {
//       "href" : "/ovirt-engine/api/schedulingpolicies/789",
//       "id" : "789"
//     },
//     "actions" : {
//       "link" : [ {
//         "href" : "/ovirt-engine/api/clusters/234/resetemulatedmachine",
//         "rel" : "resetemulatedmachine"
//       } ]
//     },
//     "name" : "Default",
//     "description" : "The default server cluster",
//     "href" : "/ovirt-engine/api/clusters/234",
//     "id" : "234",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/clusters/234/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/cpuprofiles",
//       "rel" : "cpuprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networkfilters",
//       "rel" : "networkfilters"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networks",
//       "rel" : "networks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/affinitygroups",
//       "rel" : "affinitygroups"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glusterhooks",
//       "rel" : "glusterhooks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glustervolumes",
//       "rel" : "glustervolumes"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/enabledfeatures",
//       "rel" : "enabledfeatures"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/externalnetworkproviders",
//       "rel" : "externalnetworkproviders"
//     } ]
//   } ]
// }
// ----
func (p *VmBase) MustCluster() *Cluster {
	if p.cluster == nil {
		panic("the cluster must not be nil, please use Cluster() function instead")
	}
	return p.cluster
}

func (p *VmBase) SetComment(attr string) {
	p.comment = &attr
}

func (p *VmBase) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *VmBase) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

// SetConsole Representation for serial console device.
func (p *VmBase) SetConsole(attr *Console) {
	p.console = attr
}

// Console Representation for serial console device.
func (p *VmBase) Console() (*Console, bool) {
	if p.console != nil {
		return p.console, true
	}
	return nil, false
}

// MustConsole Representation for serial console device.
func (p *VmBase) MustConsole() *Console {
	if p.console == nil {
		panic("the console must not be nil, please use Console() function instead")
	}
	return p.console
}

func (p *VmBase) SetCpu(attr *Cpu) {
	p.cpu = attr
}

func (p *VmBase) Cpu() (*Cpu, bool) {
	if p.cpu != nil {
		return p.cpu, true
	}
	return nil, false
}

func (p *VmBase) MustCpu() *Cpu {
	if p.cpu == nil {
		panic("the cpu must not be nil, please use Cpu() function instead")
	}
	return p.cpu
}

func (p *VmBase) SetCpuProfile(attr *CpuProfile) {
	p.cpuProfile = attr
}

func (p *VmBase) CpuProfile() (*CpuProfile, bool) {
	if p.cpuProfile != nil {
		return p.cpuProfile, true
	}
	return nil, false
}

func (p *VmBase) MustCpuProfile() *CpuProfile {
	if p.cpuProfile == nil {
		panic("the cpuProfile must not be nil, please use CpuProfile() function instead")
	}
	return p.cpuProfile
}

func (p *VmBase) SetCpuShares(attr int64) {
	p.cpuShares = &attr
}

func (p *VmBase) CpuShares() (int64, bool) {
	if p.cpuShares != nil {
		return *p.cpuShares, true
	}
	var zero int64
	return zero, false
}

func (p *VmBase) MustCpuShares() int64 {
	if p.cpuShares == nil {
		panic("the cpuShares must not be nil, please use CpuShares() function instead")
	}
	return *p.cpuShares
}

func (p *VmBase) SetCreationTime(attr time.Time) {
	p.creationTime = &attr
}

func (p *VmBase) CreationTime() (time.Time, bool) {
	if p.creationTime != nil {
		return *p.creationTime, true
	}
	var zero time.Time
	return zero, false
}

func (p *VmBase) MustCreationTime() time.Time {
	if p.creationTime == nil {
		panic("the creationTime must not be nil, please use CreationTime() function instead")
	}
	return *p.creationTime
}

func (p *VmBase) SetCustomCompatibilityVersion(attr *Version) {
	p.customCompatibilityVersion = attr
}

func (p *VmBase) CustomCompatibilityVersion() (*Version, bool) {
	if p.customCompatibilityVersion != nil {
		return p.customCompatibilityVersion, true
	}
	return nil, false
}

func (p *VmBase) MustCustomCompatibilityVersion() *Version {
	if p.customCompatibilityVersion == nil {
		panic("the customCompatibilityVersion must not be nil, please use CustomCompatibilityVersion() function instead")
	}
	return p.customCompatibilityVersion
}

func (p *VmBase) SetCustomCpuModel(attr string) {
	p.customCpuModel = &attr
}

func (p *VmBase) CustomCpuModel() (string, bool) {
	if p.customCpuModel != nil {
		return *p.customCpuModel, true
	}
	var zero string
	return zero, false
}

func (p *VmBase) MustCustomCpuModel() string {
	if p.customCpuModel == nil {
		panic("the customCpuModel must not be nil, please use CustomCpuModel() function instead")
	}
	return *p.customCpuModel
}

func (p *VmBase) SetCustomEmulatedMachine(attr string) {
	p.customEmulatedMachine = &attr
}

func (p *VmBase) CustomEmulatedMachine() (string, bool) {
	if p.customEmulatedMachine != nil {
		return *p.customEmulatedMachine, true
	}
	var zero string
	return zero, false
}

func (p *VmBase) MustCustomEmulatedMachine() string {
	if p.customEmulatedMachine == nil {
		panic("the customEmulatedMachine must not be nil, please use CustomEmulatedMachine() function instead")
	}
	return *p.customEmulatedMachine
}

func (p *VmBase) SetCustomProperties(attr *CustomPropertySlice) {
	p.customProperties = attr
}

func (p *VmBase) CustomProperties() (*CustomPropertySlice, bool) {
	if p.customProperties != nil {
		return p.customProperties, true
	}
	return nil, false
}

func (p *VmBase) MustCustomProperties() *CustomPropertySlice {
	if p.customProperties == nil {
		panic("the customProperties must not be nil, please use CustomProperties() function instead")
	}
	return p.customProperties
}

func (p *VmBase) SetDeleteProtected(attr bool) {
	p.deleteProtected = &attr
}

func (p *VmBase) DeleteProtected() (bool, bool) {
	if p.deleteProtected != nil {
		return *p.deleteProtected, true
	}
	var zero bool
	return zero, false
}

func (p *VmBase) MustDeleteProtected() bool {
	if p.deleteProtected == nil {
		panic("the deleteProtected must not be nil, please use DeleteProtected() function instead")
	}
	return *p.deleteProtected
}

func (p *VmBase) SetDescription(attr string) {
	p.description = &attr
}

func (p *VmBase) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *VmBase) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

// SetDisplay Represents a graphic console configuration.
func (p *VmBase) SetDisplay(attr *Display) {
	p.display = attr
}

// Display Represents a graphic console configuration.
func (p *VmBase) Display() (*Display, bool) {
	if p.display != nil {
		return p.display, true
	}
	return nil, false
}

// MustDisplay Represents a graphic console configuration.
func (p *VmBase) MustDisplay() *Display {
	if p.display == nil {
		panic("the display must not be nil, please use Display() function instead")
	}
	return p.display
}

// SetDomain This type represents a directory service domain.
func (p *VmBase) SetDomain(attr *Domain) {
	p.domain = attr
}

// Domain This type represents a directory service domain.
func (p *VmBase) Domain() (*Domain, bool) {
	if p.domain != nil {
		return p.domain, true
	}
	return nil, false
}

// MustDomain This type represents a directory service domain.
func (p *VmBase) MustDomain() *Domain {
	if p.domain == nil {
		panic("the domain must not be nil, please use Domain() function instead")
	}
	return p.domain
}

// SetHighAvailability Type representing high availability of a virtual machine.
func (p *VmBase) SetHighAvailability(attr *HighAvailability) {
	p.highAvailability = attr
}

// HighAvailability Type representing high availability of a virtual machine.
func (p *VmBase) HighAvailability() (*HighAvailability, bool) {
	if p.highAvailability != nil {
		return p.highAvailability, true
	}
	return nil, false
}

// MustHighAvailability Type representing high availability of a virtual machine.
func (p *VmBase) MustHighAvailability() *HighAvailability {
	if p.highAvailability == nil {
		panic("the highAvailability must not be nil, please use HighAvailability() function instead")
	}
	return p.highAvailability
}

func (p *VmBase) SetId(attr string) {
	p.id = &attr
}

func (p *VmBase) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *VmBase) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *VmBase) SetInitialization(attr *Initialization) {
	p.initialization = attr
}

func (p *VmBase) Initialization() (*Initialization, bool) {
	if p.initialization != nil {
		return p.initialization, true
	}
	return nil, false
}

func (p *VmBase) MustInitialization() *Initialization {
	if p.initialization == nil {
		panic("the initialization must not be nil, please use Initialization() function instead")
	}
	return p.initialization
}

func (p *VmBase) SetIo(attr *Io) {
	p.io = attr
}

func (p *VmBase) Io() (*Io, bool) {
	if p.io != nil {
		return p.io, true
	}
	return nil, false
}

func (p *VmBase) MustIo() *Io {
	if p.io == nil {
		panic("the io must not be nil, please use Io() function instead")
	}
	return p.io
}

// SetLargeIcon Icon of virtual machine or template.
func (p *VmBase) SetLargeIcon(attr *Icon) {
	p.largeIcon = attr
}

// LargeIcon Icon of virtual machine or template.
func (p *VmBase) LargeIcon() (*Icon, bool) {
	if p.largeIcon != nil {
		return p.largeIcon, true
	}
	return nil, false
}

// MustLargeIcon Icon of virtual machine or template.
func (p *VmBase) MustLargeIcon() *Icon {
	if p.largeIcon == nil {
		panic("the largeIcon must not be nil, please use LargeIcon() function instead")
	}
	return p.largeIcon
}

// SetLease Represents a lease residing on a storage domain.
//
// A lease is a http://www.ovirt.org/develop/developer-guide/vdsm/sanlock[Sanlock] resource residing on a special
// volume on the storage domain, this Sanlock resource is used to provide storage base locking.
func (p *VmBase) SetLease(attr *StorageDomainLease) {
	p.lease = attr
}

// Lease Represents a lease residing on a storage domain.
//
// A lease is a http://www.ovirt.org/develop/developer-guide/vdsm/sanlock[Sanlock] resource residing on a special
// volume on the storage domain, this Sanlock resource is used to provide storage base locking.
func (p *VmBase) Lease() (*StorageDomainLease, bool) {
	if p.lease != nil {
		return p.lease, true
	}
	return nil, false
}

// MustLease Represents a lease residing on a storage domain.
//
// A lease is a http://www.ovirt.org/develop/developer-guide/vdsm/sanlock[Sanlock] resource residing on a special
// volume on the storage domain, this Sanlock resource is used to provide storage base locking.
func (p *VmBase) MustLease() *StorageDomainLease {
	if p.lease == nil {
		panic("the lease must not be nil, please use Lease() function instead")
	}
	return p.lease
}

func (p *VmBase) SetMemory(attr int64) {
	p.memory = &attr
}

func (p *VmBase) Memory() (int64, bool) {
	if p.memory != nil {
		return *p.memory, true
	}
	var zero int64
	return zero, false
}

func (p *VmBase) MustMemory() int64 {
	if p.memory == nil {
		panic("the memory must not be nil, please use Memory() function instead")
	}
	return *p.memory
}

// SetMemoryPolicy Logical grouping of memory-related properties of virtual machine-like entities.
func (p *VmBase) SetMemoryPolicy(attr *MemoryPolicy) {
	p.memoryPolicy = attr
}

// MemoryPolicy Logical grouping of memory-related properties of virtual machine-like entities.
func (p *VmBase) MemoryPolicy() (*MemoryPolicy, bool) {
	if p.memoryPolicy != nil {
		return p.memoryPolicy, true
	}
	return nil, false
}

// MustMemoryPolicy Logical grouping of memory-related properties of virtual machine-like entities.
func (p *VmBase) MustMemoryPolicy() *MemoryPolicy {
	if p.memoryPolicy == nil {
		panic("the memoryPolicy must not be nil, please use MemoryPolicy() function instead")
	}
	return p.memoryPolicy
}

// SetMigration The type for migration options.
func (p *VmBase) SetMigration(attr *MigrationOptions) {
	p.migration = attr
}

// Migration The type for migration options.
func (p *VmBase) Migration() (*MigrationOptions, bool) {
	if p.migration != nil {
		return p.migration, true
	}
	return nil, false
}

// MustMigration The type for migration options.
func (p *VmBase) MustMigration() *MigrationOptions {
	if p.migration == nil {
		panic("the migration must not be nil, please use Migration() function instead")
	}
	return p.migration
}

func (p *VmBase) SetMigrationDowntime(attr int64) {
	p.migrationDowntime = &attr
}

func (p *VmBase) MigrationDowntime() (int64, bool) {
	if p.migrationDowntime != nil {
		return *p.migrationDowntime, true
	}
	var zero int64
	return zero, false
}

func (p *VmBase) MustMigrationDowntime() int64 {
	if p.migrationDowntime == nil {
		panic("the migrationDowntime must not be nil, please use MigrationDowntime() function instead")
	}
	return *p.migrationDowntime
}

func (p *VmBase) SetMultiQueuesEnabled(attr bool) {
	p.multiQueuesEnabled = &attr
}

func (p *VmBase) MultiQueuesEnabled() (bool, bool) {
	if p.multiQueuesEnabled != nil {
		return *p.multiQueuesEnabled, true
	}
	var zero bool
	return zero, false
}

func (p *VmBase) MustMultiQueuesEnabled() bool {
	if p.multiQueuesEnabled == nil {
		panic("the multiQueuesEnabled must not be nil, please use MultiQueuesEnabled() function instead")
	}
	return *p.multiQueuesEnabled
}

func (p *VmBase) SetName(attr string) {
	p.name = &attr
}

func (p *VmBase) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *VmBase) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *VmBase) SetOrigin(attr string) {
	p.origin = &attr
}

func (p *VmBase) Origin() (string, bool) {
	if p.origin != nil {
		return *p.origin, true
	}
	var zero string
	return zero, false
}

func (p *VmBase) MustOrigin() string {
	if p.origin == nil {
		panic("the origin must not be nil, please use Origin() function instead")
	}
	return *p.origin
}

// SetOs Information describing the operating system. This is used for both virtual machines and hosts.
func (p *VmBase) SetOs(attr *OperatingSystem) {
	p.os = attr
}

// Os Information describing the operating system. This is used for both virtual machines and hosts.
func (p *VmBase) Os() (*OperatingSystem, bool) {
	if p.os != nil {
		return p.os, true
	}
	return nil, false
}

// MustOs Information describing the operating system. This is used for both virtual machines and hosts.
func (p *VmBase) MustOs() *OperatingSystem {
	if p.os == nil {
		panic("the os must not be nil, please use Os() function instead")
	}
	return p.os
}

func (p *VmBase) SetPlacementPolicy(attr *VmPlacementPolicy) {
	p.placementPolicy = attr
}

func (p *VmBase) PlacementPolicy() (*VmPlacementPolicy, bool) {
	if p.placementPolicy != nil {
		return p.placementPolicy, true
	}
	return nil, false
}

func (p *VmBase) MustPlacementPolicy() *VmPlacementPolicy {
	if p.placementPolicy == nil {
		panic("the placementPolicy must not be nil, please use PlacementPolicy() function instead")
	}
	return p.placementPolicy
}

// SetQuota Represents a quota object.
//
// An example XML representation of a quota:
//
// [source,xml]
// ----
// <quota href="/ovirt-engine/api/datacenters/7044934e/quotas/dcad5ddc" id="dcad5ddc">
//   <name>My Quota</name>
//   <description>A quota for my oVirt environment</description>
//   <cluster_hard_limit_pct>0</cluster_hard_limit_pct>
//   <cluster_soft_limit_pct>0</cluster_soft_limit_pct>
//   <data_center href="/ovirt-engine/api/datacenters/7044934e" id="7044934e"/>
//   <storage_hard_limit_pct>0</storage_hard_limit_pct>
//   <storage_soft_limit_pct>0</storage_soft_limit_pct>
// </quota>
// ----
func (p *VmBase) SetQuota(attr *Quota) {
	p.quota = attr
}

// Quota Represents a quota object.
//
// An example XML representation of a quota:
//
// [source,xml]
// ----
// <quota href="/ovirt-engine/api/datacenters/7044934e/quotas/dcad5ddc" id="dcad5ddc">
//   <name>My Quota</name>
//   <description>A quota for my oVirt environment</description>
//   <cluster_hard_limit_pct>0</cluster_hard_limit_pct>
//   <cluster_soft_limit_pct>0</cluster_soft_limit_pct>
//   <data_center href="/ovirt-engine/api/datacenters/7044934e" id="7044934e"/>
//   <storage_hard_limit_pct>0</storage_hard_limit_pct>
//   <storage_soft_limit_pct>0</storage_soft_limit_pct>
// </quota>
// ----
func (p *VmBase) Quota() (*Quota, bool) {
	if p.quota != nil {
		return p.quota, true
	}
	return nil, false
}

// MustQuota Represents a quota object.
//
// An example XML representation of a quota:
//
// [source,xml]
// ----
// <quota href="/ovirt-engine/api/datacenters/7044934e/quotas/dcad5ddc" id="dcad5ddc">
//   <name>My Quota</name>
//   <description>A quota for my oVirt environment</description>
//   <cluster_hard_limit_pct>0</cluster_hard_limit_pct>
//   <cluster_soft_limit_pct>0</cluster_soft_limit_pct>
//   <data_center href="/ovirt-engine/api/datacenters/7044934e" id="7044934e"/>
//   <storage_hard_limit_pct>0</storage_hard_limit_pct>
//   <storage_soft_limit_pct>0</storage_soft_limit_pct>
// </quota>
// ----
func (p *VmBase) MustQuota() *Quota {
	if p.quota == nil {
		panic("the quota must not be nil, please use Quota() function instead")
	}
	return p.quota
}

// SetRngDevice Random number generator (RNG) device model.
func (p *VmBase) SetRngDevice(attr *RngDevice) {
	p.rngDevice = attr
}

// RngDevice Random number generator (RNG) device model.
func (p *VmBase) RngDevice() (*RngDevice, bool) {
	if p.rngDevice != nil {
		return p.rngDevice, true
	}
	return nil, false
}

// MustRngDevice Random number generator (RNG) device model.
func (p *VmBase) MustRngDevice() *RngDevice {
	if p.rngDevice == nil {
		panic("the rngDevice must not be nil, please use RngDevice() function instead")
	}
	return p.rngDevice
}

func (p *VmBase) SetSerialNumber(attr *SerialNumber) {
	p.serialNumber = attr
}

func (p *VmBase) SerialNumber() (*SerialNumber, bool) {
	if p.serialNumber != nil {
		return p.serialNumber, true
	}
	return nil, false
}

func (p *VmBase) MustSerialNumber() *SerialNumber {
	if p.serialNumber == nil {
		panic("the serialNumber must not be nil, please use SerialNumber() function instead")
	}
	return p.serialNumber
}

// SetSmallIcon Icon of virtual machine or template.
func (p *VmBase) SetSmallIcon(attr *Icon) {
	p.smallIcon = attr
}

// SmallIcon Icon of virtual machine or template.
func (p *VmBase) SmallIcon() (*Icon, bool) {
	if p.smallIcon != nil {
		return p.smallIcon, true
	}
	return nil, false
}

// MustSmallIcon Icon of virtual machine or template.
func (p *VmBase) MustSmallIcon() *Icon {
	if p.smallIcon == nil {
		panic("the smallIcon must not be nil, please use SmallIcon() function instead")
	}
	return p.smallIcon
}

func (p *VmBase) SetSoundcardEnabled(attr bool) {
	p.soundcardEnabled = &attr
}

func (p *VmBase) SoundcardEnabled() (bool, bool) {
	if p.soundcardEnabled != nil {
		return *p.soundcardEnabled, true
	}
	var zero bool
	return zero, false
}

func (p *VmBase) MustSoundcardEnabled() bool {
	if p.soundcardEnabled == nil {
		panic("the soundcardEnabled must not be nil, please use SoundcardEnabled() function instead")
	}
	return *p.soundcardEnabled
}

func (p *VmBase) SetSso(attr *Sso) {
	p.sso = attr
}

func (p *VmBase) Sso() (*Sso, bool) {
	if p.sso != nil {
		return p.sso, true
	}
	return nil, false
}

func (p *VmBase) MustSso() *Sso {
	if p.sso == nil {
		panic("the sso must not be nil, please use Sso() function instead")
	}
	return p.sso
}

func (p *VmBase) SetStartPaused(attr bool) {
	p.startPaused = &attr
}

func (p *VmBase) StartPaused() (bool, bool) {
	if p.startPaused != nil {
		return *p.startPaused, true
	}
	var zero bool
	return zero, false
}

func (p *VmBase) MustStartPaused() bool {
	if p.startPaused == nil {
		panic("the startPaused must not be nil, please use StartPaused() function instead")
	}
	return *p.startPaused
}

func (p *VmBase) SetStateless(attr bool) {
	p.stateless = &attr
}

func (p *VmBase) Stateless() (bool, bool) {
	if p.stateless != nil {
		return *p.stateless, true
	}
	var zero bool
	return zero, false
}

func (p *VmBase) MustStateless() bool {
	if p.stateless == nil {
		panic("the stateless must not be nil, please use Stateless() function instead")
	}
	return *p.stateless
}

// SetStorageDomain Storage domain.
//
// An XML representation of a NFS storage domain with identifier `123`:
//
// [source,xml]
// ----
// <storage_domain href="/ovirt-engine/api/storagedomains/123" id="123">
//   <name>mydata</name>
//   <description>My data</description>
//   <available>38654705664</available>
//   <committed>1073741824</committed>
//   <critical_space_action_blocker>5</critical_space_action_blocker>
//   <external_status>ok</external_status>
//   <master>true</master>
//   <storage>
//     <address>mynfs.example.com</address>
//     <nfs_version>v3</nfs_version>
//     <path>/exports/mydata</path>
//     <type>nfs</type>
//   </storage>
//   <storage_format>v3</storage_format>
//   <type>data</type>
//   <used>13958643712</used>
//   <warning_low_space_indicator>10</warning_low_space_indicator>
//   <wipe_after_delete>false</wipe_after_delete>
//   <data_centers>
//     <data_center href="/ovirt-engine/api/datacenters/456" id="456"/>
//   </data_centers>
// </storage_domain>
// ----
func (p *VmBase) SetStorageDomain(attr *StorageDomain) {
	p.storageDomain = attr
}

// StorageDomain Storage domain.
//
// An XML representation of a NFS storage domain with identifier `123`:
//
// [source,xml]
// ----
// <storage_domain href="/ovirt-engine/api/storagedomains/123" id="123">
//   <name>mydata</name>
//   <description>My data</description>
//   <available>38654705664</available>
//   <committed>1073741824</committed>
//   <critical_space_action_blocker>5</critical_space_action_blocker>
//   <external_status>ok</external_status>
//   <master>true</master>
//   <storage>
//     <address>mynfs.example.com</address>
//     <nfs_version>v3</nfs_version>
//     <path>/exports/mydata</path>
//     <type>nfs</type>
//   </storage>
//   <storage_format>v3</storage_format>
//   <type>data</type>
//   <used>13958643712</used>
//   <warning_low_space_indicator>10</warning_low_space_indicator>
//   <wipe_after_delete>false</wipe_after_delete>
//   <data_centers>
//     <data_center href="/ovirt-engine/api/datacenters/456" id="456"/>
//   </data_centers>
// </storage_domain>
// ----
func (p *VmBase) StorageDomain() (*StorageDomain, bool) {
	if p.storageDomain != nil {
		return p.storageDomain, true
	}
	return nil, false
}

// MustStorageDomain Storage domain.
//
// An XML representation of a NFS storage domain with identifier `123`:
//
// [source,xml]
// ----
// <storage_domain href="/ovirt-engine/api/storagedomains/123" id="123">
//   <name>mydata</name>
//   <description>My data</description>
//   <available>38654705664</available>
//   <committed>1073741824</committed>
//   <critical_space_action_blocker>5</critical_space_action_blocker>
//   <external_status>ok</external_status>
//   <master>true</master>
//   <storage>
//     <address>mynfs.example.com</address>
//     <nfs_version>v3</nfs_version>
//     <path>/exports/mydata</path>
//     <type>nfs</type>
//   </storage>
//   <storage_format>v3</storage_format>
//   <type>data</type>
//   <used>13958643712</used>
//   <warning_low_space_indicator>10</warning_low_space_indicator>
//   <wipe_after_delete>false</wipe_after_delete>
//   <data_centers>
//     <data_center href="/ovirt-engine/api/datacenters/456" id="456"/>
//   </data_centers>
// </storage_domain>
// ----
func (p *VmBase) MustStorageDomain() *StorageDomain {
	if p.storageDomain == nil {
		panic("the storageDomain must not be nil, please use StorageDomain() function instead")
	}
	return p.storageDomain
}

// SetStorageErrorResumeBehaviour If the storage, on which this virtual machine has some disks gets
// unresponsive, the virtual machine gets paused.
//
// This are the possible options, what should happen with the virtual machine
// in the moment the storage gets available again.
func (p *VmBase) SetStorageErrorResumeBehaviour(attr VmStorageErrorResumeBehaviour) {
	p.storageErrorResumeBehaviour = &attr
}

// StorageErrorResumeBehaviour If the storage, on which this virtual machine has some disks gets
// unresponsive, the virtual machine gets paused.
//
// This are the possible options, what should happen with the virtual machine
// in the moment the storage gets available again.
func (p *VmBase) StorageErrorResumeBehaviour() (VmStorageErrorResumeBehaviour, bool) {
	if p.storageErrorResumeBehaviour != nil {
		return *p.storageErrorResumeBehaviour, true
	}
	var zero VmStorageErrorResumeBehaviour
	return zero, false
}

// MustStorageErrorResumeBehaviour If the storage, on which this virtual machine has some disks gets
// unresponsive, the virtual machine gets paused.
//
// This are the possible options, what should happen with the virtual machine
// in the moment the storage gets available again.
func (p *VmBase) MustStorageErrorResumeBehaviour() VmStorageErrorResumeBehaviour {
	if p.storageErrorResumeBehaviour == nil {
		panic("the storageErrorResumeBehaviour must not be nil, please use StorageErrorResumeBehaviour() function instead")
	}
	return *p.storageErrorResumeBehaviour
}

// SetTimeZone Time zone representation.
func (p *VmBase) SetTimeZone(attr *TimeZone) {
	p.timeZone = attr
}

// TimeZone Time zone representation.
func (p *VmBase) TimeZone() (*TimeZone, bool) {
	if p.timeZone != nil {
		return p.timeZone, true
	}
	return nil, false
}

// MustTimeZone Time zone representation.
func (p *VmBase) MustTimeZone() *TimeZone {
	if p.timeZone == nil {
		panic("the timeZone must not be nil, please use TimeZone() function instead")
	}
	return p.timeZone
}

func (p *VmBase) SetTpmEnabled(attr bool) {
	p.tpmEnabled = &attr
}

func (p *VmBase) TpmEnabled() (bool, bool) {
	if p.tpmEnabled != nil {
		return *p.tpmEnabled, true
	}
	var zero bool
	return zero, false
}

func (p *VmBase) MustTpmEnabled() bool {
	if p.tpmEnabled == nil {
		panic("the tpmEnabled must not be nil, please use TpmEnabled() function instead")
	}
	return *p.tpmEnabled
}

func (p *VmBase) SetTunnelMigration(attr bool) {
	p.tunnelMigration = &attr
}

func (p *VmBase) TunnelMigration() (bool, bool) {
	if p.tunnelMigration != nil {
		return *p.tunnelMigration, true
	}
	var zero bool
	return zero, false
}

func (p *VmBase) MustTunnelMigration() bool {
	if p.tunnelMigration == nil {
		panic("the tunnelMigration must not be nil, please use TunnelMigration() function instead")
	}
	return *p.tunnelMigration
}

// SetType Type representing what the virtual machine is optimized for.
func (p *VmBase) SetType(attr VmType) {
	p.type_ = &attr
}

// Type Type representing what the virtual machine is optimized for.
func (p *VmBase) Type() (VmType, bool) {
	if p.type_ != nil {
		return *p.type_, true
	}
	var zero VmType
	return zero, false
}

// MustType Type representing what the virtual machine is optimized for.
func (p *VmBase) MustType() VmType {
	if p.type_ == nil {
		panic("the type_ must not be nil, please use Type() function instead")
	}
	return *p.type_
}

// SetUsb Configuration of the USB device of a virtual machine.
func (p *VmBase) SetUsb(attr *Usb) {
	p.usb = attr
}

// Usb Configuration of the USB device of a virtual machine.
func (p *VmBase) Usb() (*Usb, bool) {
	if p.usb != nil {
		return p.usb, true
	}
	return nil, false
}

// MustUsb Configuration of the USB device of a virtual machine.
func (p *VmBase) MustUsb() *Usb {
	if p.usb == nil {
		panic("the usb must not be nil, please use Usb() function instead")
	}
	return p.usb
}

// SetVirtioScsi Type representing the support of virtio-SCSI.
// If it supported we use virtio driver for SCSI guest device.
func (p *VmBase) SetVirtioScsi(attr *VirtioScsi) {
	p.virtioScsi = attr
}

// VirtioScsi Type representing the support of virtio-SCSI.
// If it supported we use virtio driver for SCSI guest device.
func (p *VmBase) VirtioScsi() (*VirtioScsi, bool) {
	if p.virtioScsi != nil {
		return p.virtioScsi, true
	}
	return nil, false
}

// MustVirtioScsi Type representing the support of virtio-SCSI.
// If it supported we use virtio driver for SCSI guest device.
func (p *VmBase) MustVirtioScsi() *VirtioScsi {
	if p.virtioScsi == nil {
		panic("the virtioScsi must not be nil, please use VirtioScsi() function instead")
	}
	return p.virtioScsi
}

func (p *VmBase) SetVirtioScsiMultiQueuesEnabled(attr bool) {
	p.virtioScsiMultiQueuesEnabled = &attr
}

func (p *VmBase) VirtioScsiMultiQueuesEnabled() (bool, bool) {
	if p.virtioScsiMultiQueuesEnabled != nil {
		return *p.virtioScsiMultiQueuesEnabled, true
	}
	var zero bool
	return zero, false
}

func (p *VmBase) MustVirtioScsiMultiQueuesEnabled() bool {
	if p.virtioScsiMultiQueuesEnabled == nil {
		panic("the virtioScsiMultiQueuesEnabled must not be nil, please use VirtioScsiMultiQueuesEnabled() function instead")
	}
	return *p.virtioScsiMultiQueuesEnabled
}

type VmPlacementPolicy struct {
	Struct
	affinity *VmAffinity
	hosts    *HostSlice
}

func (p *VmPlacementPolicy) SetAffinity(attr VmAffinity) {
	p.affinity = &attr
}

func (p *VmPlacementPolicy) Affinity() (VmAffinity, bool) {
	if p.affinity != nil {
		return *p.affinity, true
	}
	var zero VmAffinity
	return zero, false
}

func (p *VmPlacementPolicy) MustAffinity() VmAffinity {
	if p.affinity == nil {
		panic("the affinity must not be nil, please use Affinity() function instead")
	}
	return *p.affinity
}

func (p *VmPlacementPolicy) SetHosts(attr *HostSlice) {
	p.hosts = attr
}

func (p *VmPlacementPolicy) Hosts() (*HostSlice, bool) {
	if p.hosts != nil {
		return p.hosts, true
	}
	return nil, false
}

func (p *VmPlacementPolicy) MustHosts() *HostSlice {
	if p.hosts == nil {
		panic("the hosts must not be nil, please use Hosts() function instead")
	}
	return p.hosts
}

// VmPool Type represeting a virtual machines pool.
type VmPool struct {
	Struct
	autoStorageSelect        *bool
	cluster                  *Cluster
	comment                  *string
	description              *string
	display                  *Display
	id                       *string
	instanceType             *InstanceType
	maxUserVms               *int64
	name                     *string
	permissions              *PermissionSlice
	prestartedVms            *int64
	rngDevice                *RngDevice
	size                     *int64
	soundcardEnabled         *bool
	stateful                 *bool
	template                 *Template
	tpmEnabled               *bool
	type_                    *VmPoolType
	useLatestTemplateVersion *bool
	vm                       *Vm
}

func (p *VmPool) SetAutoStorageSelect(attr bool) {
	p.autoStorageSelect = &attr
}

func (p *VmPool) AutoStorageSelect() (bool, bool) {
	if p.autoStorageSelect != nil {
		return *p.autoStorageSelect, true
	}
	var zero bool
	return zero, false
}

func (p *VmPool) MustAutoStorageSelect() bool {
	if p.autoStorageSelect == nil {
		panic("the autoStorageSelect must not be nil, please use AutoStorageSelect() function instead")
	}
	return *p.autoStorageSelect
}

// SetCluster Type representation of a cluster.
//
// A JSON representation of a cluster:
//
// [source]
// ----
// {
//   "cluster" : [ {
//     "ballooning_enabled" : "false",
//     "cpu" : {
//       "architecture" : "x86_64",
//       "type" : "Intel SandyBridge Family"
//     },
//     "custom_scheduling_policy_properties" : {
//       "property" : [ {
//         "name" : "HighUtilization",
//         "value" : "80"
//       }, {
//         "name" : "CpuOverCommitDurationMinutes",
//         "value" : "2"
//       } ]
//     },
//     "error_handling" : {
//       "on_error" : "migrate"
//     },
//     "fencing_policy" : {
//       "enabled" : "true",
//       "skip_if_connectivity_broken" : {
//         "enabled" : "false",
//         "threshold" : "50"
//       },
//       "skip_if_gluster_bricks_up" : "false",
//       "skip_if_gluster_quorum_not_met" : "false",
//       "skip_if_sd_active" : {
//         "enabled" : "false"
//       }
//     },
//     "gluster_service" : "false",
//     "firewall_type" : "iptables",
//     "ha_reservation" : "false",
//     "ksm" : {
//       "enabled" : "true",
//       "merge_across_nodes" : "true"
//     },
//     "memory_policy" : {
//       "over_commit" : {
//         "percent" : "100"
//       },
//       "transparent_hugepages" : {
//         "enabled" : "true"
//       }
//     },
//     "migration" : {
//       "auto_converge" : "inherit",
//       "bandwidth" : {
//         "assignment_method" : "auto"
//       },
//       "compressed" : "inherit",
//       "policy" : {
//         "id" : "00000000-0000-0000-0000-000000000000"
//       }
//     },
//     "required_rng_sources" : {
//       "required_rng_source" : [ "random" ]
//     },
//     "switch_type" : "legacy",
//     "threads_as_cores" : "false",
//     "trusted_service" : "false",
//     "tunnel_migration" : "false",
//     "version" : {
//       "major" : "4",
//       "minor" : "1"
//     },
//     "virt_service" : "true",
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "mac_pool" : {
//       "href" : "/ovirt-engine/api/macpools/456",
//       "id" : "456"
//     },
//     "scheduling_policy" : {
//       "href" : "/ovirt-engine/api/schedulingpolicies/789",
//       "id" : "789"
//     },
//     "actions" : {
//       "link" : [ {
//         "href" : "/ovirt-engine/api/clusters/234/resetemulatedmachine",
//         "rel" : "resetemulatedmachine"
//       } ]
//     },
//     "name" : "Default",
//     "description" : "The default server cluster",
//     "href" : "/ovirt-engine/api/clusters/234",
//     "id" : "234",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/clusters/234/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/cpuprofiles",
//       "rel" : "cpuprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networkfilters",
//       "rel" : "networkfilters"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networks",
//       "rel" : "networks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/affinitygroups",
//       "rel" : "affinitygroups"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glusterhooks",
//       "rel" : "glusterhooks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glustervolumes",
//       "rel" : "glustervolumes"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/enabledfeatures",
//       "rel" : "enabledfeatures"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/externalnetworkproviders",
//       "rel" : "externalnetworkproviders"
//     } ]
//   } ]
// }
// ----
func (p *VmPool) SetCluster(attr *Cluster) {
	p.cluster = attr
}

// Cluster Type representation of a cluster.
//
// A JSON representation of a cluster:
//
// [source]
// ----
// {
//   "cluster" : [ {
//     "ballooning_enabled" : "false",
//     "cpu" : {
//       "architecture" : "x86_64",
//       "type" : "Intel SandyBridge Family"
//     },
//     "custom_scheduling_policy_properties" : {
//       "property" : [ {
//         "name" : "HighUtilization",
//         "value" : "80"
//       }, {
//         "name" : "CpuOverCommitDurationMinutes",
//         "value" : "2"
//       } ]
//     },
//     "error_handling" : {
//       "on_error" : "migrate"
//     },
//     "fencing_policy" : {
//       "enabled" : "true",
//       "skip_if_connectivity_broken" : {
//         "enabled" : "false",
//         "threshold" : "50"
//       },
//       "skip_if_gluster_bricks_up" : "false",
//       "skip_if_gluster_quorum_not_met" : "false",
//       "skip_if_sd_active" : {
//         "enabled" : "false"
//       }
//     },
//     "gluster_service" : "false",
//     "firewall_type" : "iptables",
//     "ha_reservation" : "false",
//     "ksm" : {
//       "enabled" : "true",
//       "merge_across_nodes" : "true"
//     },
//     "memory_policy" : {
//       "over_commit" : {
//         "percent" : "100"
//       },
//       "transparent_hugepages" : {
//         "enabled" : "true"
//       }
//     },
//     "migration" : {
//       "auto_converge" : "inherit",
//       "bandwidth" : {
//         "assignment_method" : "auto"
//       },
//       "compressed" : "inherit",
//       "policy" : {
//         "id" : "00000000-0000-0000-0000-000000000000"
//       }
//     },
//     "required_rng_sources" : {
//       "required_rng_source" : [ "random" ]
//     },
//     "switch_type" : "legacy",
//     "threads_as_cores" : "false",
//     "trusted_service" : "false",
//     "tunnel_migration" : "false",
//     "version" : {
//       "major" : "4",
//       "minor" : "1"
//     },
//     "virt_service" : "true",
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "mac_pool" : {
//       "href" : "/ovirt-engine/api/macpools/456",
//       "id" : "456"
//     },
//     "scheduling_policy" : {
//       "href" : "/ovirt-engine/api/schedulingpolicies/789",
//       "id" : "789"
//     },
//     "actions" : {
//       "link" : [ {
//         "href" : "/ovirt-engine/api/clusters/234/resetemulatedmachine",
//         "rel" : "resetemulatedmachine"
//       } ]
//     },
//     "name" : "Default",
//     "description" : "The default server cluster",
//     "href" : "/ovirt-engine/api/clusters/234",
//     "id" : "234",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/clusters/234/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/cpuprofiles",
//       "rel" : "cpuprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networkfilters",
//       "rel" : "networkfilters"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networks",
//       "rel" : "networks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/affinitygroups",
//       "rel" : "affinitygroups"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glusterhooks",
//       "rel" : "glusterhooks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glustervolumes",
//       "rel" : "glustervolumes"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/enabledfeatures",
//       "rel" : "enabledfeatures"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/externalnetworkproviders",
//       "rel" : "externalnetworkproviders"
//     } ]
//   } ]
// }
// ----
func (p *VmPool) Cluster() (*Cluster, bool) {
	if p.cluster != nil {
		return p.cluster, true
	}
	return nil, false
}

// MustCluster Type representation of a cluster.
//
// A JSON representation of a cluster:
//
// [source]
// ----
// {
//   "cluster" : [ {
//     "ballooning_enabled" : "false",
//     "cpu" : {
//       "architecture" : "x86_64",
//       "type" : "Intel SandyBridge Family"
//     },
//     "custom_scheduling_policy_properties" : {
//       "property" : [ {
//         "name" : "HighUtilization",
//         "value" : "80"
//       }, {
//         "name" : "CpuOverCommitDurationMinutes",
//         "value" : "2"
//       } ]
//     },
//     "error_handling" : {
//       "on_error" : "migrate"
//     },
//     "fencing_policy" : {
//       "enabled" : "true",
//       "skip_if_connectivity_broken" : {
//         "enabled" : "false",
//         "threshold" : "50"
//       },
//       "skip_if_gluster_bricks_up" : "false",
//       "skip_if_gluster_quorum_not_met" : "false",
//       "skip_if_sd_active" : {
//         "enabled" : "false"
//       }
//     },
//     "gluster_service" : "false",
//     "firewall_type" : "iptables",
//     "ha_reservation" : "false",
//     "ksm" : {
//       "enabled" : "true",
//       "merge_across_nodes" : "true"
//     },
//     "memory_policy" : {
//       "over_commit" : {
//         "percent" : "100"
//       },
//       "transparent_hugepages" : {
//         "enabled" : "true"
//       }
//     },
//     "migration" : {
//       "auto_converge" : "inherit",
//       "bandwidth" : {
//         "assignment_method" : "auto"
//       },
//       "compressed" : "inherit",
//       "policy" : {
//         "id" : "00000000-0000-0000-0000-000000000000"
//       }
//     },
//     "required_rng_sources" : {
//       "required_rng_source" : [ "random" ]
//     },
//     "switch_type" : "legacy",
//     "threads_as_cores" : "false",
//     "trusted_service" : "false",
//     "tunnel_migration" : "false",
//     "version" : {
//       "major" : "4",
//       "minor" : "1"
//     },
//     "virt_service" : "true",
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "mac_pool" : {
//       "href" : "/ovirt-engine/api/macpools/456",
//       "id" : "456"
//     },
//     "scheduling_policy" : {
//       "href" : "/ovirt-engine/api/schedulingpolicies/789",
//       "id" : "789"
//     },
//     "actions" : {
//       "link" : [ {
//         "href" : "/ovirt-engine/api/clusters/234/resetemulatedmachine",
//         "rel" : "resetemulatedmachine"
//       } ]
//     },
//     "name" : "Default",
//     "description" : "The default server cluster",
//     "href" : "/ovirt-engine/api/clusters/234",
//     "id" : "234",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/clusters/234/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/cpuprofiles",
//       "rel" : "cpuprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networkfilters",
//       "rel" : "networkfilters"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networks",
//       "rel" : "networks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/affinitygroups",
//       "rel" : "affinitygroups"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glusterhooks",
//       "rel" : "glusterhooks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glustervolumes",
//       "rel" : "glustervolumes"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/enabledfeatures",
//       "rel" : "enabledfeatures"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/externalnetworkproviders",
//       "rel" : "externalnetworkproviders"
//     } ]
//   } ]
// }
// ----
func (p *VmPool) MustCluster() *Cluster {
	if p.cluster == nil {
		panic("the cluster must not be nil, please use Cluster() function instead")
	}
	return p.cluster
}

func (p *VmPool) SetComment(attr string) {
	p.comment = &attr
}

func (p *VmPool) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *VmPool) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *VmPool) SetDescription(attr string) {
	p.description = &attr
}

func (p *VmPool) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *VmPool) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

// SetDisplay Represents a graphic console configuration.
func (p *VmPool) SetDisplay(attr *Display) {
	p.display = attr
}

// Display Represents a graphic console configuration.
func (p *VmPool) Display() (*Display, bool) {
	if p.display != nil {
		return p.display, true
	}
	return nil, false
}

// MustDisplay Represents a graphic console configuration.
func (p *VmPool) MustDisplay() *Display {
	if p.display == nil {
		panic("the display must not be nil, please use Display() function instead")
	}
	return p.display
}

func (p *VmPool) SetId(attr string) {
	p.id = &attr
}

func (p *VmPool) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *VmPool) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

// SetInstanceType Describes the hardware configuration of virtual machines.
//
// For example `medium` instance type includes 1 virtual CPU and 4 GiB of memory. It is a top-level
// entity (e.g. not bound to any data center or cluster). The attributes that are used for instance
// types and are common to virtual machine and template types are:
//
// - `console`
// - `cpu`
// - `custom_cpu_model`
// - `custom_emulated_machine`
// - `display`
// - `high_availability`
// - `io`
// - `memory`
// - `memory_policy`
// - `migration`
// - `migration_downtime`
// - `os`
// - `rng_device`
// - `soundcard_enabled`
// - `usb`
// - `virtio_scsi`
//
// When creating a virtual machine from both an instance type and a template, the virtual machine
// will inherit the hardware configurations from the instance type
//
// NOTE: An instance type inherits it's attributes from the template entity although most template
// attributes are not used in instance types.
func (p *VmPool) SetInstanceType(attr *InstanceType) {
	p.instanceType = attr
}

// InstanceType Describes the hardware configuration of virtual machines.
//
// For example `medium` instance type includes 1 virtual CPU and 4 GiB of memory. It is a top-level
// entity (e.g. not bound to any data center or cluster). The attributes that are used for instance
// types and are common to virtual machine and template types are:
//
// - `console`
// - `cpu`
// - `custom_cpu_model`
// - `custom_emulated_machine`
// - `display`
// - `high_availability`
// - `io`
// - `memory`
// - `memory_policy`
// - `migration`
// - `migration_downtime`
// - `os`
// - `rng_device`
// - `soundcard_enabled`
// - `usb`
// - `virtio_scsi`
//
// When creating a virtual machine from both an instance type and a template, the virtual machine
// will inherit the hardware configurations from the instance type
//
// NOTE: An instance type inherits it's attributes from the template entity although most template
// attributes are not used in instance types.
func (p *VmPool) InstanceType() (*InstanceType, bool) {
	if p.instanceType != nil {
		return p.instanceType, true
	}
	return nil, false
}

// MustInstanceType Describes the hardware configuration of virtual machines.
//
// For example `medium` instance type includes 1 virtual CPU and 4 GiB of memory. It is a top-level
// entity (e.g. not bound to any data center or cluster). The attributes that are used for instance
// types and are common to virtual machine and template types are:
//
// - `console`
// - `cpu`
// - `custom_cpu_model`
// - `custom_emulated_machine`
// - `display`
// - `high_availability`
// - `io`
// - `memory`
// - `memory_policy`
// - `migration`
// - `migration_downtime`
// - `os`
// - `rng_device`
// - `soundcard_enabled`
// - `usb`
// - `virtio_scsi`
//
// When creating a virtual machine from both an instance type and a template, the virtual machine
// will inherit the hardware configurations from the instance type
//
// NOTE: An instance type inherits it's attributes from the template entity although most template
// attributes are not used in instance types.
func (p *VmPool) MustInstanceType() *InstanceType {
	if p.instanceType == nil {
		panic("the instanceType must not be nil, please use InstanceType() function instead")
	}
	return p.instanceType
}

func (p *VmPool) SetMaxUserVms(attr int64) {
	p.maxUserVms = &attr
}

func (p *VmPool) MaxUserVms() (int64, bool) {
	if p.maxUserVms != nil {
		return *p.maxUserVms, true
	}
	var zero int64
	return zero, false
}

func (p *VmPool) MustMaxUserVms() int64 {
	if p.maxUserVms == nil {
		panic("the maxUserVms must not be nil, please use MaxUserVms() function instead")
	}
	return *p.maxUserVms
}

func (p *VmPool) SetName(attr string) {
	p.name = &attr
}

func (p *VmPool) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *VmPool) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *VmPool) SetPermissions(attr *PermissionSlice) {
	p.permissions = attr
}

func (p *VmPool) Permissions() (*PermissionSlice, bool) {
	if p.permissions != nil {
		return p.permissions, true
	}
	return nil, false
}

func (p *VmPool) MustPermissions() *PermissionSlice {
	if p.permissions == nil {
		panic("the permissions must not be nil, please use Permissions() function instead")
	}
	return p.permissions
}

func (p *VmPool) SetPrestartedVms(attr int64) {
	p.prestartedVms = &attr
}

func (p *VmPool) PrestartedVms() (int64, bool) {
	if p.prestartedVms != nil {
		return *p.prestartedVms, true
	}
	var zero int64
	return zero, false
}

func (p *VmPool) MustPrestartedVms() int64 {
	if p.prestartedVms == nil {
		panic("the prestartedVms must not be nil, please use PrestartedVms() function instead")
	}
	return *p.prestartedVms
}

// SetRngDevice Random number generator (RNG) device model.
func (p *VmPool) SetRngDevice(attr *RngDevice) {
	p.rngDevice = attr
}

// RngDevice Random number generator (RNG) device model.
func (p *VmPool) RngDevice() (*RngDevice, bool) {
	if p.rngDevice != nil {
		return p.rngDevice, true
	}
	return nil, false
}

// MustRngDevice Random number generator (RNG) device model.
func (p *VmPool) MustRngDevice() *RngDevice {
	if p.rngDevice == nil {
		panic("the rngDevice must not be nil, please use RngDevice() function instead")
	}
	return p.rngDevice
}

func (p *VmPool) SetSize(attr int64) {
	p.size = &attr
}

func (p *VmPool) Size() (int64, bool) {
	if p.size != nil {
		return *p.size, true
	}
	var zero int64
	return zero, false
}

func (p *VmPool) MustSize() int64 {
	if p.size == nil {
		panic("the size must not be nil, please use Size() function instead")
	}
	return *p.size
}

func (p *VmPool) SetSoundcardEnabled(attr bool) {
	p.soundcardEnabled = &attr
}

func (p *VmPool) SoundcardEnabled() (bool, bool) {
	if p.soundcardEnabled != nil {
		return *p.soundcardEnabled, true
	}
	var zero bool
	return zero, false
}

func (p *VmPool) MustSoundcardEnabled() bool {
	if p.soundcardEnabled == nil {
		panic("the soundcardEnabled must not be nil, please use SoundcardEnabled() function instead")
	}
	return *p.soundcardEnabled
}

func (p *VmPool) SetStateful(attr bool) {
	p.stateful = &attr
}

func (p *VmPool) Stateful() (bool, bool) {
	if p.stateful != nil {
		return *p.stateful, true
	}
	var zero bool
	return zero, false
}

func (p *VmPool) MustStateful() bool {
	if p.stateful == nil {
		panic("the stateful must not be nil, please use Stateful() function instead")
	}
	return *p.stateful
}

// SetTemplate The type that represents a virtual machine template.
// Templates allow for a rapid instantiation of virtual machines with common configuration and disk states.
func (p *VmPool) SetTemplate(attr *Template) {
	p.template = attr
}

// Template The type that represents a virtual machine template.
// Templates allow for a rapid instantiation of virtual machines with common configuration and disk states.
func (p *VmPool) Template() (*Template, bool) {
	if p.template != nil {
		return p.template, true
	}
	return nil, false
}

// MustTemplate The type that represents a virtual machine template.
// Templates allow for a rapid instantiation of virtual machines with common configuration and disk states.
func (p *VmPool) MustTemplate() *Template {
	if p.template == nil {
		panic("the template must not be nil, please use Template() function instead")
	}
	return p.template
}

func (p *VmPool) SetTpmEnabled(attr bool) {
	p.tpmEnabled = &attr
}

func (p *VmPool) TpmEnabled() (bool, bool) {
	if p.tpmEnabled != nil {
		return *p.tpmEnabled, true
	}
	var zero bool
	return zero, false
}

func (p *VmPool) MustTpmEnabled() bool {
	if p.tpmEnabled == nil {
		panic("the tpmEnabled must not be nil, please use TpmEnabled() function instead")
	}
	return *p.tpmEnabled
}

// SetType Type represeting the deallocation policy of virtual machines in a virtual machines pool.
func (p *VmPool) SetType(attr VmPoolType) {
	p.type_ = &attr
}

// Type Type represeting the deallocation policy of virtual machines in a virtual machines pool.
func (p *VmPool) Type() (VmPoolType, bool) {
	if p.type_ != nil {
		return *p.type_, true
	}
	var zero VmPoolType
	return zero, false
}

// MustType Type represeting the deallocation policy of virtual machines in a virtual machines pool.
func (p *VmPool) MustType() VmPoolType {
	if p.type_ == nil {
		panic("the type_ must not be nil, please use Type() function instead")
	}
	return *p.type_
}

func (p *VmPool) SetUseLatestTemplateVersion(attr bool) {
	p.useLatestTemplateVersion = &attr
}

func (p *VmPool) UseLatestTemplateVersion() (bool, bool) {
	if p.useLatestTemplateVersion != nil {
		return *p.useLatestTemplateVersion, true
	}
	var zero bool
	return zero, false
}

func (p *VmPool) MustUseLatestTemplateVersion() bool {
	if p.useLatestTemplateVersion == nil {
		panic("the useLatestTemplateVersion must not be nil, please use UseLatestTemplateVersion() function instead")
	}
	return *p.useLatestTemplateVersion
}

// SetVm Represents a virtual machine.
func (p *VmPool) SetVm(attr *Vm) {
	p.vm = attr
}

// Vm Represents a virtual machine.
func (p *VmPool) Vm() (*Vm, bool) {
	if p.vm != nil {
		return p.vm, true
	}
	return nil, false
}

// MustVm Represents a virtual machine.
func (p *VmPool) MustVm() *Vm {
	if p.vm == nil {
		panic("the vm must not be nil, please use Vm() function instead")
	}
	return p.vm
}

// VmSummary Type containing information related to virtual machines on a particular host.
type VmSummary struct {
	Struct
	active    *int64
	migrating *int64
	total     *int64
}

func (p *VmSummary) SetActive(attr int64) {
	p.active = &attr
}

func (p *VmSummary) Active() (int64, bool) {
	if p.active != nil {
		return *p.active, true
	}
	var zero int64
	return zero, false
}

func (p *VmSummary) MustActive() int64 {
	if p.active == nil {
		panic("the active must not be nil, please use Active() function instead")
	}
	return *p.active
}

func (p *VmSummary) SetMigrating(attr int64) {
	p.migrating = &attr
}

func (p *VmSummary) Migrating() (int64, bool) {
	if p.migrating != nil {
		return *p.migrating, true
	}
	var zero int64
	return zero, false
}

func (p *VmSummary) MustMigrating() int64 {
	if p.migrating == nil {
		panic("the migrating must not be nil, please use Migrating() function instead")
	}
	return *p.migrating
}

func (p *VmSummary) SetTotal(attr int64) {
	p.total = &attr
}

func (p *VmSummary) Total() (int64, bool) {
	if p.total != nil {
		return *p.total, true
	}
	var zero int64
	return zero, false
}

func (p *VmSummary) MustTotal() int64 {
	if p.total == nil {
		panic("the total must not be nil, please use Total() function instead")
	}
	return *p.total
}

type VnicPassThrough struct {
	Struct
	mode *VnicPassThroughMode
}

// SetMode Describes whether the vNIC is to be implemented as a pass-through device or a virtual one.
func (p *VnicPassThrough) SetMode(attr VnicPassThroughMode) {
	p.mode = &attr
}

// Mode Describes whether the vNIC is to be implemented as a pass-through device or a virtual one.
func (p *VnicPassThrough) Mode() (VnicPassThroughMode, bool) {
	if p.mode != nil {
		return *p.mode, true
	}
	var zero VnicPassThroughMode
	return zero, false
}

// MustMode Describes whether the vNIC is to be implemented as a pass-through device or a virtual one.
func (p *VnicPassThrough) MustMode() VnicPassThroughMode {
	if p.mode == nil {
		panic("the mode must not be nil, please use Mode() function instead")
	}
	return *p.mode
}

// VnicProfile A vNIC profile is a collection of settings that can be applied to individual <<types/nic,NIC>>.
type VnicProfile struct {
	Struct
	comment          *string
	customProperties *CustomPropertySlice
	description      *string
	failover         *VnicProfile
	id               *string
	migratable       *bool
	name             *string
	network          *Network
	networkFilter    *NetworkFilter
	passThrough      *VnicPassThrough
	permissions      *PermissionSlice
	portMirroring    *bool
	qos              *Qos
}

func (p *VnicProfile) SetComment(attr string) {
	p.comment = &attr
}

func (p *VnicProfile) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *VnicProfile) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *VnicProfile) SetCustomProperties(attr *CustomPropertySlice) {
	p.customProperties = attr
}

func (p *VnicProfile) CustomProperties() (*CustomPropertySlice, bool) {
	if p.customProperties != nil {
		return p.customProperties, true
	}
	return nil, false
}

func (p *VnicProfile) MustCustomProperties() *CustomPropertySlice {
	if p.customProperties == nil {
		panic("the customProperties must not be nil, please use CustomProperties() function instead")
	}
	return p.customProperties
}

func (p *VnicProfile) SetDescription(attr string) {
	p.description = &attr
}

func (p *VnicProfile) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *VnicProfile) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

// SetFailover A vNIC profile is a collection of settings that can be applied to individual <<types/nic,NIC>>.
func (p *VnicProfile) SetFailover(attr *VnicProfile) {
	p.failover = attr
}

// Failover A vNIC profile is a collection of settings that can be applied to individual <<types/nic,NIC>>.
func (p *VnicProfile) Failover() (*VnicProfile, bool) {
	if p.failover != nil {
		return p.failover, true
	}
	return nil, false
}

// MustFailover A vNIC profile is a collection of settings that can be applied to individual <<types/nic,NIC>>.
func (p *VnicProfile) MustFailover() *VnicProfile {
	if p.failover == nil {
		panic("the failover must not be nil, please use Failover() function instead")
	}
	return p.failover
}

func (p *VnicProfile) SetId(attr string) {
	p.id = &attr
}

func (p *VnicProfile) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *VnicProfile) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *VnicProfile) SetMigratable(attr bool) {
	p.migratable = &attr
}

func (p *VnicProfile) Migratable() (bool, bool) {
	if p.migratable != nil {
		return *p.migratable, true
	}
	var zero bool
	return zero, false
}

func (p *VnicProfile) MustMigratable() bool {
	if p.migratable == nil {
		panic("the migratable must not be nil, please use Migratable() function instead")
	}
	return *p.migratable
}

func (p *VnicProfile) SetName(attr string) {
	p.name = &attr
}

func (p *VnicProfile) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *VnicProfile) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

// SetNetwork The type for a logical network.
//
// An example of the JSON representation of a logical network:
//
// [source,json]
// ----
// {
//   "network" : [ {
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "stp" : "false",
//     "mtu" : "0",
//     "usages" : {
//       "usage" : [ "vm" ]
//     },
//     "name" : "ovirtmgmt",
//     "description" : "Management Network",
//     "href" : "/ovirt-engine/api/networks/456",
//     "id" : "456",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/networks/456/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/networks/456/vnicprofiles",
//       "rel" : "vnicprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/networks/456/labels",
//       "rel" : "labels"
//     } ]
//   } ]
// }
// ----
//
// An example of the XML representation of the same logical network:
//
// [source,xml]
// ----
// <network href="/ovirt-engine/api/networks/456" id="456">
//   <name>ovirtmgmt</name>
//   <description>Management Network</description>
//   <link href="/ovirt-engine/api/networks/456/permissions" rel="permissions"/>
//   <link href="/ovirt-engine/api/networks/456/vnicprofiles" rel="vnicprofiles"/>
//   <link href="/ovirt-engine/api/networks/456/labels" rel="labels"/>
//   <data_center href="/ovirt-engine/api/datacenters/123" id="123"/>
//   <stp>false</stp>
//   <mtu>0</mtu>
//   <usages>
//     <usage>vm</usage>
//   </usages>
// </network>
// ----
func (p *VnicProfile) SetNetwork(attr *Network) {
	p.network = attr
}

// Network The type for a logical network.
//
// An example of the JSON representation of a logical network:
//
// [source,json]
// ----
// {
//   "network" : [ {
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "stp" : "false",
//     "mtu" : "0",
//     "usages" : {
//       "usage" : [ "vm" ]
//     },
//     "name" : "ovirtmgmt",
//     "description" : "Management Network",
//     "href" : "/ovirt-engine/api/networks/456",
//     "id" : "456",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/networks/456/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/networks/456/vnicprofiles",
//       "rel" : "vnicprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/networks/456/labels",
//       "rel" : "labels"
//     } ]
//   } ]
// }
// ----
//
// An example of the XML representation of the same logical network:
//
// [source,xml]
// ----
// <network href="/ovirt-engine/api/networks/456" id="456">
//   <name>ovirtmgmt</name>
//   <description>Management Network</description>
//   <link href="/ovirt-engine/api/networks/456/permissions" rel="permissions"/>
//   <link href="/ovirt-engine/api/networks/456/vnicprofiles" rel="vnicprofiles"/>
//   <link href="/ovirt-engine/api/networks/456/labels" rel="labels"/>
//   <data_center href="/ovirt-engine/api/datacenters/123" id="123"/>
//   <stp>false</stp>
//   <mtu>0</mtu>
//   <usages>
//     <usage>vm</usage>
//   </usages>
// </network>
// ----
func (p *VnicProfile) Network() (*Network, bool) {
	if p.network != nil {
		return p.network, true
	}
	return nil, false
}

// MustNetwork The type for a logical network.
//
// An example of the JSON representation of a logical network:
//
// [source,json]
// ----
// {
//   "network" : [ {
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "stp" : "false",
//     "mtu" : "0",
//     "usages" : {
//       "usage" : [ "vm" ]
//     },
//     "name" : "ovirtmgmt",
//     "description" : "Management Network",
//     "href" : "/ovirt-engine/api/networks/456",
//     "id" : "456",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/networks/456/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/networks/456/vnicprofiles",
//       "rel" : "vnicprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/networks/456/labels",
//       "rel" : "labels"
//     } ]
//   } ]
// }
// ----
//
// An example of the XML representation of the same logical network:
//
// [source,xml]
// ----
// <network href="/ovirt-engine/api/networks/456" id="456">
//   <name>ovirtmgmt</name>
//   <description>Management Network</description>
//   <link href="/ovirt-engine/api/networks/456/permissions" rel="permissions"/>
//   <link href="/ovirt-engine/api/networks/456/vnicprofiles" rel="vnicprofiles"/>
//   <link href="/ovirt-engine/api/networks/456/labels" rel="labels"/>
//   <data_center href="/ovirt-engine/api/datacenters/123" id="123"/>
//   <stp>false</stp>
//   <mtu>0</mtu>
//   <usages>
//     <usage>vm</usage>
//   </usages>
// </network>
// ----
func (p *VnicProfile) MustNetwork() *Network {
	if p.network == nil {
		panic("the network must not be nil, please use Network() function instead")
	}
	return p.network
}

// SetNetworkFilter Network filters filter packets sent to and from the virtual machine's NIC according to defined rules.
//
// There are several types of network filters supported based on libvirt.
// For more details about the different network filters see https://libvirt.org/firewall.html[here].
//
// In addition to libvirt's network filters, there are two additional network filters:
// The first is called `vdsm-no-mac-spoofing` and is composed of `no-mac-spoofing` and `no-arp-mac-spoofing`.
// The second is called `ovirt-no-filter` and is used when no network filter is to be defined for the virtual machine's NIC.
// The `ovirt-no-filter` network filter is only used for internal implementation, and
// does not exist on the NICs.
//
// This is a example of the XML representation:
//
// [source,xml]
// ----
// <network_filter id="00000019-0019-0019-0019-00000000026c">
//   <name>example-filter</name>
//   <version>
//     <major>4</major>
//     <minor>0</minor>
//     <build>-1</build>
//     <revision>-1</revision>
//   </version>
// </network_filter>
// ----
//
// If any part of the version is not present, it is represented by -1.
func (p *VnicProfile) SetNetworkFilter(attr *NetworkFilter) {
	p.networkFilter = attr
}

// NetworkFilter Network filters filter packets sent to and from the virtual machine's NIC according to defined rules.
//
// There are several types of network filters supported based on libvirt.
// For more details about the different network filters see https://libvirt.org/firewall.html[here].
//
// In addition to libvirt's network filters, there are two additional network filters:
// The first is called `vdsm-no-mac-spoofing` and is composed of `no-mac-spoofing` and `no-arp-mac-spoofing`.
// The second is called `ovirt-no-filter` and is used when no network filter is to be defined for the virtual machine's NIC.
// The `ovirt-no-filter` network filter is only used for internal implementation, and
// does not exist on the NICs.
//
// This is a example of the XML representation:
//
// [source,xml]
// ----
// <network_filter id="00000019-0019-0019-0019-00000000026c">
//   <name>example-filter</name>
//   <version>
//     <major>4</major>
//     <minor>0</minor>
//     <build>-1</build>
//     <revision>-1</revision>
//   </version>
// </network_filter>
// ----
//
// If any part of the version is not present, it is represented by -1.
func (p *VnicProfile) NetworkFilter() (*NetworkFilter, bool) {
	if p.networkFilter != nil {
		return p.networkFilter, true
	}
	return nil, false
}

// MustNetworkFilter Network filters filter packets sent to and from the virtual machine's NIC according to defined rules.
//
// There are several types of network filters supported based on libvirt.
// For more details about the different network filters see https://libvirt.org/firewall.html[here].
//
// In addition to libvirt's network filters, there are two additional network filters:
// The first is called `vdsm-no-mac-spoofing` and is composed of `no-mac-spoofing` and `no-arp-mac-spoofing`.
// The second is called `ovirt-no-filter` and is used when no network filter is to be defined for the virtual machine's NIC.
// The `ovirt-no-filter` network filter is only used for internal implementation, and
// does not exist on the NICs.
//
// This is a example of the XML representation:
//
// [source,xml]
// ----
// <network_filter id="00000019-0019-0019-0019-00000000026c">
//   <name>example-filter</name>
//   <version>
//     <major>4</major>
//     <minor>0</minor>
//     <build>-1</build>
//     <revision>-1</revision>
//   </version>
// </network_filter>
// ----
//
// If any part of the version is not present, it is represented by -1.
func (p *VnicProfile) MustNetworkFilter() *NetworkFilter {
	if p.networkFilter == nil {
		panic("the networkFilter must not be nil, please use NetworkFilter() function instead")
	}
	return p.networkFilter
}

func (p *VnicProfile) SetPassThrough(attr *VnicPassThrough) {
	p.passThrough = attr
}

func (p *VnicProfile) PassThrough() (*VnicPassThrough, bool) {
	if p.passThrough != nil {
		return p.passThrough, true
	}
	return nil, false
}

func (p *VnicProfile) MustPassThrough() *VnicPassThrough {
	if p.passThrough == nil {
		panic("the passThrough must not be nil, please use PassThrough() function instead")
	}
	return p.passThrough
}

func (p *VnicProfile) SetPermissions(attr *PermissionSlice) {
	p.permissions = attr
}

func (p *VnicProfile) Permissions() (*PermissionSlice, bool) {
	if p.permissions != nil {
		return p.permissions, true
	}
	return nil, false
}

func (p *VnicProfile) MustPermissions() *PermissionSlice {
	if p.permissions == nil {
		panic("the permissions must not be nil, please use Permissions() function instead")
	}
	return p.permissions
}

func (p *VnicProfile) SetPortMirroring(attr bool) {
	p.portMirroring = &attr
}

func (p *VnicProfile) PortMirroring() (bool, bool) {
	if p.portMirroring != nil {
		return *p.portMirroring, true
	}
	var zero bool
	return zero, false
}

func (p *VnicProfile) MustPortMirroring() bool {
	if p.portMirroring == nil {
		panic("the portMirroring must not be nil, please use PortMirroring() function instead")
	}
	return *p.portMirroring
}

// SetQos This type represents the attributes to define Quality of service (QoS).
//
// For storage the `type` is <<types/qos_type, storage>>, the attributes `max_throughput`, `max_read_throughput`,
// `max_write_throughput`, `max_iops`, `max_read_iops` and `max_write_iops` are relevant.
//
// For resources with computing capabilities the `type` is <<types/qos_type, cpu>>, the attribute `cpu_limit` is
// relevant.
//
// For virtual machines networks the `type` is <<types/qos_type, network>>, the attributes `inbound_average`,
// `inbound_peak`, `inbound_burst`, `outbound_average`, `outbound_peak` and `outbound_burst` are relevant.
//
// For host networks the `type` is <<types/qos_type, hostnetwork>>, the attributes `outbound_average_linkshare`,
// `outbound_average_upperlimit` and `outbound_average_realtime` are relevant.
func (p *VnicProfile) SetQos(attr *Qos) {
	p.qos = attr
}

// Qos This type represents the attributes to define Quality of service (QoS).
//
// For storage the `type` is <<types/qos_type, storage>>, the attributes `max_throughput`, `max_read_throughput`,
// `max_write_throughput`, `max_iops`, `max_read_iops` and `max_write_iops` are relevant.
//
// For resources with computing capabilities the `type` is <<types/qos_type, cpu>>, the attribute `cpu_limit` is
// relevant.
//
// For virtual machines networks the `type` is <<types/qos_type, network>>, the attributes `inbound_average`,
// `inbound_peak`, `inbound_burst`, `outbound_average`, `outbound_peak` and `outbound_burst` are relevant.
//
// For host networks the `type` is <<types/qos_type, hostnetwork>>, the attributes `outbound_average_linkshare`,
// `outbound_average_upperlimit` and `outbound_average_realtime` are relevant.
func (p *VnicProfile) Qos() (*Qos, bool) {
	if p.qos != nil {
		return p.qos, true
	}
	return nil, false
}

// MustQos This type represents the attributes to define Quality of service (QoS).
//
// For storage the `type` is <<types/qos_type, storage>>, the attributes `max_throughput`, `max_read_throughput`,
// `max_write_throughput`, `max_iops`, `max_read_iops` and `max_write_iops` are relevant.
//
// For resources with computing capabilities the `type` is <<types/qos_type, cpu>>, the attribute `cpu_limit` is
// relevant.
//
// For virtual machines networks the `type` is <<types/qos_type, network>>, the attributes `inbound_average`,
// `inbound_peak`, `inbound_burst`, `outbound_average`, `outbound_peak` and `outbound_burst` are relevant.
//
// For host networks the `type` is <<types/qos_type, hostnetwork>>, the attributes `outbound_average_linkshare`,
// `outbound_average_upperlimit` and `outbound_average_realtime` are relevant.
func (p *VnicProfile) MustQos() *Qos {
	if p.qos == nil {
		panic("the qos must not be nil, please use Qos() function instead")
	}
	return p.qos
}

// VnicProfileMapping Deprecated type that maps an external virtual NIC profile to one that exists in the {engine-name}.
//
// If, for example, the desired virtual NIC profile's mapping includes the following two lines:
//
// [cols="25,35,40"]
// |===
// |Source network name|Source network profile name|Target virtual NIC profile ID
//
// |`red`
// |`gold`
// |`738dd914-8ec8-4a8b-8628-34672a5d449b`
//
// |`blue`
// |`silver`
// |`892a12ec-2028-4451-80aa-ff3bf55d6bac`
//
// |===
//
// The following form is deprecated since 4.2.1 and will be removed in the future:
//
// [source,xml]
// ----
// <vnic_profile_mappings>
//   <vnic_profile_mapping>
//     <source_network_name>red</source_network_name>
//     <source_network_profile_name>gold</source_network_profile_name>
//     <target_vnic_profile id="738dd914-8ec8-4a8b-8628-34672a5d449b"/>
//   </vnic_profile_mapping>
//   <vnic_profile_mapping>
//     <source_network_name>blue</source_network_name>
//     <source_network_profile_name>silver</source_network_profile_name>
//     <target_vnic_profile id="892a12ec-2028-4451-80aa-ff3bf55d6bac"/>
//   </vnic_profile_mapping>
// </vnic_profile_mappings>
// ----
type VnicProfileMapping struct {
	Struct
	sourceNetworkName        *string
	sourceNetworkProfileName *string
	targetVnicProfile        *VnicProfile
}

func (p *VnicProfileMapping) SetSourceNetworkName(attr string) {
	p.sourceNetworkName = &attr
}

func (p *VnicProfileMapping) SourceNetworkName() (string, bool) {
	if p.sourceNetworkName != nil {
		return *p.sourceNetworkName, true
	}
	var zero string
	return zero, false
}

func (p *VnicProfileMapping) MustSourceNetworkName() string {
	if p.sourceNetworkName == nil {
		panic("the sourceNetworkName must not be nil, please use SourceNetworkName() function instead")
	}
	return *p.sourceNetworkName
}

func (p *VnicProfileMapping) SetSourceNetworkProfileName(attr string) {
	p.sourceNetworkProfileName = &attr
}

func (p *VnicProfileMapping) SourceNetworkProfileName() (string, bool) {
	if p.sourceNetworkProfileName != nil {
		return *p.sourceNetworkProfileName, true
	}
	var zero string
	return zero, false
}

func (p *VnicProfileMapping) MustSourceNetworkProfileName() string {
	if p.sourceNetworkProfileName == nil {
		panic("the sourceNetworkProfileName must not be nil, please use SourceNetworkProfileName() function instead")
	}
	return *p.sourceNetworkProfileName
}

// SetTargetVnicProfile A vNIC profile is a collection of settings that can be applied to individual <<types/nic,NIC>>.
func (p *VnicProfileMapping) SetTargetVnicProfile(attr *VnicProfile) {
	p.targetVnicProfile = attr
}

// TargetVnicProfile A vNIC profile is a collection of settings that can be applied to individual <<types/nic,NIC>>.
func (p *VnicProfileMapping) TargetVnicProfile() (*VnicProfile, bool) {
	if p.targetVnicProfile != nil {
		return p.targetVnicProfile, true
	}
	return nil, false
}

// MustTargetVnicProfile A vNIC profile is a collection of settings that can be applied to individual <<types/nic,NIC>>.
func (p *VnicProfileMapping) MustTargetVnicProfile() *VnicProfile {
	if p.targetVnicProfile == nil {
		panic("the targetVnicProfile must not be nil, please use TargetVnicProfile() function instead")
	}
	return p.targetVnicProfile
}

type VolumeGroup struct {
	Struct
	id           *string
	logicalUnits *LogicalUnitSlice
	name         *string
}

func (p *VolumeGroup) SetId(attr string) {
	p.id = &attr
}

func (p *VolumeGroup) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *VolumeGroup) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *VolumeGroup) SetLogicalUnits(attr *LogicalUnitSlice) {
	p.logicalUnits = attr
}

func (p *VolumeGroup) LogicalUnits() (*LogicalUnitSlice, bool) {
	if p.logicalUnits != nil {
		return p.logicalUnits, true
	}
	return nil, false
}

func (p *VolumeGroup) MustLogicalUnits() *LogicalUnitSlice {
	if p.logicalUnits == nil {
		panic("the logicalUnits must not be nil, please use LogicalUnits() function instead")
	}
	return p.logicalUnits
}

func (p *VolumeGroup) SetName(attr string) {
	p.name = &attr
}

func (p *VolumeGroup) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *VolumeGroup) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

// Watchdog This type represents a watchdog configuration.
type Watchdog struct {
	Struct
	action       *WatchdogAction
	comment      *string
	description  *string
	id           *string
	instanceType *InstanceType
	model        *WatchdogModel
	name         *string
	template     *Template
	vm           *Vm
	vms          *VmSlice
}

// SetAction This type describes available watchdog actions.
func (p *Watchdog) SetAction(attr WatchdogAction) {
	p.action = &attr
}

// Action This type describes available watchdog actions.
func (p *Watchdog) Action() (WatchdogAction, bool) {
	if p.action != nil {
		return *p.action, true
	}
	var zero WatchdogAction
	return zero, false
}

// MustAction This type describes available watchdog actions.
func (p *Watchdog) MustAction() WatchdogAction {
	if p.action == nil {
		panic("the action must not be nil, please use Action() function instead")
	}
	return *p.action
}

func (p *Watchdog) SetComment(attr string) {
	p.comment = &attr
}

func (p *Watchdog) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *Watchdog) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *Watchdog) SetDescription(attr string) {
	p.description = &attr
}

func (p *Watchdog) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *Watchdog) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *Watchdog) SetId(attr string) {
	p.id = &attr
}

func (p *Watchdog) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *Watchdog) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

// SetInstanceType Describes the hardware configuration of virtual machines.
//
// For example `medium` instance type includes 1 virtual CPU and 4 GiB of memory. It is a top-level
// entity (e.g. not bound to any data center or cluster). The attributes that are used for instance
// types and are common to virtual machine and template types are:
//
// - `console`
// - `cpu`
// - `custom_cpu_model`
// - `custom_emulated_machine`
// - `display`
// - `high_availability`
// - `io`
// - `memory`
// - `memory_policy`
// - `migration`
// - `migration_downtime`
// - `os`
// - `rng_device`
// - `soundcard_enabled`
// - `usb`
// - `virtio_scsi`
//
// When creating a virtual machine from both an instance type and a template, the virtual machine
// will inherit the hardware configurations from the instance type
//
// NOTE: An instance type inherits it's attributes from the template entity although most template
// attributes are not used in instance types.
func (p *Watchdog) SetInstanceType(attr *InstanceType) {
	p.instanceType = attr
}

// InstanceType Describes the hardware configuration of virtual machines.
//
// For example `medium` instance type includes 1 virtual CPU and 4 GiB of memory. It is a top-level
// entity (e.g. not bound to any data center or cluster). The attributes that are used for instance
// types and are common to virtual machine and template types are:
//
// - `console`
// - `cpu`
// - `custom_cpu_model`
// - `custom_emulated_machine`
// - `display`
// - `high_availability`
// - `io`
// - `memory`
// - `memory_policy`
// - `migration`
// - `migration_downtime`
// - `os`
// - `rng_device`
// - `soundcard_enabled`
// - `usb`
// - `virtio_scsi`
//
// When creating a virtual machine from both an instance type and a template, the virtual machine
// will inherit the hardware configurations from the instance type
//
// NOTE: An instance type inherits it's attributes from the template entity although most template
// attributes are not used in instance types.
func (p *Watchdog) InstanceType() (*InstanceType, bool) {
	if p.instanceType != nil {
		return p.instanceType, true
	}
	return nil, false
}

// MustInstanceType Describes the hardware configuration of virtual machines.
//
// For example `medium` instance type includes 1 virtual CPU and 4 GiB of memory. It is a top-level
// entity (e.g. not bound to any data center or cluster). The attributes that are used for instance
// types and are common to virtual machine and template types are:
//
// - `console`
// - `cpu`
// - `custom_cpu_model`
// - `custom_emulated_machine`
// - `display`
// - `high_availability`
// - `io`
// - `memory`
// - `memory_policy`
// - `migration`
// - `migration_downtime`
// - `os`
// - `rng_device`
// - `soundcard_enabled`
// - `usb`
// - `virtio_scsi`
//
// When creating a virtual machine from both an instance type and a template, the virtual machine
// will inherit the hardware configurations from the instance type
//
// NOTE: An instance type inherits it's attributes from the template entity although most template
// attributes are not used in instance types.
func (p *Watchdog) MustInstanceType() *InstanceType {
	if p.instanceType == nil {
		panic("the instanceType must not be nil, please use InstanceType() function instead")
	}
	return p.instanceType
}

// SetModel This type represents the watchdog model.
func (p *Watchdog) SetModel(attr WatchdogModel) {
	p.model = &attr
}

// Model This type represents the watchdog model.
func (p *Watchdog) Model() (WatchdogModel, bool) {
	if p.model != nil {
		return *p.model, true
	}
	var zero WatchdogModel
	return zero, false
}

// MustModel This type represents the watchdog model.
func (p *Watchdog) MustModel() WatchdogModel {
	if p.model == nil {
		panic("the model must not be nil, please use Model() function instead")
	}
	return *p.model
}

func (p *Watchdog) SetName(attr string) {
	p.name = &attr
}

func (p *Watchdog) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *Watchdog) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

// SetTemplate The type that represents a virtual machine template.
// Templates allow for a rapid instantiation of virtual machines with common configuration and disk states.
func (p *Watchdog) SetTemplate(attr *Template) {
	p.template = attr
}

// Template The type that represents a virtual machine template.
// Templates allow for a rapid instantiation of virtual machines with common configuration and disk states.
func (p *Watchdog) Template() (*Template, bool) {
	if p.template != nil {
		return p.template, true
	}
	return nil, false
}

// MustTemplate The type that represents a virtual machine template.
// Templates allow for a rapid instantiation of virtual machines with common configuration and disk states.
func (p *Watchdog) MustTemplate() *Template {
	if p.template == nil {
		panic("the template must not be nil, please use Template() function instead")
	}
	return p.template
}

// SetVm Represents a virtual machine.
func (p *Watchdog) SetVm(attr *Vm) {
	p.vm = attr
}

// Vm Represents a virtual machine.
func (p *Watchdog) Vm() (*Vm, bool) {
	if p.vm != nil {
		return p.vm, true
	}
	return nil, false
}

// MustVm Represents a virtual machine.
func (p *Watchdog) MustVm() *Vm {
	if p.vm == nil {
		panic("the vm must not be nil, please use Vm() function instead")
	}
	return p.vm
}

func (p *Watchdog) SetVms(attr *VmSlice) {
	p.vms = attr
}

func (p *Watchdog) Vms() (*VmSlice, bool) {
	if p.vms != nil {
		return p.vms, true
	}
	return nil, false
}

func (p *Watchdog) MustVms() *VmSlice {
	if p.vms == nil {
		panic("the vms must not be nil, please use Vms() function instead")
	}
	return p.vms
}

type Weight struct {
	Struct
	comment              *string
	description          *string
	factor               *int64
	id                   *string
	name                 *string
	schedulingPolicy     *SchedulingPolicy
	schedulingPolicyUnit *SchedulingPolicyUnit
}

func (p *Weight) SetComment(attr string) {
	p.comment = &attr
}

func (p *Weight) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *Weight) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *Weight) SetDescription(attr string) {
	p.description = &attr
}

func (p *Weight) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *Weight) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *Weight) SetFactor(attr int64) {
	p.factor = &attr
}

func (p *Weight) Factor() (int64, bool) {
	if p.factor != nil {
		return *p.factor, true
	}
	var zero int64
	return zero, false
}

func (p *Weight) MustFactor() int64 {
	if p.factor == nil {
		panic("the factor must not be nil, please use Factor() function instead")
	}
	return *p.factor
}

func (p *Weight) SetId(attr string) {
	p.id = &attr
}

func (p *Weight) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *Weight) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *Weight) SetName(attr string) {
	p.name = &attr
}

func (p *Weight) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *Weight) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *Weight) SetSchedulingPolicy(attr *SchedulingPolicy) {
	p.schedulingPolicy = attr
}

func (p *Weight) SchedulingPolicy() (*SchedulingPolicy, bool) {
	if p.schedulingPolicy != nil {
		return p.schedulingPolicy, true
	}
	return nil, false
}

func (p *Weight) MustSchedulingPolicy() *SchedulingPolicy {
	if p.schedulingPolicy == nil {
		panic("the schedulingPolicy must not be nil, please use SchedulingPolicy() function instead")
	}
	return p.schedulingPolicy
}

func (p *Weight) SetSchedulingPolicyUnit(attr *SchedulingPolicyUnit) {
	p.schedulingPolicyUnit = attr
}

func (p *Weight) SchedulingPolicyUnit() (*SchedulingPolicyUnit, bool) {
	if p.schedulingPolicyUnit != nil {
		return p.schedulingPolicyUnit, true
	}
	return nil, false
}

func (p *Weight) MustSchedulingPolicyUnit() *SchedulingPolicyUnit {
	if p.schedulingPolicyUnit == nil {
		panic("the schedulingPolicyUnit must not be nil, please use SchedulingPolicyUnit() function instead")
	}
	return p.schedulingPolicyUnit
}

type Fault struct {
	Struct
	detail *string
	reason *string
}

func (p *Fault) SetDetail(attr string) {
	p.detail = &attr
}

func (p *Fault) Detail() (string, bool) {
	if p.detail != nil {
		return *p.detail, true
	}
	var zero string
	return zero, false
}

func (p *Fault) MustDetail() string {
	if p.detail == nil {
		panic("the detail must not be nil, please use Detail() function instead")
	}
	return *p.detail
}

func (p *Fault) SetReason(attr string) {
	p.reason = &attr
}

func (p *Fault) Reason() (string, bool) {
	if p.reason != nil {
		return *p.reason, true
	}
	var zero string
	return zero, false
}

func (p *Fault) MustReason() string {
	if p.reason == nil {
		panic("the reason must not be nil, please use Reason() function instead")
	}
	return *p.reason
}

type GracePeriod struct {
	Struct
	expiry *int64
}

func (p *GracePeriod) SetExpiry(attr int64) {
	p.expiry = &attr
}

func (p *GracePeriod) Expiry() (int64, bool) {
	if p.expiry != nil {
		return *p.expiry, true
	}
	var zero int64
	return zero, false
}

func (p *GracePeriod) MustExpiry() int64 {
	if p.expiry == nil {
		panic("the expiry must not be nil, please use Expiry() function instead")
	}
	return *p.expiry
}

type Action struct {
	Struct
	activate                       *bool
	allowPartialImport             *bool
	async                          *bool
	attachment                     *DiskAttachment
	authorizedKey                  *AuthorizedKey
	autoPinningPolicy              *AutoPinningPolicy
	bricks                         *GlusterBrickSlice
	certificates                   *CertificateSlice
	checkConnectivity              *bool
	clone                          *bool
	clonePermissions               *bool
	cluster                        *Cluster
	collapseSnapshots              *bool
	comment                        *string
	commitOnSuccess                *bool
	connection                     *StorageConnection
	connectivityTimeout            *int64
	dataCenter                     *DataCenter
	deployHostedEngine             *bool
	description                    *string
	details                        *GlusterVolumeProfileDetails
	directory                      *string
	discardSnapshots               *bool
	discoveredTargets              *IscsiDetailsSlice
	disk                           *Disk
	diskProfile                    *DiskProfile
	disks                          *DiskSlice
	exclusive                      *bool
	fault                          *Fault
	fenceType                      *string
	filename                       *string
	filter                         *bool
	fixLayout                      *bool
	force                          *bool
	gracePeriod                    *GracePeriod
	host                           *Host
	id                             *string
	image                          *string
	imageTransfer                  *ImageTransfer
	importAsTemplate               *bool
	isAttached                     *bool
	iscsi                          *IscsiDetails
	iscsiTargets                   []string
	job                            *Job
	lease                          *StorageDomainLease
	logicalUnits                   *LogicalUnitSlice
	maintenanceAfterRestart        *bool
	maintenanceEnabled             *bool
	migrateVmsInAffinityClosure    *bool
	modifiedBonds                  *HostNicSlice
	modifiedLabels                 *NetworkLabelSlice
	modifiedNetworkAttachments     *NetworkAttachmentSlice
	name                           *string
	optimizeCpuSettings            *bool
	option                         *Option
	pause                          *bool
	permission                     *Permission
	powerManagement                *PowerManagement
	proxyTicket                    *ProxyTicket
	quota                          *Quota
	reason                         *string
	reassignBadMacs                *bool
	reboot                         *bool
	registrationConfiguration      *RegistrationConfiguration
	remoteViewerConnectionFile     *string
	removedBonds                   *HostNicSlice
	removedLabels                  *NetworkLabelSlice
	removedNetworkAttachments      *NetworkAttachmentSlice
	resolutionType                 *string
	restoreMemory                  *bool
	rootPassword                   *string
	seal                           *bool
	snapshot                       *Snapshot
	sourceHost                     *Host
	ssh                            *Ssh
	status                         *string
	stopGlusterService             *bool
	storageDomain                  *StorageDomain
	storageDomains                 *StorageDomainSlice
	succeeded                      *bool
	synchronizedNetworkAttachments *NetworkAttachmentSlice
	template                       *Template
	ticket                         *Ticket
	timeout                        *int64
	undeployHostedEngine           *bool
	upgradeAction                  *ClusterUpgradeAction
	useCloudInit                   *bool
	useIgnition                    *bool
	useInitialization              *bool
	useSysprep                     *bool
	virtualFunctionsConfiguration  *HostNicVirtualFunctionsConfiguration
	vm                             *Vm
	vnicProfileMappings            *VnicProfileMappingSlice
	volatile                       *bool
}

func (p *Action) SetActivate(attr bool) {
	p.activate = &attr
}

func (p *Action) Activate() (bool, bool) {
	if p.activate != nil {
		return *p.activate, true
	}
	var zero bool
	return zero, false
}

func (p *Action) MustActivate() bool {
	if p.activate == nil {
		panic("the activate must not be nil, please use Activate() function instead")
	}
	return *p.activate
}

func (p *Action) SetAllowPartialImport(attr bool) {
	p.allowPartialImport = &attr
}

func (p *Action) AllowPartialImport() (bool, bool) {
	if p.allowPartialImport != nil {
		return *p.allowPartialImport, true
	}
	var zero bool
	return zero, false
}

func (p *Action) MustAllowPartialImport() bool {
	if p.allowPartialImport == nil {
		panic("the allowPartialImport must not be nil, please use AllowPartialImport() function instead")
	}
	return *p.allowPartialImport
}

func (p *Action) SetAsync(attr bool) {
	p.async = &attr
}

func (p *Action) Async() (bool, bool) {
	if p.async != nil {
		return *p.async, true
	}
	var zero bool
	return zero, false
}

func (p *Action) MustAsync() bool {
	if p.async == nil {
		panic("the async must not be nil, please use Async() function instead")
	}
	return *p.async
}

// SetAttachment Describes how a disk is attached to a virtual machine.
func (p *Action) SetAttachment(attr *DiskAttachment) {
	p.attachment = attr
}

// Attachment Describes how a disk is attached to a virtual machine.
func (p *Action) Attachment() (*DiskAttachment, bool) {
	if p.attachment != nil {
		return p.attachment, true
	}
	return nil, false
}

// MustAttachment Describes how a disk is attached to a virtual machine.
func (p *Action) MustAttachment() *DiskAttachment {
	if p.attachment == nil {
		panic("the attachment must not be nil, please use Attachment() function instead")
	}
	return p.attachment
}

func (p *Action) SetAuthorizedKey(attr *AuthorizedKey) {
	p.authorizedKey = attr
}

func (p *Action) AuthorizedKey() (*AuthorizedKey, bool) {
	if p.authorizedKey != nil {
		return p.authorizedKey, true
	}
	return nil, false
}

func (p *Action) MustAuthorizedKey() *AuthorizedKey {
	if p.authorizedKey == nil {
		panic("the authorizedKey must not be nil, please use AuthorizedKey() function instead")
	}
	return p.authorizedKey
}

// SetAutoPinningPolicy Type representing what the CPU and NUMA pinning policy is.
func (p *Action) SetAutoPinningPolicy(attr AutoPinningPolicy) {
	p.autoPinningPolicy = &attr
}

// AutoPinningPolicy Type representing what the CPU and NUMA pinning policy is.
func (p *Action) AutoPinningPolicy() (AutoPinningPolicy, bool) {
	if p.autoPinningPolicy != nil {
		return *p.autoPinningPolicy, true
	}
	var zero AutoPinningPolicy
	return zero, false
}

// MustAutoPinningPolicy Type representing what the CPU and NUMA pinning policy is.
func (p *Action) MustAutoPinningPolicy() AutoPinningPolicy {
	if p.autoPinningPolicy == nil {
		panic("the autoPinningPolicy must not be nil, please use AutoPinningPolicy() function instead")
	}
	return *p.autoPinningPolicy
}

func (p *Action) SetBricks(attr *GlusterBrickSlice) {
	p.bricks = attr
}

func (p *Action) Bricks() (*GlusterBrickSlice, bool) {
	if p.bricks != nil {
		return p.bricks, true
	}
	return nil, false
}

func (p *Action) MustBricks() *GlusterBrickSlice {
	if p.bricks == nil {
		panic("the bricks must not be nil, please use Bricks() function instead")
	}
	return p.bricks
}

func (p *Action) SetCertificates(attr *CertificateSlice) {
	p.certificates = attr
}

func (p *Action) Certificates() (*CertificateSlice, bool) {
	if p.certificates != nil {
		return p.certificates, true
	}
	return nil, false
}

func (p *Action) MustCertificates() *CertificateSlice {
	if p.certificates == nil {
		panic("the certificates must not be nil, please use Certificates() function instead")
	}
	return p.certificates
}

func (p *Action) SetCheckConnectivity(attr bool) {
	p.checkConnectivity = &attr
}

func (p *Action) CheckConnectivity() (bool, bool) {
	if p.checkConnectivity != nil {
		return *p.checkConnectivity, true
	}
	var zero bool
	return zero, false
}

func (p *Action) MustCheckConnectivity() bool {
	if p.checkConnectivity == nil {
		panic("the checkConnectivity must not be nil, please use CheckConnectivity() function instead")
	}
	return *p.checkConnectivity
}

func (p *Action) SetClone(attr bool) {
	p.clone = &attr
}

func (p *Action) Clone() (bool, bool) {
	if p.clone != nil {
		return *p.clone, true
	}
	var zero bool
	return zero, false
}

func (p *Action) MustClone() bool {
	if p.clone == nil {
		panic("the clone must not be nil, please use Clone() function instead")
	}
	return *p.clone
}

func (p *Action) SetClonePermissions(attr bool) {
	p.clonePermissions = &attr
}

func (p *Action) ClonePermissions() (bool, bool) {
	if p.clonePermissions != nil {
		return *p.clonePermissions, true
	}
	var zero bool
	return zero, false
}

func (p *Action) MustClonePermissions() bool {
	if p.clonePermissions == nil {
		panic("the clonePermissions must not be nil, please use ClonePermissions() function instead")
	}
	return *p.clonePermissions
}

// SetCluster Type representation of a cluster.
//
// A JSON representation of a cluster:
//
// [source]
// ----
// {
//   "cluster" : [ {
//     "ballooning_enabled" : "false",
//     "cpu" : {
//       "architecture" : "x86_64",
//       "type" : "Intel SandyBridge Family"
//     },
//     "custom_scheduling_policy_properties" : {
//       "property" : [ {
//         "name" : "HighUtilization",
//         "value" : "80"
//       }, {
//         "name" : "CpuOverCommitDurationMinutes",
//         "value" : "2"
//       } ]
//     },
//     "error_handling" : {
//       "on_error" : "migrate"
//     },
//     "fencing_policy" : {
//       "enabled" : "true",
//       "skip_if_connectivity_broken" : {
//         "enabled" : "false",
//         "threshold" : "50"
//       },
//       "skip_if_gluster_bricks_up" : "false",
//       "skip_if_gluster_quorum_not_met" : "false",
//       "skip_if_sd_active" : {
//         "enabled" : "false"
//       }
//     },
//     "gluster_service" : "false",
//     "firewall_type" : "iptables",
//     "ha_reservation" : "false",
//     "ksm" : {
//       "enabled" : "true",
//       "merge_across_nodes" : "true"
//     },
//     "memory_policy" : {
//       "over_commit" : {
//         "percent" : "100"
//       },
//       "transparent_hugepages" : {
//         "enabled" : "true"
//       }
//     },
//     "migration" : {
//       "auto_converge" : "inherit",
//       "bandwidth" : {
//         "assignment_method" : "auto"
//       },
//       "compressed" : "inherit",
//       "policy" : {
//         "id" : "00000000-0000-0000-0000-000000000000"
//       }
//     },
//     "required_rng_sources" : {
//       "required_rng_source" : [ "random" ]
//     },
//     "switch_type" : "legacy",
//     "threads_as_cores" : "false",
//     "trusted_service" : "false",
//     "tunnel_migration" : "false",
//     "version" : {
//       "major" : "4",
//       "minor" : "1"
//     },
//     "virt_service" : "true",
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "mac_pool" : {
//       "href" : "/ovirt-engine/api/macpools/456",
//       "id" : "456"
//     },
//     "scheduling_policy" : {
//       "href" : "/ovirt-engine/api/schedulingpolicies/789",
//       "id" : "789"
//     },
//     "actions" : {
//       "link" : [ {
//         "href" : "/ovirt-engine/api/clusters/234/resetemulatedmachine",
//         "rel" : "resetemulatedmachine"
//       } ]
//     },
//     "name" : "Default",
//     "description" : "The default server cluster",
//     "href" : "/ovirt-engine/api/clusters/234",
//     "id" : "234",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/clusters/234/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/cpuprofiles",
//       "rel" : "cpuprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networkfilters",
//       "rel" : "networkfilters"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networks",
//       "rel" : "networks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/affinitygroups",
//       "rel" : "affinitygroups"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glusterhooks",
//       "rel" : "glusterhooks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glustervolumes",
//       "rel" : "glustervolumes"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/enabledfeatures",
//       "rel" : "enabledfeatures"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/externalnetworkproviders",
//       "rel" : "externalnetworkproviders"
//     } ]
//   } ]
// }
// ----
func (p *Action) SetCluster(attr *Cluster) {
	p.cluster = attr
}

// Cluster Type representation of a cluster.
//
// A JSON representation of a cluster:
//
// [source]
// ----
// {
//   "cluster" : [ {
//     "ballooning_enabled" : "false",
//     "cpu" : {
//       "architecture" : "x86_64",
//       "type" : "Intel SandyBridge Family"
//     },
//     "custom_scheduling_policy_properties" : {
//       "property" : [ {
//         "name" : "HighUtilization",
//         "value" : "80"
//       }, {
//         "name" : "CpuOverCommitDurationMinutes",
//         "value" : "2"
//       } ]
//     },
//     "error_handling" : {
//       "on_error" : "migrate"
//     },
//     "fencing_policy" : {
//       "enabled" : "true",
//       "skip_if_connectivity_broken" : {
//         "enabled" : "false",
//         "threshold" : "50"
//       },
//       "skip_if_gluster_bricks_up" : "false",
//       "skip_if_gluster_quorum_not_met" : "false",
//       "skip_if_sd_active" : {
//         "enabled" : "false"
//       }
//     },
//     "gluster_service" : "false",
//     "firewall_type" : "iptables",
//     "ha_reservation" : "false",
//     "ksm" : {
//       "enabled" : "true",
//       "merge_across_nodes" : "true"
//     },
//     "memory_policy" : {
//       "over_commit" : {
//         "percent" : "100"
//       },
//       "transparent_hugepages" : {
//         "enabled" : "true"
//       }
//     },
//     "migration" : {
//       "auto_converge" : "inherit",
//       "bandwidth" : {
//         "assignment_method" : "auto"
//       },
//       "compressed" : "inherit",
//       "policy" : {
//         "id" : "00000000-0000-0000-0000-000000000000"
//       }
//     },
//     "required_rng_sources" : {
//       "required_rng_source" : [ "random" ]
//     },
//     "switch_type" : "legacy",
//     "threads_as_cores" : "false",
//     "trusted_service" : "false",
//     "tunnel_migration" : "false",
//     "version" : {
//       "major" : "4",
//       "minor" : "1"
//     },
//     "virt_service" : "true",
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "mac_pool" : {
//       "href" : "/ovirt-engine/api/macpools/456",
//       "id" : "456"
//     },
//     "scheduling_policy" : {
//       "href" : "/ovirt-engine/api/schedulingpolicies/789",
//       "id" : "789"
//     },
//     "actions" : {
//       "link" : [ {
//         "href" : "/ovirt-engine/api/clusters/234/resetemulatedmachine",
//         "rel" : "resetemulatedmachine"
//       } ]
//     },
//     "name" : "Default",
//     "description" : "The default server cluster",
//     "href" : "/ovirt-engine/api/clusters/234",
//     "id" : "234",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/clusters/234/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/cpuprofiles",
//       "rel" : "cpuprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networkfilters",
//       "rel" : "networkfilters"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networks",
//       "rel" : "networks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/affinitygroups",
//       "rel" : "affinitygroups"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glusterhooks",
//       "rel" : "glusterhooks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glustervolumes",
//       "rel" : "glustervolumes"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/enabledfeatures",
//       "rel" : "enabledfeatures"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/externalnetworkproviders",
//       "rel" : "externalnetworkproviders"
//     } ]
//   } ]
// }
// ----
func (p *Action) Cluster() (*Cluster, bool) {
	if p.cluster != nil {
		return p.cluster, true
	}
	return nil, false
}

// MustCluster Type representation of a cluster.
//
// A JSON representation of a cluster:
//
// [source]
// ----
// {
//   "cluster" : [ {
//     "ballooning_enabled" : "false",
//     "cpu" : {
//       "architecture" : "x86_64",
//       "type" : "Intel SandyBridge Family"
//     },
//     "custom_scheduling_policy_properties" : {
//       "property" : [ {
//         "name" : "HighUtilization",
//         "value" : "80"
//       }, {
//         "name" : "CpuOverCommitDurationMinutes",
//         "value" : "2"
//       } ]
//     },
//     "error_handling" : {
//       "on_error" : "migrate"
//     },
//     "fencing_policy" : {
//       "enabled" : "true",
//       "skip_if_connectivity_broken" : {
//         "enabled" : "false",
//         "threshold" : "50"
//       },
//       "skip_if_gluster_bricks_up" : "false",
//       "skip_if_gluster_quorum_not_met" : "false",
//       "skip_if_sd_active" : {
//         "enabled" : "false"
//       }
//     },
//     "gluster_service" : "false",
//     "firewall_type" : "iptables",
//     "ha_reservation" : "false",
//     "ksm" : {
//       "enabled" : "true",
//       "merge_across_nodes" : "true"
//     },
//     "memory_policy" : {
//       "over_commit" : {
//         "percent" : "100"
//       },
//       "transparent_hugepages" : {
//         "enabled" : "true"
//       }
//     },
//     "migration" : {
//       "auto_converge" : "inherit",
//       "bandwidth" : {
//         "assignment_method" : "auto"
//       },
//       "compressed" : "inherit",
//       "policy" : {
//         "id" : "00000000-0000-0000-0000-000000000000"
//       }
//     },
//     "required_rng_sources" : {
//       "required_rng_source" : [ "random" ]
//     },
//     "switch_type" : "legacy",
//     "threads_as_cores" : "false",
//     "trusted_service" : "false",
//     "tunnel_migration" : "false",
//     "version" : {
//       "major" : "4",
//       "minor" : "1"
//     },
//     "virt_service" : "true",
//     "data_center" : {
//       "href" : "/ovirt-engine/api/datacenters/123",
//       "id" : "123"
//     },
//     "mac_pool" : {
//       "href" : "/ovirt-engine/api/macpools/456",
//       "id" : "456"
//     },
//     "scheduling_policy" : {
//       "href" : "/ovirt-engine/api/schedulingpolicies/789",
//       "id" : "789"
//     },
//     "actions" : {
//       "link" : [ {
//         "href" : "/ovirt-engine/api/clusters/234/resetemulatedmachine",
//         "rel" : "resetemulatedmachine"
//       } ]
//     },
//     "name" : "Default",
//     "description" : "The default server cluster",
//     "href" : "/ovirt-engine/api/clusters/234",
//     "id" : "234",
//     "link" : [ {
//       "href" : "/ovirt-engine/api/clusters/234/permissions",
//       "rel" : "permissions"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/cpuprofiles",
//       "rel" : "cpuprofiles"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networkfilters",
//       "rel" : "networkfilters"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/networks",
//       "rel" : "networks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/affinitygroups",
//       "rel" : "affinitygroups"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glusterhooks",
//       "rel" : "glusterhooks"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/glustervolumes",
//       "rel" : "glustervolumes"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/enabledfeatures",
//       "rel" : "enabledfeatures"
//     }, {
//       "href" : "/ovirt-engine/api/clusters/234/externalnetworkproviders",
//       "rel" : "externalnetworkproviders"
//     } ]
//   } ]
// }
// ----
func (p *Action) MustCluster() *Cluster {
	if p.cluster == nil {
		panic("the cluster must not be nil, please use Cluster() function instead")
	}
	return p.cluster
}

func (p *Action) SetCollapseSnapshots(attr bool) {
	p.collapseSnapshots = &attr
}

func (p *Action) CollapseSnapshots() (bool, bool) {
	if p.collapseSnapshots != nil {
		return *p.collapseSnapshots, true
	}
	var zero bool
	return zero, false
}

func (p *Action) MustCollapseSnapshots() bool {
	if p.collapseSnapshots == nil {
		panic("the collapseSnapshots must not be nil, please use CollapseSnapshots() function instead")
	}
	return *p.collapseSnapshots
}

func (p *Action) SetComment(attr string) {
	p.comment = &attr
}

func (p *Action) Comment() (string, bool) {
	if p.comment != nil {
		return *p.comment, true
	}
	var zero string
	return zero, false
}

func (p *Action) MustComment() string {
	if p.comment == nil {
		panic("the comment must not be nil, please use Comment() function instead")
	}
	return *p.comment
}

func (p *Action) SetCommitOnSuccess(attr bool) {
	p.commitOnSuccess = &attr
}

func (p *Action) CommitOnSuccess() (bool, bool) {
	if p.commitOnSuccess != nil {
		return *p.commitOnSuccess, true
	}
	var zero bool
	return zero, false
}

func (p *Action) MustCommitOnSuccess() bool {
	if p.commitOnSuccess == nil {
		panic("the commitOnSuccess must not be nil, please use CommitOnSuccess() function instead")
	}
	return *p.commitOnSuccess
}

// SetConnection Represents a storage server connection.
//
// Example XML representation:
//
// [source,xml]
// ----
// <storage_connection id="123">
//   <address>mynfs.example.com</address>
//   <type>nfs</type>
//   <path>/exports/mydata</path>
// </storage_connection>
// ----
func (p *Action) SetConnection(attr *StorageConnection) {
	p.connection = attr
}

// Connection Represents a storage server connection.
//
// Example XML representation:
//
// [source,xml]
// ----
// <storage_connection id="123">
//   <address>mynfs.example.com</address>
//   <type>nfs</type>
//   <path>/exports/mydata</path>
// </storage_connection>
// ----
func (p *Action) Connection() (*StorageConnection, bool) {
	if p.connection != nil {
		return p.connection, true
	}
	return nil, false
}

// MustConnection Represents a storage server connection.
//
// Example XML representation:
//
// [source,xml]
// ----
// <storage_connection id="123">
//   <address>mynfs.example.com</address>
//   <type>nfs</type>
//   <path>/exports/mydata</path>
// </storage_connection>
// ----
func (p *Action) MustConnection() *StorageConnection {
	if p.connection == nil {
		panic("the connection must not be nil, please use Connection() function instead")
	}
	return p.connection
}

func (p *Action) SetConnectivityTimeout(attr int64) {
	p.connectivityTimeout = &attr
}

func (p *Action) ConnectivityTimeout() (int64, bool) {
	if p.connectivityTimeout != nil {
		return *p.connectivityTimeout, true
	}
	var zero int64
	return zero, false
}

func (p *Action) MustConnectivityTimeout() int64 {
	if p.connectivityTimeout == nil {
		panic("the connectivityTimeout must not be nil, please use ConnectivityTimeout() function instead")
	}
	return *p.connectivityTimeout
}

func (p *Action) SetDataCenter(attr *DataCenter) {
	p.dataCenter = attr
}

func (p *Action) DataCenter() (*DataCenter, bool) {
	if p.dataCenter != nil {
		return p.dataCenter, true
	}
	return nil, false
}

func (p *Action) MustDataCenter() *DataCenter {
	if p.dataCenter == nil {
		panic("the dataCenter must not be nil, please use DataCenter() function instead")
	}
	return p.dataCenter
}

func (p *Action) SetDeployHostedEngine(attr bool) {
	p.deployHostedEngine = &attr
}

func (p *Action) DeployHostedEngine() (bool, bool) {
	if p.deployHostedEngine != nil {
		return *p.deployHostedEngine, true
	}
	var zero bool
	return zero, false
}

func (p *Action) MustDeployHostedEngine() bool {
	if p.deployHostedEngine == nil {
		panic("the deployHostedEngine must not be nil, please use DeployHostedEngine() function instead")
	}
	return *p.deployHostedEngine
}

func (p *Action) SetDescription(attr string) {
	p.description = &attr
}

func (p *Action) Description() (string, bool) {
	if p.description != nil {
		return *p.description, true
	}
	var zero string
	return zero, false
}

func (p *Action) MustDescription() string {
	if p.description == nil {
		panic("the description must not be nil, please use Description() function instead")
	}
	return *p.description
}

func (p *Action) SetDetails(attr *GlusterVolumeProfileDetails) {
	p.details = attr
}

func (p *Action) Details() (*GlusterVolumeProfileDetails, bool) {
	if p.details != nil {
		return p.details, true
	}
	return nil, false
}

func (p *Action) MustDetails() *GlusterVolumeProfileDetails {
	if p.details == nil {
		panic("the details must not be nil, please use Details() function instead")
	}
	return p.details
}

func (p *Action) SetDirectory(attr string) {
	p.directory = &attr
}

func (p *Action) Directory() (string, bool) {
	if p.directory != nil {
		return *p.directory, true
	}
	var zero string
	return zero, false
}

func (p *Action) MustDirectory() string {
	if p.directory == nil {
		panic("the directory must not be nil, please use Directory() function instead")
	}
	return *p.directory
}

func (p *Action) SetDiscardSnapshots(attr bool) {
	p.discardSnapshots = &attr
}

func (p *Action) DiscardSnapshots() (bool, bool) {
	if p.discardSnapshots != nil {
		return *p.discardSnapshots, true
	}
	var zero bool
	return zero, false
}

func (p *Action) MustDiscardSnapshots() bool {
	if p.discardSnapshots == nil {
		panic("the discardSnapshots must not be nil, please use DiscardSnapshots() function instead")
	}
	return *p.discardSnapshots
}

func (p *Action) SetDiscoveredTargets(attr *IscsiDetailsSlice) {
	p.discoveredTargets = attr
}

func (p *Action) DiscoveredTargets() (*IscsiDetailsSlice, bool) {
	if p.discoveredTargets != nil {
		return p.discoveredTargets, true
	}
	return nil, false
}

func (p *Action) MustDiscoveredTargets() *IscsiDetailsSlice {
	if p.discoveredTargets == nil {
		panic("the discoveredTargets must not be nil, please use DiscoveredTargets() function instead")
	}
	return p.discoveredTargets
}

// SetDisk Represents a virtual disk device.
func (p *Action) SetDisk(attr *Disk) {
	p.disk = attr
}

// Disk Represents a virtual disk device.
func (p *Action) Disk() (*Disk, bool) {
	if p.disk != nil {
		return p.disk, true
	}
	return nil, false
}

// MustDisk Represents a virtual disk device.
func (p *Action) MustDisk() *Disk {
	if p.disk == nil {
		panic("the disk must not be nil, please use Disk() function instead")
	}
	return p.disk
}

func (p *Action) SetDiskProfile(attr *DiskProfile) {
	p.diskProfile = attr
}

func (p *Action) DiskProfile() (*DiskProfile, bool) {
	if p.diskProfile != nil {
		return p.diskProfile, true
	}
	return nil, false
}

func (p *Action) MustDiskProfile() *DiskProfile {
	if p.diskProfile == nil {
		panic("the diskProfile must not be nil, please use DiskProfile() function instead")
	}
	return p.diskProfile
}

func (p *Action) SetDisks(attr *DiskSlice) {
	p.disks = attr
}

func (p *Action) Disks() (*DiskSlice, bool) {
	if p.disks != nil {
		return p.disks, true
	}
	return nil, false
}

func (p *Action) MustDisks() *DiskSlice {
	if p.disks == nil {
		panic("the disks must not be nil, please use Disks() function instead")
	}
	return p.disks
}

func (p *Action) SetExclusive(attr bool) {
	p.exclusive = &attr
}

func (p *Action) Exclusive() (bool, bool) {
	if p.exclusive != nil {
		return *p.exclusive, true
	}
	var zero bool
	return zero, false
}

func (p *Action) MustExclusive() bool {
	if p.exclusive == nil {
		panic("the exclusive must not be nil, please use Exclusive() function instead")
	}
	return *p.exclusive
}

func (p *Action) SetFault(attr *Fault) {
	p.fault = attr
}

func (p *Action) Fault() (*Fault, bool) {
	if p.fault != nil {
		return p.fault, true
	}
	return nil, false
}

func (p *Action) MustFault() *Fault {
	if p.fault == nil {
		panic("the fault must not be nil, please use Fault() function instead")
	}
	return p.fault
}

func (p *Action) SetFenceType(attr string) {
	p.fenceType = &attr
}

func (p *Action) FenceType() (string, bool) {
	if p.fenceType != nil {
		return *p.fenceType, true
	}
	var zero string
	return zero, false
}

func (p *Action) MustFenceType() string {
	if p.fenceType == nil {
		panic("the fenceType must not be nil, please use FenceType() function instead")
	}
	return *p.fenceType
}

func (p *Action) SetFilename(attr string) {
	p.filename = &attr
}

func (p *Action) Filename() (string, bool) {
	if p.filename != nil {
		return *p.filename, true
	}
	var zero string
	return zero, false
}

func (p *Action) MustFilename() string {
	if p.filename == nil {
		panic("the filename must not be nil, please use Filename() function instead")
	}
	return *p.filename
}

func (p *Action) SetFilter(attr bool) {
	p.filter = &attr
}

func (p *Action) Filter() (bool, bool) {
	if p.filter != nil {
		return *p.filter, true
	}
	var zero bool
	return zero, false
}

func (p *Action) MustFilter() bool {
	if p.filter == nil {
		panic("the filter must not be nil, please use Filter() function instead")
	}
	return *p.filter
}

func (p *Action) SetFixLayout(attr bool) {
	p.fixLayout = &attr
}

func (p *Action) FixLayout() (bool, bool) {
	if p.fixLayout != nil {
		return *p.fixLayout, true
	}
	var zero bool
	return zero, false
}

func (p *Action) MustFixLayout() bool {
	if p.fixLayout == nil {
		panic("the fixLayout must not be nil, please use FixLayout() function instead")
	}
	return *p.fixLayout
}

func (p *Action) SetForce(attr bool) {
	p.force = &attr
}

func (p *Action) Force() (bool, bool) {
	if p.force != nil {
		return *p.force, true
	}
	var zero bool
	return zero, false
}

func (p *Action) MustForce() bool {
	if p.force == nil {
		panic("the force must not be nil, please use Force() function instead")
	}
	return *p.force
}

func (p *Action) SetGracePeriod(attr *GracePeriod) {
	p.gracePeriod = attr
}

func (p *Action) GracePeriod() (*GracePeriod, bool) {
	if p.gracePeriod != nil {
		return p.gracePeriod, true
	}
	return nil, false
}

func (p *Action) MustGracePeriod() *GracePeriod {
	if p.gracePeriod == nil {
		panic("the gracePeriod must not be nil, please use GracePeriod() function instead")
	}
	return p.gracePeriod
}

// SetHost Type representing a host.
func (p *Action) SetHost(attr *Host) {
	p.host = attr
}

// Host Type representing a host.
func (p *Action) Host() (*Host, bool) {
	if p.host != nil {
		return p.host, true
	}
	return nil, false
}

// MustHost Type representing a host.
func (p *Action) MustHost() *Host {
	if p.host == nil {
		panic("the host must not be nil, please use Host() function instead")
	}
	return p.host
}

func (p *Action) SetId(attr string) {
	p.id = &attr
}

func (p *Action) Id() (string, bool) {
	if p.id != nil {
		return *p.id, true
	}
	var zero string
	return zero, false
}

func (p *Action) MustId() string {
	if p.id == nil {
		panic("the id must not be nil, please use Id() function instead")
	}
	return *p.id
}

func (p *Action) SetImage(attr string) {
	p.image = &attr
}

func (p *Action) Image() (string, bool) {
	if p.image != nil {
		return *p.image, true
	}
	var zero string
	return zero, false
}

func (p *Action) MustImage() string {
	if p.image == nil {
		panic("the image must not be nil, please use Image() function instead")
	}
	return *p.image
}

// SetImageTransfer This type contains information regarding an image transfer being performed.
func (p *Action) SetImageTransfer(attr *ImageTransfer) {
	p.imageTransfer = attr
}

// ImageTransfer This type contains information regarding an image transfer being performed.
func (p *Action) ImageTransfer() (*ImageTransfer, bool) {
	if p.imageTransfer != nil {
		return p.imageTransfer, true
	}
	return nil, false
}

// MustImageTransfer This type contains information regarding an image transfer being performed.
func (p *Action) MustImageTransfer() *ImageTransfer {
	if p.imageTransfer == nil {
		panic("the imageTransfer must not be nil, please use ImageTransfer() function instead")
	}
	return p.imageTransfer
}

func (p *Action) SetImportAsTemplate(attr bool) {
	p.importAsTemplate = &attr
}

func (p *Action) ImportAsTemplate() (bool, bool) {
	if p.importAsTemplate != nil {
		return *p.importAsTemplate, true
	}
	var zero bool
	return zero, false
}

func (p *Action) MustImportAsTemplate() bool {
	if p.importAsTemplate == nil {
		panic("the importAsTemplate must not be nil, please use ImportAsTemplate() function instead")
	}
	return *p.importAsTemplate
}

func (p *Action) SetIsAttached(attr bool) {
	p.isAttached = &attr
}

func (p *Action) IsAttached() (bool, bool) {
	if p.isAttached != nil {
		return *p.isAttached, true
	}
	var zero bool
	return zero, false
}

func (p *Action) MustIsAttached() bool {
	if p.isAttached == nil {
		panic("the isAttached must not be nil, please use IsAttached() function instead")
	}
	return *p.isAttached
}

func (p *Action) SetIscsi(attr *IscsiDetails) {
	p.iscsi = attr
}

func (p *Action) Iscsi() (*IscsiDetails, bool) {
	if p.iscsi != nil {
		return p.iscsi, true
	}
	return nil, false
}

func (p *Action) MustIscsi() *IscsiDetails {
	if p.iscsi == nil {
		panic("the iscsi must not be nil, please use Iscsi() function instead")
	}
	return p.iscsi
}

func (p *Action) SetIscsiTargets(attr []string) {
	p.iscsiTargets = attr
}

func (p *Action) IscsiTargets() ([]string, bool) {
	if p.iscsiTargets != nil {
		return p.iscsiTargets, true
	}
	return nil, false
}

func (p *Action) MustIscsiTargets() []string {
	if p.iscsiTargets == nil {
		panic("the iscsiTargets must not be nil, please use IscsiTargets() function instead")
	}
	return p.iscsiTargets
}

// SetJob Represents a job, which monitors execution of a flow in the system.
// A job can contain multiple steps in a hierarchic structure.
// The steps can be processed in parallel, depends on the implementation of the flow.
func (p *Action) SetJob(attr *Job) {
	p.job = attr
}

// Job Represents a job, which monitors execution of a flow in the system.
// A job can contain multiple steps in a hierarchic structure.
// The steps can be processed in parallel, depends on the implementation of the flow.
func (p *Action) Job() (*Job, bool) {
	if p.job != nil {
		return p.job, true
	}
	return nil, false
}

// MustJob Represents a job, which monitors execution of a flow in the system.
// A job can contain multiple steps in a hierarchic structure.
// The steps can be processed in parallel, depends on the implementation of the flow.
func (p *Action) MustJob() *Job {
	if p.job == nil {
		panic("the job must not be nil, please use Job() function instead")
	}
	return p.job
}

// SetLease Represents a lease residing on a storage domain.
//
// A lease is a http://www.ovirt.org/develop/developer-guide/vdsm/sanlock[Sanlock] resource residing on a special
// volume on the storage domain, this Sanlock resource is used to provide storage base locking.
func (p *Action) SetLease(attr *StorageDomainLease) {
	p.lease = attr
}

// Lease Represents a lease residing on a storage domain.
//
// A lease is a http://www.ovirt.org/develop/developer-guide/vdsm/sanlock[Sanlock] resource residing on a special
// volume on the storage domain, this Sanlock resource is used to provide storage base locking.
func (p *Action) Lease() (*StorageDomainLease, bool) {
	if p.lease != nil {
		return p.lease, true
	}
	return nil, false
}

// MustLease Represents a lease residing on a storage domain.
//
// A lease is a http://www.ovirt.org/develop/developer-guide/vdsm/sanlock[Sanlock] resource residing on a special
// volume on the storage domain, this Sanlock resource is used to provide storage base locking.
func (p *Action) MustLease() *StorageDomainLease {
	if p.lease == nil {
		panic("the lease must not be nil, please use Lease() function instead")
	}
	return p.lease
}

func (p *Action) SetLogicalUnits(attr *LogicalUnitSlice) {
	p.logicalUnits = attr
}

func (p *Action) LogicalUnits() (*LogicalUnitSlice, bool) {
	if p.logicalUnits != nil {
		return p.logicalUnits, true
	}
	return nil, false
}

func (p *Action) MustLogicalUnits() *LogicalUnitSlice {
	if p.logicalUnits == nil {
		panic("the logicalUnits must not be nil, please use LogicalUnits() function instead")
	}
	return p.logicalUnits
}

func (p *Action) SetMaintenanceAfterRestart(attr bool) {
	p.maintenanceAfterRestart = &attr
}

func (p *Action) MaintenanceAfterRestart() (bool, bool) {
	if p.maintenanceAfterRestart != nil {
		return *p.maintenanceAfterRestart, true
	}
	var zero bool
	return zero, false
}

func (p *Action) MustMaintenanceAfterRestart() bool {
	if p.maintenanceAfterRestart == nil {
		panic("the maintenanceAfterRestart must not be nil, please use MaintenanceAfterRestart() function instead")
	}
	return *p.maintenanceAfterRestart
}

func (p *Action) SetMaintenanceEnabled(attr bool) {
	p.maintenanceEnabled = &attr
}

func (p *Action) MaintenanceEnabled() (bool, bool) {
	if p.maintenanceEnabled != nil {
		return *p.maintenanceEnabled, true
	}
	var zero bool
	return zero, false
}

func (p *Action) MustMaintenanceEnabled() bool {
	if p.maintenanceEnabled == nil {
		panic("the maintenanceEnabled must not be nil, please use MaintenanceEnabled() function instead")
	}
	return *p.maintenanceEnabled
}

func (p *Action) SetMigrateVmsInAffinityClosure(attr bool) {
	p.migrateVmsInAffinityClosure = &attr
}

func (p *Action) MigrateVmsInAffinityClosure() (bool, bool) {
	if p.migrateVmsInAffinityClosure != nil {
		return *p.migrateVmsInAffinityClosure, true
	}
	var zero bool
	return zero, false
}

func (p *Action) MustMigrateVmsInAffinityClosure() bool {
	if p.migrateVmsInAffinityClosure == nil {
		panic("the migrateVmsInAffinityClosure must not be nil, please use MigrateVmsInAffinityClosure() function instead")
	}
	return *p.migrateVmsInAffinityClosure
}

func (p *Action) SetModifiedBonds(attr *HostNicSlice) {
	p.modifiedBonds = attr
}

func (p *Action) ModifiedBonds() (*HostNicSlice, bool) {
	if p.modifiedBonds != nil {
		return p.modifiedBonds, true
	}
	return nil, false
}

func (p *Action) MustModifiedBonds() *HostNicSlice {
	if p.modifiedBonds == nil {
		panic("the modifiedBonds must not be nil, please use ModifiedBonds() function instead")
	}
	return p.modifiedBonds
}

func (p *Action) SetModifiedLabels(attr *NetworkLabelSlice) {
	p.modifiedLabels = attr
}

func (p *Action) ModifiedLabels() (*NetworkLabelSlice, bool) {
	if p.modifiedLabels != nil {
		return p.modifiedLabels, true
	}
	return nil, false
}

func (p *Action) MustModifiedLabels() *NetworkLabelSlice {
	if p.modifiedLabels == nil {
		panic("the modifiedLabels must not be nil, please use ModifiedLabels() function instead")
	}
	return p.modifiedLabels
}

func (p *Action) SetModifiedNetworkAttachments(attr *NetworkAttachmentSlice) {
	p.modifiedNetworkAttachments = attr
}

func (p *Action) ModifiedNetworkAttachments() (*NetworkAttachmentSlice, bool) {
	if p.modifiedNetworkAttachments != nil {
		return p.modifiedNetworkAttachments, true
	}
	return nil, false
}

func (p *Action) MustModifiedNetworkAttachments() *NetworkAttachmentSlice {
	if p.modifiedNetworkAttachments == nil {
		panic("the modifiedNetworkAttachments must not be nil, please use ModifiedNetworkAttachments() function instead")
	}
	return p.modifiedNetworkAttachments
}

func (p *Action) SetName(attr string) {
	p.name = &attr
}

func (p *Action) Name() (string, bool) {
	if p.name != nil {
		return *p.name, true
	}
	var zero string
	return zero, false
}

func (p *Action) MustName() string {
	if p.name == nil {
		panic("the name must not be nil, please use Name() function instead")
	}
	return *p.name
}

func (p *Action) SetOptimizeCpuSettings(attr bool) {
	p.optimizeCpuSettings = &attr
}

func (p *Action) OptimizeCpuSettings() (bool, bool) {
	if p.optimizeCpuSettings != nil {
		return *p.optimizeCpuSettings, true
	}
	var zero bool
	return zero, false
}

func (p *Action) MustOptimizeCpuSettings() bool {
	if p.optimizeCpuSettings == nil {
		panic("the optimizeCpuSettings must not be nil, please use OptimizeCpuSettings() function instead")
	}
	return *p.optimizeCpuSettings
}

func (p *Action) SetOption(attr *Option) {
	p.option = attr
}

func (p *Action) Option() (*Option, bool) {
	if p.option != nil {
		return p.option, true
	}
	return nil, false
}

func (p *Action) MustOption() *Option {
	if p.option == nil {
		panic("the option must not be nil, please use Option() function instead")
	}
	return p.option
}

func (p *Action) SetPause(attr bool) {
	p.pause = &attr
}

func (p *Action) Pause() (bool, bool) {
	if p.pause != nil {
		return *p.pause, true
	}
	var zero bool
	return zero, false
}

func (p *Action) MustPause() bool {
	if p.pause == nil {
		panic("the pause must not be nil, please use Pause() function instead")
	}
	return *p.pause
}

// SetPermission Type represents a permission.
func (p *Action) SetPermission(attr *Permission) {
	p.permission = attr
}

// Permission Type represents a permission.
func (p *Action) Permission() (*Permission, bool) {
	if p.permission != nil {
		return p.permission, true
	}
	return nil, false
}

// MustPermission Type represents a permission.
func (p *Action) MustPermission() *Permission {
	if p.permission == nil {
		panic("the permission must not be nil, please use Permission() function instead")
	}
	return p.permission
}

func (p *Action) SetPowerManagement(attr *PowerManagement) {
	p.powerManagement = attr
}

func (p *Action) PowerManagement() (*PowerManagement, bool) {
	if p.powerManagement != nil {
		return p.powerManagement, true
	}
	return nil, false
}

func (p *Action) MustPowerManagement() *PowerManagement {
	if p.powerManagement == nil {
		panic("the powerManagement must not be nil, please use PowerManagement() function instead")
	}
	return p.powerManagement
}

func (p *Action) SetProxyTicket(attr *ProxyTicket) {
	p.proxyTicket = attr
}

func (p *Action) ProxyTicket() (*ProxyTicket, bool) {
	if p.proxyTicket != nil {
		return p.proxyTicket, true
	}
	return nil, false
}

func (p *Action) MustProxyTicket() *ProxyTicket {
	if p.proxyTicket == nil {
		panic("the proxyTicket must not be nil, please use ProxyTicket() function instead")
	}
	return p.proxyTicket
}

// SetQuota Represents a quota object.
//
// An example XML representation of a quota:
//
// [source,xml]
// ----
// <quota href="/ovirt-engine/api/datacenters/7044934e/quotas/dcad5ddc" id="dcad5ddc">
//   <name>My Quota</name>
//   <description>A quota for my oVirt environment</description>
//   <cluster_hard_limit_pct>0</cluster_hard_limit_pct>
//   <cluster_soft_limit_pct>0</cluster_soft_limit_pct>
//   <data_center href="/ovirt-engine/api/datacenters/7044934e" id="7044934e"/>
//   <storage_hard_limit_pct>0</storage_hard_limit_pct>
//   <storage_soft_limit_pct>0</storage_soft_limit_pct>
// </quota>
// ----
func (p *Action) SetQuota(attr *Quota) {
	p.quota = attr
}

// Quota Represents a quota object.
//
// An example XML representation of a quota:
//
// [source,xml]
// ----
// <quota href="/ovirt-engine/api/datacenters/7044934e/quotas/dcad5ddc" id="dcad5ddc">
//   <name>My Quota</name>
//   <description>A quota for my oVirt environment</description>
//   <cluster_hard_limit_pct>0</cluster_hard_limit_pct>
//   <cluster_soft_limit_pct>0</cluster_soft_limit_pct>
//   <data_center href="/ovirt-engine/api/datacenters/7044934e" id="7044934e"/>
//   <storage_hard_limit_pct>0</storage_hard_limit_pct>
//   <storage_soft_limit_pct>0</storage_soft_limit_pct>
// </quota>
// ----
func (p *Action) Quota() (*Quota, bool) {
	if p.quota != nil {
		return p.quota, true
	}
	return nil, false
}

// MustQuota Represents a quota object.
//
// An example XML representation of a quota:
//
// [source,xml]
// ----
// <quota href="/ovirt-engine/api/datacenters/7044934e/quotas/dcad5ddc" id="dcad5ddc">
//   <name>My Quota</name>
//   <description>A quota for my oVirt environment</description>
//   <cluster_hard_limit_pct>0</cluster_hard_limit_pct>
//   <cluster_soft_limit_pct>0</cluster_soft_limit_pct>
//   <data_center href="/ovirt-engine/api/datacenters/7044934e" id="7044934e"/>
//   <storage_hard_limit_pct>0</storage_hard_limit_pct>
//   <storage_soft_limit_pct>0</storage_soft_limit_pct>
// </quota>
// ----
func (p *Action) MustQuota() *Quota {
	if p.quota == nil {
		panic("the quota must not be nil, please use Quota() function instead")
	}
	return p.quota
}

func (p *Action) SetReason(attr string) {
	p.reason = &attr
}

func (p *Action) Reason() (string, bool) {
	if p.reason != nil {
		return *p.reason, true
	}
	var zero string
	return zero, false
}

func (p *Action) MustReason() string {
	if p.reason == nil {
		panic("the reason must not be nil, please use Reason() function instead")
	}
	return *p.reason
}

func (p *Action) SetReassignBadMacs(attr bool) {
	p.reassignBadMacs = &attr
}

func (p *Action) ReassignBadMacs() (bool, bool) {
	if p.reassignBadMacs != nil {
		return *p.reassignBadMacs, true
	}
	var zero bool
	return zero, false
}

func (p *Action) MustReassignBadMacs() bool {
	if p.reassignBadMacs == nil {
		panic("the reassignBadMacs must not be nil, please use ReassignBadMacs() function instead")
	}
	return *p.reassignBadMacs
}

func (p *Action) SetReboot(attr bool) {
	p.reboot = &attr
}

func (p *Action) Reboot() (bool, bool) {
	if p.reboot != nil {
		return *p.reboot, true
	}
	var zero bool
	return zero, false
}

func (p *Action) MustReboot() bool {
	if p.reboot == nil {
		panic("the reboot must not be nil, please use Reboot() function instead")
	}
	return *p.reboot
}

// SetRegistrationConfiguration This type describes how an object (virtual machine, template,
// etc) is registered, and is used for the implementation of disaster recovery solutions.
//
// Each mapping contained in this type can be used to map
// objects in the original system to corresponding objects
// in the system where the virtual machine or template is being registered.
// For example, there could be a primary setup with a virtual machine
// configured on cluster A, and an active secondary setup with cluster B.
// Cluster B is compatible with that virtual machine, and in case of a
// disaster recovery scenario the storage domain can be
// imported to the secondary setup, and the user can register the
// virtual machine to cluster B.
//
// In that case, we can automate the recovery process by defining a cluster mapping.
// After the entity is registered, its OVF will indicate it belongs to
// cluster A, but the mapping will indicate that cluster A will
// be replaced with cluster B.
// {engine-name} should do the switch and register the virtual machine to cluster B
// in the secondary site.
//
// Cluster mapping is just one example, there are different types of mappings:
//
// - Cluster mapping.
// - LUN mapping.
// - Role mapping.
// - Domain mapping.
// - Permissions mapping.
// - Affinity Group mapping.
// - Affinity Label mapping.
// - Virtual NIC profile mapping.
//
// Each mapping will be used for its specific OVF's data once the register operation
// takes place in the {engine-name}.
//
// An example of an XML representation using the mapping:
//
// [source,xml]
// ----
// <action>
//   <registration_configuration>
//     <cluster_mappings>
//       <registration_cluster_mapping>
//         <from>
//           <name>myoriginalcluster</name>
//         </from>
//         <to>
//           <name>mynewcluster</name>
//         </to>
//       </registration_cluster_mapping>
//     </cluster_mappings>
//     <role_mappings>
//       <registration_role_mapping>
//         <from>
//           <name>SuperUser</name>
//         </from>
//         <to>
//           <name>UserVmRunTimeManager</name>
//         </to>
//       </registration_role_mapping>
//     </role_mappings>
//     <domain_mappings>
//       <registration_domain_mapping>
//         <from>
//           <name>redhat</name>
//         </from>
//         <to>
//           <name>internal</name>
//         </to>
//       </registration_domain_mapping>
//     </domain_mappings>
//     <lun_mappings>
//      <registration_lun_mapping>
//        <from id="111">
//        </from>
//        <to id="222">
//          <alias>weTestLun</alias>
//          <lun_storage>
//            <type>iscsi</type>
//            <logical_units>
//               <logical_unit id="36001405fb1ddb4b91e44078f1fffcfef">
//                  <address>44.33.11.22</address>
//                  <port>3260</port>
//                  <portal>1</portal>
//                  <target>iqn.2017-11.com.name.redhat:444</target>
//               </logical_unit>
//            </logical_units>
//          </lun_storage>
//        </to>
//      </registration_lun_mapping>
//     </lun_mappings>
//     <affinity_group_mappings>
//      <registration_affinity_group_mapping>
//        <from>
//          <name>affinity</name>
//        </from>
//        <to>
//          <name>affinity2</name>
//        </to>
//      </registration_affinity_group_mapping>
//     </affinity_group_mappings>
//     <affinity_label_mappings>
//      <registration_affinity_label_mapping>
//        <from>
//          <name>affinity_label</name>
//        </from>
//        <to>
//          <name>affinity_label2</name>
//        </to>
//      </registration_affinity_label_mapping>
//     </affinity_label_mappings>
//     <vnic_profile_mappings>
//       <registration_vnic_profile_mapping>
//         <from>
//           <name>gold</name>
//           <network>
//             <name>red</name>
//           </network>
//         </from>
//         <to id="738dd914-8ec8-4a8b-8628-34672a5d449b"/>
//       </registration_vnic_profile_mapping>
//       <registration_vnic_profile_mapping>
//         <from>
//           <name>silver</name>
//           <network>
//             <name>blue</name>
//           </network>
//         </from>
//         <to>
//           <name>copper</name>
//           <network>
//             <name>orange</name>
//           </network>
//         </to>
//       </registration_vnic_profile_mapping>
//     </vnic_profile_mappings>
//   </registration_configuration>
// </action>
// ----
func (p *Action) SetRegistrationConfiguration(attr *RegistrationConfiguration) {
	p.registrationConfiguration = attr
}

// RegistrationConfiguration This type describes how an object (virtual machine, template,
// etc) is registered, and is used for the implementation of disaster recovery solutions.
//
// Each mapping contained in this type can be used to map
// objects in the original system to corresponding objects
// in the system where the virtual machine or template is being registered.
// For example, there could be a primary setup with a virtual machine
// configured on cluster A, and an active secondary setup with cluster B.
// Cluster B is compatible with that virtual machine, and in case of a
// disaster recovery scenario the storage domain can be
// imported to the secondary setup, and the user can register the
// virtual machine to cluster B.
//
// In that case, we can automate the recovery process by defining a cluster mapping.
// After the entity is registered, its OVF will indicate it belongs to
// cluster A, but the mapping will indicate that cluster A will
// be replaced with cluster B.
// {engine-name} should do the switch and register the virtual machine to cluster B
// in the secondary site.
//
// Cluster mapping is just one example, there are different types of mappings:
//
// - Cluster mapping.
// - LUN mapping.
// - Role mapping.
// - Domain mapping.
// - Permissions mapping.
// - Affinity Group mapping.
// - Affinity Label mapping.
// - Virtual NIC profile mapping.
//
// Each mapping will be used for its specific OVF's data once the register operation
// takes place in the {engine-name}.
//
// An example of an XML representation using the mapping:
//
// [source,xml]
// ----
// <action>
//   <registration_configuration>
//     <cluster_mappings>
//       <registration_cluster_mapping>
//         <from>
//           <name>myoriginalcluster</name>
//         </from>
//         <to>
//           <name>mynewcluster</name>
//         </to>
//       </registration_cluster_mapping>
//     </cluster_mappings>
//     <role_mappings>
//       <registration_role_mapping>
//         <from>
//           <name>SuperUser</name>
//         </from>
//         <to>
//           <name>UserVmRunTimeManager</name>
//         </to>
//       </registration_role_mapping>
//     </role_mappings>
//     <domain_mappings>
//       <registration_domain_mapping>
//         <from>
//           <name>redhat</name>
//         </from>
//         <to>
//           <name>internal</name>
//         </to>
//       </registration_domain_mapping>
//     </domain_mappings>
//     <lun_mappings>
//      <registration_lun_mapping>
//        <from id="111">
//        </from>
//        <to id="222">
//          <alias>weTestLun</alias>
//          <lun_storage>
//            <type>iscsi</type>
//            <logical_units>
//               <logical_unit id="36001405fb1ddb4b91e44078f1fffcfef">
//                  <address>44.33.11.22</address>
//                  <port>3260</port>
//                  <portal>1</portal>
//                  <target>iqn.2017-11.com.name.redhat:444</target>
//               </logical_unit>
//            </logical_units>
//          </lun_storage>
//        </to>
//      </registration_lun_mapping>
//     </lun_mappings>
//     <affinity_group_mappings>
//      <registration_affinity_group_mapping>
//        <from>
//          <name>affinity</name>
//        </from>
//        <to>
//          <name>affinity2</name>
//        </to>
//      </registration_affinity_group_mapping>
//     </affinity_group_mappings>
//     <affinity_label_mappings>
//      <registration_affinity_label_mapping>
//        <from>
//          <name>affinity_label</name>
//        </from>
//        <to>
//          <name>affinity_label2</name>
//        </to>
//      </registration_affinity_label_mapping>
//     </affinity_label_mappings>
//     <vnic_profile_mappings>
//       <registration_vnic_profile_mapping>
//         <from>
//           <name>gold</name>
//           <network>
//             <name>red</name>
//           </network>
//         </from>
//         <to id="738dd914-8ec8-4a8b-8628-34672a5d449b"/>
//       </registration_vnic_profile_mapping>
//       <registration_vnic_profile_mapping>
//         <from>
//           <name>silver</name>
//           <network>
//             <name>blue</name>
//           </network>
//         </from>
//         <to>
//           <name>copper</name>
//           <network>
//             <name>orange</name>
//           </network>
//         </to>
//       </registration_vnic_profile_mapping>
//     </vnic_profile_mappings>
//   </registration_configuration>
// </action>
// ----
func (p *Action) RegistrationConfiguration() (*RegistrationConfiguration, bool) {
	if p.registrationConfiguration != nil {
		return p.registrationConfiguration, true
	}
	return nil, false
}

// MustRegistrationConfiguration This type describes how an object (virtual machine, template,
// etc) is registered, and is used for the implementation of disaster recovery solutions.
//
// Each mapping contained in this type can be used to map
// objects in the original system to corresponding objects
// in the system where the virtual machine or template is being registered.
// For example, there could be a primary setup with a virtual machine
// configured on cluster A, and an active secondary setup with cluster B.
// Cluster B is compatible with that virtual machine, and in case of a
// disaster recovery scenario the storage domain can be
// imported to the secondary setup, and the user can register the
// virtual machine to cluster B.
//
// In that case, we can automate the recovery process by defining a cluster mapping.
// After the entity is registered, its OVF will indicate it belongs to
// cluster A, but the mapping will indicate that cluster A will
// be replaced with cluster B.
// {engine-name} should do the switch and register the virtual machine to cluster B
// in the secondary site.
//
// Cluster mapping is just one example, there are different types of mappings:
//
// - Cluster mapping.
// - LUN mapping.
// - Role mapping.
// - Domain mapping.
// - Permissions mapping.
// - Affinity Group mapping.
// - Affinity Label mapping.
// - Virtual NIC profile mapping.
//
// Each mapping will be used for its specific OVF's data once the register operation
// takes place in the {engine-name}.
//
// An example of an XML representation using the mapping:
//
// [source,xml]
// ----
// <action>
//   <registration_configuration>
//     <cluster_mappings>
//       <registration_cluster_mapping>
//         <from>
//           <name>myoriginalcluster</name>
//         </from>
//         <to>
//           <name>mynewcluster</name>
//         </to>
//       </registration_cluster_mapping>
//     </cluster_mappings>
//     <role_mappings>
//       <registration_role_mapping>
//         <from>
//           <name>SuperUser</name>
//         </from>
//         <to>
//           <name>UserVmRunTimeManager</name>
//         </to>
//       </registration_role_mapping>
//     </role_mappings>
//     <domain_mappings>
//       <registration_domain_mapping>
//         <from>
//           <name>redhat</name>
//         </from>
//         <to>
//           <name>internal</name>
//         </to>
//       </registration_domain_mapping>
//     </domain_mappings>
//     <lun_mappings>
//      <registration_lun_mapping>
//        <from id="111">
//        </from>
//        <to id="222">
//          <alias>weTestLun</alias>
//          <lun_storage>
//            <type>iscsi</type>
//            <logical_units>
//               <logical_unit id="36001405fb1ddb4b91e44078f1fffcfef">
//                  <address>44.33.11.22</address>
//                  <port>3260</port>
//                  <portal>1</portal>
//                  <target>iqn.2017-11.com.name.redhat:444</target>
//               </logical_unit>
//            </logical_units>
//          </lun_storage>
//        </to>
//      </registration_lun_mapping>
//     </lun_mappings>
//     <affinity_group_mappings>
//      <registration_affinity_group_mapping>
//        <from>
//          <name>affinity</name>
//        </from>
//        <to>
//          <name>affinity2</name>
//        </to>
//      </registration_affinity_group_mapping>
//     </affinity_group_mappings>
//     <affinity_label_mappings>
//      <registration_affinity_label_mapping>
//        <from>
//          <name>affinity_label</name>
//        </from>
//        <to>
//          <name>affinity_label2</name>
//        </to>
//      </registration_affinity_label_mapping>
//     </affinity_label_mappings>
//     <vnic_profile_mappings>
//       <registration_vnic_profile_mapping>
//         <from>
//           <name>gold</name>
//           <network>
//             <name>red</name>
//           </network>
//         </from>
//         <to id="738dd914-8ec8-4a8b-8628-34672a5d449b"/>
//       </registration_vnic_profile_mapping>
//       <registration_vnic_profile_mapping>
//         <from>
//           <name>silver</name>
//           <network>
//             <name>blue</name>
//           </network>
//         </from>
//         <to>
//           <name>copper</name>
//           <network>
//             <name>orange</name>
//           </network>
//         </to>
//       </registration_vnic_profile_mapping>
//     </vnic_profile_mappings>
//   </registration_configuration>
// </action>
// ----
func (p *Action) MustRegistrationConfiguration() *RegistrationConfiguration {
	if p.registrationConfiguration == nil {
		panic("the registrationConfiguration must not be nil, please use RegistrationConfiguration() function instead")
	}
	return p.registrationConfiguration
}

func (p *Action) SetRemoteViewerConnectionFile(attr string) {
	p.remoteViewerConnectionFile = &attr
}

func (p *Action) RemoteViewerConnectionFile() (string, bool) {
	if p.remoteViewerConnectionFile != nil {
		return *p.remoteViewerConnectionFile, true
	}
	var zero string
	return zero, false
}

func (p *Action) MustRemoteViewerConnectionFile() string {
	if p.remoteViewerConnectionFile == nil {
		panic("the remoteViewerConnectionFile must not be nil, please use RemoteViewerConnectionFile() function instead")
	}
	return *p.remoteViewerConnectionFile
}

func (p *Action) SetRemovedBonds(attr *HostNicSlice) {
	p.removedBonds = attr
}

func (p *Action) RemovedBonds() (*HostNicSlice, bool) {
	if p.removedBonds != nil {
		return p.removedBonds, true
	}
	return nil, false
}

func (p *Action) MustRemovedBonds() *HostNicSlice {
	if p.removedBonds == nil {
		panic("the removedBonds must not be nil, please use RemovedBonds() function instead")
	}
	return p.removedBonds
}

func (p *Action) SetRemovedLabels(attr *NetworkLabelSlice) {
	p.removedLabels = attr
}

func (p *Action) RemovedLabels() (*NetworkLabelSlice, bool) {
	if p.removedLabels != nil {
		return p.removedLabels, true
	}
	return nil, false
}

func (p *Action) MustRemovedLabels() *NetworkLabelSlice {
	if p.removedLabels == nil {
		panic("the removedLabels must not be nil, please use RemovedLabels() function instead")
	}
	return p.removedLabels
}

func (p *Action) SetRemovedNetworkAttachments(attr *NetworkAttachmentSlice) {
	p.removedNetworkAttachments = attr
}

func (p *Action) RemovedNetworkAttachments() (*NetworkAttachmentSlice, bool) {
	if p.removedNetworkAttachments != nil {
		return p.removedNetworkAttachments, true
	}
	return nil, false
}

func (p *Action) MustRemovedNetworkAttachments() *NetworkAttachmentSlice {
	if p.removedNetworkAttachments == nil {
		panic("the removedNetworkAttachments must not be nil, please use RemovedNetworkAttachments() function instead")
	}
	return p.removedNetworkAttachments
}

func (p *Action) SetResolutionType(attr string) {
	p.resolutionType = &attr
}

func (p *Action) ResolutionType() (string, bool) {
	if p.resolutionType != nil {
		return *p.resolutionType, true
	}
	var zero string
	return zero, false
}

func (p *Action) MustResolutionType() string {
	if p.resolutionType == nil {
		panic("the resolutionType must not be nil, please use ResolutionType() function instead")
	}
	return *p.resolutionType
}

func (p *Action) SetRestoreMemory(attr bool) {
	p.restoreMemory = &attr
}

func (p *Action) RestoreMemory() (bool, bool) {
	if p.restoreMemory != nil {
		return *p.restoreMemory, true
	}
	var zero bool
	return zero, false
}

func (p *Action) MustRestoreMemory() bool {
	if p.restoreMemory == nil {
		panic("the restoreMemory must not be nil, please use RestoreMemory() function instead")
	}
	return *p.restoreMemory
}

func (p *Action) SetRootPassword(attr string) {
	p.rootPassword = &attr
}

func (p *Action) RootPassword() (string, bool) {
	if p.rootPassword != nil {
		return *p.rootPassword, true
	}
	var zero string
	return zero, false
}

func (p *Action) MustRootPassword() string {
	if p.rootPassword == nil {
		panic("the rootPassword must not be nil, please use RootPassword() function instead")
	}
	return *p.rootPassword
}

func (p *Action) SetSeal(attr bool) {
	p.seal = &attr
}

func (p *Action) Seal() (bool, bool) {
	if p.seal != nil {
		return *p.seal, true
	}
	var zero bool
	return zero, false
}

func (p *Action) MustSeal() bool {
	if p.seal == nil {
		panic("the seal must not be nil, please use Seal() function instead")
	}
	return *p.seal
}

// SetSnapshot Represents a snapshot object.
//
// Example XML representation:
//
// [source,xml]
// ----
// <snapshot id="456" href="/ovirt-engine/api/vms/123/snapshots/456">
//   <actions>
//     <link rel="restore" href="/ovirt-engine/api/vms/123/snapshots/456/restore"/>
//   </actions>
//   <vm id="123" href="/ovirt-engine/api/vms/123"/>
//   <description>Virtual Machine 1 - Snapshot A</description>
//   <type>active</type>
//   <date>2010-08-16T14:24:29</date>
//   <persist_memorystate>false</persist_memorystate>
// </snapshot>
// ----
func (p *Action) SetSnapshot(attr *Snapshot) {
	p.snapshot = attr
}

// Snapshot Represents a snapshot object.
//
// Example XML representation:
//
// [source,xml]
// ----
// <snapshot id="456" href="/ovirt-engine/api/vms/123/snapshots/456">
//   <actions>
//     <link rel="restore" href="/ovirt-engine/api/vms/123/snapshots/456/restore"/>
//   </actions>
//   <vm id="123" href="/ovirt-engine/api/vms/123"/>
//   <description>Virtual Machine 1 - Snapshot A</description>
//   <type>active</type>
//   <date>2010-08-16T14:24:29</date>
//   <persist_memorystate>false</persist_memorystate>
// </snapshot>
// ----
func (p *Action) Snapshot() (*Snapshot, bool) {
	if p.snapshot != nil {
		return p.snapshot, true
	}
	return nil, false
}

// MustSnapshot Represents a snapshot object.
//
// Example XML representation:
//
// [source,xml]
// ----
// <snapshot id="456" href="/ovirt-engine/api/vms/123/snapshots/456">
//   <actions>
//     <link rel="restore" href="/ovirt-engine/api/vms/123/snapshots/456/restore"/>
//   </actions>
//   <vm id="123" href="/ovirt-engine/api/vms/123"/>
//   <description>Virtual Machine 1 - Snapshot A</description>
//   <type>active</type>
//   <date>2010-08-16T14:24:29</date>
//   <persist_memorystate>false</persist_memorystate>
// </snapshot>
// ----
func (p *Action) MustSnapshot() *Snapshot {
	if p.snapshot == nil {
		panic("the snapshot must not be nil, please use Snapshot() function instead")
	}
	return p.snapshot
}

// SetSourceHost Type representing a host.
func (p *Action) SetSourceHost(attr *Host) {
	p.sourceHost = attr
}

// SourceHost Type representing a host.
func (p *Action) SourceHost() (*Host, bool) {
	if p.sourceHost != nil {
		return p.sourceHost, true
	}
	return nil, false
}

// MustSourceHost Type representing a host.
func (p *Action) MustSourceHost() *Host {
	if p.sourceHost == nil {
		panic("the sourceHost must not be nil, please use SourceHost() function instead")
	}
	return p.sourceHost
}

func (p *Action) SetSsh(attr *Ssh) {
	p.ssh = attr
}

func (p *Action) Ssh() (*Ssh, bool) {
	if p.ssh != nil {
		return p.ssh, true
	}
	return nil, false
}

func (p *Action) MustSsh() *Ssh {
	if p.ssh == nil {
		panic("the ssh must not be nil, please use Ssh() function instead")
	}
	return p.ssh
}

func (p *Action) SetStatus(attr string) {
	p.status = &attr
}

func (p *Action) Status() (string, bool) {
	if p.status != nil {
		return *p.status, true
	}
	var zero string
	return zero, false
}

func (p *Action) MustStatus() string {
	if p.status == nil {
		panic("the status must not be nil, please use Status() function instead")
	}
	return *p.status
}

func (p *Action) SetStopGlusterService(attr bool) {
	p.stopGlusterService = &attr
}

func (p *Action) StopGlusterService() (bool, bool) {
	if p.stopGlusterService != nil {
		return *p.stopGlusterService, true
	}
	var zero bool
	return zero, false
}

func (p *Action) MustStopGlusterService() bool {
	if p.stopGlusterService == nil {
		panic("the stopGlusterService must not be nil, please use StopGlusterService() function instead")
	}
	return *p.stopGlusterService
}

// SetStorageDomain Storage domain.
//
// An XML representation of a NFS storage domain with identifier `123`:
//
// [source,xml]
// ----
// <storage_domain href="/ovirt-engine/api/storagedomains/123" id="123">
//   <name>mydata</name>
//   <description>My data</description>
//   <available>38654705664</available>
//   <committed>1073741824</committed>
//   <critical_space_action_blocker>5</critical_space_action_blocker>
//   <external_status>ok</external_status>
//   <master>true</master>
//   <storage>
//     <address>mynfs.example.com</address>
//     <nfs_version>v3</nfs_version>
//     <path>/exports/mydata</path>
//     <type>nfs</type>
//   </storage>
//   <storage_format>v3</storage_format>
//   <type>data</type>
//   <used>13958643712</used>
//   <warning_low_space_indicator>10</warning_low_space_indicator>
//   <wipe_after_delete>false</wipe_after_delete>
//   <data_centers>
//     <data_center href="/ovirt-engine/api/datacenters/456" id="456"/>
//   </data_centers>
// </storage_domain>
// ----
func (p *Action) SetStorageDomain(attr *StorageDomain) {
	p.storageDomain = attr
}

// StorageDomain Storage domain.
//
// An XML representation of a NFS storage domain with identifier `123`:
//
// [source,xml]
// ----
// <storage_domain href="/ovirt-engine/api/storagedomains/123" id="123">
//   <name>mydata</name>
//   <description>My data</description>
//   <available>38654705664</available>
//   <committed>1073741824</committed>
//   <critical_space_action_blocker>5</critical_space_action_blocker>
//   <external_status>ok</external_status>
//   <master>true</master>
//   <storage>
//     <address>mynfs.example.com</address>
//     <nfs_version>v3</nfs_version>
//     <path>/exports/mydata</path>
//     <type>nfs</type>
//   </storage>
//   <storage_format>v3</storage_format>
//   <type>data</type>
//   <used>13958643712</used>
//   <warning_low_space_indicator>10</warning_low_space_indicator>
//   <wipe_after_delete>false</wipe_after_delete>
//   <data_centers>
//     <data_center href="/ovirt-engine/api/datacenters/456" id="456"/>
//   </data_centers>
// </storage_domain>
// ----
func (p *Action) StorageDomain() (*StorageDomain, bool) {
	if p.storageDomain != nil {
		return p.storageDomain, true
	}
	return nil, false
}

// MustStorageDomain Storage domain.
//
// An XML representation of a NFS storage domain with identifier `123`:
//
// [source,xml]
// ----
// <storage_domain href="/ovirt-engine/api/storagedomains/123" id="123">
//   <name>mydata</name>
//   <description>My data</description>
//   <available>38654705664</available>
//   <committed>1073741824</committed>
//   <critical_space_action_blocker>5</critical_space_action_blocker>
//   <external_status>ok</external_status>
//   <master>true</master>
//   <storage>
//     <address>mynfs.example.com</address>
//     <nfs_version>v3</nfs_version>
//     <path>/exports/mydata</path>
//     <type>nfs</type>
//   </storage>
//   <storage_format>v3</storage_format>
//   <type>data</type>
//   <used>13958643712</used>
//   <warning_low_space_indicator>10</warning_low_space_indicator>
//   <wipe_after_delete>false</wipe_after_delete>
//   <data_centers>
//     <data_center href="/ovirt-engine/api/datacenters/456" id="456"/>
//   </data_centers>
// </storage_domain>
// ----
func (p *Action) MustStorageDomain() *StorageDomain {
	if p.storageDomain == nil {
		panic("the storageDomain must not be nil, please use StorageDomain() function instead")
	}
	return p.storageDomain
}

func (p *Action) SetStorageDomains(attr *StorageDomainSlice) {
	p.storageDomains = attr
}

func (p *Action) StorageDomains() (*StorageDomainSlice, bool) {
	if p.storageDomains != nil {
		return p.storageDomains, true
	}
	return nil, false
}

func (p *Action) MustStorageDomains() *StorageDomainSlice {
	if p.storageDomains == nil {
		panic("the storageDomains must not be nil, please use StorageDomains() function instead")
	}
	return p.storageDomains
}

func (p *Action) SetSucceeded(attr bool) {
	p.succeeded = &attr
}

func (p *Action) Succeeded() (bool, bool) {
	if p.succeeded != nil {
		return *p.succeeded, true
	}
	var zero bool
	return zero, false
}

func (p *Action) MustSucceeded() bool {
	if p.succeeded == nil {
		panic("the succeeded must not be nil, please use Succeeded() function instead")
	}
	return *p.succeeded
}

func (p *Action) SetSynchronizedNetworkAttachments(attr *NetworkAttachmentSlice) {
	p.synchronizedNetworkAttachments = attr
}

func (p *Action) SynchronizedNetworkAttachments() (*NetworkAttachmentSlice, bool) {
	if p.synchronizedNetworkAttachments != nil {
		return p.synchronizedNetworkAttachments, true
	}
	return nil, false
}

func (p *Action) MustSynchronizedNetworkAttachments() *NetworkAttachmentSlice {
	if p.synchronizedNetworkAttachments == nil {
		panic("the synchronizedNetworkAttachments must not be nil, please use SynchronizedNetworkAttachments() function instead")
	}
	return p.synchronizedNetworkAttachments
}

// SetTemplate The type that represents a virtual machine template.
// Templates allow for a rapid instantiation of virtual machines with common configuration and disk states.
func (p *Action) SetTemplate(attr *Template) {
	p.template = attr
}

// Template The type that represents a virtual machine template.
// Templates allow for a rapid instantiation of virtual machines with common configuration and disk states.
func (p *Action) Template() (*Template, bool) {
	if p.template != nil {
		return p.template, true
	}
	return nil, false
}

// MustTemplate The type that represents a virtual machine template.
// Templates allow for a rapid instantiation of virtual machines with common configuration and disk states.
func (p *Action) MustTemplate() *Template {
	if p.template == nil {
		panic("the template must not be nil, please use Template() function instead")
	}
	return p.template
}

// SetTicket Type representing a ticket that allows virtual machine access.
func (p *Action) SetTicket(attr *Ticket) {
	p.ticket = attr
}

// Ticket Type representing a ticket that allows virtual machine access.
func (p *Action) Ticket() (*Ticket, bool) {
	if p.ticket != nil {
		return p.ticket, true
	}
	return nil, false
}

// MustTicket Type representing a ticket that allows virtual machine access.
func (p *Action) MustTicket() *Ticket {
	if p.ticket == nil {
		panic("the ticket must not be nil, please use Ticket() function instead")
	}
	return p.ticket
}

func (p *Action) SetTimeout(attr int64) {
	p.timeout = &attr
}

func (p *Action) Timeout() (int64, bool) {
	if p.timeout != nil {
		return *p.timeout, true
	}
	var zero int64
	return zero, false
}

func (p *Action) MustTimeout() int64 {
	if p.timeout == nil {
		panic("the timeout must not be nil, please use Timeout() function instead")
	}
	return *p.timeout
}

func (p *Action) SetUndeployHostedEngine(attr bool) {
	p.undeployHostedEngine = &attr
}

func (p *Action) UndeployHostedEngine() (bool, bool) {
	if p.undeployHostedEngine != nil {
		return *p.undeployHostedEngine, true
	}
	var zero bool
	return zero, false
}

func (p *Action) MustUndeployHostedEngine() bool {
	if p.undeployHostedEngine == nil {
		panic("the undeployHostedEngine must not be nil, please use UndeployHostedEngine() function instead")
	}
	return *p.undeployHostedEngine
}

// SetUpgradeAction The action type for cluster upgrade action.
func (p *Action) SetUpgradeAction(attr ClusterUpgradeAction) {
	p.upgradeAction = &attr
}

// UpgradeAction The action type for cluster upgrade action.
func (p *Action) UpgradeAction() (ClusterUpgradeAction, bool) {
	if p.upgradeAction != nil {
		return *p.upgradeAction, true
	}
	var zero ClusterUpgradeAction
	return zero, false
}

// MustUpgradeAction The action type for cluster upgrade action.
func (p *Action) MustUpgradeAction() ClusterUpgradeAction {
	if p.upgradeAction == nil {
		panic("the upgradeAction must not be nil, please use UpgradeAction() function instead")
	}
	return *p.upgradeAction
}

func (p *Action) SetUseCloudInit(attr bool) {
	p.useCloudInit = &attr
}

func (p *Action) UseCloudInit() (bool, bool) {
	if p.useCloudInit != nil {
		return *p.useCloudInit, true
	}
	var zero bool
	return zero, false
}

func (p *Action) MustUseCloudInit() bool {
	if p.useCloudInit == nil {
		panic("the useCloudInit must not be nil, please use UseCloudInit() function instead")
	}
	return *p.useCloudInit
}

func (p *Action) SetUseIgnition(attr bool) {
	p.useIgnition = &attr
}

func (p *Action) UseIgnition() (bool, bool) {
	if p.useIgnition != nil {
		return *p.useIgnition, true
	}
	var zero bool
	return zero, false
}

func (p *Action) MustUseIgnition() bool {
	if p.useIgnition == nil {
		panic("the useIgnition must not be nil, please use UseIgnition() function instead")
	}
	return *p.useIgnition
}

func (p *Action) SetUseInitialization(attr bool) {
	p.useInitialization = &attr
}

func (p *Action) UseInitialization() (bool, bool) {
	if p.useInitialization != nil {
		return *p.useInitialization, true
	}
	var zero bool
	return zero, false
}

func (p *Action) MustUseInitialization() bool {
	if p.useInitialization == nil {
		panic("the useInitialization must not be nil, please use UseInitialization() function instead")
	}
	return *p.useInitialization
}

func (p *Action) SetUseSysprep(attr bool) {
	p.useSysprep = &attr
}

func (p *Action) UseSysprep() (bool, bool) {
	if p.useSysprep != nil {
		return *p.useSysprep, true
	}
	var zero bool
	return zero, false
}

func (p *Action) MustUseSysprep() bool {
	if p.useSysprep == nil {
		panic("the useSysprep must not be nil, please use UseSysprep() function instead")
	}
	return *p.useSysprep
}

// SetVirtualFunctionsConfiguration Describes the virtual functions configuration of an SR-IOV-enabled physical function NIC.
func (p *Action) SetVirtualFunctionsConfiguration(attr *HostNicVirtualFunctionsConfiguration) {
	p.virtualFunctionsConfiguration = attr
}

// VirtualFunctionsConfiguration Describes the virtual functions configuration of an SR-IOV-enabled physical function NIC.
func (p *Action) VirtualFunctionsConfiguration() (*HostNicVirtualFunctionsConfiguration, bool) {
	if p.virtualFunctionsConfiguration != nil {
		return p.virtualFunctionsConfiguration, true
	}
	return nil, false
}

// MustVirtualFunctionsConfiguration Describes the virtual functions configuration of an SR-IOV-enabled physical function NIC.
func (p *Action) MustVirtualFunctionsConfiguration() *HostNicVirtualFunctionsConfiguration {
	if p.virtualFunctionsConfiguration == nil {
		panic("the virtualFunctionsConfiguration must not be nil, please use VirtualFunctionsConfiguration() function instead")
	}
	return p.virtualFunctionsConfiguration
}

// SetVm Represents a virtual machine.
func (p *Action) SetVm(attr *Vm) {
	p.vm = attr
}

// Vm Represents a virtual machine.
func (p *Action) Vm() (*Vm, bool) {
	if p.vm != nil {
		return p.vm, true
	}
	return nil, false
}

// MustVm Represents a virtual machine.
func (p *Action) MustVm() *Vm {
	if p.vm == nil {
		panic("the vm must not be nil, please use Vm() function instead")
	}
	return p.vm
}

func (p *Action) SetVnicProfileMappings(attr *VnicProfileMappingSlice) {
	p.vnicProfileMappings = attr
}

func (p *Action) VnicProfileMappings() (*VnicProfileMappingSlice, bool) {
	if p.vnicProfileMappings != nil {
		return p.vnicProfileMappings, true
	}
	return nil, false
}

func (p *Action) MustVnicProfileMappings() *VnicProfileMappingSlice {
	if p.vnicProfileMappings == nil {
		panic("the vnicProfileMappings must not be nil, please use VnicProfileMappings() function instead")
	}
	return p.vnicProfileMappings
}

func (p *Action) SetVolatile(attr bool) {
	p.volatile = &attr
}

func (p *Action) Volatile() (bool, bool) {
	if p.volatile != nil {
		return *p.volatile, true
	}
	var zero bool
	return zero, false
}

func (p *Action) MustVolatile() bool {
	if p.volatile == nil {
		panic("the volatile must not be nil, please use Volatile() function instead")
	}
	return *p.volatile
}

type AffinityGroupSlice struct {
	href  *string
	slice []*AffinityGroup
}

func (op *AffinityGroupSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *AffinityGroupSlice) SetHref(href string) {
	op.href = &href
}

func (op *AffinityGroupSlice) Slice() []*AffinityGroup {
	return op.slice
}

func (op *AffinityGroupSlice) SetSlice(slice []*AffinityGroup) {
	op.slice = slice
}

type AffinityLabelSlice struct {
	href  *string
	slice []*AffinityLabel
}

func (op *AffinityLabelSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *AffinityLabelSlice) SetHref(href string) {
	op.href = &href
}

func (op *AffinityLabelSlice) Slice() []*AffinityLabel {
	return op.slice
}

func (op *AffinityLabelSlice) SetSlice(slice []*AffinityLabel) {
	op.slice = slice
}

type AffinityRuleSlice struct {
	href  *string
	slice []*AffinityRule
}

func (op *AffinityRuleSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *AffinityRuleSlice) SetHref(href string) {
	op.href = &href
}

func (op *AffinityRuleSlice) Slice() []*AffinityRule {
	return op.slice
}

func (op *AffinityRuleSlice) SetSlice(slice []*AffinityRule) {
	op.slice = slice
}

type AgentSlice struct {
	href  *string
	slice []*Agent
}

func (op *AgentSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *AgentSlice) SetHref(href string) {
	op.href = &href
}

func (op *AgentSlice) Slice() []*Agent {
	return op.slice
}

func (op *AgentSlice) SetSlice(slice []*Agent) {
	op.slice = slice
}

type AgentConfigurationSlice struct {
	href  *string
	slice []*AgentConfiguration
}

func (op *AgentConfigurationSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *AgentConfigurationSlice) SetHref(href string) {
	op.href = &href
}

func (op *AgentConfigurationSlice) Slice() []*AgentConfiguration {
	return op.slice
}

func (op *AgentConfigurationSlice) SetSlice(slice []*AgentConfiguration) {
	op.slice = slice
}

type ApiSlice struct {
	href  *string
	slice []*Api
}

func (op *ApiSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *ApiSlice) SetHref(href string) {
	op.href = &href
}

func (op *ApiSlice) Slice() []*Api {
	return op.slice
}

func (op *ApiSlice) SetSlice(slice []*Api) {
	op.slice = slice
}

type ApiSummarySlice struct {
	href  *string
	slice []*ApiSummary
}

func (op *ApiSummarySlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *ApiSummarySlice) SetHref(href string) {
	op.href = &href
}

func (op *ApiSummarySlice) Slice() []*ApiSummary {
	return op.slice
}

func (op *ApiSummarySlice) SetSlice(slice []*ApiSummary) {
	op.slice = slice
}

type ApiSummaryItemSlice struct {
	href  *string
	slice []*ApiSummaryItem
}

func (op *ApiSummaryItemSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *ApiSummaryItemSlice) SetHref(href string) {
	op.href = &href
}

func (op *ApiSummaryItemSlice) Slice() []*ApiSummaryItem {
	return op.slice
}

func (op *ApiSummaryItemSlice) SetSlice(slice []*ApiSummaryItem) {
	op.slice = slice
}

type ApplicationSlice struct {
	href  *string
	slice []*Application
}

func (op *ApplicationSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *ApplicationSlice) SetHref(href string) {
	op.href = &href
}

func (op *ApplicationSlice) Slice() []*Application {
	return op.slice
}

func (op *ApplicationSlice) SetSlice(slice []*Application) {
	op.slice = slice
}

type AuthorizedKeySlice struct {
	href  *string
	slice []*AuthorizedKey
}

func (op *AuthorizedKeySlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *AuthorizedKeySlice) SetHref(href string) {
	op.href = &href
}

func (op *AuthorizedKeySlice) Slice() []*AuthorizedKey {
	return op.slice
}

func (op *AuthorizedKeySlice) SetSlice(slice []*AuthorizedKey) {
	op.slice = slice
}

type BackupSlice struct {
	href  *string
	slice []*Backup
}

func (op *BackupSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *BackupSlice) SetHref(href string) {
	op.href = &href
}

func (op *BackupSlice) Slice() []*Backup {
	return op.slice
}

func (op *BackupSlice) SetSlice(slice []*Backup) {
	op.slice = slice
}

type BalanceSlice struct {
	href  *string
	slice []*Balance
}

func (op *BalanceSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *BalanceSlice) SetHref(href string) {
	op.href = &href
}

func (op *BalanceSlice) Slice() []*Balance {
	return op.slice
}

func (op *BalanceSlice) SetSlice(slice []*Balance) {
	op.slice = slice
}

type BiosSlice struct {
	href  *string
	slice []*Bios
}

func (op *BiosSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *BiosSlice) SetHref(href string) {
	op.href = &href
}

func (op *BiosSlice) Slice() []*Bios {
	return op.slice
}

func (op *BiosSlice) SetSlice(slice []*Bios) {
	op.slice = slice
}

type BlockStatisticSlice struct {
	href  *string
	slice []*BlockStatistic
}

func (op *BlockStatisticSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *BlockStatisticSlice) SetHref(href string) {
	op.href = &href
}

func (op *BlockStatisticSlice) Slice() []*BlockStatistic {
	return op.slice
}

func (op *BlockStatisticSlice) SetSlice(slice []*BlockStatistic) {
	op.slice = slice
}

type BondingSlice struct {
	href  *string
	slice []*Bonding
}

func (op *BondingSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *BondingSlice) SetHref(href string) {
	op.href = &href
}

func (op *BondingSlice) Slice() []*Bonding {
	return op.slice
}

func (op *BondingSlice) SetSlice(slice []*Bonding) {
	op.slice = slice
}

type BookmarkSlice struct {
	href  *string
	slice []*Bookmark
}

func (op *BookmarkSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *BookmarkSlice) SetHref(href string) {
	op.href = &href
}

func (op *BookmarkSlice) Slice() []*Bookmark {
	return op.slice
}

func (op *BookmarkSlice) SetSlice(slice []*Bookmark) {
	op.slice = slice
}

type BootSlice struct {
	href  *string
	slice []*Boot
}

func (op *BootSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *BootSlice) SetHref(href string) {
	op.href = &href
}

func (op *BootSlice) Slice() []*Boot {
	return op.slice
}

func (op *BootSlice) SetSlice(slice []*Boot) {
	op.slice = slice
}

type BootMenuSlice struct {
	href  *string
	slice []*BootMenu
}

func (op *BootMenuSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *BootMenuSlice) SetHref(href string) {
	op.href = &href
}

func (op *BootMenuSlice) Slice() []*BootMenu {
	return op.slice
}

func (op *BootMenuSlice) SetSlice(slice []*BootMenu) {
	op.slice = slice
}

type BrickProfileDetailSlice struct {
	href  *string
	slice []*BrickProfileDetail
}

func (op *BrickProfileDetailSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *BrickProfileDetailSlice) SetHref(href string) {
	op.href = &href
}

func (op *BrickProfileDetailSlice) Slice() []*BrickProfileDetail {
	return op.slice
}

func (op *BrickProfileDetailSlice) SetSlice(slice []*BrickProfileDetail) {
	op.slice = slice
}

type CdromSlice struct {
	href  *string
	slice []*Cdrom
}

func (op *CdromSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *CdromSlice) SetHref(href string) {
	op.href = &href
}

func (op *CdromSlice) Slice() []*Cdrom {
	return op.slice
}

func (op *CdromSlice) SetSlice(slice []*Cdrom) {
	op.slice = slice
}

type CertificateSlice struct {
	href  *string
	slice []*Certificate
}

func (op *CertificateSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *CertificateSlice) SetHref(href string) {
	op.href = &href
}

func (op *CertificateSlice) Slice() []*Certificate {
	return op.slice
}

func (op *CertificateSlice) SetSlice(slice []*Certificate) {
	op.slice = slice
}

type CheckpointSlice struct {
	href  *string
	slice []*Checkpoint
}

func (op *CheckpointSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *CheckpointSlice) SetHref(href string) {
	op.href = &href
}

func (op *CheckpointSlice) Slice() []*Checkpoint {
	return op.slice
}

func (op *CheckpointSlice) SetSlice(slice []*Checkpoint) {
	op.slice = slice
}

type CloudInitSlice struct {
	href  *string
	slice []*CloudInit
}

func (op *CloudInitSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *CloudInitSlice) SetHref(href string) {
	op.href = &href
}

func (op *CloudInitSlice) Slice() []*CloudInit {
	return op.slice
}

func (op *CloudInitSlice) SetSlice(slice []*CloudInit) {
	op.slice = slice
}

type ClusterSlice struct {
	href  *string
	slice []*Cluster
}

func (op *ClusterSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *ClusterSlice) SetHref(href string) {
	op.href = &href
}

func (op *ClusterSlice) Slice() []*Cluster {
	return op.slice
}

func (op *ClusterSlice) SetSlice(slice []*Cluster) {
	op.slice = slice
}

type ClusterFeatureSlice struct {
	href  *string
	slice []*ClusterFeature
}

func (op *ClusterFeatureSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *ClusterFeatureSlice) SetHref(href string) {
	op.href = &href
}

func (op *ClusterFeatureSlice) Slice() []*ClusterFeature {
	return op.slice
}

func (op *ClusterFeatureSlice) SetSlice(slice []*ClusterFeature) {
	op.slice = slice
}

type ClusterLevelSlice struct {
	href  *string
	slice []*ClusterLevel
}

func (op *ClusterLevelSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *ClusterLevelSlice) SetHref(href string) {
	op.href = &href
}

func (op *ClusterLevelSlice) Slice() []*ClusterLevel {
	return op.slice
}

func (op *ClusterLevelSlice) SetSlice(slice []*ClusterLevel) {
	op.slice = slice
}

type ConfigurationSlice struct {
	href  *string
	slice []*Configuration
}

func (op *ConfigurationSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *ConfigurationSlice) SetHref(href string) {
	op.href = &href
}

func (op *ConfigurationSlice) Slice() []*Configuration {
	return op.slice
}

func (op *ConfigurationSlice) SetSlice(slice []*Configuration) {
	op.slice = slice
}

type ConsoleSlice struct {
	href  *string
	slice []*Console
}

func (op *ConsoleSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *ConsoleSlice) SetHref(href string) {
	op.href = &href
}

func (op *ConsoleSlice) Slice() []*Console {
	return op.slice
}

func (op *ConsoleSlice) SetSlice(slice []*Console) {
	op.slice = slice
}

type CoreSlice struct {
	href  *string
	slice []*Core
}

func (op *CoreSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *CoreSlice) SetHref(href string) {
	op.href = &href
}

func (op *CoreSlice) Slice() []*Core {
	return op.slice
}

func (op *CoreSlice) SetSlice(slice []*Core) {
	op.slice = slice
}

type CpuSlice struct {
	href  *string
	slice []*Cpu
}

func (op *CpuSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *CpuSlice) SetHref(href string) {
	op.href = &href
}

func (op *CpuSlice) Slice() []*Cpu {
	return op.slice
}

func (op *CpuSlice) SetSlice(slice []*Cpu) {
	op.slice = slice
}

type CpuProfileSlice struct {
	href  *string
	slice []*CpuProfile
}

func (op *CpuProfileSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *CpuProfileSlice) SetHref(href string) {
	op.href = &href
}

func (op *CpuProfileSlice) Slice() []*CpuProfile {
	return op.slice
}

func (op *CpuProfileSlice) SetSlice(slice []*CpuProfile) {
	op.slice = slice
}

type CpuTopologySlice struct {
	href  *string
	slice []*CpuTopology
}

func (op *CpuTopologySlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *CpuTopologySlice) SetHref(href string) {
	op.href = &href
}

func (op *CpuTopologySlice) Slice() []*CpuTopology {
	return op.slice
}

func (op *CpuTopologySlice) SetSlice(slice []*CpuTopology) {
	op.slice = slice
}

type CpuTuneSlice struct {
	href  *string
	slice []*CpuTune
}

func (op *CpuTuneSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *CpuTuneSlice) SetHref(href string) {
	op.href = &href
}

func (op *CpuTuneSlice) Slice() []*CpuTune {
	return op.slice
}

func (op *CpuTuneSlice) SetSlice(slice []*CpuTune) {
	op.slice = slice
}

type CpuTypeSlice struct {
	href  *string
	slice []*CpuType
}

func (op *CpuTypeSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *CpuTypeSlice) SetHref(href string) {
	op.href = &href
}

func (op *CpuTypeSlice) Slice() []*CpuType {
	return op.slice
}

func (op *CpuTypeSlice) SetSlice(slice []*CpuType) {
	op.slice = slice
}

type CustomPropertySlice struct {
	href  *string
	slice []*CustomProperty
}

func (op *CustomPropertySlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *CustomPropertySlice) SetHref(href string) {
	op.href = &href
}

func (op *CustomPropertySlice) Slice() []*CustomProperty {
	return op.slice
}

func (op *CustomPropertySlice) SetSlice(slice []*CustomProperty) {
	op.slice = slice
}

type DataCenterSlice struct {
	href  *string
	slice []*DataCenter
}

func (op *DataCenterSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *DataCenterSlice) SetHref(href string) {
	op.href = &href
}

func (op *DataCenterSlice) Slice() []*DataCenter {
	return op.slice
}

func (op *DataCenterSlice) SetSlice(slice []*DataCenter) {
	op.slice = slice
}

type DeviceSlice struct {
	href  *string
	slice []*Device
}

func (op *DeviceSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *DeviceSlice) SetHref(href string) {
	op.href = &href
}

func (op *DeviceSlice) Slice() []*Device {
	return op.slice
}

func (op *DeviceSlice) SetSlice(slice []*Device) {
	op.slice = slice
}

type DiskSlice struct {
	href  *string
	slice []*Disk
}

func (op *DiskSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *DiskSlice) SetHref(href string) {
	op.href = &href
}

func (op *DiskSlice) Slice() []*Disk {
	return op.slice
}

func (op *DiskSlice) SetSlice(slice []*Disk) {
	op.slice = slice
}

type DiskAttachmentSlice struct {
	href  *string
	slice []*DiskAttachment
}

func (op *DiskAttachmentSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *DiskAttachmentSlice) SetHref(href string) {
	op.href = &href
}

func (op *DiskAttachmentSlice) Slice() []*DiskAttachment {
	return op.slice
}

func (op *DiskAttachmentSlice) SetSlice(slice []*DiskAttachment) {
	op.slice = slice
}

type DiskProfileSlice struct {
	href  *string
	slice []*DiskProfile
}

func (op *DiskProfileSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *DiskProfileSlice) SetHref(href string) {
	op.href = &href
}

func (op *DiskProfileSlice) Slice() []*DiskProfile {
	return op.slice
}

func (op *DiskProfileSlice) SetSlice(slice []*DiskProfile) {
	op.slice = slice
}

type DiskSnapshotSlice struct {
	href  *string
	slice []*DiskSnapshot
}

func (op *DiskSnapshotSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *DiskSnapshotSlice) SetHref(href string) {
	op.href = &href
}

func (op *DiskSnapshotSlice) Slice() []*DiskSnapshot {
	return op.slice
}

func (op *DiskSnapshotSlice) SetSlice(slice []*DiskSnapshot) {
	op.slice = slice
}

type DisplaySlice struct {
	href  *string
	slice []*Display
}

func (op *DisplaySlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *DisplaySlice) SetHref(href string) {
	op.href = &href
}

func (op *DisplaySlice) Slice() []*Display {
	return op.slice
}

func (op *DisplaySlice) SetSlice(slice []*Display) {
	op.slice = slice
}

type DnsSlice struct {
	href  *string
	slice []*Dns
}

func (op *DnsSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *DnsSlice) SetHref(href string) {
	op.href = &href
}

func (op *DnsSlice) Slice() []*Dns {
	return op.slice
}

func (op *DnsSlice) SetSlice(slice []*Dns) {
	op.slice = slice
}

type DnsResolverConfigurationSlice struct {
	href  *string
	slice []*DnsResolverConfiguration
}

func (op *DnsResolverConfigurationSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *DnsResolverConfigurationSlice) SetHref(href string) {
	op.href = &href
}

func (op *DnsResolverConfigurationSlice) Slice() []*DnsResolverConfiguration {
	return op.slice
}

func (op *DnsResolverConfigurationSlice) SetSlice(slice []*DnsResolverConfiguration) {
	op.slice = slice
}

type DomainSlice struct {
	href  *string
	slice []*Domain
}

func (op *DomainSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *DomainSlice) SetHref(href string) {
	op.href = &href
}

func (op *DomainSlice) Slice() []*Domain {
	return op.slice
}

func (op *DomainSlice) SetSlice(slice []*Domain) {
	op.slice = slice
}

type EntityProfileDetailSlice struct {
	href  *string
	slice []*EntityProfileDetail
}

func (op *EntityProfileDetailSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *EntityProfileDetailSlice) SetHref(href string) {
	op.href = &href
}

func (op *EntityProfileDetailSlice) Slice() []*EntityProfileDetail {
	return op.slice
}

func (op *EntityProfileDetailSlice) SetSlice(slice []*EntityProfileDetail) {
	op.slice = slice
}

type ErrorHandlingSlice struct {
	href  *string
	slice []*ErrorHandling
}

func (op *ErrorHandlingSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *ErrorHandlingSlice) SetHref(href string) {
	op.href = &href
}

func (op *ErrorHandlingSlice) Slice() []*ErrorHandling {
	return op.slice
}

func (op *ErrorHandlingSlice) SetSlice(slice []*ErrorHandling) {
	op.slice = slice
}

type EventSlice struct {
	href  *string
	slice []*Event
}

func (op *EventSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *EventSlice) SetHref(href string) {
	op.href = &href
}

func (op *EventSlice) Slice() []*Event {
	return op.slice
}

func (op *EventSlice) SetSlice(slice []*Event) {
	op.slice = slice
}

type EventSubscriptionSlice struct {
	href  *string
	slice []*EventSubscription
}

func (op *EventSubscriptionSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *EventSubscriptionSlice) SetHref(href string) {
	op.href = &href
}

func (op *EventSubscriptionSlice) Slice() []*EventSubscription {
	return op.slice
}

func (op *EventSubscriptionSlice) SetSlice(slice []*EventSubscription) {
	op.slice = slice
}

type ExternalComputeResourceSlice struct {
	href  *string
	slice []*ExternalComputeResource
}

func (op *ExternalComputeResourceSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *ExternalComputeResourceSlice) SetHref(href string) {
	op.href = &href
}

func (op *ExternalComputeResourceSlice) Slice() []*ExternalComputeResource {
	return op.slice
}

func (op *ExternalComputeResourceSlice) SetSlice(slice []*ExternalComputeResource) {
	op.slice = slice
}

type ExternalDiscoveredHostSlice struct {
	href  *string
	slice []*ExternalDiscoveredHost
}

func (op *ExternalDiscoveredHostSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *ExternalDiscoveredHostSlice) SetHref(href string) {
	op.href = &href
}

func (op *ExternalDiscoveredHostSlice) Slice() []*ExternalDiscoveredHost {
	return op.slice
}

func (op *ExternalDiscoveredHostSlice) SetSlice(slice []*ExternalDiscoveredHost) {
	op.slice = slice
}

type ExternalHostSlice struct {
	href  *string
	slice []*ExternalHost
}

func (op *ExternalHostSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *ExternalHostSlice) SetHref(href string) {
	op.href = &href
}

func (op *ExternalHostSlice) Slice() []*ExternalHost {
	return op.slice
}

func (op *ExternalHostSlice) SetSlice(slice []*ExternalHost) {
	op.slice = slice
}

type ExternalHostGroupSlice struct {
	href  *string
	slice []*ExternalHostGroup
}

func (op *ExternalHostGroupSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *ExternalHostGroupSlice) SetHref(href string) {
	op.href = &href
}

func (op *ExternalHostGroupSlice) Slice() []*ExternalHostGroup {
	return op.slice
}

func (op *ExternalHostGroupSlice) SetSlice(slice []*ExternalHostGroup) {
	op.slice = slice
}

type ExternalHostProviderSlice struct {
	href  *string
	slice []*ExternalHostProvider
}

func (op *ExternalHostProviderSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *ExternalHostProviderSlice) SetHref(href string) {
	op.href = &href
}

func (op *ExternalHostProviderSlice) Slice() []*ExternalHostProvider {
	return op.slice
}

func (op *ExternalHostProviderSlice) SetSlice(slice []*ExternalHostProvider) {
	op.slice = slice
}

type ExternalNetworkProviderConfigurationSlice struct {
	href  *string
	slice []*ExternalNetworkProviderConfiguration
}

func (op *ExternalNetworkProviderConfigurationSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *ExternalNetworkProviderConfigurationSlice) SetHref(href string) {
	op.href = &href
}

func (op *ExternalNetworkProviderConfigurationSlice) Slice() []*ExternalNetworkProviderConfiguration {
	return op.slice
}

func (op *ExternalNetworkProviderConfigurationSlice) SetSlice(slice []*ExternalNetworkProviderConfiguration) {
	op.slice = slice
}

type ExternalProviderSlice struct {
	href  *string
	slice []*ExternalProvider
}

func (op *ExternalProviderSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *ExternalProviderSlice) SetHref(href string) {
	op.href = &href
}

func (op *ExternalProviderSlice) Slice() []*ExternalProvider {
	return op.slice
}

func (op *ExternalProviderSlice) SetSlice(slice []*ExternalProvider) {
	op.slice = slice
}

type ExternalTemplateImportSlice struct {
	href  *string
	slice []*ExternalTemplateImport
}

func (op *ExternalTemplateImportSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *ExternalTemplateImportSlice) SetHref(href string) {
	op.href = &href
}

func (op *ExternalTemplateImportSlice) Slice() []*ExternalTemplateImport {
	return op.slice
}

func (op *ExternalTemplateImportSlice) SetSlice(slice []*ExternalTemplateImport) {
	op.slice = slice
}

type ExternalVmImportSlice struct {
	href  *string
	slice []*ExternalVmImport
}

func (op *ExternalVmImportSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *ExternalVmImportSlice) SetHref(href string) {
	op.href = &href
}

func (op *ExternalVmImportSlice) Slice() []*ExternalVmImport {
	return op.slice
}

func (op *ExternalVmImportSlice) SetSlice(slice []*ExternalVmImport) {
	op.slice = slice
}

type FencingPolicySlice struct {
	href  *string
	slice []*FencingPolicy
}

func (op *FencingPolicySlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *FencingPolicySlice) SetHref(href string) {
	op.href = &href
}

func (op *FencingPolicySlice) Slice() []*FencingPolicy {
	return op.slice
}

func (op *FencingPolicySlice) SetSlice(slice []*FencingPolicy) {
	op.slice = slice
}

type FileSlice struct {
	href  *string
	slice []*File
}

func (op *FileSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *FileSlice) SetHref(href string) {
	op.href = &href
}

func (op *FileSlice) Slice() []*File {
	return op.slice
}

func (op *FileSlice) SetSlice(slice []*File) {
	op.slice = slice
}

type FilterSlice struct {
	href  *string
	slice []*Filter
}

func (op *FilterSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *FilterSlice) SetHref(href string) {
	op.href = &href
}

func (op *FilterSlice) Slice() []*Filter {
	return op.slice
}

func (op *FilterSlice) SetSlice(slice []*Filter) {
	op.slice = slice
}

type FloppySlice struct {
	href  *string
	slice []*Floppy
}

func (op *FloppySlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *FloppySlice) SetHref(href string) {
	op.href = &href
}

func (op *FloppySlice) Slice() []*Floppy {
	return op.slice
}

func (op *FloppySlice) SetSlice(slice []*Floppy) {
	op.slice = slice
}

type FopStatisticSlice struct {
	href  *string
	slice []*FopStatistic
}

func (op *FopStatisticSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *FopStatisticSlice) SetHref(href string) {
	op.href = &href
}

func (op *FopStatisticSlice) Slice() []*FopStatistic {
	return op.slice
}

func (op *FopStatisticSlice) SetSlice(slice []*FopStatistic) {
	op.slice = slice
}

type GlusterBrickSlice struct {
	href  *string
	slice []*GlusterBrick
}

func (op *GlusterBrickSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *GlusterBrickSlice) SetHref(href string) {
	op.href = &href
}

func (op *GlusterBrickSlice) Slice() []*GlusterBrick {
	return op.slice
}

func (op *GlusterBrickSlice) SetSlice(slice []*GlusterBrick) {
	op.slice = slice
}

type GlusterBrickAdvancedDetailsSlice struct {
	href  *string
	slice []*GlusterBrickAdvancedDetails
}

func (op *GlusterBrickAdvancedDetailsSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *GlusterBrickAdvancedDetailsSlice) SetHref(href string) {
	op.href = &href
}

func (op *GlusterBrickAdvancedDetailsSlice) Slice() []*GlusterBrickAdvancedDetails {
	return op.slice
}

func (op *GlusterBrickAdvancedDetailsSlice) SetSlice(slice []*GlusterBrickAdvancedDetails) {
	op.slice = slice
}

type GlusterBrickMemoryInfoSlice struct {
	href  *string
	slice []*GlusterBrickMemoryInfo
}

func (op *GlusterBrickMemoryInfoSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *GlusterBrickMemoryInfoSlice) SetHref(href string) {
	op.href = &href
}

func (op *GlusterBrickMemoryInfoSlice) Slice() []*GlusterBrickMemoryInfo {
	return op.slice
}

func (op *GlusterBrickMemoryInfoSlice) SetSlice(slice []*GlusterBrickMemoryInfo) {
	op.slice = slice
}

type GlusterClientSlice struct {
	href  *string
	slice []*GlusterClient
}

func (op *GlusterClientSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *GlusterClientSlice) SetHref(href string) {
	op.href = &href
}

func (op *GlusterClientSlice) Slice() []*GlusterClient {
	return op.slice
}

func (op *GlusterClientSlice) SetSlice(slice []*GlusterClient) {
	op.slice = slice
}

type GlusterHookSlice struct {
	href  *string
	slice []*GlusterHook
}

func (op *GlusterHookSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *GlusterHookSlice) SetHref(href string) {
	op.href = &href
}

func (op *GlusterHookSlice) Slice() []*GlusterHook {
	return op.slice
}

func (op *GlusterHookSlice) SetSlice(slice []*GlusterHook) {
	op.slice = slice
}

type GlusterMemoryPoolSlice struct {
	href  *string
	slice []*GlusterMemoryPool
}

func (op *GlusterMemoryPoolSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *GlusterMemoryPoolSlice) SetHref(href string) {
	op.href = &href
}

func (op *GlusterMemoryPoolSlice) Slice() []*GlusterMemoryPool {
	return op.slice
}

func (op *GlusterMemoryPoolSlice) SetSlice(slice []*GlusterMemoryPool) {
	op.slice = slice
}

type GlusterServerHookSlice struct {
	href  *string
	slice []*GlusterServerHook
}

func (op *GlusterServerHookSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *GlusterServerHookSlice) SetHref(href string) {
	op.href = &href
}

func (op *GlusterServerHookSlice) Slice() []*GlusterServerHook {
	return op.slice
}

func (op *GlusterServerHookSlice) SetSlice(slice []*GlusterServerHook) {
	op.slice = slice
}

type GlusterVolumeSlice struct {
	href  *string
	slice []*GlusterVolume
}

func (op *GlusterVolumeSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *GlusterVolumeSlice) SetHref(href string) {
	op.href = &href
}

func (op *GlusterVolumeSlice) Slice() []*GlusterVolume {
	return op.slice
}

func (op *GlusterVolumeSlice) SetSlice(slice []*GlusterVolume) {
	op.slice = slice
}

type GlusterVolumeProfileDetailsSlice struct {
	href  *string
	slice []*GlusterVolumeProfileDetails
}

func (op *GlusterVolumeProfileDetailsSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *GlusterVolumeProfileDetailsSlice) SetHref(href string) {
	op.href = &href
}

func (op *GlusterVolumeProfileDetailsSlice) Slice() []*GlusterVolumeProfileDetails {
	return op.slice
}

func (op *GlusterVolumeProfileDetailsSlice) SetSlice(slice []*GlusterVolumeProfileDetails) {
	op.slice = slice
}

type GraphicsConsoleSlice struct {
	href  *string
	slice []*GraphicsConsole
}

func (op *GraphicsConsoleSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *GraphicsConsoleSlice) SetHref(href string) {
	op.href = &href
}

func (op *GraphicsConsoleSlice) Slice() []*GraphicsConsole {
	return op.slice
}

func (op *GraphicsConsoleSlice) SetSlice(slice []*GraphicsConsole) {
	op.slice = slice
}

type GroupSlice struct {
	href  *string
	slice []*Group
}

func (op *GroupSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *GroupSlice) SetHref(href string) {
	op.href = &href
}

func (op *GroupSlice) Slice() []*Group {
	return op.slice
}

func (op *GroupSlice) SetSlice(slice []*Group) {
	op.slice = slice
}

type GuestOperatingSystemSlice struct {
	href  *string
	slice []*GuestOperatingSystem
}

func (op *GuestOperatingSystemSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *GuestOperatingSystemSlice) SetHref(href string) {
	op.href = &href
}

func (op *GuestOperatingSystemSlice) Slice() []*GuestOperatingSystem {
	return op.slice
}

func (op *GuestOperatingSystemSlice) SetSlice(slice []*GuestOperatingSystem) {
	op.slice = slice
}

type HardwareInformationSlice struct {
	href  *string
	slice []*HardwareInformation
}

func (op *HardwareInformationSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *HardwareInformationSlice) SetHref(href string) {
	op.href = &href
}

func (op *HardwareInformationSlice) Slice() []*HardwareInformation {
	return op.slice
}

func (op *HardwareInformationSlice) SetSlice(slice []*HardwareInformation) {
	op.slice = slice
}

type HighAvailabilitySlice struct {
	href  *string
	slice []*HighAvailability
}

func (op *HighAvailabilitySlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *HighAvailabilitySlice) SetHref(href string) {
	op.href = &href
}

func (op *HighAvailabilitySlice) Slice() []*HighAvailability {
	return op.slice
}

func (op *HighAvailabilitySlice) SetSlice(slice []*HighAvailability) {
	op.slice = slice
}

type HookSlice struct {
	href  *string
	slice []*Hook
}

func (op *HookSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *HookSlice) SetHref(href string) {
	op.href = &href
}

func (op *HookSlice) Slice() []*Hook {
	return op.slice
}

func (op *HookSlice) SetSlice(slice []*Hook) {
	op.slice = slice
}

type HostSlice struct {
	href  *string
	slice []*Host
}

func (op *HostSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *HostSlice) SetHref(href string) {
	op.href = &href
}

func (op *HostSlice) Slice() []*Host {
	return op.slice
}

func (op *HostSlice) SetSlice(slice []*Host) {
	op.slice = slice
}

type HostDeviceSlice struct {
	href  *string
	slice []*HostDevice
}

func (op *HostDeviceSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *HostDeviceSlice) SetHref(href string) {
	op.href = &href
}

func (op *HostDeviceSlice) Slice() []*HostDevice {
	return op.slice
}

func (op *HostDeviceSlice) SetSlice(slice []*HostDevice) {
	op.slice = slice
}

type HostDevicePassthroughSlice struct {
	href  *string
	slice []*HostDevicePassthrough
}

func (op *HostDevicePassthroughSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *HostDevicePassthroughSlice) SetHref(href string) {
	op.href = &href
}

func (op *HostDevicePassthroughSlice) Slice() []*HostDevicePassthrough {
	return op.slice
}

func (op *HostDevicePassthroughSlice) SetSlice(slice []*HostDevicePassthrough) {
	op.slice = slice
}

type HostNicSlice struct {
	href  *string
	slice []*HostNic
}

func (op *HostNicSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *HostNicSlice) SetHref(href string) {
	op.href = &href
}

func (op *HostNicSlice) Slice() []*HostNic {
	return op.slice
}

func (op *HostNicSlice) SetSlice(slice []*HostNic) {
	op.slice = slice
}

type HostNicVirtualFunctionsConfigurationSlice struct {
	href  *string
	slice []*HostNicVirtualFunctionsConfiguration
}

func (op *HostNicVirtualFunctionsConfigurationSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *HostNicVirtualFunctionsConfigurationSlice) SetHref(href string) {
	op.href = &href
}

func (op *HostNicVirtualFunctionsConfigurationSlice) Slice() []*HostNicVirtualFunctionsConfiguration {
	return op.slice
}

func (op *HostNicVirtualFunctionsConfigurationSlice) SetSlice(slice []*HostNicVirtualFunctionsConfiguration) {
	op.slice = slice
}

type HostStorageSlice struct {
	href  *string
	slice []*HostStorage
}

func (op *HostStorageSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *HostStorageSlice) SetHref(href string) {
	op.href = &href
}

func (op *HostStorageSlice) Slice() []*HostStorage {
	return op.slice
}

func (op *HostStorageSlice) SetSlice(slice []*HostStorage) {
	op.slice = slice
}

type HostedEngineSlice struct {
	href  *string
	slice []*HostedEngine
}

func (op *HostedEngineSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *HostedEngineSlice) SetHref(href string) {
	op.href = &href
}

func (op *HostedEngineSlice) Slice() []*HostedEngine {
	return op.slice
}

func (op *HostedEngineSlice) SetSlice(slice []*HostedEngine) {
	op.slice = slice
}

type IconSlice struct {
	href  *string
	slice []*Icon
}

func (op *IconSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *IconSlice) SetHref(href string) {
	op.href = &href
}

func (op *IconSlice) Slice() []*Icon {
	return op.slice
}

func (op *IconSlice) SetSlice(slice []*Icon) {
	op.slice = slice
}

type IdentifiedSlice struct {
	href  *string
	slice []*Identified
}

func (op *IdentifiedSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *IdentifiedSlice) SetHref(href string) {
	op.href = &href
}

func (op *IdentifiedSlice) Slice() []*Identified {
	return op.slice
}

func (op *IdentifiedSlice) SetSlice(slice []*Identified) {
	op.slice = slice
}

type ImageSlice struct {
	href  *string
	slice []*Image
}

func (op *ImageSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *ImageSlice) SetHref(href string) {
	op.href = &href
}

func (op *ImageSlice) Slice() []*Image {
	return op.slice
}

func (op *ImageSlice) SetSlice(slice []*Image) {
	op.slice = slice
}

type ImageTransferSlice struct {
	href  *string
	slice []*ImageTransfer
}

func (op *ImageTransferSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *ImageTransferSlice) SetHref(href string) {
	op.href = &href
}

func (op *ImageTransferSlice) Slice() []*ImageTransfer {
	return op.slice
}

func (op *ImageTransferSlice) SetSlice(slice []*ImageTransfer) {
	op.slice = slice
}

type InitializationSlice struct {
	href  *string
	slice []*Initialization
}

func (op *InitializationSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *InitializationSlice) SetHref(href string) {
	op.href = &href
}

func (op *InitializationSlice) Slice() []*Initialization {
	return op.slice
}

func (op *InitializationSlice) SetSlice(slice []*Initialization) {
	op.slice = slice
}

type InstanceTypeSlice struct {
	href  *string
	slice []*InstanceType
}

func (op *InstanceTypeSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *InstanceTypeSlice) SetHref(href string) {
	op.href = &href
}

func (op *InstanceTypeSlice) Slice() []*InstanceType {
	return op.slice
}

func (op *InstanceTypeSlice) SetSlice(slice []*InstanceType) {
	op.slice = slice
}

type IoSlice struct {
	href  *string
	slice []*Io
}

func (op *IoSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *IoSlice) SetHref(href string) {
	op.href = &href
}

func (op *IoSlice) Slice() []*Io {
	return op.slice
}

func (op *IoSlice) SetSlice(slice []*Io) {
	op.slice = slice
}

type IpSlice struct {
	href  *string
	slice []*Ip
}

func (op *IpSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *IpSlice) SetHref(href string) {
	op.href = &href
}

func (op *IpSlice) Slice() []*Ip {
	return op.slice
}

func (op *IpSlice) SetSlice(slice []*Ip) {
	op.slice = slice
}

type IpAddressAssignmentSlice struct {
	href  *string
	slice []*IpAddressAssignment
}

func (op *IpAddressAssignmentSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *IpAddressAssignmentSlice) SetHref(href string) {
	op.href = &href
}

func (op *IpAddressAssignmentSlice) Slice() []*IpAddressAssignment {
	return op.slice
}

func (op *IpAddressAssignmentSlice) SetSlice(slice []*IpAddressAssignment) {
	op.slice = slice
}

type IscsiBondSlice struct {
	href  *string
	slice []*IscsiBond
}

func (op *IscsiBondSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *IscsiBondSlice) SetHref(href string) {
	op.href = &href
}

func (op *IscsiBondSlice) Slice() []*IscsiBond {
	return op.slice
}

func (op *IscsiBondSlice) SetSlice(slice []*IscsiBond) {
	op.slice = slice
}

type IscsiDetailsSlice struct {
	href  *string
	slice []*IscsiDetails
}

func (op *IscsiDetailsSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *IscsiDetailsSlice) SetHref(href string) {
	op.href = &href
}

func (op *IscsiDetailsSlice) Slice() []*IscsiDetails {
	return op.slice
}

func (op *IscsiDetailsSlice) SetSlice(slice []*IscsiDetails) {
	op.slice = slice
}

type JobSlice struct {
	href  *string
	slice []*Job
}

func (op *JobSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *JobSlice) SetHref(href string) {
	op.href = &href
}

func (op *JobSlice) Slice() []*Job {
	return op.slice
}

func (op *JobSlice) SetSlice(slice []*Job) {
	op.slice = slice
}

type KatelloErratumSlice struct {
	href  *string
	slice []*KatelloErratum
}

func (op *KatelloErratumSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *KatelloErratumSlice) SetHref(href string) {
	op.href = &href
}

func (op *KatelloErratumSlice) Slice() []*KatelloErratum {
	return op.slice
}

func (op *KatelloErratumSlice) SetSlice(slice []*KatelloErratum) {
	op.slice = slice
}

type KernelSlice struct {
	href  *string
	slice []*Kernel
}

func (op *KernelSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *KernelSlice) SetHref(href string) {
	op.href = &href
}

func (op *KernelSlice) Slice() []*Kernel {
	return op.slice
}

func (op *KernelSlice) SetSlice(slice []*Kernel) {
	op.slice = slice
}

type KsmSlice struct {
	href  *string
	slice []*Ksm
}

func (op *KsmSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *KsmSlice) SetHref(href string) {
	op.href = &href
}

func (op *KsmSlice) Slice() []*Ksm {
	return op.slice
}

func (op *KsmSlice) SetSlice(slice []*Ksm) {
	op.slice = slice
}

type LinkLayerDiscoveryProtocolElementSlice struct {
	href  *string
	slice []*LinkLayerDiscoveryProtocolElement
}

func (op *LinkLayerDiscoveryProtocolElementSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *LinkLayerDiscoveryProtocolElementSlice) SetHref(href string) {
	op.href = &href
}

func (op *LinkLayerDiscoveryProtocolElementSlice) Slice() []*LinkLayerDiscoveryProtocolElement {
	return op.slice
}

func (op *LinkLayerDiscoveryProtocolElementSlice) SetSlice(slice []*LinkLayerDiscoveryProtocolElement) {
	op.slice = slice
}

type LogicalUnitSlice struct {
	href  *string
	slice []*LogicalUnit
}

func (op *LogicalUnitSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *LogicalUnitSlice) SetHref(href string) {
	op.href = &href
}

func (op *LogicalUnitSlice) Slice() []*LogicalUnit {
	return op.slice
}

func (op *LogicalUnitSlice) SetSlice(slice []*LogicalUnit) {
	op.slice = slice
}

type MDevTypeSlice struct {
	href  *string
	slice []*MDevType
}

func (op *MDevTypeSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *MDevTypeSlice) SetHref(href string) {
	op.href = &href
}

func (op *MDevTypeSlice) Slice() []*MDevType {
	return op.slice
}

func (op *MDevTypeSlice) SetSlice(slice []*MDevType) {
	op.slice = slice
}

type MacSlice struct {
	href  *string
	slice []*Mac
}

func (op *MacSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *MacSlice) SetHref(href string) {
	op.href = &href
}

func (op *MacSlice) Slice() []*Mac {
	return op.slice
}

func (op *MacSlice) SetSlice(slice []*Mac) {
	op.slice = slice
}

type MacPoolSlice struct {
	href  *string
	slice []*MacPool
}

func (op *MacPoolSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *MacPoolSlice) SetHref(href string) {
	op.href = &href
}

func (op *MacPoolSlice) Slice() []*MacPool {
	return op.slice
}

func (op *MacPoolSlice) SetSlice(slice []*MacPool) {
	op.slice = slice
}

type MemoryOverCommitSlice struct {
	href  *string
	slice []*MemoryOverCommit
}

func (op *MemoryOverCommitSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *MemoryOverCommitSlice) SetHref(href string) {
	op.href = &href
}

func (op *MemoryOverCommitSlice) Slice() []*MemoryOverCommit {
	return op.slice
}

func (op *MemoryOverCommitSlice) SetSlice(slice []*MemoryOverCommit) {
	op.slice = slice
}

type MemoryPolicySlice struct {
	href  *string
	slice []*MemoryPolicy
}

func (op *MemoryPolicySlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *MemoryPolicySlice) SetHref(href string) {
	op.href = &href
}

func (op *MemoryPolicySlice) Slice() []*MemoryPolicy {
	return op.slice
}

func (op *MemoryPolicySlice) SetSlice(slice []*MemoryPolicy) {
	op.slice = slice
}

type MethodSlice struct {
	href  *string
	slice []*Method
}

func (op *MethodSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *MethodSlice) SetHref(href string) {
	op.href = &href
}

func (op *MethodSlice) Slice() []*Method {
	return op.slice
}

func (op *MethodSlice) SetSlice(slice []*Method) {
	op.slice = slice
}

type MigrationBandwidthSlice struct {
	href  *string
	slice []*MigrationBandwidth
}

func (op *MigrationBandwidthSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *MigrationBandwidthSlice) SetHref(href string) {
	op.href = &href
}

func (op *MigrationBandwidthSlice) Slice() []*MigrationBandwidth {
	return op.slice
}

func (op *MigrationBandwidthSlice) SetSlice(slice []*MigrationBandwidth) {
	op.slice = slice
}

type MigrationOptionsSlice struct {
	href  *string
	slice []*MigrationOptions
}

func (op *MigrationOptionsSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *MigrationOptionsSlice) SetHref(href string) {
	op.href = &href
}

func (op *MigrationOptionsSlice) Slice() []*MigrationOptions {
	return op.slice
}

func (op *MigrationOptionsSlice) SetSlice(slice []*MigrationOptions) {
	op.slice = slice
}

type MigrationPolicySlice struct {
	href  *string
	slice []*MigrationPolicy
}

func (op *MigrationPolicySlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *MigrationPolicySlice) SetHref(href string) {
	op.href = &href
}

func (op *MigrationPolicySlice) Slice() []*MigrationPolicy {
	return op.slice
}

func (op *MigrationPolicySlice) SetSlice(slice []*MigrationPolicy) {
	op.slice = slice
}

type NetworkSlice struct {
	href  *string
	slice []*Network
}

func (op *NetworkSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *NetworkSlice) SetHref(href string) {
	op.href = &href
}

func (op *NetworkSlice) Slice() []*Network {
	return op.slice
}

func (op *NetworkSlice) SetSlice(slice []*Network) {
	op.slice = slice
}

type NetworkAttachmentSlice struct {
	href  *string
	slice []*NetworkAttachment
}

func (op *NetworkAttachmentSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *NetworkAttachmentSlice) SetHref(href string) {
	op.href = &href
}

func (op *NetworkAttachmentSlice) Slice() []*NetworkAttachment {
	return op.slice
}

func (op *NetworkAttachmentSlice) SetSlice(slice []*NetworkAttachment) {
	op.slice = slice
}

type NetworkConfigurationSlice struct {
	href  *string
	slice []*NetworkConfiguration
}

func (op *NetworkConfigurationSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *NetworkConfigurationSlice) SetHref(href string) {
	op.href = &href
}

func (op *NetworkConfigurationSlice) Slice() []*NetworkConfiguration {
	return op.slice
}

func (op *NetworkConfigurationSlice) SetSlice(slice []*NetworkConfiguration) {
	op.slice = slice
}

type NetworkFilterSlice struct {
	href  *string
	slice []*NetworkFilter
}

func (op *NetworkFilterSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *NetworkFilterSlice) SetHref(href string) {
	op.href = &href
}

func (op *NetworkFilterSlice) Slice() []*NetworkFilter {
	return op.slice
}

func (op *NetworkFilterSlice) SetSlice(slice []*NetworkFilter) {
	op.slice = slice
}

type NetworkFilterParameterSlice struct {
	href  *string
	slice []*NetworkFilterParameter
}

func (op *NetworkFilterParameterSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *NetworkFilterParameterSlice) SetHref(href string) {
	op.href = &href
}

func (op *NetworkFilterParameterSlice) Slice() []*NetworkFilterParameter {
	return op.slice
}

func (op *NetworkFilterParameterSlice) SetSlice(slice []*NetworkFilterParameter) {
	op.slice = slice
}

type NetworkLabelSlice struct {
	href  *string
	slice []*NetworkLabel
}

func (op *NetworkLabelSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *NetworkLabelSlice) SetHref(href string) {
	op.href = &href
}

func (op *NetworkLabelSlice) Slice() []*NetworkLabel {
	return op.slice
}

func (op *NetworkLabelSlice) SetSlice(slice []*NetworkLabel) {
	op.slice = slice
}

type NfsProfileDetailSlice struct {
	href  *string
	slice []*NfsProfileDetail
}

func (op *NfsProfileDetailSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *NfsProfileDetailSlice) SetHref(href string) {
	op.href = &href
}

func (op *NfsProfileDetailSlice) Slice() []*NfsProfileDetail {
	return op.slice
}

func (op *NfsProfileDetailSlice) SetSlice(slice []*NfsProfileDetail) {
	op.slice = slice
}

type NicSlice struct {
	href  *string
	slice []*Nic
}

func (op *NicSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *NicSlice) SetHref(href string) {
	op.href = &href
}

func (op *NicSlice) Slice() []*Nic {
	return op.slice
}

func (op *NicSlice) SetSlice(slice []*Nic) {
	op.slice = slice
}

type NicConfigurationSlice struct {
	href  *string
	slice []*NicConfiguration
}

func (op *NicConfigurationSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *NicConfigurationSlice) SetHref(href string) {
	op.href = &href
}

func (op *NicConfigurationSlice) Slice() []*NicConfiguration {
	return op.slice
}

func (op *NicConfigurationSlice) SetSlice(slice []*NicConfiguration) {
	op.slice = slice
}

type NumaNodeSlice struct {
	href  *string
	slice []*NumaNode
}

func (op *NumaNodeSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *NumaNodeSlice) SetHref(href string) {
	op.href = &href
}

func (op *NumaNodeSlice) Slice() []*NumaNode {
	return op.slice
}

func (op *NumaNodeSlice) SetSlice(slice []*NumaNode) {
	op.slice = slice
}

type NumaNodePinSlice struct {
	href  *string
	slice []*NumaNodePin
}

func (op *NumaNodePinSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *NumaNodePinSlice) SetHref(href string) {
	op.href = &href
}

func (op *NumaNodePinSlice) Slice() []*NumaNodePin {
	return op.slice
}

func (op *NumaNodePinSlice) SetSlice(slice []*NumaNodePin) {
	op.slice = slice
}

type OpenStackImageSlice struct {
	href  *string
	slice []*OpenStackImage
}

func (op *OpenStackImageSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *OpenStackImageSlice) SetHref(href string) {
	op.href = &href
}

func (op *OpenStackImageSlice) Slice() []*OpenStackImage {
	return op.slice
}

func (op *OpenStackImageSlice) SetSlice(slice []*OpenStackImage) {
	op.slice = slice
}

type OpenStackImageProviderSlice struct {
	href  *string
	slice []*OpenStackImageProvider
}

func (op *OpenStackImageProviderSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *OpenStackImageProviderSlice) SetHref(href string) {
	op.href = &href
}

func (op *OpenStackImageProviderSlice) Slice() []*OpenStackImageProvider {
	return op.slice
}

func (op *OpenStackImageProviderSlice) SetSlice(slice []*OpenStackImageProvider) {
	op.slice = slice
}

type OpenStackNetworkSlice struct {
	href  *string
	slice []*OpenStackNetwork
}

func (op *OpenStackNetworkSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *OpenStackNetworkSlice) SetHref(href string) {
	op.href = &href
}

func (op *OpenStackNetworkSlice) Slice() []*OpenStackNetwork {
	return op.slice
}

func (op *OpenStackNetworkSlice) SetSlice(slice []*OpenStackNetwork) {
	op.slice = slice
}

type OpenStackNetworkProviderSlice struct {
	href  *string
	slice []*OpenStackNetworkProvider
}

func (op *OpenStackNetworkProviderSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *OpenStackNetworkProviderSlice) SetHref(href string) {
	op.href = &href
}

func (op *OpenStackNetworkProviderSlice) Slice() []*OpenStackNetworkProvider {
	return op.slice
}

func (op *OpenStackNetworkProviderSlice) SetSlice(slice []*OpenStackNetworkProvider) {
	op.slice = slice
}

type OpenStackProviderSlice struct {
	href  *string
	slice []*OpenStackProvider
}

func (op *OpenStackProviderSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *OpenStackProviderSlice) SetHref(href string) {
	op.href = &href
}

func (op *OpenStackProviderSlice) Slice() []*OpenStackProvider {
	return op.slice
}

func (op *OpenStackProviderSlice) SetSlice(slice []*OpenStackProvider) {
	op.slice = slice
}

type OpenStackSubnetSlice struct {
	href  *string
	slice []*OpenStackSubnet
}

func (op *OpenStackSubnetSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *OpenStackSubnetSlice) SetHref(href string) {
	op.href = &href
}

func (op *OpenStackSubnetSlice) Slice() []*OpenStackSubnet {
	return op.slice
}

func (op *OpenStackSubnetSlice) SetSlice(slice []*OpenStackSubnet) {
	op.slice = slice
}

type OpenStackVolumeProviderSlice struct {
	href  *string
	slice []*OpenStackVolumeProvider
}

func (op *OpenStackVolumeProviderSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *OpenStackVolumeProviderSlice) SetHref(href string) {
	op.href = &href
}

func (op *OpenStackVolumeProviderSlice) Slice() []*OpenStackVolumeProvider {
	return op.slice
}

func (op *OpenStackVolumeProviderSlice) SetSlice(slice []*OpenStackVolumeProvider) {
	op.slice = slice
}

type OpenStackVolumeTypeSlice struct {
	href  *string
	slice []*OpenStackVolumeType
}

func (op *OpenStackVolumeTypeSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *OpenStackVolumeTypeSlice) SetHref(href string) {
	op.href = &href
}

func (op *OpenStackVolumeTypeSlice) Slice() []*OpenStackVolumeType {
	return op.slice
}

func (op *OpenStackVolumeTypeSlice) SetSlice(slice []*OpenStackVolumeType) {
	op.slice = slice
}

type OpenstackVolumeAuthenticationKeySlice struct {
	href  *string
	slice []*OpenstackVolumeAuthenticationKey
}

func (op *OpenstackVolumeAuthenticationKeySlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *OpenstackVolumeAuthenticationKeySlice) SetHref(href string) {
	op.href = &href
}

func (op *OpenstackVolumeAuthenticationKeySlice) Slice() []*OpenstackVolumeAuthenticationKey {
	return op.slice
}

func (op *OpenstackVolumeAuthenticationKeySlice) SetSlice(slice []*OpenstackVolumeAuthenticationKey) {
	op.slice = slice
}

type OperatingSystemSlice struct {
	href  *string
	slice []*OperatingSystem
}

func (op *OperatingSystemSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *OperatingSystemSlice) SetHref(href string) {
	op.href = &href
}

func (op *OperatingSystemSlice) Slice() []*OperatingSystem {
	return op.slice
}

func (op *OperatingSystemSlice) SetSlice(slice []*OperatingSystem) {
	op.slice = slice
}

type OperatingSystemInfoSlice struct {
	href  *string
	slice []*OperatingSystemInfo
}

func (op *OperatingSystemInfoSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *OperatingSystemInfoSlice) SetHref(href string) {
	op.href = &href
}

func (op *OperatingSystemInfoSlice) Slice() []*OperatingSystemInfo {
	return op.slice
}

func (op *OperatingSystemInfoSlice) SetSlice(slice []*OperatingSystemInfo) {
	op.slice = slice
}

type OptionSlice struct {
	href  *string
	slice []*Option
}

func (op *OptionSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *OptionSlice) SetHref(href string) {
	op.href = &href
}

func (op *OptionSlice) Slice() []*Option {
	return op.slice
}

func (op *OptionSlice) SetSlice(slice []*Option) {
	op.slice = slice
}

type PackageSlice struct {
	href  *string
	slice []*Package
}

func (op *PackageSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *PackageSlice) SetHref(href string) {
	op.href = &href
}

func (op *PackageSlice) Slice() []*Package {
	return op.slice
}

func (op *PackageSlice) SetSlice(slice []*Package) {
	op.slice = slice
}

type PayloadSlice struct {
	href  *string
	slice []*Payload
}

func (op *PayloadSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *PayloadSlice) SetHref(href string) {
	op.href = &href
}

func (op *PayloadSlice) Slice() []*Payload {
	return op.slice
}

func (op *PayloadSlice) SetSlice(slice []*Payload) {
	op.slice = slice
}

type PermissionSlice struct {
	href  *string
	slice []*Permission
}

func (op *PermissionSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *PermissionSlice) SetHref(href string) {
	op.href = &href
}

func (op *PermissionSlice) Slice() []*Permission {
	return op.slice
}

func (op *PermissionSlice) SetSlice(slice []*Permission) {
	op.slice = slice
}

type PermitSlice struct {
	href  *string
	slice []*Permit
}

func (op *PermitSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *PermitSlice) SetHref(href string) {
	op.href = &href
}

func (op *PermitSlice) Slice() []*Permit {
	return op.slice
}

func (op *PermitSlice) SetSlice(slice []*Permit) {
	op.slice = slice
}

type PmProxySlice struct {
	href  *string
	slice []*PmProxy
}

func (op *PmProxySlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *PmProxySlice) SetHref(href string) {
	op.href = &href
}

func (op *PmProxySlice) Slice() []*PmProxy {
	return op.slice
}

func (op *PmProxySlice) SetSlice(slice []*PmProxy) {
	op.slice = slice
}

type PortMirroringSlice struct {
	href  *string
	slice []*PortMirroring
}

func (op *PortMirroringSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *PortMirroringSlice) SetHref(href string) {
	op.href = &href
}

func (op *PortMirroringSlice) Slice() []*PortMirroring {
	return op.slice
}

func (op *PortMirroringSlice) SetSlice(slice []*PortMirroring) {
	op.slice = slice
}

type PowerManagementSlice struct {
	href  *string
	slice []*PowerManagement
}

func (op *PowerManagementSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *PowerManagementSlice) SetHref(href string) {
	op.href = &href
}

func (op *PowerManagementSlice) Slice() []*PowerManagement {
	return op.slice
}

func (op *PowerManagementSlice) SetSlice(slice []*PowerManagement) {
	op.slice = slice
}

type ProductSlice struct {
	href  *string
	slice []*Product
}

func (op *ProductSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *ProductSlice) SetHref(href string) {
	op.href = &href
}

func (op *ProductSlice) Slice() []*Product {
	return op.slice
}

func (op *ProductSlice) SetSlice(slice []*Product) {
	op.slice = slice
}

type ProductInfoSlice struct {
	href  *string
	slice []*ProductInfo
}

func (op *ProductInfoSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *ProductInfoSlice) SetHref(href string) {
	op.href = &href
}

func (op *ProductInfoSlice) Slice() []*ProductInfo {
	return op.slice
}

func (op *ProductInfoSlice) SetSlice(slice []*ProductInfo) {
	op.slice = slice
}

type ProfileDetailSlice struct {
	href  *string
	slice []*ProfileDetail
}

func (op *ProfileDetailSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *ProfileDetailSlice) SetHref(href string) {
	op.href = &href
}

func (op *ProfileDetailSlice) Slice() []*ProfileDetail {
	return op.slice
}

func (op *ProfileDetailSlice) SetSlice(slice []*ProfileDetail) {
	op.slice = slice
}

type PropertySlice struct {
	href  *string
	slice []*Property
}

func (op *PropertySlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *PropertySlice) SetHref(href string) {
	op.href = &href
}

func (op *PropertySlice) Slice() []*Property {
	return op.slice
}

func (op *PropertySlice) SetSlice(slice []*Property) {
	op.slice = slice
}

type ProxyTicketSlice struct {
	href  *string
	slice []*ProxyTicket
}

func (op *ProxyTicketSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *ProxyTicketSlice) SetHref(href string) {
	op.href = &href
}

func (op *ProxyTicketSlice) Slice() []*ProxyTicket {
	return op.slice
}

func (op *ProxyTicketSlice) SetSlice(slice []*ProxyTicket) {
	op.slice = slice
}

type QosSlice struct {
	href  *string
	slice []*Qos
}

func (op *QosSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *QosSlice) SetHref(href string) {
	op.href = &href
}

func (op *QosSlice) Slice() []*Qos {
	return op.slice
}

func (op *QosSlice) SetSlice(slice []*Qos) {
	op.slice = slice
}

type QuotaSlice struct {
	href  *string
	slice []*Quota
}

func (op *QuotaSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *QuotaSlice) SetHref(href string) {
	op.href = &href
}

func (op *QuotaSlice) Slice() []*Quota {
	return op.slice
}

func (op *QuotaSlice) SetSlice(slice []*Quota) {
	op.slice = slice
}

type QuotaClusterLimitSlice struct {
	href  *string
	slice []*QuotaClusterLimit
}

func (op *QuotaClusterLimitSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *QuotaClusterLimitSlice) SetHref(href string) {
	op.href = &href
}

func (op *QuotaClusterLimitSlice) Slice() []*QuotaClusterLimit {
	return op.slice
}

func (op *QuotaClusterLimitSlice) SetSlice(slice []*QuotaClusterLimit) {
	op.slice = slice
}

type QuotaStorageLimitSlice struct {
	href  *string
	slice []*QuotaStorageLimit
}

func (op *QuotaStorageLimitSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *QuotaStorageLimitSlice) SetHref(href string) {
	op.href = &href
}

func (op *QuotaStorageLimitSlice) Slice() []*QuotaStorageLimit {
	return op.slice
}

func (op *QuotaStorageLimitSlice) SetSlice(slice []*QuotaStorageLimit) {
	op.slice = slice
}

type RangeSlice struct {
	href  *string
	slice []*Range
}

func (op *RangeSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *RangeSlice) SetHref(href string) {
	op.href = &href
}

func (op *RangeSlice) Slice() []*Range {
	return op.slice
}

func (op *RangeSlice) SetSlice(slice []*Range) {
	op.slice = slice
}

type RateSlice struct {
	href  *string
	slice []*Rate
}

func (op *RateSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *RateSlice) SetHref(href string) {
	op.href = &href
}

func (op *RateSlice) Slice() []*Rate {
	return op.slice
}

func (op *RateSlice) SetSlice(slice []*Rate) {
	op.slice = slice
}

type RegistrationAffinityGroupMappingSlice struct {
	href  *string
	slice []*RegistrationAffinityGroupMapping
}

func (op *RegistrationAffinityGroupMappingSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *RegistrationAffinityGroupMappingSlice) SetHref(href string) {
	op.href = &href
}

func (op *RegistrationAffinityGroupMappingSlice) Slice() []*RegistrationAffinityGroupMapping {
	return op.slice
}

func (op *RegistrationAffinityGroupMappingSlice) SetSlice(slice []*RegistrationAffinityGroupMapping) {
	op.slice = slice
}

type RegistrationAffinityLabelMappingSlice struct {
	href  *string
	slice []*RegistrationAffinityLabelMapping
}

func (op *RegistrationAffinityLabelMappingSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *RegistrationAffinityLabelMappingSlice) SetHref(href string) {
	op.href = &href
}

func (op *RegistrationAffinityLabelMappingSlice) Slice() []*RegistrationAffinityLabelMapping {
	return op.slice
}

func (op *RegistrationAffinityLabelMappingSlice) SetSlice(slice []*RegistrationAffinityLabelMapping) {
	op.slice = slice
}

type RegistrationClusterMappingSlice struct {
	href  *string
	slice []*RegistrationClusterMapping
}

func (op *RegistrationClusterMappingSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *RegistrationClusterMappingSlice) SetHref(href string) {
	op.href = &href
}

func (op *RegistrationClusterMappingSlice) Slice() []*RegistrationClusterMapping {
	return op.slice
}

func (op *RegistrationClusterMappingSlice) SetSlice(slice []*RegistrationClusterMapping) {
	op.slice = slice
}

type RegistrationConfigurationSlice struct {
	href  *string
	slice []*RegistrationConfiguration
}

func (op *RegistrationConfigurationSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *RegistrationConfigurationSlice) SetHref(href string) {
	op.href = &href
}

func (op *RegistrationConfigurationSlice) Slice() []*RegistrationConfiguration {
	return op.slice
}

func (op *RegistrationConfigurationSlice) SetSlice(slice []*RegistrationConfiguration) {
	op.slice = slice
}

type RegistrationDomainMappingSlice struct {
	href  *string
	slice []*RegistrationDomainMapping
}

func (op *RegistrationDomainMappingSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *RegistrationDomainMappingSlice) SetHref(href string) {
	op.href = &href
}

func (op *RegistrationDomainMappingSlice) Slice() []*RegistrationDomainMapping {
	return op.slice
}

func (op *RegistrationDomainMappingSlice) SetSlice(slice []*RegistrationDomainMapping) {
	op.slice = slice
}

type RegistrationLunMappingSlice struct {
	href  *string
	slice []*RegistrationLunMapping
}

func (op *RegistrationLunMappingSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *RegistrationLunMappingSlice) SetHref(href string) {
	op.href = &href
}

func (op *RegistrationLunMappingSlice) Slice() []*RegistrationLunMapping {
	return op.slice
}

func (op *RegistrationLunMappingSlice) SetSlice(slice []*RegistrationLunMapping) {
	op.slice = slice
}

type RegistrationRoleMappingSlice struct {
	href  *string
	slice []*RegistrationRoleMapping
}

func (op *RegistrationRoleMappingSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *RegistrationRoleMappingSlice) SetHref(href string) {
	op.href = &href
}

func (op *RegistrationRoleMappingSlice) Slice() []*RegistrationRoleMapping {
	return op.slice
}

func (op *RegistrationRoleMappingSlice) SetSlice(slice []*RegistrationRoleMapping) {
	op.slice = slice
}

type RegistrationVnicProfileMappingSlice struct {
	href  *string
	slice []*RegistrationVnicProfileMapping
}

func (op *RegistrationVnicProfileMappingSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *RegistrationVnicProfileMappingSlice) SetHref(href string) {
	op.href = &href
}

func (op *RegistrationVnicProfileMappingSlice) Slice() []*RegistrationVnicProfileMapping {
	return op.slice
}

func (op *RegistrationVnicProfileMappingSlice) SetSlice(slice []*RegistrationVnicProfileMapping) {
	op.slice = slice
}

type ReportedConfigurationSlice struct {
	href  *string
	slice []*ReportedConfiguration
}

func (op *ReportedConfigurationSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *ReportedConfigurationSlice) SetHref(href string) {
	op.href = &href
}

func (op *ReportedConfigurationSlice) Slice() []*ReportedConfiguration {
	return op.slice
}

func (op *ReportedConfigurationSlice) SetSlice(slice []*ReportedConfiguration) {
	op.slice = slice
}

type ReportedDeviceSlice struct {
	href  *string
	slice []*ReportedDevice
}

func (op *ReportedDeviceSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *ReportedDeviceSlice) SetHref(href string) {
	op.href = &href
}

func (op *ReportedDeviceSlice) Slice() []*ReportedDevice {
	return op.slice
}

func (op *ReportedDeviceSlice) SetSlice(slice []*ReportedDevice) {
	op.slice = slice
}

type RngDeviceSlice struct {
	href  *string
	slice []*RngDevice
}

func (op *RngDeviceSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *RngDeviceSlice) SetHref(href string) {
	op.href = &href
}

func (op *RngDeviceSlice) Slice() []*RngDevice {
	return op.slice
}

func (op *RngDeviceSlice) SetSlice(slice []*RngDevice) {
	op.slice = slice
}

type RoleSlice struct {
	href  *string
	slice []*Role
}

func (op *RoleSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *RoleSlice) SetHref(href string) {
	op.href = &href
}

func (op *RoleSlice) Slice() []*Role {
	return op.slice
}

func (op *RoleSlice) SetSlice(slice []*Role) {
	op.slice = slice
}

type SchedulingPolicySlice struct {
	href  *string
	slice []*SchedulingPolicy
}

func (op *SchedulingPolicySlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *SchedulingPolicySlice) SetHref(href string) {
	op.href = &href
}

func (op *SchedulingPolicySlice) Slice() []*SchedulingPolicy {
	return op.slice
}

func (op *SchedulingPolicySlice) SetSlice(slice []*SchedulingPolicy) {
	op.slice = slice
}

type SchedulingPolicyUnitSlice struct {
	href  *string
	slice []*SchedulingPolicyUnit
}

func (op *SchedulingPolicyUnitSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *SchedulingPolicyUnitSlice) SetHref(href string) {
	op.href = &href
}

func (op *SchedulingPolicyUnitSlice) Slice() []*SchedulingPolicyUnit {
	return op.slice
}

func (op *SchedulingPolicyUnitSlice) SetSlice(slice []*SchedulingPolicyUnit) {
	op.slice = slice
}

type SeLinuxSlice struct {
	href  *string
	slice []*SeLinux
}

func (op *SeLinuxSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *SeLinuxSlice) SetHref(href string) {
	op.href = &href
}

func (op *SeLinuxSlice) Slice() []*SeLinux {
	return op.slice
}

func (op *SeLinuxSlice) SetSlice(slice []*SeLinux) {
	op.slice = slice
}

type SerialNumberSlice struct {
	href  *string
	slice []*SerialNumber
}

func (op *SerialNumberSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *SerialNumberSlice) SetHref(href string) {
	op.href = &href
}

func (op *SerialNumberSlice) Slice() []*SerialNumber {
	return op.slice
}

func (op *SerialNumberSlice) SetSlice(slice []*SerialNumber) {
	op.slice = slice
}

type SessionSlice struct {
	href  *string
	slice []*Session
}

func (op *SessionSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *SessionSlice) SetHref(href string) {
	op.href = &href
}

func (op *SessionSlice) Slice() []*Session {
	return op.slice
}

func (op *SessionSlice) SetSlice(slice []*Session) {
	op.slice = slice
}

type SkipIfConnectivityBrokenSlice struct {
	href  *string
	slice []*SkipIfConnectivityBroken
}

func (op *SkipIfConnectivityBrokenSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *SkipIfConnectivityBrokenSlice) SetHref(href string) {
	op.href = &href
}

func (op *SkipIfConnectivityBrokenSlice) Slice() []*SkipIfConnectivityBroken {
	return op.slice
}

func (op *SkipIfConnectivityBrokenSlice) SetSlice(slice []*SkipIfConnectivityBroken) {
	op.slice = slice
}

type SkipIfSdActiveSlice struct {
	href  *string
	slice []*SkipIfSdActive
}

func (op *SkipIfSdActiveSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *SkipIfSdActiveSlice) SetHref(href string) {
	op.href = &href
}

func (op *SkipIfSdActiveSlice) Slice() []*SkipIfSdActive {
	return op.slice
}

func (op *SkipIfSdActiveSlice) SetSlice(slice []*SkipIfSdActive) {
	op.slice = slice
}

type SnapshotSlice struct {
	href  *string
	slice []*Snapshot
}

func (op *SnapshotSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *SnapshotSlice) SetHref(href string) {
	op.href = &href
}

func (op *SnapshotSlice) Slice() []*Snapshot {
	return op.slice
}

func (op *SnapshotSlice) SetSlice(slice []*Snapshot) {
	op.slice = slice
}

type SpecialObjectsSlice struct {
	href  *string
	slice []*SpecialObjects
}

func (op *SpecialObjectsSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *SpecialObjectsSlice) SetHref(href string) {
	op.href = &href
}

func (op *SpecialObjectsSlice) Slice() []*SpecialObjects {
	return op.slice
}

func (op *SpecialObjectsSlice) SetSlice(slice []*SpecialObjects) {
	op.slice = slice
}

type SpmSlice struct {
	href  *string
	slice []*Spm
}

func (op *SpmSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *SpmSlice) SetHref(href string) {
	op.href = &href
}

func (op *SpmSlice) Slice() []*Spm {
	return op.slice
}

func (op *SpmSlice) SetSlice(slice []*Spm) {
	op.slice = slice
}

type SshSlice struct {
	href  *string
	slice []*Ssh
}

func (op *SshSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *SshSlice) SetHref(href string) {
	op.href = &href
}

func (op *SshSlice) Slice() []*Ssh {
	return op.slice
}

func (op *SshSlice) SetSlice(slice []*Ssh) {
	op.slice = slice
}

type SshPublicKeySlice struct {
	href  *string
	slice []*SshPublicKey
}

func (op *SshPublicKeySlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *SshPublicKeySlice) SetHref(href string) {
	op.href = &href
}

func (op *SshPublicKeySlice) Slice() []*SshPublicKey {
	return op.slice
}

func (op *SshPublicKeySlice) SetSlice(slice []*SshPublicKey) {
	op.slice = slice
}

type SsoSlice struct {
	href  *string
	slice []*Sso
}

func (op *SsoSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *SsoSlice) SetHref(href string) {
	op.href = &href
}

func (op *SsoSlice) Slice() []*Sso {
	return op.slice
}

func (op *SsoSlice) SetSlice(slice []*Sso) {
	op.slice = slice
}

type StatisticSlice struct {
	href  *string
	slice []*Statistic
}

func (op *StatisticSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *StatisticSlice) SetHref(href string) {
	op.href = &href
}

func (op *StatisticSlice) Slice() []*Statistic {
	return op.slice
}

func (op *StatisticSlice) SetSlice(slice []*Statistic) {
	op.slice = slice
}

type StepSlice struct {
	href  *string
	slice []*Step
}

func (op *StepSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *StepSlice) SetHref(href string) {
	op.href = &href
}

func (op *StepSlice) Slice() []*Step {
	return op.slice
}

func (op *StepSlice) SetSlice(slice []*Step) {
	op.slice = slice
}

type StorageConnectionSlice struct {
	href  *string
	slice []*StorageConnection
}

func (op *StorageConnectionSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *StorageConnectionSlice) SetHref(href string) {
	op.href = &href
}

func (op *StorageConnectionSlice) Slice() []*StorageConnection {
	return op.slice
}

func (op *StorageConnectionSlice) SetSlice(slice []*StorageConnection) {
	op.slice = slice
}

type StorageConnectionExtensionSlice struct {
	href  *string
	slice []*StorageConnectionExtension
}

func (op *StorageConnectionExtensionSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *StorageConnectionExtensionSlice) SetHref(href string) {
	op.href = &href
}

func (op *StorageConnectionExtensionSlice) Slice() []*StorageConnectionExtension {
	return op.slice
}

func (op *StorageConnectionExtensionSlice) SetSlice(slice []*StorageConnectionExtension) {
	op.slice = slice
}

type StorageDomainSlice struct {
	href  *string
	slice []*StorageDomain
}

func (op *StorageDomainSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *StorageDomainSlice) SetHref(href string) {
	op.href = &href
}

func (op *StorageDomainSlice) Slice() []*StorageDomain {
	return op.slice
}

func (op *StorageDomainSlice) SetSlice(slice []*StorageDomain) {
	op.slice = slice
}

type StorageDomainLeaseSlice struct {
	href  *string
	slice []*StorageDomainLease
}

func (op *StorageDomainLeaseSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *StorageDomainLeaseSlice) SetHref(href string) {
	op.href = &href
}

func (op *StorageDomainLeaseSlice) Slice() []*StorageDomainLease {
	return op.slice
}

func (op *StorageDomainLeaseSlice) SetSlice(slice []*StorageDomainLease) {
	op.slice = slice
}

type SystemOptionSlice struct {
	href  *string
	slice []*SystemOption
}

func (op *SystemOptionSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *SystemOptionSlice) SetHref(href string) {
	op.href = &href
}

func (op *SystemOptionSlice) Slice() []*SystemOption {
	return op.slice
}

func (op *SystemOptionSlice) SetSlice(slice []*SystemOption) {
	op.slice = slice
}

type SystemOptionValueSlice struct {
	href  *string
	slice []*SystemOptionValue
}

func (op *SystemOptionValueSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *SystemOptionValueSlice) SetHref(href string) {
	op.href = &href
}

func (op *SystemOptionValueSlice) Slice() []*SystemOptionValue {
	return op.slice
}

func (op *SystemOptionValueSlice) SetSlice(slice []*SystemOptionValue) {
	op.slice = slice
}

type TagSlice struct {
	href  *string
	slice []*Tag
}

func (op *TagSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *TagSlice) SetHref(href string) {
	op.href = &href
}

func (op *TagSlice) Slice() []*Tag {
	return op.slice
}

func (op *TagSlice) SetSlice(slice []*Tag) {
	op.slice = slice
}

type TemplateSlice struct {
	href  *string
	slice []*Template
}

func (op *TemplateSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *TemplateSlice) SetHref(href string) {
	op.href = &href
}

func (op *TemplateSlice) Slice() []*Template {
	return op.slice
}

func (op *TemplateSlice) SetSlice(slice []*Template) {
	op.slice = slice
}

type TemplateVersionSlice struct {
	href  *string
	slice []*TemplateVersion
}

func (op *TemplateVersionSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *TemplateVersionSlice) SetHref(href string) {
	op.href = &href
}

func (op *TemplateVersionSlice) Slice() []*TemplateVersion {
	return op.slice
}

func (op *TemplateVersionSlice) SetSlice(slice []*TemplateVersion) {
	op.slice = slice
}

type TicketSlice struct {
	href  *string
	slice []*Ticket
}

func (op *TicketSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *TicketSlice) SetHref(href string) {
	op.href = &href
}

func (op *TicketSlice) Slice() []*Ticket {
	return op.slice
}

func (op *TicketSlice) SetSlice(slice []*Ticket) {
	op.slice = slice
}

type TimeZoneSlice struct {
	href  *string
	slice []*TimeZone
}

func (op *TimeZoneSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *TimeZoneSlice) SetHref(href string) {
	op.href = &href
}

func (op *TimeZoneSlice) Slice() []*TimeZone {
	return op.slice
}

func (op *TimeZoneSlice) SetSlice(slice []*TimeZone) {
	op.slice = slice
}

type TransparentHugePagesSlice struct {
	href  *string
	slice []*TransparentHugePages
}

func (op *TransparentHugePagesSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *TransparentHugePagesSlice) SetHref(href string) {
	op.href = &href
}

func (op *TransparentHugePagesSlice) Slice() []*TransparentHugePages {
	return op.slice
}

func (op *TransparentHugePagesSlice) SetSlice(slice []*TransparentHugePages) {
	op.slice = slice
}

type UnmanagedNetworkSlice struct {
	href  *string
	slice []*UnmanagedNetwork
}

func (op *UnmanagedNetworkSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *UnmanagedNetworkSlice) SetHref(href string) {
	op.href = &href
}

func (op *UnmanagedNetworkSlice) Slice() []*UnmanagedNetwork {
	return op.slice
}

func (op *UnmanagedNetworkSlice) SetSlice(slice []*UnmanagedNetwork) {
	op.slice = slice
}

type UsbSlice struct {
	href  *string
	slice []*Usb
}

func (op *UsbSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *UsbSlice) SetHref(href string) {
	op.href = &href
}

func (op *UsbSlice) Slice() []*Usb {
	return op.slice
}

func (op *UsbSlice) SetSlice(slice []*Usb) {
	op.slice = slice
}

type UserSlice struct {
	href  *string
	slice []*User
}

func (op *UserSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *UserSlice) SetHref(href string) {
	op.href = &href
}

func (op *UserSlice) Slice() []*User {
	return op.slice
}

func (op *UserSlice) SetSlice(slice []*User) {
	op.slice = slice
}

type UserOptionSlice struct {
	href  *string
	slice []*UserOption
}

func (op *UserOptionSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *UserOptionSlice) SetHref(href string) {
	op.href = &href
}

func (op *UserOptionSlice) Slice() []*UserOption {
	return op.slice
}

func (op *UserOptionSlice) SetSlice(slice []*UserOption) {
	op.slice = slice
}

type ValueSlice struct {
	href  *string
	slice []*Value
}

func (op *ValueSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *ValueSlice) SetHref(href string) {
	op.href = &href
}

func (op *ValueSlice) Slice() []*Value {
	return op.slice
}

func (op *ValueSlice) SetSlice(slice []*Value) {
	op.slice = slice
}

type VcpuPinSlice struct {
	href  *string
	slice []*VcpuPin
}

func (op *VcpuPinSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *VcpuPinSlice) SetHref(href string) {
	op.href = &href
}

func (op *VcpuPinSlice) Slice() []*VcpuPin {
	return op.slice
}

func (op *VcpuPinSlice) SetSlice(slice []*VcpuPin) {
	op.slice = slice
}

type VendorSlice struct {
	href  *string
	slice []*Vendor
}

func (op *VendorSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *VendorSlice) SetHref(href string) {
	op.href = &href
}

func (op *VendorSlice) Slice() []*Vendor {
	return op.slice
}

func (op *VendorSlice) SetSlice(slice []*Vendor) {
	op.slice = slice
}

type VersionSlice struct {
	href  *string
	slice []*Version
}

func (op *VersionSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *VersionSlice) SetHref(href string) {
	op.href = &href
}

func (op *VersionSlice) Slice() []*Version {
	return op.slice
}

func (op *VersionSlice) SetSlice(slice []*Version) {
	op.slice = slice
}

type VirtioScsiSlice struct {
	href  *string
	slice []*VirtioScsi
}

func (op *VirtioScsiSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *VirtioScsiSlice) SetHref(href string) {
	op.href = &href
}

func (op *VirtioScsiSlice) Slice() []*VirtioScsi {
	return op.slice
}

func (op *VirtioScsiSlice) SetSlice(slice []*VirtioScsi) {
	op.slice = slice
}

type VirtualNumaNodeSlice struct {
	href  *string
	slice []*VirtualNumaNode
}

func (op *VirtualNumaNodeSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *VirtualNumaNodeSlice) SetHref(href string) {
	op.href = &href
}

func (op *VirtualNumaNodeSlice) Slice() []*VirtualNumaNode {
	return op.slice
}

func (op *VirtualNumaNodeSlice) SetSlice(slice []*VirtualNumaNode) {
	op.slice = slice
}

type VlanSlice struct {
	href  *string
	slice []*Vlan
}

func (op *VlanSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *VlanSlice) SetHref(href string) {
	op.href = &href
}

func (op *VlanSlice) Slice() []*Vlan {
	return op.slice
}

func (op *VlanSlice) SetSlice(slice []*Vlan) {
	op.slice = slice
}

type VmSlice struct {
	href  *string
	slice []*Vm
}

func (op *VmSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *VmSlice) SetHref(href string) {
	op.href = &href
}

func (op *VmSlice) Slice() []*Vm {
	return op.slice
}

func (op *VmSlice) SetSlice(slice []*Vm) {
	op.slice = slice
}

type VmBaseSlice struct {
	href  *string
	slice []*VmBase
}

func (op *VmBaseSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *VmBaseSlice) SetHref(href string) {
	op.href = &href
}

func (op *VmBaseSlice) Slice() []*VmBase {
	return op.slice
}

func (op *VmBaseSlice) SetSlice(slice []*VmBase) {
	op.slice = slice
}

type VmPlacementPolicySlice struct {
	href  *string
	slice []*VmPlacementPolicy
}

func (op *VmPlacementPolicySlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *VmPlacementPolicySlice) SetHref(href string) {
	op.href = &href
}

func (op *VmPlacementPolicySlice) Slice() []*VmPlacementPolicy {
	return op.slice
}

func (op *VmPlacementPolicySlice) SetSlice(slice []*VmPlacementPolicy) {
	op.slice = slice
}

type VmPoolSlice struct {
	href  *string
	slice []*VmPool
}

func (op *VmPoolSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *VmPoolSlice) SetHref(href string) {
	op.href = &href
}

func (op *VmPoolSlice) Slice() []*VmPool {
	return op.slice
}

func (op *VmPoolSlice) SetSlice(slice []*VmPool) {
	op.slice = slice
}

type VmSummarySlice struct {
	href  *string
	slice []*VmSummary
}

func (op *VmSummarySlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *VmSummarySlice) SetHref(href string) {
	op.href = &href
}

func (op *VmSummarySlice) Slice() []*VmSummary {
	return op.slice
}

func (op *VmSummarySlice) SetSlice(slice []*VmSummary) {
	op.slice = slice
}

type VnicPassThroughSlice struct {
	href  *string
	slice []*VnicPassThrough
}

func (op *VnicPassThroughSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *VnicPassThroughSlice) SetHref(href string) {
	op.href = &href
}

func (op *VnicPassThroughSlice) Slice() []*VnicPassThrough {
	return op.slice
}

func (op *VnicPassThroughSlice) SetSlice(slice []*VnicPassThrough) {
	op.slice = slice
}

type VnicProfileSlice struct {
	href  *string
	slice []*VnicProfile
}

func (op *VnicProfileSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *VnicProfileSlice) SetHref(href string) {
	op.href = &href
}

func (op *VnicProfileSlice) Slice() []*VnicProfile {
	return op.slice
}

func (op *VnicProfileSlice) SetSlice(slice []*VnicProfile) {
	op.slice = slice
}

type VnicProfileMappingSlice struct {
	href  *string
	slice []*VnicProfileMapping
}

func (op *VnicProfileMappingSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *VnicProfileMappingSlice) SetHref(href string) {
	op.href = &href
}

func (op *VnicProfileMappingSlice) Slice() []*VnicProfileMapping {
	return op.slice
}

func (op *VnicProfileMappingSlice) SetSlice(slice []*VnicProfileMapping) {
	op.slice = slice
}

type VolumeGroupSlice struct {
	href  *string
	slice []*VolumeGroup
}

func (op *VolumeGroupSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *VolumeGroupSlice) SetHref(href string) {
	op.href = &href
}

func (op *VolumeGroupSlice) Slice() []*VolumeGroup {
	return op.slice
}

func (op *VolumeGroupSlice) SetSlice(slice []*VolumeGroup) {
	op.slice = slice
}

type WatchdogSlice struct {
	href  *string
	slice []*Watchdog
}

func (op *WatchdogSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *WatchdogSlice) SetHref(href string) {
	op.href = &href
}

func (op *WatchdogSlice) Slice() []*Watchdog {
	return op.slice
}

func (op *WatchdogSlice) SetSlice(slice []*Watchdog) {
	op.slice = slice
}

type WeightSlice struct {
	href  *string
	slice []*Weight
}

func (op *WeightSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *WeightSlice) SetHref(href string) {
	op.href = &href
}

func (op *WeightSlice) Slice() []*Weight {
	return op.slice
}

func (op *WeightSlice) SetSlice(slice []*Weight) {
	op.slice = slice
}

type FaultSlice struct {
	href  *string
	slice []*Fault
}

func (op *FaultSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *FaultSlice) SetHref(href string) {
	op.href = &href
}

func (op *FaultSlice) Slice() []*Fault {
	return op.slice
}

func (op *FaultSlice) SetSlice(slice []*Fault) {
	op.slice = slice
}

type GracePeriodSlice struct {
	href  *string
	slice []*GracePeriod
}

func (op *GracePeriodSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *GracePeriodSlice) SetHref(href string) {
	op.href = &href
}

func (op *GracePeriodSlice) Slice() []*GracePeriod {
	return op.slice
}

func (op *GracePeriodSlice) SetSlice(slice []*GracePeriod) {
	op.slice = slice
}

type ActionSlice struct {
	href  *string
	slice []*Action
}

func (op *ActionSlice) Href() (string, bool) {
	if op.href == nil {
		return "", false
	}
	return *op.href, true
}

func (op *ActionSlice) SetHref(href string) {
	op.href = &href
}

func (op *ActionSlice) Slice() []*Action {
	return op.slice
}

func (op *ActionSlice) SetSlice(slice []*Action) {
	op.slice = slice
}

type AffinityGroupBuilder struct {
	affinityGroup *AffinityGroup
	err           error
}

func NewAffinityGroupBuilder() *AffinityGroupBuilder {
	return &AffinityGroupBuilder{affinityGroup: &AffinityGroup{}, err: nil}
}

func (builder *AffinityGroupBuilder) Cluster(attr *Cluster) *AffinityGroupBuilder {
	if builder.err != nil {
		return builder
	}

	builder.affinityGroup.SetCluster(attr)
	return builder
}

func (builder *AffinityGroupBuilder) ClusterBuilder(attrBuilder *ClusterBuilder) *AffinityGroupBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Cluster(attr)
}

func (builder *AffinityGroupBuilder) Comment(attr string) *AffinityGroupBuilder {
	if builder.err != nil {
		return builder
	}

	builder.affinityGroup.SetComment(attr)
	return builder
}

func (builder *AffinityGroupBuilder) Description(attr string) *AffinityGroupBuilder {
	if builder.err != nil {
		return builder
	}

	builder.affinityGroup.SetDescription(attr)
	return builder
}

func (builder *AffinityGroupBuilder) Enforcing(attr bool) *AffinityGroupBuilder {
	if builder.err != nil {
		return builder
	}

	builder.affinityGroup.SetEnforcing(attr)
	return builder
}

func (builder *AffinityGroupBuilder) HostLabels(attr *AffinityLabelSlice) *AffinityGroupBuilder {
	if builder.err != nil {
		return builder
	}

	builder.affinityGroup.SetHostLabels(attr)
	return builder
}

func (builder *AffinityGroupBuilder) HostLabelsOfAny(anys ...*AffinityLabel) *AffinityGroupBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.affinityGroup.hostLabels == nil {
		builder.affinityGroup.hostLabels = new(AffinityLabelSlice)
	}
	builder.affinityGroup.hostLabels.slice = append(builder.affinityGroup.hostLabels.slice, anys...)
	return builder
}

func (builder *AffinityGroupBuilder) HostLabelsBuilderOfAny(anyBuilders ...AffinityLabelBuilder) *AffinityGroupBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.HostLabelsOfAny(attr)
	}
	return builder
}

func (builder *AffinityGroupBuilder) Hosts(attr *HostSlice) *AffinityGroupBuilder {
	if builder.err != nil {
		return builder
	}

	builder.affinityGroup.SetHosts(attr)
	return builder
}

func (builder *AffinityGroupBuilder) HostsOfAny(anys ...*Host) *AffinityGroupBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.affinityGroup.hosts == nil {
		builder.affinityGroup.hosts = new(HostSlice)
	}
	builder.affinityGroup.hosts.slice = append(builder.affinityGroup.hosts.slice, anys...)
	return builder
}

func (builder *AffinityGroupBuilder) HostsBuilderOfAny(anyBuilders ...HostBuilder) *AffinityGroupBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.HostsOfAny(attr)
	}
	return builder
}

func (builder *AffinityGroupBuilder) HostsRule(attr *AffinityRule) *AffinityGroupBuilder {
	if builder.err != nil {
		return builder
	}

	builder.affinityGroup.SetHostsRule(attr)
	return builder
}

func (builder *AffinityGroupBuilder) HostsRuleBuilder(attrBuilder *AffinityRuleBuilder) *AffinityGroupBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.HostsRule(attr)
}

func (builder *AffinityGroupBuilder) Id(attr string) *AffinityGroupBuilder {
	if builder.err != nil {
		return builder
	}

	builder.affinityGroup.SetId(attr)
	return builder
}

func (builder *AffinityGroupBuilder) Name(attr string) *AffinityGroupBuilder {
	if builder.err != nil {
		return builder
	}

	builder.affinityGroup.SetName(attr)
	return builder
}

func (builder *AffinityGroupBuilder) Positive(attr bool) *AffinityGroupBuilder {
	if builder.err != nil {
		return builder
	}

	builder.affinityGroup.SetPositive(attr)
	return builder
}

func (builder *AffinityGroupBuilder) Priority(attr float64) *AffinityGroupBuilder {
	if builder.err != nil {
		return builder
	}

	builder.affinityGroup.SetPriority(attr)
	return builder
}

func (builder *AffinityGroupBuilder) VmLabels(attr *AffinityLabelSlice) *AffinityGroupBuilder {
	if builder.err != nil {
		return builder
	}

	builder.affinityGroup.SetVmLabels(attr)
	return builder
}

func (builder *AffinityGroupBuilder) VmLabelsOfAny(anys ...*AffinityLabel) *AffinityGroupBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.affinityGroup.vmLabels == nil {
		builder.affinityGroup.vmLabels = new(AffinityLabelSlice)
	}
	builder.affinityGroup.vmLabels.slice = append(builder.affinityGroup.vmLabels.slice, anys...)
	return builder
}

func (builder *AffinityGroupBuilder) VmLabelsBuilderOfAny(anyBuilders ...AffinityLabelBuilder) *AffinityGroupBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.VmLabelsOfAny(attr)
	}
	return builder
}

func (builder *AffinityGroupBuilder) Vms(attr *VmSlice) *AffinityGroupBuilder {
	if builder.err != nil {
		return builder
	}

	builder.affinityGroup.SetVms(attr)
	return builder
}

func (builder *AffinityGroupBuilder) VmsOfAny(anys ...*Vm) *AffinityGroupBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.affinityGroup.vms == nil {
		builder.affinityGroup.vms = new(VmSlice)
	}
	builder.affinityGroup.vms.slice = append(builder.affinityGroup.vms.slice, anys...)
	return builder
}

func (builder *AffinityGroupBuilder) VmsBuilderOfAny(anyBuilders ...VmBuilder) *AffinityGroupBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.VmsOfAny(attr)
	}
	return builder
}

func (builder *AffinityGroupBuilder) VmsRule(attr *AffinityRule) *AffinityGroupBuilder {
	if builder.err != nil {
		return builder
	}

	builder.affinityGroup.SetVmsRule(attr)
	return builder
}

func (builder *AffinityGroupBuilder) VmsRuleBuilder(attrBuilder *AffinityRuleBuilder) *AffinityGroupBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.VmsRule(attr)
}

func (builder *AffinityGroupBuilder) Href(href string) *AffinityGroupBuilder {
	if builder.err != nil {
		return builder
	}

	builder.affinityGroup.SetHref(href)
	return builder
}

func (builder *AffinityGroupBuilder) Build() (*AffinityGroup, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.affinityGroup, nil
}

func (builder *AffinityGroupBuilder) MustBuild() *AffinityGroup {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build AffinityGroup instance, reason: %v", builder.err))
	}
	return builder.affinityGroup
}

type AffinityLabelBuilder struct {
	affinityLabel *AffinityLabel
	err           error
}

func NewAffinityLabelBuilder() *AffinityLabelBuilder {
	return &AffinityLabelBuilder{affinityLabel: &AffinityLabel{}, err: nil}
}

func (builder *AffinityLabelBuilder) Comment(attr string) *AffinityLabelBuilder {
	if builder.err != nil {
		return builder
	}

	builder.affinityLabel.SetComment(attr)
	return builder
}

func (builder *AffinityLabelBuilder) Description(attr string) *AffinityLabelBuilder {
	if builder.err != nil {
		return builder
	}

	builder.affinityLabel.SetDescription(attr)
	return builder
}

func (builder *AffinityLabelBuilder) HasImplicitAffinityGroup(attr bool) *AffinityLabelBuilder {
	if builder.err != nil {
		return builder
	}

	builder.affinityLabel.SetHasImplicitAffinityGroup(attr)
	return builder
}

func (builder *AffinityLabelBuilder) Hosts(attr *HostSlice) *AffinityLabelBuilder {
	if builder.err != nil {
		return builder
	}

	builder.affinityLabel.SetHosts(attr)
	return builder
}

func (builder *AffinityLabelBuilder) HostsOfAny(anys ...*Host) *AffinityLabelBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.affinityLabel.hosts == nil {
		builder.affinityLabel.hosts = new(HostSlice)
	}
	builder.affinityLabel.hosts.slice = append(builder.affinityLabel.hosts.slice, anys...)
	return builder
}

func (builder *AffinityLabelBuilder) HostsBuilderOfAny(anyBuilders ...HostBuilder) *AffinityLabelBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.HostsOfAny(attr)
	}
	return builder
}

func (builder *AffinityLabelBuilder) Id(attr string) *AffinityLabelBuilder {
	if builder.err != nil {
		return builder
	}

	builder.affinityLabel.SetId(attr)
	return builder
}

func (builder *AffinityLabelBuilder) Name(attr string) *AffinityLabelBuilder {
	if builder.err != nil {
		return builder
	}

	builder.affinityLabel.SetName(attr)
	return builder
}

func (builder *AffinityLabelBuilder) ReadOnly(attr bool) *AffinityLabelBuilder {
	if builder.err != nil {
		return builder
	}

	builder.affinityLabel.SetReadOnly(attr)
	return builder
}

func (builder *AffinityLabelBuilder) Vms(attr *VmSlice) *AffinityLabelBuilder {
	if builder.err != nil {
		return builder
	}

	builder.affinityLabel.SetVms(attr)
	return builder
}

func (builder *AffinityLabelBuilder) VmsOfAny(anys ...*Vm) *AffinityLabelBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.affinityLabel.vms == nil {
		builder.affinityLabel.vms = new(VmSlice)
	}
	builder.affinityLabel.vms.slice = append(builder.affinityLabel.vms.slice, anys...)
	return builder
}

func (builder *AffinityLabelBuilder) VmsBuilderOfAny(anyBuilders ...VmBuilder) *AffinityLabelBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.VmsOfAny(attr)
	}
	return builder
}

func (builder *AffinityLabelBuilder) Href(href string) *AffinityLabelBuilder {
	if builder.err != nil {
		return builder
	}

	builder.affinityLabel.SetHref(href)
	return builder
}

func (builder *AffinityLabelBuilder) Build() (*AffinityLabel, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.affinityLabel, nil
}

func (builder *AffinityLabelBuilder) MustBuild() *AffinityLabel {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build AffinityLabel instance, reason: %v", builder.err))
	}
	return builder.affinityLabel
}

type AffinityRuleBuilder struct {
	affinityRule *AffinityRule
	err          error
}

func NewAffinityRuleBuilder() *AffinityRuleBuilder {
	return &AffinityRuleBuilder{affinityRule: &AffinityRule{}, err: nil}
}

func (builder *AffinityRuleBuilder) Enabled(attr bool) *AffinityRuleBuilder {
	if builder.err != nil {
		return builder
	}

	builder.affinityRule.SetEnabled(attr)
	return builder
}

func (builder *AffinityRuleBuilder) Enforcing(attr bool) *AffinityRuleBuilder {
	if builder.err != nil {
		return builder
	}

	builder.affinityRule.SetEnforcing(attr)
	return builder
}

func (builder *AffinityRuleBuilder) Positive(attr bool) *AffinityRuleBuilder {
	if builder.err != nil {
		return builder
	}

	builder.affinityRule.SetPositive(attr)
	return builder
}

func (builder *AffinityRuleBuilder) Href(href string) *AffinityRuleBuilder {
	if builder.err != nil {
		return builder
	}

	builder.affinityRule.SetHref(href)
	return builder
}

func (builder *AffinityRuleBuilder) Build() (*AffinityRule, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.affinityRule, nil
}

func (builder *AffinityRuleBuilder) MustBuild() *AffinityRule {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build AffinityRule instance, reason: %v", builder.err))
	}
	return builder.affinityRule
}

type AgentBuilder struct {
	agent *Agent
	err   error
}

func NewAgentBuilder() *AgentBuilder {
	return &AgentBuilder{agent: &Agent{}, err: nil}
}

func (builder *AgentBuilder) Address(attr string) *AgentBuilder {
	if builder.err != nil {
		return builder
	}

	builder.agent.SetAddress(attr)
	return builder
}

func (builder *AgentBuilder) Comment(attr string) *AgentBuilder {
	if builder.err != nil {
		return builder
	}

	builder.agent.SetComment(attr)
	return builder
}

func (builder *AgentBuilder) Concurrent(attr bool) *AgentBuilder {
	if builder.err != nil {
		return builder
	}

	builder.agent.SetConcurrent(attr)
	return builder
}

func (builder *AgentBuilder) Description(attr string) *AgentBuilder {
	if builder.err != nil {
		return builder
	}

	builder.agent.SetDescription(attr)
	return builder
}

func (builder *AgentBuilder) EncryptOptions(attr bool) *AgentBuilder {
	if builder.err != nil {
		return builder
	}

	builder.agent.SetEncryptOptions(attr)
	return builder
}

func (builder *AgentBuilder) Host(attr *Host) *AgentBuilder {
	if builder.err != nil {
		return builder
	}

	builder.agent.SetHost(attr)
	return builder
}

func (builder *AgentBuilder) HostBuilder(attrBuilder *HostBuilder) *AgentBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Host(attr)
}

func (builder *AgentBuilder) Id(attr string) *AgentBuilder {
	if builder.err != nil {
		return builder
	}

	builder.agent.SetId(attr)
	return builder
}

func (builder *AgentBuilder) Name(attr string) *AgentBuilder {
	if builder.err != nil {
		return builder
	}

	builder.agent.SetName(attr)
	return builder
}

func (builder *AgentBuilder) Options(attr *OptionSlice) *AgentBuilder {
	if builder.err != nil {
		return builder
	}

	builder.agent.SetOptions(attr)
	return builder
}

func (builder *AgentBuilder) OptionsOfAny(anys ...*Option) *AgentBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.agent.options == nil {
		builder.agent.options = new(OptionSlice)
	}
	builder.agent.options.slice = append(builder.agent.options.slice, anys...)
	return builder
}

func (builder *AgentBuilder) OptionsBuilderOfAny(anyBuilders ...OptionBuilder) *AgentBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.OptionsOfAny(attr)
	}
	return builder
}

func (builder *AgentBuilder) Order(attr int64) *AgentBuilder {
	if builder.err != nil {
		return builder
	}

	builder.agent.SetOrder(attr)
	return builder
}

func (builder *AgentBuilder) Password(attr string) *AgentBuilder {
	if builder.err != nil {
		return builder
	}

	builder.agent.SetPassword(attr)
	return builder
}

func (builder *AgentBuilder) Port(attr int64) *AgentBuilder {
	if builder.err != nil {
		return builder
	}

	builder.agent.SetPort(attr)
	return builder
}

func (builder *AgentBuilder) Type(attr string) *AgentBuilder {
	if builder.err != nil {
		return builder
	}

	builder.agent.SetType(attr)
	return builder
}

func (builder *AgentBuilder) Username(attr string) *AgentBuilder {
	if builder.err != nil {
		return builder
	}

	builder.agent.SetUsername(attr)
	return builder
}

func (builder *AgentBuilder) Href(href string) *AgentBuilder {
	if builder.err != nil {
		return builder
	}

	builder.agent.SetHref(href)
	return builder
}

func (builder *AgentBuilder) Build() (*Agent, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.agent, nil
}

func (builder *AgentBuilder) MustBuild() *Agent {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build Agent instance, reason: %v", builder.err))
	}
	return builder.agent
}

type AgentConfigurationBuilder struct {
	agentConfiguration *AgentConfiguration
	err                error
}

func NewAgentConfigurationBuilder() *AgentConfigurationBuilder {
	return &AgentConfigurationBuilder{agentConfiguration: &AgentConfiguration{}, err: nil}
}

func (builder *AgentConfigurationBuilder) Address(attr string) *AgentConfigurationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.agentConfiguration.SetAddress(attr)
	return builder
}

func (builder *AgentConfigurationBuilder) BrokerType(attr MessageBrokerType) *AgentConfigurationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.agentConfiguration.SetBrokerType(attr)
	return builder
}

func (builder *AgentConfigurationBuilder) NetworkMappings(attr string) *AgentConfigurationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.agentConfiguration.SetNetworkMappings(attr)
	return builder
}

func (builder *AgentConfigurationBuilder) Password(attr string) *AgentConfigurationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.agentConfiguration.SetPassword(attr)
	return builder
}

func (builder *AgentConfigurationBuilder) Port(attr int64) *AgentConfigurationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.agentConfiguration.SetPort(attr)
	return builder
}

func (builder *AgentConfigurationBuilder) Username(attr string) *AgentConfigurationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.agentConfiguration.SetUsername(attr)
	return builder
}

func (builder *AgentConfigurationBuilder) Href(href string) *AgentConfigurationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.agentConfiguration.SetHref(href)
	return builder
}

func (builder *AgentConfigurationBuilder) Build() (*AgentConfiguration, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.agentConfiguration, nil
}

func (builder *AgentConfigurationBuilder) MustBuild() *AgentConfiguration {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build AgentConfiguration instance, reason: %v", builder.err))
	}
	return builder.agentConfiguration
}

type ApiBuilder struct {
	api *Api
	err error
}

func NewApiBuilder() *ApiBuilder {
	return &ApiBuilder{api: &Api{}, err: nil}
}

func (builder *ApiBuilder) AuthenticatedUser(attr *User) *ApiBuilder {
	if builder.err != nil {
		return builder
	}

	builder.api.SetAuthenticatedUser(attr)
	return builder
}

func (builder *ApiBuilder) AuthenticatedUserBuilder(attrBuilder *UserBuilder) *ApiBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.AuthenticatedUser(attr)
}

func (builder *ApiBuilder) EffectiveUser(attr *User) *ApiBuilder {
	if builder.err != nil {
		return builder
	}

	builder.api.SetEffectiveUser(attr)
	return builder
}

func (builder *ApiBuilder) EffectiveUserBuilder(attrBuilder *UserBuilder) *ApiBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.EffectiveUser(attr)
}

func (builder *ApiBuilder) ProductInfo(attr *ProductInfo) *ApiBuilder {
	if builder.err != nil {
		return builder
	}

	builder.api.SetProductInfo(attr)
	return builder
}

func (builder *ApiBuilder) ProductInfoBuilder(attrBuilder *ProductInfoBuilder) *ApiBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.ProductInfo(attr)
}

func (builder *ApiBuilder) SpecialObjects(attr *SpecialObjects) *ApiBuilder {
	if builder.err != nil {
		return builder
	}

	builder.api.SetSpecialObjects(attr)
	return builder
}

func (builder *ApiBuilder) SpecialObjectsBuilder(attrBuilder *SpecialObjectsBuilder) *ApiBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.SpecialObjects(attr)
}

func (builder *ApiBuilder) Summary(attr *ApiSummary) *ApiBuilder {
	if builder.err != nil {
		return builder
	}

	builder.api.SetSummary(attr)
	return builder
}

func (builder *ApiBuilder) SummaryBuilder(attrBuilder *ApiSummaryBuilder) *ApiBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Summary(attr)
}

func (builder *ApiBuilder) Time(attr time.Time) *ApiBuilder {
	if builder.err != nil {
		return builder
	}

	builder.api.SetTime(attr)
	return builder
}

func (builder *ApiBuilder) Href(href string) *ApiBuilder {
	if builder.err != nil {
		return builder
	}

	builder.api.SetHref(href)
	return builder
}

func (builder *ApiBuilder) Build() (*Api, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.api, nil
}

func (builder *ApiBuilder) MustBuild() *Api {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build Api instance, reason: %v", builder.err))
	}
	return builder.api
}

type ApiSummaryBuilder struct {
	apiSummary *ApiSummary
	err        error
}

func NewApiSummaryBuilder() *ApiSummaryBuilder {
	return &ApiSummaryBuilder{apiSummary: &ApiSummary{}, err: nil}
}

func (builder *ApiSummaryBuilder) Hosts(attr *ApiSummaryItem) *ApiSummaryBuilder {
	if builder.err != nil {
		return builder
	}

	builder.apiSummary.SetHosts(attr)
	return builder
}

func (builder *ApiSummaryBuilder) HostsBuilder(attrBuilder *ApiSummaryItemBuilder) *ApiSummaryBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Hosts(attr)
}

func (builder *ApiSummaryBuilder) StorageDomains(attr *ApiSummaryItem) *ApiSummaryBuilder {
	if builder.err != nil {
		return builder
	}

	builder.apiSummary.SetStorageDomains(attr)
	return builder
}

func (builder *ApiSummaryBuilder) StorageDomainsBuilder(attrBuilder *ApiSummaryItemBuilder) *ApiSummaryBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.StorageDomains(attr)
}

func (builder *ApiSummaryBuilder) Users(attr *ApiSummaryItem) *ApiSummaryBuilder {
	if builder.err != nil {
		return builder
	}

	builder.apiSummary.SetUsers(attr)
	return builder
}

func (builder *ApiSummaryBuilder) UsersBuilder(attrBuilder *ApiSummaryItemBuilder) *ApiSummaryBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Users(attr)
}

func (builder *ApiSummaryBuilder) Vms(attr *ApiSummaryItem) *ApiSummaryBuilder {
	if builder.err != nil {
		return builder
	}

	builder.apiSummary.SetVms(attr)
	return builder
}

func (builder *ApiSummaryBuilder) VmsBuilder(attrBuilder *ApiSummaryItemBuilder) *ApiSummaryBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Vms(attr)
}

func (builder *ApiSummaryBuilder) Href(href string) *ApiSummaryBuilder {
	if builder.err != nil {
		return builder
	}

	builder.apiSummary.SetHref(href)
	return builder
}

func (builder *ApiSummaryBuilder) Build() (*ApiSummary, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.apiSummary, nil
}

func (builder *ApiSummaryBuilder) MustBuild() *ApiSummary {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build ApiSummary instance, reason: %v", builder.err))
	}
	return builder.apiSummary
}

type ApiSummaryItemBuilder struct {
	apiSummaryItem *ApiSummaryItem
	err            error
}

func NewApiSummaryItemBuilder() *ApiSummaryItemBuilder {
	return &ApiSummaryItemBuilder{apiSummaryItem: &ApiSummaryItem{}, err: nil}
}

func (builder *ApiSummaryItemBuilder) Active(attr int64) *ApiSummaryItemBuilder {
	if builder.err != nil {
		return builder
	}

	builder.apiSummaryItem.SetActive(attr)
	return builder
}

func (builder *ApiSummaryItemBuilder) Total(attr int64) *ApiSummaryItemBuilder {
	if builder.err != nil {
		return builder
	}

	builder.apiSummaryItem.SetTotal(attr)
	return builder
}

func (builder *ApiSummaryItemBuilder) Href(href string) *ApiSummaryItemBuilder {
	if builder.err != nil {
		return builder
	}

	builder.apiSummaryItem.SetHref(href)
	return builder
}

func (builder *ApiSummaryItemBuilder) Build() (*ApiSummaryItem, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.apiSummaryItem, nil
}

func (builder *ApiSummaryItemBuilder) MustBuild() *ApiSummaryItem {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build ApiSummaryItem instance, reason: %v", builder.err))
	}
	return builder.apiSummaryItem
}

type ApplicationBuilder struct {
	application *Application
	err         error
}

func NewApplicationBuilder() *ApplicationBuilder {
	return &ApplicationBuilder{application: &Application{}, err: nil}
}

func (builder *ApplicationBuilder) Comment(attr string) *ApplicationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.application.SetComment(attr)
	return builder
}

func (builder *ApplicationBuilder) Description(attr string) *ApplicationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.application.SetDescription(attr)
	return builder
}

func (builder *ApplicationBuilder) Id(attr string) *ApplicationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.application.SetId(attr)
	return builder
}

func (builder *ApplicationBuilder) Name(attr string) *ApplicationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.application.SetName(attr)
	return builder
}

func (builder *ApplicationBuilder) Vm(attr *Vm) *ApplicationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.application.SetVm(attr)
	return builder
}

func (builder *ApplicationBuilder) VmBuilder(attrBuilder *VmBuilder) *ApplicationBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Vm(attr)
}

func (builder *ApplicationBuilder) Href(href string) *ApplicationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.application.SetHref(href)
	return builder
}

func (builder *ApplicationBuilder) Build() (*Application, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.application, nil
}

func (builder *ApplicationBuilder) MustBuild() *Application {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build Application instance, reason: %v", builder.err))
	}
	return builder.application
}

type AuthorizedKeyBuilder struct {
	authorizedKey *AuthorizedKey
	err           error
}

func NewAuthorizedKeyBuilder() *AuthorizedKeyBuilder {
	return &AuthorizedKeyBuilder{authorizedKey: &AuthorizedKey{}, err: nil}
}

func (builder *AuthorizedKeyBuilder) Comment(attr string) *AuthorizedKeyBuilder {
	if builder.err != nil {
		return builder
	}

	builder.authorizedKey.SetComment(attr)
	return builder
}

func (builder *AuthorizedKeyBuilder) Description(attr string) *AuthorizedKeyBuilder {
	if builder.err != nil {
		return builder
	}

	builder.authorizedKey.SetDescription(attr)
	return builder
}

func (builder *AuthorizedKeyBuilder) Id(attr string) *AuthorizedKeyBuilder {
	if builder.err != nil {
		return builder
	}

	builder.authorizedKey.SetId(attr)
	return builder
}

func (builder *AuthorizedKeyBuilder) Key(attr string) *AuthorizedKeyBuilder {
	if builder.err != nil {
		return builder
	}

	builder.authorizedKey.SetKey(attr)
	return builder
}

func (builder *AuthorizedKeyBuilder) Name(attr string) *AuthorizedKeyBuilder {
	if builder.err != nil {
		return builder
	}

	builder.authorizedKey.SetName(attr)
	return builder
}

func (builder *AuthorizedKeyBuilder) User(attr *User) *AuthorizedKeyBuilder {
	if builder.err != nil {
		return builder
	}

	builder.authorizedKey.SetUser(attr)
	return builder
}

func (builder *AuthorizedKeyBuilder) UserBuilder(attrBuilder *UserBuilder) *AuthorizedKeyBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.User(attr)
}

func (builder *AuthorizedKeyBuilder) Href(href string) *AuthorizedKeyBuilder {
	if builder.err != nil {
		return builder
	}

	builder.authorizedKey.SetHref(href)
	return builder
}

func (builder *AuthorizedKeyBuilder) Build() (*AuthorizedKey, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.authorizedKey, nil
}

func (builder *AuthorizedKeyBuilder) MustBuild() *AuthorizedKey {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build AuthorizedKey instance, reason: %v", builder.err))
	}
	return builder.authorizedKey
}

type BackupBuilder struct {
	backup *Backup
	err    error
}

func NewBackupBuilder() *BackupBuilder {
	return &BackupBuilder{backup: &Backup{}, err: nil}
}

func (builder *BackupBuilder) Comment(attr string) *BackupBuilder {
	if builder.err != nil {
		return builder
	}

	builder.backup.SetComment(attr)
	return builder
}

func (builder *BackupBuilder) CreationDate(attr time.Time) *BackupBuilder {
	if builder.err != nil {
		return builder
	}

	builder.backup.SetCreationDate(attr)
	return builder
}

func (builder *BackupBuilder) Description(attr string) *BackupBuilder {
	if builder.err != nil {
		return builder
	}

	builder.backup.SetDescription(attr)
	return builder
}

func (builder *BackupBuilder) Disks(attr *DiskSlice) *BackupBuilder {
	if builder.err != nil {
		return builder
	}

	builder.backup.SetDisks(attr)
	return builder
}

func (builder *BackupBuilder) DisksOfAny(anys ...*Disk) *BackupBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.backup.disks == nil {
		builder.backup.disks = new(DiskSlice)
	}
	builder.backup.disks.slice = append(builder.backup.disks.slice, anys...)
	return builder
}

func (builder *BackupBuilder) DisksBuilderOfAny(anyBuilders ...DiskBuilder) *BackupBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.DisksOfAny(attr)
	}
	return builder
}

func (builder *BackupBuilder) FromCheckpointId(attr string) *BackupBuilder {
	if builder.err != nil {
		return builder
	}

	builder.backup.SetFromCheckpointId(attr)
	return builder
}

func (builder *BackupBuilder) Host(attr *Host) *BackupBuilder {
	if builder.err != nil {
		return builder
	}

	builder.backup.SetHost(attr)
	return builder
}

func (builder *BackupBuilder) HostBuilder(attrBuilder *HostBuilder) *BackupBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Host(attr)
}

func (builder *BackupBuilder) Id(attr string) *BackupBuilder {
	if builder.err != nil {
		return builder
	}

	builder.backup.SetId(attr)
	return builder
}

func (builder *BackupBuilder) Name(attr string) *BackupBuilder {
	if builder.err != nil {
		return builder
	}

	builder.backup.SetName(attr)
	return builder
}

func (builder *BackupBuilder) Phase(attr BackupPhase) *BackupBuilder {
	if builder.err != nil {
		return builder
	}

	builder.backup.SetPhase(attr)
	return builder
}

func (builder *BackupBuilder) ToCheckpointId(attr string) *BackupBuilder {
	if builder.err != nil {
		return builder
	}

	builder.backup.SetToCheckpointId(attr)
	return builder
}

func (builder *BackupBuilder) Vm(attr *Vm) *BackupBuilder {
	if builder.err != nil {
		return builder
	}

	builder.backup.SetVm(attr)
	return builder
}

func (builder *BackupBuilder) VmBuilder(attrBuilder *VmBuilder) *BackupBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Vm(attr)
}

func (builder *BackupBuilder) Href(href string) *BackupBuilder {
	if builder.err != nil {
		return builder
	}

	builder.backup.SetHref(href)
	return builder
}

func (builder *BackupBuilder) Build() (*Backup, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.backup, nil
}

func (builder *BackupBuilder) MustBuild() *Backup {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build Backup instance, reason: %v", builder.err))
	}
	return builder.backup
}

type BalanceBuilder struct {
	balance *Balance
	err     error
}

func NewBalanceBuilder() *BalanceBuilder {
	return &BalanceBuilder{balance: &Balance{}, err: nil}
}

func (builder *BalanceBuilder) Comment(attr string) *BalanceBuilder {
	if builder.err != nil {
		return builder
	}

	builder.balance.SetComment(attr)
	return builder
}

func (builder *BalanceBuilder) Description(attr string) *BalanceBuilder {
	if builder.err != nil {
		return builder
	}

	builder.balance.SetDescription(attr)
	return builder
}

func (builder *BalanceBuilder) Id(attr string) *BalanceBuilder {
	if builder.err != nil {
		return builder
	}

	builder.balance.SetId(attr)
	return builder
}

func (builder *BalanceBuilder) Name(attr string) *BalanceBuilder {
	if builder.err != nil {
		return builder
	}

	builder.balance.SetName(attr)
	return builder
}

func (builder *BalanceBuilder) SchedulingPolicy(attr *SchedulingPolicy) *BalanceBuilder {
	if builder.err != nil {
		return builder
	}

	builder.balance.SetSchedulingPolicy(attr)
	return builder
}

func (builder *BalanceBuilder) SchedulingPolicyBuilder(attrBuilder *SchedulingPolicyBuilder) *BalanceBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.SchedulingPolicy(attr)
}

func (builder *BalanceBuilder) SchedulingPolicyUnit(attr *SchedulingPolicyUnit) *BalanceBuilder {
	if builder.err != nil {
		return builder
	}

	builder.balance.SetSchedulingPolicyUnit(attr)
	return builder
}

func (builder *BalanceBuilder) SchedulingPolicyUnitBuilder(attrBuilder *SchedulingPolicyUnitBuilder) *BalanceBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.SchedulingPolicyUnit(attr)
}

func (builder *BalanceBuilder) Href(href string) *BalanceBuilder {
	if builder.err != nil {
		return builder
	}

	builder.balance.SetHref(href)
	return builder
}

func (builder *BalanceBuilder) Build() (*Balance, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.balance, nil
}

func (builder *BalanceBuilder) MustBuild() *Balance {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build Balance instance, reason: %v", builder.err))
	}
	return builder.balance
}

type BiosBuilder struct {
	bios *Bios
	err  error
}

func NewBiosBuilder() *BiosBuilder {
	return &BiosBuilder{bios: &Bios{}, err: nil}
}

func (builder *BiosBuilder) BootMenu(attr *BootMenu) *BiosBuilder {
	if builder.err != nil {
		return builder
	}

	builder.bios.SetBootMenu(attr)
	return builder
}

func (builder *BiosBuilder) BootMenuBuilder(attrBuilder *BootMenuBuilder) *BiosBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.BootMenu(attr)
}

func (builder *BiosBuilder) Type(attr BiosType) *BiosBuilder {
	if builder.err != nil {
		return builder
	}

	builder.bios.SetType(attr)
	return builder
}

func (builder *BiosBuilder) Href(href string) *BiosBuilder {
	if builder.err != nil {
		return builder
	}

	builder.bios.SetHref(href)
	return builder
}

func (builder *BiosBuilder) Build() (*Bios, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.bios, nil
}

func (builder *BiosBuilder) MustBuild() *Bios {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build Bios instance, reason: %v", builder.err))
	}
	return builder.bios
}

type BlockStatisticBuilder struct {
	blockStatistic *BlockStatistic
	err            error
}

func NewBlockStatisticBuilder() *BlockStatisticBuilder {
	return &BlockStatisticBuilder{blockStatistic: &BlockStatistic{}, err: nil}
}

func (builder *BlockStatisticBuilder) Statistics(attr *StatisticSlice) *BlockStatisticBuilder {
	if builder.err != nil {
		return builder
	}

	builder.blockStatistic.SetStatistics(attr)
	return builder
}

func (builder *BlockStatisticBuilder) StatisticsOfAny(anys ...*Statistic) *BlockStatisticBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.blockStatistic.statistics == nil {
		builder.blockStatistic.statistics = new(StatisticSlice)
	}
	builder.blockStatistic.statistics.slice = append(builder.blockStatistic.statistics.slice, anys...)
	return builder
}

func (builder *BlockStatisticBuilder) StatisticsBuilderOfAny(anyBuilders ...StatisticBuilder) *BlockStatisticBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.StatisticsOfAny(attr)
	}
	return builder
}

func (builder *BlockStatisticBuilder) Href(href string) *BlockStatisticBuilder {
	if builder.err != nil {
		return builder
	}

	builder.blockStatistic.SetHref(href)
	return builder
}

func (builder *BlockStatisticBuilder) Build() (*BlockStatistic, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.blockStatistic, nil
}

func (builder *BlockStatisticBuilder) MustBuild() *BlockStatistic {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build BlockStatistic instance, reason: %v", builder.err))
	}
	return builder.blockStatistic
}

type BondingBuilder struct {
	bonding *Bonding
	err     error
}

func NewBondingBuilder() *BondingBuilder {
	return &BondingBuilder{bonding: &Bonding{}, err: nil}
}

func (builder *BondingBuilder) ActiveSlave(attr *HostNic) *BondingBuilder {
	if builder.err != nil {
		return builder
	}

	builder.bonding.SetActiveSlave(attr)
	return builder
}

func (builder *BondingBuilder) ActiveSlaveBuilder(attrBuilder *HostNicBuilder) *BondingBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.ActiveSlave(attr)
}

func (builder *BondingBuilder) AdPartnerMac(attr *Mac) *BondingBuilder {
	if builder.err != nil {
		return builder
	}

	builder.bonding.SetAdPartnerMac(attr)
	return builder
}

func (builder *BondingBuilder) AdPartnerMacBuilder(attrBuilder *MacBuilder) *BondingBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.AdPartnerMac(attr)
}

func (builder *BondingBuilder) Options(attr *OptionSlice) *BondingBuilder {
	if builder.err != nil {
		return builder
	}

	builder.bonding.SetOptions(attr)
	return builder
}

func (builder *BondingBuilder) OptionsOfAny(anys ...*Option) *BondingBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.bonding.options == nil {
		builder.bonding.options = new(OptionSlice)
	}
	builder.bonding.options.slice = append(builder.bonding.options.slice, anys...)
	return builder
}

func (builder *BondingBuilder) OptionsBuilderOfAny(anyBuilders ...OptionBuilder) *BondingBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.OptionsOfAny(attr)
	}
	return builder
}

func (builder *BondingBuilder) Slaves(attr *HostNicSlice) *BondingBuilder {
	if builder.err != nil {
		return builder
	}

	builder.bonding.SetSlaves(attr)
	return builder
}

func (builder *BondingBuilder) SlavesOfAny(anys ...*HostNic) *BondingBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.bonding.slaves == nil {
		builder.bonding.slaves = new(HostNicSlice)
	}
	builder.bonding.slaves.slice = append(builder.bonding.slaves.slice, anys...)
	return builder
}

func (builder *BondingBuilder) SlavesBuilderOfAny(anyBuilders ...HostNicBuilder) *BondingBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.SlavesOfAny(attr)
	}
	return builder
}

func (builder *BondingBuilder) Href(href string) *BondingBuilder {
	if builder.err != nil {
		return builder
	}

	builder.bonding.SetHref(href)
	return builder
}

func (builder *BondingBuilder) Build() (*Bonding, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.bonding, nil
}

func (builder *BondingBuilder) MustBuild() *Bonding {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build Bonding instance, reason: %v", builder.err))
	}
	return builder.bonding
}

type BookmarkBuilder struct {
	bookmark *Bookmark
	err      error
}

func NewBookmarkBuilder() *BookmarkBuilder {
	return &BookmarkBuilder{bookmark: &Bookmark{}, err: nil}
}

func (builder *BookmarkBuilder) Comment(attr string) *BookmarkBuilder {
	if builder.err != nil {
		return builder
	}

	builder.bookmark.SetComment(attr)
	return builder
}

func (builder *BookmarkBuilder) Description(attr string) *BookmarkBuilder {
	if builder.err != nil {
		return builder
	}

	builder.bookmark.SetDescription(attr)
	return builder
}

func (builder *BookmarkBuilder) Id(attr string) *BookmarkBuilder {
	if builder.err != nil {
		return builder
	}

	builder.bookmark.SetId(attr)
	return builder
}

func (builder *BookmarkBuilder) Name(attr string) *BookmarkBuilder {
	if builder.err != nil {
		return builder
	}

	builder.bookmark.SetName(attr)
	return builder
}

func (builder *BookmarkBuilder) Value(attr string) *BookmarkBuilder {
	if builder.err != nil {
		return builder
	}

	builder.bookmark.SetValue(attr)
	return builder
}

func (builder *BookmarkBuilder) Href(href string) *BookmarkBuilder {
	if builder.err != nil {
		return builder
	}

	builder.bookmark.SetHref(href)
	return builder
}

func (builder *BookmarkBuilder) Build() (*Bookmark, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.bookmark, nil
}

func (builder *BookmarkBuilder) MustBuild() *Bookmark {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build Bookmark instance, reason: %v", builder.err))
	}
	return builder.bookmark
}

type BootBuilder struct {
	boot *Boot
	err  error
}

func NewBootBuilder() *BootBuilder {
	return &BootBuilder{boot: &Boot{}, err: nil}
}

func (builder *BootBuilder) Devices(attr []BootDevice) *BootBuilder {
	if builder.err != nil {
		return builder
	}

	builder.boot.SetDevices(attr)
	return builder
}

func (builder *BootBuilder) DevicesOfAny(anys ...BootDevice) *BootBuilder {
	if builder.err != nil {
		return builder
	}

	builder.boot.devices = append(builder.boot.devices, anys...)
	return builder
}

func (builder *BootBuilder) Href(href string) *BootBuilder {
	if builder.err != nil {
		return builder
	}

	builder.boot.SetHref(href)
	return builder
}

func (builder *BootBuilder) Build() (*Boot, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.boot, nil
}

func (builder *BootBuilder) MustBuild() *Boot {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build Boot instance, reason: %v", builder.err))
	}
	return builder.boot
}

type BootMenuBuilder struct {
	bootMenu *BootMenu
	err      error
}

func NewBootMenuBuilder() *BootMenuBuilder {
	return &BootMenuBuilder{bootMenu: &BootMenu{}, err: nil}
}

func (builder *BootMenuBuilder) Enabled(attr bool) *BootMenuBuilder {
	if builder.err != nil {
		return builder
	}

	builder.bootMenu.SetEnabled(attr)
	return builder
}

func (builder *BootMenuBuilder) Href(href string) *BootMenuBuilder {
	if builder.err != nil {
		return builder
	}

	builder.bootMenu.SetHref(href)
	return builder
}

func (builder *BootMenuBuilder) Build() (*BootMenu, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.bootMenu, nil
}

func (builder *BootMenuBuilder) MustBuild() *BootMenu {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build BootMenu instance, reason: %v", builder.err))
	}
	return builder.bootMenu
}

type BrickProfileDetailBuilder struct {
	brickProfileDetail *BrickProfileDetail
	err                error
}

func NewBrickProfileDetailBuilder() *BrickProfileDetailBuilder {
	return &BrickProfileDetailBuilder{brickProfileDetail: &BrickProfileDetail{}, err: nil}
}

func (builder *BrickProfileDetailBuilder) Brick(attr *GlusterBrick) *BrickProfileDetailBuilder {
	if builder.err != nil {
		return builder
	}

	builder.brickProfileDetail.SetBrick(attr)
	return builder
}

func (builder *BrickProfileDetailBuilder) BrickBuilder(attrBuilder *GlusterBrickBuilder) *BrickProfileDetailBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Brick(attr)
}

func (builder *BrickProfileDetailBuilder) ProfileDetails(attr *ProfileDetailSlice) *BrickProfileDetailBuilder {
	if builder.err != nil {
		return builder
	}

	builder.brickProfileDetail.SetProfileDetails(attr)
	return builder
}

func (builder *BrickProfileDetailBuilder) ProfileDetailsOfAny(anys ...*ProfileDetail) *BrickProfileDetailBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.brickProfileDetail.profileDetails == nil {
		builder.brickProfileDetail.profileDetails = new(ProfileDetailSlice)
	}
	builder.brickProfileDetail.profileDetails.slice = append(builder.brickProfileDetail.profileDetails.slice, anys...)
	return builder
}

func (builder *BrickProfileDetailBuilder) ProfileDetailsBuilderOfAny(anyBuilders ...ProfileDetailBuilder) *BrickProfileDetailBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.ProfileDetailsOfAny(attr)
	}
	return builder
}

func (builder *BrickProfileDetailBuilder) Href(href string) *BrickProfileDetailBuilder {
	if builder.err != nil {
		return builder
	}

	builder.brickProfileDetail.SetHref(href)
	return builder
}

func (builder *BrickProfileDetailBuilder) Build() (*BrickProfileDetail, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.brickProfileDetail, nil
}

func (builder *BrickProfileDetailBuilder) MustBuild() *BrickProfileDetail {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build BrickProfileDetail instance, reason: %v", builder.err))
	}
	return builder.brickProfileDetail
}

type CdromBuilder struct {
	cdrom *Cdrom
	err   error
}

func NewCdromBuilder() *CdromBuilder {
	return &CdromBuilder{cdrom: &Cdrom{}, err: nil}
}

func (builder *CdromBuilder) Comment(attr string) *CdromBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cdrom.SetComment(attr)
	return builder
}

func (builder *CdromBuilder) Description(attr string) *CdromBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cdrom.SetDescription(attr)
	return builder
}

func (builder *CdromBuilder) File(attr *File) *CdromBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cdrom.SetFile(attr)
	return builder
}

func (builder *CdromBuilder) FileBuilder(attrBuilder *FileBuilder) *CdromBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.File(attr)
}

func (builder *CdromBuilder) Id(attr string) *CdromBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cdrom.SetId(attr)
	return builder
}

func (builder *CdromBuilder) InstanceType(attr *InstanceType) *CdromBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cdrom.SetInstanceType(attr)
	return builder
}

func (builder *CdromBuilder) InstanceTypeBuilder(attrBuilder *InstanceTypeBuilder) *CdromBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.InstanceType(attr)
}

func (builder *CdromBuilder) Name(attr string) *CdromBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cdrom.SetName(attr)
	return builder
}

func (builder *CdromBuilder) Template(attr *Template) *CdromBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cdrom.SetTemplate(attr)
	return builder
}

func (builder *CdromBuilder) TemplateBuilder(attrBuilder *TemplateBuilder) *CdromBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Template(attr)
}

func (builder *CdromBuilder) Vm(attr *Vm) *CdromBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cdrom.SetVm(attr)
	return builder
}

func (builder *CdromBuilder) VmBuilder(attrBuilder *VmBuilder) *CdromBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Vm(attr)
}

func (builder *CdromBuilder) Vms(attr *VmSlice) *CdromBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cdrom.SetVms(attr)
	return builder
}

func (builder *CdromBuilder) VmsOfAny(anys ...*Vm) *CdromBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.cdrom.vms == nil {
		builder.cdrom.vms = new(VmSlice)
	}
	builder.cdrom.vms.slice = append(builder.cdrom.vms.slice, anys...)
	return builder
}

func (builder *CdromBuilder) VmsBuilderOfAny(anyBuilders ...VmBuilder) *CdromBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.VmsOfAny(attr)
	}
	return builder
}

func (builder *CdromBuilder) Href(href string) *CdromBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cdrom.SetHref(href)
	return builder
}

func (builder *CdromBuilder) Build() (*Cdrom, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.cdrom, nil
}

func (builder *CdromBuilder) MustBuild() *Cdrom {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build Cdrom instance, reason: %v", builder.err))
	}
	return builder.cdrom
}

type CertificateBuilder struct {
	certificate *Certificate
	err         error
}

func NewCertificateBuilder() *CertificateBuilder {
	return &CertificateBuilder{certificate: &Certificate{}, err: nil}
}

func (builder *CertificateBuilder) Comment(attr string) *CertificateBuilder {
	if builder.err != nil {
		return builder
	}

	builder.certificate.SetComment(attr)
	return builder
}

func (builder *CertificateBuilder) Content(attr string) *CertificateBuilder {
	if builder.err != nil {
		return builder
	}

	builder.certificate.SetContent(attr)
	return builder
}

func (builder *CertificateBuilder) Description(attr string) *CertificateBuilder {
	if builder.err != nil {
		return builder
	}

	builder.certificate.SetDescription(attr)
	return builder
}

func (builder *CertificateBuilder) Id(attr string) *CertificateBuilder {
	if builder.err != nil {
		return builder
	}

	builder.certificate.SetId(attr)
	return builder
}

func (builder *CertificateBuilder) Name(attr string) *CertificateBuilder {
	if builder.err != nil {
		return builder
	}

	builder.certificate.SetName(attr)
	return builder
}

func (builder *CertificateBuilder) Organization(attr string) *CertificateBuilder {
	if builder.err != nil {
		return builder
	}

	builder.certificate.SetOrganization(attr)
	return builder
}

func (builder *CertificateBuilder) Subject(attr string) *CertificateBuilder {
	if builder.err != nil {
		return builder
	}

	builder.certificate.SetSubject(attr)
	return builder
}

func (builder *CertificateBuilder) Href(href string) *CertificateBuilder {
	if builder.err != nil {
		return builder
	}

	builder.certificate.SetHref(href)
	return builder
}

func (builder *CertificateBuilder) Build() (*Certificate, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.certificate, nil
}

func (builder *CertificateBuilder) MustBuild() *Certificate {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build Certificate instance, reason: %v", builder.err))
	}
	return builder.certificate
}

type CheckpointBuilder struct {
	checkpoint *Checkpoint
	err        error
}

func NewCheckpointBuilder() *CheckpointBuilder {
	return &CheckpointBuilder{checkpoint: &Checkpoint{}, err: nil}
}

func (builder *CheckpointBuilder) Comment(attr string) *CheckpointBuilder {
	if builder.err != nil {
		return builder
	}

	builder.checkpoint.SetComment(attr)
	return builder
}

func (builder *CheckpointBuilder) CreationDate(attr time.Time) *CheckpointBuilder {
	if builder.err != nil {
		return builder
	}

	builder.checkpoint.SetCreationDate(attr)
	return builder
}

func (builder *CheckpointBuilder) Description(attr string) *CheckpointBuilder {
	if builder.err != nil {
		return builder
	}

	builder.checkpoint.SetDescription(attr)
	return builder
}

func (builder *CheckpointBuilder) Disks(attr *DiskSlice) *CheckpointBuilder {
	if builder.err != nil {
		return builder
	}

	builder.checkpoint.SetDisks(attr)
	return builder
}

func (builder *CheckpointBuilder) DisksOfAny(anys ...*Disk) *CheckpointBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.checkpoint.disks == nil {
		builder.checkpoint.disks = new(DiskSlice)
	}
	builder.checkpoint.disks.slice = append(builder.checkpoint.disks.slice, anys...)
	return builder
}

func (builder *CheckpointBuilder) DisksBuilderOfAny(anyBuilders ...DiskBuilder) *CheckpointBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.DisksOfAny(attr)
	}
	return builder
}

func (builder *CheckpointBuilder) Id(attr string) *CheckpointBuilder {
	if builder.err != nil {
		return builder
	}

	builder.checkpoint.SetId(attr)
	return builder
}

func (builder *CheckpointBuilder) Name(attr string) *CheckpointBuilder {
	if builder.err != nil {
		return builder
	}

	builder.checkpoint.SetName(attr)
	return builder
}

func (builder *CheckpointBuilder) ParentId(attr string) *CheckpointBuilder {
	if builder.err != nil {
		return builder
	}

	builder.checkpoint.SetParentId(attr)
	return builder
}

func (builder *CheckpointBuilder) State(attr CheckpointState) *CheckpointBuilder {
	if builder.err != nil {
		return builder
	}

	builder.checkpoint.SetState(attr)
	return builder
}

func (builder *CheckpointBuilder) Vm(attr *Vm) *CheckpointBuilder {
	if builder.err != nil {
		return builder
	}

	builder.checkpoint.SetVm(attr)
	return builder
}

func (builder *CheckpointBuilder) VmBuilder(attrBuilder *VmBuilder) *CheckpointBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Vm(attr)
}

func (builder *CheckpointBuilder) Href(href string) *CheckpointBuilder {
	if builder.err != nil {
		return builder
	}

	builder.checkpoint.SetHref(href)
	return builder
}

func (builder *CheckpointBuilder) Build() (*Checkpoint, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.checkpoint, nil
}

func (builder *CheckpointBuilder) MustBuild() *Checkpoint {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build Checkpoint instance, reason: %v", builder.err))
	}
	return builder.checkpoint
}

type CloudInitBuilder struct {
	cloudInit *CloudInit
	err       error
}

func NewCloudInitBuilder() *CloudInitBuilder {
	return &CloudInitBuilder{cloudInit: &CloudInit{}, err: nil}
}

func (builder *CloudInitBuilder) AuthorizedKeys(attr *AuthorizedKeySlice) *CloudInitBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cloudInit.SetAuthorizedKeys(attr)
	return builder
}

func (builder *CloudInitBuilder) AuthorizedKeysOfAny(anys ...*AuthorizedKey) *CloudInitBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.cloudInit.authorizedKeys == nil {
		builder.cloudInit.authorizedKeys = new(AuthorizedKeySlice)
	}
	builder.cloudInit.authorizedKeys.slice = append(builder.cloudInit.authorizedKeys.slice, anys...)
	return builder
}

func (builder *CloudInitBuilder) AuthorizedKeysBuilderOfAny(anyBuilders ...AuthorizedKeyBuilder) *CloudInitBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.AuthorizedKeysOfAny(attr)
	}
	return builder
}

func (builder *CloudInitBuilder) Files(attr *FileSlice) *CloudInitBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cloudInit.SetFiles(attr)
	return builder
}

func (builder *CloudInitBuilder) FilesOfAny(anys ...*File) *CloudInitBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.cloudInit.files == nil {
		builder.cloudInit.files = new(FileSlice)
	}
	builder.cloudInit.files.slice = append(builder.cloudInit.files.slice, anys...)
	return builder
}

func (builder *CloudInitBuilder) FilesBuilderOfAny(anyBuilders ...FileBuilder) *CloudInitBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.FilesOfAny(attr)
	}
	return builder
}

func (builder *CloudInitBuilder) Host(attr *Host) *CloudInitBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cloudInit.SetHost(attr)
	return builder
}

func (builder *CloudInitBuilder) HostBuilder(attrBuilder *HostBuilder) *CloudInitBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Host(attr)
}

func (builder *CloudInitBuilder) NetworkConfiguration(attr *NetworkConfiguration) *CloudInitBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cloudInit.SetNetworkConfiguration(attr)
	return builder
}

func (builder *CloudInitBuilder) NetworkConfigurationBuilder(attrBuilder *NetworkConfigurationBuilder) *CloudInitBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.NetworkConfiguration(attr)
}

func (builder *CloudInitBuilder) RegenerateSshKeys(attr bool) *CloudInitBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cloudInit.SetRegenerateSshKeys(attr)
	return builder
}

func (builder *CloudInitBuilder) Timezone(attr string) *CloudInitBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cloudInit.SetTimezone(attr)
	return builder
}

func (builder *CloudInitBuilder) Users(attr *UserSlice) *CloudInitBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cloudInit.SetUsers(attr)
	return builder
}

func (builder *CloudInitBuilder) UsersOfAny(anys ...*User) *CloudInitBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.cloudInit.users == nil {
		builder.cloudInit.users = new(UserSlice)
	}
	builder.cloudInit.users.slice = append(builder.cloudInit.users.slice, anys...)
	return builder
}

func (builder *CloudInitBuilder) UsersBuilderOfAny(anyBuilders ...UserBuilder) *CloudInitBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.UsersOfAny(attr)
	}
	return builder
}

func (builder *CloudInitBuilder) Href(href string) *CloudInitBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cloudInit.SetHref(href)
	return builder
}

func (builder *CloudInitBuilder) Build() (*CloudInit, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.cloudInit, nil
}

func (builder *CloudInitBuilder) MustBuild() *CloudInit {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build CloudInit instance, reason: %v", builder.err))
	}
	return builder.cloudInit
}

type ClusterBuilder struct {
	cluster *Cluster
	err     error
}

func NewClusterBuilder() *ClusterBuilder {
	return &ClusterBuilder{cluster: &Cluster{}, err: nil}
}

func (builder *ClusterBuilder) AffinityGroups(attr *AffinityGroupSlice) *ClusterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cluster.SetAffinityGroups(attr)
	return builder
}

func (builder *ClusterBuilder) AffinityGroupsOfAny(anys ...*AffinityGroup) *ClusterBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.cluster.affinityGroups == nil {
		builder.cluster.affinityGroups = new(AffinityGroupSlice)
	}
	builder.cluster.affinityGroups.slice = append(builder.cluster.affinityGroups.slice, anys...)
	return builder
}

func (builder *ClusterBuilder) AffinityGroupsBuilderOfAny(anyBuilders ...AffinityGroupBuilder) *ClusterBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.AffinityGroupsOfAny(attr)
	}
	return builder
}

func (builder *ClusterBuilder) BallooningEnabled(attr bool) *ClusterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cluster.SetBallooningEnabled(attr)
	return builder
}

func (builder *ClusterBuilder) BiosType(attr BiosType) *ClusterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cluster.SetBiosType(attr)
	return builder
}

func (builder *ClusterBuilder) Comment(attr string) *ClusterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cluster.SetComment(attr)
	return builder
}

func (builder *ClusterBuilder) Cpu(attr *Cpu) *ClusterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cluster.SetCpu(attr)
	return builder
}

func (builder *ClusterBuilder) CpuBuilder(attrBuilder *CpuBuilder) *ClusterBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Cpu(attr)
}

func (builder *ClusterBuilder) CpuProfiles(attr *CpuProfileSlice) *ClusterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cluster.SetCpuProfiles(attr)
	return builder
}

func (builder *ClusterBuilder) CpuProfilesOfAny(anys ...*CpuProfile) *ClusterBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.cluster.cpuProfiles == nil {
		builder.cluster.cpuProfiles = new(CpuProfileSlice)
	}
	builder.cluster.cpuProfiles.slice = append(builder.cluster.cpuProfiles.slice, anys...)
	return builder
}

func (builder *ClusterBuilder) CpuProfilesBuilderOfAny(anyBuilders ...CpuProfileBuilder) *ClusterBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.CpuProfilesOfAny(attr)
	}
	return builder
}

func (builder *ClusterBuilder) CustomSchedulingPolicyProperties(attr *PropertySlice) *ClusterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cluster.SetCustomSchedulingPolicyProperties(attr)
	return builder
}

func (builder *ClusterBuilder) CustomSchedulingPolicyPropertiesOfAny(anys ...*Property) *ClusterBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.cluster.customSchedulingPolicyProperties == nil {
		builder.cluster.customSchedulingPolicyProperties = new(PropertySlice)
	}
	builder.cluster.customSchedulingPolicyProperties.slice = append(builder.cluster.customSchedulingPolicyProperties.slice, anys...)
	return builder
}

func (builder *ClusterBuilder) CustomSchedulingPolicyPropertiesBuilderOfAny(anyBuilders ...PropertyBuilder) *ClusterBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.CustomSchedulingPolicyPropertiesOfAny(attr)
	}
	return builder
}

func (builder *ClusterBuilder) DataCenter(attr *DataCenter) *ClusterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cluster.SetDataCenter(attr)
	return builder
}

func (builder *ClusterBuilder) DataCenterBuilder(attrBuilder *DataCenterBuilder) *ClusterBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.DataCenter(attr)
}

func (builder *ClusterBuilder) Description(attr string) *ClusterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cluster.SetDescription(attr)
	return builder
}

func (builder *ClusterBuilder) Display(attr *Display) *ClusterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cluster.SetDisplay(attr)
	return builder
}

func (builder *ClusterBuilder) DisplayBuilder(attrBuilder *DisplayBuilder) *ClusterBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Display(attr)
}

func (builder *ClusterBuilder) EnabledFeatures(attr *ClusterFeatureSlice) *ClusterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cluster.SetEnabledFeatures(attr)
	return builder
}

func (builder *ClusterBuilder) EnabledFeaturesOfAny(anys ...*ClusterFeature) *ClusterBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.cluster.enabledFeatures == nil {
		builder.cluster.enabledFeatures = new(ClusterFeatureSlice)
	}
	builder.cluster.enabledFeatures.slice = append(builder.cluster.enabledFeatures.slice, anys...)
	return builder
}

func (builder *ClusterBuilder) EnabledFeaturesBuilderOfAny(anyBuilders ...ClusterFeatureBuilder) *ClusterBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.EnabledFeaturesOfAny(attr)
	}
	return builder
}

func (builder *ClusterBuilder) ErrorHandling(attr *ErrorHandling) *ClusterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cluster.SetErrorHandling(attr)
	return builder
}

func (builder *ClusterBuilder) ErrorHandlingBuilder(attrBuilder *ErrorHandlingBuilder) *ClusterBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.ErrorHandling(attr)
}

func (builder *ClusterBuilder) ExternalNetworkProviders(attr *ExternalProviderSlice) *ClusterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cluster.SetExternalNetworkProviders(attr)
	return builder
}

func (builder *ClusterBuilder) ExternalNetworkProvidersOfAny(anys ...*ExternalProvider) *ClusterBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.cluster.externalNetworkProviders == nil {
		builder.cluster.externalNetworkProviders = new(ExternalProviderSlice)
	}
	builder.cluster.externalNetworkProviders.slice = append(builder.cluster.externalNetworkProviders.slice, anys...)
	return builder
}

func (builder *ClusterBuilder) ExternalNetworkProvidersBuilderOfAny(anyBuilders ...ExternalProviderBuilder) *ClusterBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.ExternalNetworkProvidersOfAny(attr)
	}
	return builder
}

func (builder *ClusterBuilder) FencingPolicy(attr *FencingPolicy) *ClusterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cluster.SetFencingPolicy(attr)
	return builder
}

func (builder *ClusterBuilder) FencingPolicyBuilder(attrBuilder *FencingPolicyBuilder) *ClusterBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.FencingPolicy(attr)
}

func (builder *ClusterBuilder) FipsMode(attr FipsMode) *ClusterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cluster.SetFipsMode(attr)
	return builder
}

func (builder *ClusterBuilder) FirewallType(attr FirewallType) *ClusterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cluster.SetFirewallType(attr)
	return builder
}

func (builder *ClusterBuilder) GlusterHooks(attr *GlusterHookSlice) *ClusterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cluster.SetGlusterHooks(attr)
	return builder
}

func (builder *ClusterBuilder) GlusterHooksOfAny(anys ...*GlusterHook) *ClusterBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.cluster.glusterHooks == nil {
		builder.cluster.glusterHooks = new(GlusterHookSlice)
	}
	builder.cluster.glusterHooks.slice = append(builder.cluster.glusterHooks.slice, anys...)
	return builder
}

func (builder *ClusterBuilder) GlusterHooksBuilderOfAny(anyBuilders ...GlusterHookBuilder) *ClusterBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.GlusterHooksOfAny(attr)
	}
	return builder
}

func (builder *ClusterBuilder) GlusterService(attr bool) *ClusterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cluster.SetGlusterService(attr)
	return builder
}

func (builder *ClusterBuilder) GlusterTunedProfile(attr string) *ClusterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cluster.SetGlusterTunedProfile(attr)
	return builder
}

func (builder *ClusterBuilder) GlusterVolumes(attr *GlusterVolumeSlice) *ClusterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cluster.SetGlusterVolumes(attr)
	return builder
}

func (builder *ClusterBuilder) GlusterVolumesOfAny(anys ...*GlusterVolume) *ClusterBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.cluster.glusterVolumes == nil {
		builder.cluster.glusterVolumes = new(GlusterVolumeSlice)
	}
	builder.cluster.glusterVolumes.slice = append(builder.cluster.glusterVolumes.slice, anys...)
	return builder
}

func (builder *ClusterBuilder) GlusterVolumesBuilderOfAny(anyBuilders ...GlusterVolumeBuilder) *ClusterBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.GlusterVolumesOfAny(attr)
	}
	return builder
}

func (builder *ClusterBuilder) HaReservation(attr bool) *ClusterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cluster.SetHaReservation(attr)
	return builder
}

func (builder *ClusterBuilder) Id(attr string) *ClusterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cluster.SetId(attr)
	return builder
}

func (builder *ClusterBuilder) Ksm(attr *Ksm) *ClusterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cluster.SetKsm(attr)
	return builder
}

func (builder *ClusterBuilder) KsmBuilder(attrBuilder *KsmBuilder) *ClusterBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Ksm(attr)
}

func (builder *ClusterBuilder) LogMaxMemoryUsedThreshold(attr int64) *ClusterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cluster.SetLogMaxMemoryUsedThreshold(attr)
	return builder
}

func (builder *ClusterBuilder) LogMaxMemoryUsedThresholdType(attr LogMaxMemoryUsedThresholdType) *ClusterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cluster.SetLogMaxMemoryUsedThresholdType(attr)
	return builder
}

func (builder *ClusterBuilder) MacPool(attr *MacPool) *ClusterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cluster.SetMacPool(attr)
	return builder
}

func (builder *ClusterBuilder) MacPoolBuilder(attrBuilder *MacPoolBuilder) *ClusterBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.MacPool(attr)
}

func (builder *ClusterBuilder) MaintenanceReasonRequired(attr bool) *ClusterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cluster.SetMaintenanceReasonRequired(attr)
	return builder
}

func (builder *ClusterBuilder) ManagementNetwork(attr *Network) *ClusterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cluster.SetManagementNetwork(attr)
	return builder
}

func (builder *ClusterBuilder) ManagementNetworkBuilder(attrBuilder *NetworkBuilder) *ClusterBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.ManagementNetwork(attr)
}

func (builder *ClusterBuilder) MemoryPolicy(attr *MemoryPolicy) *ClusterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cluster.SetMemoryPolicy(attr)
	return builder
}

func (builder *ClusterBuilder) MemoryPolicyBuilder(attrBuilder *MemoryPolicyBuilder) *ClusterBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.MemoryPolicy(attr)
}

func (builder *ClusterBuilder) Migration(attr *MigrationOptions) *ClusterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cluster.SetMigration(attr)
	return builder
}

func (builder *ClusterBuilder) MigrationBuilder(attrBuilder *MigrationOptionsBuilder) *ClusterBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Migration(attr)
}

func (builder *ClusterBuilder) Name(attr string) *ClusterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cluster.SetName(attr)
	return builder
}

func (builder *ClusterBuilder) NetworkFilters(attr *NetworkFilterSlice) *ClusterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cluster.SetNetworkFilters(attr)
	return builder
}

func (builder *ClusterBuilder) NetworkFiltersOfAny(anys ...*NetworkFilter) *ClusterBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.cluster.networkFilters == nil {
		builder.cluster.networkFilters = new(NetworkFilterSlice)
	}
	builder.cluster.networkFilters.slice = append(builder.cluster.networkFilters.slice, anys...)
	return builder
}

func (builder *ClusterBuilder) NetworkFiltersBuilderOfAny(anyBuilders ...NetworkFilterBuilder) *ClusterBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.NetworkFiltersOfAny(attr)
	}
	return builder
}

func (builder *ClusterBuilder) Networks(attr *NetworkSlice) *ClusterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cluster.SetNetworks(attr)
	return builder
}

func (builder *ClusterBuilder) NetworksOfAny(anys ...*Network) *ClusterBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.cluster.networks == nil {
		builder.cluster.networks = new(NetworkSlice)
	}
	builder.cluster.networks.slice = append(builder.cluster.networks.slice, anys...)
	return builder
}

func (builder *ClusterBuilder) NetworksBuilderOfAny(anyBuilders ...NetworkBuilder) *ClusterBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.NetworksOfAny(attr)
	}
	return builder
}

func (builder *ClusterBuilder) OptionalReason(attr bool) *ClusterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cluster.SetOptionalReason(attr)
	return builder
}

func (builder *ClusterBuilder) Permissions(attr *PermissionSlice) *ClusterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cluster.SetPermissions(attr)
	return builder
}

func (builder *ClusterBuilder) PermissionsOfAny(anys ...*Permission) *ClusterBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.cluster.permissions == nil {
		builder.cluster.permissions = new(PermissionSlice)
	}
	builder.cluster.permissions.slice = append(builder.cluster.permissions.slice, anys...)
	return builder
}

func (builder *ClusterBuilder) PermissionsBuilderOfAny(anyBuilders ...PermissionBuilder) *ClusterBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.PermissionsOfAny(attr)
	}
	return builder
}

func (builder *ClusterBuilder) RequiredRngSources(attr []RngSource) *ClusterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cluster.SetRequiredRngSources(attr)
	return builder
}

func (builder *ClusterBuilder) RequiredRngSourcesOfAny(anys ...RngSource) *ClusterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cluster.requiredRngSources = append(builder.cluster.requiredRngSources, anys...)
	return builder
}

func (builder *ClusterBuilder) SchedulingPolicy(attr *SchedulingPolicy) *ClusterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cluster.SetSchedulingPolicy(attr)
	return builder
}

func (builder *ClusterBuilder) SchedulingPolicyBuilder(attrBuilder *SchedulingPolicyBuilder) *ClusterBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.SchedulingPolicy(attr)
}

func (builder *ClusterBuilder) SerialNumber(attr *SerialNumber) *ClusterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cluster.SetSerialNumber(attr)
	return builder
}

func (builder *ClusterBuilder) SerialNumberBuilder(attrBuilder *SerialNumberBuilder) *ClusterBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.SerialNumber(attr)
}

func (builder *ClusterBuilder) SupportedVersions(attr *VersionSlice) *ClusterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cluster.SetSupportedVersions(attr)
	return builder
}

func (builder *ClusterBuilder) SupportedVersionsOfAny(anys ...*Version) *ClusterBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.cluster.supportedVersions == nil {
		builder.cluster.supportedVersions = new(VersionSlice)
	}
	builder.cluster.supportedVersions.slice = append(builder.cluster.supportedVersions.slice, anys...)
	return builder
}

func (builder *ClusterBuilder) SupportedVersionsBuilderOfAny(anyBuilders ...VersionBuilder) *ClusterBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.SupportedVersionsOfAny(attr)
	}
	return builder
}

func (builder *ClusterBuilder) SwitchType(attr SwitchType) *ClusterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cluster.SetSwitchType(attr)
	return builder
}

func (builder *ClusterBuilder) ThreadsAsCores(attr bool) *ClusterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cluster.SetThreadsAsCores(attr)
	return builder
}

func (builder *ClusterBuilder) TrustedService(attr bool) *ClusterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cluster.SetTrustedService(attr)
	return builder
}

func (builder *ClusterBuilder) TunnelMigration(attr bool) *ClusterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cluster.SetTunnelMigration(attr)
	return builder
}

func (builder *ClusterBuilder) Version(attr *Version) *ClusterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cluster.SetVersion(attr)
	return builder
}

func (builder *ClusterBuilder) VersionBuilder(attrBuilder *VersionBuilder) *ClusterBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Version(attr)
}

func (builder *ClusterBuilder) VirtService(attr bool) *ClusterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cluster.SetVirtService(attr)
	return builder
}

func (builder *ClusterBuilder) VncEncryption(attr bool) *ClusterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cluster.SetVncEncryption(attr)
	return builder
}

func (builder *ClusterBuilder) Href(href string) *ClusterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cluster.SetHref(href)
	return builder
}

func (builder *ClusterBuilder) Build() (*Cluster, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.cluster, nil
}

func (builder *ClusterBuilder) MustBuild() *Cluster {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build Cluster instance, reason: %v", builder.err))
	}
	return builder.cluster
}

type ClusterFeatureBuilder struct {
	clusterFeature *ClusterFeature
	err            error
}

func NewClusterFeatureBuilder() *ClusterFeatureBuilder {
	return &ClusterFeatureBuilder{clusterFeature: &ClusterFeature{}, err: nil}
}

func (builder *ClusterFeatureBuilder) ClusterLevel(attr *ClusterLevel) *ClusterFeatureBuilder {
	if builder.err != nil {
		return builder
	}

	builder.clusterFeature.SetClusterLevel(attr)
	return builder
}

func (builder *ClusterFeatureBuilder) ClusterLevelBuilder(attrBuilder *ClusterLevelBuilder) *ClusterFeatureBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.ClusterLevel(attr)
}

func (builder *ClusterFeatureBuilder) Comment(attr string) *ClusterFeatureBuilder {
	if builder.err != nil {
		return builder
	}

	builder.clusterFeature.SetComment(attr)
	return builder
}

func (builder *ClusterFeatureBuilder) Description(attr string) *ClusterFeatureBuilder {
	if builder.err != nil {
		return builder
	}

	builder.clusterFeature.SetDescription(attr)
	return builder
}

func (builder *ClusterFeatureBuilder) Id(attr string) *ClusterFeatureBuilder {
	if builder.err != nil {
		return builder
	}

	builder.clusterFeature.SetId(attr)
	return builder
}

func (builder *ClusterFeatureBuilder) Name(attr string) *ClusterFeatureBuilder {
	if builder.err != nil {
		return builder
	}

	builder.clusterFeature.SetName(attr)
	return builder
}

func (builder *ClusterFeatureBuilder) Href(href string) *ClusterFeatureBuilder {
	if builder.err != nil {
		return builder
	}

	builder.clusterFeature.SetHref(href)
	return builder
}

func (builder *ClusterFeatureBuilder) Build() (*ClusterFeature, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.clusterFeature, nil
}

func (builder *ClusterFeatureBuilder) MustBuild() *ClusterFeature {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build ClusterFeature instance, reason: %v", builder.err))
	}
	return builder.clusterFeature
}

type ClusterLevelBuilder struct {
	clusterLevel *ClusterLevel
	err          error
}

func NewClusterLevelBuilder() *ClusterLevelBuilder {
	return &ClusterLevelBuilder{clusterLevel: &ClusterLevel{}, err: nil}
}

func (builder *ClusterLevelBuilder) ClusterFeatures(attr *ClusterFeatureSlice) *ClusterLevelBuilder {
	if builder.err != nil {
		return builder
	}

	builder.clusterLevel.SetClusterFeatures(attr)
	return builder
}

func (builder *ClusterLevelBuilder) ClusterFeaturesOfAny(anys ...*ClusterFeature) *ClusterLevelBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.clusterLevel.clusterFeatures == nil {
		builder.clusterLevel.clusterFeatures = new(ClusterFeatureSlice)
	}
	builder.clusterLevel.clusterFeatures.slice = append(builder.clusterLevel.clusterFeatures.slice, anys...)
	return builder
}

func (builder *ClusterLevelBuilder) ClusterFeaturesBuilderOfAny(anyBuilders ...ClusterFeatureBuilder) *ClusterLevelBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.ClusterFeaturesOfAny(attr)
	}
	return builder
}

func (builder *ClusterLevelBuilder) Comment(attr string) *ClusterLevelBuilder {
	if builder.err != nil {
		return builder
	}

	builder.clusterLevel.SetComment(attr)
	return builder
}

func (builder *ClusterLevelBuilder) CpuTypes(attr *CpuTypeSlice) *ClusterLevelBuilder {
	if builder.err != nil {
		return builder
	}

	builder.clusterLevel.SetCpuTypes(attr)
	return builder
}

func (builder *ClusterLevelBuilder) CpuTypesOfAny(anys ...*CpuType) *ClusterLevelBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.clusterLevel.cpuTypes == nil {
		builder.clusterLevel.cpuTypes = new(CpuTypeSlice)
	}
	builder.clusterLevel.cpuTypes.slice = append(builder.clusterLevel.cpuTypes.slice, anys...)
	return builder
}

func (builder *ClusterLevelBuilder) CpuTypesBuilderOfAny(anyBuilders ...CpuTypeBuilder) *ClusterLevelBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.CpuTypesOfAny(attr)
	}
	return builder
}

func (builder *ClusterLevelBuilder) Description(attr string) *ClusterLevelBuilder {
	if builder.err != nil {
		return builder
	}

	builder.clusterLevel.SetDescription(attr)
	return builder
}

func (builder *ClusterLevelBuilder) Id(attr string) *ClusterLevelBuilder {
	if builder.err != nil {
		return builder
	}

	builder.clusterLevel.SetId(attr)
	return builder
}

func (builder *ClusterLevelBuilder) Name(attr string) *ClusterLevelBuilder {
	if builder.err != nil {
		return builder
	}

	builder.clusterLevel.SetName(attr)
	return builder
}

func (builder *ClusterLevelBuilder) Permits(attr *PermitSlice) *ClusterLevelBuilder {
	if builder.err != nil {
		return builder
	}

	builder.clusterLevel.SetPermits(attr)
	return builder
}

func (builder *ClusterLevelBuilder) PermitsOfAny(anys ...*Permit) *ClusterLevelBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.clusterLevel.permits == nil {
		builder.clusterLevel.permits = new(PermitSlice)
	}
	builder.clusterLevel.permits.slice = append(builder.clusterLevel.permits.slice, anys...)
	return builder
}

func (builder *ClusterLevelBuilder) PermitsBuilderOfAny(anyBuilders ...PermitBuilder) *ClusterLevelBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.PermitsOfAny(attr)
	}
	return builder
}

func (builder *ClusterLevelBuilder) Href(href string) *ClusterLevelBuilder {
	if builder.err != nil {
		return builder
	}

	builder.clusterLevel.SetHref(href)
	return builder
}

func (builder *ClusterLevelBuilder) Build() (*ClusterLevel, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.clusterLevel, nil
}

func (builder *ClusterLevelBuilder) MustBuild() *ClusterLevel {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build ClusterLevel instance, reason: %v", builder.err))
	}
	return builder.clusterLevel
}

type ConfigurationBuilder struct {
	configuration *Configuration
	err           error
}

func NewConfigurationBuilder() *ConfigurationBuilder {
	return &ConfigurationBuilder{configuration: &Configuration{}, err: nil}
}

func (builder *ConfigurationBuilder) Data(attr string) *ConfigurationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.configuration.SetData(attr)
	return builder
}

func (builder *ConfigurationBuilder) Type(attr ConfigurationType) *ConfigurationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.configuration.SetType(attr)
	return builder
}

func (builder *ConfigurationBuilder) Href(href string) *ConfigurationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.configuration.SetHref(href)
	return builder
}

func (builder *ConfigurationBuilder) Build() (*Configuration, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.configuration, nil
}

func (builder *ConfigurationBuilder) MustBuild() *Configuration {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build Configuration instance, reason: %v", builder.err))
	}
	return builder.configuration
}

type ConsoleBuilder struct {
	console *Console
	err     error
}

func NewConsoleBuilder() *ConsoleBuilder {
	return &ConsoleBuilder{console: &Console{}, err: nil}
}

func (builder *ConsoleBuilder) Enabled(attr bool) *ConsoleBuilder {
	if builder.err != nil {
		return builder
	}

	builder.console.SetEnabled(attr)
	return builder
}

func (builder *ConsoleBuilder) Href(href string) *ConsoleBuilder {
	if builder.err != nil {
		return builder
	}

	builder.console.SetHref(href)
	return builder
}

func (builder *ConsoleBuilder) Build() (*Console, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.console, nil
}

func (builder *ConsoleBuilder) MustBuild() *Console {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build Console instance, reason: %v", builder.err))
	}
	return builder.console
}

type CoreBuilder struct {
	core *Core
	err  error
}

func NewCoreBuilder() *CoreBuilder {
	return &CoreBuilder{core: &Core{}, err: nil}
}

func (builder *CoreBuilder) Index(attr int64) *CoreBuilder {
	if builder.err != nil {
		return builder
	}

	builder.core.SetIndex(attr)
	return builder
}

func (builder *CoreBuilder) Socket(attr int64) *CoreBuilder {
	if builder.err != nil {
		return builder
	}

	builder.core.SetSocket(attr)
	return builder
}

func (builder *CoreBuilder) Href(href string) *CoreBuilder {
	if builder.err != nil {
		return builder
	}

	builder.core.SetHref(href)
	return builder
}

func (builder *CoreBuilder) Build() (*Core, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.core, nil
}

func (builder *CoreBuilder) MustBuild() *Core {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build Core instance, reason: %v", builder.err))
	}
	return builder.core
}

type CpuBuilder struct {
	cpu *Cpu
	err error
}

func NewCpuBuilder() *CpuBuilder {
	return &CpuBuilder{cpu: &Cpu{}, err: nil}
}

func (builder *CpuBuilder) Architecture(attr Architecture) *CpuBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cpu.SetArchitecture(attr)
	return builder
}

func (builder *CpuBuilder) Cores(attr *CoreSlice) *CpuBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cpu.SetCores(attr)
	return builder
}

func (builder *CpuBuilder) CoresOfAny(anys ...*Core) *CpuBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.cpu.cores == nil {
		builder.cpu.cores = new(CoreSlice)
	}
	builder.cpu.cores.slice = append(builder.cpu.cores.slice, anys...)
	return builder
}

func (builder *CpuBuilder) CoresBuilderOfAny(anyBuilders ...CoreBuilder) *CpuBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.CoresOfAny(attr)
	}
	return builder
}

func (builder *CpuBuilder) CpuTune(attr *CpuTune) *CpuBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cpu.SetCpuTune(attr)
	return builder
}

func (builder *CpuBuilder) CpuTuneBuilder(attrBuilder *CpuTuneBuilder) *CpuBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.CpuTune(attr)
}

func (builder *CpuBuilder) Level(attr int64) *CpuBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cpu.SetLevel(attr)
	return builder
}

func (builder *CpuBuilder) Mode(attr CpuMode) *CpuBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cpu.SetMode(attr)
	return builder
}

func (builder *CpuBuilder) Name(attr string) *CpuBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cpu.SetName(attr)
	return builder
}

func (builder *CpuBuilder) Speed(attr float64) *CpuBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cpu.SetSpeed(attr)
	return builder
}

func (builder *CpuBuilder) Topology(attr *CpuTopology) *CpuBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cpu.SetTopology(attr)
	return builder
}

func (builder *CpuBuilder) TopologyBuilder(attrBuilder *CpuTopologyBuilder) *CpuBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Topology(attr)
}

func (builder *CpuBuilder) Type(attr string) *CpuBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cpu.SetType(attr)
	return builder
}

func (builder *CpuBuilder) Href(href string) *CpuBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cpu.SetHref(href)
	return builder
}

func (builder *CpuBuilder) Build() (*Cpu, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.cpu, nil
}

func (builder *CpuBuilder) MustBuild() *Cpu {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build Cpu instance, reason: %v", builder.err))
	}
	return builder.cpu
}

type CpuProfileBuilder struct {
	cpuProfile *CpuProfile
	err        error
}

func NewCpuProfileBuilder() *CpuProfileBuilder {
	return &CpuProfileBuilder{cpuProfile: &CpuProfile{}, err: nil}
}

func (builder *CpuProfileBuilder) Cluster(attr *Cluster) *CpuProfileBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cpuProfile.SetCluster(attr)
	return builder
}

func (builder *CpuProfileBuilder) ClusterBuilder(attrBuilder *ClusterBuilder) *CpuProfileBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Cluster(attr)
}

func (builder *CpuProfileBuilder) Comment(attr string) *CpuProfileBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cpuProfile.SetComment(attr)
	return builder
}

func (builder *CpuProfileBuilder) Description(attr string) *CpuProfileBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cpuProfile.SetDescription(attr)
	return builder
}

func (builder *CpuProfileBuilder) Id(attr string) *CpuProfileBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cpuProfile.SetId(attr)
	return builder
}

func (builder *CpuProfileBuilder) Name(attr string) *CpuProfileBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cpuProfile.SetName(attr)
	return builder
}

func (builder *CpuProfileBuilder) Permissions(attr *PermissionSlice) *CpuProfileBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cpuProfile.SetPermissions(attr)
	return builder
}

func (builder *CpuProfileBuilder) PermissionsOfAny(anys ...*Permission) *CpuProfileBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.cpuProfile.permissions == nil {
		builder.cpuProfile.permissions = new(PermissionSlice)
	}
	builder.cpuProfile.permissions.slice = append(builder.cpuProfile.permissions.slice, anys...)
	return builder
}

func (builder *CpuProfileBuilder) PermissionsBuilderOfAny(anyBuilders ...PermissionBuilder) *CpuProfileBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.PermissionsOfAny(attr)
	}
	return builder
}

func (builder *CpuProfileBuilder) Qos(attr *Qos) *CpuProfileBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cpuProfile.SetQos(attr)
	return builder
}

func (builder *CpuProfileBuilder) QosBuilder(attrBuilder *QosBuilder) *CpuProfileBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Qos(attr)
}

func (builder *CpuProfileBuilder) Href(href string) *CpuProfileBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cpuProfile.SetHref(href)
	return builder
}

func (builder *CpuProfileBuilder) Build() (*CpuProfile, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.cpuProfile, nil
}

func (builder *CpuProfileBuilder) MustBuild() *CpuProfile {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build CpuProfile instance, reason: %v", builder.err))
	}
	return builder.cpuProfile
}

type CpuTopologyBuilder struct {
	cpuTopology *CpuTopology
	err         error
}

func NewCpuTopologyBuilder() *CpuTopologyBuilder {
	return &CpuTopologyBuilder{cpuTopology: &CpuTopology{}, err: nil}
}

func (builder *CpuTopologyBuilder) Cores(attr int64) *CpuTopologyBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cpuTopology.SetCores(attr)
	return builder
}

func (builder *CpuTopologyBuilder) Sockets(attr int64) *CpuTopologyBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cpuTopology.SetSockets(attr)
	return builder
}

func (builder *CpuTopologyBuilder) Threads(attr int64) *CpuTopologyBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cpuTopology.SetThreads(attr)
	return builder
}

func (builder *CpuTopologyBuilder) Href(href string) *CpuTopologyBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cpuTopology.SetHref(href)
	return builder
}

func (builder *CpuTopologyBuilder) Build() (*CpuTopology, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.cpuTopology, nil
}

func (builder *CpuTopologyBuilder) MustBuild() *CpuTopology {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build CpuTopology instance, reason: %v", builder.err))
	}
	return builder.cpuTopology
}

type CpuTuneBuilder struct {
	cpuTune *CpuTune
	err     error
}

func NewCpuTuneBuilder() *CpuTuneBuilder {
	return &CpuTuneBuilder{cpuTune: &CpuTune{}, err: nil}
}

func (builder *CpuTuneBuilder) VcpuPins(attr *VcpuPinSlice) *CpuTuneBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cpuTune.SetVcpuPins(attr)
	return builder
}

func (builder *CpuTuneBuilder) VcpuPinsOfAny(anys ...*VcpuPin) *CpuTuneBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.cpuTune.vcpuPins == nil {
		builder.cpuTune.vcpuPins = new(VcpuPinSlice)
	}
	builder.cpuTune.vcpuPins.slice = append(builder.cpuTune.vcpuPins.slice, anys...)
	return builder
}

func (builder *CpuTuneBuilder) VcpuPinsBuilderOfAny(anyBuilders ...VcpuPinBuilder) *CpuTuneBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.VcpuPinsOfAny(attr)
	}
	return builder
}

func (builder *CpuTuneBuilder) Href(href string) *CpuTuneBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cpuTune.SetHref(href)
	return builder
}

func (builder *CpuTuneBuilder) Build() (*CpuTune, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.cpuTune, nil
}

func (builder *CpuTuneBuilder) MustBuild() *CpuTune {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build CpuTune instance, reason: %v", builder.err))
	}
	return builder.cpuTune
}

type CpuTypeBuilder struct {
	cpuType *CpuType
	err     error
}

func NewCpuTypeBuilder() *CpuTypeBuilder {
	return &CpuTypeBuilder{cpuType: &CpuType{}, err: nil}
}

func (builder *CpuTypeBuilder) Architecture(attr Architecture) *CpuTypeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cpuType.SetArchitecture(attr)
	return builder
}

func (builder *CpuTypeBuilder) Level(attr int64) *CpuTypeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cpuType.SetLevel(attr)
	return builder
}

func (builder *CpuTypeBuilder) Name(attr string) *CpuTypeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cpuType.SetName(attr)
	return builder
}

func (builder *CpuTypeBuilder) Href(href string) *CpuTypeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.cpuType.SetHref(href)
	return builder
}

func (builder *CpuTypeBuilder) Build() (*CpuType, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.cpuType, nil
}

func (builder *CpuTypeBuilder) MustBuild() *CpuType {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build CpuType instance, reason: %v", builder.err))
	}
	return builder.cpuType
}

type CustomPropertyBuilder struct {
	customProperty *CustomProperty
	err            error
}

func NewCustomPropertyBuilder() *CustomPropertyBuilder {
	return &CustomPropertyBuilder{customProperty: &CustomProperty{}, err: nil}
}

func (builder *CustomPropertyBuilder) Name(attr string) *CustomPropertyBuilder {
	if builder.err != nil {
		return builder
	}

	builder.customProperty.SetName(attr)
	return builder
}

func (builder *CustomPropertyBuilder) Regexp(attr string) *CustomPropertyBuilder {
	if builder.err != nil {
		return builder
	}

	builder.customProperty.SetRegexp(attr)
	return builder
}

func (builder *CustomPropertyBuilder) Value(attr string) *CustomPropertyBuilder {
	if builder.err != nil {
		return builder
	}

	builder.customProperty.SetValue(attr)
	return builder
}

func (builder *CustomPropertyBuilder) Href(href string) *CustomPropertyBuilder {
	if builder.err != nil {
		return builder
	}

	builder.customProperty.SetHref(href)
	return builder
}

func (builder *CustomPropertyBuilder) Build() (*CustomProperty, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.customProperty, nil
}

func (builder *CustomPropertyBuilder) MustBuild() *CustomProperty {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build CustomProperty instance, reason: %v", builder.err))
	}
	return builder.customProperty
}

type DataCenterBuilder struct {
	dataCenter *DataCenter
	err        error
}

func NewDataCenterBuilder() *DataCenterBuilder {
	return &DataCenterBuilder{dataCenter: &DataCenter{}, err: nil}
}

func (builder *DataCenterBuilder) Clusters(attr *ClusterSlice) *DataCenterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.dataCenter.SetClusters(attr)
	return builder
}

func (builder *DataCenterBuilder) ClustersOfAny(anys ...*Cluster) *DataCenterBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.dataCenter.clusters == nil {
		builder.dataCenter.clusters = new(ClusterSlice)
	}
	builder.dataCenter.clusters.slice = append(builder.dataCenter.clusters.slice, anys...)
	return builder
}

func (builder *DataCenterBuilder) ClustersBuilderOfAny(anyBuilders ...ClusterBuilder) *DataCenterBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.ClustersOfAny(attr)
	}
	return builder
}

func (builder *DataCenterBuilder) Comment(attr string) *DataCenterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.dataCenter.SetComment(attr)
	return builder
}

func (builder *DataCenterBuilder) Description(attr string) *DataCenterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.dataCenter.SetDescription(attr)
	return builder
}

func (builder *DataCenterBuilder) Id(attr string) *DataCenterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.dataCenter.SetId(attr)
	return builder
}

func (builder *DataCenterBuilder) IscsiBonds(attr *IscsiBondSlice) *DataCenterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.dataCenter.SetIscsiBonds(attr)
	return builder
}

func (builder *DataCenterBuilder) IscsiBondsOfAny(anys ...*IscsiBond) *DataCenterBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.dataCenter.iscsiBonds == nil {
		builder.dataCenter.iscsiBonds = new(IscsiBondSlice)
	}
	builder.dataCenter.iscsiBonds.slice = append(builder.dataCenter.iscsiBonds.slice, anys...)
	return builder
}

func (builder *DataCenterBuilder) IscsiBondsBuilderOfAny(anyBuilders ...IscsiBondBuilder) *DataCenterBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.IscsiBondsOfAny(attr)
	}
	return builder
}

func (builder *DataCenterBuilder) Local(attr bool) *DataCenterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.dataCenter.SetLocal(attr)
	return builder
}

func (builder *DataCenterBuilder) MacPool(attr *MacPool) *DataCenterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.dataCenter.SetMacPool(attr)
	return builder
}

func (builder *DataCenterBuilder) MacPoolBuilder(attrBuilder *MacPoolBuilder) *DataCenterBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.MacPool(attr)
}

func (builder *DataCenterBuilder) Name(attr string) *DataCenterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.dataCenter.SetName(attr)
	return builder
}

func (builder *DataCenterBuilder) Networks(attr *NetworkSlice) *DataCenterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.dataCenter.SetNetworks(attr)
	return builder
}

func (builder *DataCenterBuilder) NetworksOfAny(anys ...*Network) *DataCenterBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.dataCenter.networks == nil {
		builder.dataCenter.networks = new(NetworkSlice)
	}
	builder.dataCenter.networks.slice = append(builder.dataCenter.networks.slice, anys...)
	return builder
}

func (builder *DataCenterBuilder) NetworksBuilderOfAny(anyBuilders ...NetworkBuilder) *DataCenterBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.NetworksOfAny(attr)
	}
	return builder
}

func (builder *DataCenterBuilder) Permissions(attr *PermissionSlice) *DataCenterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.dataCenter.SetPermissions(attr)
	return builder
}

func (builder *DataCenterBuilder) PermissionsOfAny(anys ...*Permission) *DataCenterBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.dataCenter.permissions == nil {
		builder.dataCenter.permissions = new(PermissionSlice)
	}
	builder.dataCenter.permissions.slice = append(builder.dataCenter.permissions.slice, anys...)
	return builder
}

func (builder *DataCenterBuilder) PermissionsBuilderOfAny(anyBuilders ...PermissionBuilder) *DataCenterBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.PermissionsOfAny(attr)
	}
	return builder
}

func (builder *DataCenterBuilder) Qoss(attr *QosSlice) *DataCenterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.dataCenter.SetQoss(attr)
	return builder
}

func (builder *DataCenterBuilder) QossOfAny(anys ...*Qos) *DataCenterBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.dataCenter.qoss == nil {
		builder.dataCenter.qoss = new(QosSlice)
	}
	builder.dataCenter.qoss.slice = append(builder.dataCenter.qoss.slice, anys...)
	return builder
}

func (builder *DataCenterBuilder) QossBuilderOfAny(anyBuilders ...QosBuilder) *DataCenterBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.QossOfAny(attr)
	}
	return builder
}

func (builder *DataCenterBuilder) QuotaMode(attr QuotaModeType) *DataCenterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.dataCenter.SetQuotaMode(attr)
	return builder
}

func (builder *DataCenterBuilder) Quotas(attr *QuotaSlice) *DataCenterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.dataCenter.SetQuotas(attr)
	return builder
}

func (builder *DataCenterBuilder) QuotasOfAny(anys ...*Quota) *DataCenterBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.dataCenter.quotas == nil {
		builder.dataCenter.quotas = new(QuotaSlice)
	}
	builder.dataCenter.quotas.slice = append(builder.dataCenter.quotas.slice, anys...)
	return builder
}

func (builder *DataCenterBuilder) QuotasBuilderOfAny(anyBuilders ...QuotaBuilder) *DataCenterBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.QuotasOfAny(attr)
	}
	return builder
}

func (builder *DataCenterBuilder) Status(attr DataCenterStatus) *DataCenterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.dataCenter.SetStatus(attr)
	return builder
}

func (builder *DataCenterBuilder) StorageDomains(attr *StorageDomainSlice) *DataCenterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.dataCenter.SetStorageDomains(attr)
	return builder
}

func (builder *DataCenterBuilder) StorageDomainsOfAny(anys ...*StorageDomain) *DataCenterBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.dataCenter.storageDomains == nil {
		builder.dataCenter.storageDomains = new(StorageDomainSlice)
	}
	builder.dataCenter.storageDomains.slice = append(builder.dataCenter.storageDomains.slice, anys...)
	return builder
}

func (builder *DataCenterBuilder) StorageDomainsBuilderOfAny(anyBuilders ...StorageDomainBuilder) *DataCenterBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.StorageDomainsOfAny(attr)
	}
	return builder
}

func (builder *DataCenterBuilder) StorageFormat(attr StorageFormat) *DataCenterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.dataCenter.SetStorageFormat(attr)
	return builder
}

func (builder *DataCenterBuilder) SupportedVersions(attr *VersionSlice) *DataCenterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.dataCenter.SetSupportedVersions(attr)
	return builder
}

func (builder *DataCenterBuilder) SupportedVersionsOfAny(anys ...*Version) *DataCenterBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.dataCenter.supportedVersions == nil {
		builder.dataCenter.supportedVersions = new(VersionSlice)
	}
	builder.dataCenter.supportedVersions.slice = append(builder.dataCenter.supportedVersions.slice, anys...)
	return builder
}

func (builder *DataCenterBuilder) SupportedVersionsBuilderOfAny(anyBuilders ...VersionBuilder) *DataCenterBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.SupportedVersionsOfAny(attr)
	}
	return builder
}

func (builder *DataCenterBuilder) Version(attr *Version) *DataCenterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.dataCenter.SetVersion(attr)
	return builder
}

func (builder *DataCenterBuilder) VersionBuilder(attrBuilder *VersionBuilder) *DataCenterBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Version(attr)
}

func (builder *DataCenterBuilder) Href(href string) *DataCenterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.dataCenter.SetHref(href)
	return builder
}

func (builder *DataCenterBuilder) Build() (*DataCenter, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.dataCenter, nil
}

func (builder *DataCenterBuilder) MustBuild() *DataCenter {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build DataCenter instance, reason: %v", builder.err))
	}
	return builder.dataCenter
}

type DeviceBuilder struct {
	device *Device
	err    error
}

func NewDeviceBuilder() *DeviceBuilder {
	return &DeviceBuilder{device: &Device{}, err: nil}
}

func (builder *DeviceBuilder) Comment(attr string) *DeviceBuilder {
	if builder.err != nil {
		return builder
	}

	builder.device.SetComment(attr)
	return builder
}

func (builder *DeviceBuilder) Description(attr string) *DeviceBuilder {
	if builder.err != nil {
		return builder
	}

	builder.device.SetDescription(attr)
	return builder
}

func (builder *DeviceBuilder) Id(attr string) *DeviceBuilder {
	if builder.err != nil {
		return builder
	}

	builder.device.SetId(attr)
	return builder
}

func (builder *DeviceBuilder) InstanceType(attr *InstanceType) *DeviceBuilder {
	if builder.err != nil {
		return builder
	}

	builder.device.SetInstanceType(attr)
	return builder
}

func (builder *DeviceBuilder) InstanceTypeBuilder(attrBuilder *InstanceTypeBuilder) *DeviceBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.InstanceType(attr)
}

func (builder *DeviceBuilder) Name(attr string) *DeviceBuilder {
	if builder.err != nil {
		return builder
	}

	builder.device.SetName(attr)
	return builder
}

func (builder *DeviceBuilder) Template(attr *Template) *DeviceBuilder {
	if builder.err != nil {
		return builder
	}

	builder.device.SetTemplate(attr)
	return builder
}

func (builder *DeviceBuilder) TemplateBuilder(attrBuilder *TemplateBuilder) *DeviceBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Template(attr)
}

func (builder *DeviceBuilder) Vm(attr *Vm) *DeviceBuilder {
	if builder.err != nil {
		return builder
	}

	builder.device.SetVm(attr)
	return builder
}

func (builder *DeviceBuilder) VmBuilder(attrBuilder *VmBuilder) *DeviceBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Vm(attr)
}

func (builder *DeviceBuilder) Vms(attr *VmSlice) *DeviceBuilder {
	if builder.err != nil {
		return builder
	}

	builder.device.SetVms(attr)
	return builder
}

func (builder *DeviceBuilder) VmsOfAny(anys ...*Vm) *DeviceBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.device.vms == nil {
		builder.device.vms = new(VmSlice)
	}
	builder.device.vms.slice = append(builder.device.vms.slice, anys...)
	return builder
}

func (builder *DeviceBuilder) VmsBuilderOfAny(anyBuilders ...VmBuilder) *DeviceBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.VmsOfAny(attr)
	}
	return builder
}

func (builder *DeviceBuilder) Href(href string) *DeviceBuilder {
	if builder.err != nil {
		return builder
	}

	builder.device.SetHref(href)
	return builder
}

func (builder *DeviceBuilder) Build() (*Device, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.device, nil
}

func (builder *DeviceBuilder) MustBuild() *Device {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build Device instance, reason: %v", builder.err))
	}
	return builder.device
}

type DiskBuilder struct {
	disk *Disk
	err  error
}

func NewDiskBuilder() *DiskBuilder {
	return &DiskBuilder{disk: &Disk{}, err: nil}
}

func (builder *DiskBuilder) Active(attr bool) *DiskBuilder {
	if builder.err != nil {
		return builder
	}

	builder.disk.SetActive(attr)
	return builder
}

func (builder *DiskBuilder) ActualSize(attr int64) *DiskBuilder {
	if builder.err != nil {
		return builder
	}

	builder.disk.SetActualSize(attr)
	return builder
}

func (builder *DiskBuilder) Alias(attr string) *DiskBuilder {
	if builder.err != nil {
		return builder
	}

	builder.disk.SetAlias(attr)
	return builder
}

func (builder *DiskBuilder) Backup(attr DiskBackup) *DiskBuilder {
	if builder.err != nil {
		return builder
	}

	builder.disk.SetBackup(attr)
	return builder
}

func (builder *DiskBuilder) BackupMode(attr DiskBackupMode) *DiskBuilder {
	if builder.err != nil {
		return builder
	}

	builder.disk.SetBackupMode(attr)
	return builder
}

func (builder *DiskBuilder) Bootable(attr bool) *DiskBuilder {
	if builder.err != nil {
		return builder
	}

	builder.disk.SetBootable(attr)
	return builder
}

func (builder *DiskBuilder) Comment(attr string) *DiskBuilder {
	if builder.err != nil {
		return builder
	}

	builder.disk.SetComment(attr)
	return builder
}

func (builder *DiskBuilder) ContentType(attr DiskContentType) *DiskBuilder {
	if builder.err != nil {
		return builder
	}

	builder.disk.SetContentType(attr)
	return builder
}

func (builder *DiskBuilder) Description(attr string) *DiskBuilder {
	if builder.err != nil {
		return builder
	}

	builder.disk.SetDescription(attr)
	return builder
}

func (builder *DiskBuilder) DiskProfile(attr *DiskProfile) *DiskBuilder {
	if builder.err != nil {
		return builder
	}

	builder.disk.SetDiskProfile(attr)
	return builder
}

func (builder *DiskBuilder) DiskProfileBuilder(attrBuilder *DiskProfileBuilder) *DiskBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.DiskProfile(attr)
}

func (builder *DiskBuilder) DiskSnapshots(attr *DiskSnapshotSlice) *DiskBuilder {
	if builder.err != nil {
		return builder
	}

	builder.disk.SetDiskSnapshots(attr)
	return builder
}

func (builder *DiskBuilder) DiskSnapshotsOfAny(anys ...*DiskSnapshot) *DiskBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.disk.diskSnapshots == nil {
		builder.disk.diskSnapshots = new(DiskSnapshotSlice)
	}
	builder.disk.diskSnapshots.slice = append(builder.disk.diskSnapshots.slice, anys...)
	return builder
}

func (builder *DiskBuilder) DiskSnapshotsBuilderOfAny(anyBuilders ...DiskSnapshotBuilder) *DiskBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.DiskSnapshotsOfAny(attr)
	}
	return builder
}

func (builder *DiskBuilder) ExternalDisk(attr string) *DiskBuilder {
	if builder.err != nil {
		return builder
	}

	builder.disk.SetExternalDisk(attr)
	return builder
}

func (builder *DiskBuilder) Format(attr DiskFormat) *DiskBuilder {
	if builder.err != nil {
		return builder
	}

	builder.disk.SetFormat(attr)
	return builder
}

func (builder *DiskBuilder) Id(attr string) *DiskBuilder {
	if builder.err != nil {
		return builder
	}

	builder.disk.SetId(attr)
	return builder
}

func (builder *DiskBuilder) ImageId(attr string) *DiskBuilder {
	if builder.err != nil {
		return builder
	}

	builder.disk.SetImageId(attr)
	return builder
}

func (builder *DiskBuilder) InitialSize(attr int64) *DiskBuilder {
	if builder.err != nil {
		return builder
	}

	builder.disk.SetInitialSize(attr)
	return builder
}

func (builder *DiskBuilder) InstanceType(attr *InstanceType) *DiskBuilder {
	if builder.err != nil {
		return builder
	}

	builder.disk.SetInstanceType(attr)
	return builder
}

func (builder *DiskBuilder) InstanceTypeBuilder(attrBuilder *InstanceTypeBuilder) *DiskBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.InstanceType(attr)
}

func (builder *DiskBuilder) Interface(attr DiskInterface) *DiskBuilder {
	if builder.err != nil {
		return builder
	}

	builder.disk.SetInterface(attr)
	return builder
}

func (builder *DiskBuilder) LogicalName(attr string) *DiskBuilder {
	if builder.err != nil {
		return builder
	}

	builder.disk.SetLogicalName(attr)
	return builder
}

func (builder *DiskBuilder) LunStorage(attr *HostStorage) *DiskBuilder {
	if builder.err != nil {
		return builder
	}

	builder.disk.SetLunStorage(attr)
	return builder
}

func (builder *DiskBuilder) LunStorageBuilder(attrBuilder *HostStorageBuilder) *DiskBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.LunStorage(attr)
}

func (builder *DiskBuilder) Name(attr string) *DiskBuilder {
	if builder.err != nil {
		return builder
	}

	builder.disk.SetName(attr)
	return builder
}

func (builder *DiskBuilder) OpenstackVolumeType(attr *OpenStackVolumeType) *DiskBuilder {
	if builder.err != nil {
		return builder
	}

	builder.disk.SetOpenstackVolumeType(attr)
	return builder
}

func (builder *DiskBuilder) OpenstackVolumeTypeBuilder(attrBuilder *OpenStackVolumeTypeBuilder) *DiskBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.OpenstackVolumeType(attr)
}

func (builder *DiskBuilder) Permissions(attr *PermissionSlice) *DiskBuilder {
	if builder.err != nil {
		return builder
	}

	builder.disk.SetPermissions(attr)
	return builder
}

func (builder *DiskBuilder) PermissionsOfAny(anys ...*Permission) *DiskBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.disk.permissions == nil {
		builder.disk.permissions = new(PermissionSlice)
	}
	builder.disk.permissions.slice = append(builder.disk.permissions.slice, anys...)
	return builder
}

func (builder *DiskBuilder) PermissionsBuilderOfAny(anyBuilders ...PermissionBuilder) *DiskBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.PermissionsOfAny(attr)
	}
	return builder
}

func (builder *DiskBuilder) PropagateErrors(attr bool) *DiskBuilder {
	if builder.err != nil {
		return builder
	}

	builder.disk.SetPropagateErrors(attr)
	return builder
}

func (builder *DiskBuilder) ProvisionedSize(attr int64) *DiskBuilder {
	if builder.err != nil {
		return builder
	}

	builder.disk.SetProvisionedSize(attr)
	return builder
}

func (builder *DiskBuilder) QcowVersion(attr QcowVersion) *DiskBuilder {
	if builder.err != nil {
		return builder
	}

	builder.disk.SetQcowVersion(attr)
	return builder
}

func (builder *DiskBuilder) Quota(attr *Quota) *DiskBuilder {
	if builder.err != nil {
		return builder
	}

	builder.disk.SetQuota(attr)
	return builder
}

func (builder *DiskBuilder) QuotaBuilder(attrBuilder *QuotaBuilder) *DiskBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Quota(attr)
}

func (builder *DiskBuilder) ReadOnly(attr bool) *DiskBuilder {
	if builder.err != nil {
		return builder
	}

	builder.disk.SetReadOnly(attr)
	return builder
}

func (builder *DiskBuilder) Sgio(attr ScsiGenericIO) *DiskBuilder {
	if builder.err != nil {
		return builder
	}

	builder.disk.SetSgio(attr)
	return builder
}

func (builder *DiskBuilder) Shareable(attr bool) *DiskBuilder {
	if builder.err != nil {
		return builder
	}

	builder.disk.SetShareable(attr)
	return builder
}

func (builder *DiskBuilder) Snapshot(attr *Snapshot) *DiskBuilder {
	if builder.err != nil {
		return builder
	}

	builder.disk.SetSnapshot(attr)
	return builder
}

func (builder *DiskBuilder) SnapshotBuilder(attrBuilder *SnapshotBuilder) *DiskBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Snapshot(attr)
}

func (builder *DiskBuilder) Sparse(attr bool) *DiskBuilder {
	if builder.err != nil {
		return builder
	}

	builder.disk.SetSparse(attr)
	return builder
}

func (builder *DiskBuilder) Statistics(attr *StatisticSlice) *DiskBuilder {
	if builder.err != nil {
		return builder
	}

	builder.disk.SetStatistics(attr)
	return builder
}

func (builder *DiskBuilder) StatisticsOfAny(anys ...*Statistic) *DiskBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.disk.statistics == nil {
		builder.disk.statistics = new(StatisticSlice)
	}
	builder.disk.statistics.slice = append(builder.disk.statistics.slice, anys...)
	return builder
}

func (builder *DiskBuilder) StatisticsBuilderOfAny(anyBuilders ...StatisticBuilder) *DiskBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.StatisticsOfAny(attr)
	}
	return builder
}

func (builder *DiskBuilder) Status(attr DiskStatus) *DiskBuilder {
	if builder.err != nil {
		return builder
	}

	builder.disk.SetStatus(attr)
	return builder
}

func (builder *DiskBuilder) StorageDomain(attr *StorageDomain) *DiskBuilder {
	if builder.err != nil {
		return builder
	}

	builder.disk.SetStorageDomain(attr)
	return builder
}

func (builder *DiskBuilder) StorageDomainBuilder(attrBuilder *StorageDomainBuilder) *DiskBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.StorageDomain(attr)
}

func (builder *DiskBuilder) StorageDomains(attr *StorageDomainSlice) *DiskBuilder {
	if builder.err != nil {
		return builder
	}

	builder.disk.SetStorageDomains(attr)
	return builder
}

func (builder *DiskBuilder) StorageDomainsOfAny(anys ...*StorageDomain) *DiskBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.disk.storageDomains == nil {
		builder.disk.storageDomains = new(StorageDomainSlice)
	}
	builder.disk.storageDomains.slice = append(builder.disk.storageDomains.slice, anys...)
	return builder
}

func (builder *DiskBuilder) StorageDomainsBuilderOfAny(anyBuilders ...StorageDomainBuilder) *DiskBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.StorageDomainsOfAny(attr)
	}
	return builder
}

func (builder *DiskBuilder) StorageType(attr DiskStorageType) *DiskBuilder {
	if builder.err != nil {
		return builder
	}

	builder.disk.SetStorageType(attr)
	return builder
}

func (builder *DiskBuilder) Template(attr *Template) *DiskBuilder {
	if builder.err != nil {
		return builder
	}

	builder.disk.SetTemplate(attr)
	return builder
}

func (builder *DiskBuilder) TemplateBuilder(attrBuilder *TemplateBuilder) *DiskBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Template(attr)
}

func (builder *DiskBuilder) TotalSize(attr int64) *DiskBuilder {
	if builder.err != nil {
		return builder
	}

	builder.disk.SetTotalSize(attr)
	return builder
}

func (builder *DiskBuilder) UsesScsiReservation(attr bool) *DiskBuilder {
	if builder.err != nil {
		return builder
	}

	builder.disk.SetUsesScsiReservation(attr)
	return builder
}

func (builder *DiskBuilder) Vm(attr *Vm) *DiskBuilder {
	if builder.err != nil {
		return builder
	}

	builder.disk.SetVm(attr)
	return builder
}

func (builder *DiskBuilder) VmBuilder(attrBuilder *VmBuilder) *DiskBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Vm(attr)
}

func (builder *DiskBuilder) Vms(attr *VmSlice) *DiskBuilder {
	if builder.err != nil {
		return builder
	}

	builder.disk.SetVms(attr)
	return builder
}

func (builder *DiskBuilder) VmsOfAny(anys ...*Vm) *DiskBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.disk.vms == nil {
		builder.disk.vms = new(VmSlice)
	}
	builder.disk.vms.slice = append(builder.disk.vms.slice, anys...)
	return builder
}

func (builder *DiskBuilder) VmsBuilderOfAny(anyBuilders ...VmBuilder) *DiskBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.VmsOfAny(attr)
	}
	return builder
}

func (builder *DiskBuilder) WipeAfterDelete(attr bool) *DiskBuilder {
	if builder.err != nil {
		return builder
	}

	builder.disk.SetWipeAfterDelete(attr)
	return builder
}

func (builder *DiskBuilder) Href(href string) *DiskBuilder {
	if builder.err != nil {
		return builder
	}

	builder.disk.SetHref(href)
	return builder
}

func (builder *DiskBuilder) Build() (*Disk, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.disk, nil
}

func (builder *DiskBuilder) MustBuild() *Disk {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build Disk instance, reason: %v", builder.err))
	}
	return builder.disk
}

type DiskAttachmentBuilder struct {
	diskAttachment *DiskAttachment
	err            error
}

func NewDiskAttachmentBuilder() *DiskAttachmentBuilder {
	return &DiskAttachmentBuilder{diskAttachment: &DiskAttachment{}, err: nil}
}

func (builder *DiskAttachmentBuilder) Active(attr bool) *DiskAttachmentBuilder {
	if builder.err != nil {
		return builder
	}

	builder.diskAttachment.SetActive(attr)
	return builder
}

func (builder *DiskAttachmentBuilder) Bootable(attr bool) *DiskAttachmentBuilder {
	if builder.err != nil {
		return builder
	}

	builder.diskAttachment.SetBootable(attr)
	return builder
}

func (builder *DiskAttachmentBuilder) Comment(attr string) *DiskAttachmentBuilder {
	if builder.err != nil {
		return builder
	}

	builder.diskAttachment.SetComment(attr)
	return builder
}

func (builder *DiskAttachmentBuilder) Description(attr string) *DiskAttachmentBuilder {
	if builder.err != nil {
		return builder
	}

	builder.diskAttachment.SetDescription(attr)
	return builder
}

func (builder *DiskAttachmentBuilder) Disk(attr *Disk) *DiskAttachmentBuilder {
	if builder.err != nil {
		return builder
	}

	builder.diskAttachment.SetDisk(attr)
	return builder
}

func (builder *DiskAttachmentBuilder) DiskBuilder(attrBuilder *DiskBuilder) *DiskAttachmentBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Disk(attr)
}

func (builder *DiskAttachmentBuilder) Id(attr string) *DiskAttachmentBuilder {
	if builder.err != nil {
		return builder
	}

	builder.diskAttachment.SetId(attr)
	return builder
}

func (builder *DiskAttachmentBuilder) Interface(attr DiskInterface) *DiskAttachmentBuilder {
	if builder.err != nil {
		return builder
	}

	builder.diskAttachment.SetInterface(attr)
	return builder
}

func (builder *DiskAttachmentBuilder) LogicalName(attr string) *DiskAttachmentBuilder {
	if builder.err != nil {
		return builder
	}

	builder.diskAttachment.SetLogicalName(attr)
	return builder
}

func (builder *DiskAttachmentBuilder) Name(attr string) *DiskAttachmentBuilder {
	if builder.err != nil {
		return builder
	}

	builder.diskAttachment.SetName(attr)
	return builder
}

func (builder *DiskAttachmentBuilder) PassDiscard(attr bool) *DiskAttachmentBuilder {
	if builder.err != nil {
		return builder
	}

	builder.diskAttachment.SetPassDiscard(attr)
	return builder
}

func (builder *DiskAttachmentBuilder) ReadOnly(attr bool) *DiskAttachmentBuilder {
	if builder.err != nil {
		return builder
	}

	builder.diskAttachment.SetReadOnly(attr)
	return builder
}

func (builder *DiskAttachmentBuilder) Template(attr *Template) *DiskAttachmentBuilder {
	if builder.err != nil {
		return builder
	}

	builder.diskAttachment.SetTemplate(attr)
	return builder
}

func (builder *DiskAttachmentBuilder) TemplateBuilder(attrBuilder *TemplateBuilder) *DiskAttachmentBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Template(attr)
}

func (builder *DiskAttachmentBuilder) UsesScsiReservation(attr bool) *DiskAttachmentBuilder {
	if builder.err != nil {
		return builder
	}

	builder.diskAttachment.SetUsesScsiReservation(attr)
	return builder
}

func (builder *DiskAttachmentBuilder) Vm(attr *Vm) *DiskAttachmentBuilder {
	if builder.err != nil {
		return builder
	}

	builder.diskAttachment.SetVm(attr)
	return builder
}

func (builder *DiskAttachmentBuilder) VmBuilder(attrBuilder *VmBuilder) *DiskAttachmentBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Vm(attr)
}

func (builder *DiskAttachmentBuilder) Href(href string) *DiskAttachmentBuilder {
	if builder.err != nil {
		return builder
	}

	builder.diskAttachment.SetHref(href)
	return builder
}

func (builder *DiskAttachmentBuilder) Build() (*DiskAttachment, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.diskAttachment, nil
}

func (builder *DiskAttachmentBuilder) MustBuild() *DiskAttachment {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build DiskAttachment instance, reason: %v", builder.err))
	}
	return builder.diskAttachment
}

type DiskProfileBuilder struct {
	diskProfile *DiskProfile
	err         error
}

func NewDiskProfileBuilder() *DiskProfileBuilder {
	return &DiskProfileBuilder{diskProfile: &DiskProfile{}, err: nil}
}

func (builder *DiskProfileBuilder) Comment(attr string) *DiskProfileBuilder {
	if builder.err != nil {
		return builder
	}

	builder.diskProfile.SetComment(attr)
	return builder
}

func (builder *DiskProfileBuilder) Description(attr string) *DiskProfileBuilder {
	if builder.err != nil {
		return builder
	}

	builder.diskProfile.SetDescription(attr)
	return builder
}

func (builder *DiskProfileBuilder) Id(attr string) *DiskProfileBuilder {
	if builder.err != nil {
		return builder
	}

	builder.diskProfile.SetId(attr)
	return builder
}

func (builder *DiskProfileBuilder) Name(attr string) *DiskProfileBuilder {
	if builder.err != nil {
		return builder
	}

	builder.diskProfile.SetName(attr)
	return builder
}

func (builder *DiskProfileBuilder) Permissions(attr *PermissionSlice) *DiskProfileBuilder {
	if builder.err != nil {
		return builder
	}

	builder.diskProfile.SetPermissions(attr)
	return builder
}

func (builder *DiskProfileBuilder) PermissionsOfAny(anys ...*Permission) *DiskProfileBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.diskProfile.permissions == nil {
		builder.diskProfile.permissions = new(PermissionSlice)
	}
	builder.diskProfile.permissions.slice = append(builder.diskProfile.permissions.slice, anys...)
	return builder
}

func (builder *DiskProfileBuilder) PermissionsBuilderOfAny(anyBuilders ...PermissionBuilder) *DiskProfileBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.PermissionsOfAny(attr)
	}
	return builder
}

func (builder *DiskProfileBuilder) Qos(attr *Qos) *DiskProfileBuilder {
	if builder.err != nil {
		return builder
	}

	builder.diskProfile.SetQos(attr)
	return builder
}

func (builder *DiskProfileBuilder) QosBuilder(attrBuilder *QosBuilder) *DiskProfileBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Qos(attr)
}

func (builder *DiskProfileBuilder) StorageDomain(attr *StorageDomain) *DiskProfileBuilder {
	if builder.err != nil {
		return builder
	}

	builder.diskProfile.SetStorageDomain(attr)
	return builder
}

func (builder *DiskProfileBuilder) StorageDomainBuilder(attrBuilder *StorageDomainBuilder) *DiskProfileBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.StorageDomain(attr)
}

func (builder *DiskProfileBuilder) Href(href string) *DiskProfileBuilder {
	if builder.err != nil {
		return builder
	}

	builder.diskProfile.SetHref(href)
	return builder
}

func (builder *DiskProfileBuilder) Build() (*DiskProfile, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.diskProfile, nil
}

func (builder *DiskProfileBuilder) MustBuild() *DiskProfile {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build DiskProfile instance, reason: %v", builder.err))
	}
	return builder.diskProfile
}

type DiskSnapshotBuilder struct {
	diskSnapshot *DiskSnapshot
	err          error
}

func NewDiskSnapshotBuilder() *DiskSnapshotBuilder {
	return &DiskSnapshotBuilder{diskSnapshot: &DiskSnapshot{}, err: nil}
}

func (builder *DiskSnapshotBuilder) Active(attr bool) *DiskSnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.diskSnapshot.SetActive(attr)
	return builder
}

func (builder *DiskSnapshotBuilder) ActualSize(attr int64) *DiskSnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.diskSnapshot.SetActualSize(attr)
	return builder
}

func (builder *DiskSnapshotBuilder) Alias(attr string) *DiskSnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.diskSnapshot.SetAlias(attr)
	return builder
}

func (builder *DiskSnapshotBuilder) Backup(attr DiskBackup) *DiskSnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.diskSnapshot.SetBackup(attr)
	return builder
}

func (builder *DiskSnapshotBuilder) BackupMode(attr DiskBackupMode) *DiskSnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.diskSnapshot.SetBackupMode(attr)
	return builder
}

func (builder *DiskSnapshotBuilder) Bootable(attr bool) *DiskSnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.diskSnapshot.SetBootable(attr)
	return builder
}

func (builder *DiskSnapshotBuilder) Comment(attr string) *DiskSnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.diskSnapshot.SetComment(attr)
	return builder
}

func (builder *DiskSnapshotBuilder) ContentType(attr DiskContentType) *DiskSnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.diskSnapshot.SetContentType(attr)
	return builder
}

func (builder *DiskSnapshotBuilder) Description(attr string) *DiskSnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.diskSnapshot.SetDescription(attr)
	return builder
}

func (builder *DiskSnapshotBuilder) Disk(attr *Disk) *DiskSnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.diskSnapshot.SetDisk(attr)
	return builder
}

func (builder *DiskSnapshotBuilder) DiskBuilder(attrBuilder *DiskBuilder) *DiskSnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Disk(attr)
}

func (builder *DiskSnapshotBuilder) DiskProfile(attr *DiskProfile) *DiskSnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.diskSnapshot.SetDiskProfile(attr)
	return builder
}

func (builder *DiskSnapshotBuilder) DiskProfileBuilder(attrBuilder *DiskProfileBuilder) *DiskSnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.DiskProfile(attr)
}

func (builder *DiskSnapshotBuilder) DiskSnapshots(attr *DiskSnapshotSlice) *DiskSnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.diskSnapshot.SetDiskSnapshots(attr)
	return builder
}

func (builder *DiskSnapshotBuilder) DiskSnapshotsOfAny(anys ...*DiskSnapshot) *DiskSnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.diskSnapshot.diskSnapshots == nil {
		builder.diskSnapshot.diskSnapshots = new(DiskSnapshotSlice)
	}
	builder.diskSnapshot.diskSnapshots.slice = append(builder.diskSnapshot.diskSnapshots.slice, anys...)
	return builder
}

func (builder *DiskSnapshotBuilder) DiskSnapshotsBuilderOfAny(anyBuilders ...DiskSnapshotBuilder) *DiskSnapshotBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.DiskSnapshotsOfAny(attr)
	}
	return builder
}

func (builder *DiskSnapshotBuilder) ExternalDisk(attr string) *DiskSnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.diskSnapshot.SetExternalDisk(attr)
	return builder
}

func (builder *DiskSnapshotBuilder) Format(attr DiskFormat) *DiskSnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.diskSnapshot.SetFormat(attr)
	return builder
}

func (builder *DiskSnapshotBuilder) Id(attr string) *DiskSnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.diskSnapshot.SetId(attr)
	return builder
}

func (builder *DiskSnapshotBuilder) ImageId(attr string) *DiskSnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.diskSnapshot.SetImageId(attr)
	return builder
}

func (builder *DiskSnapshotBuilder) InitialSize(attr int64) *DiskSnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.diskSnapshot.SetInitialSize(attr)
	return builder
}

func (builder *DiskSnapshotBuilder) InstanceType(attr *InstanceType) *DiskSnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.diskSnapshot.SetInstanceType(attr)
	return builder
}

func (builder *DiskSnapshotBuilder) InstanceTypeBuilder(attrBuilder *InstanceTypeBuilder) *DiskSnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.InstanceType(attr)
}

func (builder *DiskSnapshotBuilder) Interface(attr DiskInterface) *DiskSnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.diskSnapshot.SetInterface(attr)
	return builder
}

func (builder *DiskSnapshotBuilder) LogicalName(attr string) *DiskSnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.diskSnapshot.SetLogicalName(attr)
	return builder
}

func (builder *DiskSnapshotBuilder) LunStorage(attr *HostStorage) *DiskSnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.diskSnapshot.SetLunStorage(attr)
	return builder
}

func (builder *DiskSnapshotBuilder) LunStorageBuilder(attrBuilder *HostStorageBuilder) *DiskSnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.LunStorage(attr)
}

func (builder *DiskSnapshotBuilder) Name(attr string) *DiskSnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.diskSnapshot.SetName(attr)
	return builder
}

func (builder *DiskSnapshotBuilder) OpenstackVolumeType(attr *OpenStackVolumeType) *DiskSnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.diskSnapshot.SetOpenstackVolumeType(attr)
	return builder
}

func (builder *DiskSnapshotBuilder) OpenstackVolumeTypeBuilder(attrBuilder *OpenStackVolumeTypeBuilder) *DiskSnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.OpenstackVolumeType(attr)
}

func (builder *DiskSnapshotBuilder) Parent(attr *DiskSnapshot) *DiskSnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.diskSnapshot.SetParent(attr)
	return builder
}

func (builder *DiskSnapshotBuilder) ParentBuilder(attrBuilder *DiskSnapshotBuilder) *DiskSnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Parent(attr)
}

func (builder *DiskSnapshotBuilder) Permissions(attr *PermissionSlice) *DiskSnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.diskSnapshot.SetPermissions(attr)
	return builder
}

func (builder *DiskSnapshotBuilder) PermissionsOfAny(anys ...*Permission) *DiskSnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.diskSnapshot.permissions == nil {
		builder.diskSnapshot.permissions = new(PermissionSlice)
	}
	builder.diskSnapshot.permissions.slice = append(builder.diskSnapshot.permissions.slice, anys...)
	return builder
}

func (builder *DiskSnapshotBuilder) PermissionsBuilderOfAny(anyBuilders ...PermissionBuilder) *DiskSnapshotBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.PermissionsOfAny(attr)
	}
	return builder
}

func (builder *DiskSnapshotBuilder) PropagateErrors(attr bool) *DiskSnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.diskSnapshot.SetPropagateErrors(attr)
	return builder
}

func (builder *DiskSnapshotBuilder) ProvisionedSize(attr int64) *DiskSnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.diskSnapshot.SetProvisionedSize(attr)
	return builder
}

func (builder *DiskSnapshotBuilder) QcowVersion(attr QcowVersion) *DiskSnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.diskSnapshot.SetQcowVersion(attr)
	return builder
}

func (builder *DiskSnapshotBuilder) Quota(attr *Quota) *DiskSnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.diskSnapshot.SetQuota(attr)
	return builder
}

func (builder *DiskSnapshotBuilder) QuotaBuilder(attrBuilder *QuotaBuilder) *DiskSnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Quota(attr)
}

func (builder *DiskSnapshotBuilder) ReadOnly(attr bool) *DiskSnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.diskSnapshot.SetReadOnly(attr)
	return builder
}

func (builder *DiskSnapshotBuilder) Sgio(attr ScsiGenericIO) *DiskSnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.diskSnapshot.SetSgio(attr)
	return builder
}

func (builder *DiskSnapshotBuilder) Shareable(attr bool) *DiskSnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.diskSnapshot.SetShareable(attr)
	return builder
}

func (builder *DiskSnapshotBuilder) Snapshot(attr *Snapshot) *DiskSnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.diskSnapshot.SetSnapshot(attr)
	return builder
}

func (builder *DiskSnapshotBuilder) SnapshotBuilder(attrBuilder *SnapshotBuilder) *DiskSnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Snapshot(attr)
}

func (builder *DiskSnapshotBuilder) Sparse(attr bool) *DiskSnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.diskSnapshot.SetSparse(attr)
	return builder
}

func (builder *DiskSnapshotBuilder) Statistics(attr *StatisticSlice) *DiskSnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.diskSnapshot.SetStatistics(attr)
	return builder
}

func (builder *DiskSnapshotBuilder) StatisticsOfAny(anys ...*Statistic) *DiskSnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.diskSnapshot.statistics == nil {
		builder.diskSnapshot.statistics = new(StatisticSlice)
	}
	builder.diskSnapshot.statistics.slice = append(builder.diskSnapshot.statistics.slice, anys...)
	return builder
}

func (builder *DiskSnapshotBuilder) StatisticsBuilderOfAny(anyBuilders ...StatisticBuilder) *DiskSnapshotBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.StatisticsOfAny(attr)
	}
	return builder
}

func (builder *DiskSnapshotBuilder) Status(attr DiskStatus) *DiskSnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.diskSnapshot.SetStatus(attr)
	return builder
}

func (builder *DiskSnapshotBuilder) StorageDomain(attr *StorageDomain) *DiskSnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.diskSnapshot.SetStorageDomain(attr)
	return builder
}

func (builder *DiskSnapshotBuilder) StorageDomainBuilder(attrBuilder *StorageDomainBuilder) *DiskSnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.StorageDomain(attr)
}

func (builder *DiskSnapshotBuilder) StorageDomains(attr *StorageDomainSlice) *DiskSnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.diskSnapshot.SetStorageDomains(attr)
	return builder
}

func (builder *DiskSnapshotBuilder) StorageDomainsOfAny(anys ...*StorageDomain) *DiskSnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.diskSnapshot.storageDomains == nil {
		builder.diskSnapshot.storageDomains = new(StorageDomainSlice)
	}
	builder.diskSnapshot.storageDomains.slice = append(builder.diskSnapshot.storageDomains.slice, anys...)
	return builder
}

func (builder *DiskSnapshotBuilder) StorageDomainsBuilderOfAny(anyBuilders ...StorageDomainBuilder) *DiskSnapshotBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.StorageDomainsOfAny(attr)
	}
	return builder
}

func (builder *DiskSnapshotBuilder) StorageType(attr DiskStorageType) *DiskSnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.diskSnapshot.SetStorageType(attr)
	return builder
}

func (builder *DiskSnapshotBuilder) Template(attr *Template) *DiskSnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.diskSnapshot.SetTemplate(attr)
	return builder
}

func (builder *DiskSnapshotBuilder) TemplateBuilder(attrBuilder *TemplateBuilder) *DiskSnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Template(attr)
}

func (builder *DiskSnapshotBuilder) TotalSize(attr int64) *DiskSnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.diskSnapshot.SetTotalSize(attr)
	return builder
}

func (builder *DiskSnapshotBuilder) UsesScsiReservation(attr bool) *DiskSnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.diskSnapshot.SetUsesScsiReservation(attr)
	return builder
}

func (builder *DiskSnapshotBuilder) Vm(attr *Vm) *DiskSnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.diskSnapshot.SetVm(attr)
	return builder
}

func (builder *DiskSnapshotBuilder) VmBuilder(attrBuilder *VmBuilder) *DiskSnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Vm(attr)
}

func (builder *DiskSnapshotBuilder) Vms(attr *VmSlice) *DiskSnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.diskSnapshot.SetVms(attr)
	return builder
}

func (builder *DiskSnapshotBuilder) VmsOfAny(anys ...*Vm) *DiskSnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.diskSnapshot.vms == nil {
		builder.diskSnapshot.vms = new(VmSlice)
	}
	builder.diskSnapshot.vms.slice = append(builder.diskSnapshot.vms.slice, anys...)
	return builder
}

func (builder *DiskSnapshotBuilder) VmsBuilderOfAny(anyBuilders ...VmBuilder) *DiskSnapshotBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.VmsOfAny(attr)
	}
	return builder
}

func (builder *DiskSnapshotBuilder) WipeAfterDelete(attr bool) *DiskSnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.diskSnapshot.SetWipeAfterDelete(attr)
	return builder
}

func (builder *DiskSnapshotBuilder) Href(href string) *DiskSnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.diskSnapshot.SetHref(href)
	return builder
}

func (builder *DiskSnapshotBuilder) Build() (*DiskSnapshot, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.diskSnapshot, nil
}

func (builder *DiskSnapshotBuilder) MustBuild() *DiskSnapshot {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build DiskSnapshot instance, reason: %v", builder.err))
	}
	return builder.diskSnapshot
}

type DisplayBuilder struct {
	display *Display
	err     error
}

func NewDisplayBuilder() *DisplayBuilder {
	return &DisplayBuilder{display: &Display{}, err: nil}
}

func (builder *DisplayBuilder) Address(attr string) *DisplayBuilder {
	if builder.err != nil {
		return builder
	}

	builder.display.SetAddress(attr)
	return builder
}

func (builder *DisplayBuilder) AllowOverride(attr bool) *DisplayBuilder {
	if builder.err != nil {
		return builder
	}

	builder.display.SetAllowOverride(attr)
	return builder
}

func (builder *DisplayBuilder) Certificate(attr *Certificate) *DisplayBuilder {
	if builder.err != nil {
		return builder
	}

	builder.display.SetCertificate(attr)
	return builder
}

func (builder *DisplayBuilder) CertificateBuilder(attrBuilder *CertificateBuilder) *DisplayBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Certificate(attr)
}

func (builder *DisplayBuilder) CopyPasteEnabled(attr bool) *DisplayBuilder {
	if builder.err != nil {
		return builder
	}

	builder.display.SetCopyPasteEnabled(attr)
	return builder
}

func (builder *DisplayBuilder) DisconnectAction(attr string) *DisplayBuilder {
	if builder.err != nil {
		return builder
	}

	builder.display.SetDisconnectAction(attr)
	return builder
}

func (builder *DisplayBuilder) FileTransferEnabled(attr bool) *DisplayBuilder {
	if builder.err != nil {
		return builder
	}

	builder.display.SetFileTransferEnabled(attr)
	return builder
}

func (builder *DisplayBuilder) KeyboardLayout(attr string) *DisplayBuilder {
	if builder.err != nil {
		return builder
	}

	builder.display.SetKeyboardLayout(attr)
	return builder
}

func (builder *DisplayBuilder) Monitors(attr int64) *DisplayBuilder {
	if builder.err != nil {
		return builder
	}

	builder.display.SetMonitors(attr)
	return builder
}

func (builder *DisplayBuilder) Port(attr int64) *DisplayBuilder {
	if builder.err != nil {
		return builder
	}

	builder.display.SetPort(attr)
	return builder
}

func (builder *DisplayBuilder) Proxy(attr string) *DisplayBuilder {
	if builder.err != nil {
		return builder
	}

	builder.display.SetProxy(attr)
	return builder
}

func (builder *DisplayBuilder) SecurePort(attr int64) *DisplayBuilder {
	if builder.err != nil {
		return builder
	}

	builder.display.SetSecurePort(attr)
	return builder
}

func (builder *DisplayBuilder) SingleQxlPci(attr bool) *DisplayBuilder {
	if builder.err != nil {
		return builder
	}

	builder.display.SetSingleQxlPci(attr)
	return builder
}

func (builder *DisplayBuilder) SmartcardEnabled(attr bool) *DisplayBuilder {
	if builder.err != nil {
		return builder
	}

	builder.display.SetSmartcardEnabled(attr)
	return builder
}

func (builder *DisplayBuilder) Type(attr DisplayType) *DisplayBuilder {
	if builder.err != nil {
		return builder
	}

	builder.display.SetType(attr)
	return builder
}

func (builder *DisplayBuilder) Href(href string) *DisplayBuilder {
	if builder.err != nil {
		return builder
	}

	builder.display.SetHref(href)
	return builder
}

func (builder *DisplayBuilder) Build() (*Display, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.display, nil
}

func (builder *DisplayBuilder) MustBuild() *Display {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build Display instance, reason: %v", builder.err))
	}
	return builder.display
}

type DnsBuilder struct {
	dns *Dns
	err error
}

func NewDnsBuilder() *DnsBuilder {
	return &DnsBuilder{dns: &Dns{}, err: nil}
}

func (builder *DnsBuilder) SearchDomains(attr *HostSlice) *DnsBuilder {
	if builder.err != nil {
		return builder
	}

	builder.dns.SetSearchDomains(attr)
	return builder
}

func (builder *DnsBuilder) SearchDomainsOfAny(anys ...*Host) *DnsBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.dns.searchDomains == nil {
		builder.dns.searchDomains = new(HostSlice)
	}
	builder.dns.searchDomains.slice = append(builder.dns.searchDomains.slice, anys...)
	return builder
}

func (builder *DnsBuilder) SearchDomainsBuilderOfAny(anyBuilders ...HostBuilder) *DnsBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.SearchDomainsOfAny(attr)
	}
	return builder
}

func (builder *DnsBuilder) Servers(attr *HostSlice) *DnsBuilder {
	if builder.err != nil {
		return builder
	}

	builder.dns.SetServers(attr)
	return builder
}

func (builder *DnsBuilder) ServersOfAny(anys ...*Host) *DnsBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.dns.servers == nil {
		builder.dns.servers = new(HostSlice)
	}
	builder.dns.servers.slice = append(builder.dns.servers.slice, anys...)
	return builder
}

func (builder *DnsBuilder) ServersBuilderOfAny(anyBuilders ...HostBuilder) *DnsBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.ServersOfAny(attr)
	}
	return builder
}

func (builder *DnsBuilder) Href(href string) *DnsBuilder {
	if builder.err != nil {
		return builder
	}

	builder.dns.SetHref(href)
	return builder
}

func (builder *DnsBuilder) Build() (*Dns, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.dns, nil
}

func (builder *DnsBuilder) MustBuild() *Dns {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build Dns instance, reason: %v", builder.err))
	}
	return builder.dns
}

type DnsResolverConfigurationBuilder struct {
	dnsResolverConfiguration *DnsResolverConfiguration
	err                      error
}

func NewDnsResolverConfigurationBuilder() *DnsResolverConfigurationBuilder {
	return &DnsResolverConfigurationBuilder{dnsResolverConfiguration: &DnsResolverConfiguration{}, err: nil}
}

func (builder *DnsResolverConfigurationBuilder) NameServers(attr []string) *DnsResolverConfigurationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.dnsResolverConfiguration.SetNameServers(attr)
	return builder
}

func (builder *DnsResolverConfigurationBuilder) NameServersOfAny(anys ...string) *DnsResolverConfigurationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.dnsResolverConfiguration.nameServers = append(builder.dnsResolverConfiguration.nameServers, anys...)
	return builder
}

func (builder *DnsResolverConfigurationBuilder) Href(href string) *DnsResolverConfigurationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.dnsResolverConfiguration.SetHref(href)
	return builder
}

func (builder *DnsResolverConfigurationBuilder) Build() (*DnsResolverConfiguration, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.dnsResolverConfiguration, nil
}

func (builder *DnsResolverConfigurationBuilder) MustBuild() *DnsResolverConfiguration {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build DnsResolverConfiguration instance, reason: %v", builder.err))
	}
	return builder.dnsResolverConfiguration
}

type DomainBuilder struct {
	domain *Domain
	err    error
}

func NewDomainBuilder() *DomainBuilder {
	return &DomainBuilder{domain: &Domain{}, err: nil}
}

func (builder *DomainBuilder) Comment(attr string) *DomainBuilder {
	if builder.err != nil {
		return builder
	}

	builder.domain.SetComment(attr)
	return builder
}

func (builder *DomainBuilder) Description(attr string) *DomainBuilder {
	if builder.err != nil {
		return builder
	}

	builder.domain.SetDescription(attr)
	return builder
}

func (builder *DomainBuilder) Groups(attr *GroupSlice) *DomainBuilder {
	if builder.err != nil {
		return builder
	}

	builder.domain.SetGroups(attr)
	return builder
}

func (builder *DomainBuilder) GroupsOfAny(anys ...*Group) *DomainBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.domain.groups == nil {
		builder.domain.groups = new(GroupSlice)
	}
	builder.domain.groups.slice = append(builder.domain.groups.slice, anys...)
	return builder
}

func (builder *DomainBuilder) GroupsBuilderOfAny(anyBuilders ...GroupBuilder) *DomainBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.GroupsOfAny(attr)
	}
	return builder
}

func (builder *DomainBuilder) Id(attr string) *DomainBuilder {
	if builder.err != nil {
		return builder
	}

	builder.domain.SetId(attr)
	return builder
}

func (builder *DomainBuilder) Name(attr string) *DomainBuilder {
	if builder.err != nil {
		return builder
	}

	builder.domain.SetName(attr)
	return builder
}

func (builder *DomainBuilder) User(attr *User) *DomainBuilder {
	if builder.err != nil {
		return builder
	}

	builder.domain.SetUser(attr)
	return builder
}

func (builder *DomainBuilder) UserBuilder(attrBuilder *UserBuilder) *DomainBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.User(attr)
}

func (builder *DomainBuilder) Users(attr *UserSlice) *DomainBuilder {
	if builder.err != nil {
		return builder
	}

	builder.domain.SetUsers(attr)
	return builder
}

func (builder *DomainBuilder) UsersOfAny(anys ...*User) *DomainBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.domain.users == nil {
		builder.domain.users = new(UserSlice)
	}
	builder.domain.users.slice = append(builder.domain.users.slice, anys...)
	return builder
}

func (builder *DomainBuilder) UsersBuilderOfAny(anyBuilders ...UserBuilder) *DomainBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.UsersOfAny(attr)
	}
	return builder
}

func (builder *DomainBuilder) Href(href string) *DomainBuilder {
	if builder.err != nil {
		return builder
	}

	builder.domain.SetHref(href)
	return builder
}

func (builder *DomainBuilder) Build() (*Domain, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.domain, nil
}

func (builder *DomainBuilder) MustBuild() *Domain {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build Domain instance, reason: %v", builder.err))
	}
	return builder.domain
}

type EntityProfileDetailBuilder struct {
	entityProfileDetail *EntityProfileDetail
	err                 error
}

func NewEntityProfileDetailBuilder() *EntityProfileDetailBuilder {
	return &EntityProfileDetailBuilder{entityProfileDetail: &EntityProfileDetail{}, err: nil}
}

func (builder *EntityProfileDetailBuilder) ProfileDetails(attr *ProfileDetailSlice) *EntityProfileDetailBuilder {
	if builder.err != nil {
		return builder
	}

	builder.entityProfileDetail.SetProfileDetails(attr)
	return builder
}

func (builder *EntityProfileDetailBuilder) ProfileDetailsOfAny(anys ...*ProfileDetail) *EntityProfileDetailBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.entityProfileDetail.profileDetails == nil {
		builder.entityProfileDetail.profileDetails = new(ProfileDetailSlice)
	}
	builder.entityProfileDetail.profileDetails.slice = append(builder.entityProfileDetail.profileDetails.slice, anys...)
	return builder
}

func (builder *EntityProfileDetailBuilder) ProfileDetailsBuilderOfAny(anyBuilders ...ProfileDetailBuilder) *EntityProfileDetailBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.ProfileDetailsOfAny(attr)
	}
	return builder
}

func (builder *EntityProfileDetailBuilder) Href(href string) *EntityProfileDetailBuilder {
	if builder.err != nil {
		return builder
	}

	builder.entityProfileDetail.SetHref(href)
	return builder
}

func (builder *EntityProfileDetailBuilder) Build() (*EntityProfileDetail, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.entityProfileDetail, nil
}

func (builder *EntityProfileDetailBuilder) MustBuild() *EntityProfileDetail {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build EntityProfileDetail instance, reason: %v", builder.err))
	}
	return builder.entityProfileDetail
}

type ErrorHandlingBuilder struct {
	errorHandling *ErrorHandling
	err           error
}

func NewErrorHandlingBuilder() *ErrorHandlingBuilder {
	return &ErrorHandlingBuilder{errorHandling: &ErrorHandling{}, err: nil}
}

func (builder *ErrorHandlingBuilder) OnError(attr MigrateOnError) *ErrorHandlingBuilder {
	if builder.err != nil {
		return builder
	}

	builder.errorHandling.SetOnError(attr)
	return builder
}

func (builder *ErrorHandlingBuilder) Href(href string) *ErrorHandlingBuilder {
	if builder.err != nil {
		return builder
	}

	builder.errorHandling.SetHref(href)
	return builder
}

func (builder *ErrorHandlingBuilder) Build() (*ErrorHandling, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.errorHandling, nil
}

func (builder *ErrorHandlingBuilder) MustBuild() *ErrorHandling {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build ErrorHandling instance, reason: %v", builder.err))
	}
	return builder.errorHandling
}

type EventBuilder struct {
	event *Event
	err   error
}

func NewEventBuilder() *EventBuilder {
	return &EventBuilder{event: &Event{}, err: nil}
}

func (builder *EventBuilder) Cluster(attr *Cluster) *EventBuilder {
	if builder.err != nil {
		return builder
	}

	builder.event.SetCluster(attr)
	return builder
}

func (builder *EventBuilder) ClusterBuilder(attrBuilder *ClusterBuilder) *EventBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Cluster(attr)
}

func (builder *EventBuilder) Code(attr int64) *EventBuilder {
	if builder.err != nil {
		return builder
	}

	builder.event.SetCode(attr)
	return builder
}

func (builder *EventBuilder) Comment(attr string) *EventBuilder {
	if builder.err != nil {
		return builder
	}

	builder.event.SetComment(attr)
	return builder
}

func (builder *EventBuilder) CorrelationId(attr string) *EventBuilder {
	if builder.err != nil {
		return builder
	}

	builder.event.SetCorrelationId(attr)
	return builder
}

func (builder *EventBuilder) CustomData(attr string) *EventBuilder {
	if builder.err != nil {
		return builder
	}

	builder.event.SetCustomData(attr)
	return builder
}

func (builder *EventBuilder) CustomId(attr int64) *EventBuilder {
	if builder.err != nil {
		return builder
	}

	builder.event.SetCustomId(attr)
	return builder
}

func (builder *EventBuilder) DataCenter(attr *DataCenter) *EventBuilder {
	if builder.err != nil {
		return builder
	}

	builder.event.SetDataCenter(attr)
	return builder
}

func (builder *EventBuilder) DataCenterBuilder(attrBuilder *DataCenterBuilder) *EventBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.DataCenter(attr)
}

func (builder *EventBuilder) Description(attr string) *EventBuilder {
	if builder.err != nil {
		return builder
	}

	builder.event.SetDescription(attr)
	return builder
}

func (builder *EventBuilder) FloodRate(attr int64) *EventBuilder {
	if builder.err != nil {
		return builder
	}

	builder.event.SetFloodRate(attr)
	return builder
}

func (builder *EventBuilder) Host(attr *Host) *EventBuilder {
	if builder.err != nil {
		return builder
	}

	builder.event.SetHost(attr)
	return builder
}

func (builder *EventBuilder) HostBuilder(attrBuilder *HostBuilder) *EventBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Host(attr)
}

func (builder *EventBuilder) Id(attr string) *EventBuilder {
	if builder.err != nil {
		return builder
	}

	builder.event.SetId(attr)
	return builder
}

func (builder *EventBuilder) Index(attr int64) *EventBuilder {
	if builder.err != nil {
		return builder
	}

	builder.event.SetIndex(attr)
	return builder
}

func (builder *EventBuilder) LogOnHost(attr bool) *EventBuilder {
	if builder.err != nil {
		return builder
	}

	builder.event.SetLogOnHost(attr)
	return builder
}

func (builder *EventBuilder) Name(attr string) *EventBuilder {
	if builder.err != nil {
		return builder
	}

	builder.event.SetName(attr)
	return builder
}

func (builder *EventBuilder) Origin(attr string) *EventBuilder {
	if builder.err != nil {
		return builder
	}

	builder.event.SetOrigin(attr)
	return builder
}

func (builder *EventBuilder) Severity(attr LogSeverity) *EventBuilder {
	if builder.err != nil {
		return builder
	}

	builder.event.SetSeverity(attr)
	return builder
}

func (builder *EventBuilder) StorageDomain(attr *StorageDomain) *EventBuilder {
	if builder.err != nil {
		return builder
	}

	builder.event.SetStorageDomain(attr)
	return builder
}

func (builder *EventBuilder) StorageDomainBuilder(attrBuilder *StorageDomainBuilder) *EventBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.StorageDomain(attr)
}

func (builder *EventBuilder) Template(attr *Template) *EventBuilder {
	if builder.err != nil {
		return builder
	}

	builder.event.SetTemplate(attr)
	return builder
}

func (builder *EventBuilder) TemplateBuilder(attrBuilder *TemplateBuilder) *EventBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Template(attr)
}

func (builder *EventBuilder) Time(attr time.Time) *EventBuilder {
	if builder.err != nil {
		return builder
	}

	builder.event.SetTime(attr)
	return builder
}

func (builder *EventBuilder) User(attr *User) *EventBuilder {
	if builder.err != nil {
		return builder
	}

	builder.event.SetUser(attr)
	return builder
}

func (builder *EventBuilder) UserBuilder(attrBuilder *UserBuilder) *EventBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.User(attr)
}

func (builder *EventBuilder) Vm(attr *Vm) *EventBuilder {
	if builder.err != nil {
		return builder
	}

	builder.event.SetVm(attr)
	return builder
}

func (builder *EventBuilder) VmBuilder(attrBuilder *VmBuilder) *EventBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Vm(attr)
}

func (builder *EventBuilder) Href(href string) *EventBuilder {
	if builder.err != nil {
		return builder
	}

	builder.event.SetHref(href)
	return builder
}

func (builder *EventBuilder) Build() (*Event, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.event, nil
}

func (builder *EventBuilder) MustBuild() *Event {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build Event instance, reason: %v", builder.err))
	}
	return builder.event
}

type EventSubscriptionBuilder struct {
	eventSubscription *EventSubscription
	err               error
}

func NewEventSubscriptionBuilder() *EventSubscriptionBuilder {
	return &EventSubscriptionBuilder{eventSubscription: &EventSubscription{}, err: nil}
}

func (builder *EventSubscriptionBuilder) Address(attr string) *EventSubscriptionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.eventSubscription.SetAddress(attr)
	return builder
}

func (builder *EventSubscriptionBuilder) Comment(attr string) *EventSubscriptionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.eventSubscription.SetComment(attr)
	return builder
}

func (builder *EventSubscriptionBuilder) Description(attr string) *EventSubscriptionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.eventSubscription.SetDescription(attr)
	return builder
}

func (builder *EventSubscriptionBuilder) Event(attr NotifiableEvent) *EventSubscriptionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.eventSubscription.SetEvent(attr)
	return builder
}

func (builder *EventSubscriptionBuilder) Id(attr string) *EventSubscriptionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.eventSubscription.SetId(attr)
	return builder
}

func (builder *EventSubscriptionBuilder) Name(attr string) *EventSubscriptionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.eventSubscription.SetName(attr)
	return builder
}

func (builder *EventSubscriptionBuilder) NotificationMethod(attr NotificationMethod) *EventSubscriptionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.eventSubscription.SetNotificationMethod(attr)
	return builder
}

func (builder *EventSubscriptionBuilder) User(attr *User) *EventSubscriptionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.eventSubscription.SetUser(attr)
	return builder
}

func (builder *EventSubscriptionBuilder) UserBuilder(attrBuilder *UserBuilder) *EventSubscriptionBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.User(attr)
}

func (builder *EventSubscriptionBuilder) Href(href string) *EventSubscriptionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.eventSubscription.SetHref(href)
	return builder
}

func (builder *EventSubscriptionBuilder) Build() (*EventSubscription, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.eventSubscription, nil
}

func (builder *EventSubscriptionBuilder) MustBuild() *EventSubscription {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build EventSubscription instance, reason: %v", builder.err))
	}
	return builder.eventSubscription
}

type ExternalComputeResourceBuilder struct {
	externalComputeResource *ExternalComputeResource
	err                     error
}

func NewExternalComputeResourceBuilder() *ExternalComputeResourceBuilder {
	return &ExternalComputeResourceBuilder{externalComputeResource: &ExternalComputeResource{}, err: nil}
}

func (builder *ExternalComputeResourceBuilder) Comment(attr string) *ExternalComputeResourceBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalComputeResource.SetComment(attr)
	return builder
}

func (builder *ExternalComputeResourceBuilder) Description(attr string) *ExternalComputeResourceBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalComputeResource.SetDescription(attr)
	return builder
}

func (builder *ExternalComputeResourceBuilder) ExternalHostProvider(attr *ExternalHostProvider) *ExternalComputeResourceBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalComputeResource.SetExternalHostProvider(attr)
	return builder
}

func (builder *ExternalComputeResourceBuilder) ExternalHostProviderBuilder(attrBuilder *ExternalHostProviderBuilder) *ExternalComputeResourceBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.ExternalHostProvider(attr)
}

func (builder *ExternalComputeResourceBuilder) Id(attr string) *ExternalComputeResourceBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalComputeResource.SetId(attr)
	return builder
}

func (builder *ExternalComputeResourceBuilder) Name(attr string) *ExternalComputeResourceBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalComputeResource.SetName(attr)
	return builder
}

func (builder *ExternalComputeResourceBuilder) Provider(attr string) *ExternalComputeResourceBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalComputeResource.SetProvider(attr)
	return builder
}

func (builder *ExternalComputeResourceBuilder) Url(attr string) *ExternalComputeResourceBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalComputeResource.SetUrl(attr)
	return builder
}

func (builder *ExternalComputeResourceBuilder) User(attr string) *ExternalComputeResourceBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalComputeResource.SetUser(attr)
	return builder
}

func (builder *ExternalComputeResourceBuilder) Href(href string) *ExternalComputeResourceBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalComputeResource.SetHref(href)
	return builder
}

func (builder *ExternalComputeResourceBuilder) Build() (*ExternalComputeResource, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.externalComputeResource, nil
}

func (builder *ExternalComputeResourceBuilder) MustBuild() *ExternalComputeResource {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build ExternalComputeResource instance, reason: %v", builder.err))
	}
	return builder.externalComputeResource
}

type ExternalDiscoveredHostBuilder struct {
	externalDiscoveredHost *ExternalDiscoveredHost
	err                    error
}

func NewExternalDiscoveredHostBuilder() *ExternalDiscoveredHostBuilder {
	return &ExternalDiscoveredHostBuilder{externalDiscoveredHost: &ExternalDiscoveredHost{}, err: nil}
}

func (builder *ExternalDiscoveredHostBuilder) Comment(attr string) *ExternalDiscoveredHostBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalDiscoveredHost.SetComment(attr)
	return builder
}

func (builder *ExternalDiscoveredHostBuilder) Description(attr string) *ExternalDiscoveredHostBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalDiscoveredHost.SetDescription(attr)
	return builder
}

func (builder *ExternalDiscoveredHostBuilder) ExternalHostProvider(attr *ExternalHostProvider) *ExternalDiscoveredHostBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalDiscoveredHost.SetExternalHostProvider(attr)
	return builder
}

func (builder *ExternalDiscoveredHostBuilder) ExternalHostProviderBuilder(attrBuilder *ExternalHostProviderBuilder) *ExternalDiscoveredHostBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.ExternalHostProvider(attr)
}

func (builder *ExternalDiscoveredHostBuilder) Id(attr string) *ExternalDiscoveredHostBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalDiscoveredHost.SetId(attr)
	return builder
}

func (builder *ExternalDiscoveredHostBuilder) Ip(attr string) *ExternalDiscoveredHostBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalDiscoveredHost.SetIp(attr)
	return builder
}

func (builder *ExternalDiscoveredHostBuilder) LastReport(attr string) *ExternalDiscoveredHostBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalDiscoveredHost.SetLastReport(attr)
	return builder
}

func (builder *ExternalDiscoveredHostBuilder) Mac(attr string) *ExternalDiscoveredHostBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalDiscoveredHost.SetMac(attr)
	return builder
}

func (builder *ExternalDiscoveredHostBuilder) Name(attr string) *ExternalDiscoveredHostBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalDiscoveredHost.SetName(attr)
	return builder
}

func (builder *ExternalDiscoveredHostBuilder) SubnetName(attr string) *ExternalDiscoveredHostBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalDiscoveredHost.SetSubnetName(attr)
	return builder
}

func (builder *ExternalDiscoveredHostBuilder) Href(href string) *ExternalDiscoveredHostBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalDiscoveredHost.SetHref(href)
	return builder
}

func (builder *ExternalDiscoveredHostBuilder) Build() (*ExternalDiscoveredHost, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.externalDiscoveredHost, nil
}

func (builder *ExternalDiscoveredHostBuilder) MustBuild() *ExternalDiscoveredHost {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build ExternalDiscoveredHost instance, reason: %v", builder.err))
	}
	return builder.externalDiscoveredHost
}

type ExternalHostBuilder struct {
	externalHost *ExternalHost
	err          error
}

func NewExternalHostBuilder() *ExternalHostBuilder {
	return &ExternalHostBuilder{externalHost: &ExternalHost{}, err: nil}
}

func (builder *ExternalHostBuilder) Address(attr string) *ExternalHostBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalHost.SetAddress(attr)
	return builder
}

func (builder *ExternalHostBuilder) Comment(attr string) *ExternalHostBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalHost.SetComment(attr)
	return builder
}

func (builder *ExternalHostBuilder) Description(attr string) *ExternalHostBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalHost.SetDescription(attr)
	return builder
}

func (builder *ExternalHostBuilder) ExternalHostProvider(attr *ExternalHostProvider) *ExternalHostBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalHost.SetExternalHostProvider(attr)
	return builder
}

func (builder *ExternalHostBuilder) ExternalHostProviderBuilder(attrBuilder *ExternalHostProviderBuilder) *ExternalHostBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.ExternalHostProvider(attr)
}

func (builder *ExternalHostBuilder) Id(attr string) *ExternalHostBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalHost.SetId(attr)
	return builder
}

func (builder *ExternalHostBuilder) Name(attr string) *ExternalHostBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalHost.SetName(attr)
	return builder
}

func (builder *ExternalHostBuilder) Href(href string) *ExternalHostBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalHost.SetHref(href)
	return builder
}

func (builder *ExternalHostBuilder) Build() (*ExternalHost, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.externalHost, nil
}

func (builder *ExternalHostBuilder) MustBuild() *ExternalHost {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build ExternalHost instance, reason: %v", builder.err))
	}
	return builder.externalHost
}

type ExternalHostGroupBuilder struct {
	externalHostGroup *ExternalHostGroup
	err               error
}

func NewExternalHostGroupBuilder() *ExternalHostGroupBuilder {
	return &ExternalHostGroupBuilder{externalHostGroup: &ExternalHostGroup{}, err: nil}
}

func (builder *ExternalHostGroupBuilder) ArchitectureName(attr string) *ExternalHostGroupBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalHostGroup.SetArchitectureName(attr)
	return builder
}

func (builder *ExternalHostGroupBuilder) Comment(attr string) *ExternalHostGroupBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalHostGroup.SetComment(attr)
	return builder
}

func (builder *ExternalHostGroupBuilder) Description(attr string) *ExternalHostGroupBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalHostGroup.SetDescription(attr)
	return builder
}

func (builder *ExternalHostGroupBuilder) DomainName(attr string) *ExternalHostGroupBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalHostGroup.SetDomainName(attr)
	return builder
}

func (builder *ExternalHostGroupBuilder) ExternalHostProvider(attr *ExternalHostProvider) *ExternalHostGroupBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalHostGroup.SetExternalHostProvider(attr)
	return builder
}

func (builder *ExternalHostGroupBuilder) ExternalHostProviderBuilder(attrBuilder *ExternalHostProviderBuilder) *ExternalHostGroupBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.ExternalHostProvider(attr)
}

func (builder *ExternalHostGroupBuilder) Id(attr string) *ExternalHostGroupBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalHostGroup.SetId(attr)
	return builder
}

func (builder *ExternalHostGroupBuilder) Name(attr string) *ExternalHostGroupBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalHostGroup.SetName(attr)
	return builder
}

func (builder *ExternalHostGroupBuilder) OperatingSystemName(attr string) *ExternalHostGroupBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalHostGroup.SetOperatingSystemName(attr)
	return builder
}

func (builder *ExternalHostGroupBuilder) SubnetName(attr string) *ExternalHostGroupBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalHostGroup.SetSubnetName(attr)
	return builder
}

func (builder *ExternalHostGroupBuilder) Href(href string) *ExternalHostGroupBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalHostGroup.SetHref(href)
	return builder
}

func (builder *ExternalHostGroupBuilder) Build() (*ExternalHostGroup, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.externalHostGroup, nil
}

func (builder *ExternalHostGroupBuilder) MustBuild() *ExternalHostGroup {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build ExternalHostGroup instance, reason: %v", builder.err))
	}
	return builder.externalHostGroup
}

type ExternalHostProviderBuilder struct {
	externalHostProvider *ExternalHostProvider
	err                  error
}

func NewExternalHostProviderBuilder() *ExternalHostProviderBuilder {
	return &ExternalHostProviderBuilder{externalHostProvider: &ExternalHostProvider{}, err: nil}
}

func (builder *ExternalHostProviderBuilder) AuthenticationUrl(attr string) *ExternalHostProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalHostProvider.SetAuthenticationUrl(attr)
	return builder
}

func (builder *ExternalHostProviderBuilder) Certificates(attr *CertificateSlice) *ExternalHostProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalHostProvider.SetCertificates(attr)
	return builder
}

func (builder *ExternalHostProviderBuilder) CertificatesOfAny(anys ...*Certificate) *ExternalHostProviderBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.externalHostProvider.certificates == nil {
		builder.externalHostProvider.certificates = new(CertificateSlice)
	}
	builder.externalHostProvider.certificates.slice = append(builder.externalHostProvider.certificates.slice, anys...)
	return builder
}

func (builder *ExternalHostProviderBuilder) CertificatesBuilderOfAny(anyBuilders ...CertificateBuilder) *ExternalHostProviderBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.CertificatesOfAny(attr)
	}
	return builder
}

func (builder *ExternalHostProviderBuilder) Comment(attr string) *ExternalHostProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalHostProvider.SetComment(attr)
	return builder
}

func (builder *ExternalHostProviderBuilder) ComputeResources(attr *ExternalComputeResourceSlice) *ExternalHostProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalHostProvider.SetComputeResources(attr)
	return builder
}

func (builder *ExternalHostProviderBuilder) ComputeResourcesOfAny(anys ...*ExternalComputeResource) *ExternalHostProviderBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.externalHostProvider.computeResources == nil {
		builder.externalHostProvider.computeResources = new(ExternalComputeResourceSlice)
	}
	builder.externalHostProvider.computeResources.slice = append(builder.externalHostProvider.computeResources.slice, anys...)
	return builder
}

func (builder *ExternalHostProviderBuilder) ComputeResourcesBuilderOfAny(anyBuilders ...ExternalComputeResourceBuilder) *ExternalHostProviderBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.ComputeResourcesOfAny(attr)
	}
	return builder
}

func (builder *ExternalHostProviderBuilder) Description(attr string) *ExternalHostProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalHostProvider.SetDescription(attr)
	return builder
}

func (builder *ExternalHostProviderBuilder) DiscoveredHosts(attr *ExternalDiscoveredHostSlice) *ExternalHostProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalHostProvider.SetDiscoveredHosts(attr)
	return builder
}

func (builder *ExternalHostProviderBuilder) DiscoveredHostsOfAny(anys ...*ExternalDiscoveredHost) *ExternalHostProviderBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.externalHostProvider.discoveredHosts == nil {
		builder.externalHostProvider.discoveredHosts = new(ExternalDiscoveredHostSlice)
	}
	builder.externalHostProvider.discoveredHosts.slice = append(builder.externalHostProvider.discoveredHosts.slice, anys...)
	return builder
}

func (builder *ExternalHostProviderBuilder) DiscoveredHostsBuilderOfAny(anyBuilders ...ExternalDiscoveredHostBuilder) *ExternalHostProviderBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.DiscoveredHostsOfAny(attr)
	}
	return builder
}

func (builder *ExternalHostProviderBuilder) HostGroups(attr *ExternalHostGroupSlice) *ExternalHostProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalHostProvider.SetHostGroups(attr)
	return builder
}

func (builder *ExternalHostProviderBuilder) HostGroupsOfAny(anys ...*ExternalHostGroup) *ExternalHostProviderBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.externalHostProvider.hostGroups == nil {
		builder.externalHostProvider.hostGroups = new(ExternalHostGroupSlice)
	}
	builder.externalHostProvider.hostGroups.slice = append(builder.externalHostProvider.hostGroups.slice, anys...)
	return builder
}

func (builder *ExternalHostProviderBuilder) HostGroupsBuilderOfAny(anyBuilders ...ExternalHostGroupBuilder) *ExternalHostProviderBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.HostGroupsOfAny(attr)
	}
	return builder
}

func (builder *ExternalHostProviderBuilder) Hosts(attr *HostSlice) *ExternalHostProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalHostProvider.SetHosts(attr)
	return builder
}

func (builder *ExternalHostProviderBuilder) HostsOfAny(anys ...*Host) *ExternalHostProviderBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.externalHostProvider.hosts == nil {
		builder.externalHostProvider.hosts = new(HostSlice)
	}
	builder.externalHostProvider.hosts.slice = append(builder.externalHostProvider.hosts.slice, anys...)
	return builder
}

func (builder *ExternalHostProviderBuilder) HostsBuilderOfAny(anyBuilders ...HostBuilder) *ExternalHostProviderBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.HostsOfAny(attr)
	}
	return builder
}

func (builder *ExternalHostProviderBuilder) Id(attr string) *ExternalHostProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalHostProvider.SetId(attr)
	return builder
}

func (builder *ExternalHostProviderBuilder) Name(attr string) *ExternalHostProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalHostProvider.SetName(attr)
	return builder
}

func (builder *ExternalHostProviderBuilder) Password(attr string) *ExternalHostProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalHostProvider.SetPassword(attr)
	return builder
}

func (builder *ExternalHostProviderBuilder) Properties(attr *PropertySlice) *ExternalHostProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalHostProvider.SetProperties(attr)
	return builder
}

func (builder *ExternalHostProviderBuilder) PropertiesOfAny(anys ...*Property) *ExternalHostProviderBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.externalHostProvider.properties == nil {
		builder.externalHostProvider.properties = new(PropertySlice)
	}
	builder.externalHostProvider.properties.slice = append(builder.externalHostProvider.properties.slice, anys...)
	return builder
}

func (builder *ExternalHostProviderBuilder) PropertiesBuilderOfAny(anyBuilders ...PropertyBuilder) *ExternalHostProviderBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.PropertiesOfAny(attr)
	}
	return builder
}

func (builder *ExternalHostProviderBuilder) RequiresAuthentication(attr bool) *ExternalHostProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalHostProvider.SetRequiresAuthentication(attr)
	return builder
}

func (builder *ExternalHostProviderBuilder) Url(attr string) *ExternalHostProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalHostProvider.SetUrl(attr)
	return builder
}

func (builder *ExternalHostProviderBuilder) Username(attr string) *ExternalHostProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalHostProvider.SetUsername(attr)
	return builder
}

func (builder *ExternalHostProviderBuilder) Href(href string) *ExternalHostProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalHostProvider.SetHref(href)
	return builder
}

func (builder *ExternalHostProviderBuilder) Build() (*ExternalHostProvider, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.externalHostProvider, nil
}

func (builder *ExternalHostProviderBuilder) MustBuild() *ExternalHostProvider {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build ExternalHostProvider instance, reason: %v", builder.err))
	}
	return builder.externalHostProvider
}

type ExternalNetworkProviderConfigurationBuilder struct {
	externalNetworkProviderConfiguration *ExternalNetworkProviderConfiguration
	err                                  error
}

func NewExternalNetworkProviderConfigurationBuilder() *ExternalNetworkProviderConfigurationBuilder {
	return &ExternalNetworkProviderConfigurationBuilder{externalNetworkProviderConfiguration: &ExternalNetworkProviderConfiguration{}, err: nil}
}

func (builder *ExternalNetworkProviderConfigurationBuilder) Comment(attr string) *ExternalNetworkProviderConfigurationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalNetworkProviderConfiguration.SetComment(attr)
	return builder
}

func (builder *ExternalNetworkProviderConfigurationBuilder) Description(attr string) *ExternalNetworkProviderConfigurationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalNetworkProviderConfiguration.SetDescription(attr)
	return builder
}

func (builder *ExternalNetworkProviderConfigurationBuilder) ExternalNetworkProvider(attr *ExternalProvider) *ExternalNetworkProviderConfigurationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalNetworkProviderConfiguration.SetExternalNetworkProvider(attr)
	return builder
}

func (builder *ExternalNetworkProviderConfigurationBuilder) ExternalNetworkProviderBuilder(attrBuilder *ExternalProviderBuilder) *ExternalNetworkProviderConfigurationBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.ExternalNetworkProvider(attr)
}

func (builder *ExternalNetworkProviderConfigurationBuilder) Host(attr *Host) *ExternalNetworkProviderConfigurationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalNetworkProviderConfiguration.SetHost(attr)
	return builder
}

func (builder *ExternalNetworkProviderConfigurationBuilder) HostBuilder(attrBuilder *HostBuilder) *ExternalNetworkProviderConfigurationBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Host(attr)
}

func (builder *ExternalNetworkProviderConfigurationBuilder) Id(attr string) *ExternalNetworkProviderConfigurationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalNetworkProviderConfiguration.SetId(attr)
	return builder
}

func (builder *ExternalNetworkProviderConfigurationBuilder) Name(attr string) *ExternalNetworkProviderConfigurationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalNetworkProviderConfiguration.SetName(attr)
	return builder
}

func (builder *ExternalNetworkProviderConfigurationBuilder) Href(href string) *ExternalNetworkProviderConfigurationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalNetworkProviderConfiguration.SetHref(href)
	return builder
}

func (builder *ExternalNetworkProviderConfigurationBuilder) Build() (*ExternalNetworkProviderConfiguration, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.externalNetworkProviderConfiguration, nil
}

func (builder *ExternalNetworkProviderConfigurationBuilder) MustBuild() *ExternalNetworkProviderConfiguration {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build ExternalNetworkProviderConfiguration instance, reason: %v", builder.err))
	}
	return builder.externalNetworkProviderConfiguration
}

type ExternalProviderBuilder struct {
	externalProvider *ExternalProvider
	err              error
}

func NewExternalProviderBuilder() *ExternalProviderBuilder {
	return &ExternalProviderBuilder{externalProvider: &ExternalProvider{}, err: nil}
}

func (builder *ExternalProviderBuilder) AuthenticationUrl(attr string) *ExternalProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalProvider.SetAuthenticationUrl(attr)
	return builder
}

func (builder *ExternalProviderBuilder) Comment(attr string) *ExternalProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalProvider.SetComment(attr)
	return builder
}

func (builder *ExternalProviderBuilder) Description(attr string) *ExternalProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalProvider.SetDescription(attr)
	return builder
}

func (builder *ExternalProviderBuilder) Id(attr string) *ExternalProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalProvider.SetId(attr)
	return builder
}

func (builder *ExternalProviderBuilder) Name(attr string) *ExternalProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalProvider.SetName(attr)
	return builder
}

func (builder *ExternalProviderBuilder) Password(attr string) *ExternalProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalProvider.SetPassword(attr)
	return builder
}

func (builder *ExternalProviderBuilder) Properties(attr *PropertySlice) *ExternalProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalProvider.SetProperties(attr)
	return builder
}

func (builder *ExternalProviderBuilder) PropertiesOfAny(anys ...*Property) *ExternalProviderBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.externalProvider.properties == nil {
		builder.externalProvider.properties = new(PropertySlice)
	}
	builder.externalProvider.properties.slice = append(builder.externalProvider.properties.slice, anys...)
	return builder
}

func (builder *ExternalProviderBuilder) PropertiesBuilderOfAny(anyBuilders ...PropertyBuilder) *ExternalProviderBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.PropertiesOfAny(attr)
	}
	return builder
}

func (builder *ExternalProviderBuilder) RequiresAuthentication(attr bool) *ExternalProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalProvider.SetRequiresAuthentication(attr)
	return builder
}

func (builder *ExternalProviderBuilder) Url(attr string) *ExternalProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalProvider.SetUrl(attr)
	return builder
}

func (builder *ExternalProviderBuilder) Username(attr string) *ExternalProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalProvider.SetUsername(attr)
	return builder
}

func (builder *ExternalProviderBuilder) Href(href string) *ExternalProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalProvider.SetHref(href)
	return builder
}

func (builder *ExternalProviderBuilder) Build() (*ExternalProvider, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.externalProvider, nil
}

func (builder *ExternalProviderBuilder) MustBuild() *ExternalProvider {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build ExternalProvider instance, reason: %v", builder.err))
	}
	return builder.externalProvider
}

type ExternalTemplateImportBuilder struct {
	externalTemplateImport *ExternalTemplateImport
	err                    error
}

func NewExternalTemplateImportBuilder() *ExternalTemplateImportBuilder {
	return &ExternalTemplateImportBuilder{externalTemplateImport: &ExternalTemplateImport{}, err: nil}
}

func (builder *ExternalTemplateImportBuilder) Cluster(attr *Cluster) *ExternalTemplateImportBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalTemplateImport.SetCluster(attr)
	return builder
}

func (builder *ExternalTemplateImportBuilder) ClusterBuilder(attrBuilder *ClusterBuilder) *ExternalTemplateImportBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Cluster(attr)
}

func (builder *ExternalTemplateImportBuilder) CpuProfile(attr *CpuProfile) *ExternalTemplateImportBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalTemplateImport.SetCpuProfile(attr)
	return builder
}

func (builder *ExternalTemplateImportBuilder) CpuProfileBuilder(attrBuilder *CpuProfileBuilder) *ExternalTemplateImportBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.CpuProfile(attr)
}

func (builder *ExternalTemplateImportBuilder) Host(attr *Host) *ExternalTemplateImportBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalTemplateImport.SetHost(attr)
	return builder
}

func (builder *ExternalTemplateImportBuilder) HostBuilder(attrBuilder *HostBuilder) *ExternalTemplateImportBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Host(attr)
}

func (builder *ExternalTemplateImportBuilder) Quota(attr *Quota) *ExternalTemplateImportBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalTemplateImport.SetQuota(attr)
	return builder
}

func (builder *ExternalTemplateImportBuilder) QuotaBuilder(attrBuilder *QuotaBuilder) *ExternalTemplateImportBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Quota(attr)
}

func (builder *ExternalTemplateImportBuilder) StorageDomain(attr *StorageDomain) *ExternalTemplateImportBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalTemplateImport.SetStorageDomain(attr)
	return builder
}

func (builder *ExternalTemplateImportBuilder) StorageDomainBuilder(attrBuilder *StorageDomainBuilder) *ExternalTemplateImportBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.StorageDomain(attr)
}

func (builder *ExternalTemplateImportBuilder) Template(attr *Template) *ExternalTemplateImportBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalTemplateImport.SetTemplate(attr)
	return builder
}

func (builder *ExternalTemplateImportBuilder) TemplateBuilder(attrBuilder *TemplateBuilder) *ExternalTemplateImportBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Template(attr)
}

func (builder *ExternalTemplateImportBuilder) Url(attr string) *ExternalTemplateImportBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalTemplateImport.SetUrl(attr)
	return builder
}

func (builder *ExternalTemplateImportBuilder) Href(href string) *ExternalTemplateImportBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalTemplateImport.SetHref(href)
	return builder
}

func (builder *ExternalTemplateImportBuilder) Build() (*ExternalTemplateImport, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.externalTemplateImport, nil
}

func (builder *ExternalTemplateImportBuilder) MustBuild() *ExternalTemplateImport {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build ExternalTemplateImport instance, reason: %v", builder.err))
	}
	return builder.externalTemplateImport
}

type ExternalVmImportBuilder struct {
	externalVmImport *ExternalVmImport
	err              error
}

func NewExternalVmImportBuilder() *ExternalVmImportBuilder {
	return &ExternalVmImportBuilder{externalVmImport: &ExternalVmImport{}, err: nil}
}

func (builder *ExternalVmImportBuilder) Cluster(attr *Cluster) *ExternalVmImportBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalVmImport.SetCluster(attr)
	return builder
}

func (builder *ExternalVmImportBuilder) ClusterBuilder(attrBuilder *ClusterBuilder) *ExternalVmImportBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Cluster(attr)
}

func (builder *ExternalVmImportBuilder) CpuProfile(attr *CpuProfile) *ExternalVmImportBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalVmImport.SetCpuProfile(attr)
	return builder
}

func (builder *ExternalVmImportBuilder) CpuProfileBuilder(attrBuilder *CpuProfileBuilder) *ExternalVmImportBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.CpuProfile(attr)
}

func (builder *ExternalVmImportBuilder) DriversIso(attr *File) *ExternalVmImportBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalVmImport.SetDriversIso(attr)
	return builder
}

func (builder *ExternalVmImportBuilder) DriversIsoBuilder(attrBuilder *FileBuilder) *ExternalVmImportBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.DriversIso(attr)
}

func (builder *ExternalVmImportBuilder) Host(attr *Host) *ExternalVmImportBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalVmImport.SetHost(attr)
	return builder
}

func (builder *ExternalVmImportBuilder) HostBuilder(attrBuilder *HostBuilder) *ExternalVmImportBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Host(attr)
}

func (builder *ExternalVmImportBuilder) Name(attr string) *ExternalVmImportBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalVmImport.SetName(attr)
	return builder
}

func (builder *ExternalVmImportBuilder) Password(attr string) *ExternalVmImportBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalVmImport.SetPassword(attr)
	return builder
}

func (builder *ExternalVmImportBuilder) Provider(attr ExternalVmProviderType) *ExternalVmImportBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalVmImport.SetProvider(attr)
	return builder
}

func (builder *ExternalVmImportBuilder) Quota(attr *Quota) *ExternalVmImportBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalVmImport.SetQuota(attr)
	return builder
}

func (builder *ExternalVmImportBuilder) QuotaBuilder(attrBuilder *QuotaBuilder) *ExternalVmImportBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Quota(attr)
}

func (builder *ExternalVmImportBuilder) Sparse(attr bool) *ExternalVmImportBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalVmImport.SetSparse(attr)
	return builder
}

func (builder *ExternalVmImportBuilder) StorageDomain(attr *StorageDomain) *ExternalVmImportBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalVmImport.SetStorageDomain(attr)
	return builder
}

func (builder *ExternalVmImportBuilder) StorageDomainBuilder(attrBuilder *StorageDomainBuilder) *ExternalVmImportBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.StorageDomain(attr)
}

func (builder *ExternalVmImportBuilder) Url(attr string) *ExternalVmImportBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalVmImport.SetUrl(attr)
	return builder
}

func (builder *ExternalVmImportBuilder) Username(attr string) *ExternalVmImportBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalVmImport.SetUsername(attr)
	return builder
}

func (builder *ExternalVmImportBuilder) Vm(attr *Vm) *ExternalVmImportBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalVmImport.SetVm(attr)
	return builder
}

func (builder *ExternalVmImportBuilder) VmBuilder(attrBuilder *VmBuilder) *ExternalVmImportBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Vm(attr)
}

func (builder *ExternalVmImportBuilder) Href(href string) *ExternalVmImportBuilder {
	if builder.err != nil {
		return builder
	}

	builder.externalVmImport.SetHref(href)
	return builder
}

func (builder *ExternalVmImportBuilder) Build() (*ExternalVmImport, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.externalVmImport, nil
}

func (builder *ExternalVmImportBuilder) MustBuild() *ExternalVmImport {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build ExternalVmImport instance, reason: %v", builder.err))
	}
	return builder.externalVmImport
}

type FencingPolicyBuilder struct {
	fencingPolicy *FencingPolicy
	err           error
}

func NewFencingPolicyBuilder() *FencingPolicyBuilder {
	return &FencingPolicyBuilder{fencingPolicy: &FencingPolicy{}, err: nil}
}

func (builder *FencingPolicyBuilder) Enabled(attr bool) *FencingPolicyBuilder {
	if builder.err != nil {
		return builder
	}

	builder.fencingPolicy.SetEnabled(attr)
	return builder
}

func (builder *FencingPolicyBuilder) SkipIfConnectivityBroken(attr *SkipIfConnectivityBroken) *FencingPolicyBuilder {
	if builder.err != nil {
		return builder
	}

	builder.fencingPolicy.SetSkipIfConnectivityBroken(attr)
	return builder
}

func (builder *FencingPolicyBuilder) SkipIfConnectivityBrokenBuilder(attrBuilder *SkipIfConnectivityBrokenBuilder) *FencingPolicyBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.SkipIfConnectivityBroken(attr)
}

func (builder *FencingPolicyBuilder) SkipIfGlusterBricksUp(attr bool) *FencingPolicyBuilder {
	if builder.err != nil {
		return builder
	}

	builder.fencingPolicy.SetSkipIfGlusterBricksUp(attr)
	return builder
}

func (builder *FencingPolicyBuilder) SkipIfGlusterQuorumNotMet(attr bool) *FencingPolicyBuilder {
	if builder.err != nil {
		return builder
	}

	builder.fencingPolicy.SetSkipIfGlusterQuorumNotMet(attr)
	return builder
}

func (builder *FencingPolicyBuilder) SkipIfSdActive(attr *SkipIfSdActive) *FencingPolicyBuilder {
	if builder.err != nil {
		return builder
	}

	builder.fencingPolicy.SetSkipIfSdActive(attr)
	return builder
}

func (builder *FencingPolicyBuilder) SkipIfSdActiveBuilder(attrBuilder *SkipIfSdActiveBuilder) *FencingPolicyBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.SkipIfSdActive(attr)
}

func (builder *FencingPolicyBuilder) Href(href string) *FencingPolicyBuilder {
	if builder.err != nil {
		return builder
	}

	builder.fencingPolicy.SetHref(href)
	return builder
}

func (builder *FencingPolicyBuilder) Build() (*FencingPolicy, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.fencingPolicy, nil
}

func (builder *FencingPolicyBuilder) MustBuild() *FencingPolicy {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build FencingPolicy instance, reason: %v", builder.err))
	}
	return builder.fencingPolicy
}

type FileBuilder struct {
	file *File
	err  error
}

func NewFileBuilder() *FileBuilder {
	return &FileBuilder{file: &File{}, err: nil}
}

func (builder *FileBuilder) Comment(attr string) *FileBuilder {
	if builder.err != nil {
		return builder
	}

	builder.file.SetComment(attr)
	return builder
}

func (builder *FileBuilder) Content(attr string) *FileBuilder {
	if builder.err != nil {
		return builder
	}

	builder.file.SetContent(attr)
	return builder
}

func (builder *FileBuilder) Description(attr string) *FileBuilder {
	if builder.err != nil {
		return builder
	}

	builder.file.SetDescription(attr)
	return builder
}

func (builder *FileBuilder) Id(attr string) *FileBuilder {
	if builder.err != nil {
		return builder
	}

	builder.file.SetId(attr)
	return builder
}

func (builder *FileBuilder) Name(attr string) *FileBuilder {
	if builder.err != nil {
		return builder
	}

	builder.file.SetName(attr)
	return builder
}

func (builder *FileBuilder) StorageDomain(attr *StorageDomain) *FileBuilder {
	if builder.err != nil {
		return builder
	}

	builder.file.SetStorageDomain(attr)
	return builder
}

func (builder *FileBuilder) StorageDomainBuilder(attrBuilder *StorageDomainBuilder) *FileBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.StorageDomain(attr)
}

func (builder *FileBuilder) Type(attr string) *FileBuilder {
	if builder.err != nil {
		return builder
	}

	builder.file.SetType(attr)
	return builder
}

func (builder *FileBuilder) Href(href string) *FileBuilder {
	if builder.err != nil {
		return builder
	}

	builder.file.SetHref(href)
	return builder
}

func (builder *FileBuilder) Build() (*File, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.file, nil
}

func (builder *FileBuilder) MustBuild() *File {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build File instance, reason: %v", builder.err))
	}
	return builder.file
}

type FilterBuilder struct {
	filter *Filter
	err    error
}

func NewFilterBuilder() *FilterBuilder {
	return &FilterBuilder{filter: &Filter{}, err: nil}
}

func (builder *FilterBuilder) Comment(attr string) *FilterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.filter.SetComment(attr)
	return builder
}

func (builder *FilterBuilder) Description(attr string) *FilterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.filter.SetDescription(attr)
	return builder
}

func (builder *FilterBuilder) Id(attr string) *FilterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.filter.SetId(attr)
	return builder
}

func (builder *FilterBuilder) Name(attr string) *FilterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.filter.SetName(attr)
	return builder
}

func (builder *FilterBuilder) Position(attr int64) *FilterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.filter.SetPosition(attr)
	return builder
}

func (builder *FilterBuilder) SchedulingPolicyUnit(attr *SchedulingPolicyUnit) *FilterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.filter.SetSchedulingPolicyUnit(attr)
	return builder
}

func (builder *FilterBuilder) SchedulingPolicyUnitBuilder(attrBuilder *SchedulingPolicyUnitBuilder) *FilterBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.SchedulingPolicyUnit(attr)
}

func (builder *FilterBuilder) Href(href string) *FilterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.filter.SetHref(href)
	return builder
}

func (builder *FilterBuilder) Build() (*Filter, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.filter, nil
}

func (builder *FilterBuilder) MustBuild() *Filter {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build Filter instance, reason: %v", builder.err))
	}
	return builder.filter
}

type FloppyBuilder struct {
	floppy *Floppy
	err    error
}

func NewFloppyBuilder() *FloppyBuilder {
	return &FloppyBuilder{floppy: &Floppy{}, err: nil}
}

func (builder *FloppyBuilder) Comment(attr string) *FloppyBuilder {
	if builder.err != nil {
		return builder
	}

	builder.floppy.SetComment(attr)
	return builder
}

func (builder *FloppyBuilder) Description(attr string) *FloppyBuilder {
	if builder.err != nil {
		return builder
	}

	builder.floppy.SetDescription(attr)
	return builder
}

func (builder *FloppyBuilder) File(attr *File) *FloppyBuilder {
	if builder.err != nil {
		return builder
	}

	builder.floppy.SetFile(attr)
	return builder
}

func (builder *FloppyBuilder) FileBuilder(attrBuilder *FileBuilder) *FloppyBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.File(attr)
}

func (builder *FloppyBuilder) Id(attr string) *FloppyBuilder {
	if builder.err != nil {
		return builder
	}

	builder.floppy.SetId(attr)
	return builder
}

func (builder *FloppyBuilder) InstanceType(attr *InstanceType) *FloppyBuilder {
	if builder.err != nil {
		return builder
	}

	builder.floppy.SetInstanceType(attr)
	return builder
}

func (builder *FloppyBuilder) InstanceTypeBuilder(attrBuilder *InstanceTypeBuilder) *FloppyBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.InstanceType(attr)
}

func (builder *FloppyBuilder) Name(attr string) *FloppyBuilder {
	if builder.err != nil {
		return builder
	}

	builder.floppy.SetName(attr)
	return builder
}

func (builder *FloppyBuilder) Template(attr *Template) *FloppyBuilder {
	if builder.err != nil {
		return builder
	}

	builder.floppy.SetTemplate(attr)
	return builder
}

func (builder *FloppyBuilder) TemplateBuilder(attrBuilder *TemplateBuilder) *FloppyBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Template(attr)
}

func (builder *FloppyBuilder) Vm(attr *Vm) *FloppyBuilder {
	if builder.err != nil {
		return builder
	}

	builder.floppy.SetVm(attr)
	return builder
}

func (builder *FloppyBuilder) VmBuilder(attrBuilder *VmBuilder) *FloppyBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Vm(attr)
}

func (builder *FloppyBuilder) Vms(attr *VmSlice) *FloppyBuilder {
	if builder.err != nil {
		return builder
	}

	builder.floppy.SetVms(attr)
	return builder
}

func (builder *FloppyBuilder) VmsOfAny(anys ...*Vm) *FloppyBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.floppy.vms == nil {
		builder.floppy.vms = new(VmSlice)
	}
	builder.floppy.vms.slice = append(builder.floppy.vms.slice, anys...)
	return builder
}

func (builder *FloppyBuilder) VmsBuilderOfAny(anyBuilders ...VmBuilder) *FloppyBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.VmsOfAny(attr)
	}
	return builder
}

func (builder *FloppyBuilder) Href(href string) *FloppyBuilder {
	if builder.err != nil {
		return builder
	}

	builder.floppy.SetHref(href)
	return builder
}

func (builder *FloppyBuilder) Build() (*Floppy, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.floppy, nil
}

func (builder *FloppyBuilder) MustBuild() *Floppy {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build Floppy instance, reason: %v", builder.err))
	}
	return builder.floppy
}

type FopStatisticBuilder struct {
	fopStatistic *FopStatistic
	err          error
}

func NewFopStatisticBuilder() *FopStatisticBuilder {
	return &FopStatisticBuilder{fopStatistic: &FopStatistic{}, err: nil}
}

func (builder *FopStatisticBuilder) Name(attr string) *FopStatisticBuilder {
	if builder.err != nil {
		return builder
	}

	builder.fopStatistic.SetName(attr)
	return builder
}

func (builder *FopStatisticBuilder) Statistics(attr *StatisticSlice) *FopStatisticBuilder {
	if builder.err != nil {
		return builder
	}

	builder.fopStatistic.SetStatistics(attr)
	return builder
}

func (builder *FopStatisticBuilder) StatisticsOfAny(anys ...*Statistic) *FopStatisticBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.fopStatistic.statistics == nil {
		builder.fopStatistic.statistics = new(StatisticSlice)
	}
	builder.fopStatistic.statistics.slice = append(builder.fopStatistic.statistics.slice, anys...)
	return builder
}

func (builder *FopStatisticBuilder) StatisticsBuilderOfAny(anyBuilders ...StatisticBuilder) *FopStatisticBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.StatisticsOfAny(attr)
	}
	return builder
}

func (builder *FopStatisticBuilder) Href(href string) *FopStatisticBuilder {
	if builder.err != nil {
		return builder
	}

	builder.fopStatistic.SetHref(href)
	return builder
}

func (builder *FopStatisticBuilder) Build() (*FopStatistic, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.fopStatistic, nil
}

func (builder *FopStatisticBuilder) MustBuild() *FopStatistic {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build FopStatistic instance, reason: %v", builder.err))
	}
	return builder.fopStatistic
}

type GlusterBrickBuilder struct {
	glusterBrick *GlusterBrick
	err          error
}

func NewGlusterBrickBuilder() *GlusterBrickBuilder {
	return &GlusterBrickBuilder{glusterBrick: &GlusterBrick{}, err: nil}
}

func (builder *GlusterBrickBuilder) BrickDir(attr string) *GlusterBrickBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterBrick.SetBrickDir(attr)
	return builder
}

func (builder *GlusterBrickBuilder) Comment(attr string) *GlusterBrickBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterBrick.SetComment(attr)
	return builder
}

func (builder *GlusterBrickBuilder) Description(attr string) *GlusterBrickBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterBrick.SetDescription(attr)
	return builder
}

func (builder *GlusterBrickBuilder) Device(attr string) *GlusterBrickBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterBrick.SetDevice(attr)
	return builder
}

func (builder *GlusterBrickBuilder) FsName(attr string) *GlusterBrickBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterBrick.SetFsName(attr)
	return builder
}

func (builder *GlusterBrickBuilder) GlusterClients(attr *GlusterClientSlice) *GlusterBrickBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterBrick.SetGlusterClients(attr)
	return builder
}

func (builder *GlusterBrickBuilder) GlusterClientsOfAny(anys ...*GlusterClient) *GlusterBrickBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.glusterBrick.glusterClients == nil {
		builder.glusterBrick.glusterClients = new(GlusterClientSlice)
	}
	builder.glusterBrick.glusterClients.slice = append(builder.glusterBrick.glusterClients.slice, anys...)
	return builder
}

func (builder *GlusterBrickBuilder) GlusterClientsBuilderOfAny(anyBuilders ...GlusterClientBuilder) *GlusterBrickBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.GlusterClientsOfAny(attr)
	}
	return builder
}

func (builder *GlusterBrickBuilder) GlusterVolume(attr *GlusterVolume) *GlusterBrickBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterBrick.SetGlusterVolume(attr)
	return builder
}

func (builder *GlusterBrickBuilder) GlusterVolumeBuilder(attrBuilder *GlusterVolumeBuilder) *GlusterBrickBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.GlusterVolume(attr)
}

func (builder *GlusterBrickBuilder) Id(attr string) *GlusterBrickBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterBrick.SetId(attr)
	return builder
}

func (builder *GlusterBrickBuilder) InstanceType(attr *InstanceType) *GlusterBrickBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterBrick.SetInstanceType(attr)
	return builder
}

func (builder *GlusterBrickBuilder) InstanceTypeBuilder(attrBuilder *InstanceTypeBuilder) *GlusterBrickBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.InstanceType(attr)
}

func (builder *GlusterBrickBuilder) MemoryPools(attr *GlusterMemoryPoolSlice) *GlusterBrickBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterBrick.SetMemoryPools(attr)
	return builder
}

func (builder *GlusterBrickBuilder) MemoryPoolsOfAny(anys ...*GlusterMemoryPool) *GlusterBrickBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.glusterBrick.memoryPools == nil {
		builder.glusterBrick.memoryPools = new(GlusterMemoryPoolSlice)
	}
	builder.glusterBrick.memoryPools.slice = append(builder.glusterBrick.memoryPools.slice, anys...)
	return builder
}

func (builder *GlusterBrickBuilder) MemoryPoolsBuilderOfAny(anyBuilders ...GlusterMemoryPoolBuilder) *GlusterBrickBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.MemoryPoolsOfAny(attr)
	}
	return builder
}

func (builder *GlusterBrickBuilder) MntOptions(attr string) *GlusterBrickBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterBrick.SetMntOptions(attr)
	return builder
}

func (builder *GlusterBrickBuilder) Name(attr string) *GlusterBrickBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterBrick.SetName(attr)
	return builder
}

func (builder *GlusterBrickBuilder) Pid(attr int64) *GlusterBrickBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterBrick.SetPid(attr)
	return builder
}

func (builder *GlusterBrickBuilder) Port(attr int64) *GlusterBrickBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterBrick.SetPort(attr)
	return builder
}

func (builder *GlusterBrickBuilder) ServerId(attr string) *GlusterBrickBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterBrick.SetServerId(attr)
	return builder
}

func (builder *GlusterBrickBuilder) Statistics(attr *StatisticSlice) *GlusterBrickBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterBrick.SetStatistics(attr)
	return builder
}

func (builder *GlusterBrickBuilder) StatisticsOfAny(anys ...*Statistic) *GlusterBrickBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.glusterBrick.statistics == nil {
		builder.glusterBrick.statistics = new(StatisticSlice)
	}
	builder.glusterBrick.statistics.slice = append(builder.glusterBrick.statistics.slice, anys...)
	return builder
}

func (builder *GlusterBrickBuilder) StatisticsBuilderOfAny(anyBuilders ...StatisticBuilder) *GlusterBrickBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.StatisticsOfAny(attr)
	}
	return builder
}

func (builder *GlusterBrickBuilder) Status(attr GlusterBrickStatus) *GlusterBrickBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterBrick.SetStatus(attr)
	return builder
}

func (builder *GlusterBrickBuilder) Template(attr *Template) *GlusterBrickBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterBrick.SetTemplate(attr)
	return builder
}

func (builder *GlusterBrickBuilder) TemplateBuilder(attrBuilder *TemplateBuilder) *GlusterBrickBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Template(attr)
}

func (builder *GlusterBrickBuilder) Vm(attr *Vm) *GlusterBrickBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterBrick.SetVm(attr)
	return builder
}

func (builder *GlusterBrickBuilder) VmBuilder(attrBuilder *VmBuilder) *GlusterBrickBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Vm(attr)
}

func (builder *GlusterBrickBuilder) Vms(attr *VmSlice) *GlusterBrickBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterBrick.SetVms(attr)
	return builder
}

func (builder *GlusterBrickBuilder) VmsOfAny(anys ...*Vm) *GlusterBrickBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.glusterBrick.vms == nil {
		builder.glusterBrick.vms = new(VmSlice)
	}
	builder.glusterBrick.vms.slice = append(builder.glusterBrick.vms.slice, anys...)
	return builder
}

func (builder *GlusterBrickBuilder) VmsBuilderOfAny(anyBuilders ...VmBuilder) *GlusterBrickBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.VmsOfAny(attr)
	}
	return builder
}

func (builder *GlusterBrickBuilder) Href(href string) *GlusterBrickBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterBrick.SetHref(href)
	return builder
}

func (builder *GlusterBrickBuilder) Build() (*GlusterBrick, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.glusterBrick, nil
}

func (builder *GlusterBrickBuilder) MustBuild() *GlusterBrick {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build GlusterBrick instance, reason: %v", builder.err))
	}
	return builder.glusterBrick
}

type GlusterBrickAdvancedDetailsBuilder struct {
	glusterBrickAdvancedDetails *GlusterBrickAdvancedDetails
	err                         error
}

func NewGlusterBrickAdvancedDetailsBuilder() *GlusterBrickAdvancedDetailsBuilder {
	return &GlusterBrickAdvancedDetailsBuilder{glusterBrickAdvancedDetails: &GlusterBrickAdvancedDetails{}, err: nil}
}

func (builder *GlusterBrickAdvancedDetailsBuilder) Comment(attr string) *GlusterBrickAdvancedDetailsBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterBrickAdvancedDetails.SetComment(attr)
	return builder
}

func (builder *GlusterBrickAdvancedDetailsBuilder) Description(attr string) *GlusterBrickAdvancedDetailsBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterBrickAdvancedDetails.SetDescription(attr)
	return builder
}

func (builder *GlusterBrickAdvancedDetailsBuilder) Device(attr string) *GlusterBrickAdvancedDetailsBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterBrickAdvancedDetails.SetDevice(attr)
	return builder
}

func (builder *GlusterBrickAdvancedDetailsBuilder) FsName(attr string) *GlusterBrickAdvancedDetailsBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterBrickAdvancedDetails.SetFsName(attr)
	return builder
}

func (builder *GlusterBrickAdvancedDetailsBuilder) GlusterClients(attr *GlusterClientSlice) *GlusterBrickAdvancedDetailsBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterBrickAdvancedDetails.SetGlusterClients(attr)
	return builder
}

func (builder *GlusterBrickAdvancedDetailsBuilder) GlusterClientsOfAny(anys ...*GlusterClient) *GlusterBrickAdvancedDetailsBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.glusterBrickAdvancedDetails.glusterClients == nil {
		builder.glusterBrickAdvancedDetails.glusterClients = new(GlusterClientSlice)
	}
	builder.glusterBrickAdvancedDetails.glusterClients.slice = append(builder.glusterBrickAdvancedDetails.glusterClients.slice, anys...)
	return builder
}

func (builder *GlusterBrickAdvancedDetailsBuilder) GlusterClientsBuilderOfAny(anyBuilders ...GlusterClientBuilder) *GlusterBrickAdvancedDetailsBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.GlusterClientsOfAny(attr)
	}
	return builder
}

func (builder *GlusterBrickAdvancedDetailsBuilder) Id(attr string) *GlusterBrickAdvancedDetailsBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterBrickAdvancedDetails.SetId(attr)
	return builder
}

func (builder *GlusterBrickAdvancedDetailsBuilder) InstanceType(attr *InstanceType) *GlusterBrickAdvancedDetailsBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterBrickAdvancedDetails.SetInstanceType(attr)
	return builder
}

func (builder *GlusterBrickAdvancedDetailsBuilder) InstanceTypeBuilder(attrBuilder *InstanceTypeBuilder) *GlusterBrickAdvancedDetailsBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.InstanceType(attr)
}

func (builder *GlusterBrickAdvancedDetailsBuilder) MemoryPools(attr *GlusterMemoryPoolSlice) *GlusterBrickAdvancedDetailsBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterBrickAdvancedDetails.SetMemoryPools(attr)
	return builder
}

func (builder *GlusterBrickAdvancedDetailsBuilder) MemoryPoolsOfAny(anys ...*GlusterMemoryPool) *GlusterBrickAdvancedDetailsBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.glusterBrickAdvancedDetails.memoryPools == nil {
		builder.glusterBrickAdvancedDetails.memoryPools = new(GlusterMemoryPoolSlice)
	}
	builder.glusterBrickAdvancedDetails.memoryPools.slice = append(builder.glusterBrickAdvancedDetails.memoryPools.slice, anys...)
	return builder
}

func (builder *GlusterBrickAdvancedDetailsBuilder) MemoryPoolsBuilderOfAny(anyBuilders ...GlusterMemoryPoolBuilder) *GlusterBrickAdvancedDetailsBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.MemoryPoolsOfAny(attr)
	}
	return builder
}

func (builder *GlusterBrickAdvancedDetailsBuilder) MntOptions(attr string) *GlusterBrickAdvancedDetailsBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterBrickAdvancedDetails.SetMntOptions(attr)
	return builder
}

func (builder *GlusterBrickAdvancedDetailsBuilder) Name(attr string) *GlusterBrickAdvancedDetailsBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterBrickAdvancedDetails.SetName(attr)
	return builder
}

func (builder *GlusterBrickAdvancedDetailsBuilder) Pid(attr int64) *GlusterBrickAdvancedDetailsBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterBrickAdvancedDetails.SetPid(attr)
	return builder
}

func (builder *GlusterBrickAdvancedDetailsBuilder) Port(attr int64) *GlusterBrickAdvancedDetailsBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterBrickAdvancedDetails.SetPort(attr)
	return builder
}

func (builder *GlusterBrickAdvancedDetailsBuilder) Template(attr *Template) *GlusterBrickAdvancedDetailsBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterBrickAdvancedDetails.SetTemplate(attr)
	return builder
}

func (builder *GlusterBrickAdvancedDetailsBuilder) TemplateBuilder(attrBuilder *TemplateBuilder) *GlusterBrickAdvancedDetailsBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Template(attr)
}

func (builder *GlusterBrickAdvancedDetailsBuilder) Vm(attr *Vm) *GlusterBrickAdvancedDetailsBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterBrickAdvancedDetails.SetVm(attr)
	return builder
}

func (builder *GlusterBrickAdvancedDetailsBuilder) VmBuilder(attrBuilder *VmBuilder) *GlusterBrickAdvancedDetailsBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Vm(attr)
}

func (builder *GlusterBrickAdvancedDetailsBuilder) Vms(attr *VmSlice) *GlusterBrickAdvancedDetailsBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterBrickAdvancedDetails.SetVms(attr)
	return builder
}

func (builder *GlusterBrickAdvancedDetailsBuilder) VmsOfAny(anys ...*Vm) *GlusterBrickAdvancedDetailsBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.glusterBrickAdvancedDetails.vms == nil {
		builder.glusterBrickAdvancedDetails.vms = new(VmSlice)
	}
	builder.glusterBrickAdvancedDetails.vms.slice = append(builder.glusterBrickAdvancedDetails.vms.slice, anys...)
	return builder
}

func (builder *GlusterBrickAdvancedDetailsBuilder) VmsBuilderOfAny(anyBuilders ...VmBuilder) *GlusterBrickAdvancedDetailsBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.VmsOfAny(attr)
	}
	return builder
}

func (builder *GlusterBrickAdvancedDetailsBuilder) Href(href string) *GlusterBrickAdvancedDetailsBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterBrickAdvancedDetails.SetHref(href)
	return builder
}

func (builder *GlusterBrickAdvancedDetailsBuilder) Build() (*GlusterBrickAdvancedDetails, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.glusterBrickAdvancedDetails, nil
}

func (builder *GlusterBrickAdvancedDetailsBuilder) MustBuild() *GlusterBrickAdvancedDetails {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build GlusterBrickAdvancedDetails instance, reason: %v", builder.err))
	}
	return builder.glusterBrickAdvancedDetails
}

type GlusterBrickMemoryInfoBuilder struct {
	glusterBrickMemoryInfo *GlusterBrickMemoryInfo
	err                    error
}

func NewGlusterBrickMemoryInfoBuilder() *GlusterBrickMemoryInfoBuilder {
	return &GlusterBrickMemoryInfoBuilder{glusterBrickMemoryInfo: &GlusterBrickMemoryInfo{}, err: nil}
}

func (builder *GlusterBrickMemoryInfoBuilder) MemoryPools(attr *GlusterMemoryPoolSlice) *GlusterBrickMemoryInfoBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterBrickMemoryInfo.SetMemoryPools(attr)
	return builder
}

func (builder *GlusterBrickMemoryInfoBuilder) MemoryPoolsOfAny(anys ...*GlusterMemoryPool) *GlusterBrickMemoryInfoBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.glusterBrickMemoryInfo.memoryPools == nil {
		builder.glusterBrickMemoryInfo.memoryPools = new(GlusterMemoryPoolSlice)
	}
	builder.glusterBrickMemoryInfo.memoryPools.slice = append(builder.glusterBrickMemoryInfo.memoryPools.slice, anys...)
	return builder
}

func (builder *GlusterBrickMemoryInfoBuilder) MemoryPoolsBuilderOfAny(anyBuilders ...GlusterMemoryPoolBuilder) *GlusterBrickMemoryInfoBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.MemoryPoolsOfAny(attr)
	}
	return builder
}

func (builder *GlusterBrickMemoryInfoBuilder) Href(href string) *GlusterBrickMemoryInfoBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterBrickMemoryInfo.SetHref(href)
	return builder
}

func (builder *GlusterBrickMemoryInfoBuilder) Build() (*GlusterBrickMemoryInfo, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.glusterBrickMemoryInfo, nil
}

func (builder *GlusterBrickMemoryInfoBuilder) MustBuild() *GlusterBrickMemoryInfo {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build GlusterBrickMemoryInfo instance, reason: %v", builder.err))
	}
	return builder.glusterBrickMemoryInfo
}

type GlusterClientBuilder struct {
	glusterClient *GlusterClient
	err           error
}

func NewGlusterClientBuilder() *GlusterClientBuilder {
	return &GlusterClientBuilder{glusterClient: &GlusterClient{}, err: nil}
}

func (builder *GlusterClientBuilder) BytesRead(attr int64) *GlusterClientBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterClient.SetBytesRead(attr)
	return builder
}

func (builder *GlusterClientBuilder) BytesWritten(attr int64) *GlusterClientBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterClient.SetBytesWritten(attr)
	return builder
}

func (builder *GlusterClientBuilder) ClientPort(attr int64) *GlusterClientBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterClient.SetClientPort(attr)
	return builder
}

func (builder *GlusterClientBuilder) HostName(attr string) *GlusterClientBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterClient.SetHostName(attr)
	return builder
}

func (builder *GlusterClientBuilder) Href(href string) *GlusterClientBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterClient.SetHref(href)
	return builder
}

func (builder *GlusterClientBuilder) Build() (*GlusterClient, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.glusterClient, nil
}

func (builder *GlusterClientBuilder) MustBuild() *GlusterClient {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build GlusterClient instance, reason: %v", builder.err))
	}
	return builder.glusterClient
}

type GlusterHookBuilder struct {
	glusterHook *GlusterHook
	err         error
}

func NewGlusterHookBuilder() *GlusterHookBuilder {
	return &GlusterHookBuilder{glusterHook: &GlusterHook{}, err: nil}
}

func (builder *GlusterHookBuilder) Checksum(attr string) *GlusterHookBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterHook.SetChecksum(attr)
	return builder
}

func (builder *GlusterHookBuilder) Cluster(attr *Cluster) *GlusterHookBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterHook.SetCluster(attr)
	return builder
}

func (builder *GlusterHookBuilder) ClusterBuilder(attrBuilder *ClusterBuilder) *GlusterHookBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Cluster(attr)
}

func (builder *GlusterHookBuilder) Comment(attr string) *GlusterHookBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterHook.SetComment(attr)
	return builder
}

func (builder *GlusterHookBuilder) ConflictStatus(attr int64) *GlusterHookBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterHook.SetConflictStatus(attr)
	return builder
}

func (builder *GlusterHookBuilder) Conflicts(attr string) *GlusterHookBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterHook.SetConflicts(attr)
	return builder
}

func (builder *GlusterHookBuilder) Content(attr string) *GlusterHookBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterHook.SetContent(attr)
	return builder
}

func (builder *GlusterHookBuilder) ContentType(attr HookContentType) *GlusterHookBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterHook.SetContentType(attr)
	return builder
}

func (builder *GlusterHookBuilder) Description(attr string) *GlusterHookBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterHook.SetDescription(attr)
	return builder
}

func (builder *GlusterHookBuilder) GlusterCommand(attr string) *GlusterHookBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterHook.SetGlusterCommand(attr)
	return builder
}

func (builder *GlusterHookBuilder) Id(attr string) *GlusterHookBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterHook.SetId(attr)
	return builder
}

func (builder *GlusterHookBuilder) Name(attr string) *GlusterHookBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterHook.SetName(attr)
	return builder
}

func (builder *GlusterHookBuilder) ServerHooks(attr *GlusterServerHookSlice) *GlusterHookBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterHook.SetServerHooks(attr)
	return builder
}

func (builder *GlusterHookBuilder) ServerHooksOfAny(anys ...*GlusterServerHook) *GlusterHookBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.glusterHook.serverHooks == nil {
		builder.glusterHook.serverHooks = new(GlusterServerHookSlice)
	}
	builder.glusterHook.serverHooks.slice = append(builder.glusterHook.serverHooks.slice, anys...)
	return builder
}

func (builder *GlusterHookBuilder) ServerHooksBuilderOfAny(anyBuilders ...GlusterServerHookBuilder) *GlusterHookBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.ServerHooksOfAny(attr)
	}
	return builder
}

func (builder *GlusterHookBuilder) Stage(attr HookStage) *GlusterHookBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterHook.SetStage(attr)
	return builder
}

func (builder *GlusterHookBuilder) Status(attr GlusterHookStatus) *GlusterHookBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterHook.SetStatus(attr)
	return builder
}

func (builder *GlusterHookBuilder) Href(href string) *GlusterHookBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterHook.SetHref(href)
	return builder
}

func (builder *GlusterHookBuilder) Build() (*GlusterHook, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.glusterHook, nil
}

func (builder *GlusterHookBuilder) MustBuild() *GlusterHook {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build GlusterHook instance, reason: %v", builder.err))
	}
	return builder.glusterHook
}

type GlusterMemoryPoolBuilder struct {
	glusterMemoryPool *GlusterMemoryPool
	err               error
}

func NewGlusterMemoryPoolBuilder() *GlusterMemoryPoolBuilder {
	return &GlusterMemoryPoolBuilder{glusterMemoryPool: &GlusterMemoryPool{}, err: nil}
}

func (builder *GlusterMemoryPoolBuilder) AllocCount(attr int64) *GlusterMemoryPoolBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterMemoryPool.SetAllocCount(attr)
	return builder
}

func (builder *GlusterMemoryPoolBuilder) ColdCount(attr int64) *GlusterMemoryPoolBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterMemoryPool.SetColdCount(attr)
	return builder
}

func (builder *GlusterMemoryPoolBuilder) Comment(attr string) *GlusterMemoryPoolBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterMemoryPool.SetComment(attr)
	return builder
}

func (builder *GlusterMemoryPoolBuilder) Description(attr string) *GlusterMemoryPoolBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterMemoryPool.SetDescription(attr)
	return builder
}

func (builder *GlusterMemoryPoolBuilder) HotCount(attr int64) *GlusterMemoryPoolBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterMemoryPool.SetHotCount(attr)
	return builder
}

func (builder *GlusterMemoryPoolBuilder) Id(attr string) *GlusterMemoryPoolBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterMemoryPool.SetId(attr)
	return builder
}

func (builder *GlusterMemoryPoolBuilder) MaxAlloc(attr int64) *GlusterMemoryPoolBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterMemoryPool.SetMaxAlloc(attr)
	return builder
}

func (builder *GlusterMemoryPoolBuilder) MaxStdalloc(attr int64) *GlusterMemoryPoolBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterMemoryPool.SetMaxStdalloc(attr)
	return builder
}

func (builder *GlusterMemoryPoolBuilder) Name(attr string) *GlusterMemoryPoolBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterMemoryPool.SetName(attr)
	return builder
}

func (builder *GlusterMemoryPoolBuilder) PaddedSize(attr int64) *GlusterMemoryPoolBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterMemoryPool.SetPaddedSize(attr)
	return builder
}

func (builder *GlusterMemoryPoolBuilder) PoolMisses(attr int64) *GlusterMemoryPoolBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterMemoryPool.SetPoolMisses(attr)
	return builder
}

func (builder *GlusterMemoryPoolBuilder) Type(attr string) *GlusterMemoryPoolBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterMemoryPool.SetType(attr)
	return builder
}

func (builder *GlusterMemoryPoolBuilder) Href(href string) *GlusterMemoryPoolBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterMemoryPool.SetHref(href)
	return builder
}

func (builder *GlusterMemoryPoolBuilder) Build() (*GlusterMemoryPool, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.glusterMemoryPool, nil
}

func (builder *GlusterMemoryPoolBuilder) MustBuild() *GlusterMemoryPool {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build GlusterMemoryPool instance, reason: %v", builder.err))
	}
	return builder.glusterMemoryPool
}

type GlusterServerHookBuilder struct {
	glusterServerHook *GlusterServerHook
	err               error
}

func NewGlusterServerHookBuilder() *GlusterServerHookBuilder {
	return &GlusterServerHookBuilder{glusterServerHook: &GlusterServerHook{}, err: nil}
}

func (builder *GlusterServerHookBuilder) Checksum(attr string) *GlusterServerHookBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterServerHook.SetChecksum(attr)
	return builder
}

func (builder *GlusterServerHookBuilder) Comment(attr string) *GlusterServerHookBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterServerHook.SetComment(attr)
	return builder
}

func (builder *GlusterServerHookBuilder) ContentType(attr HookContentType) *GlusterServerHookBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterServerHook.SetContentType(attr)
	return builder
}

func (builder *GlusterServerHookBuilder) Description(attr string) *GlusterServerHookBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterServerHook.SetDescription(attr)
	return builder
}

func (builder *GlusterServerHookBuilder) Host(attr *Host) *GlusterServerHookBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterServerHook.SetHost(attr)
	return builder
}

func (builder *GlusterServerHookBuilder) HostBuilder(attrBuilder *HostBuilder) *GlusterServerHookBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Host(attr)
}

func (builder *GlusterServerHookBuilder) Id(attr string) *GlusterServerHookBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterServerHook.SetId(attr)
	return builder
}

func (builder *GlusterServerHookBuilder) Name(attr string) *GlusterServerHookBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterServerHook.SetName(attr)
	return builder
}

func (builder *GlusterServerHookBuilder) Status(attr GlusterHookStatus) *GlusterServerHookBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterServerHook.SetStatus(attr)
	return builder
}

func (builder *GlusterServerHookBuilder) Href(href string) *GlusterServerHookBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterServerHook.SetHref(href)
	return builder
}

func (builder *GlusterServerHookBuilder) Build() (*GlusterServerHook, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.glusterServerHook, nil
}

func (builder *GlusterServerHookBuilder) MustBuild() *GlusterServerHook {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build GlusterServerHook instance, reason: %v", builder.err))
	}
	return builder.glusterServerHook
}

type GlusterVolumeBuilder struct {
	glusterVolume *GlusterVolume
	err           error
}

func NewGlusterVolumeBuilder() *GlusterVolumeBuilder {
	return &GlusterVolumeBuilder{glusterVolume: &GlusterVolume{}, err: nil}
}

func (builder *GlusterVolumeBuilder) Bricks(attr *GlusterBrickSlice) *GlusterVolumeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterVolume.SetBricks(attr)
	return builder
}

func (builder *GlusterVolumeBuilder) BricksOfAny(anys ...*GlusterBrick) *GlusterVolumeBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.glusterVolume.bricks == nil {
		builder.glusterVolume.bricks = new(GlusterBrickSlice)
	}
	builder.glusterVolume.bricks.slice = append(builder.glusterVolume.bricks.slice, anys...)
	return builder
}

func (builder *GlusterVolumeBuilder) BricksBuilderOfAny(anyBuilders ...GlusterBrickBuilder) *GlusterVolumeBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.BricksOfAny(attr)
	}
	return builder
}

func (builder *GlusterVolumeBuilder) Cluster(attr *Cluster) *GlusterVolumeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterVolume.SetCluster(attr)
	return builder
}

func (builder *GlusterVolumeBuilder) ClusterBuilder(attrBuilder *ClusterBuilder) *GlusterVolumeBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Cluster(attr)
}

func (builder *GlusterVolumeBuilder) Comment(attr string) *GlusterVolumeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterVolume.SetComment(attr)
	return builder
}

func (builder *GlusterVolumeBuilder) Description(attr string) *GlusterVolumeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterVolume.SetDescription(attr)
	return builder
}

func (builder *GlusterVolumeBuilder) DisperseCount(attr int64) *GlusterVolumeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterVolume.SetDisperseCount(attr)
	return builder
}

func (builder *GlusterVolumeBuilder) Id(attr string) *GlusterVolumeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterVolume.SetId(attr)
	return builder
}

func (builder *GlusterVolumeBuilder) Name(attr string) *GlusterVolumeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterVolume.SetName(attr)
	return builder
}

func (builder *GlusterVolumeBuilder) Options(attr *OptionSlice) *GlusterVolumeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterVolume.SetOptions(attr)
	return builder
}

func (builder *GlusterVolumeBuilder) OptionsOfAny(anys ...*Option) *GlusterVolumeBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.glusterVolume.options == nil {
		builder.glusterVolume.options = new(OptionSlice)
	}
	builder.glusterVolume.options.slice = append(builder.glusterVolume.options.slice, anys...)
	return builder
}

func (builder *GlusterVolumeBuilder) OptionsBuilderOfAny(anyBuilders ...OptionBuilder) *GlusterVolumeBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.OptionsOfAny(attr)
	}
	return builder
}

func (builder *GlusterVolumeBuilder) RedundancyCount(attr int64) *GlusterVolumeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterVolume.SetRedundancyCount(attr)
	return builder
}

func (builder *GlusterVolumeBuilder) ReplicaCount(attr int64) *GlusterVolumeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterVolume.SetReplicaCount(attr)
	return builder
}

func (builder *GlusterVolumeBuilder) Statistics(attr *StatisticSlice) *GlusterVolumeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterVolume.SetStatistics(attr)
	return builder
}

func (builder *GlusterVolumeBuilder) StatisticsOfAny(anys ...*Statistic) *GlusterVolumeBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.glusterVolume.statistics == nil {
		builder.glusterVolume.statistics = new(StatisticSlice)
	}
	builder.glusterVolume.statistics.slice = append(builder.glusterVolume.statistics.slice, anys...)
	return builder
}

func (builder *GlusterVolumeBuilder) StatisticsBuilderOfAny(anyBuilders ...StatisticBuilder) *GlusterVolumeBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.StatisticsOfAny(attr)
	}
	return builder
}

func (builder *GlusterVolumeBuilder) Status(attr GlusterVolumeStatus) *GlusterVolumeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterVolume.SetStatus(attr)
	return builder
}

func (builder *GlusterVolumeBuilder) StripeCount(attr int64) *GlusterVolumeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterVolume.SetStripeCount(attr)
	return builder
}

func (builder *GlusterVolumeBuilder) TransportTypes(attr []TransportType) *GlusterVolumeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterVolume.SetTransportTypes(attr)
	return builder
}

func (builder *GlusterVolumeBuilder) TransportTypesOfAny(anys ...TransportType) *GlusterVolumeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterVolume.transportTypes = append(builder.glusterVolume.transportTypes, anys...)
	return builder
}

func (builder *GlusterVolumeBuilder) VolumeType(attr GlusterVolumeType) *GlusterVolumeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterVolume.SetVolumeType(attr)
	return builder
}

func (builder *GlusterVolumeBuilder) Href(href string) *GlusterVolumeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterVolume.SetHref(href)
	return builder
}

func (builder *GlusterVolumeBuilder) Build() (*GlusterVolume, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.glusterVolume, nil
}

func (builder *GlusterVolumeBuilder) MustBuild() *GlusterVolume {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build GlusterVolume instance, reason: %v", builder.err))
	}
	return builder.glusterVolume
}

type GlusterVolumeProfileDetailsBuilder struct {
	glusterVolumeProfileDetails *GlusterVolumeProfileDetails
	err                         error
}

func NewGlusterVolumeProfileDetailsBuilder() *GlusterVolumeProfileDetailsBuilder {
	return &GlusterVolumeProfileDetailsBuilder{glusterVolumeProfileDetails: &GlusterVolumeProfileDetails{}, err: nil}
}

func (builder *GlusterVolumeProfileDetailsBuilder) BrickProfileDetails(attr *BrickProfileDetailSlice) *GlusterVolumeProfileDetailsBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterVolumeProfileDetails.SetBrickProfileDetails(attr)
	return builder
}

func (builder *GlusterVolumeProfileDetailsBuilder) BrickProfileDetailsOfAny(anys ...*BrickProfileDetail) *GlusterVolumeProfileDetailsBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.glusterVolumeProfileDetails.brickProfileDetails == nil {
		builder.glusterVolumeProfileDetails.brickProfileDetails = new(BrickProfileDetailSlice)
	}
	builder.glusterVolumeProfileDetails.brickProfileDetails.slice = append(builder.glusterVolumeProfileDetails.brickProfileDetails.slice, anys...)
	return builder
}

func (builder *GlusterVolumeProfileDetailsBuilder) BrickProfileDetailsBuilderOfAny(anyBuilders ...BrickProfileDetailBuilder) *GlusterVolumeProfileDetailsBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.BrickProfileDetailsOfAny(attr)
	}
	return builder
}

func (builder *GlusterVolumeProfileDetailsBuilder) Comment(attr string) *GlusterVolumeProfileDetailsBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterVolumeProfileDetails.SetComment(attr)
	return builder
}

func (builder *GlusterVolumeProfileDetailsBuilder) Description(attr string) *GlusterVolumeProfileDetailsBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterVolumeProfileDetails.SetDescription(attr)
	return builder
}

func (builder *GlusterVolumeProfileDetailsBuilder) Id(attr string) *GlusterVolumeProfileDetailsBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterVolumeProfileDetails.SetId(attr)
	return builder
}

func (builder *GlusterVolumeProfileDetailsBuilder) Name(attr string) *GlusterVolumeProfileDetailsBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterVolumeProfileDetails.SetName(attr)
	return builder
}

func (builder *GlusterVolumeProfileDetailsBuilder) NfsProfileDetails(attr *NfsProfileDetailSlice) *GlusterVolumeProfileDetailsBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterVolumeProfileDetails.SetNfsProfileDetails(attr)
	return builder
}

func (builder *GlusterVolumeProfileDetailsBuilder) NfsProfileDetailsOfAny(anys ...*NfsProfileDetail) *GlusterVolumeProfileDetailsBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.glusterVolumeProfileDetails.nfsProfileDetails == nil {
		builder.glusterVolumeProfileDetails.nfsProfileDetails = new(NfsProfileDetailSlice)
	}
	builder.glusterVolumeProfileDetails.nfsProfileDetails.slice = append(builder.glusterVolumeProfileDetails.nfsProfileDetails.slice, anys...)
	return builder
}

func (builder *GlusterVolumeProfileDetailsBuilder) NfsProfileDetailsBuilderOfAny(anyBuilders ...NfsProfileDetailBuilder) *GlusterVolumeProfileDetailsBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.NfsProfileDetailsOfAny(attr)
	}
	return builder
}

func (builder *GlusterVolumeProfileDetailsBuilder) Href(href string) *GlusterVolumeProfileDetailsBuilder {
	if builder.err != nil {
		return builder
	}

	builder.glusterVolumeProfileDetails.SetHref(href)
	return builder
}

func (builder *GlusterVolumeProfileDetailsBuilder) Build() (*GlusterVolumeProfileDetails, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.glusterVolumeProfileDetails, nil
}

func (builder *GlusterVolumeProfileDetailsBuilder) MustBuild() *GlusterVolumeProfileDetails {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build GlusterVolumeProfileDetails instance, reason: %v", builder.err))
	}
	return builder.glusterVolumeProfileDetails
}

type GraphicsConsoleBuilder struct {
	graphicsConsole *GraphicsConsole
	err             error
}

func NewGraphicsConsoleBuilder() *GraphicsConsoleBuilder {
	return &GraphicsConsoleBuilder{graphicsConsole: &GraphicsConsole{}, err: nil}
}

func (builder *GraphicsConsoleBuilder) Address(attr string) *GraphicsConsoleBuilder {
	if builder.err != nil {
		return builder
	}

	builder.graphicsConsole.SetAddress(attr)
	return builder
}

func (builder *GraphicsConsoleBuilder) Comment(attr string) *GraphicsConsoleBuilder {
	if builder.err != nil {
		return builder
	}

	builder.graphicsConsole.SetComment(attr)
	return builder
}

func (builder *GraphicsConsoleBuilder) Description(attr string) *GraphicsConsoleBuilder {
	if builder.err != nil {
		return builder
	}

	builder.graphicsConsole.SetDescription(attr)
	return builder
}

func (builder *GraphicsConsoleBuilder) Id(attr string) *GraphicsConsoleBuilder {
	if builder.err != nil {
		return builder
	}

	builder.graphicsConsole.SetId(attr)
	return builder
}

func (builder *GraphicsConsoleBuilder) InstanceType(attr *InstanceType) *GraphicsConsoleBuilder {
	if builder.err != nil {
		return builder
	}

	builder.graphicsConsole.SetInstanceType(attr)
	return builder
}

func (builder *GraphicsConsoleBuilder) InstanceTypeBuilder(attrBuilder *InstanceTypeBuilder) *GraphicsConsoleBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.InstanceType(attr)
}

func (builder *GraphicsConsoleBuilder) Name(attr string) *GraphicsConsoleBuilder {
	if builder.err != nil {
		return builder
	}

	builder.graphicsConsole.SetName(attr)
	return builder
}

func (builder *GraphicsConsoleBuilder) Port(attr int64) *GraphicsConsoleBuilder {
	if builder.err != nil {
		return builder
	}

	builder.graphicsConsole.SetPort(attr)
	return builder
}

func (builder *GraphicsConsoleBuilder) Protocol(attr GraphicsType) *GraphicsConsoleBuilder {
	if builder.err != nil {
		return builder
	}

	builder.graphicsConsole.SetProtocol(attr)
	return builder
}

func (builder *GraphicsConsoleBuilder) Template(attr *Template) *GraphicsConsoleBuilder {
	if builder.err != nil {
		return builder
	}

	builder.graphicsConsole.SetTemplate(attr)
	return builder
}

func (builder *GraphicsConsoleBuilder) TemplateBuilder(attrBuilder *TemplateBuilder) *GraphicsConsoleBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Template(attr)
}

func (builder *GraphicsConsoleBuilder) TlsPort(attr int64) *GraphicsConsoleBuilder {
	if builder.err != nil {
		return builder
	}

	builder.graphicsConsole.SetTlsPort(attr)
	return builder
}

func (builder *GraphicsConsoleBuilder) Vm(attr *Vm) *GraphicsConsoleBuilder {
	if builder.err != nil {
		return builder
	}

	builder.graphicsConsole.SetVm(attr)
	return builder
}

func (builder *GraphicsConsoleBuilder) VmBuilder(attrBuilder *VmBuilder) *GraphicsConsoleBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Vm(attr)
}

func (builder *GraphicsConsoleBuilder) Href(href string) *GraphicsConsoleBuilder {
	if builder.err != nil {
		return builder
	}

	builder.graphicsConsole.SetHref(href)
	return builder
}

func (builder *GraphicsConsoleBuilder) Build() (*GraphicsConsole, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.graphicsConsole, nil
}

func (builder *GraphicsConsoleBuilder) MustBuild() *GraphicsConsole {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build GraphicsConsole instance, reason: %v", builder.err))
	}
	return builder.graphicsConsole
}

type GroupBuilder struct {
	group *Group
	err   error
}

func NewGroupBuilder() *GroupBuilder {
	return &GroupBuilder{group: &Group{}, err: nil}
}

func (builder *GroupBuilder) Comment(attr string) *GroupBuilder {
	if builder.err != nil {
		return builder
	}

	builder.group.SetComment(attr)
	return builder
}

func (builder *GroupBuilder) Description(attr string) *GroupBuilder {
	if builder.err != nil {
		return builder
	}

	builder.group.SetDescription(attr)
	return builder
}

func (builder *GroupBuilder) Domain(attr *Domain) *GroupBuilder {
	if builder.err != nil {
		return builder
	}

	builder.group.SetDomain(attr)
	return builder
}

func (builder *GroupBuilder) DomainBuilder(attrBuilder *DomainBuilder) *GroupBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Domain(attr)
}

func (builder *GroupBuilder) DomainEntryId(attr string) *GroupBuilder {
	if builder.err != nil {
		return builder
	}

	builder.group.SetDomainEntryId(attr)
	return builder
}

func (builder *GroupBuilder) Id(attr string) *GroupBuilder {
	if builder.err != nil {
		return builder
	}

	builder.group.SetId(attr)
	return builder
}

func (builder *GroupBuilder) Name(attr string) *GroupBuilder {
	if builder.err != nil {
		return builder
	}

	builder.group.SetName(attr)
	return builder
}

func (builder *GroupBuilder) Namespace(attr string) *GroupBuilder {
	if builder.err != nil {
		return builder
	}

	builder.group.SetNamespace(attr)
	return builder
}

func (builder *GroupBuilder) Permissions(attr *PermissionSlice) *GroupBuilder {
	if builder.err != nil {
		return builder
	}

	builder.group.SetPermissions(attr)
	return builder
}

func (builder *GroupBuilder) PermissionsOfAny(anys ...*Permission) *GroupBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.group.permissions == nil {
		builder.group.permissions = new(PermissionSlice)
	}
	builder.group.permissions.slice = append(builder.group.permissions.slice, anys...)
	return builder
}

func (builder *GroupBuilder) PermissionsBuilderOfAny(anyBuilders ...PermissionBuilder) *GroupBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.PermissionsOfAny(attr)
	}
	return builder
}

func (builder *GroupBuilder) Roles(attr *RoleSlice) *GroupBuilder {
	if builder.err != nil {
		return builder
	}

	builder.group.SetRoles(attr)
	return builder
}

func (builder *GroupBuilder) RolesOfAny(anys ...*Role) *GroupBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.group.roles == nil {
		builder.group.roles = new(RoleSlice)
	}
	builder.group.roles.slice = append(builder.group.roles.slice, anys...)
	return builder
}

func (builder *GroupBuilder) RolesBuilderOfAny(anyBuilders ...RoleBuilder) *GroupBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.RolesOfAny(attr)
	}
	return builder
}

func (builder *GroupBuilder) Tags(attr *TagSlice) *GroupBuilder {
	if builder.err != nil {
		return builder
	}

	builder.group.SetTags(attr)
	return builder
}

func (builder *GroupBuilder) TagsOfAny(anys ...*Tag) *GroupBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.group.tags == nil {
		builder.group.tags = new(TagSlice)
	}
	builder.group.tags.slice = append(builder.group.tags.slice, anys...)
	return builder
}

func (builder *GroupBuilder) TagsBuilderOfAny(anyBuilders ...TagBuilder) *GroupBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.TagsOfAny(attr)
	}
	return builder
}

func (builder *GroupBuilder) Href(href string) *GroupBuilder {
	if builder.err != nil {
		return builder
	}

	builder.group.SetHref(href)
	return builder
}

func (builder *GroupBuilder) Build() (*Group, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.group, nil
}

func (builder *GroupBuilder) MustBuild() *Group {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build Group instance, reason: %v", builder.err))
	}
	return builder.group
}

type GuestOperatingSystemBuilder struct {
	guestOperatingSystem *GuestOperatingSystem
	err                  error
}

func NewGuestOperatingSystemBuilder() *GuestOperatingSystemBuilder {
	return &GuestOperatingSystemBuilder{guestOperatingSystem: &GuestOperatingSystem{}, err: nil}
}

func (builder *GuestOperatingSystemBuilder) Architecture(attr string) *GuestOperatingSystemBuilder {
	if builder.err != nil {
		return builder
	}

	builder.guestOperatingSystem.SetArchitecture(attr)
	return builder
}

func (builder *GuestOperatingSystemBuilder) Codename(attr string) *GuestOperatingSystemBuilder {
	if builder.err != nil {
		return builder
	}

	builder.guestOperatingSystem.SetCodename(attr)
	return builder
}

func (builder *GuestOperatingSystemBuilder) Distribution(attr string) *GuestOperatingSystemBuilder {
	if builder.err != nil {
		return builder
	}

	builder.guestOperatingSystem.SetDistribution(attr)
	return builder
}

func (builder *GuestOperatingSystemBuilder) Family(attr string) *GuestOperatingSystemBuilder {
	if builder.err != nil {
		return builder
	}

	builder.guestOperatingSystem.SetFamily(attr)
	return builder
}

func (builder *GuestOperatingSystemBuilder) Kernel(attr *Kernel) *GuestOperatingSystemBuilder {
	if builder.err != nil {
		return builder
	}

	builder.guestOperatingSystem.SetKernel(attr)
	return builder
}

func (builder *GuestOperatingSystemBuilder) KernelBuilder(attrBuilder *KernelBuilder) *GuestOperatingSystemBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Kernel(attr)
}

func (builder *GuestOperatingSystemBuilder) Version(attr *Version) *GuestOperatingSystemBuilder {
	if builder.err != nil {
		return builder
	}

	builder.guestOperatingSystem.SetVersion(attr)
	return builder
}

func (builder *GuestOperatingSystemBuilder) VersionBuilder(attrBuilder *VersionBuilder) *GuestOperatingSystemBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Version(attr)
}

func (builder *GuestOperatingSystemBuilder) Href(href string) *GuestOperatingSystemBuilder {
	if builder.err != nil {
		return builder
	}

	builder.guestOperatingSystem.SetHref(href)
	return builder
}

func (builder *GuestOperatingSystemBuilder) Build() (*GuestOperatingSystem, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.guestOperatingSystem, nil
}

func (builder *GuestOperatingSystemBuilder) MustBuild() *GuestOperatingSystem {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build GuestOperatingSystem instance, reason: %v", builder.err))
	}
	return builder.guestOperatingSystem
}

type HardwareInformationBuilder struct {
	hardwareInformation *HardwareInformation
	err                 error
}

func NewHardwareInformationBuilder() *HardwareInformationBuilder {
	return &HardwareInformationBuilder{hardwareInformation: &HardwareInformation{}, err: nil}
}

func (builder *HardwareInformationBuilder) Family(attr string) *HardwareInformationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hardwareInformation.SetFamily(attr)
	return builder
}

func (builder *HardwareInformationBuilder) Manufacturer(attr string) *HardwareInformationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hardwareInformation.SetManufacturer(attr)
	return builder
}

func (builder *HardwareInformationBuilder) ProductName(attr string) *HardwareInformationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hardwareInformation.SetProductName(attr)
	return builder
}

func (builder *HardwareInformationBuilder) SerialNumber(attr string) *HardwareInformationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hardwareInformation.SetSerialNumber(attr)
	return builder
}

func (builder *HardwareInformationBuilder) SupportedRngSources(attr []RngSource) *HardwareInformationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hardwareInformation.SetSupportedRngSources(attr)
	return builder
}

func (builder *HardwareInformationBuilder) SupportedRngSourcesOfAny(anys ...RngSource) *HardwareInformationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hardwareInformation.supportedRngSources = append(builder.hardwareInformation.supportedRngSources, anys...)
	return builder
}

func (builder *HardwareInformationBuilder) Uuid(attr string) *HardwareInformationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hardwareInformation.SetUuid(attr)
	return builder
}

func (builder *HardwareInformationBuilder) Version(attr string) *HardwareInformationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hardwareInformation.SetVersion(attr)
	return builder
}

func (builder *HardwareInformationBuilder) Href(href string) *HardwareInformationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hardwareInformation.SetHref(href)
	return builder
}

func (builder *HardwareInformationBuilder) Build() (*HardwareInformation, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.hardwareInformation, nil
}

func (builder *HardwareInformationBuilder) MustBuild() *HardwareInformation {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build HardwareInformation instance, reason: %v", builder.err))
	}
	return builder.hardwareInformation
}

type HighAvailabilityBuilder struct {
	highAvailability *HighAvailability
	err              error
}

func NewHighAvailabilityBuilder() *HighAvailabilityBuilder {
	return &HighAvailabilityBuilder{highAvailability: &HighAvailability{}, err: nil}
}

func (builder *HighAvailabilityBuilder) Enabled(attr bool) *HighAvailabilityBuilder {
	if builder.err != nil {
		return builder
	}

	builder.highAvailability.SetEnabled(attr)
	return builder
}

func (builder *HighAvailabilityBuilder) Priority(attr int64) *HighAvailabilityBuilder {
	if builder.err != nil {
		return builder
	}

	builder.highAvailability.SetPriority(attr)
	return builder
}

func (builder *HighAvailabilityBuilder) Href(href string) *HighAvailabilityBuilder {
	if builder.err != nil {
		return builder
	}

	builder.highAvailability.SetHref(href)
	return builder
}

func (builder *HighAvailabilityBuilder) Build() (*HighAvailability, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.highAvailability, nil
}

func (builder *HighAvailabilityBuilder) MustBuild() *HighAvailability {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build HighAvailability instance, reason: %v", builder.err))
	}
	return builder.highAvailability
}

type HookBuilder struct {
	hook *Hook
	err  error
}

func NewHookBuilder() *HookBuilder {
	return &HookBuilder{hook: &Hook{}, err: nil}
}

func (builder *HookBuilder) Comment(attr string) *HookBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hook.SetComment(attr)
	return builder
}

func (builder *HookBuilder) Description(attr string) *HookBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hook.SetDescription(attr)
	return builder
}

func (builder *HookBuilder) EventName(attr string) *HookBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hook.SetEventName(attr)
	return builder
}

func (builder *HookBuilder) Host(attr *Host) *HookBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hook.SetHost(attr)
	return builder
}

func (builder *HookBuilder) HostBuilder(attrBuilder *HostBuilder) *HookBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Host(attr)
}

func (builder *HookBuilder) Id(attr string) *HookBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hook.SetId(attr)
	return builder
}

func (builder *HookBuilder) Md5(attr string) *HookBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hook.SetMd5(attr)
	return builder
}

func (builder *HookBuilder) Name(attr string) *HookBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hook.SetName(attr)
	return builder
}

func (builder *HookBuilder) Href(href string) *HookBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hook.SetHref(href)
	return builder
}

func (builder *HookBuilder) Build() (*Hook, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.hook, nil
}

func (builder *HookBuilder) MustBuild() *Hook {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build Hook instance, reason: %v", builder.err))
	}
	return builder.hook
}

type HostBuilder struct {
	host *Host
	err  error
}

func NewHostBuilder() *HostBuilder {
	return &HostBuilder{host: &Host{}, err: nil}
}

func (builder *HostBuilder) Address(attr string) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	builder.host.SetAddress(attr)
	return builder
}

func (builder *HostBuilder) AffinityLabels(attr *AffinityLabelSlice) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	builder.host.SetAffinityLabels(attr)
	return builder
}

func (builder *HostBuilder) AffinityLabelsOfAny(anys ...*AffinityLabel) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.host.affinityLabels == nil {
		builder.host.affinityLabels = new(AffinityLabelSlice)
	}
	builder.host.affinityLabels.slice = append(builder.host.affinityLabels.slice, anys...)
	return builder
}

func (builder *HostBuilder) AffinityLabelsBuilderOfAny(anyBuilders ...AffinityLabelBuilder) *HostBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.AffinityLabelsOfAny(attr)
	}
	return builder
}

func (builder *HostBuilder) Agents(attr *AgentSlice) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	builder.host.SetAgents(attr)
	return builder
}

func (builder *HostBuilder) AgentsOfAny(anys ...*Agent) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.host.agents == nil {
		builder.host.agents = new(AgentSlice)
	}
	builder.host.agents.slice = append(builder.host.agents.slice, anys...)
	return builder
}

func (builder *HostBuilder) AgentsBuilderOfAny(anyBuilders ...AgentBuilder) *HostBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.AgentsOfAny(attr)
	}
	return builder
}

func (builder *HostBuilder) AutoNumaStatus(attr AutoNumaStatus) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	builder.host.SetAutoNumaStatus(attr)
	return builder
}

func (builder *HostBuilder) Certificate(attr *Certificate) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	builder.host.SetCertificate(attr)
	return builder
}

func (builder *HostBuilder) CertificateBuilder(attrBuilder *CertificateBuilder) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Certificate(attr)
}

func (builder *HostBuilder) Cluster(attr *Cluster) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	builder.host.SetCluster(attr)
	return builder
}

func (builder *HostBuilder) ClusterBuilder(attrBuilder *ClusterBuilder) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Cluster(attr)
}

func (builder *HostBuilder) Comment(attr string) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	builder.host.SetComment(attr)
	return builder
}

func (builder *HostBuilder) Cpu(attr *Cpu) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	builder.host.SetCpu(attr)
	return builder
}

func (builder *HostBuilder) CpuBuilder(attrBuilder *CpuBuilder) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Cpu(attr)
}

func (builder *HostBuilder) Description(attr string) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	builder.host.SetDescription(attr)
	return builder
}

func (builder *HostBuilder) DevicePassthrough(attr *HostDevicePassthrough) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	builder.host.SetDevicePassthrough(attr)
	return builder
}

func (builder *HostBuilder) DevicePassthroughBuilder(attrBuilder *HostDevicePassthroughBuilder) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.DevicePassthrough(attr)
}

func (builder *HostBuilder) Devices(attr *HostDeviceSlice) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	builder.host.SetDevices(attr)
	return builder
}

func (builder *HostBuilder) DevicesOfAny(anys ...*HostDevice) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.host.devices == nil {
		builder.host.devices = new(HostDeviceSlice)
	}
	builder.host.devices.slice = append(builder.host.devices.slice, anys...)
	return builder
}

func (builder *HostBuilder) DevicesBuilderOfAny(anyBuilders ...HostDeviceBuilder) *HostBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.DevicesOfAny(attr)
	}
	return builder
}

func (builder *HostBuilder) Display(attr *Display) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	builder.host.SetDisplay(attr)
	return builder
}

func (builder *HostBuilder) DisplayBuilder(attrBuilder *DisplayBuilder) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Display(attr)
}

func (builder *HostBuilder) ExternalHostProvider(attr *ExternalHostProvider) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	builder.host.SetExternalHostProvider(attr)
	return builder
}

func (builder *HostBuilder) ExternalHostProviderBuilder(attrBuilder *ExternalHostProviderBuilder) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.ExternalHostProvider(attr)
}

func (builder *HostBuilder) ExternalNetworkProviderConfigurations(attr *ExternalNetworkProviderConfigurationSlice) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	builder.host.SetExternalNetworkProviderConfigurations(attr)
	return builder
}

func (builder *HostBuilder) ExternalNetworkProviderConfigurationsOfAny(anys ...*ExternalNetworkProviderConfiguration) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.host.externalNetworkProviderConfigurations == nil {
		builder.host.externalNetworkProviderConfigurations = new(ExternalNetworkProviderConfigurationSlice)
	}
	builder.host.externalNetworkProviderConfigurations.slice = append(builder.host.externalNetworkProviderConfigurations.slice, anys...)
	return builder
}

func (builder *HostBuilder) ExternalNetworkProviderConfigurationsBuilderOfAny(anyBuilders ...ExternalNetworkProviderConfigurationBuilder) *HostBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.ExternalNetworkProviderConfigurationsOfAny(attr)
	}
	return builder
}

func (builder *HostBuilder) ExternalStatus(attr ExternalStatus) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	builder.host.SetExternalStatus(attr)
	return builder
}

func (builder *HostBuilder) HardwareInformation(attr *HardwareInformation) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	builder.host.SetHardwareInformation(attr)
	return builder
}

func (builder *HostBuilder) HardwareInformationBuilder(attrBuilder *HardwareInformationBuilder) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.HardwareInformation(attr)
}

func (builder *HostBuilder) Hooks(attr *HookSlice) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	builder.host.SetHooks(attr)
	return builder
}

func (builder *HostBuilder) HooksOfAny(anys ...*Hook) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.host.hooks == nil {
		builder.host.hooks = new(HookSlice)
	}
	builder.host.hooks.slice = append(builder.host.hooks.slice, anys...)
	return builder
}

func (builder *HostBuilder) HooksBuilderOfAny(anyBuilders ...HookBuilder) *HostBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.HooksOfAny(attr)
	}
	return builder
}

func (builder *HostBuilder) HostedEngine(attr *HostedEngine) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	builder.host.SetHostedEngine(attr)
	return builder
}

func (builder *HostBuilder) HostedEngineBuilder(attrBuilder *HostedEngineBuilder) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.HostedEngine(attr)
}

func (builder *HostBuilder) Id(attr string) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	builder.host.SetId(attr)
	return builder
}

func (builder *HostBuilder) Iscsi(attr *IscsiDetails) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	builder.host.SetIscsi(attr)
	return builder
}

func (builder *HostBuilder) IscsiBuilder(attrBuilder *IscsiDetailsBuilder) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Iscsi(attr)
}

func (builder *HostBuilder) KatelloErrata(attr *KatelloErratumSlice) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	builder.host.SetKatelloErrata(attr)
	return builder
}

func (builder *HostBuilder) KatelloErrataOfAny(anys ...*KatelloErratum) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.host.katelloErrata == nil {
		builder.host.katelloErrata = new(KatelloErratumSlice)
	}
	builder.host.katelloErrata.slice = append(builder.host.katelloErrata.slice, anys...)
	return builder
}

func (builder *HostBuilder) KatelloErrataBuilderOfAny(anyBuilders ...KatelloErratumBuilder) *HostBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.KatelloErrataOfAny(attr)
	}
	return builder
}

func (builder *HostBuilder) KdumpStatus(attr KdumpStatus) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	builder.host.SetKdumpStatus(attr)
	return builder
}

func (builder *HostBuilder) Ksm(attr *Ksm) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	builder.host.SetKsm(attr)
	return builder
}

func (builder *HostBuilder) KsmBuilder(attrBuilder *KsmBuilder) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Ksm(attr)
}

func (builder *HostBuilder) LibvirtVersion(attr *Version) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	builder.host.SetLibvirtVersion(attr)
	return builder
}

func (builder *HostBuilder) LibvirtVersionBuilder(attrBuilder *VersionBuilder) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.LibvirtVersion(attr)
}

func (builder *HostBuilder) MaxSchedulingMemory(attr int64) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	builder.host.SetMaxSchedulingMemory(attr)
	return builder
}

func (builder *HostBuilder) Memory(attr int64) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	builder.host.SetMemory(attr)
	return builder
}

func (builder *HostBuilder) Name(attr string) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	builder.host.SetName(attr)
	return builder
}

func (builder *HostBuilder) NetworkAttachments(attr *NetworkAttachmentSlice) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	builder.host.SetNetworkAttachments(attr)
	return builder
}

func (builder *HostBuilder) NetworkAttachmentsOfAny(anys ...*NetworkAttachment) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.host.networkAttachments == nil {
		builder.host.networkAttachments = new(NetworkAttachmentSlice)
	}
	builder.host.networkAttachments.slice = append(builder.host.networkAttachments.slice, anys...)
	return builder
}

func (builder *HostBuilder) NetworkAttachmentsBuilderOfAny(anyBuilders ...NetworkAttachmentBuilder) *HostBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.NetworkAttachmentsOfAny(attr)
	}
	return builder
}

func (builder *HostBuilder) NetworkOperationInProgress(attr bool) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	builder.host.SetNetworkOperationInProgress(attr)
	return builder
}

func (builder *HostBuilder) Nics(attr *HostNicSlice) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	builder.host.SetNics(attr)
	return builder
}

func (builder *HostBuilder) NicsOfAny(anys ...*HostNic) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.host.nics == nil {
		builder.host.nics = new(HostNicSlice)
	}
	builder.host.nics.slice = append(builder.host.nics.slice, anys...)
	return builder
}

func (builder *HostBuilder) NicsBuilderOfAny(anyBuilders ...HostNicBuilder) *HostBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.NicsOfAny(attr)
	}
	return builder
}

func (builder *HostBuilder) NumaNodes(attr *NumaNodeSlice) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	builder.host.SetNumaNodes(attr)
	return builder
}

func (builder *HostBuilder) NumaNodesOfAny(anys ...*NumaNode) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.host.numaNodes == nil {
		builder.host.numaNodes = new(NumaNodeSlice)
	}
	builder.host.numaNodes.slice = append(builder.host.numaNodes.slice, anys...)
	return builder
}

func (builder *HostBuilder) NumaNodesBuilderOfAny(anyBuilders ...NumaNodeBuilder) *HostBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.NumaNodesOfAny(attr)
	}
	return builder
}

func (builder *HostBuilder) NumaSupported(attr bool) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	builder.host.SetNumaSupported(attr)
	return builder
}

func (builder *HostBuilder) Os(attr *OperatingSystem) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	builder.host.SetOs(attr)
	return builder
}

func (builder *HostBuilder) OsBuilder(attrBuilder *OperatingSystemBuilder) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Os(attr)
}

func (builder *HostBuilder) OverrideIptables(attr bool) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	builder.host.SetOverrideIptables(attr)
	return builder
}

func (builder *HostBuilder) Permissions(attr *PermissionSlice) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	builder.host.SetPermissions(attr)
	return builder
}

func (builder *HostBuilder) PermissionsOfAny(anys ...*Permission) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.host.permissions == nil {
		builder.host.permissions = new(PermissionSlice)
	}
	builder.host.permissions.slice = append(builder.host.permissions.slice, anys...)
	return builder
}

func (builder *HostBuilder) PermissionsBuilderOfAny(anyBuilders ...PermissionBuilder) *HostBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.PermissionsOfAny(attr)
	}
	return builder
}

func (builder *HostBuilder) Port(attr int64) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	builder.host.SetPort(attr)
	return builder
}

func (builder *HostBuilder) PowerManagement(attr *PowerManagement) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	builder.host.SetPowerManagement(attr)
	return builder
}

func (builder *HostBuilder) PowerManagementBuilder(attrBuilder *PowerManagementBuilder) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.PowerManagement(attr)
}

func (builder *HostBuilder) Protocol(attr HostProtocol) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	builder.host.SetProtocol(attr)
	return builder
}

func (builder *HostBuilder) ReinstallationRequired(attr bool) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	builder.host.SetReinstallationRequired(attr)
	return builder
}

func (builder *HostBuilder) RootPassword(attr string) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	builder.host.SetRootPassword(attr)
	return builder
}

func (builder *HostBuilder) SeLinux(attr *SeLinux) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	builder.host.SetSeLinux(attr)
	return builder
}

func (builder *HostBuilder) SeLinuxBuilder(attrBuilder *SeLinuxBuilder) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.SeLinux(attr)
}

func (builder *HostBuilder) Spm(attr *Spm) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	builder.host.SetSpm(attr)
	return builder
}

func (builder *HostBuilder) SpmBuilder(attrBuilder *SpmBuilder) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Spm(attr)
}

func (builder *HostBuilder) Ssh(attr *Ssh) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	builder.host.SetSsh(attr)
	return builder
}

func (builder *HostBuilder) SshBuilder(attrBuilder *SshBuilder) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Ssh(attr)
}

func (builder *HostBuilder) Statistics(attr *StatisticSlice) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	builder.host.SetStatistics(attr)
	return builder
}

func (builder *HostBuilder) StatisticsOfAny(anys ...*Statistic) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.host.statistics == nil {
		builder.host.statistics = new(StatisticSlice)
	}
	builder.host.statistics.slice = append(builder.host.statistics.slice, anys...)
	return builder
}

func (builder *HostBuilder) StatisticsBuilderOfAny(anyBuilders ...StatisticBuilder) *HostBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.StatisticsOfAny(attr)
	}
	return builder
}

func (builder *HostBuilder) Status(attr HostStatus) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	builder.host.SetStatus(attr)
	return builder
}

func (builder *HostBuilder) StatusDetail(attr string) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	builder.host.SetStatusDetail(attr)
	return builder
}

func (builder *HostBuilder) StorageConnectionExtensions(attr *StorageConnectionExtensionSlice) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	builder.host.SetStorageConnectionExtensions(attr)
	return builder
}

func (builder *HostBuilder) StorageConnectionExtensionsOfAny(anys ...*StorageConnectionExtension) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.host.storageConnectionExtensions == nil {
		builder.host.storageConnectionExtensions = new(StorageConnectionExtensionSlice)
	}
	builder.host.storageConnectionExtensions.slice = append(builder.host.storageConnectionExtensions.slice, anys...)
	return builder
}

func (builder *HostBuilder) StorageConnectionExtensionsBuilderOfAny(anyBuilders ...StorageConnectionExtensionBuilder) *HostBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.StorageConnectionExtensionsOfAny(attr)
	}
	return builder
}

func (builder *HostBuilder) Storages(attr *HostStorageSlice) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	builder.host.SetStorages(attr)
	return builder
}

func (builder *HostBuilder) StoragesOfAny(anys ...*HostStorage) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.host.storages == nil {
		builder.host.storages = new(HostStorageSlice)
	}
	builder.host.storages.slice = append(builder.host.storages.slice, anys...)
	return builder
}

func (builder *HostBuilder) StoragesBuilderOfAny(anyBuilders ...HostStorageBuilder) *HostBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.StoragesOfAny(attr)
	}
	return builder
}

func (builder *HostBuilder) Summary(attr *VmSummary) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	builder.host.SetSummary(attr)
	return builder
}

func (builder *HostBuilder) SummaryBuilder(attrBuilder *VmSummaryBuilder) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Summary(attr)
}

func (builder *HostBuilder) Tags(attr *TagSlice) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	builder.host.SetTags(attr)
	return builder
}

func (builder *HostBuilder) TagsOfAny(anys ...*Tag) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.host.tags == nil {
		builder.host.tags = new(TagSlice)
	}
	builder.host.tags.slice = append(builder.host.tags.slice, anys...)
	return builder
}

func (builder *HostBuilder) TagsBuilderOfAny(anyBuilders ...TagBuilder) *HostBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.TagsOfAny(attr)
	}
	return builder
}

func (builder *HostBuilder) TransparentHugePages(attr *TransparentHugePages) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	builder.host.SetTransparentHugePages(attr)
	return builder
}

func (builder *HostBuilder) TransparentHugePagesBuilder(attrBuilder *TransparentHugePagesBuilder) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.TransparentHugePages(attr)
}

func (builder *HostBuilder) Type(attr HostType) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	builder.host.SetType(attr)
	return builder
}

func (builder *HostBuilder) UnmanagedNetworks(attr *UnmanagedNetworkSlice) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	builder.host.SetUnmanagedNetworks(attr)
	return builder
}

func (builder *HostBuilder) UnmanagedNetworksOfAny(anys ...*UnmanagedNetwork) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.host.unmanagedNetworks == nil {
		builder.host.unmanagedNetworks = new(UnmanagedNetworkSlice)
	}
	builder.host.unmanagedNetworks.slice = append(builder.host.unmanagedNetworks.slice, anys...)
	return builder
}

func (builder *HostBuilder) UnmanagedNetworksBuilderOfAny(anyBuilders ...UnmanagedNetworkBuilder) *HostBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.UnmanagedNetworksOfAny(attr)
	}
	return builder
}

func (builder *HostBuilder) UpdateAvailable(attr bool) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	builder.host.SetUpdateAvailable(attr)
	return builder
}

func (builder *HostBuilder) Version(attr *Version) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	builder.host.SetVersion(attr)
	return builder
}

func (builder *HostBuilder) VersionBuilder(attrBuilder *VersionBuilder) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Version(attr)
}

func (builder *HostBuilder) VgpuPlacement(attr VgpuPlacement) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	builder.host.SetVgpuPlacement(attr)
	return builder
}

func (builder *HostBuilder) Href(href string) *HostBuilder {
	if builder.err != nil {
		return builder
	}

	builder.host.SetHref(href)
	return builder
}

func (builder *HostBuilder) Build() (*Host, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.host, nil
}

func (builder *HostBuilder) MustBuild() *Host {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build Host instance, reason: %v", builder.err))
	}
	return builder.host
}

type HostDeviceBuilder struct {
	hostDevice *HostDevice
	err        error
}

func NewHostDeviceBuilder() *HostDeviceBuilder {
	return &HostDeviceBuilder{hostDevice: &HostDevice{}, err: nil}
}

func (builder *HostDeviceBuilder) Capability(attr string) *HostDeviceBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostDevice.SetCapability(attr)
	return builder
}

func (builder *HostDeviceBuilder) Comment(attr string) *HostDeviceBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostDevice.SetComment(attr)
	return builder
}

func (builder *HostDeviceBuilder) Description(attr string) *HostDeviceBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostDevice.SetDescription(attr)
	return builder
}

func (builder *HostDeviceBuilder) Driver(attr string) *HostDeviceBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostDevice.SetDriver(attr)
	return builder
}

func (builder *HostDeviceBuilder) Host(attr *Host) *HostDeviceBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostDevice.SetHost(attr)
	return builder
}

func (builder *HostDeviceBuilder) HostBuilder(attrBuilder *HostBuilder) *HostDeviceBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Host(attr)
}

func (builder *HostDeviceBuilder) Id(attr string) *HostDeviceBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostDevice.SetId(attr)
	return builder
}

func (builder *HostDeviceBuilder) IommuGroup(attr int64) *HostDeviceBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostDevice.SetIommuGroup(attr)
	return builder
}

func (builder *HostDeviceBuilder) MDevTypes(attr *MDevTypeSlice) *HostDeviceBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostDevice.SetMDevTypes(attr)
	return builder
}

func (builder *HostDeviceBuilder) MDevTypesOfAny(anys ...*MDevType) *HostDeviceBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.hostDevice.mDevTypes == nil {
		builder.hostDevice.mDevTypes = new(MDevTypeSlice)
	}
	builder.hostDevice.mDevTypes.slice = append(builder.hostDevice.mDevTypes.slice, anys...)
	return builder
}

func (builder *HostDeviceBuilder) MDevTypesBuilderOfAny(anyBuilders ...MDevTypeBuilder) *HostDeviceBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.MDevTypesOfAny(attr)
	}
	return builder
}

func (builder *HostDeviceBuilder) Name(attr string) *HostDeviceBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostDevice.SetName(attr)
	return builder
}

func (builder *HostDeviceBuilder) ParentDevice(attr *HostDevice) *HostDeviceBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostDevice.SetParentDevice(attr)
	return builder
}

func (builder *HostDeviceBuilder) ParentDeviceBuilder(attrBuilder *HostDeviceBuilder) *HostDeviceBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.ParentDevice(attr)
}

func (builder *HostDeviceBuilder) PhysicalFunction(attr *HostDevice) *HostDeviceBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostDevice.SetPhysicalFunction(attr)
	return builder
}

func (builder *HostDeviceBuilder) PhysicalFunctionBuilder(attrBuilder *HostDeviceBuilder) *HostDeviceBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.PhysicalFunction(attr)
}

func (builder *HostDeviceBuilder) Placeholder(attr bool) *HostDeviceBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostDevice.SetPlaceholder(attr)
	return builder
}

func (builder *HostDeviceBuilder) Product(attr *Product) *HostDeviceBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostDevice.SetProduct(attr)
	return builder
}

func (builder *HostDeviceBuilder) ProductBuilder(attrBuilder *ProductBuilder) *HostDeviceBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Product(attr)
}

func (builder *HostDeviceBuilder) Vendor(attr *Vendor) *HostDeviceBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostDevice.SetVendor(attr)
	return builder
}

func (builder *HostDeviceBuilder) VendorBuilder(attrBuilder *VendorBuilder) *HostDeviceBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Vendor(attr)
}

func (builder *HostDeviceBuilder) VirtualFunctions(attr int64) *HostDeviceBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostDevice.SetVirtualFunctions(attr)
	return builder
}

func (builder *HostDeviceBuilder) Vm(attr *Vm) *HostDeviceBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostDevice.SetVm(attr)
	return builder
}

func (builder *HostDeviceBuilder) VmBuilder(attrBuilder *VmBuilder) *HostDeviceBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Vm(attr)
}

func (builder *HostDeviceBuilder) Href(href string) *HostDeviceBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostDevice.SetHref(href)
	return builder
}

func (builder *HostDeviceBuilder) Build() (*HostDevice, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.hostDevice, nil
}

func (builder *HostDeviceBuilder) MustBuild() *HostDevice {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build HostDevice instance, reason: %v", builder.err))
	}
	return builder.hostDevice
}

type HostDevicePassthroughBuilder struct {
	hostDevicePassthrough *HostDevicePassthrough
	err                   error
}

func NewHostDevicePassthroughBuilder() *HostDevicePassthroughBuilder {
	return &HostDevicePassthroughBuilder{hostDevicePassthrough: &HostDevicePassthrough{}, err: nil}
}

func (builder *HostDevicePassthroughBuilder) Enabled(attr bool) *HostDevicePassthroughBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostDevicePassthrough.SetEnabled(attr)
	return builder
}

func (builder *HostDevicePassthroughBuilder) Href(href string) *HostDevicePassthroughBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostDevicePassthrough.SetHref(href)
	return builder
}

func (builder *HostDevicePassthroughBuilder) Build() (*HostDevicePassthrough, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.hostDevicePassthrough, nil
}

func (builder *HostDevicePassthroughBuilder) MustBuild() *HostDevicePassthrough {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build HostDevicePassthrough instance, reason: %v", builder.err))
	}
	return builder.hostDevicePassthrough
}

type HostNicBuilder struct {
	hostNic *HostNic
	err     error
}

func NewHostNicBuilder() *HostNicBuilder {
	return &HostNicBuilder{hostNic: &HostNic{}, err: nil}
}

func (builder *HostNicBuilder) AdAggregatorId(attr int64) *HostNicBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostNic.SetAdAggregatorId(attr)
	return builder
}

func (builder *HostNicBuilder) BaseInterface(attr string) *HostNicBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostNic.SetBaseInterface(attr)
	return builder
}

func (builder *HostNicBuilder) Bonding(attr *Bonding) *HostNicBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostNic.SetBonding(attr)
	return builder
}

func (builder *HostNicBuilder) BondingBuilder(attrBuilder *BondingBuilder) *HostNicBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Bonding(attr)
}

func (builder *HostNicBuilder) BootProtocol(attr BootProtocol) *HostNicBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostNic.SetBootProtocol(attr)
	return builder
}

func (builder *HostNicBuilder) Bridged(attr bool) *HostNicBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostNic.SetBridged(attr)
	return builder
}

func (builder *HostNicBuilder) CheckConnectivity(attr bool) *HostNicBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostNic.SetCheckConnectivity(attr)
	return builder
}

func (builder *HostNicBuilder) Comment(attr string) *HostNicBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostNic.SetComment(attr)
	return builder
}

func (builder *HostNicBuilder) CustomConfiguration(attr bool) *HostNicBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostNic.SetCustomConfiguration(attr)
	return builder
}

func (builder *HostNicBuilder) Description(attr string) *HostNicBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostNic.SetDescription(attr)
	return builder
}

func (builder *HostNicBuilder) Host(attr *Host) *HostNicBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostNic.SetHost(attr)
	return builder
}

func (builder *HostNicBuilder) HostBuilder(attrBuilder *HostBuilder) *HostNicBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Host(attr)
}

func (builder *HostNicBuilder) Id(attr string) *HostNicBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostNic.SetId(attr)
	return builder
}

func (builder *HostNicBuilder) Ip(attr *Ip) *HostNicBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostNic.SetIp(attr)
	return builder
}

func (builder *HostNicBuilder) IpBuilder(attrBuilder *IpBuilder) *HostNicBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Ip(attr)
}

func (builder *HostNicBuilder) Ipv6(attr *Ip) *HostNicBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostNic.SetIpv6(attr)
	return builder
}

func (builder *HostNicBuilder) Ipv6Builder(attrBuilder *IpBuilder) *HostNicBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Ipv6(attr)
}

func (builder *HostNicBuilder) Ipv6BootProtocol(attr BootProtocol) *HostNicBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostNic.SetIpv6BootProtocol(attr)
	return builder
}

func (builder *HostNicBuilder) Mac(attr *Mac) *HostNicBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostNic.SetMac(attr)
	return builder
}

func (builder *HostNicBuilder) MacBuilder(attrBuilder *MacBuilder) *HostNicBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Mac(attr)
}

func (builder *HostNicBuilder) Mtu(attr int64) *HostNicBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostNic.SetMtu(attr)
	return builder
}

func (builder *HostNicBuilder) Name(attr string) *HostNicBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostNic.SetName(attr)
	return builder
}

func (builder *HostNicBuilder) Network(attr *Network) *HostNicBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostNic.SetNetwork(attr)
	return builder
}

func (builder *HostNicBuilder) NetworkBuilder(attrBuilder *NetworkBuilder) *HostNicBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Network(attr)
}

func (builder *HostNicBuilder) NetworkLabels(attr *NetworkLabelSlice) *HostNicBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostNic.SetNetworkLabels(attr)
	return builder
}

func (builder *HostNicBuilder) NetworkLabelsOfAny(anys ...*NetworkLabel) *HostNicBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.hostNic.networkLabels == nil {
		builder.hostNic.networkLabels = new(NetworkLabelSlice)
	}
	builder.hostNic.networkLabels.slice = append(builder.hostNic.networkLabels.slice, anys...)
	return builder
}

func (builder *HostNicBuilder) NetworkLabelsBuilderOfAny(anyBuilders ...NetworkLabelBuilder) *HostNicBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.NetworkLabelsOfAny(attr)
	}
	return builder
}

func (builder *HostNicBuilder) OverrideConfiguration(attr bool) *HostNicBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostNic.SetOverrideConfiguration(attr)
	return builder
}

func (builder *HostNicBuilder) PhysicalFunction(attr *HostNic) *HostNicBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostNic.SetPhysicalFunction(attr)
	return builder
}

func (builder *HostNicBuilder) PhysicalFunctionBuilder(attrBuilder *HostNicBuilder) *HostNicBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.PhysicalFunction(attr)
}

func (builder *HostNicBuilder) Properties(attr *PropertySlice) *HostNicBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostNic.SetProperties(attr)
	return builder
}

func (builder *HostNicBuilder) PropertiesOfAny(anys ...*Property) *HostNicBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.hostNic.properties == nil {
		builder.hostNic.properties = new(PropertySlice)
	}
	builder.hostNic.properties.slice = append(builder.hostNic.properties.slice, anys...)
	return builder
}

func (builder *HostNicBuilder) PropertiesBuilderOfAny(anyBuilders ...PropertyBuilder) *HostNicBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.PropertiesOfAny(attr)
	}
	return builder
}

func (builder *HostNicBuilder) Qos(attr *Qos) *HostNicBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostNic.SetQos(attr)
	return builder
}

func (builder *HostNicBuilder) QosBuilder(attrBuilder *QosBuilder) *HostNicBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Qos(attr)
}

func (builder *HostNicBuilder) Speed(attr int64) *HostNicBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostNic.SetSpeed(attr)
	return builder
}

func (builder *HostNicBuilder) Statistics(attr *StatisticSlice) *HostNicBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostNic.SetStatistics(attr)
	return builder
}

func (builder *HostNicBuilder) StatisticsOfAny(anys ...*Statistic) *HostNicBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.hostNic.statistics == nil {
		builder.hostNic.statistics = new(StatisticSlice)
	}
	builder.hostNic.statistics.slice = append(builder.hostNic.statistics.slice, anys...)
	return builder
}

func (builder *HostNicBuilder) StatisticsBuilderOfAny(anyBuilders ...StatisticBuilder) *HostNicBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.StatisticsOfAny(attr)
	}
	return builder
}

func (builder *HostNicBuilder) Status(attr NicStatus) *HostNicBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostNic.SetStatus(attr)
	return builder
}

func (builder *HostNicBuilder) VirtualFunctionsConfiguration(attr *HostNicVirtualFunctionsConfiguration) *HostNicBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostNic.SetVirtualFunctionsConfiguration(attr)
	return builder
}

func (builder *HostNicBuilder) VirtualFunctionsConfigurationBuilder(attrBuilder *HostNicVirtualFunctionsConfigurationBuilder) *HostNicBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.VirtualFunctionsConfiguration(attr)
}

func (builder *HostNicBuilder) Vlan(attr *Vlan) *HostNicBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostNic.SetVlan(attr)
	return builder
}

func (builder *HostNicBuilder) VlanBuilder(attrBuilder *VlanBuilder) *HostNicBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Vlan(attr)
}

func (builder *HostNicBuilder) Href(href string) *HostNicBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostNic.SetHref(href)
	return builder
}

func (builder *HostNicBuilder) Build() (*HostNic, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.hostNic, nil
}

func (builder *HostNicBuilder) MustBuild() *HostNic {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build HostNic instance, reason: %v", builder.err))
	}
	return builder.hostNic
}

type HostNicVirtualFunctionsConfigurationBuilder struct {
	hostNicVirtualFunctionsConfiguration *HostNicVirtualFunctionsConfiguration
	err                                  error
}

func NewHostNicVirtualFunctionsConfigurationBuilder() *HostNicVirtualFunctionsConfigurationBuilder {
	return &HostNicVirtualFunctionsConfigurationBuilder{hostNicVirtualFunctionsConfiguration: &HostNicVirtualFunctionsConfiguration{}, err: nil}
}

func (builder *HostNicVirtualFunctionsConfigurationBuilder) AllNetworksAllowed(attr bool) *HostNicVirtualFunctionsConfigurationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostNicVirtualFunctionsConfiguration.SetAllNetworksAllowed(attr)
	return builder
}

func (builder *HostNicVirtualFunctionsConfigurationBuilder) MaxNumberOfVirtualFunctions(attr int64) *HostNicVirtualFunctionsConfigurationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostNicVirtualFunctionsConfiguration.SetMaxNumberOfVirtualFunctions(attr)
	return builder
}

func (builder *HostNicVirtualFunctionsConfigurationBuilder) NumberOfVirtualFunctions(attr int64) *HostNicVirtualFunctionsConfigurationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostNicVirtualFunctionsConfiguration.SetNumberOfVirtualFunctions(attr)
	return builder
}

func (builder *HostNicVirtualFunctionsConfigurationBuilder) Href(href string) *HostNicVirtualFunctionsConfigurationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostNicVirtualFunctionsConfiguration.SetHref(href)
	return builder
}

func (builder *HostNicVirtualFunctionsConfigurationBuilder) Build() (*HostNicVirtualFunctionsConfiguration, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.hostNicVirtualFunctionsConfiguration, nil
}

func (builder *HostNicVirtualFunctionsConfigurationBuilder) MustBuild() *HostNicVirtualFunctionsConfiguration {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build HostNicVirtualFunctionsConfiguration instance, reason: %v", builder.err))
	}
	return builder.hostNicVirtualFunctionsConfiguration
}

type HostStorageBuilder struct {
	hostStorage *HostStorage
	err         error
}

func NewHostStorageBuilder() *HostStorageBuilder {
	return &HostStorageBuilder{hostStorage: &HostStorage{}, err: nil}
}

func (builder *HostStorageBuilder) Address(attr string) *HostStorageBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostStorage.SetAddress(attr)
	return builder
}

func (builder *HostStorageBuilder) Comment(attr string) *HostStorageBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostStorage.SetComment(attr)
	return builder
}

func (builder *HostStorageBuilder) Description(attr string) *HostStorageBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostStorage.SetDescription(attr)
	return builder
}

func (builder *HostStorageBuilder) DriverOptions(attr *PropertySlice) *HostStorageBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostStorage.SetDriverOptions(attr)
	return builder
}

func (builder *HostStorageBuilder) DriverOptionsOfAny(anys ...*Property) *HostStorageBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.hostStorage.driverOptions == nil {
		builder.hostStorage.driverOptions = new(PropertySlice)
	}
	builder.hostStorage.driverOptions.slice = append(builder.hostStorage.driverOptions.slice, anys...)
	return builder
}

func (builder *HostStorageBuilder) DriverOptionsBuilderOfAny(anyBuilders ...PropertyBuilder) *HostStorageBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.DriverOptionsOfAny(attr)
	}
	return builder
}

func (builder *HostStorageBuilder) DriverSensitiveOptions(attr *PropertySlice) *HostStorageBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostStorage.SetDriverSensitiveOptions(attr)
	return builder
}

func (builder *HostStorageBuilder) DriverSensitiveOptionsOfAny(anys ...*Property) *HostStorageBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.hostStorage.driverSensitiveOptions == nil {
		builder.hostStorage.driverSensitiveOptions = new(PropertySlice)
	}
	builder.hostStorage.driverSensitiveOptions.slice = append(builder.hostStorage.driverSensitiveOptions.slice, anys...)
	return builder
}

func (builder *HostStorageBuilder) DriverSensitiveOptionsBuilderOfAny(anyBuilders ...PropertyBuilder) *HostStorageBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.DriverSensitiveOptionsOfAny(attr)
	}
	return builder
}

func (builder *HostStorageBuilder) Host(attr *Host) *HostStorageBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostStorage.SetHost(attr)
	return builder
}

func (builder *HostStorageBuilder) HostBuilder(attrBuilder *HostBuilder) *HostStorageBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Host(attr)
}

func (builder *HostStorageBuilder) Id(attr string) *HostStorageBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostStorage.SetId(attr)
	return builder
}

func (builder *HostStorageBuilder) LogicalUnits(attr *LogicalUnitSlice) *HostStorageBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostStorage.SetLogicalUnits(attr)
	return builder
}

func (builder *HostStorageBuilder) LogicalUnitsOfAny(anys ...*LogicalUnit) *HostStorageBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.hostStorage.logicalUnits == nil {
		builder.hostStorage.logicalUnits = new(LogicalUnitSlice)
	}
	builder.hostStorage.logicalUnits.slice = append(builder.hostStorage.logicalUnits.slice, anys...)
	return builder
}

func (builder *HostStorageBuilder) LogicalUnitsBuilderOfAny(anyBuilders ...LogicalUnitBuilder) *HostStorageBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.LogicalUnitsOfAny(attr)
	}
	return builder
}

func (builder *HostStorageBuilder) MountOptions(attr string) *HostStorageBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostStorage.SetMountOptions(attr)
	return builder
}

func (builder *HostStorageBuilder) Name(attr string) *HostStorageBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostStorage.SetName(attr)
	return builder
}

func (builder *HostStorageBuilder) NfsRetrans(attr int64) *HostStorageBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostStorage.SetNfsRetrans(attr)
	return builder
}

func (builder *HostStorageBuilder) NfsTimeo(attr int64) *HostStorageBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostStorage.SetNfsTimeo(attr)
	return builder
}

func (builder *HostStorageBuilder) NfsVersion(attr NfsVersion) *HostStorageBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostStorage.SetNfsVersion(attr)
	return builder
}

func (builder *HostStorageBuilder) OverrideLuns(attr bool) *HostStorageBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostStorage.SetOverrideLuns(attr)
	return builder
}

func (builder *HostStorageBuilder) Password(attr string) *HostStorageBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostStorage.SetPassword(attr)
	return builder
}

func (builder *HostStorageBuilder) Path(attr string) *HostStorageBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostStorage.SetPath(attr)
	return builder
}

func (builder *HostStorageBuilder) Port(attr int64) *HostStorageBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostStorage.SetPort(attr)
	return builder
}

func (builder *HostStorageBuilder) Portal(attr string) *HostStorageBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostStorage.SetPortal(attr)
	return builder
}

func (builder *HostStorageBuilder) Target(attr string) *HostStorageBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostStorage.SetTarget(attr)
	return builder
}

func (builder *HostStorageBuilder) Type(attr StorageType) *HostStorageBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostStorage.SetType(attr)
	return builder
}

func (builder *HostStorageBuilder) Username(attr string) *HostStorageBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostStorage.SetUsername(attr)
	return builder
}

func (builder *HostStorageBuilder) VfsType(attr string) *HostStorageBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostStorage.SetVfsType(attr)
	return builder
}

func (builder *HostStorageBuilder) VolumeGroup(attr *VolumeGroup) *HostStorageBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostStorage.SetVolumeGroup(attr)
	return builder
}

func (builder *HostStorageBuilder) VolumeGroupBuilder(attrBuilder *VolumeGroupBuilder) *HostStorageBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.VolumeGroup(attr)
}

func (builder *HostStorageBuilder) Href(href string) *HostStorageBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostStorage.SetHref(href)
	return builder
}

func (builder *HostStorageBuilder) Build() (*HostStorage, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.hostStorage, nil
}

func (builder *HostStorageBuilder) MustBuild() *HostStorage {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build HostStorage instance, reason: %v", builder.err))
	}
	return builder.hostStorage
}

type HostedEngineBuilder struct {
	hostedEngine *HostedEngine
	err          error
}

func NewHostedEngineBuilder() *HostedEngineBuilder {
	return &HostedEngineBuilder{hostedEngine: &HostedEngine{}, err: nil}
}

func (builder *HostedEngineBuilder) Active(attr bool) *HostedEngineBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostedEngine.SetActive(attr)
	return builder
}

func (builder *HostedEngineBuilder) Configured(attr bool) *HostedEngineBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostedEngine.SetConfigured(attr)
	return builder
}

func (builder *HostedEngineBuilder) GlobalMaintenance(attr bool) *HostedEngineBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostedEngine.SetGlobalMaintenance(attr)
	return builder
}

func (builder *HostedEngineBuilder) LocalMaintenance(attr bool) *HostedEngineBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostedEngine.SetLocalMaintenance(attr)
	return builder
}

func (builder *HostedEngineBuilder) Score(attr int64) *HostedEngineBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostedEngine.SetScore(attr)
	return builder
}

func (builder *HostedEngineBuilder) Href(href string) *HostedEngineBuilder {
	if builder.err != nil {
		return builder
	}

	builder.hostedEngine.SetHref(href)
	return builder
}

func (builder *HostedEngineBuilder) Build() (*HostedEngine, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.hostedEngine, nil
}

func (builder *HostedEngineBuilder) MustBuild() *HostedEngine {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build HostedEngine instance, reason: %v", builder.err))
	}
	return builder.hostedEngine
}

type IconBuilder struct {
	icon *Icon
	err  error
}

func NewIconBuilder() *IconBuilder {
	return &IconBuilder{icon: &Icon{}, err: nil}
}

func (builder *IconBuilder) Comment(attr string) *IconBuilder {
	if builder.err != nil {
		return builder
	}

	builder.icon.SetComment(attr)
	return builder
}

func (builder *IconBuilder) Data(attr string) *IconBuilder {
	if builder.err != nil {
		return builder
	}

	builder.icon.SetData(attr)
	return builder
}

func (builder *IconBuilder) Description(attr string) *IconBuilder {
	if builder.err != nil {
		return builder
	}

	builder.icon.SetDescription(attr)
	return builder
}

func (builder *IconBuilder) Id(attr string) *IconBuilder {
	if builder.err != nil {
		return builder
	}

	builder.icon.SetId(attr)
	return builder
}

func (builder *IconBuilder) MediaType(attr string) *IconBuilder {
	if builder.err != nil {
		return builder
	}

	builder.icon.SetMediaType(attr)
	return builder
}

func (builder *IconBuilder) Name(attr string) *IconBuilder {
	if builder.err != nil {
		return builder
	}

	builder.icon.SetName(attr)
	return builder
}

func (builder *IconBuilder) Href(href string) *IconBuilder {
	if builder.err != nil {
		return builder
	}

	builder.icon.SetHref(href)
	return builder
}

func (builder *IconBuilder) Build() (*Icon, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.icon, nil
}

func (builder *IconBuilder) MustBuild() *Icon {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build Icon instance, reason: %v", builder.err))
	}
	return builder.icon
}

type IdentifiedBuilder struct {
	identified *Identified
	err        error
}

func NewIdentifiedBuilder() *IdentifiedBuilder {
	return &IdentifiedBuilder{identified: &Identified{}, err: nil}
}

func (builder *IdentifiedBuilder) Comment(attr string) *IdentifiedBuilder {
	if builder.err != nil {
		return builder
	}

	builder.identified.SetComment(attr)
	return builder
}

func (builder *IdentifiedBuilder) Description(attr string) *IdentifiedBuilder {
	if builder.err != nil {
		return builder
	}

	builder.identified.SetDescription(attr)
	return builder
}

func (builder *IdentifiedBuilder) Id(attr string) *IdentifiedBuilder {
	if builder.err != nil {
		return builder
	}

	builder.identified.SetId(attr)
	return builder
}

func (builder *IdentifiedBuilder) Name(attr string) *IdentifiedBuilder {
	if builder.err != nil {
		return builder
	}

	builder.identified.SetName(attr)
	return builder
}

func (builder *IdentifiedBuilder) Href(href string) *IdentifiedBuilder {
	if builder.err != nil {
		return builder
	}

	builder.identified.SetHref(href)
	return builder
}

func (builder *IdentifiedBuilder) Build() (*Identified, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.identified, nil
}

func (builder *IdentifiedBuilder) MustBuild() *Identified {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build Identified instance, reason: %v", builder.err))
	}
	return builder.identified
}

type ImageBuilder struct {
	image *Image
	err   error
}

func NewImageBuilder() *ImageBuilder {
	return &ImageBuilder{image: &Image{}, err: nil}
}

func (builder *ImageBuilder) Comment(attr string) *ImageBuilder {
	if builder.err != nil {
		return builder
	}

	builder.image.SetComment(attr)
	return builder
}

func (builder *ImageBuilder) Description(attr string) *ImageBuilder {
	if builder.err != nil {
		return builder
	}

	builder.image.SetDescription(attr)
	return builder
}

func (builder *ImageBuilder) Id(attr string) *ImageBuilder {
	if builder.err != nil {
		return builder
	}

	builder.image.SetId(attr)
	return builder
}

func (builder *ImageBuilder) Name(attr string) *ImageBuilder {
	if builder.err != nil {
		return builder
	}

	builder.image.SetName(attr)
	return builder
}

func (builder *ImageBuilder) Size(attr int64) *ImageBuilder {
	if builder.err != nil {
		return builder
	}

	builder.image.SetSize(attr)
	return builder
}

func (builder *ImageBuilder) StorageDomain(attr *StorageDomain) *ImageBuilder {
	if builder.err != nil {
		return builder
	}

	builder.image.SetStorageDomain(attr)
	return builder
}

func (builder *ImageBuilder) StorageDomainBuilder(attrBuilder *StorageDomainBuilder) *ImageBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.StorageDomain(attr)
}

func (builder *ImageBuilder) Type(attr ImageFileType) *ImageBuilder {
	if builder.err != nil {
		return builder
	}

	builder.image.SetType(attr)
	return builder
}

func (builder *ImageBuilder) Href(href string) *ImageBuilder {
	if builder.err != nil {
		return builder
	}

	builder.image.SetHref(href)
	return builder
}

func (builder *ImageBuilder) Build() (*Image, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.image, nil
}

func (builder *ImageBuilder) MustBuild() *Image {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build Image instance, reason: %v", builder.err))
	}
	return builder.image
}

type ImageTransferBuilder struct {
	imageTransfer *ImageTransfer
	err           error
}

func NewImageTransferBuilder() *ImageTransferBuilder {
	return &ImageTransferBuilder{imageTransfer: &ImageTransfer{}, err: nil}
}

func (builder *ImageTransferBuilder) Active(attr bool) *ImageTransferBuilder {
	if builder.err != nil {
		return builder
	}

	builder.imageTransfer.SetActive(attr)
	return builder
}

func (builder *ImageTransferBuilder) Backup(attr *Backup) *ImageTransferBuilder {
	if builder.err != nil {
		return builder
	}

	builder.imageTransfer.SetBackup(attr)
	return builder
}

func (builder *ImageTransferBuilder) BackupBuilder(attrBuilder *BackupBuilder) *ImageTransferBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Backup(attr)
}

func (builder *ImageTransferBuilder) Comment(attr string) *ImageTransferBuilder {
	if builder.err != nil {
		return builder
	}

	builder.imageTransfer.SetComment(attr)
	return builder
}

func (builder *ImageTransferBuilder) Description(attr string) *ImageTransferBuilder {
	if builder.err != nil {
		return builder
	}

	builder.imageTransfer.SetDescription(attr)
	return builder
}

func (builder *ImageTransferBuilder) Direction(attr ImageTransferDirection) *ImageTransferBuilder {
	if builder.err != nil {
		return builder
	}

	builder.imageTransfer.SetDirection(attr)
	return builder
}

func (builder *ImageTransferBuilder) Disk(attr *Disk) *ImageTransferBuilder {
	if builder.err != nil {
		return builder
	}

	builder.imageTransfer.SetDisk(attr)
	return builder
}

func (builder *ImageTransferBuilder) DiskBuilder(attrBuilder *DiskBuilder) *ImageTransferBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Disk(attr)
}

func (builder *ImageTransferBuilder) Format(attr DiskFormat) *ImageTransferBuilder {
	if builder.err != nil {
		return builder
	}

	builder.imageTransfer.SetFormat(attr)
	return builder
}

func (builder *ImageTransferBuilder) Host(attr *Host) *ImageTransferBuilder {
	if builder.err != nil {
		return builder
	}

	builder.imageTransfer.SetHost(attr)
	return builder
}

func (builder *ImageTransferBuilder) HostBuilder(attrBuilder *HostBuilder) *ImageTransferBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Host(attr)
}

func (builder *ImageTransferBuilder) Id(attr string) *ImageTransferBuilder {
	if builder.err != nil {
		return builder
	}

	builder.imageTransfer.SetId(attr)
	return builder
}

func (builder *ImageTransferBuilder) Image(attr *Image) *ImageTransferBuilder {
	if builder.err != nil {
		return builder
	}

	builder.imageTransfer.SetImage(attr)
	return builder
}

func (builder *ImageTransferBuilder) ImageBuilder(attrBuilder *ImageBuilder) *ImageTransferBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Image(attr)
}

func (builder *ImageTransferBuilder) InactivityTimeout(attr int64) *ImageTransferBuilder {
	if builder.err != nil {
		return builder
	}

	builder.imageTransfer.SetInactivityTimeout(attr)
	return builder
}

func (builder *ImageTransferBuilder) Name(attr string) *ImageTransferBuilder {
	if builder.err != nil {
		return builder
	}

	builder.imageTransfer.SetName(attr)
	return builder
}

func (builder *ImageTransferBuilder) Phase(attr ImageTransferPhase) *ImageTransferBuilder {
	if builder.err != nil {
		return builder
	}

	builder.imageTransfer.SetPhase(attr)
	return builder
}

func (builder *ImageTransferBuilder) ProxyUrl(attr string) *ImageTransferBuilder {
	if builder.err != nil {
		return builder
	}

	builder.imageTransfer.SetProxyUrl(attr)
	return builder
}

func (builder *ImageTransferBuilder) Shallow(attr bool) *ImageTransferBuilder {
	if builder.err != nil {
		return builder
	}

	builder.imageTransfer.SetShallow(attr)
	return builder
}

func (builder *ImageTransferBuilder) Snapshot(attr *DiskSnapshot) *ImageTransferBuilder {
	if builder.err != nil {
		return builder
	}

	builder.imageTransfer.SetSnapshot(attr)
	return builder
}

func (builder *ImageTransferBuilder) SnapshotBuilder(attrBuilder *DiskSnapshotBuilder) *ImageTransferBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Snapshot(attr)
}

func (builder *ImageTransferBuilder) TimeoutPolicy(attr ImageTransferTimeoutPolicy) *ImageTransferBuilder {
	if builder.err != nil {
		return builder
	}

	builder.imageTransfer.SetTimeoutPolicy(attr)
	return builder
}

func (builder *ImageTransferBuilder) TransferUrl(attr string) *ImageTransferBuilder {
	if builder.err != nil {
		return builder
	}

	builder.imageTransfer.SetTransferUrl(attr)
	return builder
}

func (builder *ImageTransferBuilder) Transferred(attr int64) *ImageTransferBuilder {
	if builder.err != nil {
		return builder
	}

	builder.imageTransfer.SetTransferred(attr)
	return builder
}

func (builder *ImageTransferBuilder) Href(href string) *ImageTransferBuilder {
	if builder.err != nil {
		return builder
	}

	builder.imageTransfer.SetHref(href)
	return builder
}

func (builder *ImageTransferBuilder) Build() (*ImageTransfer, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.imageTransfer, nil
}

func (builder *ImageTransferBuilder) MustBuild() *ImageTransfer {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build ImageTransfer instance, reason: %v", builder.err))
	}
	return builder.imageTransfer
}

type InitializationBuilder struct {
	initialization *Initialization
	err            error
}

func NewInitializationBuilder() *InitializationBuilder {
	return &InitializationBuilder{initialization: &Initialization{}, err: nil}
}

func (builder *InitializationBuilder) ActiveDirectoryOu(attr string) *InitializationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.initialization.SetActiveDirectoryOu(attr)
	return builder
}

func (builder *InitializationBuilder) AuthorizedSshKeys(attr string) *InitializationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.initialization.SetAuthorizedSshKeys(attr)
	return builder
}

func (builder *InitializationBuilder) CloudInit(attr *CloudInit) *InitializationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.initialization.SetCloudInit(attr)
	return builder
}

func (builder *InitializationBuilder) CloudInitBuilder(attrBuilder *CloudInitBuilder) *InitializationBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.CloudInit(attr)
}

func (builder *InitializationBuilder) CloudInitNetworkProtocol(attr CloudInitNetworkProtocol) *InitializationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.initialization.SetCloudInitNetworkProtocol(attr)
	return builder
}

func (builder *InitializationBuilder) Configuration(attr *Configuration) *InitializationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.initialization.SetConfiguration(attr)
	return builder
}

func (builder *InitializationBuilder) ConfigurationBuilder(attrBuilder *ConfigurationBuilder) *InitializationBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Configuration(attr)
}

func (builder *InitializationBuilder) CustomScript(attr string) *InitializationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.initialization.SetCustomScript(attr)
	return builder
}

func (builder *InitializationBuilder) DnsSearch(attr string) *InitializationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.initialization.SetDnsSearch(attr)
	return builder
}

func (builder *InitializationBuilder) DnsServers(attr string) *InitializationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.initialization.SetDnsServers(attr)
	return builder
}

func (builder *InitializationBuilder) Domain(attr string) *InitializationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.initialization.SetDomain(attr)
	return builder
}

func (builder *InitializationBuilder) HostName(attr string) *InitializationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.initialization.SetHostName(attr)
	return builder
}

func (builder *InitializationBuilder) InputLocale(attr string) *InitializationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.initialization.SetInputLocale(attr)
	return builder
}

func (builder *InitializationBuilder) NicConfigurations(attr *NicConfigurationSlice) *InitializationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.initialization.SetNicConfigurations(attr)
	return builder
}

func (builder *InitializationBuilder) NicConfigurationsOfAny(anys ...*NicConfiguration) *InitializationBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.initialization.nicConfigurations == nil {
		builder.initialization.nicConfigurations = new(NicConfigurationSlice)
	}
	builder.initialization.nicConfigurations.slice = append(builder.initialization.nicConfigurations.slice, anys...)
	return builder
}

func (builder *InitializationBuilder) NicConfigurationsBuilderOfAny(anyBuilders ...NicConfigurationBuilder) *InitializationBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.NicConfigurationsOfAny(attr)
	}
	return builder
}

func (builder *InitializationBuilder) OrgName(attr string) *InitializationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.initialization.SetOrgName(attr)
	return builder
}

func (builder *InitializationBuilder) RegenerateIds(attr bool) *InitializationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.initialization.SetRegenerateIds(attr)
	return builder
}

func (builder *InitializationBuilder) RegenerateSshKeys(attr bool) *InitializationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.initialization.SetRegenerateSshKeys(attr)
	return builder
}

func (builder *InitializationBuilder) RootPassword(attr string) *InitializationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.initialization.SetRootPassword(attr)
	return builder
}

func (builder *InitializationBuilder) SystemLocale(attr string) *InitializationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.initialization.SetSystemLocale(attr)
	return builder
}

func (builder *InitializationBuilder) Timezone(attr string) *InitializationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.initialization.SetTimezone(attr)
	return builder
}

func (builder *InitializationBuilder) UiLanguage(attr string) *InitializationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.initialization.SetUiLanguage(attr)
	return builder
}

func (builder *InitializationBuilder) UserLocale(attr string) *InitializationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.initialization.SetUserLocale(attr)
	return builder
}

func (builder *InitializationBuilder) UserName(attr string) *InitializationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.initialization.SetUserName(attr)
	return builder
}

func (builder *InitializationBuilder) WindowsLicenseKey(attr string) *InitializationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.initialization.SetWindowsLicenseKey(attr)
	return builder
}

func (builder *InitializationBuilder) Href(href string) *InitializationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.initialization.SetHref(href)
	return builder
}

func (builder *InitializationBuilder) Build() (*Initialization, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.initialization, nil
}

func (builder *InitializationBuilder) MustBuild() *Initialization {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build Initialization instance, reason: %v", builder.err))
	}
	return builder.initialization
}

type InstanceTypeBuilder struct {
	instanceType *InstanceType
	err          error
}

func NewInstanceTypeBuilder() *InstanceTypeBuilder {
	return &InstanceTypeBuilder{instanceType: &InstanceType{}, err: nil}
}

func (builder *InstanceTypeBuilder) Bios(attr *Bios) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.instanceType.SetBios(attr)
	return builder
}

func (builder *InstanceTypeBuilder) BiosBuilder(attrBuilder *BiosBuilder) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Bios(attr)
}

func (builder *InstanceTypeBuilder) Cdroms(attr *CdromSlice) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.instanceType.SetCdroms(attr)
	return builder
}

func (builder *InstanceTypeBuilder) CdromsOfAny(anys ...*Cdrom) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.instanceType.cdroms == nil {
		builder.instanceType.cdroms = new(CdromSlice)
	}
	builder.instanceType.cdroms.slice = append(builder.instanceType.cdroms.slice, anys...)
	return builder
}

func (builder *InstanceTypeBuilder) CdromsBuilderOfAny(anyBuilders ...CdromBuilder) *InstanceTypeBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.CdromsOfAny(attr)
	}
	return builder
}

func (builder *InstanceTypeBuilder) Cluster(attr *Cluster) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.instanceType.SetCluster(attr)
	return builder
}

func (builder *InstanceTypeBuilder) ClusterBuilder(attrBuilder *ClusterBuilder) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Cluster(attr)
}

func (builder *InstanceTypeBuilder) Comment(attr string) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.instanceType.SetComment(attr)
	return builder
}

func (builder *InstanceTypeBuilder) Console(attr *Console) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.instanceType.SetConsole(attr)
	return builder
}

func (builder *InstanceTypeBuilder) ConsoleBuilder(attrBuilder *ConsoleBuilder) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Console(attr)
}

func (builder *InstanceTypeBuilder) Cpu(attr *Cpu) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.instanceType.SetCpu(attr)
	return builder
}

func (builder *InstanceTypeBuilder) CpuBuilder(attrBuilder *CpuBuilder) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Cpu(attr)
}

func (builder *InstanceTypeBuilder) CpuProfile(attr *CpuProfile) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.instanceType.SetCpuProfile(attr)
	return builder
}

func (builder *InstanceTypeBuilder) CpuProfileBuilder(attrBuilder *CpuProfileBuilder) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.CpuProfile(attr)
}

func (builder *InstanceTypeBuilder) CpuShares(attr int64) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.instanceType.SetCpuShares(attr)
	return builder
}

func (builder *InstanceTypeBuilder) CreationTime(attr time.Time) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.instanceType.SetCreationTime(attr)
	return builder
}

func (builder *InstanceTypeBuilder) CustomCompatibilityVersion(attr *Version) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.instanceType.SetCustomCompatibilityVersion(attr)
	return builder
}

func (builder *InstanceTypeBuilder) CustomCompatibilityVersionBuilder(attrBuilder *VersionBuilder) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.CustomCompatibilityVersion(attr)
}

func (builder *InstanceTypeBuilder) CustomCpuModel(attr string) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.instanceType.SetCustomCpuModel(attr)
	return builder
}

func (builder *InstanceTypeBuilder) CustomEmulatedMachine(attr string) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.instanceType.SetCustomEmulatedMachine(attr)
	return builder
}

func (builder *InstanceTypeBuilder) CustomProperties(attr *CustomPropertySlice) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.instanceType.SetCustomProperties(attr)
	return builder
}

func (builder *InstanceTypeBuilder) CustomPropertiesOfAny(anys ...*CustomProperty) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.instanceType.customProperties == nil {
		builder.instanceType.customProperties = new(CustomPropertySlice)
	}
	builder.instanceType.customProperties.slice = append(builder.instanceType.customProperties.slice, anys...)
	return builder
}

func (builder *InstanceTypeBuilder) CustomPropertiesBuilderOfAny(anyBuilders ...CustomPropertyBuilder) *InstanceTypeBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.CustomPropertiesOfAny(attr)
	}
	return builder
}

func (builder *InstanceTypeBuilder) DeleteProtected(attr bool) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.instanceType.SetDeleteProtected(attr)
	return builder
}

func (builder *InstanceTypeBuilder) Description(attr string) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.instanceType.SetDescription(attr)
	return builder
}

func (builder *InstanceTypeBuilder) DiskAttachments(attr *DiskAttachmentSlice) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.instanceType.SetDiskAttachments(attr)
	return builder
}

func (builder *InstanceTypeBuilder) DiskAttachmentsOfAny(anys ...*DiskAttachment) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.instanceType.diskAttachments == nil {
		builder.instanceType.diskAttachments = new(DiskAttachmentSlice)
	}
	builder.instanceType.diskAttachments.slice = append(builder.instanceType.diskAttachments.slice, anys...)
	return builder
}

func (builder *InstanceTypeBuilder) DiskAttachmentsBuilderOfAny(anyBuilders ...DiskAttachmentBuilder) *InstanceTypeBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.DiskAttachmentsOfAny(attr)
	}
	return builder
}

func (builder *InstanceTypeBuilder) Display(attr *Display) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.instanceType.SetDisplay(attr)
	return builder
}

func (builder *InstanceTypeBuilder) DisplayBuilder(attrBuilder *DisplayBuilder) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Display(attr)
}

func (builder *InstanceTypeBuilder) Domain(attr *Domain) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.instanceType.SetDomain(attr)
	return builder
}

func (builder *InstanceTypeBuilder) DomainBuilder(attrBuilder *DomainBuilder) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Domain(attr)
}

func (builder *InstanceTypeBuilder) GraphicsConsoles(attr *GraphicsConsoleSlice) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.instanceType.SetGraphicsConsoles(attr)
	return builder
}

func (builder *InstanceTypeBuilder) GraphicsConsolesOfAny(anys ...*GraphicsConsole) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.instanceType.graphicsConsoles == nil {
		builder.instanceType.graphicsConsoles = new(GraphicsConsoleSlice)
	}
	builder.instanceType.graphicsConsoles.slice = append(builder.instanceType.graphicsConsoles.slice, anys...)
	return builder
}

func (builder *InstanceTypeBuilder) GraphicsConsolesBuilderOfAny(anyBuilders ...GraphicsConsoleBuilder) *InstanceTypeBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.GraphicsConsolesOfAny(attr)
	}
	return builder
}

func (builder *InstanceTypeBuilder) HighAvailability(attr *HighAvailability) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.instanceType.SetHighAvailability(attr)
	return builder
}

func (builder *InstanceTypeBuilder) HighAvailabilityBuilder(attrBuilder *HighAvailabilityBuilder) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.HighAvailability(attr)
}

func (builder *InstanceTypeBuilder) Id(attr string) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.instanceType.SetId(attr)
	return builder
}

func (builder *InstanceTypeBuilder) Initialization(attr *Initialization) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.instanceType.SetInitialization(attr)
	return builder
}

func (builder *InstanceTypeBuilder) InitializationBuilder(attrBuilder *InitializationBuilder) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Initialization(attr)
}

func (builder *InstanceTypeBuilder) Io(attr *Io) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.instanceType.SetIo(attr)
	return builder
}

func (builder *InstanceTypeBuilder) IoBuilder(attrBuilder *IoBuilder) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Io(attr)
}

func (builder *InstanceTypeBuilder) LargeIcon(attr *Icon) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.instanceType.SetLargeIcon(attr)
	return builder
}

func (builder *InstanceTypeBuilder) LargeIconBuilder(attrBuilder *IconBuilder) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.LargeIcon(attr)
}

func (builder *InstanceTypeBuilder) Lease(attr *StorageDomainLease) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.instanceType.SetLease(attr)
	return builder
}

func (builder *InstanceTypeBuilder) LeaseBuilder(attrBuilder *StorageDomainLeaseBuilder) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Lease(attr)
}

func (builder *InstanceTypeBuilder) Memory(attr int64) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.instanceType.SetMemory(attr)
	return builder
}

func (builder *InstanceTypeBuilder) MemoryPolicy(attr *MemoryPolicy) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.instanceType.SetMemoryPolicy(attr)
	return builder
}

func (builder *InstanceTypeBuilder) MemoryPolicyBuilder(attrBuilder *MemoryPolicyBuilder) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.MemoryPolicy(attr)
}

func (builder *InstanceTypeBuilder) Migration(attr *MigrationOptions) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.instanceType.SetMigration(attr)
	return builder
}

func (builder *InstanceTypeBuilder) MigrationBuilder(attrBuilder *MigrationOptionsBuilder) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Migration(attr)
}

func (builder *InstanceTypeBuilder) MigrationDowntime(attr int64) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.instanceType.SetMigrationDowntime(attr)
	return builder
}

func (builder *InstanceTypeBuilder) MultiQueuesEnabled(attr bool) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.instanceType.SetMultiQueuesEnabled(attr)
	return builder
}

func (builder *InstanceTypeBuilder) Name(attr string) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.instanceType.SetName(attr)
	return builder
}

func (builder *InstanceTypeBuilder) Nics(attr *NicSlice) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.instanceType.SetNics(attr)
	return builder
}

func (builder *InstanceTypeBuilder) NicsOfAny(anys ...*Nic) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.instanceType.nics == nil {
		builder.instanceType.nics = new(NicSlice)
	}
	builder.instanceType.nics.slice = append(builder.instanceType.nics.slice, anys...)
	return builder
}

func (builder *InstanceTypeBuilder) NicsBuilderOfAny(anyBuilders ...NicBuilder) *InstanceTypeBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.NicsOfAny(attr)
	}
	return builder
}

func (builder *InstanceTypeBuilder) Origin(attr string) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.instanceType.SetOrigin(attr)
	return builder
}

func (builder *InstanceTypeBuilder) Os(attr *OperatingSystem) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.instanceType.SetOs(attr)
	return builder
}

func (builder *InstanceTypeBuilder) OsBuilder(attrBuilder *OperatingSystemBuilder) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Os(attr)
}

func (builder *InstanceTypeBuilder) Permissions(attr *PermissionSlice) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.instanceType.SetPermissions(attr)
	return builder
}

func (builder *InstanceTypeBuilder) PermissionsOfAny(anys ...*Permission) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.instanceType.permissions == nil {
		builder.instanceType.permissions = new(PermissionSlice)
	}
	builder.instanceType.permissions.slice = append(builder.instanceType.permissions.slice, anys...)
	return builder
}

func (builder *InstanceTypeBuilder) PermissionsBuilderOfAny(anyBuilders ...PermissionBuilder) *InstanceTypeBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.PermissionsOfAny(attr)
	}
	return builder
}

func (builder *InstanceTypeBuilder) PlacementPolicy(attr *VmPlacementPolicy) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.instanceType.SetPlacementPolicy(attr)
	return builder
}

func (builder *InstanceTypeBuilder) PlacementPolicyBuilder(attrBuilder *VmPlacementPolicyBuilder) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.PlacementPolicy(attr)
}

func (builder *InstanceTypeBuilder) Quota(attr *Quota) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.instanceType.SetQuota(attr)
	return builder
}

func (builder *InstanceTypeBuilder) QuotaBuilder(attrBuilder *QuotaBuilder) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Quota(attr)
}

func (builder *InstanceTypeBuilder) RngDevice(attr *RngDevice) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.instanceType.SetRngDevice(attr)
	return builder
}

func (builder *InstanceTypeBuilder) RngDeviceBuilder(attrBuilder *RngDeviceBuilder) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.RngDevice(attr)
}

func (builder *InstanceTypeBuilder) SerialNumber(attr *SerialNumber) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.instanceType.SetSerialNumber(attr)
	return builder
}

func (builder *InstanceTypeBuilder) SerialNumberBuilder(attrBuilder *SerialNumberBuilder) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.SerialNumber(attr)
}

func (builder *InstanceTypeBuilder) SmallIcon(attr *Icon) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.instanceType.SetSmallIcon(attr)
	return builder
}

func (builder *InstanceTypeBuilder) SmallIconBuilder(attrBuilder *IconBuilder) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.SmallIcon(attr)
}

func (builder *InstanceTypeBuilder) SoundcardEnabled(attr bool) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.instanceType.SetSoundcardEnabled(attr)
	return builder
}

func (builder *InstanceTypeBuilder) Sso(attr *Sso) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.instanceType.SetSso(attr)
	return builder
}

func (builder *InstanceTypeBuilder) SsoBuilder(attrBuilder *SsoBuilder) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Sso(attr)
}

func (builder *InstanceTypeBuilder) StartPaused(attr bool) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.instanceType.SetStartPaused(attr)
	return builder
}

func (builder *InstanceTypeBuilder) Stateless(attr bool) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.instanceType.SetStateless(attr)
	return builder
}

func (builder *InstanceTypeBuilder) Status(attr TemplateStatus) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.instanceType.SetStatus(attr)
	return builder
}

func (builder *InstanceTypeBuilder) StorageDomain(attr *StorageDomain) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.instanceType.SetStorageDomain(attr)
	return builder
}

func (builder *InstanceTypeBuilder) StorageDomainBuilder(attrBuilder *StorageDomainBuilder) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.StorageDomain(attr)
}

func (builder *InstanceTypeBuilder) StorageErrorResumeBehaviour(attr VmStorageErrorResumeBehaviour) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.instanceType.SetStorageErrorResumeBehaviour(attr)
	return builder
}

func (builder *InstanceTypeBuilder) Tags(attr *TagSlice) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.instanceType.SetTags(attr)
	return builder
}

func (builder *InstanceTypeBuilder) TagsOfAny(anys ...*Tag) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.instanceType.tags == nil {
		builder.instanceType.tags = new(TagSlice)
	}
	builder.instanceType.tags.slice = append(builder.instanceType.tags.slice, anys...)
	return builder
}

func (builder *InstanceTypeBuilder) TagsBuilderOfAny(anyBuilders ...TagBuilder) *InstanceTypeBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.TagsOfAny(attr)
	}
	return builder
}

func (builder *InstanceTypeBuilder) TimeZone(attr *TimeZone) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.instanceType.SetTimeZone(attr)
	return builder
}

func (builder *InstanceTypeBuilder) TimeZoneBuilder(attrBuilder *TimeZoneBuilder) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.TimeZone(attr)
}

func (builder *InstanceTypeBuilder) TpmEnabled(attr bool) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.instanceType.SetTpmEnabled(attr)
	return builder
}

func (builder *InstanceTypeBuilder) TunnelMigration(attr bool) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.instanceType.SetTunnelMigration(attr)
	return builder
}

func (builder *InstanceTypeBuilder) Type(attr VmType) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.instanceType.SetType(attr)
	return builder
}

func (builder *InstanceTypeBuilder) Usb(attr *Usb) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.instanceType.SetUsb(attr)
	return builder
}

func (builder *InstanceTypeBuilder) UsbBuilder(attrBuilder *UsbBuilder) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Usb(attr)
}

func (builder *InstanceTypeBuilder) Version(attr *TemplateVersion) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.instanceType.SetVersion(attr)
	return builder
}

func (builder *InstanceTypeBuilder) VersionBuilder(attrBuilder *TemplateVersionBuilder) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Version(attr)
}

func (builder *InstanceTypeBuilder) VirtioScsi(attr *VirtioScsi) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.instanceType.SetVirtioScsi(attr)
	return builder
}

func (builder *InstanceTypeBuilder) VirtioScsiBuilder(attrBuilder *VirtioScsiBuilder) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.VirtioScsi(attr)
}

func (builder *InstanceTypeBuilder) VirtioScsiMultiQueuesEnabled(attr bool) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.instanceType.SetVirtioScsiMultiQueuesEnabled(attr)
	return builder
}

func (builder *InstanceTypeBuilder) Vm(attr *Vm) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.instanceType.SetVm(attr)
	return builder
}

func (builder *InstanceTypeBuilder) VmBuilder(attrBuilder *VmBuilder) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Vm(attr)
}

func (builder *InstanceTypeBuilder) Watchdogs(attr *WatchdogSlice) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.instanceType.SetWatchdogs(attr)
	return builder
}

func (builder *InstanceTypeBuilder) WatchdogsOfAny(anys ...*Watchdog) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.instanceType.watchdogs == nil {
		builder.instanceType.watchdogs = new(WatchdogSlice)
	}
	builder.instanceType.watchdogs.slice = append(builder.instanceType.watchdogs.slice, anys...)
	return builder
}

func (builder *InstanceTypeBuilder) WatchdogsBuilderOfAny(anyBuilders ...WatchdogBuilder) *InstanceTypeBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.WatchdogsOfAny(attr)
	}
	return builder
}

func (builder *InstanceTypeBuilder) Href(href string) *InstanceTypeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.instanceType.SetHref(href)
	return builder
}

func (builder *InstanceTypeBuilder) Build() (*InstanceType, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.instanceType, nil
}

func (builder *InstanceTypeBuilder) MustBuild() *InstanceType {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build InstanceType instance, reason: %v", builder.err))
	}
	return builder.instanceType
}

type IoBuilder struct {
	io  *Io
	err error
}

func NewIoBuilder() *IoBuilder {
	return &IoBuilder{io: &Io{}, err: nil}
}

func (builder *IoBuilder) Threads(attr int64) *IoBuilder {
	if builder.err != nil {
		return builder
	}

	builder.io.SetThreads(attr)
	return builder
}

func (builder *IoBuilder) Href(href string) *IoBuilder {
	if builder.err != nil {
		return builder
	}

	builder.io.SetHref(href)
	return builder
}

func (builder *IoBuilder) Build() (*Io, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.io, nil
}

func (builder *IoBuilder) MustBuild() *Io {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build Io instance, reason: %v", builder.err))
	}
	return builder.io
}

type IpBuilder struct {
	ip  *Ip
	err error
}

func NewIpBuilder() *IpBuilder {
	return &IpBuilder{ip: &Ip{}, err: nil}
}

func (builder *IpBuilder) Address(attr string) *IpBuilder {
	if builder.err != nil {
		return builder
	}

	builder.ip.SetAddress(attr)
	return builder
}

func (builder *IpBuilder) Gateway(attr string) *IpBuilder {
	if builder.err != nil {
		return builder
	}

	builder.ip.SetGateway(attr)
	return builder
}

func (builder *IpBuilder) Netmask(attr string) *IpBuilder {
	if builder.err != nil {
		return builder
	}

	builder.ip.SetNetmask(attr)
	return builder
}

func (builder *IpBuilder) Version(attr IpVersion) *IpBuilder {
	if builder.err != nil {
		return builder
	}

	builder.ip.SetVersion(attr)
	return builder
}

func (builder *IpBuilder) Href(href string) *IpBuilder {
	if builder.err != nil {
		return builder
	}

	builder.ip.SetHref(href)
	return builder
}

func (builder *IpBuilder) Build() (*Ip, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.ip, nil
}

func (builder *IpBuilder) MustBuild() *Ip {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build Ip instance, reason: %v", builder.err))
	}
	return builder.ip
}

type IpAddressAssignmentBuilder struct {
	ipAddressAssignment *IpAddressAssignment
	err                 error
}

func NewIpAddressAssignmentBuilder() *IpAddressAssignmentBuilder {
	return &IpAddressAssignmentBuilder{ipAddressAssignment: &IpAddressAssignment{}, err: nil}
}

func (builder *IpAddressAssignmentBuilder) AssignmentMethod(attr BootProtocol) *IpAddressAssignmentBuilder {
	if builder.err != nil {
		return builder
	}

	builder.ipAddressAssignment.SetAssignmentMethod(attr)
	return builder
}

func (builder *IpAddressAssignmentBuilder) Ip(attr *Ip) *IpAddressAssignmentBuilder {
	if builder.err != nil {
		return builder
	}

	builder.ipAddressAssignment.SetIp(attr)
	return builder
}

func (builder *IpAddressAssignmentBuilder) IpBuilder(attrBuilder *IpBuilder) *IpAddressAssignmentBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Ip(attr)
}

func (builder *IpAddressAssignmentBuilder) Href(href string) *IpAddressAssignmentBuilder {
	if builder.err != nil {
		return builder
	}

	builder.ipAddressAssignment.SetHref(href)
	return builder
}

func (builder *IpAddressAssignmentBuilder) Build() (*IpAddressAssignment, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.ipAddressAssignment, nil
}

func (builder *IpAddressAssignmentBuilder) MustBuild() *IpAddressAssignment {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build IpAddressAssignment instance, reason: %v", builder.err))
	}
	return builder.ipAddressAssignment
}

type IscsiBondBuilder struct {
	iscsiBond *IscsiBond
	err       error
}

func NewIscsiBondBuilder() *IscsiBondBuilder {
	return &IscsiBondBuilder{iscsiBond: &IscsiBond{}, err: nil}
}

func (builder *IscsiBondBuilder) Comment(attr string) *IscsiBondBuilder {
	if builder.err != nil {
		return builder
	}

	builder.iscsiBond.SetComment(attr)
	return builder
}

func (builder *IscsiBondBuilder) DataCenter(attr *DataCenter) *IscsiBondBuilder {
	if builder.err != nil {
		return builder
	}

	builder.iscsiBond.SetDataCenter(attr)
	return builder
}

func (builder *IscsiBondBuilder) DataCenterBuilder(attrBuilder *DataCenterBuilder) *IscsiBondBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.DataCenter(attr)
}

func (builder *IscsiBondBuilder) Description(attr string) *IscsiBondBuilder {
	if builder.err != nil {
		return builder
	}

	builder.iscsiBond.SetDescription(attr)
	return builder
}

func (builder *IscsiBondBuilder) Id(attr string) *IscsiBondBuilder {
	if builder.err != nil {
		return builder
	}

	builder.iscsiBond.SetId(attr)
	return builder
}

func (builder *IscsiBondBuilder) Name(attr string) *IscsiBondBuilder {
	if builder.err != nil {
		return builder
	}

	builder.iscsiBond.SetName(attr)
	return builder
}

func (builder *IscsiBondBuilder) Networks(attr *NetworkSlice) *IscsiBondBuilder {
	if builder.err != nil {
		return builder
	}

	builder.iscsiBond.SetNetworks(attr)
	return builder
}

func (builder *IscsiBondBuilder) NetworksOfAny(anys ...*Network) *IscsiBondBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.iscsiBond.networks == nil {
		builder.iscsiBond.networks = new(NetworkSlice)
	}
	builder.iscsiBond.networks.slice = append(builder.iscsiBond.networks.slice, anys...)
	return builder
}

func (builder *IscsiBondBuilder) NetworksBuilderOfAny(anyBuilders ...NetworkBuilder) *IscsiBondBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.NetworksOfAny(attr)
	}
	return builder
}

func (builder *IscsiBondBuilder) StorageConnections(attr *StorageConnectionSlice) *IscsiBondBuilder {
	if builder.err != nil {
		return builder
	}

	builder.iscsiBond.SetStorageConnections(attr)
	return builder
}

func (builder *IscsiBondBuilder) StorageConnectionsOfAny(anys ...*StorageConnection) *IscsiBondBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.iscsiBond.storageConnections == nil {
		builder.iscsiBond.storageConnections = new(StorageConnectionSlice)
	}
	builder.iscsiBond.storageConnections.slice = append(builder.iscsiBond.storageConnections.slice, anys...)
	return builder
}

func (builder *IscsiBondBuilder) StorageConnectionsBuilderOfAny(anyBuilders ...StorageConnectionBuilder) *IscsiBondBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.StorageConnectionsOfAny(attr)
	}
	return builder
}

func (builder *IscsiBondBuilder) Href(href string) *IscsiBondBuilder {
	if builder.err != nil {
		return builder
	}

	builder.iscsiBond.SetHref(href)
	return builder
}

func (builder *IscsiBondBuilder) Build() (*IscsiBond, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.iscsiBond, nil
}

func (builder *IscsiBondBuilder) MustBuild() *IscsiBond {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build IscsiBond instance, reason: %v", builder.err))
	}
	return builder.iscsiBond
}

type IscsiDetailsBuilder struct {
	iscsiDetails *IscsiDetails
	err          error
}

func NewIscsiDetailsBuilder() *IscsiDetailsBuilder {
	return &IscsiDetailsBuilder{iscsiDetails: &IscsiDetails{}, err: nil}
}

func (builder *IscsiDetailsBuilder) Address(attr string) *IscsiDetailsBuilder {
	if builder.err != nil {
		return builder
	}

	builder.iscsiDetails.SetAddress(attr)
	return builder
}

func (builder *IscsiDetailsBuilder) DiskId(attr string) *IscsiDetailsBuilder {
	if builder.err != nil {
		return builder
	}

	builder.iscsiDetails.SetDiskId(attr)
	return builder
}

func (builder *IscsiDetailsBuilder) Initiator(attr string) *IscsiDetailsBuilder {
	if builder.err != nil {
		return builder
	}

	builder.iscsiDetails.SetInitiator(attr)
	return builder
}

func (builder *IscsiDetailsBuilder) LunMapping(attr int64) *IscsiDetailsBuilder {
	if builder.err != nil {
		return builder
	}

	builder.iscsiDetails.SetLunMapping(attr)
	return builder
}

func (builder *IscsiDetailsBuilder) Password(attr string) *IscsiDetailsBuilder {
	if builder.err != nil {
		return builder
	}

	builder.iscsiDetails.SetPassword(attr)
	return builder
}

func (builder *IscsiDetailsBuilder) Paths(attr int64) *IscsiDetailsBuilder {
	if builder.err != nil {
		return builder
	}

	builder.iscsiDetails.SetPaths(attr)
	return builder
}

func (builder *IscsiDetailsBuilder) Port(attr int64) *IscsiDetailsBuilder {
	if builder.err != nil {
		return builder
	}

	builder.iscsiDetails.SetPort(attr)
	return builder
}

func (builder *IscsiDetailsBuilder) Portal(attr string) *IscsiDetailsBuilder {
	if builder.err != nil {
		return builder
	}

	builder.iscsiDetails.SetPortal(attr)
	return builder
}

func (builder *IscsiDetailsBuilder) ProductId(attr string) *IscsiDetailsBuilder {
	if builder.err != nil {
		return builder
	}

	builder.iscsiDetails.SetProductId(attr)
	return builder
}

func (builder *IscsiDetailsBuilder) Serial(attr string) *IscsiDetailsBuilder {
	if builder.err != nil {
		return builder
	}

	builder.iscsiDetails.SetSerial(attr)
	return builder
}

func (builder *IscsiDetailsBuilder) Size(attr int64) *IscsiDetailsBuilder {
	if builder.err != nil {
		return builder
	}

	builder.iscsiDetails.SetSize(attr)
	return builder
}

func (builder *IscsiDetailsBuilder) Status(attr string) *IscsiDetailsBuilder {
	if builder.err != nil {
		return builder
	}

	builder.iscsiDetails.SetStatus(attr)
	return builder
}

func (builder *IscsiDetailsBuilder) StorageDomainId(attr string) *IscsiDetailsBuilder {
	if builder.err != nil {
		return builder
	}

	builder.iscsiDetails.SetStorageDomainId(attr)
	return builder
}

func (builder *IscsiDetailsBuilder) Target(attr string) *IscsiDetailsBuilder {
	if builder.err != nil {
		return builder
	}

	builder.iscsiDetails.SetTarget(attr)
	return builder
}

func (builder *IscsiDetailsBuilder) Username(attr string) *IscsiDetailsBuilder {
	if builder.err != nil {
		return builder
	}

	builder.iscsiDetails.SetUsername(attr)
	return builder
}

func (builder *IscsiDetailsBuilder) VendorId(attr string) *IscsiDetailsBuilder {
	if builder.err != nil {
		return builder
	}

	builder.iscsiDetails.SetVendorId(attr)
	return builder
}

func (builder *IscsiDetailsBuilder) VolumeGroupId(attr string) *IscsiDetailsBuilder {
	if builder.err != nil {
		return builder
	}

	builder.iscsiDetails.SetVolumeGroupId(attr)
	return builder
}

func (builder *IscsiDetailsBuilder) Href(href string) *IscsiDetailsBuilder {
	if builder.err != nil {
		return builder
	}

	builder.iscsiDetails.SetHref(href)
	return builder
}

func (builder *IscsiDetailsBuilder) Build() (*IscsiDetails, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.iscsiDetails, nil
}

func (builder *IscsiDetailsBuilder) MustBuild() *IscsiDetails {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build IscsiDetails instance, reason: %v", builder.err))
	}
	return builder.iscsiDetails
}

type JobBuilder struct {
	job *Job
	err error
}

func NewJobBuilder() *JobBuilder {
	return &JobBuilder{job: &Job{}, err: nil}
}

func (builder *JobBuilder) AutoCleared(attr bool) *JobBuilder {
	if builder.err != nil {
		return builder
	}

	builder.job.SetAutoCleared(attr)
	return builder
}

func (builder *JobBuilder) Comment(attr string) *JobBuilder {
	if builder.err != nil {
		return builder
	}

	builder.job.SetComment(attr)
	return builder
}

func (builder *JobBuilder) Description(attr string) *JobBuilder {
	if builder.err != nil {
		return builder
	}

	builder.job.SetDescription(attr)
	return builder
}

func (builder *JobBuilder) EndTime(attr time.Time) *JobBuilder {
	if builder.err != nil {
		return builder
	}

	builder.job.SetEndTime(attr)
	return builder
}

func (builder *JobBuilder) External(attr bool) *JobBuilder {
	if builder.err != nil {
		return builder
	}

	builder.job.SetExternal(attr)
	return builder
}

func (builder *JobBuilder) Id(attr string) *JobBuilder {
	if builder.err != nil {
		return builder
	}

	builder.job.SetId(attr)
	return builder
}

func (builder *JobBuilder) LastUpdated(attr time.Time) *JobBuilder {
	if builder.err != nil {
		return builder
	}

	builder.job.SetLastUpdated(attr)
	return builder
}

func (builder *JobBuilder) Name(attr string) *JobBuilder {
	if builder.err != nil {
		return builder
	}

	builder.job.SetName(attr)
	return builder
}

func (builder *JobBuilder) Owner(attr *User) *JobBuilder {
	if builder.err != nil {
		return builder
	}

	builder.job.SetOwner(attr)
	return builder
}

func (builder *JobBuilder) OwnerBuilder(attrBuilder *UserBuilder) *JobBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Owner(attr)
}

func (builder *JobBuilder) StartTime(attr time.Time) *JobBuilder {
	if builder.err != nil {
		return builder
	}

	builder.job.SetStartTime(attr)
	return builder
}

func (builder *JobBuilder) Status(attr JobStatus) *JobBuilder {
	if builder.err != nil {
		return builder
	}

	builder.job.SetStatus(attr)
	return builder
}

func (builder *JobBuilder) Steps(attr *StepSlice) *JobBuilder {
	if builder.err != nil {
		return builder
	}

	builder.job.SetSteps(attr)
	return builder
}

func (builder *JobBuilder) StepsOfAny(anys ...*Step) *JobBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.job.steps == nil {
		builder.job.steps = new(StepSlice)
	}
	builder.job.steps.slice = append(builder.job.steps.slice, anys...)
	return builder
}

func (builder *JobBuilder) StepsBuilderOfAny(anyBuilders ...StepBuilder) *JobBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.StepsOfAny(attr)
	}
	return builder
}

func (builder *JobBuilder) Href(href string) *JobBuilder {
	if builder.err != nil {
		return builder
	}

	builder.job.SetHref(href)
	return builder
}

func (builder *JobBuilder) Build() (*Job, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.job, nil
}

func (builder *JobBuilder) MustBuild() *Job {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build Job instance, reason: %v", builder.err))
	}
	return builder.job
}

type KatelloErratumBuilder struct {
	katelloErratum *KatelloErratum
	err            error
}

func NewKatelloErratumBuilder() *KatelloErratumBuilder {
	return &KatelloErratumBuilder{katelloErratum: &KatelloErratum{}, err: nil}
}

func (builder *KatelloErratumBuilder) Comment(attr string) *KatelloErratumBuilder {
	if builder.err != nil {
		return builder
	}

	builder.katelloErratum.SetComment(attr)
	return builder
}

func (builder *KatelloErratumBuilder) Description(attr string) *KatelloErratumBuilder {
	if builder.err != nil {
		return builder
	}

	builder.katelloErratum.SetDescription(attr)
	return builder
}

func (builder *KatelloErratumBuilder) Host(attr *Host) *KatelloErratumBuilder {
	if builder.err != nil {
		return builder
	}

	builder.katelloErratum.SetHost(attr)
	return builder
}

func (builder *KatelloErratumBuilder) HostBuilder(attrBuilder *HostBuilder) *KatelloErratumBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Host(attr)
}

func (builder *KatelloErratumBuilder) Id(attr string) *KatelloErratumBuilder {
	if builder.err != nil {
		return builder
	}

	builder.katelloErratum.SetId(attr)
	return builder
}

func (builder *KatelloErratumBuilder) Issued(attr time.Time) *KatelloErratumBuilder {
	if builder.err != nil {
		return builder
	}

	builder.katelloErratum.SetIssued(attr)
	return builder
}

func (builder *KatelloErratumBuilder) Name(attr string) *KatelloErratumBuilder {
	if builder.err != nil {
		return builder
	}

	builder.katelloErratum.SetName(attr)
	return builder
}

func (builder *KatelloErratumBuilder) Packages(attr *PackageSlice) *KatelloErratumBuilder {
	if builder.err != nil {
		return builder
	}

	builder.katelloErratum.SetPackages(attr)
	return builder
}

func (builder *KatelloErratumBuilder) PackagesOfAny(anys ...*Package) *KatelloErratumBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.katelloErratum.packages == nil {
		builder.katelloErratum.packages = new(PackageSlice)
	}
	builder.katelloErratum.packages.slice = append(builder.katelloErratum.packages.slice, anys...)
	return builder
}

func (builder *KatelloErratumBuilder) PackagesBuilderOfAny(anyBuilders ...PackageBuilder) *KatelloErratumBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.PackagesOfAny(attr)
	}
	return builder
}

func (builder *KatelloErratumBuilder) Severity(attr string) *KatelloErratumBuilder {
	if builder.err != nil {
		return builder
	}

	builder.katelloErratum.SetSeverity(attr)
	return builder
}

func (builder *KatelloErratumBuilder) Solution(attr string) *KatelloErratumBuilder {
	if builder.err != nil {
		return builder
	}

	builder.katelloErratum.SetSolution(attr)
	return builder
}

func (builder *KatelloErratumBuilder) Summary(attr string) *KatelloErratumBuilder {
	if builder.err != nil {
		return builder
	}

	builder.katelloErratum.SetSummary(attr)
	return builder
}

func (builder *KatelloErratumBuilder) Title(attr string) *KatelloErratumBuilder {
	if builder.err != nil {
		return builder
	}

	builder.katelloErratum.SetTitle(attr)
	return builder
}

func (builder *KatelloErratumBuilder) Type(attr string) *KatelloErratumBuilder {
	if builder.err != nil {
		return builder
	}

	builder.katelloErratum.SetType(attr)
	return builder
}

func (builder *KatelloErratumBuilder) Vm(attr *Vm) *KatelloErratumBuilder {
	if builder.err != nil {
		return builder
	}

	builder.katelloErratum.SetVm(attr)
	return builder
}

func (builder *KatelloErratumBuilder) VmBuilder(attrBuilder *VmBuilder) *KatelloErratumBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Vm(attr)
}

func (builder *KatelloErratumBuilder) Href(href string) *KatelloErratumBuilder {
	if builder.err != nil {
		return builder
	}

	builder.katelloErratum.SetHref(href)
	return builder
}

func (builder *KatelloErratumBuilder) Build() (*KatelloErratum, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.katelloErratum, nil
}

func (builder *KatelloErratumBuilder) MustBuild() *KatelloErratum {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build KatelloErratum instance, reason: %v", builder.err))
	}
	return builder.katelloErratum
}

type KernelBuilder struct {
	kernel *Kernel
	err    error
}

func NewKernelBuilder() *KernelBuilder {
	return &KernelBuilder{kernel: &Kernel{}, err: nil}
}

func (builder *KernelBuilder) Version(attr *Version) *KernelBuilder {
	if builder.err != nil {
		return builder
	}

	builder.kernel.SetVersion(attr)
	return builder
}

func (builder *KernelBuilder) VersionBuilder(attrBuilder *VersionBuilder) *KernelBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Version(attr)
}

func (builder *KernelBuilder) Href(href string) *KernelBuilder {
	if builder.err != nil {
		return builder
	}

	builder.kernel.SetHref(href)
	return builder
}

func (builder *KernelBuilder) Build() (*Kernel, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.kernel, nil
}

func (builder *KernelBuilder) MustBuild() *Kernel {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build Kernel instance, reason: %v", builder.err))
	}
	return builder.kernel
}

type KsmBuilder struct {
	ksm *Ksm
	err error
}

func NewKsmBuilder() *KsmBuilder {
	return &KsmBuilder{ksm: &Ksm{}, err: nil}
}

func (builder *KsmBuilder) Enabled(attr bool) *KsmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.ksm.SetEnabled(attr)
	return builder
}

func (builder *KsmBuilder) MergeAcrossNodes(attr bool) *KsmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.ksm.SetMergeAcrossNodes(attr)
	return builder
}

func (builder *KsmBuilder) Href(href string) *KsmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.ksm.SetHref(href)
	return builder
}

func (builder *KsmBuilder) Build() (*Ksm, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.ksm, nil
}

func (builder *KsmBuilder) MustBuild() *Ksm {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build Ksm instance, reason: %v", builder.err))
	}
	return builder.ksm
}

type LinkLayerDiscoveryProtocolElementBuilder struct {
	linkLayerDiscoveryProtocolElement *LinkLayerDiscoveryProtocolElement
	err                               error
}

func NewLinkLayerDiscoveryProtocolElementBuilder() *LinkLayerDiscoveryProtocolElementBuilder {
	return &LinkLayerDiscoveryProtocolElementBuilder{linkLayerDiscoveryProtocolElement: &LinkLayerDiscoveryProtocolElement{}, err: nil}
}

func (builder *LinkLayerDiscoveryProtocolElementBuilder) Comment(attr string) *LinkLayerDiscoveryProtocolElementBuilder {
	if builder.err != nil {
		return builder
	}

	builder.linkLayerDiscoveryProtocolElement.SetComment(attr)
	return builder
}

func (builder *LinkLayerDiscoveryProtocolElementBuilder) Description(attr string) *LinkLayerDiscoveryProtocolElementBuilder {
	if builder.err != nil {
		return builder
	}

	builder.linkLayerDiscoveryProtocolElement.SetDescription(attr)
	return builder
}

func (builder *LinkLayerDiscoveryProtocolElementBuilder) Id(attr string) *LinkLayerDiscoveryProtocolElementBuilder {
	if builder.err != nil {
		return builder
	}

	builder.linkLayerDiscoveryProtocolElement.SetId(attr)
	return builder
}

func (builder *LinkLayerDiscoveryProtocolElementBuilder) Name(attr string) *LinkLayerDiscoveryProtocolElementBuilder {
	if builder.err != nil {
		return builder
	}

	builder.linkLayerDiscoveryProtocolElement.SetName(attr)
	return builder
}

func (builder *LinkLayerDiscoveryProtocolElementBuilder) Oui(attr int64) *LinkLayerDiscoveryProtocolElementBuilder {
	if builder.err != nil {
		return builder
	}

	builder.linkLayerDiscoveryProtocolElement.SetOui(attr)
	return builder
}

func (builder *LinkLayerDiscoveryProtocolElementBuilder) Properties(attr *PropertySlice) *LinkLayerDiscoveryProtocolElementBuilder {
	if builder.err != nil {
		return builder
	}

	builder.linkLayerDiscoveryProtocolElement.SetProperties(attr)
	return builder
}

func (builder *LinkLayerDiscoveryProtocolElementBuilder) PropertiesOfAny(anys ...*Property) *LinkLayerDiscoveryProtocolElementBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.linkLayerDiscoveryProtocolElement.properties == nil {
		builder.linkLayerDiscoveryProtocolElement.properties = new(PropertySlice)
	}
	builder.linkLayerDiscoveryProtocolElement.properties.slice = append(builder.linkLayerDiscoveryProtocolElement.properties.slice, anys...)
	return builder
}

func (builder *LinkLayerDiscoveryProtocolElementBuilder) PropertiesBuilderOfAny(anyBuilders ...PropertyBuilder) *LinkLayerDiscoveryProtocolElementBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.PropertiesOfAny(attr)
	}
	return builder
}

func (builder *LinkLayerDiscoveryProtocolElementBuilder) Subtype(attr int64) *LinkLayerDiscoveryProtocolElementBuilder {
	if builder.err != nil {
		return builder
	}

	builder.linkLayerDiscoveryProtocolElement.SetSubtype(attr)
	return builder
}

func (builder *LinkLayerDiscoveryProtocolElementBuilder) Type(attr int64) *LinkLayerDiscoveryProtocolElementBuilder {
	if builder.err != nil {
		return builder
	}

	builder.linkLayerDiscoveryProtocolElement.SetType(attr)
	return builder
}

func (builder *LinkLayerDiscoveryProtocolElementBuilder) Href(href string) *LinkLayerDiscoveryProtocolElementBuilder {
	if builder.err != nil {
		return builder
	}

	builder.linkLayerDiscoveryProtocolElement.SetHref(href)
	return builder
}

func (builder *LinkLayerDiscoveryProtocolElementBuilder) Build() (*LinkLayerDiscoveryProtocolElement, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.linkLayerDiscoveryProtocolElement, nil
}

func (builder *LinkLayerDiscoveryProtocolElementBuilder) MustBuild() *LinkLayerDiscoveryProtocolElement {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build LinkLayerDiscoveryProtocolElement instance, reason: %v", builder.err))
	}
	return builder.linkLayerDiscoveryProtocolElement
}

type LogicalUnitBuilder struct {
	logicalUnit *LogicalUnit
	err         error
}

func NewLogicalUnitBuilder() *LogicalUnitBuilder {
	return &LogicalUnitBuilder{logicalUnit: &LogicalUnit{}, err: nil}
}

func (builder *LogicalUnitBuilder) Address(attr string) *LogicalUnitBuilder {
	if builder.err != nil {
		return builder
	}

	builder.logicalUnit.SetAddress(attr)
	return builder
}

func (builder *LogicalUnitBuilder) DiscardMaxSize(attr int64) *LogicalUnitBuilder {
	if builder.err != nil {
		return builder
	}

	builder.logicalUnit.SetDiscardMaxSize(attr)
	return builder
}

func (builder *LogicalUnitBuilder) DiscardZeroesData(attr bool) *LogicalUnitBuilder {
	if builder.err != nil {
		return builder
	}

	builder.logicalUnit.SetDiscardZeroesData(attr)
	return builder
}

func (builder *LogicalUnitBuilder) DiskId(attr string) *LogicalUnitBuilder {
	if builder.err != nil {
		return builder
	}

	builder.logicalUnit.SetDiskId(attr)
	return builder
}

func (builder *LogicalUnitBuilder) Id(attr string) *LogicalUnitBuilder {
	if builder.err != nil {
		return builder
	}

	builder.logicalUnit.SetId(attr)
	return builder
}

func (builder *LogicalUnitBuilder) LunMapping(attr int64) *LogicalUnitBuilder {
	if builder.err != nil {
		return builder
	}

	builder.logicalUnit.SetLunMapping(attr)
	return builder
}

func (builder *LogicalUnitBuilder) Password(attr string) *LogicalUnitBuilder {
	if builder.err != nil {
		return builder
	}

	builder.logicalUnit.SetPassword(attr)
	return builder
}

func (builder *LogicalUnitBuilder) Paths(attr int64) *LogicalUnitBuilder {
	if builder.err != nil {
		return builder
	}

	builder.logicalUnit.SetPaths(attr)
	return builder
}

func (builder *LogicalUnitBuilder) Port(attr int64) *LogicalUnitBuilder {
	if builder.err != nil {
		return builder
	}

	builder.logicalUnit.SetPort(attr)
	return builder
}

func (builder *LogicalUnitBuilder) Portal(attr string) *LogicalUnitBuilder {
	if builder.err != nil {
		return builder
	}

	builder.logicalUnit.SetPortal(attr)
	return builder
}

func (builder *LogicalUnitBuilder) ProductId(attr string) *LogicalUnitBuilder {
	if builder.err != nil {
		return builder
	}

	builder.logicalUnit.SetProductId(attr)
	return builder
}

func (builder *LogicalUnitBuilder) Serial(attr string) *LogicalUnitBuilder {
	if builder.err != nil {
		return builder
	}

	builder.logicalUnit.SetSerial(attr)
	return builder
}

func (builder *LogicalUnitBuilder) Size(attr int64) *LogicalUnitBuilder {
	if builder.err != nil {
		return builder
	}

	builder.logicalUnit.SetSize(attr)
	return builder
}

func (builder *LogicalUnitBuilder) Status(attr LunStatus) *LogicalUnitBuilder {
	if builder.err != nil {
		return builder
	}

	builder.logicalUnit.SetStatus(attr)
	return builder
}

func (builder *LogicalUnitBuilder) StorageDomainId(attr string) *LogicalUnitBuilder {
	if builder.err != nil {
		return builder
	}

	builder.logicalUnit.SetStorageDomainId(attr)
	return builder
}

func (builder *LogicalUnitBuilder) Target(attr string) *LogicalUnitBuilder {
	if builder.err != nil {
		return builder
	}

	builder.logicalUnit.SetTarget(attr)
	return builder
}

func (builder *LogicalUnitBuilder) Username(attr string) *LogicalUnitBuilder {
	if builder.err != nil {
		return builder
	}

	builder.logicalUnit.SetUsername(attr)
	return builder
}

func (builder *LogicalUnitBuilder) VendorId(attr string) *LogicalUnitBuilder {
	if builder.err != nil {
		return builder
	}

	builder.logicalUnit.SetVendorId(attr)
	return builder
}

func (builder *LogicalUnitBuilder) VolumeGroupId(attr string) *LogicalUnitBuilder {
	if builder.err != nil {
		return builder
	}

	builder.logicalUnit.SetVolumeGroupId(attr)
	return builder
}

func (builder *LogicalUnitBuilder) Href(href string) *LogicalUnitBuilder {
	if builder.err != nil {
		return builder
	}

	builder.logicalUnit.SetHref(href)
	return builder
}

func (builder *LogicalUnitBuilder) Build() (*LogicalUnit, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.logicalUnit, nil
}

func (builder *LogicalUnitBuilder) MustBuild() *LogicalUnit {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build LogicalUnit instance, reason: %v", builder.err))
	}
	return builder.logicalUnit
}

type MDevTypeBuilder struct {
	mDevType *MDevType
	err      error
}

func NewMDevTypeBuilder() *MDevTypeBuilder {
	return &MDevTypeBuilder{mDevType: &MDevType{}, err: nil}
}

func (builder *MDevTypeBuilder) AvailableInstances(attr int64) *MDevTypeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.mDevType.SetAvailableInstances(attr)
	return builder
}

func (builder *MDevTypeBuilder) Description(attr string) *MDevTypeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.mDevType.SetDescription(attr)
	return builder
}

func (builder *MDevTypeBuilder) HumanReadableName(attr string) *MDevTypeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.mDevType.SetHumanReadableName(attr)
	return builder
}

func (builder *MDevTypeBuilder) Name(attr string) *MDevTypeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.mDevType.SetName(attr)
	return builder
}

func (builder *MDevTypeBuilder) Href(href string) *MDevTypeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.mDevType.SetHref(href)
	return builder
}

func (builder *MDevTypeBuilder) Build() (*MDevType, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.mDevType, nil
}

func (builder *MDevTypeBuilder) MustBuild() *MDevType {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build MDevType instance, reason: %v", builder.err))
	}
	return builder.mDevType
}

type MacBuilder struct {
	mac *Mac
	err error
}

func NewMacBuilder() *MacBuilder {
	return &MacBuilder{mac: &Mac{}, err: nil}
}

func (builder *MacBuilder) Address(attr string) *MacBuilder {
	if builder.err != nil {
		return builder
	}

	builder.mac.SetAddress(attr)
	return builder
}

func (builder *MacBuilder) Href(href string) *MacBuilder {
	if builder.err != nil {
		return builder
	}

	builder.mac.SetHref(href)
	return builder
}

func (builder *MacBuilder) Build() (*Mac, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.mac, nil
}

func (builder *MacBuilder) MustBuild() *Mac {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build Mac instance, reason: %v", builder.err))
	}
	return builder.mac
}

type MacPoolBuilder struct {
	macPool *MacPool
	err     error
}

func NewMacPoolBuilder() *MacPoolBuilder {
	return &MacPoolBuilder{macPool: &MacPool{}, err: nil}
}

func (builder *MacPoolBuilder) AllowDuplicates(attr bool) *MacPoolBuilder {
	if builder.err != nil {
		return builder
	}

	builder.macPool.SetAllowDuplicates(attr)
	return builder
}

func (builder *MacPoolBuilder) Comment(attr string) *MacPoolBuilder {
	if builder.err != nil {
		return builder
	}

	builder.macPool.SetComment(attr)
	return builder
}

func (builder *MacPoolBuilder) DefaultPool(attr bool) *MacPoolBuilder {
	if builder.err != nil {
		return builder
	}

	builder.macPool.SetDefaultPool(attr)
	return builder
}

func (builder *MacPoolBuilder) Description(attr string) *MacPoolBuilder {
	if builder.err != nil {
		return builder
	}

	builder.macPool.SetDescription(attr)
	return builder
}

func (builder *MacPoolBuilder) Id(attr string) *MacPoolBuilder {
	if builder.err != nil {
		return builder
	}

	builder.macPool.SetId(attr)
	return builder
}

func (builder *MacPoolBuilder) Name(attr string) *MacPoolBuilder {
	if builder.err != nil {
		return builder
	}

	builder.macPool.SetName(attr)
	return builder
}

func (builder *MacPoolBuilder) Permissions(attr *PermissionSlice) *MacPoolBuilder {
	if builder.err != nil {
		return builder
	}

	builder.macPool.SetPermissions(attr)
	return builder
}

func (builder *MacPoolBuilder) PermissionsOfAny(anys ...*Permission) *MacPoolBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.macPool.permissions == nil {
		builder.macPool.permissions = new(PermissionSlice)
	}
	builder.macPool.permissions.slice = append(builder.macPool.permissions.slice, anys...)
	return builder
}

func (builder *MacPoolBuilder) PermissionsBuilderOfAny(anyBuilders ...PermissionBuilder) *MacPoolBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.PermissionsOfAny(attr)
	}
	return builder
}

func (builder *MacPoolBuilder) Ranges(attr *RangeSlice) *MacPoolBuilder {
	if builder.err != nil {
		return builder
	}

	builder.macPool.SetRanges(attr)
	return builder
}

func (builder *MacPoolBuilder) RangesOfAny(anys ...*Range) *MacPoolBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.macPool.ranges == nil {
		builder.macPool.ranges = new(RangeSlice)
	}
	builder.macPool.ranges.slice = append(builder.macPool.ranges.slice, anys...)
	return builder
}

func (builder *MacPoolBuilder) RangesBuilderOfAny(anyBuilders ...RangeBuilder) *MacPoolBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.RangesOfAny(attr)
	}
	return builder
}

func (builder *MacPoolBuilder) Href(href string) *MacPoolBuilder {
	if builder.err != nil {
		return builder
	}

	builder.macPool.SetHref(href)
	return builder
}

func (builder *MacPoolBuilder) Build() (*MacPool, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.macPool, nil
}

func (builder *MacPoolBuilder) MustBuild() *MacPool {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build MacPool instance, reason: %v", builder.err))
	}
	return builder.macPool
}

type MemoryOverCommitBuilder struct {
	memoryOverCommit *MemoryOverCommit
	err              error
}

func NewMemoryOverCommitBuilder() *MemoryOverCommitBuilder {
	return &MemoryOverCommitBuilder{memoryOverCommit: &MemoryOverCommit{}, err: nil}
}

func (builder *MemoryOverCommitBuilder) Percent(attr int64) *MemoryOverCommitBuilder {
	if builder.err != nil {
		return builder
	}

	builder.memoryOverCommit.SetPercent(attr)
	return builder
}

func (builder *MemoryOverCommitBuilder) Href(href string) *MemoryOverCommitBuilder {
	if builder.err != nil {
		return builder
	}

	builder.memoryOverCommit.SetHref(href)
	return builder
}

func (builder *MemoryOverCommitBuilder) Build() (*MemoryOverCommit, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.memoryOverCommit, nil
}

func (builder *MemoryOverCommitBuilder) MustBuild() *MemoryOverCommit {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build MemoryOverCommit instance, reason: %v", builder.err))
	}
	return builder.memoryOverCommit
}

type MemoryPolicyBuilder struct {
	memoryPolicy *MemoryPolicy
	err          error
}

func NewMemoryPolicyBuilder() *MemoryPolicyBuilder {
	return &MemoryPolicyBuilder{memoryPolicy: &MemoryPolicy{}, err: nil}
}

func (builder *MemoryPolicyBuilder) Ballooning(attr bool) *MemoryPolicyBuilder {
	if builder.err != nil {
		return builder
	}

	builder.memoryPolicy.SetBallooning(attr)
	return builder
}

func (builder *MemoryPolicyBuilder) Guaranteed(attr int64) *MemoryPolicyBuilder {
	if builder.err != nil {
		return builder
	}

	builder.memoryPolicy.SetGuaranteed(attr)
	return builder
}

func (builder *MemoryPolicyBuilder) Max(attr int64) *MemoryPolicyBuilder {
	if builder.err != nil {
		return builder
	}

	builder.memoryPolicy.SetMax(attr)
	return builder
}

func (builder *MemoryPolicyBuilder) OverCommit(attr *MemoryOverCommit) *MemoryPolicyBuilder {
	if builder.err != nil {
		return builder
	}

	builder.memoryPolicy.SetOverCommit(attr)
	return builder
}

func (builder *MemoryPolicyBuilder) OverCommitBuilder(attrBuilder *MemoryOverCommitBuilder) *MemoryPolicyBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.OverCommit(attr)
}

func (builder *MemoryPolicyBuilder) TransparentHugePages(attr *TransparentHugePages) *MemoryPolicyBuilder {
	if builder.err != nil {
		return builder
	}

	builder.memoryPolicy.SetTransparentHugePages(attr)
	return builder
}

func (builder *MemoryPolicyBuilder) TransparentHugePagesBuilder(attrBuilder *TransparentHugePagesBuilder) *MemoryPolicyBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.TransparentHugePages(attr)
}

func (builder *MemoryPolicyBuilder) Href(href string) *MemoryPolicyBuilder {
	if builder.err != nil {
		return builder
	}

	builder.memoryPolicy.SetHref(href)
	return builder
}

func (builder *MemoryPolicyBuilder) Build() (*MemoryPolicy, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.memoryPolicy, nil
}

func (builder *MemoryPolicyBuilder) MustBuild() *MemoryPolicy {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build MemoryPolicy instance, reason: %v", builder.err))
	}
	return builder.memoryPolicy
}

type MethodBuilder struct {
	method *Method
	err    error
}

func NewMethodBuilder() *MethodBuilder {
	return &MethodBuilder{method: &Method{}, err: nil}
}

func (builder *MethodBuilder) Id(attr SsoMethod) *MethodBuilder {
	if builder.err != nil {
		return builder
	}

	builder.method.SetId(attr)
	return builder
}

func (builder *MethodBuilder) Href(href string) *MethodBuilder {
	if builder.err != nil {
		return builder
	}

	builder.method.SetHref(href)
	return builder
}

func (builder *MethodBuilder) Build() (*Method, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.method, nil
}

func (builder *MethodBuilder) MustBuild() *Method {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build Method instance, reason: %v", builder.err))
	}
	return builder.method
}

type MigrationBandwidthBuilder struct {
	migrationBandwidth *MigrationBandwidth
	err                error
}

func NewMigrationBandwidthBuilder() *MigrationBandwidthBuilder {
	return &MigrationBandwidthBuilder{migrationBandwidth: &MigrationBandwidth{}, err: nil}
}

func (builder *MigrationBandwidthBuilder) AssignmentMethod(attr MigrationBandwidthAssignmentMethod) *MigrationBandwidthBuilder {
	if builder.err != nil {
		return builder
	}

	builder.migrationBandwidth.SetAssignmentMethod(attr)
	return builder
}

func (builder *MigrationBandwidthBuilder) CustomValue(attr int64) *MigrationBandwidthBuilder {
	if builder.err != nil {
		return builder
	}

	builder.migrationBandwidth.SetCustomValue(attr)
	return builder
}

func (builder *MigrationBandwidthBuilder) Href(href string) *MigrationBandwidthBuilder {
	if builder.err != nil {
		return builder
	}

	builder.migrationBandwidth.SetHref(href)
	return builder
}

func (builder *MigrationBandwidthBuilder) Build() (*MigrationBandwidth, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.migrationBandwidth, nil
}

func (builder *MigrationBandwidthBuilder) MustBuild() *MigrationBandwidth {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build MigrationBandwidth instance, reason: %v", builder.err))
	}
	return builder.migrationBandwidth
}

type MigrationOptionsBuilder struct {
	migrationOptions *MigrationOptions
	err              error
}

func NewMigrationOptionsBuilder() *MigrationOptionsBuilder {
	return &MigrationOptionsBuilder{migrationOptions: &MigrationOptions{}, err: nil}
}

func (builder *MigrationOptionsBuilder) AutoConverge(attr InheritableBoolean) *MigrationOptionsBuilder {
	if builder.err != nil {
		return builder
	}

	builder.migrationOptions.SetAutoConverge(attr)
	return builder
}

func (builder *MigrationOptionsBuilder) Bandwidth(attr *MigrationBandwidth) *MigrationOptionsBuilder {
	if builder.err != nil {
		return builder
	}

	builder.migrationOptions.SetBandwidth(attr)
	return builder
}

func (builder *MigrationOptionsBuilder) BandwidthBuilder(attrBuilder *MigrationBandwidthBuilder) *MigrationOptionsBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Bandwidth(attr)
}

func (builder *MigrationOptionsBuilder) Compressed(attr InheritableBoolean) *MigrationOptionsBuilder {
	if builder.err != nil {
		return builder
	}

	builder.migrationOptions.SetCompressed(attr)
	return builder
}

func (builder *MigrationOptionsBuilder) Encrypted(attr InheritableBoolean) *MigrationOptionsBuilder {
	if builder.err != nil {
		return builder
	}

	builder.migrationOptions.SetEncrypted(attr)
	return builder
}

func (builder *MigrationOptionsBuilder) Policy(attr *MigrationPolicy) *MigrationOptionsBuilder {
	if builder.err != nil {
		return builder
	}

	builder.migrationOptions.SetPolicy(attr)
	return builder
}

func (builder *MigrationOptionsBuilder) PolicyBuilder(attrBuilder *MigrationPolicyBuilder) *MigrationOptionsBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Policy(attr)
}

func (builder *MigrationOptionsBuilder) Href(href string) *MigrationOptionsBuilder {
	if builder.err != nil {
		return builder
	}

	builder.migrationOptions.SetHref(href)
	return builder
}

func (builder *MigrationOptionsBuilder) Build() (*MigrationOptions, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.migrationOptions, nil
}

func (builder *MigrationOptionsBuilder) MustBuild() *MigrationOptions {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build MigrationOptions instance, reason: %v", builder.err))
	}
	return builder.migrationOptions
}

type MigrationPolicyBuilder struct {
	migrationPolicy *MigrationPolicy
	err             error
}

func NewMigrationPolicyBuilder() *MigrationPolicyBuilder {
	return &MigrationPolicyBuilder{migrationPolicy: &MigrationPolicy{}, err: nil}
}

func (builder *MigrationPolicyBuilder) Comment(attr string) *MigrationPolicyBuilder {
	if builder.err != nil {
		return builder
	}

	builder.migrationPolicy.SetComment(attr)
	return builder
}

func (builder *MigrationPolicyBuilder) Description(attr string) *MigrationPolicyBuilder {
	if builder.err != nil {
		return builder
	}

	builder.migrationPolicy.SetDescription(attr)
	return builder
}

func (builder *MigrationPolicyBuilder) Id(attr string) *MigrationPolicyBuilder {
	if builder.err != nil {
		return builder
	}

	builder.migrationPolicy.SetId(attr)
	return builder
}

func (builder *MigrationPolicyBuilder) Name(attr string) *MigrationPolicyBuilder {
	if builder.err != nil {
		return builder
	}

	builder.migrationPolicy.SetName(attr)
	return builder
}

func (builder *MigrationPolicyBuilder) Href(href string) *MigrationPolicyBuilder {
	if builder.err != nil {
		return builder
	}

	builder.migrationPolicy.SetHref(href)
	return builder
}

func (builder *MigrationPolicyBuilder) Build() (*MigrationPolicy, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.migrationPolicy, nil
}

func (builder *MigrationPolicyBuilder) MustBuild() *MigrationPolicy {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build MigrationPolicy instance, reason: %v", builder.err))
	}
	return builder.migrationPolicy
}

type NetworkBuilder struct {
	network *Network
	err     error
}

func NewNetworkBuilder() *NetworkBuilder {
	return &NetworkBuilder{network: &Network{}, err: nil}
}

func (builder *NetworkBuilder) Cluster(attr *Cluster) *NetworkBuilder {
	if builder.err != nil {
		return builder
	}

	builder.network.SetCluster(attr)
	return builder
}

func (builder *NetworkBuilder) ClusterBuilder(attrBuilder *ClusterBuilder) *NetworkBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Cluster(attr)
}

func (builder *NetworkBuilder) Comment(attr string) *NetworkBuilder {
	if builder.err != nil {
		return builder
	}

	builder.network.SetComment(attr)
	return builder
}

func (builder *NetworkBuilder) DataCenter(attr *DataCenter) *NetworkBuilder {
	if builder.err != nil {
		return builder
	}

	builder.network.SetDataCenter(attr)
	return builder
}

func (builder *NetworkBuilder) DataCenterBuilder(attrBuilder *DataCenterBuilder) *NetworkBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.DataCenter(attr)
}

func (builder *NetworkBuilder) Description(attr string) *NetworkBuilder {
	if builder.err != nil {
		return builder
	}

	builder.network.SetDescription(attr)
	return builder
}

func (builder *NetworkBuilder) Display(attr bool) *NetworkBuilder {
	if builder.err != nil {
		return builder
	}

	builder.network.SetDisplay(attr)
	return builder
}

func (builder *NetworkBuilder) DnsResolverConfiguration(attr *DnsResolverConfiguration) *NetworkBuilder {
	if builder.err != nil {
		return builder
	}

	builder.network.SetDnsResolverConfiguration(attr)
	return builder
}

func (builder *NetworkBuilder) DnsResolverConfigurationBuilder(attrBuilder *DnsResolverConfigurationBuilder) *NetworkBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.DnsResolverConfiguration(attr)
}

func (builder *NetworkBuilder) ExternalProvider(attr *OpenStackNetworkProvider) *NetworkBuilder {
	if builder.err != nil {
		return builder
	}

	builder.network.SetExternalProvider(attr)
	return builder
}

func (builder *NetworkBuilder) ExternalProviderBuilder(attrBuilder *OpenStackNetworkProviderBuilder) *NetworkBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.ExternalProvider(attr)
}

func (builder *NetworkBuilder) ExternalProviderPhysicalNetwork(attr *Network) *NetworkBuilder {
	if builder.err != nil {
		return builder
	}

	builder.network.SetExternalProviderPhysicalNetwork(attr)
	return builder
}

func (builder *NetworkBuilder) ExternalProviderPhysicalNetworkBuilder(attrBuilder *NetworkBuilder) *NetworkBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.ExternalProviderPhysicalNetwork(attr)
}

func (builder *NetworkBuilder) Id(attr string) *NetworkBuilder {
	if builder.err != nil {
		return builder
	}

	builder.network.SetId(attr)
	return builder
}

func (builder *NetworkBuilder) Ip(attr *Ip) *NetworkBuilder {
	if builder.err != nil {
		return builder
	}

	builder.network.SetIp(attr)
	return builder
}

func (builder *NetworkBuilder) IpBuilder(attrBuilder *IpBuilder) *NetworkBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Ip(attr)
}

func (builder *NetworkBuilder) Mtu(attr int64) *NetworkBuilder {
	if builder.err != nil {
		return builder
	}

	builder.network.SetMtu(attr)
	return builder
}

func (builder *NetworkBuilder) Name(attr string) *NetworkBuilder {
	if builder.err != nil {
		return builder
	}

	builder.network.SetName(attr)
	return builder
}

func (builder *NetworkBuilder) NetworkLabels(attr *NetworkLabelSlice) *NetworkBuilder {
	if builder.err != nil {
		return builder
	}

	builder.network.SetNetworkLabels(attr)
	return builder
}

func (builder *NetworkBuilder) NetworkLabelsOfAny(anys ...*NetworkLabel) *NetworkBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.network.networkLabels == nil {
		builder.network.networkLabels = new(NetworkLabelSlice)
	}
	builder.network.networkLabels.slice = append(builder.network.networkLabels.slice, anys...)
	return builder
}

func (builder *NetworkBuilder) NetworkLabelsBuilderOfAny(anyBuilders ...NetworkLabelBuilder) *NetworkBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.NetworkLabelsOfAny(attr)
	}
	return builder
}

func (builder *NetworkBuilder) Permissions(attr *PermissionSlice) *NetworkBuilder {
	if builder.err != nil {
		return builder
	}

	builder.network.SetPermissions(attr)
	return builder
}

func (builder *NetworkBuilder) PermissionsOfAny(anys ...*Permission) *NetworkBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.network.permissions == nil {
		builder.network.permissions = new(PermissionSlice)
	}
	builder.network.permissions.slice = append(builder.network.permissions.slice, anys...)
	return builder
}

func (builder *NetworkBuilder) PermissionsBuilderOfAny(anyBuilders ...PermissionBuilder) *NetworkBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.PermissionsOfAny(attr)
	}
	return builder
}

func (builder *NetworkBuilder) PortIsolation(attr bool) *NetworkBuilder {
	if builder.err != nil {
		return builder
	}

	builder.network.SetPortIsolation(attr)
	return builder
}

func (builder *NetworkBuilder) ProfileRequired(attr bool) *NetworkBuilder {
	if builder.err != nil {
		return builder
	}

	builder.network.SetProfileRequired(attr)
	return builder
}

func (builder *NetworkBuilder) Qos(attr *Qos) *NetworkBuilder {
	if builder.err != nil {
		return builder
	}

	builder.network.SetQos(attr)
	return builder
}

func (builder *NetworkBuilder) QosBuilder(attrBuilder *QosBuilder) *NetworkBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Qos(attr)
}

func (builder *NetworkBuilder) Required(attr bool) *NetworkBuilder {
	if builder.err != nil {
		return builder
	}

	builder.network.SetRequired(attr)
	return builder
}

func (builder *NetworkBuilder) Status(attr NetworkStatus) *NetworkBuilder {
	if builder.err != nil {
		return builder
	}

	builder.network.SetStatus(attr)
	return builder
}

func (builder *NetworkBuilder) Stp(attr bool) *NetworkBuilder {
	if builder.err != nil {
		return builder
	}

	builder.network.SetStp(attr)
	return builder
}

func (builder *NetworkBuilder) Usages(attr []NetworkUsage) *NetworkBuilder {
	if builder.err != nil {
		return builder
	}

	builder.network.SetUsages(attr)
	return builder
}

func (builder *NetworkBuilder) UsagesOfAny(anys ...NetworkUsage) *NetworkBuilder {
	if builder.err != nil {
		return builder
	}

	builder.network.usages = append(builder.network.usages, anys...)
	return builder
}

func (builder *NetworkBuilder) VdsmName(attr string) *NetworkBuilder {
	if builder.err != nil {
		return builder
	}

	builder.network.SetVdsmName(attr)
	return builder
}

func (builder *NetworkBuilder) Vlan(attr *Vlan) *NetworkBuilder {
	if builder.err != nil {
		return builder
	}

	builder.network.SetVlan(attr)
	return builder
}

func (builder *NetworkBuilder) VlanBuilder(attrBuilder *VlanBuilder) *NetworkBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Vlan(attr)
}

func (builder *NetworkBuilder) VnicProfiles(attr *VnicProfileSlice) *NetworkBuilder {
	if builder.err != nil {
		return builder
	}

	builder.network.SetVnicProfiles(attr)
	return builder
}

func (builder *NetworkBuilder) VnicProfilesOfAny(anys ...*VnicProfile) *NetworkBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.network.vnicProfiles == nil {
		builder.network.vnicProfiles = new(VnicProfileSlice)
	}
	builder.network.vnicProfiles.slice = append(builder.network.vnicProfiles.slice, anys...)
	return builder
}

func (builder *NetworkBuilder) VnicProfilesBuilderOfAny(anyBuilders ...VnicProfileBuilder) *NetworkBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.VnicProfilesOfAny(attr)
	}
	return builder
}

func (builder *NetworkBuilder) Href(href string) *NetworkBuilder {
	if builder.err != nil {
		return builder
	}

	builder.network.SetHref(href)
	return builder
}

func (builder *NetworkBuilder) Build() (*Network, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.network, nil
}

func (builder *NetworkBuilder) MustBuild() *Network {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build Network instance, reason: %v", builder.err))
	}
	return builder.network
}

type NetworkAttachmentBuilder struct {
	networkAttachment *NetworkAttachment
	err               error
}

func NewNetworkAttachmentBuilder() *NetworkAttachmentBuilder {
	return &NetworkAttachmentBuilder{networkAttachment: &NetworkAttachment{}, err: nil}
}

func (builder *NetworkAttachmentBuilder) Comment(attr string) *NetworkAttachmentBuilder {
	if builder.err != nil {
		return builder
	}

	builder.networkAttachment.SetComment(attr)
	return builder
}

func (builder *NetworkAttachmentBuilder) Description(attr string) *NetworkAttachmentBuilder {
	if builder.err != nil {
		return builder
	}

	builder.networkAttachment.SetDescription(attr)
	return builder
}

func (builder *NetworkAttachmentBuilder) DnsResolverConfiguration(attr *DnsResolverConfiguration) *NetworkAttachmentBuilder {
	if builder.err != nil {
		return builder
	}

	builder.networkAttachment.SetDnsResolverConfiguration(attr)
	return builder
}

func (builder *NetworkAttachmentBuilder) DnsResolverConfigurationBuilder(attrBuilder *DnsResolverConfigurationBuilder) *NetworkAttachmentBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.DnsResolverConfiguration(attr)
}

func (builder *NetworkAttachmentBuilder) Host(attr *Host) *NetworkAttachmentBuilder {
	if builder.err != nil {
		return builder
	}

	builder.networkAttachment.SetHost(attr)
	return builder
}

func (builder *NetworkAttachmentBuilder) HostBuilder(attrBuilder *HostBuilder) *NetworkAttachmentBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Host(attr)
}

func (builder *NetworkAttachmentBuilder) HostNic(attr *HostNic) *NetworkAttachmentBuilder {
	if builder.err != nil {
		return builder
	}

	builder.networkAttachment.SetHostNic(attr)
	return builder
}

func (builder *NetworkAttachmentBuilder) HostNicBuilder(attrBuilder *HostNicBuilder) *NetworkAttachmentBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.HostNic(attr)
}

func (builder *NetworkAttachmentBuilder) Id(attr string) *NetworkAttachmentBuilder {
	if builder.err != nil {
		return builder
	}

	builder.networkAttachment.SetId(attr)
	return builder
}

func (builder *NetworkAttachmentBuilder) InSync(attr bool) *NetworkAttachmentBuilder {
	if builder.err != nil {
		return builder
	}

	builder.networkAttachment.SetInSync(attr)
	return builder
}

func (builder *NetworkAttachmentBuilder) IpAddressAssignments(attr *IpAddressAssignmentSlice) *NetworkAttachmentBuilder {
	if builder.err != nil {
		return builder
	}

	builder.networkAttachment.SetIpAddressAssignments(attr)
	return builder
}

func (builder *NetworkAttachmentBuilder) IpAddressAssignmentsOfAny(anys ...*IpAddressAssignment) *NetworkAttachmentBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.networkAttachment.ipAddressAssignments == nil {
		builder.networkAttachment.ipAddressAssignments = new(IpAddressAssignmentSlice)
	}
	builder.networkAttachment.ipAddressAssignments.slice = append(builder.networkAttachment.ipAddressAssignments.slice, anys...)
	return builder
}

func (builder *NetworkAttachmentBuilder) IpAddressAssignmentsBuilderOfAny(anyBuilders ...IpAddressAssignmentBuilder) *NetworkAttachmentBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.IpAddressAssignmentsOfAny(attr)
	}
	return builder
}

func (builder *NetworkAttachmentBuilder) Name(attr string) *NetworkAttachmentBuilder {
	if builder.err != nil {
		return builder
	}

	builder.networkAttachment.SetName(attr)
	return builder
}

func (builder *NetworkAttachmentBuilder) Network(attr *Network) *NetworkAttachmentBuilder {
	if builder.err != nil {
		return builder
	}

	builder.networkAttachment.SetNetwork(attr)
	return builder
}

func (builder *NetworkAttachmentBuilder) NetworkBuilder(attrBuilder *NetworkBuilder) *NetworkAttachmentBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Network(attr)
}

func (builder *NetworkAttachmentBuilder) Properties(attr *PropertySlice) *NetworkAttachmentBuilder {
	if builder.err != nil {
		return builder
	}

	builder.networkAttachment.SetProperties(attr)
	return builder
}

func (builder *NetworkAttachmentBuilder) PropertiesOfAny(anys ...*Property) *NetworkAttachmentBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.networkAttachment.properties == nil {
		builder.networkAttachment.properties = new(PropertySlice)
	}
	builder.networkAttachment.properties.slice = append(builder.networkAttachment.properties.slice, anys...)
	return builder
}

func (builder *NetworkAttachmentBuilder) PropertiesBuilderOfAny(anyBuilders ...PropertyBuilder) *NetworkAttachmentBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.PropertiesOfAny(attr)
	}
	return builder
}

func (builder *NetworkAttachmentBuilder) Qos(attr *Qos) *NetworkAttachmentBuilder {
	if builder.err != nil {
		return builder
	}

	builder.networkAttachment.SetQos(attr)
	return builder
}

func (builder *NetworkAttachmentBuilder) QosBuilder(attrBuilder *QosBuilder) *NetworkAttachmentBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Qos(attr)
}

func (builder *NetworkAttachmentBuilder) ReportedConfigurations(attr *ReportedConfigurationSlice) *NetworkAttachmentBuilder {
	if builder.err != nil {
		return builder
	}

	builder.networkAttachment.SetReportedConfigurations(attr)
	return builder
}

func (builder *NetworkAttachmentBuilder) ReportedConfigurationsOfAny(anys ...*ReportedConfiguration) *NetworkAttachmentBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.networkAttachment.reportedConfigurations == nil {
		builder.networkAttachment.reportedConfigurations = new(ReportedConfigurationSlice)
	}
	builder.networkAttachment.reportedConfigurations.slice = append(builder.networkAttachment.reportedConfigurations.slice, anys...)
	return builder
}

func (builder *NetworkAttachmentBuilder) ReportedConfigurationsBuilderOfAny(anyBuilders ...ReportedConfigurationBuilder) *NetworkAttachmentBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.ReportedConfigurationsOfAny(attr)
	}
	return builder
}

func (builder *NetworkAttachmentBuilder) Href(href string) *NetworkAttachmentBuilder {
	if builder.err != nil {
		return builder
	}

	builder.networkAttachment.SetHref(href)
	return builder
}

func (builder *NetworkAttachmentBuilder) Build() (*NetworkAttachment, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.networkAttachment, nil
}

func (builder *NetworkAttachmentBuilder) MustBuild() *NetworkAttachment {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build NetworkAttachment instance, reason: %v", builder.err))
	}
	return builder.networkAttachment
}

type NetworkConfigurationBuilder struct {
	networkConfiguration *NetworkConfiguration
	err                  error
}

func NewNetworkConfigurationBuilder() *NetworkConfigurationBuilder {
	return &NetworkConfigurationBuilder{networkConfiguration: &NetworkConfiguration{}, err: nil}
}

func (builder *NetworkConfigurationBuilder) Dns(attr *Dns) *NetworkConfigurationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.networkConfiguration.SetDns(attr)
	return builder
}

func (builder *NetworkConfigurationBuilder) DnsBuilder(attrBuilder *DnsBuilder) *NetworkConfigurationBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Dns(attr)
}

func (builder *NetworkConfigurationBuilder) Nics(attr *NicSlice) *NetworkConfigurationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.networkConfiguration.SetNics(attr)
	return builder
}

func (builder *NetworkConfigurationBuilder) NicsOfAny(anys ...*Nic) *NetworkConfigurationBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.networkConfiguration.nics == nil {
		builder.networkConfiguration.nics = new(NicSlice)
	}
	builder.networkConfiguration.nics.slice = append(builder.networkConfiguration.nics.slice, anys...)
	return builder
}

func (builder *NetworkConfigurationBuilder) NicsBuilderOfAny(anyBuilders ...NicBuilder) *NetworkConfigurationBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.NicsOfAny(attr)
	}
	return builder
}

func (builder *NetworkConfigurationBuilder) Href(href string) *NetworkConfigurationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.networkConfiguration.SetHref(href)
	return builder
}

func (builder *NetworkConfigurationBuilder) Build() (*NetworkConfiguration, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.networkConfiguration, nil
}

func (builder *NetworkConfigurationBuilder) MustBuild() *NetworkConfiguration {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build NetworkConfiguration instance, reason: %v", builder.err))
	}
	return builder.networkConfiguration
}

type NetworkFilterBuilder struct {
	networkFilter *NetworkFilter
	err           error
}

func NewNetworkFilterBuilder() *NetworkFilterBuilder {
	return &NetworkFilterBuilder{networkFilter: &NetworkFilter{}, err: nil}
}

func (builder *NetworkFilterBuilder) Comment(attr string) *NetworkFilterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.networkFilter.SetComment(attr)
	return builder
}

func (builder *NetworkFilterBuilder) Description(attr string) *NetworkFilterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.networkFilter.SetDescription(attr)
	return builder
}

func (builder *NetworkFilterBuilder) Id(attr string) *NetworkFilterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.networkFilter.SetId(attr)
	return builder
}

func (builder *NetworkFilterBuilder) Name(attr string) *NetworkFilterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.networkFilter.SetName(attr)
	return builder
}

func (builder *NetworkFilterBuilder) Version(attr *Version) *NetworkFilterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.networkFilter.SetVersion(attr)
	return builder
}

func (builder *NetworkFilterBuilder) VersionBuilder(attrBuilder *VersionBuilder) *NetworkFilterBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Version(attr)
}

func (builder *NetworkFilterBuilder) Href(href string) *NetworkFilterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.networkFilter.SetHref(href)
	return builder
}

func (builder *NetworkFilterBuilder) Build() (*NetworkFilter, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.networkFilter, nil
}

func (builder *NetworkFilterBuilder) MustBuild() *NetworkFilter {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build NetworkFilter instance, reason: %v", builder.err))
	}
	return builder.networkFilter
}

type NetworkFilterParameterBuilder struct {
	networkFilterParameter *NetworkFilterParameter
	err                    error
}

func NewNetworkFilterParameterBuilder() *NetworkFilterParameterBuilder {
	return &NetworkFilterParameterBuilder{networkFilterParameter: &NetworkFilterParameter{}, err: nil}
}

func (builder *NetworkFilterParameterBuilder) Comment(attr string) *NetworkFilterParameterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.networkFilterParameter.SetComment(attr)
	return builder
}

func (builder *NetworkFilterParameterBuilder) Description(attr string) *NetworkFilterParameterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.networkFilterParameter.SetDescription(attr)
	return builder
}

func (builder *NetworkFilterParameterBuilder) Id(attr string) *NetworkFilterParameterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.networkFilterParameter.SetId(attr)
	return builder
}

func (builder *NetworkFilterParameterBuilder) Name(attr string) *NetworkFilterParameterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.networkFilterParameter.SetName(attr)
	return builder
}

func (builder *NetworkFilterParameterBuilder) Nic(attr *Nic) *NetworkFilterParameterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.networkFilterParameter.SetNic(attr)
	return builder
}

func (builder *NetworkFilterParameterBuilder) NicBuilder(attrBuilder *NicBuilder) *NetworkFilterParameterBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Nic(attr)
}

func (builder *NetworkFilterParameterBuilder) Value(attr string) *NetworkFilterParameterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.networkFilterParameter.SetValue(attr)
	return builder
}

func (builder *NetworkFilterParameterBuilder) Href(href string) *NetworkFilterParameterBuilder {
	if builder.err != nil {
		return builder
	}

	builder.networkFilterParameter.SetHref(href)
	return builder
}

func (builder *NetworkFilterParameterBuilder) Build() (*NetworkFilterParameter, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.networkFilterParameter, nil
}

func (builder *NetworkFilterParameterBuilder) MustBuild() *NetworkFilterParameter {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build NetworkFilterParameter instance, reason: %v", builder.err))
	}
	return builder.networkFilterParameter
}

type NetworkLabelBuilder struct {
	networkLabel *NetworkLabel
	err          error
}

func NewNetworkLabelBuilder() *NetworkLabelBuilder {
	return &NetworkLabelBuilder{networkLabel: &NetworkLabel{}, err: nil}
}

func (builder *NetworkLabelBuilder) Comment(attr string) *NetworkLabelBuilder {
	if builder.err != nil {
		return builder
	}

	builder.networkLabel.SetComment(attr)
	return builder
}

func (builder *NetworkLabelBuilder) Description(attr string) *NetworkLabelBuilder {
	if builder.err != nil {
		return builder
	}

	builder.networkLabel.SetDescription(attr)
	return builder
}

func (builder *NetworkLabelBuilder) HostNic(attr *HostNic) *NetworkLabelBuilder {
	if builder.err != nil {
		return builder
	}

	builder.networkLabel.SetHostNic(attr)
	return builder
}

func (builder *NetworkLabelBuilder) HostNicBuilder(attrBuilder *HostNicBuilder) *NetworkLabelBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.HostNic(attr)
}

func (builder *NetworkLabelBuilder) Id(attr string) *NetworkLabelBuilder {
	if builder.err != nil {
		return builder
	}

	builder.networkLabel.SetId(attr)
	return builder
}

func (builder *NetworkLabelBuilder) Name(attr string) *NetworkLabelBuilder {
	if builder.err != nil {
		return builder
	}

	builder.networkLabel.SetName(attr)
	return builder
}

func (builder *NetworkLabelBuilder) Network(attr *Network) *NetworkLabelBuilder {
	if builder.err != nil {
		return builder
	}

	builder.networkLabel.SetNetwork(attr)
	return builder
}

func (builder *NetworkLabelBuilder) NetworkBuilder(attrBuilder *NetworkBuilder) *NetworkLabelBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Network(attr)
}

func (builder *NetworkLabelBuilder) Href(href string) *NetworkLabelBuilder {
	if builder.err != nil {
		return builder
	}

	builder.networkLabel.SetHref(href)
	return builder
}

func (builder *NetworkLabelBuilder) Build() (*NetworkLabel, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.networkLabel, nil
}

func (builder *NetworkLabelBuilder) MustBuild() *NetworkLabel {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build NetworkLabel instance, reason: %v", builder.err))
	}
	return builder.networkLabel
}

type NfsProfileDetailBuilder struct {
	nfsProfileDetail *NfsProfileDetail
	err              error
}

func NewNfsProfileDetailBuilder() *NfsProfileDetailBuilder {
	return &NfsProfileDetailBuilder{nfsProfileDetail: &NfsProfileDetail{}, err: nil}
}

func (builder *NfsProfileDetailBuilder) NfsServerIp(attr string) *NfsProfileDetailBuilder {
	if builder.err != nil {
		return builder
	}

	builder.nfsProfileDetail.SetNfsServerIp(attr)
	return builder
}

func (builder *NfsProfileDetailBuilder) ProfileDetails(attr *ProfileDetailSlice) *NfsProfileDetailBuilder {
	if builder.err != nil {
		return builder
	}

	builder.nfsProfileDetail.SetProfileDetails(attr)
	return builder
}

func (builder *NfsProfileDetailBuilder) ProfileDetailsOfAny(anys ...*ProfileDetail) *NfsProfileDetailBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.nfsProfileDetail.profileDetails == nil {
		builder.nfsProfileDetail.profileDetails = new(ProfileDetailSlice)
	}
	builder.nfsProfileDetail.profileDetails.slice = append(builder.nfsProfileDetail.profileDetails.slice, anys...)
	return builder
}

func (builder *NfsProfileDetailBuilder) ProfileDetailsBuilderOfAny(anyBuilders ...ProfileDetailBuilder) *NfsProfileDetailBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.ProfileDetailsOfAny(attr)
	}
	return builder
}

func (builder *NfsProfileDetailBuilder) Href(href string) *NfsProfileDetailBuilder {
	if builder.err != nil {
		return builder
	}

	builder.nfsProfileDetail.SetHref(href)
	return builder
}

func (builder *NfsProfileDetailBuilder) Build() (*NfsProfileDetail, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.nfsProfileDetail, nil
}

func (builder *NfsProfileDetailBuilder) MustBuild() *NfsProfileDetail {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build NfsProfileDetail instance, reason: %v", builder.err))
	}
	return builder.nfsProfileDetail
}

type NicBuilder struct {
	nic *Nic
	err error
}

func NewNicBuilder() *NicBuilder {
	return &NicBuilder{nic: &Nic{}, err: nil}
}

func (builder *NicBuilder) BootProtocol(attr BootProtocol) *NicBuilder {
	if builder.err != nil {
		return builder
	}

	builder.nic.SetBootProtocol(attr)
	return builder
}

func (builder *NicBuilder) Comment(attr string) *NicBuilder {
	if builder.err != nil {
		return builder
	}

	builder.nic.SetComment(attr)
	return builder
}

func (builder *NicBuilder) Description(attr string) *NicBuilder {
	if builder.err != nil {
		return builder
	}

	builder.nic.SetDescription(attr)
	return builder
}

func (builder *NicBuilder) Id(attr string) *NicBuilder {
	if builder.err != nil {
		return builder
	}

	builder.nic.SetId(attr)
	return builder
}

func (builder *NicBuilder) InstanceType(attr *InstanceType) *NicBuilder {
	if builder.err != nil {
		return builder
	}

	builder.nic.SetInstanceType(attr)
	return builder
}

func (builder *NicBuilder) InstanceTypeBuilder(attrBuilder *InstanceTypeBuilder) *NicBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.InstanceType(attr)
}

func (builder *NicBuilder) Interface(attr NicInterface) *NicBuilder {
	if builder.err != nil {
		return builder
	}

	builder.nic.SetInterface(attr)
	return builder
}

func (builder *NicBuilder) Linked(attr bool) *NicBuilder {
	if builder.err != nil {
		return builder
	}

	builder.nic.SetLinked(attr)
	return builder
}

func (builder *NicBuilder) Mac(attr *Mac) *NicBuilder {
	if builder.err != nil {
		return builder
	}

	builder.nic.SetMac(attr)
	return builder
}

func (builder *NicBuilder) MacBuilder(attrBuilder *MacBuilder) *NicBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Mac(attr)
}

func (builder *NicBuilder) Name(attr string) *NicBuilder {
	if builder.err != nil {
		return builder
	}

	builder.nic.SetName(attr)
	return builder
}

func (builder *NicBuilder) Network(attr *Network) *NicBuilder {
	if builder.err != nil {
		return builder
	}

	builder.nic.SetNetwork(attr)
	return builder
}

func (builder *NicBuilder) NetworkBuilder(attrBuilder *NetworkBuilder) *NicBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Network(attr)
}

func (builder *NicBuilder) NetworkAttachments(attr *NetworkAttachmentSlice) *NicBuilder {
	if builder.err != nil {
		return builder
	}

	builder.nic.SetNetworkAttachments(attr)
	return builder
}

func (builder *NicBuilder) NetworkAttachmentsOfAny(anys ...*NetworkAttachment) *NicBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.nic.networkAttachments == nil {
		builder.nic.networkAttachments = new(NetworkAttachmentSlice)
	}
	builder.nic.networkAttachments.slice = append(builder.nic.networkAttachments.slice, anys...)
	return builder
}

func (builder *NicBuilder) NetworkAttachmentsBuilderOfAny(anyBuilders ...NetworkAttachmentBuilder) *NicBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.NetworkAttachmentsOfAny(attr)
	}
	return builder
}

func (builder *NicBuilder) NetworkFilterParameters(attr *NetworkFilterParameterSlice) *NicBuilder {
	if builder.err != nil {
		return builder
	}

	builder.nic.SetNetworkFilterParameters(attr)
	return builder
}

func (builder *NicBuilder) NetworkFilterParametersOfAny(anys ...*NetworkFilterParameter) *NicBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.nic.networkFilterParameters == nil {
		builder.nic.networkFilterParameters = new(NetworkFilterParameterSlice)
	}
	builder.nic.networkFilterParameters.slice = append(builder.nic.networkFilterParameters.slice, anys...)
	return builder
}

func (builder *NicBuilder) NetworkFilterParametersBuilderOfAny(anyBuilders ...NetworkFilterParameterBuilder) *NicBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.NetworkFilterParametersOfAny(attr)
	}
	return builder
}

func (builder *NicBuilder) NetworkLabels(attr *NetworkLabelSlice) *NicBuilder {
	if builder.err != nil {
		return builder
	}

	builder.nic.SetNetworkLabels(attr)
	return builder
}

func (builder *NicBuilder) NetworkLabelsOfAny(anys ...*NetworkLabel) *NicBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.nic.networkLabels == nil {
		builder.nic.networkLabels = new(NetworkLabelSlice)
	}
	builder.nic.networkLabels.slice = append(builder.nic.networkLabels.slice, anys...)
	return builder
}

func (builder *NicBuilder) NetworkLabelsBuilderOfAny(anyBuilders ...NetworkLabelBuilder) *NicBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.NetworkLabelsOfAny(attr)
	}
	return builder
}

func (builder *NicBuilder) OnBoot(attr bool) *NicBuilder {
	if builder.err != nil {
		return builder
	}

	builder.nic.SetOnBoot(attr)
	return builder
}

func (builder *NicBuilder) Plugged(attr bool) *NicBuilder {
	if builder.err != nil {
		return builder
	}

	builder.nic.SetPlugged(attr)
	return builder
}

func (builder *NicBuilder) ReportedDevices(attr *ReportedDeviceSlice) *NicBuilder {
	if builder.err != nil {
		return builder
	}

	builder.nic.SetReportedDevices(attr)
	return builder
}

func (builder *NicBuilder) ReportedDevicesOfAny(anys ...*ReportedDevice) *NicBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.nic.reportedDevices == nil {
		builder.nic.reportedDevices = new(ReportedDeviceSlice)
	}
	builder.nic.reportedDevices.slice = append(builder.nic.reportedDevices.slice, anys...)
	return builder
}

func (builder *NicBuilder) ReportedDevicesBuilderOfAny(anyBuilders ...ReportedDeviceBuilder) *NicBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.ReportedDevicesOfAny(attr)
	}
	return builder
}

func (builder *NicBuilder) Statistics(attr *StatisticSlice) *NicBuilder {
	if builder.err != nil {
		return builder
	}

	builder.nic.SetStatistics(attr)
	return builder
}

func (builder *NicBuilder) StatisticsOfAny(anys ...*Statistic) *NicBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.nic.statistics == nil {
		builder.nic.statistics = new(StatisticSlice)
	}
	builder.nic.statistics.slice = append(builder.nic.statistics.slice, anys...)
	return builder
}

func (builder *NicBuilder) StatisticsBuilderOfAny(anyBuilders ...StatisticBuilder) *NicBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.StatisticsOfAny(attr)
	}
	return builder
}

func (builder *NicBuilder) Synced(attr bool) *NicBuilder {
	if builder.err != nil {
		return builder
	}

	builder.nic.SetSynced(attr)
	return builder
}

func (builder *NicBuilder) Template(attr *Template) *NicBuilder {
	if builder.err != nil {
		return builder
	}

	builder.nic.SetTemplate(attr)
	return builder
}

func (builder *NicBuilder) TemplateBuilder(attrBuilder *TemplateBuilder) *NicBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Template(attr)
}

func (builder *NicBuilder) VirtualFunctionAllowedLabels(attr *NetworkLabelSlice) *NicBuilder {
	if builder.err != nil {
		return builder
	}

	builder.nic.SetVirtualFunctionAllowedLabels(attr)
	return builder
}

func (builder *NicBuilder) VirtualFunctionAllowedLabelsOfAny(anys ...*NetworkLabel) *NicBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.nic.virtualFunctionAllowedLabels == nil {
		builder.nic.virtualFunctionAllowedLabels = new(NetworkLabelSlice)
	}
	builder.nic.virtualFunctionAllowedLabels.slice = append(builder.nic.virtualFunctionAllowedLabels.slice, anys...)
	return builder
}

func (builder *NicBuilder) VirtualFunctionAllowedLabelsBuilderOfAny(anyBuilders ...NetworkLabelBuilder) *NicBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.VirtualFunctionAllowedLabelsOfAny(attr)
	}
	return builder
}

func (builder *NicBuilder) VirtualFunctionAllowedNetworks(attr *NetworkSlice) *NicBuilder {
	if builder.err != nil {
		return builder
	}

	builder.nic.SetVirtualFunctionAllowedNetworks(attr)
	return builder
}

func (builder *NicBuilder) VirtualFunctionAllowedNetworksOfAny(anys ...*Network) *NicBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.nic.virtualFunctionAllowedNetworks == nil {
		builder.nic.virtualFunctionAllowedNetworks = new(NetworkSlice)
	}
	builder.nic.virtualFunctionAllowedNetworks.slice = append(builder.nic.virtualFunctionAllowedNetworks.slice, anys...)
	return builder
}

func (builder *NicBuilder) VirtualFunctionAllowedNetworksBuilderOfAny(anyBuilders ...NetworkBuilder) *NicBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.VirtualFunctionAllowedNetworksOfAny(attr)
	}
	return builder
}

func (builder *NicBuilder) Vm(attr *Vm) *NicBuilder {
	if builder.err != nil {
		return builder
	}

	builder.nic.SetVm(attr)
	return builder
}

func (builder *NicBuilder) VmBuilder(attrBuilder *VmBuilder) *NicBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Vm(attr)
}

func (builder *NicBuilder) Vms(attr *VmSlice) *NicBuilder {
	if builder.err != nil {
		return builder
	}

	builder.nic.SetVms(attr)
	return builder
}

func (builder *NicBuilder) VmsOfAny(anys ...*Vm) *NicBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.nic.vms == nil {
		builder.nic.vms = new(VmSlice)
	}
	builder.nic.vms.slice = append(builder.nic.vms.slice, anys...)
	return builder
}

func (builder *NicBuilder) VmsBuilderOfAny(anyBuilders ...VmBuilder) *NicBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.VmsOfAny(attr)
	}
	return builder
}

func (builder *NicBuilder) VnicProfile(attr *VnicProfile) *NicBuilder {
	if builder.err != nil {
		return builder
	}

	builder.nic.SetVnicProfile(attr)
	return builder
}

func (builder *NicBuilder) VnicProfileBuilder(attrBuilder *VnicProfileBuilder) *NicBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.VnicProfile(attr)
}

func (builder *NicBuilder) Href(href string) *NicBuilder {
	if builder.err != nil {
		return builder
	}

	builder.nic.SetHref(href)
	return builder
}

func (builder *NicBuilder) Build() (*Nic, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.nic, nil
}

func (builder *NicBuilder) MustBuild() *Nic {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build Nic instance, reason: %v", builder.err))
	}
	return builder.nic
}

type NicConfigurationBuilder struct {
	nicConfiguration *NicConfiguration
	err              error
}

func NewNicConfigurationBuilder() *NicConfigurationBuilder {
	return &NicConfigurationBuilder{nicConfiguration: &NicConfiguration{}, err: nil}
}

func (builder *NicConfigurationBuilder) BootProtocol(attr BootProtocol) *NicConfigurationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.nicConfiguration.SetBootProtocol(attr)
	return builder
}

func (builder *NicConfigurationBuilder) Ip(attr *Ip) *NicConfigurationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.nicConfiguration.SetIp(attr)
	return builder
}

func (builder *NicConfigurationBuilder) IpBuilder(attrBuilder *IpBuilder) *NicConfigurationBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Ip(attr)
}

func (builder *NicConfigurationBuilder) Ipv6(attr *Ip) *NicConfigurationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.nicConfiguration.SetIpv6(attr)
	return builder
}

func (builder *NicConfigurationBuilder) Ipv6Builder(attrBuilder *IpBuilder) *NicConfigurationBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Ipv6(attr)
}

func (builder *NicConfigurationBuilder) Ipv6BootProtocol(attr BootProtocol) *NicConfigurationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.nicConfiguration.SetIpv6BootProtocol(attr)
	return builder
}

func (builder *NicConfigurationBuilder) Name(attr string) *NicConfigurationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.nicConfiguration.SetName(attr)
	return builder
}

func (builder *NicConfigurationBuilder) OnBoot(attr bool) *NicConfigurationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.nicConfiguration.SetOnBoot(attr)
	return builder
}

func (builder *NicConfigurationBuilder) Href(href string) *NicConfigurationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.nicConfiguration.SetHref(href)
	return builder
}

func (builder *NicConfigurationBuilder) Build() (*NicConfiguration, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.nicConfiguration, nil
}

func (builder *NicConfigurationBuilder) MustBuild() *NicConfiguration {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build NicConfiguration instance, reason: %v", builder.err))
	}
	return builder.nicConfiguration
}

type NumaNodeBuilder struct {
	numaNode *NumaNode
	err      error
}

func NewNumaNodeBuilder() *NumaNodeBuilder {
	return &NumaNodeBuilder{numaNode: &NumaNode{}, err: nil}
}

func (builder *NumaNodeBuilder) Comment(attr string) *NumaNodeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.numaNode.SetComment(attr)
	return builder
}

func (builder *NumaNodeBuilder) Cpu(attr *Cpu) *NumaNodeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.numaNode.SetCpu(attr)
	return builder
}

func (builder *NumaNodeBuilder) CpuBuilder(attrBuilder *CpuBuilder) *NumaNodeBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Cpu(attr)
}

func (builder *NumaNodeBuilder) Description(attr string) *NumaNodeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.numaNode.SetDescription(attr)
	return builder
}

func (builder *NumaNodeBuilder) Host(attr *Host) *NumaNodeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.numaNode.SetHost(attr)
	return builder
}

func (builder *NumaNodeBuilder) HostBuilder(attrBuilder *HostBuilder) *NumaNodeBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Host(attr)
}

func (builder *NumaNodeBuilder) Id(attr string) *NumaNodeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.numaNode.SetId(attr)
	return builder
}

func (builder *NumaNodeBuilder) Index(attr int64) *NumaNodeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.numaNode.SetIndex(attr)
	return builder
}

func (builder *NumaNodeBuilder) Memory(attr int64) *NumaNodeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.numaNode.SetMemory(attr)
	return builder
}

func (builder *NumaNodeBuilder) Name(attr string) *NumaNodeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.numaNode.SetName(attr)
	return builder
}

func (builder *NumaNodeBuilder) NodeDistance(attr string) *NumaNodeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.numaNode.SetNodeDistance(attr)
	return builder
}

func (builder *NumaNodeBuilder) Statistics(attr *StatisticSlice) *NumaNodeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.numaNode.SetStatistics(attr)
	return builder
}

func (builder *NumaNodeBuilder) StatisticsOfAny(anys ...*Statistic) *NumaNodeBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.numaNode.statistics == nil {
		builder.numaNode.statistics = new(StatisticSlice)
	}
	builder.numaNode.statistics.slice = append(builder.numaNode.statistics.slice, anys...)
	return builder
}

func (builder *NumaNodeBuilder) StatisticsBuilderOfAny(anyBuilders ...StatisticBuilder) *NumaNodeBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.StatisticsOfAny(attr)
	}
	return builder
}

func (builder *NumaNodeBuilder) Href(href string) *NumaNodeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.numaNode.SetHref(href)
	return builder
}

func (builder *NumaNodeBuilder) Build() (*NumaNode, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.numaNode, nil
}

func (builder *NumaNodeBuilder) MustBuild() *NumaNode {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build NumaNode instance, reason: %v", builder.err))
	}
	return builder.numaNode
}

type NumaNodePinBuilder struct {
	numaNodePin *NumaNodePin
	err         error
}

func NewNumaNodePinBuilder() *NumaNodePinBuilder {
	return &NumaNodePinBuilder{numaNodePin: &NumaNodePin{}, err: nil}
}

func (builder *NumaNodePinBuilder) HostNumaNode(attr *NumaNode) *NumaNodePinBuilder {
	if builder.err != nil {
		return builder
	}

	builder.numaNodePin.SetHostNumaNode(attr)
	return builder
}

func (builder *NumaNodePinBuilder) HostNumaNodeBuilder(attrBuilder *NumaNodeBuilder) *NumaNodePinBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.HostNumaNode(attr)
}

func (builder *NumaNodePinBuilder) Index(attr int64) *NumaNodePinBuilder {
	if builder.err != nil {
		return builder
	}

	builder.numaNodePin.SetIndex(attr)
	return builder
}

func (builder *NumaNodePinBuilder) Pinned(attr bool) *NumaNodePinBuilder {
	if builder.err != nil {
		return builder
	}

	builder.numaNodePin.SetPinned(attr)
	return builder
}

func (builder *NumaNodePinBuilder) Href(href string) *NumaNodePinBuilder {
	if builder.err != nil {
		return builder
	}

	builder.numaNodePin.SetHref(href)
	return builder
}

func (builder *NumaNodePinBuilder) Build() (*NumaNodePin, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.numaNodePin, nil
}

func (builder *NumaNodePinBuilder) MustBuild() *NumaNodePin {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build NumaNodePin instance, reason: %v", builder.err))
	}
	return builder.numaNodePin
}

type OpenStackImageBuilder struct {
	openStackImage *OpenStackImage
	err            error
}

func NewOpenStackImageBuilder() *OpenStackImageBuilder {
	return &OpenStackImageBuilder{openStackImage: &OpenStackImage{}, err: nil}
}

func (builder *OpenStackImageBuilder) Comment(attr string) *OpenStackImageBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackImage.SetComment(attr)
	return builder
}

func (builder *OpenStackImageBuilder) Description(attr string) *OpenStackImageBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackImage.SetDescription(attr)
	return builder
}

func (builder *OpenStackImageBuilder) Id(attr string) *OpenStackImageBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackImage.SetId(attr)
	return builder
}

func (builder *OpenStackImageBuilder) Name(attr string) *OpenStackImageBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackImage.SetName(attr)
	return builder
}

func (builder *OpenStackImageBuilder) OpenstackImageProvider(attr *OpenStackImageProvider) *OpenStackImageBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackImage.SetOpenstackImageProvider(attr)
	return builder
}

func (builder *OpenStackImageBuilder) OpenstackImageProviderBuilder(attrBuilder *OpenStackImageProviderBuilder) *OpenStackImageBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.OpenstackImageProvider(attr)
}

func (builder *OpenStackImageBuilder) Href(href string) *OpenStackImageBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackImage.SetHref(href)
	return builder
}

func (builder *OpenStackImageBuilder) Build() (*OpenStackImage, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.openStackImage, nil
}

func (builder *OpenStackImageBuilder) MustBuild() *OpenStackImage {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build OpenStackImage instance, reason: %v", builder.err))
	}
	return builder.openStackImage
}

type OpenStackImageProviderBuilder struct {
	openStackImageProvider *OpenStackImageProvider
	err                    error
}

func NewOpenStackImageProviderBuilder() *OpenStackImageProviderBuilder {
	return &OpenStackImageProviderBuilder{openStackImageProvider: &OpenStackImageProvider{}, err: nil}
}

func (builder *OpenStackImageProviderBuilder) AuthenticationUrl(attr string) *OpenStackImageProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackImageProvider.SetAuthenticationUrl(attr)
	return builder
}

func (builder *OpenStackImageProviderBuilder) Certificates(attr *CertificateSlice) *OpenStackImageProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackImageProvider.SetCertificates(attr)
	return builder
}

func (builder *OpenStackImageProviderBuilder) CertificatesOfAny(anys ...*Certificate) *OpenStackImageProviderBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.openStackImageProvider.certificates == nil {
		builder.openStackImageProvider.certificates = new(CertificateSlice)
	}
	builder.openStackImageProvider.certificates.slice = append(builder.openStackImageProvider.certificates.slice, anys...)
	return builder
}

func (builder *OpenStackImageProviderBuilder) CertificatesBuilderOfAny(anyBuilders ...CertificateBuilder) *OpenStackImageProviderBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.CertificatesOfAny(attr)
	}
	return builder
}

func (builder *OpenStackImageProviderBuilder) Comment(attr string) *OpenStackImageProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackImageProvider.SetComment(attr)
	return builder
}

func (builder *OpenStackImageProviderBuilder) Description(attr string) *OpenStackImageProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackImageProvider.SetDescription(attr)
	return builder
}

func (builder *OpenStackImageProviderBuilder) Id(attr string) *OpenStackImageProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackImageProvider.SetId(attr)
	return builder
}

func (builder *OpenStackImageProviderBuilder) Images(attr *OpenStackImageSlice) *OpenStackImageProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackImageProvider.SetImages(attr)
	return builder
}

func (builder *OpenStackImageProviderBuilder) ImagesOfAny(anys ...*OpenStackImage) *OpenStackImageProviderBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.openStackImageProvider.images == nil {
		builder.openStackImageProvider.images = new(OpenStackImageSlice)
	}
	builder.openStackImageProvider.images.slice = append(builder.openStackImageProvider.images.slice, anys...)
	return builder
}

func (builder *OpenStackImageProviderBuilder) ImagesBuilderOfAny(anyBuilders ...OpenStackImageBuilder) *OpenStackImageProviderBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.ImagesOfAny(attr)
	}
	return builder
}

func (builder *OpenStackImageProviderBuilder) Name(attr string) *OpenStackImageProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackImageProvider.SetName(attr)
	return builder
}

func (builder *OpenStackImageProviderBuilder) Password(attr string) *OpenStackImageProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackImageProvider.SetPassword(attr)
	return builder
}

func (builder *OpenStackImageProviderBuilder) Properties(attr *PropertySlice) *OpenStackImageProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackImageProvider.SetProperties(attr)
	return builder
}

func (builder *OpenStackImageProviderBuilder) PropertiesOfAny(anys ...*Property) *OpenStackImageProviderBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.openStackImageProvider.properties == nil {
		builder.openStackImageProvider.properties = new(PropertySlice)
	}
	builder.openStackImageProvider.properties.slice = append(builder.openStackImageProvider.properties.slice, anys...)
	return builder
}

func (builder *OpenStackImageProviderBuilder) PropertiesBuilderOfAny(anyBuilders ...PropertyBuilder) *OpenStackImageProviderBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.PropertiesOfAny(attr)
	}
	return builder
}

func (builder *OpenStackImageProviderBuilder) RequiresAuthentication(attr bool) *OpenStackImageProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackImageProvider.SetRequiresAuthentication(attr)
	return builder
}

func (builder *OpenStackImageProviderBuilder) TenantName(attr string) *OpenStackImageProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackImageProvider.SetTenantName(attr)
	return builder
}

func (builder *OpenStackImageProviderBuilder) Url(attr string) *OpenStackImageProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackImageProvider.SetUrl(attr)
	return builder
}

func (builder *OpenStackImageProviderBuilder) Username(attr string) *OpenStackImageProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackImageProvider.SetUsername(attr)
	return builder
}

func (builder *OpenStackImageProviderBuilder) Href(href string) *OpenStackImageProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackImageProvider.SetHref(href)
	return builder
}

func (builder *OpenStackImageProviderBuilder) Build() (*OpenStackImageProvider, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.openStackImageProvider, nil
}

func (builder *OpenStackImageProviderBuilder) MustBuild() *OpenStackImageProvider {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build OpenStackImageProvider instance, reason: %v", builder.err))
	}
	return builder.openStackImageProvider
}

type OpenStackNetworkBuilder struct {
	openStackNetwork *OpenStackNetwork
	err              error
}

func NewOpenStackNetworkBuilder() *OpenStackNetworkBuilder {
	return &OpenStackNetworkBuilder{openStackNetwork: &OpenStackNetwork{}, err: nil}
}

func (builder *OpenStackNetworkBuilder) Comment(attr string) *OpenStackNetworkBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackNetwork.SetComment(attr)
	return builder
}

func (builder *OpenStackNetworkBuilder) Description(attr string) *OpenStackNetworkBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackNetwork.SetDescription(attr)
	return builder
}

func (builder *OpenStackNetworkBuilder) Id(attr string) *OpenStackNetworkBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackNetwork.SetId(attr)
	return builder
}

func (builder *OpenStackNetworkBuilder) Name(attr string) *OpenStackNetworkBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackNetwork.SetName(attr)
	return builder
}

func (builder *OpenStackNetworkBuilder) OpenstackNetworkProvider(attr *OpenStackNetworkProvider) *OpenStackNetworkBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackNetwork.SetOpenstackNetworkProvider(attr)
	return builder
}

func (builder *OpenStackNetworkBuilder) OpenstackNetworkProviderBuilder(attrBuilder *OpenStackNetworkProviderBuilder) *OpenStackNetworkBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.OpenstackNetworkProvider(attr)
}

func (builder *OpenStackNetworkBuilder) Href(href string) *OpenStackNetworkBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackNetwork.SetHref(href)
	return builder
}

func (builder *OpenStackNetworkBuilder) Build() (*OpenStackNetwork, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.openStackNetwork, nil
}

func (builder *OpenStackNetworkBuilder) MustBuild() *OpenStackNetwork {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build OpenStackNetwork instance, reason: %v", builder.err))
	}
	return builder.openStackNetwork
}

type OpenStackNetworkProviderBuilder struct {
	openStackNetworkProvider *OpenStackNetworkProvider
	err                      error
}

func NewOpenStackNetworkProviderBuilder() *OpenStackNetworkProviderBuilder {
	return &OpenStackNetworkProviderBuilder{openStackNetworkProvider: &OpenStackNetworkProvider{}, err: nil}
}

func (builder *OpenStackNetworkProviderBuilder) AgentConfiguration(attr *AgentConfiguration) *OpenStackNetworkProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackNetworkProvider.SetAgentConfiguration(attr)
	return builder
}

func (builder *OpenStackNetworkProviderBuilder) AgentConfigurationBuilder(attrBuilder *AgentConfigurationBuilder) *OpenStackNetworkProviderBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.AgentConfiguration(attr)
}

func (builder *OpenStackNetworkProviderBuilder) AuthenticationUrl(attr string) *OpenStackNetworkProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackNetworkProvider.SetAuthenticationUrl(attr)
	return builder
}

func (builder *OpenStackNetworkProviderBuilder) AutoSync(attr bool) *OpenStackNetworkProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackNetworkProvider.SetAutoSync(attr)
	return builder
}

func (builder *OpenStackNetworkProviderBuilder) Certificates(attr *CertificateSlice) *OpenStackNetworkProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackNetworkProvider.SetCertificates(attr)
	return builder
}

func (builder *OpenStackNetworkProviderBuilder) CertificatesOfAny(anys ...*Certificate) *OpenStackNetworkProviderBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.openStackNetworkProvider.certificates == nil {
		builder.openStackNetworkProvider.certificates = new(CertificateSlice)
	}
	builder.openStackNetworkProvider.certificates.slice = append(builder.openStackNetworkProvider.certificates.slice, anys...)
	return builder
}

func (builder *OpenStackNetworkProviderBuilder) CertificatesBuilderOfAny(anyBuilders ...CertificateBuilder) *OpenStackNetworkProviderBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.CertificatesOfAny(attr)
	}
	return builder
}

func (builder *OpenStackNetworkProviderBuilder) Comment(attr string) *OpenStackNetworkProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackNetworkProvider.SetComment(attr)
	return builder
}

func (builder *OpenStackNetworkProviderBuilder) Description(attr string) *OpenStackNetworkProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackNetworkProvider.SetDescription(attr)
	return builder
}

func (builder *OpenStackNetworkProviderBuilder) ExternalPluginType(attr string) *OpenStackNetworkProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackNetworkProvider.SetExternalPluginType(attr)
	return builder
}

func (builder *OpenStackNetworkProviderBuilder) Id(attr string) *OpenStackNetworkProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackNetworkProvider.SetId(attr)
	return builder
}

func (builder *OpenStackNetworkProviderBuilder) Name(attr string) *OpenStackNetworkProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackNetworkProvider.SetName(attr)
	return builder
}

func (builder *OpenStackNetworkProviderBuilder) Networks(attr *OpenStackNetworkSlice) *OpenStackNetworkProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackNetworkProvider.SetNetworks(attr)
	return builder
}

func (builder *OpenStackNetworkProviderBuilder) NetworksOfAny(anys ...*OpenStackNetwork) *OpenStackNetworkProviderBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.openStackNetworkProvider.networks == nil {
		builder.openStackNetworkProvider.networks = new(OpenStackNetworkSlice)
	}
	builder.openStackNetworkProvider.networks.slice = append(builder.openStackNetworkProvider.networks.slice, anys...)
	return builder
}

func (builder *OpenStackNetworkProviderBuilder) NetworksBuilderOfAny(anyBuilders ...OpenStackNetworkBuilder) *OpenStackNetworkProviderBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.NetworksOfAny(attr)
	}
	return builder
}

func (builder *OpenStackNetworkProviderBuilder) Password(attr string) *OpenStackNetworkProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackNetworkProvider.SetPassword(attr)
	return builder
}

func (builder *OpenStackNetworkProviderBuilder) PluginType(attr NetworkPluginType) *OpenStackNetworkProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackNetworkProvider.SetPluginType(attr)
	return builder
}

func (builder *OpenStackNetworkProviderBuilder) ProjectDomainName(attr string) *OpenStackNetworkProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackNetworkProvider.SetProjectDomainName(attr)
	return builder
}

func (builder *OpenStackNetworkProviderBuilder) ProjectName(attr string) *OpenStackNetworkProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackNetworkProvider.SetProjectName(attr)
	return builder
}

func (builder *OpenStackNetworkProviderBuilder) Properties(attr *PropertySlice) *OpenStackNetworkProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackNetworkProvider.SetProperties(attr)
	return builder
}

func (builder *OpenStackNetworkProviderBuilder) PropertiesOfAny(anys ...*Property) *OpenStackNetworkProviderBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.openStackNetworkProvider.properties == nil {
		builder.openStackNetworkProvider.properties = new(PropertySlice)
	}
	builder.openStackNetworkProvider.properties.slice = append(builder.openStackNetworkProvider.properties.slice, anys...)
	return builder
}

func (builder *OpenStackNetworkProviderBuilder) PropertiesBuilderOfAny(anyBuilders ...PropertyBuilder) *OpenStackNetworkProviderBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.PropertiesOfAny(attr)
	}
	return builder
}

func (builder *OpenStackNetworkProviderBuilder) ReadOnly(attr bool) *OpenStackNetworkProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackNetworkProvider.SetReadOnly(attr)
	return builder
}

func (builder *OpenStackNetworkProviderBuilder) RequiresAuthentication(attr bool) *OpenStackNetworkProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackNetworkProvider.SetRequiresAuthentication(attr)
	return builder
}

func (builder *OpenStackNetworkProviderBuilder) Subnets(attr *OpenStackSubnetSlice) *OpenStackNetworkProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackNetworkProvider.SetSubnets(attr)
	return builder
}

func (builder *OpenStackNetworkProviderBuilder) SubnetsOfAny(anys ...*OpenStackSubnet) *OpenStackNetworkProviderBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.openStackNetworkProvider.subnets == nil {
		builder.openStackNetworkProvider.subnets = new(OpenStackSubnetSlice)
	}
	builder.openStackNetworkProvider.subnets.slice = append(builder.openStackNetworkProvider.subnets.slice, anys...)
	return builder
}

func (builder *OpenStackNetworkProviderBuilder) SubnetsBuilderOfAny(anyBuilders ...OpenStackSubnetBuilder) *OpenStackNetworkProviderBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.SubnetsOfAny(attr)
	}
	return builder
}

func (builder *OpenStackNetworkProviderBuilder) TenantName(attr string) *OpenStackNetworkProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackNetworkProvider.SetTenantName(attr)
	return builder
}

func (builder *OpenStackNetworkProviderBuilder) Type(attr OpenStackNetworkProviderType) *OpenStackNetworkProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackNetworkProvider.SetType(attr)
	return builder
}

func (builder *OpenStackNetworkProviderBuilder) Unmanaged(attr bool) *OpenStackNetworkProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackNetworkProvider.SetUnmanaged(attr)
	return builder
}

func (builder *OpenStackNetworkProviderBuilder) Url(attr string) *OpenStackNetworkProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackNetworkProvider.SetUrl(attr)
	return builder
}

func (builder *OpenStackNetworkProviderBuilder) UserDomainName(attr string) *OpenStackNetworkProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackNetworkProvider.SetUserDomainName(attr)
	return builder
}

func (builder *OpenStackNetworkProviderBuilder) Username(attr string) *OpenStackNetworkProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackNetworkProvider.SetUsername(attr)
	return builder
}

func (builder *OpenStackNetworkProviderBuilder) Href(href string) *OpenStackNetworkProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackNetworkProvider.SetHref(href)
	return builder
}

func (builder *OpenStackNetworkProviderBuilder) Build() (*OpenStackNetworkProvider, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.openStackNetworkProvider, nil
}

func (builder *OpenStackNetworkProviderBuilder) MustBuild() *OpenStackNetworkProvider {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build OpenStackNetworkProvider instance, reason: %v", builder.err))
	}
	return builder.openStackNetworkProvider
}

type OpenStackProviderBuilder struct {
	openStackProvider *OpenStackProvider
	err               error
}

func NewOpenStackProviderBuilder() *OpenStackProviderBuilder {
	return &OpenStackProviderBuilder{openStackProvider: &OpenStackProvider{}, err: nil}
}

func (builder *OpenStackProviderBuilder) AuthenticationUrl(attr string) *OpenStackProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackProvider.SetAuthenticationUrl(attr)
	return builder
}

func (builder *OpenStackProviderBuilder) Comment(attr string) *OpenStackProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackProvider.SetComment(attr)
	return builder
}

func (builder *OpenStackProviderBuilder) Description(attr string) *OpenStackProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackProvider.SetDescription(attr)
	return builder
}

func (builder *OpenStackProviderBuilder) Id(attr string) *OpenStackProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackProvider.SetId(attr)
	return builder
}

func (builder *OpenStackProviderBuilder) Name(attr string) *OpenStackProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackProvider.SetName(attr)
	return builder
}

func (builder *OpenStackProviderBuilder) Password(attr string) *OpenStackProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackProvider.SetPassword(attr)
	return builder
}

func (builder *OpenStackProviderBuilder) Properties(attr *PropertySlice) *OpenStackProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackProvider.SetProperties(attr)
	return builder
}

func (builder *OpenStackProviderBuilder) PropertiesOfAny(anys ...*Property) *OpenStackProviderBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.openStackProvider.properties == nil {
		builder.openStackProvider.properties = new(PropertySlice)
	}
	builder.openStackProvider.properties.slice = append(builder.openStackProvider.properties.slice, anys...)
	return builder
}

func (builder *OpenStackProviderBuilder) PropertiesBuilderOfAny(anyBuilders ...PropertyBuilder) *OpenStackProviderBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.PropertiesOfAny(attr)
	}
	return builder
}

func (builder *OpenStackProviderBuilder) RequiresAuthentication(attr bool) *OpenStackProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackProvider.SetRequiresAuthentication(attr)
	return builder
}

func (builder *OpenStackProviderBuilder) TenantName(attr string) *OpenStackProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackProvider.SetTenantName(attr)
	return builder
}

func (builder *OpenStackProviderBuilder) Url(attr string) *OpenStackProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackProvider.SetUrl(attr)
	return builder
}

func (builder *OpenStackProviderBuilder) Username(attr string) *OpenStackProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackProvider.SetUsername(attr)
	return builder
}

func (builder *OpenStackProviderBuilder) Href(href string) *OpenStackProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackProvider.SetHref(href)
	return builder
}

func (builder *OpenStackProviderBuilder) Build() (*OpenStackProvider, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.openStackProvider, nil
}

func (builder *OpenStackProviderBuilder) MustBuild() *OpenStackProvider {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build OpenStackProvider instance, reason: %v", builder.err))
	}
	return builder.openStackProvider
}

type OpenStackSubnetBuilder struct {
	openStackSubnet *OpenStackSubnet
	err             error
}

func NewOpenStackSubnetBuilder() *OpenStackSubnetBuilder {
	return &OpenStackSubnetBuilder{openStackSubnet: &OpenStackSubnet{}, err: nil}
}

func (builder *OpenStackSubnetBuilder) Cidr(attr string) *OpenStackSubnetBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackSubnet.SetCidr(attr)
	return builder
}

func (builder *OpenStackSubnetBuilder) Comment(attr string) *OpenStackSubnetBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackSubnet.SetComment(attr)
	return builder
}

func (builder *OpenStackSubnetBuilder) Description(attr string) *OpenStackSubnetBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackSubnet.SetDescription(attr)
	return builder
}

func (builder *OpenStackSubnetBuilder) DnsServers(attr []string) *OpenStackSubnetBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackSubnet.SetDnsServers(attr)
	return builder
}

func (builder *OpenStackSubnetBuilder) DnsServersOfAny(anys ...string) *OpenStackSubnetBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackSubnet.dnsServers = append(builder.openStackSubnet.dnsServers, anys...)
	return builder
}

func (builder *OpenStackSubnetBuilder) Gateway(attr string) *OpenStackSubnetBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackSubnet.SetGateway(attr)
	return builder
}

func (builder *OpenStackSubnetBuilder) Id(attr string) *OpenStackSubnetBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackSubnet.SetId(attr)
	return builder
}

func (builder *OpenStackSubnetBuilder) IpVersion(attr string) *OpenStackSubnetBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackSubnet.SetIpVersion(attr)
	return builder
}

func (builder *OpenStackSubnetBuilder) Name(attr string) *OpenStackSubnetBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackSubnet.SetName(attr)
	return builder
}

func (builder *OpenStackSubnetBuilder) OpenstackNetwork(attr *OpenStackNetwork) *OpenStackSubnetBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackSubnet.SetOpenstackNetwork(attr)
	return builder
}

func (builder *OpenStackSubnetBuilder) OpenstackNetworkBuilder(attrBuilder *OpenStackNetworkBuilder) *OpenStackSubnetBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.OpenstackNetwork(attr)
}

func (builder *OpenStackSubnetBuilder) Href(href string) *OpenStackSubnetBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackSubnet.SetHref(href)
	return builder
}

func (builder *OpenStackSubnetBuilder) Build() (*OpenStackSubnet, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.openStackSubnet, nil
}

func (builder *OpenStackSubnetBuilder) MustBuild() *OpenStackSubnet {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build OpenStackSubnet instance, reason: %v", builder.err))
	}
	return builder.openStackSubnet
}

type OpenStackVolumeProviderBuilder struct {
	openStackVolumeProvider *OpenStackVolumeProvider
	err                     error
}

func NewOpenStackVolumeProviderBuilder() *OpenStackVolumeProviderBuilder {
	return &OpenStackVolumeProviderBuilder{openStackVolumeProvider: &OpenStackVolumeProvider{}, err: nil}
}

func (builder *OpenStackVolumeProviderBuilder) AuthenticationKeys(attr *OpenstackVolumeAuthenticationKeySlice) *OpenStackVolumeProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackVolumeProvider.SetAuthenticationKeys(attr)
	return builder
}

func (builder *OpenStackVolumeProviderBuilder) AuthenticationKeysOfAny(anys ...*OpenstackVolumeAuthenticationKey) *OpenStackVolumeProviderBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.openStackVolumeProvider.authenticationKeys == nil {
		builder.openStackVolumeProvider.authenticationKeys = new(OpenstackVolumeAuthenticationKeySlice)
	}
	builder.openStackVolumeProvider.authenticationKeys.slice = append(builder.openStackVolumeProvider.authenticationKeys.slice, anys...)
	return builder
}

func (builder *OpenStackVolumeProviderBuilder) AuthenticationKeysBuilderOfAny(anyBuilders ...OpenstackVolumeAuthenticationKeyBuilder) *OpenStackVolumeProviderBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.AuthenticationKeysOfAny(attr)
	}
	return builder
}

func (builder *OpenStackVolumeProviderBuilder) AuthenticationUrl(attr string) *OpenStackVolumeProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackVolumeProvider.SetAuthenticationUrl(attr)
	return builder
}

func (builder *OpenStackVolumeProviderBuilder) Certificates(attr *CertificateSlice) *OpenStackVolumeProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackVolumeProvider.SetCertificates(attr)
	return builder
}

func (builder *OpenStackVolumeProviderBuilder) CertificatesOfAny(anys ...*Certificate) *OpenStackVolumeProviderBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.openStackVolumeProvider.certificates == nil {
		builder.openStackVolumeProvider.certificates = new(CertificateSlice)
	}
	builder.openStackVolumeProvider.certificates.slice = append(builder.openStackVolumeProvider.certificates.slice, anys...)
	return builder
}

func (builder *OpenStackVolumeProviderBuilder) CertificatesBuilderOfAny(anyBuilders ...CertificateBuilder) *OpenStackVolumeProviderBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.CertificatesOfAny(attr)
	}
	return builder
}

func (builder *OpenStackVolumeProviderBuilder) Comment(attr string) *OpenStackVolumeProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackVolumeProvider.SetComment(attr)
	return builder
}

func (builder *OpenStackVolumeProviderBuilder) DataCenter(attr *DataCenter) *OpenStackVolumeProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackVolumeProvider.SetDataCenter(attr)
	return builder
}

func (builder *OpenStackVolumeProviderBuilder) DataCenterBuilder(attrBuilder *DataCenterBuilder) *OpenStackVolumeProviderBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.DataCenter(attr)
}

func (builder *OpenStackVolumeProviderBuilder) Description(attr string) *OpenStackVolumeProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackVolumeProvider.SetDescription(attr)
	return builder
}

func (builder *OpenStackVolumeProviderBuilder) Id(attr string) *OpenStackVolumeProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackVolumeProvider.SetId(attr)
	return builder
}

func (builder *OpenStackVolumeProviderBuilder) Name(attr string) *OpenStackVolumeProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackVolumeProvider.SetName(attr)
	return builder
}

func (builder *OpenStackVolumeProviderBuilder) Password(attr string) *OpenStackVolumeProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackVolumeProvider.SetPassword(attr)
	return builder
}

func (builder *OpenStackVolumeProviderBuilder) Properties(attr *PropertySlice) *OpenStackVolumeProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackVolumeProvider.SetProperties(attr)
	return builder
}

func (builder *OpenStackVolumeProviderBuilder) PropertiesOfAny(anys ...*Property) *OpenStackVolumeProviderBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.openStackVolumeProvider.properties == nil {
		builder.openStackVolumeProvider.properties = new(PropertySlice)
	}
	builder.openStackVolumeProvider.properties.slice = append(builder.openStackVolumeProvider.properties.slice, anys...)
	return builder
}

func (builder *OpenStackVolumeProviderBuilder) PropertiesBuilderOfAny(anyBuilders ...PropertyBuilder) *OpenStackVolumeProviderBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.PropertiesOfAny(attr)
	}
	return builder
}

func (builder *OpenStackVolumeProviderBuilder) RequiresAuthentication(attr bool) *OpenStackVolumeProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackVolumeProvider.SetRequiresAuthentication(attr)
	return builder
}

func (builder *OpenStackVolumeProviderBuilder) TenantName(attr string) *OpenStackVolumeProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackVolumeProvider.SetTenantName(attr)
	return builder
}

func (builder *OpenStackVolumeProviderBuilder) Url(attr string) *OpenStackVolumeProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackVolumeProvider.SetUrl(attr)
	return builder
}

func (builder *OpenStackVolumeProviderBuilder) Username(attr string) *OpenStackVolumeProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackVolumeProvider.SetUsername(attr)
	return builder
}

func (builder *OpenStackVolumeProviderBuilder) VolumeTypes(attr *OpenStackVolumeTypeSlice) *OpenStackVolumeProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackVolumeProvider.SetVolumeTypes(attr)
	return builder
}

func (builder *OpenStackVolumeProviderBuilder) VolumeTypesOfAny(anys ...*OpenStackVolumeType) *OpenStackVolumeProviderBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.openStackVolumeProvider.volumeTypes == nil {
		builder.openStackVolumeProvider.volumeTypes = new(OpenStackVolumeTypeSlice)
	}
	builder.openStackVolumeProvider.volumeTypes.slice = append(builder.openStackVolumeProvider.volumeTypes.slice, anys...)
	return builder
}

func (builder *OpenStackVolumeProviderBuilder) VolumeTypesBuilderOfAny(anyBuilders ...OpenStackVolumeTypeBuilder) *OpenStackVolumeProviderBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.VolumeTypesOfAny(attr)
	}
	return builder
}

func (builder *OpenStackVolumeProviderBuilder) Href(href string) *OpenStackVolumeProviderBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackVolumeProvider.SetHref(href)
	return builder
}

func (builder *OpenStackVolumeProviderBuilder) Build() (*OpenStackVolumeProvider, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.openStackVolumeProvider, nil
}

func (builder *OpenStackVolumeProviderBuilder) MustBuild() *OpenStackVolumeProvider {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build OpenStackVolumeProvider instance, reason: %v", builder.err))
	}
	return builder.openStackVolumeProvider
}

type OpenStackVolumeTypeBuilder struct {
	openStackVolumeType *OpenStackVolumeType
	err                 error
}

func NewOpenStackVolumeTypeBuilder() *OpenStackVolumeTypeBuilder {
	return &OpenStackVolumeTypeBuilder{openStackVolumeType: &OpenStackVolumeType{}, err: nil}
}

func (builder *OpenStackVolumeTypeBuilder) Comment(attr string) *OpenStackVolumeTypeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackVolumeType.SetComment(attr)
	return builder
}

func (builder *OpenStackVolumeTypeBuilder) Description(attr string) *OpenStackVolumeTypeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackVolumeType.SetDescription(attr)
	return builder
}

func (builder *OpenStackVolumeTypeBuilder) Id(attr string) *OpenStackVolumeTypeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackVolumeType.SetId(attr)
	return builder
}

func (builder *OpenStackVolumeTypeBuilder) Name(attr string) *OpenStackVolumeTypeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackVolumeType.SetName(attr)
	return builder
}

func (builder *OpenStackVolumeTypeBuilder) OpenstackVolumeProvider(attr *OpenStackVolumeProvider) *OpenStackVolumeTypeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackVolumeType.SetOpenstackVolumeProvider(attr)
	return builder
}

func (builder *OpenStackVolumeTypeBuilder) OpenstackVolumeProviderBuilder(attrBuilder *OpenStackVolumeProviderBuilder) *OpenStackVolumeTypeBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.OpenstackVolumeProvider(attr)
}

func (builder *OpenStackVolumeTypeBuilder) Properties(attr *PropertySlice) *OpenStackVolumeTypeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackVolumeType.SetProperties(attr)
	return builder
}

func (builder *OpenStackVolumeTypeBuilder) PropertiesOfAny(anys ...*Property) *OpenStackVolumeTypeBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.openStackVolumeType.properties == nil {
		builder.openStackVolumeType.properties = new(PropertySlice)
	}
	builder.openStackVolumeType.properties.slice = append(builder.openStackVolumeType.properties.slice, anys...)
	return builder
}

func (builder *OpenStackVolumeTypeBuilder) PropertiesBuilderOfAny(anyBuilders ...PropertyBuilder) *OpenStackVolumeTypeBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.PropertiesOfAny(attr)
	}
	return builder
}

func (builder *OpenStackVolumeTypeBuilder) Href(href string) *OpenStackVolumeTypeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openStackVolumeType.SetHref(href)
	return builder
}

func (builder *OpenStackVolumeTypeBuilder) Build() (*OpenStackVolumeType, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.openStackVolumeType, nil
}

func (builder *OpenStackVolumeTypeBuilder) MustBuild() *OpenStackVolumeType {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build OpenStackVolumeType instance, reason: %v", builder.err))
	}
	return builder.openStackVolumeType
}

type OpenstackVolumeAuthenticationKeyBuilder struct {
	openstackVolumeAuthenticationKey *OpenstackVolumeAuthenticationKey
	err                              error
}

func NewOpenstackVolumeAuthenticationKeyBuilder() *OpenstackVolumeAuthenticationKeyBuilder {
	return &OpenstackVolumeAuthenticationKeyBuilder{openstackVolumeAuthenticationKey: &OpenstackVolumeAuthenticationKey{}, err: nil}
}

func (builder *OpenstackVolumeAuthenticationKeyBuilder) Comment(attr string) *OpenstackVolumeAuthenticationKeyBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openstackVolumeAuthenticationKey.SetComment(attr)
	return builder
}

func (builder *OpenstackVolumeAuthenticationKeyBuilder) CreationDate(attr time.Time) *OpenstackVolumeAuthenticationKeyBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openstackVolumeAuthenticationKey.SetCreationDate(attr)
	return builder
}

func (builder *OpenstackVolumeAuthenticationKeyBuilder) Description(attr string) *OpenstackVolumeAuthenticationKeyBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openstackVolumeAuthenticationKey.SetDescription(attr)
	return builder
}

func (builder *OpenstackVolumeAuthenticationKeyBuilder) Id(attr string) *OpenstackVolumeAuthenticationKeyBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openstackVolumeAuthenticationKey.SetId(attr)
	return builder
}

func (builder *OpenstackVolumeAuthenticationKeyBuilder) Name(attr string) *OpenstackVolumeAuthenticationKeyBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openstackVolumeAuthenticationKey.SetName(attr)
	return builder
}

func (builder *OpenstackVolumeAuthenticationKeyBuilder) OpenstackVolumeProvider(attr *OpenStackVolumeProvider) *OpenstackVolumeAuthenticationKeyBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openstackVolumeAuthenticationKey.SetOpenstackVolumeProvider(attr)
	return builder
}

func (builder *OpenstackVolumeAuthenticationKeyBuilder) OpenstackVolumeProviderBuilder(attrBuilder *OpenStackVolumeProviderBuilder) *OpenstackVolumeAuthenticationKeyBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.OpenstackVolumeProvider(attr)
}

func (builder *OpenstackVolumeAuthenticationKeyBuilder) UsageType(attr OpenstackVolumeAuthenticationKeyUsageType) *OpenstackVolumeAuthenticationKeyBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openstackVolumeAuthenticationKey.SetUsageType(attr)
	return builder
}

func (builder *OpenstackVolumeAuthenticationKeyBuilder) Uuid(attr string) *OpenstackVolumeAuthenticationKeyBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openstackVolumeAuthenticationKey.SetUuid(attr)
	return builder
}

func (builder *OpenstackVolumeAuthenticationKeyBuilder) Value(attr string) *OpenstackVolumeAuthenticationKeyBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openstackVolumeAuthenticationKey.SetValue(attr)
	return builder
}

func (builder *OpenstackVolumeAuthenticationKeyBuilder) Href(href string) *OpenstackVolumeAuthenticationKeyBuilder {
	if builder.err != nil {
		return builder
	}

	builder.openstackVolumeAuthenticationKey.SetHref(href)
	return builder
}

func (builder *OpenstackVolumeAuthenticationKeyBuilder) Build() (*OpenstackVolumeAuthenticationKey, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.openstackVolumeAuthenticationKey, nil
}

func (builder *OpenstackVolumeAuthenticationKeyBuilder) MustBuild() *OpenstackVolumeAuthenticationKey {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build OpenstackVolumeAuthenticationKey instance, reason: %v", builder.err))
	}
	return builder.openstackVolumeAuthenticationKey
}

type OperatingSystemBuilder struct {
	operatingSystem *OperatingSystem
	err             error
}

func NewOperatingSystemBuilder() *OperatingSystemBuilder {
	return &OperatingSystemBuilder{operatingSystem: &OperatingSystem{}, err: nil}
}

func (builder *OperatingSystemBuilder) Boot(attr *Boot) *OperatingSystemBuilder {
	if builder.err != nil {
		return builder
	}

	builder.operatingSystem.SetBoot(attr)
	return builder
}

func (builder *OperatingSystemBuilder) BootBuilder(attrBuilder *BootBuilder) *OperatingSystemBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Boot(attr)
}

func (builder *OperatingSystemBuilder) Cmdline(attr string) *OperatingSystemBuilder {
	if builder.err != nil {
		return builder
	}

	builder.operatingSystem.SetCmdline(attr)
	return builder
}

func (builder *OperatingSystemBuilder) CustomKernelCmdline(attr string) *OperatingSystemBuilder {
	if builder.err != nil {
		return builder
	}

	builder.operatingSystem.SetCustomKernelCmdline(attr)
	return builder
}

func (builder *OperatingSystemBuilder) Initrd(attr string) *OperatingSystemBuilder {
	if builder.err != nil {
		return builder
	}

	builder.operatingSystem.SetInitrd(attr)
	return builder
}

func (builder *OperatingSystemBuilder) Kernel(attr string) *OperatingSystemBuilder {
	if builder.err != nil {
		return builder
	}

	builder.operatingSystem.SetKernel(attr)
	return builder
}

func (builder *OperatingSystemBuilder) ReportedKernelCmdline(attr string) *OperatingSystemBuilder {
	if builder.err != nil {
		return builder
	}

	builder.operatingSystem.SetReportedKernelCmdline(attr)
	return builder
}

func (builder *OperatingSystemBuilder) Type(attr string) *OperatingSystemBuilder {
	if builder.err != nil {
		return builder
	}

	builder.operatingSystem.SetType(attr)
	return builder
}

func (builder *OperatingSystemBuilder) Version(attr *Version) *OperatingSystemBuilder {
	if builder.err != nil {
		return builder
	}

	builder.operatingSystem.SetVersion(attr)
	return builder
}

func (builder *OperatingSystemBuilder) VersionBuilder(attrBuilder *VersionBuilder) *OperatingSystemBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Version(attr)
}

func (builder *OperatingSystemBuilder) Href(href string) *OperatingSystemBuilder {
	if builder.err != nil {
		return builder
	}

	builder.operatingSystem.SetHref(href)
	return builder
}

func (builder *OperatingSystemBuilder) Build() (*OperatingSystem, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.operatingSystem, nil
}

func (builder *OperatingSystemBuilder) MustBuild() *OperatingSystem {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build OperatingSystem instance, reason: %v", builder.err))
	}
	return builder.operatingSystem
}

type OperatingSystemInfoBuilder struct {
	operatingSystemInfo *OperatingSystemInfo
	err                 error
}

func NewOperatingSystemInfoBuilder() *OperatingSystemInfoBuilder {
	return &OperatingSystemInfoBuilder{operatingSystemInfo: &OperatingSystemInfo{}, err: nil}
}

func (builder *OperatingSystemInfoBuilder) Architecture(attr Architecture) *OperatingSystemInfoBuilder {
	if builder.err != nil {
		return builder
	}

	builder.operatingSystemInfo.SetArchitecture(attr)
	return builder
}

func (builder *OperatingSystemInfoBuilder) Comment(attr string) *OperatingSystemInfoBuilder {
	if builder.err != nil {
		return builder
	}

	builder.operatingSystemInfo.SetComment(attr)
	return builder
}

func (builder *OperatingSystemInfoBuilder) Description(attr string) *OperatingSystemInfoBuilder {
	if builder.err != nil {
		return builder
	}

	builder.operatingSystemInfo.SetDescription(attr)
	return builder
}

func (builder *OperatingSystemInfoBuilder) Id(attr string) *OperatingSystemInfoBuilder {
	if builder.err != nil {
		return builder
	}

	builder.operatingSystemInfo.SetId(attr)
	return builder
}

func (builder *OperatingSystemInfoBuilder) LargeIcon(attr *Icon) *OperatingSystemInfoBuilder {
	if builder.err != nil {
		return builder
	}

	builder.operatingSystemInfo.SetLargeIcon(attr)
	return builder
}

func (builder *OperatingSystemInfoBuilder) LargeIconBuilder(attrBuilder *IconBuilder) *OperatingSystemInfoBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.LargeIcon(attr)
}

func (builder *OperatingSystemInfoBuilder) Name(attr string) *OperatingSystemInfoBuilder {
	if builder.err != nil {
		return builder
	}

	builder.operatingSystemInfo.SetName(attr)
	return builder
}

func (builder *OperatingSystemInfoBuilder) SmallIcon(attr *Icon) *OperatingSystemInfoBuilder {
	if builder.err != nil {
		return builder
	}

	builder.operatingSystemInfo.SetSmallIcon(attr)
	return builder
}

func (builder *OperatingSystemInfoBuilder) SmallIconBuilder(attrBuilder *IconBuilder) *OperatingSystemInfoBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.SmallIcon(attr)
}

func (builder *OperatingSystemInfoBuilder) Href(href string) *OperatingSystemInfoBuilder {
	if builder.err != nil {
		return builder
	}

	builder.operatingSystemInfo.SetHref(href)
	return builder
}

func (builder *OperatingSystemInfoBuilder) Build() (*OperatingSystemInfo, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.operatingSystemInfo, nil
}

func (builder *OperatingSystemInfoBuilder) MustBuild() *OperatingSystemInfo {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build OperatingSystemInfo instance, reason: %v", builder.err))
	}
	return builder.operatingSystemInfo
}

type OptionBuilder struct {
	option *Option
	err    error
}

func NewOptionBuilder() *OptionBuilder {
	return &OptionBuilder{option: &Option{}, err: nil}
}

func (builder *OptionBuilder) Name(attr string) *OptionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.option.SetName(attr)
	return builder
}

func (builder *OptionBuilder) Type(attr string) *OptionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.option.SetType(attr)
	return builder
}

func (builder *OptionBuilder) Value(attr string) *OptionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.option.SetValue(attr)
	return builder
}

func (builder *OptionBuilder) Href(href string) *OptionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.option.SetHref(href)
	return builder
}

func (builder *OptionBuilder) Build() (*Option, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.option, nil
}

func (builder *OptionBuilder) MustBuild() *Option {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build Option instance, reason: %v", builder.err))
	}
	return builder.option
}

type PackageBuilder struct {
	package_ *Package
	err      error
}

func NewPackageBuilder() *PackageBuilder {
	return &PackageBuilder{package_: &Package{}, err: nil}
}

func (builder *PackageBuilder) Name(attr string) *PackageBuilder {
	if builder.err != nil {
		return builder
	}

	builder.package_.SetName(attr)
	return builder
}

func (builder *PackageBuilder) Href(href string) *PackageBuilder {
	if builder.err != nil {
		return builder
	}

	builder.package_.SetHref(href)
	return builder
}

func (builder *PackageBuilder) Build() (*Package, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.package_, nil
}

func (builder *PackageBuilder) MustBuild() *Package {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build Package instance, reason: %v", builder.err))
	}
	return builder.package_
}

type PayloadBuilder struct {
	payload *Payload
	err     error
}

func NewPayloadBuilder() *PayloadBuilder {
	return &PayloadBuilder{payload: &Payload{}, err: nil}
}

func (builder *PayloadBuilder) Files(attr *FileSlice) *PayloadBuilder {
	if builder.err != nil {
		return builder
	}

	builder.payload.SetFiles(attr)
	return builder
}

func (builder *PayloadBuilder) FilesOfAny(anys ...*File) *PayloadBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.payload.files == nil {
		builder.payload.files = new(FileSlice)
	}
	builder.payload.files.slice = append(builder.payload.files.slice, anys...)
	return builder
}

func (builder *PayloadBuilder) FilesBuilderOfAny(anyBuilders ...FileBuilder) *PayloadBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.FilesOfAny(attr)
	}
	return builder
}

func (builder *PayloadBuilder) Type(attr VmDeviceType) *PayloadBuilder {
	if builder.err != nil {
		return builder
	}

	builder.payload.SetType(attr)
	return builder
}

func (builder *PayloadBuilder) VolumeId(attr string) *PayloadBuilder {
	if builder.err != nil {
		return builder
	}

	builder.payload.SetVolumeId(attr)
	return builder
}

func (builder *PayloadBuilder) Href(href string) *PayloadBuilder {
	if builder.err != nil {
		return builder
	}

	builder.payload.SetHref(href)
	return builder
}

func (builder *PayloadBuilder) Build() (*Payload, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.payload, nil
}

func (builder *PayloadBuilder) MustBuild() *Payload {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build Payload instance, reason: %v", builder.err))
	}
	return builder.payload
}

type PermissionBuilder struct {
	permission *Permission
	err        error
}

func NewPermissionBuilder() *PermissionBuilder {
	return &PermissionBuilder{permission: &Permission{}, err: nil}
}

func (builder *PermissionBuilder) Cluster(attr *Cluster) *PermissionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.permission.SetCluster(attr)
	return builder
}

func (builder *PermissionBuilder) ClusterBuilder(attrBuilder *ClusterBuilder) *PermissionBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Cluster(attr)
}

func (builder *PermissionBuilder) Comment(attr string) *PermissionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.permission.SetComment(attr)
	return builder
}

func (builder *PermissionBuilder) DataCenter(attr *DataCenter) *PermissionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.permission.SetDataCenter(attr)
	return builder
}

func (builder *PermissionBuilder) DataCenterBuilder(attrBuilder *DataCenterBuilder) *PermissionBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.DataCenter(attr)
}

func (builder *PermissionBuilder) Description(attr string) *PermissionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.permission.SetDescription(attr)
	return builder
}

func (builder *PermissionBuilder) Disk(attr *Disk) *PermissionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.permission.SetDisk(attr)
	return builder
}

func (builder *PermissionBuilder) DiskBuilder(attrBuilder *DiskBuilder) *PermissionBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Disk(attr)
}

func (builder *PermissionBuilder) Group(attr *Group) *PermissionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.permission.SetGroup(attr)
	return builder
}

func (builder *PermissionBuilder) GroupBuilder(attrBuilder *GroupBuilder) *PermissionBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Group(attr)
}

func (builder *PermissionBuilder) Host(attr *Host) *PermissionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.permission.SetHost(attr)
	return builder
}

func (builder *PermissionBuilder) HostBuilder(attrBuilder *HostBuilder) *PermissionBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Host(attr)
}

func (builder *PermissionBuilder) Id(attr string) *PermissionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.permission.SetId(attr)
	return builder
}

func (builder *PermissionBuilder) Name(attr string) *PermissionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.permission.SetName(attr)
	return builder
}

func (builder *PermissionBuilder) Role(attr *Role) *PermissionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.permission.SetRole(attr)
	return builder
}

func (builder *PermissionBuilder) RoleBuilder(attrBuilder *RoleBuilder) *PermissionBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Role(attr)
}

func (builder *PermissionBuilder) StorageDomain(attr *StorageDomain) *PermissionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.permission.SetStorageDomain(attr)
	return builder
}

func (builder *PermissionBuilder) StorageDomainBuilder(attrBuilder *StorageDomainBuilder) *PermissionBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.StorageDomain(attr)
}

func (builder *PermissionBuilder) Template(attr *Template) *PermissionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.permission.SetTemplate(attr)
	return builder
}

func (builder *PermissionBuilder) TemplateBuilder(attrBuilder *TemplateBuilder) *PermissionBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Template(attr)
}

func (builder *PermissionBuilder) User(attr *User) *PermissionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.permission.SetUser(attr)
	return builder
}

func (builder *PermissionBuilder) UserBuilder(attrBuilder *UserBuilder) *PermissionBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.User(attr)
}

func (builder *PermissionBuilder) Vm(attr *Vm) *PermissionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.permission.SetVm(attr)
	return builder
}

func (builder *PermissionBuilder) VmBuilder(attrBuilder *VmBuilder) *PermissionBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Vm(attr)
}

func (builder *PermissionBuilder) VmPool(attr *VmPool) *PermissionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.permission.SetVmPool(attr)
	return builder
}

func (builder *PermissionBuilder) VmPoolBuilder(attrBuilder *VmPoolBuilder) *PermissionBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.VmPool(attr)
}

func (builder *PermissionBuilder) Href(href string) *PermissionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.permission.SetHref(href)
	return builder
}

func (builder *PermissionBuilder) Build() (*Permission, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.permission, nil
}

func (builder *PermissionBuilder) MustBuild() *Permission {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build Permission instance, reason: %v", builder.err))
	}
	return builder.permission
}

type PermitBuilder struct {
	permit *Permit
	err    error
}

func NewPermitBuilder() *PermitBuilder {
	return &PermitBuilder{permit: &Permit{}, err: nil}
}

func (builder *PermitBuilder) Administrative(attr bool) *PermitBuilder {
	if builder.err != nil {
		return builder
	}

	builder.permit.SetAdministrative(attr)
	return builder
}

func (builder *PermitBuilder) Comment(attr string) *PermitBuilder {
	if builder.err != nil {
		return builder
	}

	builder.permit.SetComment(attr)
	return builder
}

func (builder *PermitBuilder) Description(attr string) *PermitBuilder {
	if builder.err != nil {
		return builder
	}

	builder.permit.SetDescription(attr)
	return builder
}

func (builder *PermitBuilder) Id(attr string) *PermitBuilder {
	if builder.err != nil {
		return builder
	}

	builder.permit.SetId(attr)
	return builder
}

func (builder *PermitBuilder) Name(attr string) *PermitBuilder {
	if builder.err != nil {
		return builder
	}

	builder.permit.SetName(attr)
	return builder
}

func (builder *PermitBuilder) Role(attr *Role) *PermitBuilder {
	if builder.err != nil {
		return builder
	}

	builder.permit.SetRole(attr)
	return builder
}

func (builder *PermitBuilder) RoleBuilder(attrBuilder *RoleBuilder) *PermitBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Role(attr)
}

func (builder *PermitBuilder) Href(href string) *PermitBuilder {
	if builder.err != nil {
		return builder
	}

	builder.permit.SetHref(href)
	return builder
}

func (builder *PermitBuilder) Build() (*Permit, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.permit, nil
}

func (builder *PermitBuilder) MustBuild() *Permit {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build Permit instance, reason: %v", builder.err))
	}
	return builder.permit
}

type PmProxyBuilder struct {
	pmProxy *PmProxy
	err     error
}

func NewPmProxyBuilder() *PmProxyBuilder {
	return &PmProxyBuilder{pmProxy: &PmProxy{}, err: nil}
}

func (builder *PmProxyBuilder) Type(attr PmProxyType) *PmProxyBuilder {
	if builder.err != nil {
		return builder
	}

	builder.pmProxy.SetType(attr)
	return builder
}

func (builder *PmProxyBuilder) Href(href string) *PmProxyBuilder {
	if builder.err != nil {
		return builder
	}

	builder.pmProxy.SetHref(href)
	return builder
}

func (builder *PmProxyBuilder) Build() (*PmProxy, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.pmProxy, nil
}

func (builder *PmProxyBuilder) MustBuild() *PmProxy {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build PmProxy instance, reason: %v", builder.err))
	}
	return builder.pmProxy
}

type PortMirroringBuilder struct {
	portMirroring *PortMirroring
	err           error
}

func NewPortMirroringBuilder() *PortMirroringBuilder {
	return &PortMirroringBuilder{portMirroring: &PortMirroring{}, err: nil}
}

func (builder *PortMirroringBuilder) Href(href string) *PortMirroringBuilder {
	if builder.err != nil {
		return builder
	}

	builder.portMirroring.SetHref(href)
	return builder
}

func (builder *PortMirroringBuilder) Build() (*PortMirroring, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.portMirroring, nil
}

func (builder *PortMirroringBuilder) MustBuild() *PortMirroring {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build PortMirroring instance, reason: %v", builder.err))
	}
	return builder.portMirroring
}

type PowerManagementBuilder struct {
	powerManagement *PowerManagement
	err             error
}

func NewPowerManagementBuilder() *PowerManagementBuilder {
	return &PowerManagementBuilder{powerManagement: &PowerManagement{}, err: nil}
}

func (builder *PowerManagementBuilder) Address(attr string) *PowerManagementBuilder {
	if builder.err != nil {
		return builder
	}

	builder.powerManagement.SetAddress(attr)
	return builder
}

func (builder *PowerManagementBuilder) Agents(attr *AgentSlice) *PowerManagementBuilder {
	if builder.err != nil {
		return builder
	}

	builder.powerManagement.SetAgents(attr)
	return builder
}

func (builder *PowerManagementBuilder) AgentsOfAny(anys ...*Agent) *PowerManagementBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.powerManagement.agents == nil {
		builder.powerManagement.agents = new(AgentSlice)
	}
	builder.powerManagement.agents.slice = append(builder.powerManagement.agents.slice, anys...)
	return builder
}

func (builder *PowerManagementBuilder) AgentsBuilderOfAny(anyBuilders ...AgentBuilder) *PowerManagementBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.AgentsOfAny(attr)
	}
	return builder
}

func (builder *PowerManagementBuilder) AutomaticPmEnabled(attr bool) *PowerManagementBuilder {
	if builder.err != nil {
		return builder
	}

	builder.powerManagement.SetAutomaticPmEnabled(attr)
	return builder
}

func (builder *PowerManagementBuilder) Enabled(attr bool) *PowerManagementBuilder {
	if builder.err != nil {
		return builder
	}

	builder.powerManagement.SetEnabled(attr)
	return builder
}

func (builder *PowerManagementBuilder) KdumpDetection(attr bool) *PowerManagementBuilder {
	if builder.err != nil {
		return builder
	}

	builder.powerManagement.SetKdumpDetection(attr)
	return builder
}

func (builder *PowerManagementBuilder) Options(attr *OptionSlice) *PowerManagementBuilder {
	if builder.err != nil {
		return builder
	}

	builder.powerManagement.SetOptions(attr)
	return builder
}

func (builder *PowerManagementBuilder) OptionsOfAny(anys ...*Option) *PowerManagementBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.powerManagement.options == nil {
		builder.powerManagement.options = new(OptionSlice)
	}
	builder.powerManagement.options.slice = append(builder.powerManagement.options.slice, anys...)
	return builder
}

func (builder *PowerManagementBuilder) OptionsBuilderOfAny(anyBuilders ...OptionBuilder) *PowerManagementBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.OptionsOfAny(attr)
	}
	return builder
}

func (builder *PowerManagementBuilder) Password(attr string) *PowerManagementBuilder {
	if builder.err != nil {
		return builder
	}

	builder.powerManagement.SetPassword(attr)
	return builder
}

func (builder *PowerManagementBuilder) PmProxies(attr *PmProxySlice) *PowerManagementBuilder {
	if builder.err != nil {
		return builder
	}

	builder.powerManagement.SetPmProxies(attr)
	return builder
}

func (builder *PowerManagementBuilder) PmProxiesOfAny(anys ...*PmProxy) *PowerManagementBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.powerManagement.pmProxies == nil {
		builder.powerManagement.pmProxies = new(PmProxySlice)
	}
	builder.powerManagement.pmProxies.slice = append(builder.powerManagement.pmProxies.slice, anys...)
	return builder
}

func (builder *PowerManagementBuilder) PmProxiesBuilderOfAny(anyBuilders ...PmProxyBuilder) *PowerManagementBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.PmProxiesOfAny(attr)
	}
	return builder
}

func (builder *PowerManagementBuilder) Status(attr PowerManagementStatus) *PowerManagementBuilder {
	if builder.err != nil {
		return builder
	}

	builder.powerManagement.SetStatus(attr)
	return builder
}

func (builder *PowerManagementBuilder) Type(attr string) *PowerManagementBuilder {
	if builder.err != nil {
		return builder
	}

	builder.powerManagement.SetType(attr)
	return builder
}

func (builder *PowerManagementBuilder) Username(attr string) *PowerManagementBuilder {
	if builder.err != nil {
		return builder
	}

	builder.powerManagement.SetUsername(attr)
	return builder
}

func (builder *PowerManagementBuilder) Href(href string) *PowerManagementBuilder {
	if builder.err != nil {
		return builder
	}

	builder.powerManagement.SetHref(href)
	return builder
}

func (builder *PowerManagementBuilder) Build() (*PowerManagement, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.powerManagement, nil
}

func (builder *PowerManagementBuilder) MustBuild() *PowerManagement {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build PowerManagement instance, reason: %v", builder.err))
	}
	return builder.powerManagement
}

type ProductBuilder struct {
	product *Product
	err     error
}

func NewProductBuilder() *ProductBuilder {
	return &ProductBuilder{product: &Product{}, err: nil}
}

func (builder *ProductBuilder) Comment(attr string) *ProductBuilder {
	if builder.err != nil {
		return builder
	}

	builder.product.SetComment(attr)
	return builder
}

func (builder *ProductBuilder) Description(attr string) *ProductBuilder {
	if builder.err != nil {
		return builder
	}

	builder.product.SetDescription(attr)
	return builder
}

func (builder *ProductBuilder) Id(attr string) *ProductBuilder {
	if builder.err != nil {
		return builder
	}

	builder.product.SetId(attr)
	return builder
}

func (builder *ProductBuilder) Name(attr string) *ProductBuilder {
	if builder.err != nil {
		return builder
	}

	builder.product.SetName(attr)
	return builder
}

func (builder *ProductBuilder) Href(href string) *ProductBuilder {
	if builder.err != nil {
		return builder
	}

	builder.product.SetHref(href)
	return builder
}

func (builder *ProductBuilder) Build() (*Product, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.product, nil
}

func (builder *ProductBuilder) MustBuild() *Product {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build Product instance, reason: %v", builder.err))
	}
	return builder.product
}

type ProductInfoBuilder struct {
	productInfo *ProductInfo
	err         error
}

func NewProductInfoBuilder() *ProductInfoBuilder {
	return &ProductInfoBuilder{productInfo: &ProductInfo{}, err: nil}
}

func (builder *ProductInfoBuilder) InstanceId(attr string) *ProductInfoBuilder {
	if builder.err != nil {
		return builder
	}

	builder.productInfo.SetInstanceId(attr)
	return builder
}

func (builder *ProductInfoBuilder) Name(attr string) *ProductInfoBuilder {
	if builder.err != nil {
		return builder
	}

	builder.productInfo.SetName(attr)
	return builder
}

func (builder *ProductInfoBuilder) Vendor(attr string) *ProductInfoBuilder {
	if builder.err != nil {
		return builder
	}

	builder.productInfo.SetVendor(attr)
	return builder
}

func (builder *ProductInfoBuilder) Version(attr *Version) *ProductInfoBuilder {
	if builder.err != nil {
		return builder
	}

	builder.productInfo.SetVersion(attr)
	return builder
}

func (builder *ProductInfoBuilder) VersionBuilder(attrBuilder *VersionBuilder) *ProductInfoBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Version(attr)
}

func (builder *ProductInfoBuilder) Href(href string) *ProductInfoBuilder {
	if builder.err != nil {
		return builder
	}

	builder.productInfo.SetHref(href)
	return builder
}

func (builder *ProductInfoBuilder) Build() (*ProductInfo, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.productInfo, nil
}

func (builder *ProductInfoBuilder) MustBuild() *ProductInfo {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build ProductInfo instance, reason: %v", builder.err))
	}
	return builder.productInfo
}

type ProfileDetailBuilder struct {
	profileDetail *ProfileDetail
	err           error
}

func NewProfileDetailBuilder() *ProfileDetailBuilder {
	return &ProfileDetailBuilder{profileDetail: &ProfileDetail{}, err: nil}
}

func (builder *ProfileDetailBuilder) BlockStatistics(attr *BlockStatisticSlice) *ProfileDetailBuilder {
	if builder.err != nil {
		return builder
	}

	builder.profileDetail.SetBlockStatistics(attr)
	return builder
}

func (builder *ProfileDetailBuilder) BlockStatisticsOfAny(anys ...*BlockStatistic) *ProfileDetailBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.profileDetail.blockStatistics == nil {
		builder.profileDetail.blockStatistics = new(BlockStatisticSlice)
	}
	builder.profileDetail.blockStatistics.slice = append(builder.profileDetail.blockStatistics.slice, anys...)
	return builder
}

func (builder *ProfileDetailBuilder) BlockStatisticsBuilderOfAny(anyBuilders ...BlockStatisticBuilder) *ProfileDetailBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.BlockStatisticsOfAny(attr)
	}
	return builder
}

func (builder *ProfileDetailBuilder) Duration(attr int64) *ProfileDetailBuilder {
	if builder.err != nil {
		return builder
	}

	builder.profileDetail.SetDuration(attr)
	return builder
}

func (builder *ProfileDetailBuilder) FopStatistics(attr *FopStatisticSlice) *ProfileDetailBuilder {
	if builder.err != nil {
		return builder
	}

	builder.profileDetail.SetFopStatistics(attr)
	return builder
}

func (builder *ProfileDetailBuilder) FopStatisticsOfAny(anys ...*FopStatistic) *ProfileDetailBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.profileDetail.fopStatistics == nil {
		builder.profileDetail.fopStatistics = new(FopStatisticSlice)
	}
	builder.profileDetail.fopStatistics.slice = append(builder.profileDetail.fopStatistics.slice, anys...)
	return builder
}

func (builder *ProfileDetailBuilder) FopStatisticsBuilderOfAny(anyBuilders ...FopStatisticBuilder) *ProfileDetailBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.FopStatisticsOfAny(attr)
	}
	return builder
}

func (builder *ProfileDetailBuilder) ProfileType(attr string) *ProfileDetailBuilder {
	if builder.err != nil {
		return builder
	}

	builder.profileDetail.SetProfileType(attr)
	return builder
}

func (builder *ProfileDetailBuilder) Statistics(attr *StatisticSlice) *ProfileDetailBuilder {
	if builder.err != nil {
		return builder
	}

	builder.profileDetail.SetStatistics(attr)
	return builder
}

func (builder *ProfileDetailBuilder) StatisticsOfAny(anys ...*Statistic) *ProfileDetailBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.profileDetail.statistics == nil {
		builder.profileDetail.statistics = new(StatisticSlice)
	}
	builder.profileDetail.statistics.slice = append(builder.profileDetail.statistics.slice, anys...)
	return builder
}

func (builder *ProfileDetailBuilder) StatisticsBuilderOfAny(anyBuilders ...StatisticBuilder) *ProfileDetailBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.StatisticsOfAny(attr)
	}
	return builder
}

func (builder *ProfileDetailBuilder) Href(href string) *ProfileDetailBuilder {
	if builder.err != nil {
		return builder
	}

	builder.profileDetail.SetHref(href)
	return builder
}

func (builder *ProfileDetailBuilder) Build() (*ProfileDetail, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.profileDetail, nil
}

func (builder *ProfileDetailBuilder) MustBuild() *ProfileDetail {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build ProfileDetail instance, reason: %v", builder.err))
	}
	return builder.profileDetail
}

type PropertyBuilder struct {
	property *Property
	err      error
}

func NewPropertyBuilder() *PropertyBuilder {
	return &PropertyBuilder{property: &Property{}, err: nil}
}

func (builder *PropertyBuilder) Name(attr string) *PropertyBuilder {
	if builder.err != nil {
		return builder
	}

	builder.property.SetName(attr)
	return builder
}

func (builder *PropertyBuilder) Value(attr string) *PropertyBuilder {
	if builder.err != nil {
		return builder
	}

	builder.property.SetValue(attr)
	return builder
}

func (builder *PropertyBuilder) Href(href string) *PropertyBuilder {
	if builder.err != nil {
		return builder
	}

	builder.property.SetHref(href)
	return builder
}

func (builder *PropertyBuilder) Build() (*Property, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.property, nil
}

func (builder *PropertyBuilder) MustBuild() *Property {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build Property instance, reason: %v", builder.err))
	}
	return builder.property
}

type ProxyTicketBuilder struct {
	proxyTicket *ProxyTicket
	err         error
}

func NewProxyTicketBuilder() *ProxyTicketBuilder {
	return &ProxyTicketBuilder{proxyTicket: &ProxyTicket{}, err: nil}
}

func (builder *ProxyTicketBuilder) Value(attr string) *ProxyTicketBuilder {
	if builder.err != nil {
		return builder
	}

	builder.proxyTicket.SetValue(attr)
	return builder
}

func (builder *ProxyTicketBuilder) Href(href string) *ProxyTicketBuilder {
	if builder.err != nil {
		return builder
	}

	builder.proxyTicket.SetHref(href)
	return builder
}

func (builder *ProxyTicketBuilder) Build() (*ProxyTicket, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.proxyTicket, nil
}

func (builder *ProxyTicketBuilder) MustBuild() *ProxyTicket {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build ProxyTicket instance, reason: %v", builder.err))
	}
	return builder.proxyTicket
}

type QosBuilder struct {
	qos *Qos
	err error
}

func NewQosBuilder() *QosBuilder {
	return &QosBuilder{qos: &Qos{}, err: nil}
}

func (builder *QosBuilder) Comment(attr string) *QosBuilder {
	if builder.err != nil {
		return builder
	}

	builder.qos.SetComment(attr)
	return builder
}

func (builder *QosBuilder) CpuLimit(attr int64) *QosBuilder {
	if builder.err != nil {
		return builder
	}

	builder.qos.SetCpuLimit(attr)
	return builder
}

func (builder *QosBuilder) DataCenter(attr *DataCenter) *QosBuilder {
	if builder.err != nil {
		return builder
	}

	builder.qos.SetDataCenter(attr)
	return builder
}

func (builder *QosBuilder) DataCenterBuilder(attrBuilder *DataCenterBuilder) *QosBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.DataCenter(attr)
}

func (builder *QosBuilder) Description(attr string) *QosBuilder {
	if builder.err != nil {
		return builder
	}

	builder.qos.SetDescription(attr)
	return builder
}

func (builder *QosBuilder) Id(attr string) *QosBuilder {
	if builder.err != nil {
		return builder
	}

	builder.qos.SetId(attr)
	return builder
}

func (builder *QosBuilder) InboundAverage(attr int64) *QosBuilder {
	if builder.err != nil {
		return builder
	}

	builder.qos.SetInboundAverage(attr)
	return builder
}

func (builder *QosBuilder) InboundBurst(attr int64) *QosBuilder {
	if builder.err != nil {
		return builder
	}

	builder.qos.SetInboundBurst(attr)
	return builder
}

func (builder *QosBuilder) InboundPeak(attr int64) *QosBuilder {
	if builder.err != nil {
		return builder
	}

	builder.qos.SetInboundPeak(attr)
	return builder
}

func (builder *QosBuilder) MaxIops(attr int64) *QosBuilder {
	if builder.err != nil {
		return builder
	}

	builder.qos.SetMaxIops(attr)
	return builder
}

func (builder *QosBuilder) MaxReadIops(attr int64) *QosBuilder {
	if builder.err != nil {
		return builder
	}

	builder.qos.SetMaxReadIops(attr)
	return builder
}

func (builder *QosBuilder) MaxReadThroughput(attr int64) *QosBuilder {
	if builder.err != nil {
		return builder
	}

	builder.qos.SetMaxReadThroughput(attr)
	return builder
}

func (builder *QosBuilder) MaxThroughput(attr int64) *QosBuilder {
	if builder.err != nil {
		return builder
	}

	builder.qos.SetMaxThroughput(attr)
	return builder
}

func (builder *QosBuilder) MaxWriteIops(attr int64) *QosBuilder {
	if builder.err != nil {
		return builder
	}

	builder.qos.SetMaxWriteIops(attr)
	return builder
}

func (builder *QosBuilder) MaxWriteThroughput(attr int64) *QosBuilder {
	if builder.err != nil {
		return builder
	}

	builder.qos.SetMaxWriteThroughput(attr)
	return builder
}

func (builder *QosBuilder) Name(attr string) *QosBuilder {
	if builder.err != nil {
		return builder
	}

	builder.qos.SetName(attr)
	return builder
}

func (builder *QosBuilder) OutboundAverage(attr int64) *QosBuilder {
	if builder.err != nil {
		return builder
	}

	builder.qos.SetOutboundAverage(attr)
	return builder
}

func (builder *QosBuilder) OutboundAverageLinkshare(attr int64) *QosBuilder {
	if builder.err != nil {
		return builder
	}

	builder.qos.SetOutboundAverageLinkshare(attr)
	return builder
}

func (builder *QosBuilder) OutboundAverageRealtime(attr int64) *QosBuilder {
	if builder.err != nil {
		return builder
	}

	builder.qos.SetOutboundAverageRealtime(attr)
	return builder
}

func (builder *QosBuilder) OutboundAverageUpperlimit(attr int64) *QosBuilder {
	if builder.err != nil {
		return builder
	}

	builder.qos.SetOutboundAverageUpperlimit(attr)
	return builder
}

func (builder *QosBuilder) OutboundBurst(attr int64) *QosBuilder {
	if builder.err != nil {
		return builder
	}

	builder.qos.SetOutboundBurst(attr)
	return builder
}

func (builder *QosBuilder) OutboundPeak(attr int64) *QosBuilder {
	if builder.err != nil {
		return builder
	}

	builder.qos.SetOutboundPeak(attr)
	return builder
}

func (builder *QosBuilder) Type(attr QosType) *QosBuilder {
	if builder.err != nil {
		return builder
	}

	builder.qos.SetType(attr)
	return builder
}

func (builder *QosBuilder) Href(href string) *QosBuilder {
	if builder.err != nil {
		return builder
	}

	builder.qos.SetHref(href)
	return builder
}

func (builder *QosBuilder) Build() (*Qos, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.qos, nil
}

func (builder *QosBuilder) MustBuild() *Qos {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build Qos instance, reason: %v", builder.err))
	}
	return builder.qos
}

type QuotaBuilder struct {
	quota *Quota
	err   error
}

func NewQuotaBuilder() *QuotaBuilder {
	return &QuotaBuilder{quota: &Quota{}, err: nil}
}

func (builder *QuotaBuilder) ClusterHardLimitPct(attr int64) *QuotaBuilder {
	if builder.err != nil {
		return builder
	}

	builder.quota.SetClusterHardLimitPct(attr)
	return builder
}

func (builder *QuotaBuilder) ClusterSoftLimitPct(attr int64) *QuotaBuilder {
	if builder.err != nil {
		return builder
	}

	builder.quota.SetClusterSoftLimitPct(attr)
	return builder
}

func (builder *QuotaBuilder) Comment(attr string) *QuotaBuilder {
	if builder.err != nil {
		return builder
	}

	builder.quota.SetComment(attr)
	return builder
}

func (builder *QuotaBuilder) DataCenter(attr *DataCenter) *QuotaBuilder {
	if builder.err != nil {
		return builder
	}

	builder.quota.SetDataCenter(attr)
	return builder
}

func (builder *QuotaBuilder) DataCenterBuilder(attrBuilder *DataCenterBuilder) *QuotaBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.DataCenter(attr)
}

func (builder *QuotaBuilder) Description(attr string) *QuotaBuilder {
	if builder.err != nil {
		return builder
	}

	builder.quota.SetDescription(attr)
	return builder
}

func (builder *QuotaBuilder) Disks(attr *DiskSlice) *QuotaBuilder {
	if builder.err != nil {
		return builder
	}

	builder.quota.SetDisks(attr)
	return builder
}

func (builder *QuotaBuilder) DisksOfAny(anys ...*Disk) *QuotaBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.quota.disks == nil {
		builder.quota.disks = new(DiskSlice)
	}
	builder.quota.disks.slice = append(builder.quota.disks.slice, anys...)
	return builder
}

func (builder *QuotaBuilder) DisksBuilderOfAny(anyBuilders ...DiskBuilder) *QuotaBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.DisksOfAny(attr)
	}
	return builder
}

func (builder *QuotaBuilder) Id(attr string) *QuotaBuilder {
	if builder.err != nil {
		return builder
	}

	builder.quota.SetId(attr)
	return builder
}

func (builder *QuotaBuilder) Name(attr string) *QuotaBuilder {
	if builder.err != nil {
		return builder
	}

	builder.quota.SetName(attr)
	return builder
}

func (builder *QuotaBuilder) Permissions(attr *PermissionSlice) *QuotaBuilder {
	if builder.err != nil {
		return builder
	}

	builder.quota.SetPermissions(attr)
	return builder
}

func (builder *QuotaBuilder) PermissionsOfAny(anys ...*Permission) *QuotaBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.quota.permissions == nil {
		builder.quota.permissions = new(PermissionSlice)
	}
	builder.quota.permissions.slice = append(builder.quota.permissions.slice, anys...)
	return builder
}

func (builder *QuotaBuilder) PermissionsBuilderOfAny(anyBuilders ...PermissionBuilder) *QuotaBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.PermissionsOfAny(attr)
	}
	return builder
}

func (builder *QuotaBuilder) QuotaClusterLimits(attr *QuotaClusterLimitSlice) *QuotaBuilder {
	if builder.err != nil {
		return builder
	}

	builder.quota.SetQuotaClusterLimits(attr)
	return builder
}

func (builder *QuotaBuilder) QuotaClusterLimitsOfAny(anys ...*QuotaClusterLimit) *QuotaBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.quota.quotaClusterLimits == nil {
		builder.quota.quotaClusterLimits = new(QuotaClusterLimitSlice)
	}
	builder.quota.quotaClusterLimits.slice = append(builder.quota.quotaClusterLimits.slice, anys...)
	return builder
}

func (builder *QuotaBuilder) QuotaClusterLimitsBuilderOfAny(anyBuilders ...QuotaClusterLimitBuilder) *QuotaBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.QuotaClusterLimitsOfAny(attr)
	}
	return builder
}

func (builder *QuotaBuilder) QuotaStorageLimits(attr *QuotaStorageLimitSlice) *QuotaBuilder {
	if builder.err != nil {
		return builder
	}

	builder.quota.SetQuotaStorageLimits(attr)
	return builder
}

func (builder *QuotaBuilder) QuotaStorageLimitsOfAny(anys ...*QuotaStorageLimit) *QuotaBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.quota.quotaStorageLimits == nil {
		builder.quota.quotaStorageLimits = new(QuotaStorageLimitSlice)
	}
	builder.quota.quotaStorageLimits.slice = append(builder.quota.quotaStorageLimits.slice, anys...)
	return builder
}

func (builder *QuotaBuilder) QuotaStorageLimitsBuilderOfAny(anyBuilders ...QuotaStorageLimitBuilder) *QuotaBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.QuotaStorageLimitsOfAny(attr)
	}
	return builder
}

func (builder *QuotaBuilder) StorageHardLimitPct(attr int64) *QuotaBuilder {
	if builder.err != nil {
		return builder
	}

	builder.quota.SetStorageHardLimitPct(attr)
	return builder
}

func (builder *QuotaBuilder) StorageSoftLimitPct(attr int64) *QuotaBuilder {
	if builder.err != nil {
		return builder
	}

	builder.quota.SetStorageSoftLimitPct(attr)
	return builder
}

func (builder *QuotaBuilder) Users(attr *UserSlice) *QuotaBuilder {
	if builder.err != nil {
		return builder
	}

	builder.quota.SetUsers(attr)
	return builder
}

func (builder *QuotaBuilder) UsersOfAny(anys ...*User) *QuotaBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.quota.users == nil {
		builder.quota.users = new(UserSlice)
	}
	builder.quota.users.slice = append(builder.quota.users.slice, anys...)
	return builder
}

func (builder *QuotaBuilder) UsersBuilderOfAny(anyBuilders ...UserBuilder) *QuotaBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.UsersOfAny(attr)
	}
	return builder
}

func (builder *QuotaBuilder) Vms(attr *VmSlice) *QuotaBuilder {
	if builder.err != nil {
		return builder
	}

	builder.quota.SetVms(attr)
	return builder
}

func (builder *QuotaBuilder) VmsOfAny(anys ...*Vm) *QuotaBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.quota.vms == nil {
		builder.quota.vms = new(VmSlice)
	}
	builder.quota.vms.slice = append(builder.quota.vms.slice, anys...)
	return builder
}

func (builder *QuotaBuilder) VmsBuilderOfAny(anyBuilders ...VmBuilder) *QuotaBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.VmsOfAny(attr)
	}
	return builder
}

func (builder *QuotaBuilder) Href(href string) *QuotaBuilder {
	if builder.err != nil {
		return builder
	}

	builder.quota.SetHref(href)
	return builder
}

func (builder *QuotaBuilder) Build() (*Quota, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.quota, nil
}

func (builder *QuotaBuilder) MustBuild() *Quota {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build Quota instance, reason: %v", builder.err))
	}
	return builder.quota
}

type QuotaClusterLimitBuilder struct {
	quotaClusterLimit *QuotaClusterLimit
	err               error
}

func NewQuotaClusterLimitBuilder() *QuotaClusterLimitBuilder {
	return &QuotaClusterLimitBuilder{quotaClusterLimit: &QuotaClusterLimit{}, err: nil}
}

func (builder *QuotaClusterLimitBuilder) Cluster(attr *Cluster) *QuotaClusterLimitBuilder {
	if builder.err != nil {
		return builder
	}

	builder.quotaClusterLimit.SetCluster(attr)
	return builder
}

func (builder *QuotaClusterLimitBuilder) ClusterBuilder(attrBuilder *ClusterBuilder) *QuotaClusterLimitBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Cluster(attr)
}

func (builder *QuotaClusterLimitBuilder) Comment(attr string) *QuotaClusterLimitBuilder {
	if builder.err != nil {
		return builder
	}

	builder.quotaClusterLimit.SetComment(attr)
	return builder
}

func (builder *QuotaClusterLimitBuilder) Description(attr string) *QuotaClusterLimitBuilder {
	if builder.err != nil {
		return builder
	}

	builder.quotaClusterLimit.SetDescription(attr)
	return builder
}

func (builder *QuotaClusterLimitBuilder) Id(attr string) *QuotaClusterLimitBuilder {
	if builder.err != nil {
		return builder
	}

	builder.quotaClusterLimit.SetId(attr)
	return builder
}

func (builder *QuotaClusterLimitBuilder) MemoryLimit(attr float64) *QuotaClusterLimitBuilder {
	if builder.err != nil {
		return builder
	}

	builder.quotaClusterLimit.SetMemoryLimit(attr)
	return builder
}

func (builder *QuotaClusterLimitBuilder) MemoryUsage(attr float64) *QuotaClusterLimitBuilder {
	if builder.err != nil {
		return builder
	}

	builder.quotaClusterLimit.SetMemoryUsage(attr)
	return builder
}

func (builder *QuotaClusterLimitBuilder) Name(attr string) *QuotaClusterLimitBuilder {
	if builder.err != nil {
		return builder
	}

	builder.quotaClusterLimit.SetName(attr)
	return builder
}

func (builder *QuotaClusterLimitBuilder) Quota(attr *Quota) *QuotaClusterLimitBuilder {
	if builder.err != nil {
		return builder
	}

	builder.quotaClusterLimit.SetQuota(attr)
	return builder
}

func (builder *QuotaClusterLimitBuilder) QuotaBuilder(attrBuilder *QuotaBuilder) *QuotaClusterLimitBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Quota(attr)
}

func (builder *QuotaClusterLimitBuilder) VcpuLimit(attr int64) *QuotaClusterLimitBuilder {
	if builder.err != nil {
		return builder
	}

	builder.quotaClusterLimit.SetVcpuLimit(attr)
	return builder
}

func (builder *QuotaClusterLimitBuilder) VcpuUsage(attr int64) *QuotaClusterLimitBuilder {
	if builder.err != nil {
		return builder
	}

	builder.quotaClusterLimit.SetVcpuUsage(attr)
	return builder
}

func (builder *QuotaClusterLimitBuilder) Href(href string) *QuotaClusterLimitBuilder {
	if builder.err != nil {
		return builder
	}

	builder.quotaClusterLimit.SetHref(href)
	return builder
}

func (builder *QuotaClusterLimitBuilder) Build() (*QuotaClusterLimit, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.quotaClusterLimit, nil
}

func (builder *QuotaClusterLimitBuilder) MustBuild() *QuotaClusterLimit {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build QuotaClusterLimit instance, reason: %v", builder.err))
	}
	return builder.quotaClusterLimit
}

type QuotaStorageLimitBuilder struct {
	quotaStorageLimit *QuotaStorageLimit
	err               error
}

func NewQuotaStorageLimitBuilder() *QuotaStorageLimitBuilder {
	return &QuotaStorageLimitBuilder{quotaStorageLimit: &QuotaStorageLimit{}, err: nil}
}

func (builder *QuotaStorageLimitBuilder) Comment(attr string) *QuotaStorageLimitBuilder {
	if builder.err != nil {
		return builder
	}

	builder.quotaStorageLimit.SetComment(attr)
	return builder
}

func (builder *QuotaStorageLimitBuilder) Description(attr string) *QuotaStorageLimitBuilder {
	if builder.err != nil {
		return builder
	}

	builder.quotaStorageLimit.SetDescription(attr)
	return builder
}

func (builder *QuotaStorageLimitBuilder) Id(attr string) *QuotaStorageLimitBuilder {
	if builder.err != nil {
		return builder
	}

	builder.quotaStorageLimit.SetId(attr)
	return builder
}

func (builder *QuotaStorageLimitBuilder) Limit(attr int64) *QuotaStorageLimitBuilder {
	if builder.err != nil {
		return builder
	}

	builder.quotaStorageLimit.SetLimit(attr)
	return builder
}

func (builder *QuotaStorageLimitBuilder) Name(attr string) *QuotaStorageLimitBuilder {
	if builder.err != nil {
		return builder
	}

	builder.quotaStorageLimit.SetName(attr)
	return builder
}

func (builder *QuotaStorageLimitBuilder) Quota(attr *Quota) *QuotaStorageLimitBuilder {
	if builder.err != nil {
		return builder
	}

	builder.quotaStorageLimit.SetQuota(attr)
	return builder
}

func (builder *QuotaStorageLimitBuilder) QuotaBuilder(attrBuilder *QuotaBuilder) *QuotaStorageLimitBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Quota(attr)
}

func (builder *QuotaStorageLimitBuilder) StorageDomain(attr *StorageDomain) *QuotaStorageLimitBuilder {
	if builder.err != nil {
		return builder
	}

	builder.quotaStorageLimit.SetStorageDomain(attr)
	return builder
}

func (builder *QuotaStorageLimitBuilder) StorageDomainBuilder(attrBuilder *StorageDomainBuilder) *QuotaStorageLimitBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.StorageDomain(attr)
}

func (builder *QuotaStorageLimitBuilder) Usage(attr float64) *QuotaStorageLimitBuilder {
	if builder.err != nil {
		return builder
	}

	builder.quotaStorageLimit.SetUsage(attr)
	return builder
}

func (builder *QuotaStorageLimitBuilder) Href(href string) *QuotaStorageLimitBuilder {
	if builder.err != nil {
		return builder
	}

	builder.quotaStorageLimit.SetHref(href)
	return builder
}

func (builder *QuotaStorageLimitBuilder) Build() (*QuotaStorageLimit, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.quotaStorageLimit, nil
}

func (builder *QuotaStorageLimitBuilder) MustBuild() *QuotaStorageLimit {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build QuotaStorageLimit instance, reason: %v", builder.err))
	}
	return builder.quotaStorageLimit
}

type RangeBuilder struct {
	range_ *Range
	err    error
}

func NewRangeBuilder() *RangeBuilder {
	return &RangeBuilder{range_: &Range{}, err: nil}
}

func (builder *RangeBuilder) From(attr string) *RangeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.range_.SetFrom(attr)
	return builder
}

func (builder *RangeBuilder) To(attr string) *RangeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.range_.SetTo(attr)
	return builder
}

func (builder *RangeBuilder) Href(href string) *RangeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.range_.SetHref(href)
	return builder
}

func (builder *RangeBuilder) Build() (*Range, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.range_, nil
}

func (builder *RangeBuilder) MustBuild() *Range {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build Range instance, reason: %v", builder.err))
	}
	return builder.range_
}

type RateBuilder struct {
	rate *Rate
	err  error
}

func NewRateBuilder() *RateBuilder {
	return &RateBuilder{rate: &Rate{}, err: nil}
}

func (builder *RateBuilder) Bytes(attr int64) *RateBuilder {
	if builder.err != nil {
		return builder
	}

	builder.rate.SetBytes(attr)
	return builder
}

func (builder *RateBuilder) Period(attr int64) *RateBuilder {
	if builder.err != nil {
		return builder
	}

	builder.rate.SetPeriod(attr)
	return builder
}

func (builder *RateBuilder) Href(href string) *RateBuilder {
	if builder.err != nil {
		return builder
	}

	builder.rate.SetHref(href)
	return builder
}

func (builder *RateBuilder) Build() (*Rate, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.rate, nil
}

func (builder *RateBuilder) MustBuild() *Rate {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build Rate instance, reason: %v", builder.err))
	}
	return builder.rate
}

type RegistrationAffinityGroupMappingBuilder struct {
	registrationAffinityGroupMapping *RegistrationAffinityGroupMapping
	err                              error
}

func NewRegistrationAffinityGroupMappingBuilder() *RegistrationAffinityGroupMappingBuilder {
	return &RegistrationAffinityGroupMappingBuilder{registrationAffinityGroupMapping: &RegistrationAffinityGroupMapping{}, err: nil}
}

func (builder *RegistrationAffinityGroupMappingBuilder) From(attr *AffinityGroup) *RegistrationAffinityGroupMappingBuilder {
	if builder.err != nil {
		return builder
	}

	builder.registrationAffinityGroupMapping.SetFrom(attr)
	return builder
}

func (builder *RegistrationAffinityGroupMappingBuilder) FromBuilder(attrBuilder *AffinityGroupBuilder) *RegistrationAffinityGroupMappingBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.From(attr)
}

func (builder *RegistrationAffinityGroupMappingBuilder) To(attr *AffinityGroup) *RegistrationAffinityGroupMappingBuilder {
	if builder.err != nil {
		return builder
	}

	builder.registrationAffinityGroupMapping.SetTo(attr)
	return builder
}

func (builder *RegistrationAffinityGroupMappingBuilder) ToBuilder(attrBuilder *AffinityGroupBuilder) *RegistrationAffinityGroupMappingBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.To(attr)
}

func (builder *RegistrationAffinityGroupMappingBuilder) Href(href string) *RegistrationAffinityGroupMappingBuilder {
	if builder.err != nil {
		return builder
	}

	builder.registrationAffinityGroupMapping.SetHref(href)
	return builder
}

func (builder *RegistrationAffinityGroupMappingBuilder) Build() (*RegistrationAffinityGroupMapping, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.registrationAffinityGroupMapping, nil
}

func (builder *RegistrationAffinityGroupMappingBuilder) MustBuild() *RegistrationAffinityGroupMapping {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build RegistrationAffinityGroupMapping instance, reason: %v", builder.err))
	}
	return builder.registrationAffinityGroupMapping
}

type RegistrationAffinityLabelMappingBuilder struct {
	registrationAffinityLabelMapping *RegistrationAffinityLabelMapping
	err                              error
}

func NewRegistrationAffinityLabelMappingBuilder() *RegistrationAffinityLabelMappingBuilder {
	return &RegistrationAffinityLabelMappingBuilder{registrationAffinityLabelMapping: &RegistrationAffinityLabelMapping{}, err: nil}
}

func (builder *RegistrationAffinityLabelMappingBuilder) From(attr *AffinityLabel) *RegistrationAffinityLabelMappingBuilder {
	if builder.err != nil {
		return builder
	}

	builder.registrationAffinityLabelMapping.SetFrom(attr)
	return builder
}

func (builder *RegistrationAffinityLabelMappingBuilder) FromBuilder(attrBuilder *AffinityLabelBuilder) *RegistrationAffinityLabelMappingBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.From(attr)
}

func (builder *RegistrationAffinityLabelMappingBuilder) To(attr *AffinityLabel) *RegistrationAffinityLabelMappingBuilder {
	if builder.err != nil {
		return builder
	}

	builder.registrationAffinityLabelMapping.SetTo(attr)
	return builder
}

func (builder *RegistrationAffinityLabelMappingBuilder) ToBuilder(attrBuilder *AffinityLabelBuilder) *RegistrationAffinityLabelMappingBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.To(attr)
}

func (builder *RegistrationAffinityLabelMappingBuilder) Href(href string) *RegistrationAffinityLabelMappingBuilder {
	if builder.err != nil {
		return builder
	}

	builder.registrationAffinityLabelMapping.SetHref(href)
	return builder
}

func (builder *RegistrationAffinityLabelMappingBuilder) Build() (*RegistrationAffinityLabelMapping, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.registrationAffinityLabelMapping, nil
}

func (builder *RegistrationAffinityLabelMappingBuilder) MustBuild() *RegistrationAffinityLabelMapping {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build RegistrationAffinityLabelMapping instance, reason: %v", builder.err))
	}
	return builder.registrationAffinityLabelMapping
}

type RegistrationClusterMappingBuilder struct {
	registrationClusterMapping *RegistrationClusterMapping
	err                        error
}

func NewRegistrationClusterMappingBuilder() *RegistrationClusterMappingBuilder {
	return &RegistrationClusterMappingBuilder{registrationClusterMapping: &RegistrationClusterMapping{}, err: nil}
}

func (builder *RegistrationClusterMappingBuilder) From(attr *Cluster) *RegistrationClusterMappingBuilder {
	if builder.err != nil {
		return builder
	}

	builder.registrationClusterMapping.SetFrom(attr)
	return builder
}

func (builder *RegistrationClusterMappingBuilder) FromBuilder(attrBuilder *ClusterBuilder) *RegistrationClusterMappingBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.From(attr)
}

func (builder *RegistrationClusterMappingBuilder) To(attr *Cluster) *RegistrationClusterMappingBuilder {
	if builder.err != nil {
		return builder
	}

	builder.registrationClusterMapping.SetTo(attr)
	return builder
}

func (builder *RegistrationClusterMappingBuilder) ToBuilder(attrBuilder *ClusterBuilder) *RegistrationClusterMappingBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.To(attr)
}

func (builder *RegistrationClusterMappingBuilder) Href(href string) *RegistrationClusterMappingBuilder {
	if builder.err != nil {
		return builder
	}

	builder.registrationClusterMapping.SetHref(href)
	return builder
}

func (builder *RegistrationClusterMappingBuilder) Build() (*RegistrationClusterMapping, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.registrationClusterMapping, nil
}

func (builder *RegistrationClusterMappingBuilder) MustBuild() *RegistrationClusterMapping {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build RegistrationClusterMapping instance, reason: %v", builder.err))
	}
	return builder.registrationClusterMapping
}

type RegistrationConfigurationBuilder struct {
	registrationConfiguration *RegistrationConfiguration
	err                       error
}

func NewRegistrationConfigurationBuilder() *RegistrationConfigurationBuilder {
	return &RegistrationConfigurationBuilder{registrationConfiguration: &RegistrationConfiguration{}, err: nil}
}

func (builder *RegistrationConfigurationBuilder) AffinityGroupMappings(attr *RegistrationAffinityGroupMappingSlice) *RegistrationConfigurationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.registrationConfiguration.SetAffinityGroupMappings(attr)
	return builder
}

func (builder *RegistrationConfigurationBuilder) AffinityGroupMappingsOfAny(anys ...*RegistrationAffinityGroupMapping) *RegistrationConfigurationBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.registrationConfiguration.affinityGroupMappings == nil {
		builder.registrationConfiguration.affinityGroupMappings = new(RegistrationAffinityGroupMappingSlice)
	}
	builder.registrationConfiguration.affinityGroupMappings.slice = append(builder.registrationConfiguration.affinityGroupMappings.slice, anys...)
	return builder
}

func (builder *RegistrationConfigurationBuilder) AffinityGroupMappingsBuilderOfAny(anyBuilders ...RegistrationAffinityGroupMappingBuilder) *RegistrationConfigurationBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.AffinityGroupMappingsOfAny(attr)
	}
	return builder
}

func (builder *RegistrationConfigurationBuilder) AffinityLabelMappings(attr *RegistrationAffinityLabelMappingSlice) *RegistrationConfigurationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.registrationConfiguration.SetAffinityLabelMappings(attr)
	return builder
}

func (builder *RegistrationConfigurationBuilder) AffinityLabelMappingsOfAny(anys ...*RegistrationAffinityLabelMapping) *RegistrationConfigurationBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.registrationConfiguration.affinityLabelMappings == nil {
		builder.registrationConfiguration.affinityLabelMappings = new(RegistrationAffinityLabelMappingSlice)
	}
	builder.registrationConfiguration.affinityLabelMappings.slice = append(builder.registrationConfiguration.affinityLabelMappings.slice, anys...)
	return builder
}

func (builder *RegistrationConfigurationBuilder) AffinityLabelMappingsBuilderOfAny(anyBuilders ...RegistrationAffinityLabelMappingBuilder) *RegistrationConfigurationBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.AffinityLabelMappingsOfAny(attr)
	}
	return builder
}

func (builder *RegistrationConfigurationBuilder) ClusterMappings(attr *RegistrationClusterMappingSlice) *RegistrationConfigurationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.registrationConfiguration.SetClusterMappings(attr)
	return builder
}

func (builder *RegistrationConfigurationBuilder) ClusterMappingsOfAny(anys ...*RegistrationClusterMapping) *RegistrationConfigurationBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.registrationConfiguration.clusterMappings == nil {
		builder.registrationConfiguration.clusterMappings = new(RegistrationClusterMappingSlice)
	}
	builder.registrationConfiguration.clusterMappings.slice = append(builder.registrationConfiguration.clusterMappings.slice, anys...)
	return builder
}

func (builder *RegistrationConfigurationBuilder) ClusterMappingsBuilderOfAny(anyBuilders ...RegistrationClusterMappingBuilder) *RegistrationConfigurationBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.ClusterMappingsOfAny(attr)
	}
	return builder
}

func (builder *RegistrationConfigurationBuilder) DomainMappings(attr *RegistrationDomainMappingSlice) *RegistrationConfigurationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.registrationConfiguration.SetDomainMappings(attr)
	return builder
}

func (builder *RegistrationConfigurationBuilder) DomainMappingsOfAny(anys ...*RegistrationDomainMapping) *RegistrationConfigurationBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.registrationConfiguration.domainMappings == nil {
		builder.registrationConfiguration.domainMappings = new(RegistrationDomainMappingSlice)
	}
	builder.registrationConfiguration.domainMappings.slice = append(builder.registrationConfiguration.domainMappings.slice, anys...)
	return builder
}

func (builder *RegistrationConfigurationBuilder) DomainMappingsBuilderOfAny(anyBuilders ...RegistrationDomainMappingBuilder) *RegistrationConfigurationBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.DomainMappingsOfAny(attr)
	}
	return builder
}

func (builder *RegistrationConfigurationBuilder) LunMappings(attr *RegistrationLunMappingSlice) *RegistrationConfigurationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.registrationConfiguration.SetLunMappings(attr)
	return builder
}

func (builder *RegistrationConfigurationBuilder) LunMappingsOfAny(anys ...*RegistrationLunMapping) *RegistrationConfigurationBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.registrationConfiguration.lunMappings == nil {
		builder.registrationConfiguration.lunMappings = new(RegistrationLunMappingSlice)
	}
	builder.registrationConfiguration.lunMappings.slice = append(builder.registrationConfiguration.lunMappings.slice, anys...)
	return builder
}

func (builder *RegistrationConfigurationBuilder) LunMappingsBuilderOfAny(anyBuilders ...RegistrationLunMappingBuilder) *RegistrationConfigurationBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.LunMappingsOfAny(attr)
	}
	return builder
}

func (builder *RegistrationConfigurationBuilder) RoleMappings(attr *RegistrationRoleMappingSlice) *RegistrationConfigurationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.registrationConfiguration.SetRoleMappings(attr)
	return builder
}

func (builder *RegistrationConfigurationBuilder) RoleMappingsOfAny(anys ...*RegistrationRoleMapping) *RegistrationConfigurationBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.registrationConfiguration.roleMappings == nil {
		builder.registrationConfiguration.roleMappings = new(RegistrationRoleMappingSlice)
	}
	builder.registrationConfiguration.roleMappings.slice = append(builder.registrationConfiguration.roleMappings.slice, anys...)
	return builder
}

func (builder *RegistrationConfigurationBuilder) RoleMappingsBuilderOfAny(anyBuilders ...RegistrationRoleMappingBuilder) *RegistrationConfigurationBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.RoleMappingsOfAny(attr)
	}
	return builder
}

func (builder *RegistrationConfigurationBuilder) VnicProfileMappings(attr *RegistrationVnicProfileMappingSlice) *RegistrationConfigurationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.registrationConfiguration.SetVnicProfileMappings(attr)
	return builder
}

func (builder *RegistrationConfigurationBuilder) VnicProfileMappingsOfAny(anys ...*RegistrationVnicProfileMapping) *RegistrationConfigurationBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.registrationConfiguration.vnicProfileMappings == nil {
		builder.registrationConfiguration.vnicProfileMappings = new(RegistrationVnicProfileMappingSlice)
	}
	builder.registrationConfiguration.vnicProfileMappings.slice = append(builder.registrationConfiguration.vnicProfileMappings.slice, anys...)
	return builder
}

func (builder *RegistrationConfigurationBuilder) VnicProfileMappingsBuilderOfAny(anyBuilders ...RegistrationVnicProfileMappingBuilder) *RegistrationConfigurationBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.VnicProfileMappingsOfAny(attr)
	}
	return builder
}

func (builder *RegistrationConfigurationBuilder) Href(href string) *RegistrationConfigurationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.registrationConfiguration.SetHref(href)
	return builder
}

func (builder *RegistrationConfigurationBuilder) Build() (*RegistrationConfiguration, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.registrationConfiguration, nil
}

func (builder *RegistrationConfigurationBuilder) MustBuild() *RegistrationConfiguration {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build RegistrationConfiguration instance, reason: %v", builder.err))
	}
	return builder.registrationConfiguration
}

type RegistrationDomainMappingBuilder struct {
	registrationDomainMapping *RegistrationDomainMapping
	err                       error
}

func NewRegistrationDomainMappingBuilder() *RegistrationDomainMappingBuilder {
	return &RegistrationDomainMappingBuilder{registrationDomainMapping: &RegistrationDomainMapping{}, err: nil}
}

func (builder *RegistrationDomainMappingBuilder) From(attr *Domain) *RegistrationDomainMappingBuilder {
	if builder.err != nil {
		return builder
	}

	builder.registrationDomainMapping.SetFrom(attr)
	return builder
}

func (builder *RegistrationDomainMappingBuilder) FromBuilder(attrBuilder *DomainBuilder) *RegistrationDomainMappingBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.From(attr)
}

func (builder *RegistrationDomainMappingBuilder) To(attr *Domain) *RegistrationDomainMappingBuilder {
	if builder.err != nil {
		return builder
	}

	builder.registrationDomainMapping.SetTo(attr)
	return builder
}

func (builder *RegistrationDomainMappingBuilder) ToBuilder(attrBuilder *DomainBuilder) *RegistrationDomainMappingBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.To(attr)
}

func (builder *RegistrationDomainMappingBuilder) Href(href string) *RegistrationDomainMappingBuilder {
	if builder.err != nil {
		return builder
	}

	builder.registrationDomainMapping.SetHref(href)
	return builder
}

func (builder *RegistrationDomainMappingBuilder) Build() (*RegistrationDomainMapping, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.registrationDomainMapping, nil
}

func (builder *RegistrationDomainMappingBuilder) MustBuild() *RegistrationDomainMapping {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build RegistrationDomainMapping instance, reason: %v", builder.err))
	}
	return builder.registrationDomainMapping
}

type RegistrationLunMappingBuilder struct {
	registrationLunMapping *RegistrationLunMapping
	err                    error
}

func NewRegistrationLunMappingBuilder() *RegistrationLunMappingBuilder {
	return &RegistrationLunMappingBuilder{registrationLunMapping: &RegistrationLunMapping{}, err: nil}
}

func (builder *RegistrationLunMappingBuilder) From(attr *Disk) *RegistrationLunMappingBuilder {
	if builder.err != nil {
		return builder
	}

	builder.registrationLunMapping.SetFrom(attr)
	return builder
}

func (builder *RegistrationLunMappingBuilder) FromBuilder(attrBuilder *DiskBuilder) *RegistrationLunMappingBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.From(attr)
}

func (builder *RegistrationLunMappingBuilder) To(attr *Disk) *RegistrationLunMappingBuilder {
	if builder.err != nil {
		return builder
	}

	builder.registrationLunMapping.SetTo(attr)
	return builder
}

func (builder *RegistrationLunMappingBuilder) ToBuilder(attrBuilder *DiskBuilder) *RegistrationLunMappingBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.To(attr)
}

func (builder *RegistrationLunMappingBuilder) Href(href string) *RegistrationLunMappingBuilder {
	if builder.err != nil {
		return builder
	}

	builder.registrationLunMapping.SetHref(href)
	return builder
}

func (builder *RegistrationLunMappingBuilder) Build() (*RegistrationLunMapping, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.registrationLunMapping, nil
}

func (builder *RegistrationLunMappingBuilder) MustBuild() *RegistrationLunMapping {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build RegistrationLunMapping instance, reason: %v", builder.err))
	}
	return builder.registrationLunMapping
}

type RegistrationRoleMappingBuilder struct {
	registrationRoleMapping *RegistrationRoleMapping
	err                     error
}

func NewRegistrationRoleMappingBuilder() *RegistrationRoleMappingBuilder {
	return &RegistrationRoleMappingBuilder{registrationRoleMapping: &RegistrationRoleMapping{}, err: nil}
}

func (builder *RegistrationRoleMappingBuilder) From(attr *Role) *RegistrationRoleMappingBuilder {
	if builder.err != nil {
		return builder
	}

	builder.registrationRoleMapping.SetFrom(attr)
	return builder
}

func (builder *RegistrationRoleMappingBuilder) FromBuilder(attrBuilder *RoleBuilder) *RegistrationRoleMappingBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.From(attr)
}

func (builder *RegistrationRoleMappingBuilder) To(attr *Role) *RegistrationRoleMappingBuilder {
	if builder.err != nil {
		return builder
	}

	builder.registrationRoleMapping.SetTo(attr)
	return builder
}

func (builder *RegistrationRoleMappingBuilder) ToBuilder(attrBuilder *RoleBuilder) *RegistrationRoleMappingBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.To(attr)
}

func (builder *RegistrationRoleMappingBuilder) Href(href string) *RegistrationRoleMappingBuilder {
	if builder.err != nil {
		return builder
	}

	builder.registrationRoleMapping.SetHref(href)
	return builder
}

func (builder *RegistrationRoleMappingBuilder) Build() (*RegistrationRoleMapping, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.registrationRoleMapping, nil
}

func (builder *RegistrationRoleMappingBuilder) MustBuild() *RegistrationRoleMapping {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build RegistrationRoleMapping instance, reason: %v", builder.err))
	}
	return builder.registrationRoleMapping
}

type RegistrationVnicProfileMappingBuilder struct {
	registrationVnicProfileMapping *RegistrationVnicProfileMapping
	err                            error
}

func NewRegistrationVnicProfileMappingBuilder() *RegistrationVnicProfileMappingBuilder {
	return &RegistrationVnicProfileMappingBuilder{registrationVnicProfileMapping: &RegistrationVnicProfileMapping{}, err: nil}
}

func (builder *RegistrationVnicProfileMappingBuilder) From(attr *VnicProfile) *RegistrationVnicProfileMappingBuilder {
	if builder.err != nil {
		return builder
	}

	builder.registrationVnicProfileMapping.SetFrom(attr)
	return builder
}

func (builder *RegistrationVnicProfileMappingBuilder) FromBuilder(attrBuilder *VnicProfileBuilder) *RegistrationVnicProfileMappingBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.From(attr)
}

func (builder *RegistrationVnicProfileMappingBuilder) To(attr *VnicProfile) *RegistrationVnicProfileMappingBuilder {
	if builder.err != nil {
		return builder
	}

	builder.registrationVnicProfileMapping.SetTo(attr)
	return builder
}

func (builder *RegistrationVnicProfileMappingBuilder) ToBuilder(attrBuilder *VnicProfileBuilder) *RegistrationVnicProfileMappingBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.To(attr)
}

func (builder *RegistrationVnicProfileMappingBuilder) Href(href string) *RegistrationVnicProfileMappingBuilder {
	if builder.err != nil {
		return builder
	}

	builder.registrationVnicProfileMapping.SetHref(href)
	return builder
}

func (builder *RegistrationVnicProfileMappingBuilder) Build() (*RegistrationVnicProfileMapping, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.registrationVnicProfileMapping, nil
}

func (builder *RegistrationVnicProfileMappingBuilder) MustBuild() *RegistrationVnicProfileMapping {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build RegistrationVnicProfileMapping instance, reason: %v", builder.err))
	}
	return builder.registrationVnicProfileMapping
}

type ReportedConfigurationBuilder struct {
	reportedConfiguration *ReportedConfiguration
	err                   error
}

func NewReportedConfigurationBuilder() *ReportedConfigurationBuilder {
	return &ReportedConfigurationBuilder{reportedConfiguration: &ReportedConfiguration{}, err: nil}
}

func (builder *ReportedConfigurationBuilder) ActualValue(attr string) *ReportedConfigurationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.reportedConfiguration.SetActualValue(attr)
	return builder
}

func (builder *ReportedConfigurationBuilder) ExpectedValue(attr string) *ReportedConfigurationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.reportedConfiguration.SetExpectedValue(attr)
	return builder
}

func (builder *ReportedConfigurationBuilder) InSync(attr bool) *ReportedConfigurationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.reportedConfiguration.SetInSync(attr)
	return builder
}

func (builder *ReportedConfigurationBuilder) Name(attr string) *ReportedConfigurationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.reportedConfiguration.SetName(attr)
	return builder
}

func (builder *ReportedConfigurationBuilder) Href(href string) *ReportedConfigurationBuilder {
	if builder.err != nil {
		return builder
	}

	builder.reportedConfiguration.SetHref(href)
	return builder
}

func (builder *ReportedConfigurationBuilder) Build() (*ReportedConfiguration, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.reportedConfiguration, nil
}

func (builder *ReportedConfigurationBuilder) MustBuild() *ReportedConfiguration {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build ReportedConfiguration instance, reason: %v", builder.err))
	}
	return builder.reportedConfiguration
}

type ReportedDeviceBuilder struct {
	reportedDevice *ReportedDevice
	err            error
}

func NewReportedDeviceBuilder() *ReportedDeviceBuilder {
	return &ReportedDeviceBuilder{reportedDevice: &ReportedDevice{}, err: nil}
}

func (builder *ReportedDeviceBuilder) Comment(attr string) *ReportedDeviceBuilder {
	if builder.err != nil {
		return builder
	}

	builder.reportedDevice.SetComment(attr)
	return builder
}

func (builder *ReportedDeviceBuilder) Description(attr string) *ReportedDeviceBuilder {
	if builder.err != nil {
		return builder
	}

	builder.reportedDevice.SetDescription(attr)
	return builder
}

func (builder *ReportedDeviceBuilder) Id(attr string) *ReportedDeviceBuilder {
	if builder.err != nil {
		return builder
	}

	builder.reportedDevice.SetId(attr)
	return builder
}

func (builder *ReportedDeviceBuilder) Ips(attr *IpSlice) *ReportedDeviceBuilder {
	if builder.err != nil {
		return builder
	}

	builder.reportedDevice.SetIps(attr)
	return builder
}

func (builder *ReportedDeviceBuilder) IpsOfAny(anys ...*Ip) *ReportedDeviceBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.reportedDevice.ips == nil {
		builder.reportedDevice.ips = new(IpSlice)
	}
	builder.reportedDevice.ips.slice = append(builder.reportedDevice.ips.slice, anys...)
	return builder
}

func (builder *ReportedDeviceBuilder) IpsBuilderOfAny(anyBuilders ...IpBuilder) *ReportedDeviceBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.IpsOfAny(attr)
	}
	return builder
}

func (builder *ReportedDeviceBuilder) Mac(attr *Mac) *ReportedDeviceBuilder {
	if builder.err != nil {
		return builder
	}

	builder.reportedDevice.SetMac(attr)
	return builder
}

func (builder *ReportedDeviceBuilder) MacBuilder(attrBuilder *MacBuilder) *ReportedDeviceBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Mac(attr)
}

func (builder *ReportedDeviceBuilder) Name(attr string) *ReportedDeviceBuilder {
	if builder.err != nil {
		return builder
	}

	builder.reportedDevice.SetName(attr)
	return builder
}

func (builder *ReportedDeviceBuilder) Type(attr ReportedDeviceType) *ReportedDeviceBuilder {
	if builder.err != nil {
		return builder
	}

	builder.reportedDevice.SetType(attr)
	return builder
}

func (builder *ReportedDeviceBuilder) Vm(attr *Vm) *ReportedDeviceBuilder {
	if builder.err != nil {
		return builder
	}

	builder.reportedDevice.SetVm(attr)
	return builder
}

func (builder *ReportedDeviceBuilder) VmBuilder(attrBuilder *VmBuilder) *ReportedDeviceBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Vm(attr)
}

func (builder *ReportedDeviceBuilder) Href(href string) *ReportedDeviceBuilder {
	if builder.err != nil {
		return builder
	}

	builder.reportedDevice.SetHref(href)
	return builder
}

func (builder *ReportedDeviceBuilder) Build() (*ReportedDevice, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.reportedDevice, nil
}

func (builder *ReportedDeviceBuilder) MustBuild() *ReportedDevice {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build ReportedDevice instance, reason: %v", builder.err))
	}
	return builder.reportedDevice
}

type RngDeviceBuilder struct {
	rngDevice *RngDevice
	err       error
}

func NewRngDeviceBuilder() *RngDeviceBuilder {
	return &RngDeviceBuilder{rngDevice: &RngDevice{}, err: nil}
}

func (builder *RngDeviceBuilder) Rate(attr *Rate) *RngDeviceBuilder {
	if builder.err != nil {
		return builder
	}

	builder.rngDevice.SetRate(attr)
	return builder
}

func (builder *RngDeviceBuilder) RateBuilder(attrBuilder *RateBuilder) *RngDeviceBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Rate(attr)
}

func (builder *RngDeviceBuilder) Source(attr RngSource) *RngDeviceBuilder {
	if builder.err != nil {
		return builder
	}

	builder.rngDevice.SetSource(attr)
	return builder
}

func (builder *RngDeviceBuilder) Href(href string) *RngDeviceBuilder {
	if builder.err != nil {
		return builder
	}

	builder.rngDevice.SetHref(href)
	return builder
}

func (builder *RngDeviceBuilder) Build() (*RngDevice, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.rngDevice, nil
}

func (builder *RngDeviceBuilder) MustBuild() *RngDevice {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build RngDevice instance, reason: %v", builder.err))
	}
	return builder.rngDevice
}

type RoleBuilder struct {
	role *Role
	err  error
}

func NewRoleBuilder() *RoleBuilder {
	return &RoleBuilder{role: &Role{}, err: nil}
}

func (builder *RoleBuilder) Administrative(attr bool) *RoleBuilder {
	if builder.err != nil {
		return builder
	}

	builder.role.SetAdministrative(attr)
	return builder
}

func (builder *RoleBuilder) Comment(attr string) *RoleBuilder {
	if builder.err != nil {
		return builder
	}

	builder.role.SetComment(attr)
	return builder
}

func (builder *RoleBuilder) Description(attr string) *RoleBuilder {
	if builder.err != nil {
		return builder
	}

	builder.role.SetDescription(attr)
	return builder
}

func (builder *RoleBuilder) Id(attr string) *RoleBuilder {
	if builder.err != nil {
		return builder
	}

	builder.role.SetId(attr)
	return builder
}

func (builder *RoleBuilder) Mutable(attr bool) *RoleBuilder {
	if builder.err != nil {
		return builder
	}

	builder.role.SetMutable(attr)
	return builder
}

func (builder *RoleBuilder) Name(attr string) *RoleBuilder {
	if builder.err != nil {
		return builder
	}

	builder.role.SetName(attr)
	return builder
}

func (builder *RoleBuilder) Permits(attr *PermitSlice) *RoleBuilder {
	if builder.err != nil {
		return builder
	}

	builder.role.SetPermits(attr)
	return builder
}

func (builder *RoleBuilder) PermitsOfAny(anys ...*Permit) *RoleBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.role.permits == nil {
		builder.role.permits = new(PermitSlice)
	}
	builder.role.permits.slice = append(builder.role.permits.slice, anys...)
	return builder
}

func (builder *RoleBuilder) PermitsBuilderOfAny(anyBuilders ...PermitBuilder) *RoleBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.PermitsOfAny(attr)
	}
	return builder
}

func (builder *RoleBuilder) User(attr *User) *RoleBuilder {
	if builder.err != nil {
		return builder
	}

	builder.role.SetUser(attr)
	return builder
}

func (builder *RoleBuilder) UserBuilder(attrBuilder *UserBuilder) *RoleBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.User(attr)
}

func (builder *RoleBuilder) Href(href string) *RoleBuilder {
	if builder.err != nil {
		return builder
	}

	builder.role.SetHref(href)
	return builder
}

func (builder *RoleBuilder) Build() (*Role, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.role, nil
}

func (builder *RoleBuilder) MustBuild() *Role {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build Role instance, reason: %v", builder.err))
	}
	return builder.role
}

type SchedulingPolicyBuilder struct {
	schedulingPolicy *SchedulingPolicy
	err              error
}

func NewSchedulingPolicyBuilder() *SchedulingPolicyBuilder {
	return &SchedulingPolicyBuilder{schedulingPolicy: &SchedulingPolicy{}, err: nil}
}

func (builder *SchedulingPolicyBuilder) Balances(attr *BalanceSlice) *SchedulingPolicyBuilder {
	if builder.err != nil {
		return builder
	}

	builder.schedulingPolicy.SetBalances(attr)
	return builder
}

func (builder *SchedulingPolicyBuilder) BalancesOfAny(anys ...*Balance) *SchedulingPolicyBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.schedulingPolicy.balances == nil {
		builder.schedulingPolicy.balances = new(BalanceSlice)
	}
	builder.schedulingPolicy.balances.slice = append(builder.schedulingPolicy.balances.slice, anys...)
	return builder
}

func (builder *SchedulingPolicyBuilder) BalancesBuilderOfAny(anyBuilders ...BalanceBuilder) *SchedulingPolicyBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.BalancesOfAny(attr)
	}
	return builder
}

func (builder *SchedulingPolicyBuilder) Comment(attr string) *SchedulingPolicyBuilder {
	if builder.err != nil {
		return builder
	}

	builder.schedulingPolicy.SetComment(attr)
	return builder
}

func (builder *SchedulingPolicyBuilder) DefaultPolicy(attr bool) *SchedulingPolicyBuilder {
	if builder.err != nil {
		return builder
	}

	builder.schedulingPolicy.SetDefaultPolicy(attr)
	return builder
}

func (builder *SchedulingPolicyBuilder) Description(attr string) *SchedulingPolicyBuilder {
	if builder.err != nil {
		return builder
	}

	builder.schedulingPolicy.SetDescription(attr)
	return builder
}

func (builder *SchedulingPolicyBuilder) Filters(attr *FilterSlice) *SchedulingPolicyBuilder {
	if builder.err != nil {
		return builder
	}

	builder.schedulingPolicy.SetFilters(attr)
	return builder
}

func (builder *SchedulingPolicyBuilder) FiltersOfAny(anys ...*Filter) *SchedulingPolicyBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.schedulingPolicy.filters == nil {
		builder.schedulingPolicy.filters = new(FilterSlice)
	}
	builder.schedulingPolicy.filters.slice = append(builder.schedulingPolicy.filters.slice, anys...)
	return builder
}

func (builder *SchedulingPolicyBuilder) FiltersBuilderOfAny(anyBuilders ...FilterBuilder) *SchedulingPolicyBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.FiltersOfAny(attr)
	}
	return builder
}

func (builder *SchedulingPolicyBuilder) Id(attr string) *SchedulingPolicyBuilder {
	if builder.err != nil {
		return builder
	}

	builder.schedulingPolicy.SetId(attr)
	return builder
}

func (builder *SchedulingPolicyBuilder) Locked(attr bool) *SchedulingPolicyBuilder {
	if builder.err != nil {
		return builder
	}

	builder.schedulingPolicy.SetLocked(attr)
	return builder
}

func (builder *SchedulingPolicyBuilder) Name(attr string) *SchedulingPolicyBuilder {
	if builder.err != nil {
		return builder
	}

	builder.schedulingPolicy.SetName(attr)
	return builder
}

func (builder *SchedulingPolicyBuilder) Properties(attr *PropertySlice) *SchedulingPolicyBuilder {
	if builder.err != nil {
		return builder
	}

	builder.schedulingPolicy.SetProperties(attr)
	return builder
}

func (builder *SchedulingPolicyBuilder) PropertiesOfAny(anys ...*Property) *SchedulingPolicyBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.schedulingPolicy.properties == nil {
		builder.schedulingPolicy.properties = new(PropertySlice)
	}
	builder.schedulingPolicy.properties.slice = append(builder.schedulingPolicy.properties.slice, anys...)
	return builder
}

func (builder *SchedulingPolicyBuilder) PropertiesBuilderOfAny(anyBuilders ...PropertyBuilder) *SchedulingPolicyBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.PropertiesOfAny(attr)
	}
	return builder
}

func (builder *SchedulingPolicyBuilder) Weight(attr *WeightSlice) *SchedulingPolicyBuilder {
	if builder.err != nil {
		return builder
	}

	builder.schedulingPolicy.SetWeight(attr)
	return builder
}

func (builder *SchedulingPolicyBuilder) WeightOfAny(anys ...*Weight) *SchedulingPolicyBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.schedulingPolicy.weight == nil {
		builder.schedulingPolicy.weight = new(WeightSlice)
	}
	builder.schedulingPolicy.weight.slice = append(builder.schedulingPolicy.weight.slice, anys...)
	return builder
}

func (builder *SchedulingPolicyBuilder) WeightBuilderOfAny(anyBuilders ...WeightBuilder) *SchedulingPolicyBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.WeightOfAny(attr)
	}
	return builder
}

func (builder *SchedulingPolicyBuilder) Href(href string) *SchedulingPolicyBuilder {
	if builder.err != nil {
		return builder
	}

	builder.schedulingPolicy.SetHref(href)
	return builder
}

func (builder *SchedulingPolicyBuilder) Build() (*SchedulingPolicy, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.schedulingPolicy, nil
}

func (builder *SchedulingPolicyBuilder) MustBuild() *SchedulingPolicy {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build SchedulingPolicy instance, reason: %v", builder.err))
	}
	return builder.schedulingPolicy
}

type SchedulingPolicyUnitBuilder struct {
	schedulingPolicyUnit *SchedulingPolicyUnit
	err                  error
}

func NewSchedulingPolicyUnitBuilder() *SchedulingPolicyUnitBuilder {
	return &SchedulingPolicyUnitBuilder{schedulingPolicyUnit: &SchedulingPolicyUnit{}, err: nil}
}

func (builder *SchedulingPolicyUnitBuilder) Comment(attr string) *SchedulingPolicyUnitBuilder {
	if builder.err != nil {
		return builder
	}

	builder.schedulingPolicyUnit.SetComment(attr)
	return builder
}

func (builder *SchedulingPolicyUnitBuilder) Description(attr string) *SchedulingPolicyUnitBuilder {
	if builder.err != nil {
		return builder
	}

	builder.schedulingPolicyUnit.SetDescription(attr)
	return builder
}

func (builder *SchedulingPolicyUnitBuilder) Enabled(attr bool) *SchedulingPolicyUnitBuilder {
	if builder.err != nil {
		return builder
	}

	builder.schedulingPolicyUnit.SetEnabled(attr)
	return builder
}

func (builder *SchedulingPolicyUnitBuilder) Id(attr string) *SchedulingPolicyUnitBuilder {
	if builder.err != nil {
		return builder
	}

	builder.schedulingPolicyUnit.SetId(attr)
	return builder
}

func (builder *SchedulingPolicyUnitBuilder) Internal(attr bool) *SchedulingPolicyUnitBuilder {
	if builder.err != nil {
		return builder
	}

	builder.schedulingPolicyUnit.SetInternal(attr)
	return builder
}

func (builder *SchedulingPolicyUnitBuilder) Name(attr string) *SchedulingPolicyUnitBuilder {
	if builder.err != nil {
		return builder
	}

	builder.schedulingPolicyUnit.SetName(attr)
	return builder
}

func (builder *SchedulingPolicyUnitBuilder) Properties(attr *PropertySlice) *SchedulingPolicyUnitBuilder {
	if builder.err != nil {
		return builder
	}

	builder.schedulingPolicyUnit.SetProperties(attr)
	return builder
}

func (builder *SchedulingPolicyUnitBuilder) PropertiesOfAny(anys ...*Property) *SchedulingPolicyUnitBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.schedulingPolicyUnit.properties == nil {
		builder.schedulingPolicyUnit.properties = new(PropertySlice)
	}
	builder.schedulingPolicyUnit.properties.slice = append(builder.schedulingPolicyUnit.properties.slice, anys...)
	return builder
}

func (builder *SchedulingPolicyUnitBuilder) PropertiesBuilderOfAny(anyBuilders ...PropertyBuilder) *SchedulingPolicyUnitBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.PropertiesOfAny(attr)
	}
	return builder
}

func (builder *SchedulingPolicyUnitBuilder) Type(attr PolicyUnitType) *SchedulingPolicyUnitBuilder {
	if builder.err != nil {
		return builder
	}

	builder.schedulingPolicyUnit.SetType(attr)
	return builder
}

func (builder *SchedulingPolicyUnitBuilder) Href(href string) *SchedulingPolicyUnitBuilder {
	if builder.err != nil {
		return builder
	}

	builder.schedulingPolicyUnit.SetHref(href)
	return builder
}

func (builder *SchedulingPolicyUnitBuilder) Build() (*SchedulingPolicyUnit, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.schedulingPolicyUnit, nil
}

func (builder *SchedulingPolicyUnitBuilder) MustBuild() *SchedulingPolicyUnit {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build SchedulingPolicyUnit instance, reason: %v", builder.err))
	}
	return builder.schedulingPolicyUnit
}

type SeLinuxBuilder struct {
	seLinux *SeLinux
	err     error
}

func NewSeLinuxBuilder() *SeLinuxBuilder {
	return &SeLinuxBuilder{seLinux: &SeLinux{}, err: nil}
}

func (builder *SeLinuxBuilder) Mode(attr SeLinuxMode) *SeLinuxBuilder {
	if builder.err != nil {
		return builder
	}

	builder.seLinux.SetMode(attr)
	return builder
}

func (builder *SeLinuxBuilder) Href(href string) *SeLinuxBuilder {
	if builder.err != nil {
		return builder
	}

	builder.seLinux.SetHref(href)
	return builder
}

func (builder *SeLinuxBuilder) Build() (*SeLinux, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.seLinux, nil
}

func (builder *SeLinuxBuilder) MustBuild() *SeLinux {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build SeLinux instance, reason: %v", builder.err))
	}
	return builder.seLinux
}

type SerialNumberBuilder struct {
	serialNumber *SerialNumber
	err          error
}

func NewSerialNumberBuilder() *SerialNumberBuilder {
	return &SerialNumberBuilder{serialNumber: &SerialNumber{}, err: nil}
}

func (builder *SerialNumberBuilder) Policy(attr SerialNumberPolicy) *SerialNumberBuilder {
	if builder.err != nil {
		return builder
	}

	builder.serialNumber.SetPolicy(attr)
	return builder
}

func (builder *SerialNumberBuilder) Value(attr string) *SerialNumberBuilder {
	if builder.err != nil {
		return builder
	}

	builder.serialNumber.SetValue(attr)
	return builder
}

func (builder *SerialNumberBuilder) Href(href string) *SerialNumberBuilder {
	if builder.err != nil {
		return builder
	}

	builder.serialNumber.SetHref(href)
	return builder
}

func (builder *SerialNumberBuilder) Build() (*SerialNumber, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.serialNumber, nil
}

func (builder *SerialNumberBuilder) MustBuild() *SerialNumber {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build SerialNumber instance, reason: %v", builder.err))
	}
	return builder.serialNumber
}

type SessionBuilder struct {
	session *Session
	err     error
}

func NewSessionBuilder() *SessionBuilder {
	return &SessionBuilder{session: &Session{}, err: nil}
}

func (builder *SessionBuilder) Comment(attr string) *SessionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.session.SetComment(attr)
	return builder
}

func (builder *SessionBuilder) ConsoleUser(attr bool) *SessionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.session.SetConsoleUser(attr)
	return builder
}

func (builder *SessionBuilder) Description(attr string) *SessionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.session.SetDescription(attr)
	return builder
}

func (builder *SessionBuilder) Id(attr string) *SessionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.session.SetId(attr)
	return builder
}

func (builder *SessionBuilder) Ip(attr *Ip) *SessionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.session.SetIp(attr)
	return builder
}

func (builder *SessionBuilder) IpBuilder(attrBuilder *IpBuilder) *SessionBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Ip(attr)
}

func (builder *SessionBuilder) Name(attr string) *SessionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.session.SetName(attr)
	return builder
}

func (builder *SessionBuilder) Protocol(attr string) *SessionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.session.SetProtocol(attr)
	return builder
}

func (builder *SessionBuilder) User(attr *User) *SessionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.session.SetUser(attr)
	return builder
}

func (builder *SessionBuilder) UserBuilder(attrBuilder *UserBuilder) *SessionBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.User(attr)
}

func (builder *SessionBuilder) Vm(attr *Vm) *SessionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.session.SetVm(attr)
	return builder
}

func (builder *SessionBuilder) VmBuilder(attrBuilder *VmBuilder) *SessionBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Vm(attr)
}

func (builder *SessionBuilder) Href(href string) *SessionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.session.SetHref(href)
	return builder
}

func (builder *SessionBuilder) Build() (*Session, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.session, nil
}

func (builder *SessionBuilder) MustBuild() *Session {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build Session instance, reason: %v", builder.err))
	}
	return builder.session
}

type SkipIfConnectivityBrokenBuilder struct {
	skipIfConnectivityBroken *SkipIfConnectivityBroken
	err                      error
}

func NewSkipIfConnectivityBrokenBuilder() *SkipIfConnectivityBrokenBuilder {
	return &SkipIfConnectivityBrokenBuilder{skipIfConnectivityBroken: &SkipIfConnectivityBroken{}, err: nil}
}

func (builder *SkipIfConnectivityBrokenBuilder) Enabled(attr bool) *SkipIfConnectivityBrokenBuilder {
	if builder.err != nil {
		return builder
	}

	builder.skipIfConnectivityBroken.SetEnabled(attr)
	return builder
}

func (builder *SkipIfConnectivityBrokenBuilder) Threshold(attr int64) *SkipIfConnectivityBrokenBuilder {
	if builder.err != nil {
		return builder
	}

	builder.skipIfConnectivityBroken.SetThreshold(attr)
	return builder
}

func (builder *SkipIfConnectivityBrokenBuilder) Href(href string) *SkipIfConnectivityBrokenBuilder {
	if builder.err != nil {
		return builder
	}

	builder.skipIfConnectivityBroken.SetHref(href)
	return builder
}

func (builder *SkipIfConnectivityBrokenBuilder) Build() (*SkipIfConnectivityBroken, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.skipIfConnectivityBroken, nil
}

func (builder *SkipIfConnectivityBrokenBuilder) MustBuild() *SkipIfConnectivityBroken {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build SkipIfConnectivityBroken instance, reason: %v", builder.err))
	}
	return builder.skipIfConnectivityBroken
}

type SkipIfSdActiveBuilder struct {
	skipIfSdActive *SkipIfSdActive
	err            error
}

func NewSkipIfSdActiveBuilder() *SkipIfSdActiveBuilder {
	return &SkipIfSdActiveBuilder{skipIfSdActive: &SkipIfSdActive{}, err: nil}
}

func (builder *SkipIfSdActiveBuilder) Enabled(attr bool) *SkipIfSdActiveBuilder {
	if builder.err != nil {
		return builder
	}

	builder.skipIfSdActive.SetEnabled(attr)
	return builder
}

func (builder *SkipIfSdActiveBuilder) Href(href string) *SkipIfSdActiveBuilder {
	if builder.err != nil {
		return builder
	}

	builder.skipIfSdActive.SetHref(href)
	return builder
}

func (builder *SkipIfSdActiveBuilder) Build() (*SkipIfSdActive, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.skipIfSdActive, nil
}

func (builder *SkipIfSdActiveBuilder) MustBuild() *SkipIfSdActive {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build SkipIfSdActive instance, reason: %v", builder.err))
	}
	return builder.skipIfSdActive
}

type SnapshotBuilder struct {
	snapshot *Snapshot
	err      error
}

func NewSnapshotBuilder() *SnapshotBuilder {
	return &SnapshotBuilder{snapshot: &Snapshot{}, err: nil}
}

func (builder *SnapshotBuilder) AffinityLabels(attr *AffinityLabelSlice) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetAffinityLabels(attr)
	return builder
}

func (builder *SnapshotBuilder) AffinityLabelsOfAny(anys ...*AffinityLabel) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.snapshot.affinityLabels == nil {
		builder.snapshot.affinityLabels = new(AffinityLabelSlice)
	}
	builder.snapshot.affinityLabels.slice = append(builder.snapshot.affinityLabels.slice, anys...)
	return builder
}

func (builder *SnapshotBuilder) AffinityLabelsBuilderOfAny(anyBuilders ...AffinityLabelBuilder) *SnapshotBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.AffinityLabelsOfAny(attr)
	}
	return builder
}

func (builder *SnapshotBuilder) Applications(attr *ApplicationSlice) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetApplications(attr)
	return builder
}

func (builder *SnapshotBuilder) ApplicationsOfAny(anys ...*Application) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.snapshot.applications == nil {
		builder.snapshot.applications = new(ApplicationSlice)
	}
	builder.snapshot.applications.slice = append(builder.snapshot.applications.slice, anys...)
	return builder
}

func (builder *SnapshotBuilder) ApplicationsBuilderOfAny(anyBuilders ...ApplicationBuilder) *SnapshotBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.ApplicationsOfAny(attr)
	}
	return builder
}

func (builder *SnapshotBuilder) Bios(attr *Bios) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetBios(attr)
	return builder
}

func (builder *SnapshotBuilder) BiosBuilder(attrBuilder *BiosBuilder) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Bios(attr)
}

func (builder *SnapshotBuilder) Cdroms(attr *CdromSlice) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetCdroms(attr)
	return builder
}

func (builder *SnapshotBuilder) CdromsOfAny(anys ...*Cdrom) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.snapshot.cdroms == nil {
		builder.snapshot.cdroms = new(CdromSlice)
	}
	builder.snapshot.cdroms.slice = append(builder.snapshot.cdroms.slice, anys...)
	return builder
}

func (builder *SnapshotBuilder) CdromsBuilderOfAny(anyBuilders ...CdromBuilder) *SnapshotBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.CdromsOfAny(attr)
	}
	return builder
}

func (builder *SnapshotBuilder) Cluster(attr *Cluster) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetCluster(attr)
	return builder
}

func (builder *SnapshotBuilder) ClusterBuilder(attrBuilder *ClusterBuilder) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Cluster(attr)
}

func (builder *SnapshotBuilder) Comment(attr string) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetComment(attr)
	return builder
}

func (builder *SnapshotBuilder) Console(attr *Console) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetConsole(attr)
	return builder
}

func (builder *SnapshotBuilder) ConsoleBuilder(attrBuilder *ConsoleBuilder) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Console(attr)
}

func (builder *SnapshotBuilder) Cpu(attr *Cpu) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetCpu(attr)
	return builder
}

func (builder *SnapshotBuilder) CpuBuilder(attrBuilder *CpuBuilder) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Cpu(attr)
}

func (builder *SnapshotBuilder) CpuProfile(attr *CpuProfile) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetCpuProfile(attr)
	return builder
}

func (builder *SnapshotBuilder) CpuProfileBuilder(attrBuilder *CpuProfileBuilder) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.CpuProfile(attr)
}

func (builder *SnapshotBuilder) CpuShares(attr int64) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetCpuShares(attr)
	return builder
}

func (builder *SnapshotBuilder) CreationTime(attr time.Time) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetCreationTime(attr)
	return builder
}

func (builder *SnapshotBuilder) CustomCompatibilityVersion(attr *Version) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetCustomCompatibilityVersion(attr)
	return builder
}

func (builder *SnapshotBuilder) CustomCompatibilityVersionBuilder(attrBuilder *VersionBuilder) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.CustomCompatibilityVersion(attr)
}

func (builder *SnapshotBuilder) CustomCpuModel(attr string) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetCustomCpuModel(attr)
	return builder
}

func (builder *SnapshotBuilder) CustomEmulatedMachine(attr string) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetCustomEmulatedMachine(attr)
	return builder
}

func (builder *SnapshotBuilder) CustomProperties(attr *CustomPropertySlice) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetCustomProperties(attr)
	return builder
}

func (builder *SnapshotBuilder) CustomPropertiesOfAny(anys ...*CustomProperty) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.snapshot.customProperties == nil {
		builder.snapshot.customProperties = new(CustomPropertySlice)
	}
	builder.snapshot.customProperties.slice = append(builder.snapshot.customProperties.slice, anys...)
	return builder
}

func (builder *SnapshotBuilder) CustomPropertiesBuilderOfAny(anyBuilders ...CustomPropertyBuilder) *SnapshotBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.CustomPropertiesOfAny(attr)
	}
	return builder
}

func (builder *SnapshotBuilder) Date(attr time.Time) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetDate(attr)
	return builder
}

func (builder *SnapshotBuilder) DeleteProtected(attr bool) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetDeleteProtected(attr)
	return builder
}

func (builder *SnapshotBuilder) Description(attr string) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetDescription(attr)
	return builder
}

func (builder *SnapshotBuilder) DiskAttachments(attr *DiskAttachmentSlice) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetDiskAttachments(attr)
	return builder
}

func (builder *SnapshotBuilder) DiskAttachmentsOfAny(anys ...*DiskAttachment) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.snapshot.diskAttachments == nil {
		builder.snapshot.diskAttachments = new(DiskAttachmentSlice)
	}
	builder.snapshot.diskAttachments.slice = append(builder.snapshot.diskAttachments.slice, anys...)
	return builder
}

func (builder *SnapshotBuilder) DiskAttachmentsBuilderOfAny(anyBuilders ...DiskAttachmentBuilder) *SnapshotBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.DiskAttachmentsOfAny(attr)
	}
	return builder
}

func (builder *SnapshotBuilder) Disks(attr *DiskSlice) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetDisks(attr)
	return builder
}

func (builder *SnapshotBuilder) DisksOfAny(anys ...*Disk) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.snapshot.disks == nil {
		builder.snapshot.disks = new(DiskSlice)
	}
	builder.snapshot.disks.slice = append(builder.snapshot.disks.slice, anys...)
	return builder
}

func (builder *SnapshotBuilder) DisksBuilderOfAny(anyBuilders ...DiskBuilder) *SnapshotBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.DisksOfAny(attr)
	}
	return builder
}

func (builder *SnapshotBuilder) Display(attr *Display) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetDisplay(attr)
	return builder
}

func (builder *SnapshotBuilder) DisplayBuilder(attrBuilder *DisplayBuilder) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Display(attr)
}

func (builder *SnapshotBuilder) Domain(attr *Domain) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetDomain(attr)
	return builder
}

func (builder *SnapshotBuilder) DomainBuilder(attrBuilder *DomainBuilder) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Domain(attr)
}

func (builder *SnapshotBuilder) ExternalHostProvider(attr *ExternalHostProvider) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetExternalHostProvider(attr)
	return builder
}

func (builder *SnapshotBuilder) ExternalHostProviderBuilder(attrBuilder *ExternalHostProviderBuilder) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.ExternalHostProvider(attr)
}

func (builder *SnapshotBuilder) Floppies(attr *FloppySlice) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetFloppies(attr)
	return builder
}

func (builder *SnapshotBuilder) FloppiesOfAny(anys ...*Floppy) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.snapshot.floppies == nil {
		builder.snapshot.floppies = new(FloppySlice)
	}
	builder.snapshot.floppies.slice = append(builder.snapshot.floppies.slice, anys...)
	return builder
}

func (builder *SnapshotBuilder) FloppiesBuilderOfAny(anyBuilders ...FloppyBuilder) *SnapshotBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.FloppiesOfAny(attr)
	}
	return builder
}

func (builder *SnapshotBuilder) Fqdn(attr string) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetFqdn(attr)
	return builder
}

func (builder *SnapshotBuilder) GraphicsConsoles(attr *GraphicsConsoleSlice) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetGraphicsConsoles(attr)
	return builder
}

func (builder *SnapshotBuilder) GraphicsConsolesOfAny(anys ...*GraphicsConsole) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.snapshot.graphicsConsoles == nil {
		builder.snapshot.graphicsConsoles = new(GraphicsConsoleSlice)
	}
	builder.snapshot.graphicsConsoles.slice = append(builder.snapshot.graphicsConsoles.slice, anys...)
	return builder
}

func (builder *SnapshotBuilder) GraphicsConsolesBuilderOfAny(anyBuilders ...GraphicsConsoleBuilder) *SnapshotBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.GraphicsConsolesOfAny(attr)
	}
	return builder
}

func (builder *SnapshotBuilder) GuestOperatingSystem(attr *GuestOperatingSystem) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetGuestOperatingSystem(attr)
	return builder
}

func (builder *SnapshotBuilder) GuestOperatingSystemBuilder(attrBuilder *GuestOperatingSystemBuilder) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.GuestOperatingSystem(attr)
}

func (builder *SnapshotBuilder) GuestTimeZone(attr *TimeZone) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetGuestTimeZone(attr)
	return builder
}

func (builder *SnapshotBuilder) GuestTimeZoneBuilder(attrBuilder *TimeZoneBuilder) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.GuestTimeZone(attr)
}

func (builder *SnapshotBuilder) HasIllegalImages(attr bool) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetHasIllegalImages(attr)
	return builder
}

func (builder *SnapshotBuilder) HighAvailability(attr *HighAvailability) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetHighAvailability(attr)
	return builder
}

func (builder *SnapshotBuilder) HighAvailabilityBuilder(attrBuilder *HighAvailabilityBuilder) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.HighAvailability(attr)
}

func (builder *SnapshotBuilder) Host(attr *Host) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetHost(attr)
	return builder
}

func (builder *SnapshotBuilder) HostBuilder(attrBuilder *HostBuilder) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Host(attr)
}

func (builder *SnapshotBuilder) HostDevices(attr *HostDeviceSlice) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetHostDevices(attr)
	return builder
}

func (builder *SnapshotBuilder) HostDevicesOfAny(anys ...*HostDevice) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.snapshot.hostDevices == nil {
		builder.snapshot.hostDevices = new(HostDeviceSlice)
	}
	builder.snapshot.hostDevices.slice = append(builder.snapshot.hostDevices.slice, anys...)
	return builder
}

func (builder *SnapshotBuilder) HostDevicesBuilderOfAny(anyBuilders ...HostDeviceBuilder) *SnapshotBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.HostDevicesOfAny(attr)
	}
	return builder
}

func (builder *SnapshotBuilder) Id(attr string) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetId(attr)
	return builder
}

func (builder *SnapshotBuilder) Initialization(attr *Initialization) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetInitialization(attr)
	return builder
}

func (builder *SnapshotBuilder) InitializationBuilder(attrBuilder *InitializationBuilder) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Initialization(attr)
}

func (builder *SnapshotBuilder) InstanceType(attr *InstanceType) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetInstanceType(attr)
	return builder
}

func (builder *SnapshotBuilder) InstanceTypeBuilder(attrBuilder *InstanceTypeBuilder) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.InstanceType(attr)
}

func (builder *SnapshotBuilder) Io(attr *Io) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetIo(attr)
	return builder
}

func (builder *SnapshotBuilder) IoBuilder(attrBuilder *IoBuilder) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Io(attr)
}

func (builder *SnapshotBuilder) KatelloErrata(attr *KatelloErratumSlice) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetKatelloErrata(attr)
	return builder
}

func (builder *SnapshotBuilder) KatelloErrataOfAny(anys ...*KatelloErratum) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.snapshot.katelloErrata == nil {
		builder.snapshot.katelloErrata = new(KatelloErratumSlice)
	}
	builder.snapshot.katelloErrata.slice = append(builder.snapshot.katelloErrata.slice, anys...)
	return builder
}

func (builder *SnapshotBuilder) KatelloErrataBuilderOfAny(anyBuilders ...KatelloErratumBuilder) *SnapshotBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.KatelloErrataOfAny(attr)
	}
	return builder
}

func (builder *SnapshotBuilder) LargeIcon(attr *Icon) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetLargeIcon(attr)
	return builder
}

func (builder *SnapshotBuilder) LargeIconBuilder(attrBuilder *IconBuilder) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.LargeIcon(attr)
}

func (builder *SnapshotBuilder) Lease(attr *StorageDomainLease) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetLease(attr)
	return builder
}

func (builder *SnapshotBuilder) LeaseBuilder(attrBuilder *StorageDomainLeaseBuilder) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Lease(attr)
}

func (builder *SnapshotBuilder) Memory(attr int64) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetMemory(attr)
	return builder
}

func (builder *SnapshotBuilder) MemoryPolicy(attr *MemoryPolicy) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetMemoryPolicy(attr)
	return builder
}

func (builder *SnapshotBuilder) MemoryPolicyBuilder(attrBuilder *MemoryPolicyBuilder) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.MemoryPolicy(attr)
}

func (builder *SnapshotBuilder) Migration(attr *MigrationOptions) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetMigration(attr)
	return builder
}

func (builder *SnapshotBuilder) MigrationBuilder(attrBuilder *MigrationOptionsBuilder) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Migration(attr)
}

func (builder *SnapshotBuilder) MigrationDowntime(attr int64) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetMigrationDowntime(attr)
	return builder
}

func (builder *SnapshotBuilder) MultiQueuesEnabled(attr bool) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetMultiQueuesEnabled(attr)
	return builder
}

func (builder *SnapshotBuilder) Name(attr string) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetName(attr)
	return builder
}

func (builder *SnapshotBuilder) NextRunConfigurationExists(attr bool) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetNextRunConfigurationExists(attr)
	return builder
}

func (builder *SnapshotBuilder) Nics(attr *NicSlice) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetNics(attr)
	return builder
}

func (builder *SnapshotBuilder) NicsOfAny(anys ...*Nic) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.snapshot.nics == nil {
		builder.snapshot.nics = new(NicSlice)
	}
	builder.snapshot.nics.slice = append(builder.snapshot.nics.slice, anys...)
	return builder
}

func (builder *SnapshotBuilder) NicsBuilderOfAny(anyBuilders ...NicBuilder) *SnapshotBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.NicsOfAny(attr)
	}
	return builder
}

func (builder *SnapshotBuilder) NumaNodes(attr *NumaNodeSlice) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetNumaNodes(attr)
	return builder
}

func (builder *SnapshotBuilder) NumaNodesOfAny(anys ...*NumaNode) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.snapshot.numaNodes == nil {
		builder.snapshot.numaNodes = new(NumaNodeSlice)
	}
	builder.snapshot.numaNodes.slice = append(builder.snapshot.numaNodes.slice, anys...)
	return builder
}

func (builder *SnapshotBuilder) NumaNodesBuilderOfAny(anyBuilders ...NumaNodeBuilder) *SnapshotBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.NumaNodesOfAny(attr)
	}
	return builder
}

func (builder *SnapshotBuilder) NumaTuneMode(attr NumaTuneMode) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetNumaTuneMode(attr)
	return builder
}

func (builder *SnapshotBuilder) Origin(attr string) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetOrigin(attr)
	return builder
}

func (builder *SnapshotBuilder) OriginalTemplate(attr *Template) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetOriginalTemplate(attr)
	return builder
}

func (builder *SnapshotBuilder) OriginalTemplateBuilder(attrBuilder *TemplateBuilder) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.OriginalTemplate(attr)
}

func (builder *SnapshotBuilder) Os(attr *OperatingSystem) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetOs(attr)
	return builder
}

func (builder *SnapshotBuilder) OsBuilder(attrBuilder *OperatingSystemBuilder) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Os(attr)
}

func (builder *SnapshotBuilder) Payloads(attr *PayloadSlice) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetPayloads(attr)
	return builder
}

func (builder *SnapshotBuilder) PayloadsOfAny(anys ...*Payload) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.snapshot.payloads == nil {
		builder.snapshot.payloads = new(PayloadSlice)
	}
	builder.snapshot.payloads.slice = append(builder.snapshot.payloads.slice, anys...)
	return builder
}

func (builder *SnapshotBuilder) PayloadsBuilderOfAny(anyBuilders ...PayloadBuilder) *SnapshotBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.PayloadsOfAny(attr)
	}
	return builder
}

func (builder *SnapshotBuilder) Permissions(attr *PermissionSlice) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetPermissions(attr)
	return builder
}

func (builder *SnapshotBuilder) PermissionsOfAny(anys ...*Permission) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.snapshot.permissions == nil {
		builder.snapshot.permissions = new(PermissionSlice)
	}
	builder.snapshot.permissions.slice = append(builder.snapshot.permissions.slice, anys...)
	return builder
}

func (builder *SnapshotBuilder) PermissionsBuilderOfAny(anyBuilders ...PermissionBuilder) *SnapshotBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.PermissionsOfAny(attr)
	}
	return builder
}

func (builder *SnapshotBuilder) PersistMemorystate(attr bool) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetPersistMemorystate(attr)
	return builder
}

func (builder *SnapshotBuilder) PlacementPolicy(attr *VmPlacementPolicy) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetPlacementPolicy(attr)
	return builder
}

func (builder *SnapshotBuilder) PlacementPolicyBuilder(attrBuilder *VmPlacementPolicyBuilder) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.PlacementPolicy(attr)
}

func (builder *SnapshotBuilder) Quota(attr *Quota) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetQuota(attr)
	return builder
}

func (builder *SnapshotBuilder) QuotaBuilder(attrBuilder *QuotaBuilder) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Quota(attr)
}

func (builder *SnapshotBuilder) ReportedDevices(attr *ReportedDeviceSlice) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetReportedDevices(attr)
	return builder
}

func (builder *SnapshotBuilder) ReportedDevicesOfAny(anys ...*ReportedDevice) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.snapshot.reportedDevices == nil {
		builder.snapshot.reportedDevices = new(ReportedDeviceSlice)
	}
	builder.snapshot.reportedDevices.slice = append(builder.snapshot.reportedDevices.slice, anys...)
	return builder
}

func (builder *SnapshotBuilder) ReportedDevicesBuilderOfAny(anyBuilders ...ReportedDeviceBuilder) *SnapshotBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.ReportedDevicesOfAny(attr)
	}
	return builder
}

func (builder *SnapshotBuilder) RngDevice(attr *RngDevice) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetRngDevice(attr)
	return builder
}

func (builder *SnapshotBuilder) RngDeviceBuilder(attrBuilder *RngDeviceBuilder) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.RngDevice(attr)
}

func (builder *SnapshotBuilder) RunOnce(attr bool) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetRunOnce(attr)
	return builder
}

func (builder *SnapshotBuilder) SerialNumber(attr *SerialNumber) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetSerialNumber(attr)
	return builder
}

func (builder *SnapshotBuilder) SerialNumberBuilder(attrBuilder *SerialNumberBuilder) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.SerialNumber(attr)
}

func (builder *SnapshotBuilder) Sessions(attr *SessionSlice) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetSessions(attr)
	return builder
}

func (builder *SnapshotBuilder) SessionsOfAny(anys ...*Session) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.snapshot.sessions == nil {
		builder.snapshot.sessions = new(SessionSlice)
	}
	builder.snapshot.sessions.slice = append(builder.snapshot.sessions.slice, anys...)
	return builder
}

func (builder *SnapshotBuilder) SessionsBuilderOfAny(anyBuilders ...SessionBuilder) *SnapshotBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.SessionsOfAny(attr)
	}
	return builder
}

func (builder *SnapshotBuilder) SmallIcon(attr *Icon) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetSmallIcon(attr)
	return builder
}

func (builder *SnapshotBuilder) SmallIconBuilder(attrBuilder *IconBuilder) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.SmallIcon(attr)
}

func (builder *SnapshotBuilder) SnapshotStatus(attr SnapshotStatus) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetSnapshotStatus(attr)
	return builder
}

func (builder *SnapshotBuilder) SnapshotType(attr SnapshotType) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetSnapshotType(attr)
	return builder
}

func (builder *SnapshotBuilder) Snapshots(attr *SnapshotSlice) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetSnapshots(attr)
	return builder
}

func (builder *SnapshotBuilder) SnapshotsOfAny(anys ...*Snapshot) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.snapshot.snapshots == nil {
		builder.snapshot.snapshots = new(SnapshotSlice)
	}
	builder.snapshot.snapshots.slice = append(builder.snapshot.snapshots.slice, anys...)
	return builder
}

func (builder *SnapshotBuilder) SnapshotsBuilderOfAny(anyBuilders ...SnapshotBuilder) *SnapshotBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.SnapshotsOfAny(attr)
	}
	return builder
}

func (builder *SnapshotBuilder) SoundcardEnabled(attr bool) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetSoundcardEnabled(attr)
	return builder
}

func (builder *SnapshotBuilder) Sso(attr *Sso) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetSso(attr)
	return builder
}

func (builder *SnapshotBuilder) SsoBuilder(attrBuilder *SsoBuilder) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Sso(attr)
}

func (builder *SnapshotBuilder) StartPaused(attr bool) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetStartPaused(attr)
	return builder
}

func (builder *SnapshotBuilder) StartTime(attr time.Time) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetStartTime(attr)
	return builder
}

func (builder *SnapshotBuilder) Stateless(attr bool) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetStateless(attr)
	return builder
}

func (builder *SnapshotBuilder) Statistics(attr *StatisticSlice) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetStatistics(attr)
	return builder
}

func (builder *SnapshotBuilder) StatisticsOfAny(anys ...*Statistic) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.snapshot.statistics == nil {
		builder.snapshot.statistics = new(StatisticSlice)
	}
	builder.snapshot.statistics.slice = append(builder.snapshot.statistics.slice, anys...)
	return builder
}

func (builder *SnapshotBuilder) StatisticsBuilderOfAny(anyBuilders ...StatisticBuilder) *SnapshotBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.StatisticsOfAny(attr)
	}
	return builder
}

func (builder *SnapshotBuilder) Status(attr VmStatus) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetStatus(attr)
	return builder
}

func (builder *SnapshotBuilder) StatusDetail(attr string) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetStatusDetail(attr)
	return builder
}

func (builder *SnapshotBuilder) StopReason(attr string) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetStopReason(attr)
	return builder
}

func (builder *SnapshotBuilder) StopTime(attr time.Time) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetStopTime(attr)
	return builder
}

func (builder *SnapshotBuilder) StorageDomain(attr *StorageDomain) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetStorageDomain(attr)
	return builder
}

func (builder *SnapshotBuilder) StorageDomainBuilder(attrBuilder *StorageDomainBuilder) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.StorageDomain(attr)
}

func (builder *SnapshotBuilder) StorageErrorResumeBehaviour(attr VmStorageErrorResumeBehaviour) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetStorageErrorResumeBehaviour(attr)
	return builder
}

func (builder *SnapshotBuilder) Tags(attr *TagSlice) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetTags(attr)
	return builder
}

func (builder *SnapshotBuilder) TagsOfAny(anys ...*Tag) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.snapshot.tags == nil {
		builder.snapshot.tags = new(TagSlice)
	}
	builder.snapshot.tags.slice = append(builder.snapshot.tags.slice, anys...)
	return builder
}

func (builder *SnapshotBuilder) TagsBuilderOfAny(anyBuilders ...TagBuilder) *SnapshotBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.TagsOfAny(attr)
	}
	return builder
}

func (builder *SnapshotBuilder) Template(attr *Template) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetTemplate(attr)
	return builder
}

func (builder *SnapshotBuilder) TemplateBuilder(attrBuilder *TemplateBuilder) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Template(attr)
}

func (builder *SnapshotBuilder) TimeZone(attr *TimeZone) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetTimeZone(attr)
	return builder
}

func (builder *SnapshotBuilder) TimeZoneBuilder(attrBuilder *TimeZoneBuilder) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.TimeZone(attr)
}

func (builder *SnapshotBuilder) TpmEnabled(attr bool) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetTpmEnabled(attr)
	return builder
}

func (builder *SnapshotBuilder) TunnelMigration(attr bool) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetTunnelMigration(attr)
	return builder
}

func (builder *SnapshotBuilder) Type(attr VmType) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetType(attr)
	return builder
}

func (builder *SnapshotBuilder) Usb(attr *Usb) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetUsb(attr)
	return builder
}

func (builder *SnapshotBuilder) UsbBuilder(attrBuilder *UsbBuilder) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Usb(attr)
}

func (builder *SnapshotBuilder) UseLatestTemplateVersion(attr bool) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetUseLatestTemplateVersion(attr)
	return builder
}

func (builder *SnapshotBuilder) VirtioScsi(attr *VirtioScsi) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetVirtioScsi(attr)
	return builder
}

func (builder *SnapshotBuilder) VirtioScsiBuilder(attrBuilder *VirtioScsiBuilder) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.VirtioScsi(attr)
}

func (builder *SnapshotBuilder) VirtioScsiMultiQueuesEnabled(attr bool) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetVirtioScsiMultiQueuesEnabled(attr)
	return builder
}

func (builder *SnapshotBuilder) Vm(attr *Vm) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetVm(attr)
	return builder
}

func (builder *SnapshotBuilder) VmBuilder(attrBuilder *VmBuilder) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Vm(attr)
}

func (builder *SnapshotBuilder) VmPool(attr *VmPool) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetVmPool(attr)
	return builder
}

func (builder *SnapshotBuilder) VmPoolBuilder(attrBuilder *VmPoolBuilder) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.VmPool(attr)
}

func (builder *SnapshotBuilder) Watchdogs(attr *WatchdogSlice) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetWatchdogs(attr)
	return builder
}

func (builder *SnapshotBuilder) WatchdogsOfAny(anys ...*Watchdog) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.snapshot.watchdogs == nil {
		builder.snapshot.watchdogs = new(WatchdogSlice)
	}
	builder.snapshot.watchdogs.slice = append(builder.snapshot.watchdogs.slice, anys...)
	return builder
}

func (builder *SnapshotBuilder) WatchdogsBuilderOfAny(anyBuilders ...WatchdogBuilder) *SnapshotBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.WatchdogsOfAny(attr)
	}
	return builder
}

func (builder *SnapshotBuilder) Href(href string) *SnapshotBuilder {
	if builder.err != nil {
		return builder
	}

	builder.snapshot.SetHref(href)
	return builder
}

func (builder *SnapshotBuilder) Build() (*Snapshot, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.snapshot, nil
}

func (builder *SnapshotBuilder) MustBuild() *Snapshot {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build Snapshot instance, reason: %v", builder.err))
	}
	return builder.snapshot
}

type SpecialObjectsBuilder struct {
	specialObjects *SpecialObjects
	err            error
}

func NewSpecialObjectsBuilder() *SpecialObjectsBuilder {
	return &SpecialObjectsBuilder{specialObjects: &SpecialObjects{}, err: nil}
}

func (builder *SpecialObjectsBuilder) BlankTemplate(attr *Template) *SpecialObjectsBuilder {
	if builder.err != nil {
		return builder
	}

	builder.specialObjects.SetBlankTemplate(attr)
	return builder
}

func (builder *SpecialObjectsBuilder) BlankTemplateBuilder(attrBuilder *TemplateBuilder) *SpecialObjectsBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.BlankTemplate(attr)
}

func (builder *SpecialObjectsBuilder) RootTag(attr *Tag) *SpecialObjectsBuilder {
	if builder.err != nil {
		return builder
	}

	builder.specialObjects.SetRootTag(attr)
	return builder
}

func (builder *SpecialObjectsBuilder) RootTagBuilder(attrBuilder *TagBuilder) *SpecialObjectsBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.RootTag(attr)
}

func (builder *SpecialObjectsBuilder) Href(href string) *SpecialObjectsBuilder {
	if builder.err != nil {
		return builder
	}

	builder.specialObjects.SetHref(href)
	return builder
}

func (builder *SpecialObjectsBuilder) Build() (*SpecialObjects, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.specialObjects, nil
}

func (builder *SpecialObjectsBuilder) MustBuild() *SpecialObjects {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build SpecialObjects instance, reason: %v", builder.err))
	}
	return builder.specialObjects
}

type SpmBuilder struct {
	spm *Spm
	err error
}

func NewSpmBuilder() *SpmBuilder {
	return &SpmBuilder{spm: &Spm{}, err: nil}
}

func (builder *SpmBuilder) Priority(attr int64) *SpmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.spm.SetPriority(attr)
	return builder
}

func (builder *SpmBuilder) Status(attr SpmStatus) *SpmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.spm.SetStatus(attr)
	return builder
}

func (builder *SpmBuilder) Href(href string) *SpmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.spm.SetHref(href)
	return builder
}

func (builder *SpmBuilder) Build() (*Spm, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.spm, nil
}

func (builder *SpmBuilder) MustBuild() *Spm {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build Spm instance, reason: %v", builder.err))
	}
	return builder.spm
}

type SshBuilder struct {
	ssh *Ssh
	err error
}

func NewSshBuilder() *SshBuilder {
	return &SshBuilder{ssh: &Ssh{}, err: nil}
}

func (builder *SshBuilder) AuthenticationMethod(attr SshAuthenticationMethod) *SshBuilder {
	if builder.err != nil {
		return builder
	}

	builder.ssh.SetAuthenticationMethod(attr)
	return builder
}

func (builder *SshBuilder) Comment(attr string) *SshBuilder {
	if builder.err != nil {
		return builder
	}

	builder.ssh.SetComment(attr)
	return builder
}

func (builder *SshBuilder) Description(attr string) *SshBuilder {
	if builder.err != nil {
		return builder
	}

	builder.ssh.SetDescription(attr)
	return builder
}

func (builder *SshBuilder) Fingerprint(attr string) *SshBuilder {
	if builder.err != nil {
		return builder
	}

	builder.ssh.SetFingerprint(attr)
	return builder
}

func (builder *SshBuilder) Id(attr string) *SshBuilder {
	if builder.err != nil {
		return builder
	}

	builder.ssh.SetId(attr)
	return builder
}

func (builder *SshBuilder) Name(attr string) *SshBuilder {
	if builder.err != nil {
		return builder
	}

	builder.ssh.SetName(attr)
	return builder
}

func (builder *SshBuilder) Port(attr int64) *SshBuilder {
	if builder.err != nil {
		return builder
	}

	builder.ssh.SetPort(attr)
	return builder
}

func (builder *SshBuilder) PublicKey(attr string) *SshBuilder {
	if builder.err != nil {
		return builder
	}

	builder.ssh.SetPublicKey(attr)
	return builder
}

func (builder *SshBuilder) User(attr *User) *SshBuilder {
	if builder.err != nil {
		return builder
	}

	builder.ssh.SetUser(attr)
	return builder
}

func (builder *SshBuilder) UserBuilder(attrBuilder *UserBuilder) *SshBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.User(attr)
}

func (builder *SshBuilder) Href(href string) *SshBuilder {
	if builder.err != nil {
		return builder
	}

	builder.ssh.SetHref(href)
	return builder
}

func (builder *SshBuilder) Build() (*Ssh, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.ssh, nil
}

func (builder *SshBuilder) MustBuild() *Ssh {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build Ssh instance, reason: %v", builder.err))
	}
	return builder.ssh
}

type SshPublicKeyBuilder struct {
	sshPublicKey *SshPublicKey
	err          error
}

func NewSshPublicKeyBuilder() *SshPublicKeyBuilder {
	return &SshPublicKeyBuilder{sshPublicKey: &SshPublicKey{}, err: nil}
}

func (builder *SshPublicKeyBuilder) Comment(attr string) *SshPublicKeyBuilder {
	if builder.err != nil {
		return builder
	}

	builder.sshPublicKey.SetComment(attr)
	return builder
}

func (builder *SshPublicKeyBuilder) Content(attr string) *SshPublicKeyBuilder {
	if builder.err != nil {
		return builder
	}

	builder.sshPublicKey.SetContent(attr)
	return builder
}

func (builder *SshPublicKeyBuilder) Description(attr string) *SshPublicKeyBuilder {
	if builder.err != nil {
		return builder
	}

	builder.sshPublicKey.SetDescription(attr)
	return builder
}

func (builder *SshPublicKeyBuilder) Id(attr string) *SshPublicKeyBuilder {
	if builder.err != nil {
		return builder
	}

	builder.sshPublicKey.SetId(attr)
	return builder
}

func (builder *SshPublicKeyBuilder) Name(attr string) *SshPublicKeyBuilder {
	if builder.err != nil {
		return builder
	}

	builder.sshPublicKey.SetName(attr)
	return builder
}

func (builder *SshPublicKeyBuilder) User(attr *User) *SshPublicKeyBuilder {
	if builder.err != nil {
		return builder
	}

	builder.sshPublicKey.SetUser(attr)
	return builder
}

func (builder *SshPublicKeyBuilder) UserBuilder(attrBuilder *UserBuilder) *SshPublicKeyBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.User(attr)
}

func (builder *SshPublicKeyBuilder) Href(href string) *SshPublicKeyBuilder {
	if builder.err != nil {
		return builder
	}

	builder.sshPublicKey.SetHref(href)
	return builder
}

func (builder *SshPublicKeyBuilder) Build() (*SshPublicKey, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.sshPublicKey, nil
}

func (builder *SshPublicKeyBuilder) MustBuild() *SshPublicKey {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build SshPublicKey instance, reason: %v", builder.err))
	}
	return builder.sshPublicKey
}

type SsoBuilder struct {
	sso *Sso
	err error
}

func NewSsoBuilder() *SsoBuilder {
	return &SsoBuilder{sso: &Sso{}, err: nil}
}

func (builder *SsoBuilder) Methods(attr *MethodSlice) *SsoBuilder {
	if builder.err != nil {
		return builder
	}

	builder.sso.SetMethods(attr)
	return builder
}

func (builder *SsoBuilder) MethodsOfAny(anys ...*Method) *SsoBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.sso.methods == nil {
		builder.sso.methods = new(MethodSlice)
	}
	builder.sso.methods.slice = append(builder.sso.methods.slice, anys...)
	return builder
}

func (builder *SsoBuilder) MethodsBuilderOfAny(anyBuilders ...MethodBuilder) *SsoBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.MethodsOfAny(attr)
	}
	return builder
}

func (builder *SsoBuilder) Href(href string) *SsoBuilder {
	if builder.err != nil {
		return builder
	}

	builder.sso.SetHref(href)
	return builder
}

func (builder *SsoBuilder) Build() (*Sso, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.sso, nil
}

func (builder *SsoBuilder) MustBuild() *Sso {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build Sso instance, reason: %v", builder.err))
	}
	return builder.sso
}

type StatisticBuilder struct {
	statistic *Statistic
	err       error
}

func NewStatisticBuilder() *StatisticBuilder {
	return &StatisticBuilder{statistic: &Statistic{}, err: nil}
}

func (builder *StatisticBuilder) Brick(attr *GlusterBrick) *StatisticBuilder {
	if builder.err != nil {
		return builder
	}

	builder.statistic.SetBrick(attr)
	return builder
}

func (builder *StatisticBuilder) BrickBuilder(attrBuilder *GlusterBrickBuilder) *StatisticBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Brick(attr)
}

func (builder *StatisticBuilder) Comment(attr string) *StatisticBuilder {
	if builder.err != nil {
		return builder
	}

	builder.statistic.SetComment(attr)
	return builder
}

func (builder *StatisticBuilder) Description(attr string) *StatisticBuilder {
	if builder.err != nil {
		return builder
	}

	builder.statistic.SetDescription(attr)
	return builder
}

func (builder *StatisticBuilder) Disk(attr *Disk) *StatisticBuilder {
	if builder.err != nil {
		return builder
	}

	builder.statistic.SetDisk(attr)
	return builder
}

func (builder *StatisticBuilder) DiskBuilder(attrBuilder *DiskBuilder) *StatisticBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Disk(attr)
}

func (builder *StatisticBuilder) GlusterVolume(attr *GlusterVolume) *StatisticBuilder {
	if builder.err != nil {
		return builder
	}

	builder.statistic.SetGlusterVolume(attr)
	return builder
}

func (builder *StatisticBuilder) GlusterVolumeBuilder(attrBuilder *GlusterVolumeBuilder) *StatisticBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.GlusterVolume(attr)
}

func (builder *StatisticBuilder) Host(attr *Host) *StatisticBuilder {
	if builder.err != nil {
		return builder
	}

	builder.statistic.SetHost(attr)
	return builder
}

func (builder *StatisticBuilder) HostBuilder(attrBuilder *HostBuilder) *StatisticBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Host(attr)
}

func (builder *StatisticBuilder) HostNic(attr *HostNic) *StatisticBuilder {
	if builder.err != nil {
		return builder
	}

	builder.statistic.SetHostNic(attr)
	return builder
}

func (builder *StatisticBuilder) HostNicBuilder(attrBuilder *HostNicBuilder) *StatisticBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.HostNic(attr)
}

func (builder *StatisticBuilder) HostNumaNode(attr *NumaNode) *StatisticBuilder {
	if builder.err != nil {
		return builder
	}

	builder.statistic.SetHostNumaNode(attr)
	return builder
}

func (builder *StatisticBuilder) HostNumaNodeBuilder(attrBuilder *NumaNodeBuilder) *StatisticBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.HostNumaNode(attr)
}

func (builder *StatisticBuilder) Id(attr string) *StatisticBuilder {
	if builder.err != nil {
		return builder
	}

	builder.statistic.SetId(attr)
	return builder
}

func (builder *StatisticBuilder) Kind(attr StatisticKind) *StatisticBuilder {
	if builder.err != nil {
		return builder
	}

	builder.statistic.SetKind(attr)
	return builder
}

func (builder *StatisticBuilder) Name(attr string) *StatisticBuilder {
	if builder.err != nil {
		return builder
	}

	builder.statistic.SetName(attr)
	return builder
}

func (builder *StatisticBuilder) Nic(attr *Nic) *StatisticBuilder {
	if builder.err != nil {
		return builder
	}

	builder.statistic.SetNic(attr)
	return builder
}

func (builder *StatisticBuilder) NicBuilder(attrBuilder *NicBuilder) *StatisticBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Nic(attr)
}

func (builder *StatisticBuilder) Step(attr *Step) *StatisticBuilder {
	if builder.err != nil {
		return builder
	}

	builder.statistic.SetStep(attr)
	return builder
}

func (builder *StatisticBuilder) StepBuilder(attrBuilder *StepBuilder) *StatisticBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Step(attr)
}

func (builder *StatisticBuilder) Type(attr ValueType) *StatisticBuilder {
	if builder.err != nil {
		return builder
	}

	builder.statistic.SetType(attr)
	return builder
}

func (builder *StatisticBuilder) Unit(attr StatisticUnit) *StatisticBuilder {
	if builder.err != nil {
		return builder
	}

	builder.statistic.SetUnit(attr)
	return builder
}

func (builder *StatisticBuilder) Values(attr *ValueSlice) *StatisticBuilder {
	if builder.err != nil {
		return builder
	}

	builder.statistic.SetValues(attr)
	return builder
}

func (builder *StatisticBuilder) ValuesOfAny(anys ...*Value) *StatisticBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.statistic.values == nil {
		builder.statistic.values = new(ValueSlice)
	}
	builder.statistic.values.slice = append(builder.statistic.values.slice, anys...)
	return builder
}

func (builder *StatisticBuilder) ValuesBuilderOfAny(anyBuilders ...ValueBuilder) *StatisticBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.ValuesOfAny(attr)
	}
	return builder
}

func (builder *StatisticBuilder) Vm(attr *Vm) *StatisticBuilder {
	if builder.err != nil {
		return builder
	}

	builder.statistic.SetVm(attr)
	return builder
}

func (builder *StatisticBuilder) VmBuilder(attrBuilder *VmBuilder) *StatisticBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Vm(attr)
}

func (builder *StatisticBuilder) Href(href string) *StatisticBuilder {
	if builder.err != nil {
		return builder
	}

	builder.statistic.SetHref(href)
	return builder
}

func (builder *StatisticBuilder) Build() (*Statistic, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.statistic, nil
}

func (builder *StatisticBuilder) MustBuild() *Statistic {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build Statistic instance, reason: %v", builder.err))
	}
	return builder.statistic
}

type StepBuilder struct {
	step *Step
	err  error
}

func NewStepBuilder() *StepBuilder {
	return &StepBuilder{step: &Step{}, err: nil}
}

func (builder *StepBuilder) Comment(attr string) *StepBuilder {
	if builder.err != nil {
		return builder
	}

	builder.step.SetComment(attr)
	return builder
}

func (builder *StepBuilder) Description(attr string) *StepBuilder {
	if builder.err != nil {
		return builder
	}

	builder.step.SetDescription(attr)
	return builder
}

func (builder *StepBuilder) EndTime(attr time.Time) *StepBuilder {
	if builder.err != nil {
		return builder
	}

	builder.step.SetEndTime(attr)
	return builder
}

func (builder *StepBuilder) ExecutionHost(attr *Host) *StepBuilder {
	if builder.err != nil {
		return builder
	}

	builder.step.SetExecutionHost(attr)
	return builder
}

func (builder *StepBuilder) ExecutionHostBuilder(attrBuilder *HostBuilder) *StepBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.ExecutionHost(attr)
}

func (builder *StepBuilder) External(attr bool) *StepBuilder {
	if builder.err != nil {
		return builder
	}

	builder.step.SetExternal(attr)
	return builder
}

func (builder *StepBuilder) ExternalType(attr ExternalSystemType) *StepBuilder {
	if builder.err != nil {
		return builder
	}

	builder.step.SetExternalType(attr)
	return builder
}

func (builder *StepBuilder) Id(attr string) *StepBuilder {
	if builder.err != nil {
		return builder
	}

	builder.step.SetId(attr)
	return builder
}

func (builder *StepBuilder) Job(attr *Job) *StepBuilder {
	if builder.err != nil {
		return builder
	}

	builder.step.SetJob(attr)
	return builder
}

func (builder *StepBuilder) JobBuilder(attrBuilder *JobBuilder) *StepBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Job(attr)
}

func (builder *StepBuilder) Name(attr string) *StepBuilder {
	if builder.err != nil {
		return builder
	}

	builder.step.SetName(attr)
	return builder
}

func (builder *StepBuilder) Number(attr int64) *StepBuilder {
	if builder.err != nil {
		return builder
	}

	builder.step.SetNumber(attr)
	return builder
}

func (builder *StepBuilder) ParentStep(attr *Step) *StepBuilder {
	if builder.err != nil {
		return builder
	}

	builder.step.SetParentStep(attr)
	return builder
}

func (builder *StepBuilder) ParentStepBuilder(attrBuilder *StepBuilder) *StepBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.ParentStep(attr)
}

func (builder *StepBuilder) Progress(attr int64) *StepBuilder {
	if builder.err != nil {
		return builder
	}

	builder.step.SetProgress(attr)
	return builder
}

func (builder *StepBuilder) StartTime(attr time.Time) *StepBuilder {
	if builder.err != nil {
		return builder
	}

	builder.step.SetStartTime(attr)
	return builder
}

func (builder *StepBuilder) Statistics(attr *StatisticSlice) *StepBuilder {
	if builder.err != nil {
		return builder
	}

	builder.step.SetStatistics(attr)
	return builder
}

func (builder *StepBuilder) StatisticsOfAny(anys ...*Statistic) *StepBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.step.statistics == nil {
		builder.step.statistics = new(StatisticSlice)
	}
	builder.step.statistics.slice = append(builder.step.statistics.slice, anys...)
	return builder
}

func (builder *StepBuilder) StatisticsBuilderOfAny(anyBuilders ...StatisticBuilder) *StepBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.StatisticsOfAny(attr)
	}
	return builder
}

func (builder *StepBuilder) Status(attr StepStatus) *StepBuilder {
	if builder.err != nil {
		return builder
	}

	builder.step.SetStatus(attr)
	return builder
}

func (builder *StepBuilder) Type(attr StepEnum) *StepBuilder {
	if builder.err != nil {
		return builder
	}

	builder.step.SetType(attr)
	return builder
}

func (builder *StepBuilder) Href(href string) *StepBuilder {
	if builder.err != nil {
		return builder
	}

	builder.step.SetHref(href)
	return builder
}

func (builder *StepBuilder) Build() (*Step, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.step, nil
}

func (builder *StepBuilder) MustBuild() *Step {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build Step instance, reason: %v", builder.err))
	}
	return builder.step
}

type StorageConnectionBuilder struct {
	storageConnection *StorageConnection
	err               error
}

func NewStorageConnectionBuilder() *StorageConnectionBuilder {
	return &StorageConnectionBuilder{storageConnection: &StorageConnection{}, err: nil}
}

func (builder *StorageConnectionBuilder) Address(attr string) *StorageConnectionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.storageConnection.SetAddress(attr)
	return builder
}

func (builder *StorageConnectionBuilder) Comment(attr string) *StorageConnectionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.storageConnection.SetComment(attr)
	return builder
}

func (builder *StorageConnectionBuilder) Description(attr string) *StorageConnectionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.storageConnection.SetDescription(attr)
	return builder
}

func (builder *StorageConnectionBuilder) GlusterVolume(attr *GlusterVolume) *StorageConnectionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.storageConnection.SetGlusterVolume(attr)
	return builder
}

func (builder *StorageConnectionBuilder) GlusterVolumeBuilder(attrBuilder *GlusterVolumeBuilder) *StorageConnectionBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.GlusterVolume(attr)
}

func (builder *StorageConnectionBuilder) Host(attr *Host) *StorageConnectionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.storageConnection.SetHost(attr)
	return builder
}

func (builder *StorageConnectionBuilder) HostBuilder(attrBuilder *HostBuilder) *StorageConnectionBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Host(attr)
}

func (builder *StorageConnectionBuilder) Id(attr string) *StorageConnectionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.storageConnection.SetId(attr)
	return builder
}

func (builder *StorageConnectionBuilder) MountOptions(attr string) *StorageConnectionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.storageConnection.SetMountOptions(attr)
	return builder
}

func (builder *StorageConnectionBuilder) Name(attr string) *StorageConnectionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.storageConnection.SetName(attr)
	return builder
}

func (builder *StorageConnectionBuilder) NfsRetrans(attr int64) *StorageConnectionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.storageConnection.SetNfsRetrans(attr)
	return builder
}

func (builder *StorageConnectionBuilder) NfsTimeo(attr int64) *StorageConnectionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.storageConnection.SetNfsTimeo(attr)
	return builder
}

func (builder *StorageConnectionBuilder) NfsVersion(attr NfsVersion) *StorageConnectionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.storageConnection.SetNfsVersion(attr)
	return builder
}

func (builder *StorageConnectionBuilder) Password(attr string) *StorageConnectionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.storageConnection.SetPassword(attr)
	return builder
}

func (builder *StorageConnectionBuilder) Path(attr string) *StorageConnectionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.storageConnection.SetPath(attr)
	return builder
}

func (builder *StorageConnectionBuilder) Port(attr int64) *StorageConnectionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.storageConnection.SetPort(attr)
	return builder
}

func (builder *StorageConnectionBuilder) Portal(attr string) *StorageConnectionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.storageConnection.SetPortal(attr)
	return builder
}

func (builder *StorageConnectionBuilder) Target(attr string) *StorageConnectionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.storageConnection.SetTarget(attr)
	return builder
}

func (builder *StorageConnectionBuilder) Type(attr StorageType) *StorageConnectionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.storageConnection.SetType(attr)
	return builder
}

func (builder *StorageConnectionBuilder) Username(attr string) *StorageConnectionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.storageConnection.SetUsername(attr)
	return builder
}

func (builder *StorageConnectionBuilder) VfsType(attr string) *StorageConnectionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.storageConnection.SetVfsType(attr)
	return builder
}

func (builder *StorageConnectionBuilder) Href(href string) *StorageConnectionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.storageConnection.SetHref(href)
	return builder
}

func (builder *StorageConnectionBuilder) Build() (*StorageConnection, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.storageConnection, nil
}

func (builder *StorageConnectionBuilder) MustBuild() *StorageConnection {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build StorageConnection instance, reason: %v", builder.err))
	}
	return builder.storageConnection
}

type StorageConnectionExtensionBuilder struct {
	storageConnectionExtension *StorageConnectionExtension
	err                        error
}

func NewStorageConnectionExtensionBuilder() *StorageConnectionExtensionBuilder {
	return &StorageConnectionExtensionBuilder{storageConnectionExtension: &StorageConnectionExtension{}, err: nil}
}

func (builder *StorageConnectionExtensionBuilder) Comment(attr string) *StorageConnectionExtensionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.storageConnectionExtension.SetComment(attr)
	return builder
}

func (builder *StorageConnectionExtensionBuilder) Description(attr string) *StorageConnectionExtensionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.storageConnectionExtension.SetDescription(attr)
	return builder
}

func (builder *StorageConnectionExtensionBuilder) Host(attr *Host) *StorageConnectionExtensionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.storageConnectionExtension.SetHost(attr)
	return builder
}

func (builder *StorageConnectionExtensionBuilder) HostBuilder(attrBuilder *HostBuilder) *StorageConnectionExtensionBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Host(attr)
}

func (builder *StorageConnectionExtensionBuilder) Id(attr string) *StorageConnectionExtensionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.storageConnectionExtension.SetId(attr)
	return builder
}

func (builder *StorageConnectionExtensionBuilder) Name(attr string) *StorageConnectionExtensionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.storageConnectionExtension.SetName(attr)
	return builder
}

func (builder *StorageConnectionExtensionBuilder) Password(attr string) *StorageConnectionExtensionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.storageConnectionExtension.SetPassword(attr)
	return builder
}

func (builder *StorageConnectionExtensionBuilder) Target(attr string) *StorageConnectionExtensionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.storageConnectionExtension.SetTarget(attr)
	return builder
}

func (builder *StorageConnectionExtensionBuilder) Username(attr string) *StorageConnectionExtensionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.storageConnectionExtension.SetUsername(attr)
	return builder
}

func (builder *StorageConnectionExtensionBuilder) Href(href string) *StorageConnectionExtensionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.storageConnectionExtension.SetHref(href)
	return builder
}

func (builder *StorageConnectionExtensionBuilder) Build() (*StorageConnectionExtension, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.storageConnectionExtension, nil
}

func (builder *StorageConnectionExtensionBuilder) MustBuild() *StorageConnectionExtension {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build StorageConnectionExtension instance, reason: %v", builder.err))
	}
	return builder.storageConnectionExtension
}

type StorageDomainBuilder struct {
	storageDomain *StorageDomain
	err           error
}

func NewStorageDomainBuilder() *StorageDomainBuilder {
	return &StorageDomainBuilder{storageDomain: &StorageDomain{}, err: nil}
}

func (builder *StorageDomainBuilder) Available(attr int64) *StorageDomainBuilder {
	if builder.err != nil {
		return builder
	}

	builder.storageDomain.SetAvailable(attr)
	return builder
}

func (builder *StorageDomainBuilder) Backup(attr bool) *StorageDomainBuilder {
	if builder.err != nil {
		return builder
	}

	builder.storageDomain.SetBackup(attr)
	return builder
}

func (builder *StorageDomainBuilder) BlockSize(attr int64) *StorageDomainBuilder {
	if builder.err != nil {
		return builder
	}

	builder.storageDomain.SetBlockSize(attr)
	return builder
}

func (builder *StorageDomainBuilder) Comment(attr string) *StorageDomainBuilder {
	if builder.err != nil {
		return builder
	}

	builder.storageDomain.SetComment(attr)
	return builder
}

func (builder *StorageDomainBuilder) Committed(attr int64) *StorageDomainBuilder {
	if builder.err != nil {
		return builder
	}

	builder.storageDomain.SetCommitted(attr)
	return builder
}

func (builder *StorageDomainBuilder) CriticalSpaceActionBlocker(attr int64) *StorageDomainBuilder {
	if builder.err != nil {
		return builder
	}

	builder.storageDomain.SetCriticalSpaceActionBlocker(attr)
	return builder
}

func (builder *StorageDomainBuilder) DataCenter(attr *DataCenter) *StorageDomainBuilder {
	if builder.err != nil {
		return builder
	}

	builder.storageDomain.SetDataCenter(attr)
	return builder
}

func (builder *StorageDomainBuilder) DataCenterBuilder(attrBuilder *DataCenterBuilder) *StorageDomainBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.DataCenter(attr)
}

func (builder *StorageDomainBuilder) DataCenters(attr *DataCenterSlice) *StorageDomainBuilder {
	if builder.err != nil {
		return builder
	}

	builder.storageDomain.SetDataCenters(attr)
	return builder
}

func (builder *StorageDomainBuilder) DataCentersOfAny(anys ...*DataCenter) *StorageDomainBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.storageDomain.dataCenters == nil {
		builder.storageDomain.dataCenters = new(DataCenterSlice)
	}
	builder.storageDomain.dataCenters.slice = append(builder.storageDomain.dataCenters.slice, anys...)
	return builder
}

func (builder *StorageDomainBuilder) DataCentersBuilderOfAny(anyBuilders ...DataCenterBuilder) *StorageDomainBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.DataCentersOfAny(attr)
	}
	return builder
}

func (builder *StorageDomainBuilder) Description(attr string) *StorageDomainBuilder {
	if builder.err != nil {
		return builder
	}

	builder.storageDomain.SetDescription(attr)
	return builder
}

func (builder *StorageDomainBuilder) DiscardAfterDelete(attr bool) *StorageDomainBuilder {
	if builder.err != nil {
		return builder
	}

	builder.storageDomain.SetDiscardAfterDelete(attr)
	return builder
}

func (builder *StorageDomainBuilder) DiskProfiles(attr *DiskProfileSlice) *StorageDomainBuilder {
	if builder.err != nil {
		return builder
	}

	builder.storageDomain.SetDiskProfiles(attr)
	return builder
}

func (builder *StorageDomainBuilder) DiskProfilesOfAny(anys ...*DiskProfile) *StorageDomainBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.storageDomain.diskProfiles == nil {
		builder.storageDomain.diskProfiles = new(DiskProfileSlice)
	}
	builder.storageDomain.diskProfiles.slice = append(builder.storageDomain.diskProfiles.slice, anys...)
	return builder
}

func (builder *StorageDomainBuilder) DiskProfilesBuilderOfAny(anyBuilders ...DiskProfileBuilder) *StorageDomainBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.DiskProfilesOfAny(attr)
	}
	return builder
}

func (builder *StorageDomainBuilder) DiskSnapshots(attr *DiskSnapshotSlice) *StorageDomainBuilder {
	if builder.err != nil {
		return builder
	}

	builder.storageDomain.SetDiskSnapshots(attr)
	return builder
}

func (builder *StorageDomainBuilder) DiskSnapshotsOfAny(anys ...*DiskSnapshot) *StorageDomainBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.storageDomain.diskSnapshots == nil {
		builder.storageDomain.diskSnapshots = new(DiskSnapshotSlice)
	}
	builder.storageDomain.diskSnapshots.slice = append(builder.storageDomain.diskSnapshots.slice, anys...)
	return builder
}

func (builder *StorageDomainBuilder) DiskSnapshotsBuilderOfAny(anyBuilders ...DiskSnapshotBuilder) *StorageDomainBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.DiskSnapshotsOfAny(attr)
	}
	return builder
}

func (builder *StorageDomainBuilder) Disks(attr *DiskSlice) *StorageDomainBuilder {
	if builder.err != nil {
		return builder
	}

	builder.storageDomain.SetDisks(attr)
	return builder
}

func (builder *StorageDomainBuilder) DisksOfAny(anys ...*Disk) *StorageDomainBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.storageDomain.disks == nil {
		builder.storageDomain.disks = new(DiskSlice)
	}
	builder.storageDomain.disks.slice = append(builder.storageDomain.disks.slice, anys...)
	return builder
}

func (builder *StorageDomainBuilder) DisksBuilderOfAny(anyBuilders ...DiskBuilder) *StorageDomainBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.DisksOfAny(attr)
	}
	return builder
}

func (builder *StorageDomainBuilder) ExternalStatus(attr ExternalStatus) *StorageDomainBuilder {
	if builder.err != nil {
		return builder
	}

	builder.storageDomain.SetExternalStatus(attr)
	return builder
}

func (builder *StorageDomainBuilder) Files(attr *FileSlice) *StorageDomainBuilder {
	if builder.err != nil {
		return builder
	}

	builder.storageDomain.SetFiles(attr)
	return builder
}

func (builder *StorageDomainBuilder) FilesOfAny(anys ...*File) *StorageDomainBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.storageDomain.files == nil {
		builder.storageDomain.files = new(FileSlice)
	}
	builder.storageDomain.files.slice = append(builder.storageDomain.files.slice, anys...)
	return builder
}

func (builder *StorageDomainBuilder) FilesBuilderOfAny(anyBuilders ...FileBuilder) *StorageDomainBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.FilesOfAny(attr)
	}
	return builder
}

func (builder *StorageDomainBuilder) Host(attr *Host) *StorageDomainBuilder {
	if builder.err != nil {
		return builder
	}

	builder.storageDomain.SetHost(attr)
	return builder
}

func (builder *StorageDomainBuilder) HostBuilder(attrBuilder *HostBuilder) *StorageDomainBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Host(attr)
}

func (builder *StorageDomainBuilder) Id(attr string) *StorageDomainBuilder {
	if builder.err != nil {
		return builder
	}

	builder.storageDomain.SetId(attr)
	return builder
}

func (builder *StorageDomainBuilder) Images(attr *ImageSlice) *StorageDomainBuilder {
	if builder.err != nil {
		return builder
	}

	builder.storageDomain.SetImages(attr)
	return builder
}

func (builder *StorageDomainBuilder) ImagesOfAny(anys ...*Image) *StorageDomainBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.storageDomain.images == nil {
		builder.storageDomain.images = new(ImageSlice)
	}
	builder.storageDomain.images.slice = append(builder.storageDomain.images.slice, anys...)
	return builder
}

func (builder *StorageDomainBuilder) ImagesBuilderOfAny(anyBuilders ...ImageBuilder) *StorageDomainBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.ImagesOfAny(attr)
	}
	return builder
}

func (builder *StorageDomainBuilder) Import(attr bool) *StorageDomainBuilder {
	if builder.err != nil {
		return builder
	}

	builder.storageDomain.SetImport(attr)
	return builder
}

func (builder *StorageDomainBuilder) Master(attr bool) *StorageDomainBuilder {
	if builder.err != nil {
		return builder
	}

	builder.storageDomain.SetMaster(attr)
	return builder
}

func (builder *StorageDomainBuilder) Name(attr string) *StorageDomainBuilder {
	if builder.err != nil {
		return builder
	}

	builder.storageDomain.SetName(attr)
	return builder
}

func (builder *StorageDomainBuilder) Permissions(attr *PermissionSlice) *StorageDomainBuilder {
	if builder.err != nil {
		return builder
	}

	builder.storageDomain.SetPermissions(attr)
	return builder
}

func (builder *StorageDomainBuilder) PermissionsOfAny(anys ...*Permission) *StorageDomainBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.storageDomain.permissions == nil {
		builder.storageDomain.permissions = new(PermissionSlice)
	}
	builder.storageDomain.permissions.slice = append(builder.storageDomain.permissions.slice, anys...)
	return builder
}

func (builder *StorageDomainBuilder) PermissionsBuilderOfAny(anyBuilders ...PermissionBuilder) *StorageDomainBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.PermissionsOfAny(attr)
	}
	return builder
}

func (builder *StorageDomainBuilder) Status(attr StorageDomainStatus) *StorageDomainBuilder {
	if builder.err != nil {
		return builder
	}

	builder.storageDomain.SetStatus(attr)
	return builder
}

func (builder *StorageDomainBuilder) Storage(attr *HostStorage) *StorageDomainBuilder {
	if builder.err != nil {
		return builder
	}

	builder.storageDomain.SetStorage(attr)
	return builder
}

func (builder *StorageDomainBuilder) StorageBuilder(attrBuilder *HostStorageBuilder) *StorageDomainBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Storage(attr)
}

func (builder *StorageDomainBuilder) StorageConnections(attr *StorageConnectionSlice) *StorageDomainBuilder {
	if builder.err != nil {
		return builder
	}

	builder.storageDomain.SetStorageConnections(attr)
	return builder
}

func (builder *StorageDomainBuilder) StorageConnectionsOfAny(anys ...*StorageConnection) *StorageDomainBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.storageDomain.storageConnections == nil {
		builder.storageDomain.storageConnections = new(StorageConnectionSlice)
	}
	builder.storageDomain.storageConnections.slice = append(builder.storageDomain.storageConnections.slice, anys...)
	return builder
}

func (builder *StorageDomainBuilder) StorageConnectionsBuilderOfAny(anyBuilders ...StorageConnectionBuilder) *StorageDomainBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.StorageConnectionsOfAny(attr)
	}
	return builder
}

func (builder *StorageDomainBuilder) StorageFormat(attr StorageFormat) *StorageDomainBuilder {
	if builder.err != nil {
		return builder
	}

	builder.storageDomain.SetStorageFormat(attr)
	return builder
}

func (builder *StorageDomainBuilder) SupportsDiscard(attr bool) *StorageDomainBuilder {
	if builder.err != nil {
		return builder
	}

	builder.storageDomain.SetSupportsDiscard(attr)
	return builder
}

func (builder *StorageDomainBuilder) SupportsDiscardZeroesData(attr bool) *StorageDomainBuilder {
	if builder.err != nil {
		return builder
	}

	builder.storageDomain.SetSupportsDiscardZeroesData(attr)
	return builder
}

func (builder *StorageDomainBuilder) Templates(attr *TemplateSlice) *StorageDomainBuilder {
	if builder.err != nil {
		return builder
	}

	builder.storageDomain.SetTemplates(attr)
	return builder
}

func (builder *StorageDomainBuilder) TemplatesOfAny(anys ...*Template) *StorageDomainBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.storageDomain.templates == nil {
		builder.storageDomain.templates = new(TemplateSlice)
	}
	builder.storageDomain.templates.slice = append(builder.storageDomain.templates.slice, anys...)
	return builder
}

func (builder *StorageDomainBuilder) TemplatesBuilderOfAny(anyBuilders ...TemplateBuilder) *StorageDomainBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.TemplatesOfAny(attr)
	}
	return builder
}

func (builder *StorageDomainBuilder) Type(attr StorageDomainType) *StorageDomainBuilder {
	if builder.err != nil {
		return builder
	}

	builder.storageDomain.SetType(attr)
	return builder
}

func (builder *StorageDomainBuilder) Used(attr int64) *StorageDomainBuilder {
	if builder.err != nil {
		return builder
	}

	builder.storageDomain.SetUsed(attr)
	return builder
}

func (builder *StorageDomainBuilder) Vms(attr *VmSlice) *StorageDomainBuilder {
	if builder.err != nil {
		return builder
	}

	builder.storageDomain.SetVms(attr)
	return builder
}

func (builder *StorageDomainBuilder) VmsOfAny(anys ...*Vm) *StorageDomainBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.storageDomain.vms == nil {
		builder.storageDomain.vms = new(VmSlice)
	}
	builder.storageDomain.vms.slice = append(builder.storageDomain.vms.slice, anys...)
	return builder
}

func (builder *StorageDomainBuilder) VmsBuilderOfAny(anyBuilders ...VmBuilder) *StorageDomainBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.VmsOfAny(attr)
	}
	return builder
}

func (builder *StorageDomainBuilder) WarningLowSpaceIndicator(attr int64) *StorageDomainBuilder {
	if builder.err != nil {
		return builder
	}

	builder.storageDomain.SetWarningLowSpaceIndicator(attr)
	return builder
}

func (builder *StorageDomainBuilder) WipeAfterDelete(attr bool) *StorageDomainBuilder {
	if builder.err != nil {
		return builder
	}

	builder.storageDomain.SetWipeAfterDelete(attr)
	return builder
}

func (builder *StorageDomainBuilder) Href(href string) *StorageDomainBuilder {
	if builder.err != nil {
		return builder
	}

	builder.storageDomain.SetHref(href)
	return builder
}

func (builder *StorageDomainBuilder) Build() (*StorageDomain, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.storageDomain, nil
}

func (builder *StorageDomainBuilder) MustBuild() *StorageDomain {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build StorageDomain instance, reason: %v", builder.err))
	}
	return builder.storageDomain
}

type StorageDomainLeaseBuilder struct {
	storageDomainLease *StorageDomainLease
	err                error
}

func NewStorageDomainLeaseBuilder() *StorageDomainLeaseBuilder {
	return &StorageDomainLeaseBuilder{storageDomainLease: &StorageDomainLease{}, err: nil}
}

func (builder *StorageDomainLeaseBuilder) StorageDomain(attr *StorageDomain) *StorageDomainLeaseBuilder {
	if builder.err != nil {
		return builder
	}

	builder.storageDomainLease.SetStorageDomain(attr)
	return builder
}

func (builder *StorageDomainLeaseBuilder) StorageDomainBuilder(attrBuilder *StorageDomainBuilder) *StorageDomainLeaseBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.StorageDomain(attr)
}

func (builder *StorageDomainLeaseBuilder) Href(href string) *StorageDomainLeaseBuilder {
	if builder.err != nil {
		return builder
	}

	builder.storageDomainLease.SetHref(href)
	return builder
}

func (builder *StorageDomainLeaseBuilder) Build() (*StorageDomainLease, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.storageDomainLease, nil
}

func (builder *StorageDomainLeaseBuilder) MustBuild() *StorageDomainLease {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build StorageDomainLease instance, reason: %v", builder.err))
	}
	return builder.storageDomainLease
}

type SystemOptionBuilder struct {
	systemOption *SystemOption
	err          error
}

func NewSystemOptionBuilder() *SystemOptionBuilder {
	return &SystemOptionBuilder{systemOption: &SystemOption{}, err: nil}
}

func (builder *SystemOptionBuilder) Comment(attr string) *SystemOptionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.systemOption.SetComment(attr)
	return builder
}

func (builder *SystemOptionBuilder) Description(attr string) *SystemOptionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.systemOption.SetDescription(attr)
	return builder
}

func (builder *SystemOptionBuilder) Id(attr string) *SystemOptionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.systemOption.SetId(attr)
	return builder
}

func (builder *SystemOptionBuilder) Name(attr string) *SystemOptionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.systemOption.SetName(attr)
	return builder
}

func (builder *SystemOptionBuilder) Values(attr *SystemOptionValueSlice) *SystemOptionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.systemOption.SetValues(attr)
	return builder
}

func (builder *SystemOptionBuilder) ValuesOfAny(anys ...*SystemOptionValue) *SystemOptionBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.systemOption.values == nil {
		builder.systemOption.values = new(SystemOptionValueSlice)
	}
	builder.systemOption.values.slice = append(builder.systemOption.values.slice, anys...)
	return builder
}

func (builder *SystemOptionBuilder) ValuesBuilderOfAny(anyBuilders ...SystemOptionValueBuilder) *SystemOptionBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.ValuesOfAny(attr)
	}
	return builder
}

func (builder *SystemOptionBuilder) Href(href string) *SystemOptionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.systemOption.SetHref(href)
	return builder
}

func (builder *SystemOptionBuilder) Build() (*SystemOption, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.systemOption, nil
}

func (builder *SystemOptionBuilder) MustBuild() *SystemOption {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build SystemOption instance, reason: %v", builder.err))
	}
	return builder.systemOption
}

type SystemOptionValueBuilder struct {
	systemOptionValue *SystemOptionValue
	err               error
}

func NewSystemOptionValueBuilder() *SystemOptionValueBuilder {
	return &SystemOptionValueBuilder{systemOptionValue: &SystemOptionValue{}, err: nil}
}

func (builder *SystemOptionValueBuilder) Value(attr string) *SystemOptionValueBuilder {
	if builder.err != nil {
		return builder
	}

	builder.systemOptionValue.SetValue(attr)
	return builder
}

func (builder *SystemOptionValueBuilder) Version(attr string) *SystemOptionValueBuilder {
	if builder.err != nil {
		return builder
	}

	builder.systemOptionValue.SetVersion(attr)
	return builder
}

func (builder *SystemOptionValueBuilder) Href(href string) *SystemOptionValueBuilder {
	if builder.err != nil {
		return builder
	}

	builder.systemOptionValue.SetHref(href)
	return builder
}

func (builder *SystemOptionValueBuilder) Build() (*SystemOptionValue, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.systemOptionValue, nil
}

func (builder *SystemOptionValueBuilder) MustBuild() *SystemOptionValue {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build SystemOptionValue instance, reason: %v", builder.err))
	}
	return builder.systemOptionValue
}

type TagBuilder struct {
	tag *Tag
	err error
}

func NewTagBuilder() *TagBuilder {
	return &TagBuilder{tag: &Tag{}, err: nil}
}

func (builder *TagBuilder) Comment(attr string) *TagBuilder {
	if builder.err != nil {
		return builder
	}

	builder.tag.SetComment(attr)
	return builder
}

func (builder *TagBuilder) Description(attr string) *TagBuilder {
	if builder.err != nil {
		return builder
	}

	builder.tag.SetDescription(attr)
	return builder
}

func (builder *TagBuilder) Group(attr *Group) *TagBuilder {
	if builder.err != nil {
		return builder
	}

	builder.tag.SetGroup(attr)
	return builder
}

func (builder *TagBuilder) GroupBuilder(attrBuilder *GroupBuilder) *TagBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Group(attr)
}

func (builder *TagBuilder) Host(attr *Host) *TagBuilder {
	if builder.err != nil {
		return builder
	}

	builder.tag.SetHost(attr)
	return builder
}

func (builder *TagBuilder) HostBuilder(attrBuilder *HostBuilder) *TagBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Host(attr)
}

func (builder *TagBuilder) Id(attr string) *TagBuilder {
	if builder.err != nil {
		return builder
	}

	builder.tag.SetId(attr)
	return builder
}

func (builder *TagBuilder) Name(attr string) *TagBuilder {
	if builder.err != nil {
		return builder
	}

	builder.tag.SetName(attr)
	return builder
}

func (builder *TagBuilder) Parent(attr *Tag) *TagBuilder {
	if builder.err != nil {
		return builder
	}

	builder.tag.SetParent(attr)
	return builder
}

func (builder *TagBuilder) ParentBuilder(attrBuilder *TagBuilder) *TagBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Parent(attr)
}

func (builder *TagBuilder) Template(attr *Template) *TagBuilder {
	if builder.err != nil {
		return builder
	}

	builder.tag.SetTemplate(attr)
	return builder
}

func (builder *TagBuilder) TemplateBuilder(attrBuilder *TemplateBuilder) *TagBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Template(attr)
}

func (builder *TagBuilder) User(attr *User) *TagBuilder {
	if builder.err != nil {
		return builder
	}

	builder.tag.SetUser(attr)
	return builder
}

func (builder *TagBuilder) UserBuilder(attrBuilder *UserBuilder) *TagBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.User(attr)
}

func (builder *TagBuilder) Vm(attr *Vm) *TagBuilder {
	if builder.err != nil {
		return builder
	}

	builder.tag.SetVm(attr)
	return builder
}

func (builder *TagBuilder) VmBuilder(attrBuilder *VmBuilder) *TagBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Vm(attr)
}

func (builder *TagBuilder) Href(href string) *TagBuilder {
	if builder.err != nil {
		return builder
	}

	builder.tag.SetHref(href)
	return builder
}

func (builder *TagBuilder) Build() (*Tag, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.tag, nil
}

func (builder *TagBuilder) MustBuild() *Tag {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build Tag instance, reason: %v", builder.err))
	}
	return builder.tag
}

type TemplateBuilder struct {
	template *Template
	err      error
}

func NewTemplateBuilder() *TemplateBuilder {
	return &TemplateBuilder{template: &Template{}, err: nil}
}

func (builder *TemplateBuilder) Bios(attr *Bios) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	builder.template.SetBios(attr)
	return builder
}

func (builder *TemplateBuilder) BiosBuilder(attrBuilder *BiosBuilder) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Bios(attr)
}

func (builder *TemplateBuilder) Cdroms(attr *CdromSlice) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	builder.template.SetCdroms(attr)
	return builder
}

func (builder *TemplateBuilder) CdromsOfAny(anys ...*Cdrom) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.template.cdroms == nil {
		builder.template.cdroms = new(CdromSlice)
	}
	builder.template.cdroms.slice = append(builder.template.cdroms.slice, anys...)
	return builder
}

func (builder *TemplateBuilder) CdromsBuilderOfAny(anyBuilders ...CdromBuilder) *TemplateBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.CdromsOfAny(attr)
	}
	return builder
}

func (builder *TemplateBuilder) Cluster(attr *Cluster) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	builder.template.SetCluster(attr)
	return builder
}

func (builder *TemplateBuilder) ClusterBuilder(attrBuilder *ClusterBuilder) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Cluster(attr)
}

func (builder *TemplateBuilder) Comment(attr string) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	builder.template.SetComment(attr)
	return builder
}

func (builder *TemplateBuilder) Console(attr *Console) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	builder.template.SetConsole(attr)
	return builder
}

func (builder *TemplateBuilder) ConsoleBuilder(attrBuilder *ConsoleBuilder) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Console(attr)
}

func (builder *TemplateBuilder) Cpu(attr *Cpu) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	builder.template.SetCpu(attr)
	return builder
}

func (builder *TemplateBuilder) CpuBuilder(attrBuilder *CpuBuilder) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Cpu(attr)
}

func (builder *TemplateBuilder) CpuProfile(attr *CpuProfile) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	builder.template.SetCpuProfile(attr)
	return builder
}

func (builder *TemplateBuilder) CpuProfileBuilder(attrBuilder *CpuProfileBuilder) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.CpuProfile(attr)
}

func (builder *TemplateBuilder) CpuShares(attr int64) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	builder.template.SetCpuShares(attr)
	return builder
}

func (builder *TemplateBuilder) CreationTime(attr time.Time) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	builder.template.SetCreationTime(attr)
	return builder
}

func (builder *TemplateBuilder) CustomCompatibilityVersion(attr *Version) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	builder.template.SetCustomCompatibilityVersion(attr)
	return builder
}

func (builder *TemplateBuilder) CustomCompatibilityVersionBuilder(attrBuilder *VersionBuilder) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.CustomCompatibilityVersion(attr)
}

func (builder *TemplateBuilder) CustomCpuModel(attr string) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	builder.template.SetCustomCpuModel(attr)
	return builder
}

func (builder *TemplateBuilder) CustomEmulatedMachine(attr string) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	builder.template.SetCustomEmulatedMachine(attr)
	return builder
}

func (builder *TemplateBuilder) CustomProperties(attr *CustomPropertySlice) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	builder.template.SetCustomProperties(attr)
	return builder
}

func (builder *TemplateBuilder) CustomPropertiesOfAny(anys ...*CustomProperty) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.template.customProperties == nil {
		builder.template.customProperties = new(CustomPropertySlice)
	}
	builder.template.customProperties.slice = append(builder.template.customProperties.slice, anys...)
	return builder
}

func (builder *TemplateBuilder) CustomPropertiesBuilderOfAny(anyBuilders ...CustomPropertyBuilder) *TemplateBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.CustomPropertiesOfAny(attr)
	}
	return builder
}

func (builder *TemplateBuilder) DeleteProtected(attr bool) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	builder.template.SetDeleteProtected(attr)
	return builder
}

func (builder *TemplateBuilder) Description(attr string) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	builder.template.SetDescription(attr)
	return builder
}

func (builder *TemplateBuilder) DiskAttachments(attr *DiskAttachmentSlice) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	builder.template.SetDiskAttachments(attr)
	return builder
}

func (builder *TemplateBuilder) DiskAttachmentsOfAny(anys ...*DiskAttachment) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.template.diskAttachments == nil {
		builder.template.diskAttachments = new(DiskAttachmentSlice)
	}
	builder.template.diskAttachments.slice = append(builder.template.diskAttachments.slice, anys...)
	return builder
}

func (builder *TemplateBuilder) DiskAttachmentsBuilderOfAny(anyBuilders ...DiskAttachmentBuilder) *TemplateBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.DiskAttachmentsOfAny(attr)
	}
	return builder
}

func (builder *TemplateBuilder) Display(attr *Display) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	builder.template.SetDisplay(attr)
	return builder
}

func (builder *TemplateBuilder) DisplayBuilder(attrBuilder *DisplayBuilder) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Display(attr)
}

func (builder *TemplateBuilder) Domain(attr *Domain) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	builder.template.SetDomain(attr)
	return builder
}

func (builder *TemplateBuilder) DomainBuilder(attrBuilder *DomainBuilder) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Domain(attr)
}

func (builder *TemplateBuilder) GraphicsConsoles(attr *GraphicsConsoleSlice) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	builder.template.SetGraphicsConsoles(attr)
	return builder
}

func (builder *TemplateBuilder) GraphicsConsolesOfAny(anys ...*GraphicsConsole) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.template.graphicsConsoles == nil {
		builder.template.graphicsConsoles = new(GraphicsConsoleSlice)
	}
	builder.template.graphicsConsoles.slice = append(builder.template.graphicsConsoles.slice, anys...)
	return builder
}

func (builder *TemplateBuilder) GraphicsConsolesBuilderOfAny(anyBuilders ...GraphicsConsoleBuilder) *TemplateBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.GraphicsConsolesOfAny(attr)
	}
	return builder
}

func (builder *TemplateBuilder) HighAvailability(attr *HighAvailability) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	builder.template.SetHighAvailability(attr)
	return builder
}

func (builder *TemplateBuilder) HighAvailabilityBuilder(attrBuilder *HighAvailabilityBuilder) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.HighAvailability(attr)
}

func (builder *TemplateBuilder) Id(attr string) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	builder.template.SetId(attr)
	return builder
}

func (builder *TemplateBuilder) Initialization(attr *Initialization) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	builder.template.SetInitialization(attr)
	return builder
}

func (builder *TemplateBuilder) InitializationBuilder(attrBuilder *InitializationBuilder) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Initialization(attr)
}

func (builder *TemplateBuilder) Io(attr *Io) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	builder.template.SetIo(attr)
	return builder
}

func (builder *TemplateBuilder) IoBuilder(attrBuilder *IoBuilder) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Io(attr)
}

func (builder *TemplateBuilder) LargeIcon(attr *Icon) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	builder.template.SetLargeIcon(attr)
	return builder
}

func (builder *TemplateBuilder) LargeIconBuilder(attrBuilder *IconBuilder) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.LargeIcon(attr)
}

func (builder *TemplateBuilder) Lease(attr *StorageDomainLease) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	builder.template.SetLease(attr)
	return builder
}

func (builder *TemplateBuilder) LeaseBuilder(attrBuilder *StorageDomainLeaseBuilder) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Lease(attr)
}

func (builder *TemplateBuilder) Memory(attr int64) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	builder.template.SetMemory(attr)
	return builder
}

func (builder *TemplateBuilder) MemoryPolicy(attr *MemoryPolicy) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	builder.template.SetMemoryPolicy(attr)
	return builder
}

func (builder *TemplateBuilder) MemoryPolicyBuilder(attrBuilder *MemoryPolicyBuilder) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.MemoryPolicy(attr)
}

func (builder *TemplateBuilder) Migration(attr *MigrationOptions) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	builder.template.SetMigration(attr)
	return builder
}

func (builder *TemplateBuilder) MigrationBuilder(attrBuilder *MigrationOptionsBuilder) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Migration(attr)
}

func (builder *TemplateBuilder) MigrationDowntime(attr int64) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	builder.template.SetMigrationDowntime(attr)
	return builder
}

func (builder *TemplateBuilder) MultiQueuesEnabled(attr bool) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	builder.template.SetMultiQueuesEnabled(attr)
	return builder
}

func (builder *TemplateBuilder) Name(attr string) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	builder.template.SetName(attr)
	return builder
}

func (builder *TemplateBuilder) Nics(attr *NicSlice) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	builder.template.SetNics(attr)
	return builder
}

func (builder *TemplateBuilder) NicsOfAny(anys ...*Nic) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.template.nics == nil {
		builder.template.nics = new(NicSlice)
	}
	builder.template.nics.slice = append(builder.template.nics.slice, anys...)
	return builder
}

func (builder *TemplateBuilder) NicsBuilderOfAny(anyBuilders ...NicBuilder) *TemplateBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.NicsOfAny(attr)
	}
	return builder
}

func (builder *TemplateBuilder) Origin(attr string) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	builder.template.SetOrigin(attr)
	return builder
}

func (builder *TemplateBuilder) Os(attr *OperatingSystem) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	builder.template.SetOs(attr)
	return builder
}

func (builder *TemplateBuilder) OsBuilder(attrBuilder *OperatingSystemBuilder) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Os(attr)
}

func (builder *TemplateBuilder) Permissions(attr *PermissionSlice) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	builder.template.SetPermissions(attr)
	return builder
}

func (builder *TemplateBuilder) PermissionsOfAny(anys ...*Permission) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.template.permissions == nil {
		builder.template.permissions = new(PermissionSlice)
	}
	builder.template.permissions.slice = append(builder.template.permissions.slice, anys...)
	return builder
}

func (builder *TemplateBuilder) PermissionsBuilderOfAny(anyBuilders ...PermissionBuilder) *TemplateBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.PermissionsOfAny(attr)
	}
	return builder
}

func (builder *TemplateBuilder) PlacementPolicy(attr *VmPlacementPolicy) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	builder.template.SetPlacementPolicy(attr)
	return builder
}

func (builder *TemplateBuilder) PlacementPolicyBuilder(attrBuilder *VmPlacementPolicyBuilder) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.PlacementPolicy(attr)
}

func (builder *TemplateBuilder) Quota(attr *Quota) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	builder.template.SetQuota(attr)
	return builder
}

func (builder *TemplateBuilder) QuotaBuilder(attrBuilder *QuotaBuilder) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Quota(attr)
}

func (builder *TemplateBuilder) RngDevice(attr *RngDevice) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	builder.template.SetRngDevice(attr)
	return builder
}

func (builder *TemplateBuilder) RngDeviceBuilder(attrBuilder *RngDeviceBuilder) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.RngDevice(attr)
}

func (builder *TemplateBuilder) SerialNumber(attr *SerialNumber) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	builder.template.SetSerialNumber(attr)
	return builder
}

func (builder *TemplateBuilder) SerialNumberBuilder(attrBuilder *SerialNumberBuilder) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.SerialNumber(attr)
}

func (builder *TemplateBuilder) SmallIcon(attr *Icon) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	builder.template.SetSmallIcon(attr)
	return builder
}

func (builder *TemplateBuilder) SmallIconBuilder(attrBuilder *IconBuilder) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.SmallIcon(attr)
}

func (builder *TemplateBuilder) SoundcardEnabled(attr bool) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	builder.template.SetSoundcardEnabled(attr)
	return builder
}

func (builder *TemplateBuilder) Sso(attr *Sso) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	builder.template.SetSso(attr)
	return builder
}

func (builder *TemplateBuilder) SsoBuilder(attrBuilder *SsoBuilder) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Sso(attr)
}

func (builder *TemplateBuilder) StartPaused(attr bool) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	builder.template.SetStartPaused(attr)
	return builder
}

func (builder *TemplateBuilder) Stateless(attr bool) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	builder.template.SetStateless(attr)
	return builder
}

func (builder *TemplateBuilder) Status(attr TemplateStatus) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	builder.template.SetStatus(attr)
	return builder
}

func (builder *TemplateBuilder) StorageDomain(attr *StorageDomain) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	builder.template.SetStorageDomain(attr)
	return builder
}

func (builder *TemplateBuilder) StorageDomainBuilder(attrBuilder *StorageDomainBuilder) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.StorageDomain(attr)
}

func (builder *TemplateBuilder) StorageErrorResumeBehaviour(attr VmStorageErrorResumeBehaviour) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	builder.template.SetStorageErrorResumeBehaviour(attr)
	return builder
}

func (builder *TemplateBuilder) Tags(attr *TagSlice) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	builder.template.SetTags(attr)
	return builder
}

func (builder *TemplateBuilder) TagsOfAny(anys ...*Tag) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.template.tags == nil {
		builder.template.tags = new(TagSlice)
	}
	builder.template.tags.slice = append(builder.template.tags.slice, anys...)
	return builder
}

func (builder *TemplateBuilder) TagsBuilderOfAny(anyBuilders ...TagBuilder) *TemplateBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.TagsOfAny(attr)
	}
	return builder
}

func (builder *TemplateBuilder) TimeZone(attr *TimeZone) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	builder.template.SetTimeZone(attr)
	return builder
}

func (builder *TemplateBuilder) TimeZoneBuilder(attrBuilder *TimeZoneBuilder) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.TimeZone(attr)
}

func (builder *TemplateBuilder) TpmEnabled(attr bool) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	builder.template.SetTpmEnabled(attr)
	return builder
}

func (builder *TemplateBuilder) TunnelMigration(attr bool) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	builder.template.SetTunnelMigration(attr)
	return builder
}

func (builder *TemplateBuilder) Type(attr VmType) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	builder.template.SetType(attr)
	return builder
}

func (builder *TemplateBuilder) Usb(attr *Usb) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	builder.template.SetUsb(attr)
	return builder
}

func (builder *TemplateBuilder) UsbBuilder(attrBuilder *UsbBuilder) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Usb(attr)
}

func (builder *TemplateBuilder) Version(attr *TemplateVersion) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	builder.template.SetVersion(attr)
	return builder
}

func (builder *TemplateBuilder) VersionBuilder(attrBuilder *TemplateVersionBuilder) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Version(attr)
}

func (builder *TemplateBuilder) VirtioScsi(attr *VirtioScsi) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	builder.template.SetVirtioScsi(attr)
	return builder
}

func (builder *TemplateBuilder) VirtioScsiBuilder(attrBuilder *VirtioScsiBuilder) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.VirtioScsi(attr)
}

func (builder *TemplateBuilder) VirtioScsiMultiQueuesEnabled(attr bool) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	builder.template.SetVirtioScsiMultiQueuesEnabled(attr)
	return builder
}

func (builder *TemplateBuilder) Vm(attr *Vm) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	builder.template.SetVm(attr)
	return builder
}

func (builder *TemplateBuilder) VmBuilder(attrBuilder *VmBuilder) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Vm(attr)
}

func (builder *TemplateBuilder) Watchdogs(attr *WatchdogSlice) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	builder.template.SetWatchdogs(attr)
	return builder
}

func (builder *TemplateBuilder) WatchdogsOfAny(anys ...*Watchdog) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.template.watchdogs == nil {
		builder.template.watchdogs = new(WatchdogSlice)
	}
	builder.template.watchdogs.slice = append(builder.template.watchdogs.slice, anys...)
	return builder
}

func (builder *TemplateBuilder) WatchdogsBuilderOfAny(anyBuilders ...WatchdogBuilder) *TemplateBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.WatchdogsOfAny(attr)
	}
	return builder
}

func (builder *TemplateBuilder) Href(href string) *TemplateBuilder {
	if builder.err != nil {
		return builder
	}

	builder.template.SetHref(href)
	return builder
}

func (builder *TemplateBuilder) Build() (*Template, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.template, nil
}

func (builder *TemplateBuilder) MustBuild() *Template {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build Template instance, reason: %v", builder.err))
	}
	return builder.template
}

type TemplateVersionBuilder struct {
	templateVersion *TemplateVersion
	err             error
}

func NewTemplateVersionBuilder() *TemplateVersionBuilder {
	return &TemplateVersionBuilder{templateVersion: &TemplateVersion{}, err: nil}
}

func (builder *TemplateVersionBuilder) BaseTemplate(attr *Template) *TemplateVersionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.templateVersion.SetBaseTemplate(attr)
	return builder
}

func (builder *TemplateVersionBuilder) BaseTemplateBuilder(attrBuilder *TemplateBuilder) *TemplateVersionBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.BaseTemplate(attr)
}

func (builder *TemplateVersionBuilder) VersionName(attr string) *TemplateVersionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.templateVersion.SetVersionName(attr)
	return builder
}

func (builder *TemplateVersionBuilder) VersionNumber(attr int64) *TemplateVersionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.templateVersion.SetVersionNumber(attr)
	return builder
}

func (builder *TemplateVersionBuilder) Href(href string) *TemplateVersionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.templateVersion.SetHref(href)
	return builder
}

func (builder *TemplateVersionBuilder) Build() (*TemplateVersion, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.templateVersion, nil
}

func (builder *TemplateVersionBuilder) MustBuild() *TemplateVersion {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build TemplateVersion instance, reason: %v", builder.err))
	}
	return builder.templateVersion
}

type TicketBuilder struct {
	ticket *Ticket
	err    error
}

func NewTicketBuilder() *TicketBuilder {
	return &TicketBuilder{ticket: &Ticket{}, err: nil}
}

func (builder *TicketBuilder) Expiry(attr int64) *TicketBuilder {
	if builder.err != nil {
		return builder
	}

	builder.ticket.SetExpiry(attr)
	return builder
}

func (builder *TicketBuilder) Value(attr string) *TicketBuilder {
	if builder.err != nil {
		return builder
	}

	builder.ticket.SetValue(attr)
	return builder
}

func (builder *TicketBuilder) Href(href string) *TicketBuilder {
	if builder.err != nil {
		return builder
	}

	builder.ticket.SetHref(href)
	return builder
}

func (builder *TicketBuilder) Build() (*Ticket, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.ticket, nil
}

func (builder *TicketBuilder) MustBuild() *Ticket {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build Ticket instance, reason: %v", builder.err))
	}
	return builder.ticket
}

type TimeZoneBuilder struct {
	timeZone *TimeZone
	err      error
}

func NewTimeZoneBuilder() *TimeZoneBuilder {
	return &TimeZoneBuilder{timeZone: &TimeZone{}, err: nil}
}

func (builder *TimeZoneBuilder) Name(attr string) *TimeZoneBuilder {
	if builder.err != nil {
		return builder
	}

	builder.timeZone.SetName(attr)
	return builder
}

func (builder *TimeZoneBuilder) UtcOffset(attr string) *TimeZoneBuilder {
	if builder.err != nil {
		return builder
	}

	builder.timeZone.SetUtcOffset(attr)
	return builder
}

func (builder *TimeZoneBuilder) Href(href string) *TimeZoneBuilder {
	if builder.err != nil {
		return builder
	}

	builder.timeZone.SetHref(href)
	return builder
}

func (builder *TimeZoneBuilder) Build() (*TimeZone, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.timeZone, nil
}

func (builder *TimeZoneBuilder) MustBuild() *TimeZone {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build TimeZone instance, reason: %v", builder.err))
	}
	return builder.timeZone
}

type TransparentHugePagesBuilder struct {
	transparentHugePages *TransparentHugePages
	err                  error
}

func NewTransparentHugePagesBuilder() *TransparentHugePagesBuilder {
	return &TransparentHugePagesBuilder{transparentHugePages: &TransparentHugePages{}, err: nil}
}

func (builder *TransparentHugePagesBuilder) Enabled(attr bool) *TransparentHugePagesBuilder {
	if builder.err != nil {
		return builder
	}

	builder.transparentHugePages.SetEnabled(attr)
	return builder
}

func (builder *TransparentHugePagesBuilder) Href(href string) *TransparentHugePagesBuilder {
	if builder.err != nil {
		return builder
	}

	builder.transparentHugePages.SetHref(href)
	return builder
}

func (builder *TransparentHugePagesBuilder) Build() (*TransparentHugePages, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.transparentHugePages, nil
}

func (builder *TransparentHugePagesBuilder) MustBuild() *TransparentHugePages {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build TransparentHugePages instance, reason: %v", builder.err))
	}
	return builder.transparentHugePages
}

type UnmanagedNetworkBuilder struct {
	unmanagedNetwork *UnmanagedNetwork
	err              error
}

func NewUnmanagedNetworkBuilder() *UnmanagedNetworkBuilder {
	return &UnmanagedNetworkBuilder{unmanagedNetwork: &UnmanagedNetwork{}, err: nil}
}

func (builder *UnmanagedNetworkBuilder) Comment(attr string) *UnmanagedNetworkBuilder {
	if builder.err != nil {
		return builder
	}

	builder.unmanagedNetwork.SetComment(attr)
	return builder
}

func (builder *UnmanagedNetworkBuilder) Description(attr string) *UnmanagedNetworkBuilder {
	if builder.err != nil {
		return builder
	}

	builder.unmanagedNetwork.SetDescription(attr)
	return builder
}

func (builder *UnmanagedNetworkBuilder) Host(attr *Host) *UnmanagedNetworkBuilder {
	if builder.err != nil {
		return builder
	}

	builder.unmanagedNetwork.SetHost(attr)
	return builder
}

func (builder *UnmanagedNetworkBuilder) HostBuilder(attrBuilder *HostBuilder) *UnmanagedNetworkBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Host(attr)
}

func (builder *UnmanagedNetworkBuilder) HostNic(attr *HostNic) *UnmanagedNetworkBuilder {
	if builder.err != nil {
		return builder
	}

	builder.unmanagedNetwork.SetHostNic(attr)
	return builder
}

func (builder *UnmanagedNetworkBuilder) HostNicBuilder(attrBuilder *HostNicBuilder) *UnmanagedNetworkBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.HostNic(attr)
}

func (builder *UnmanagedNetworkBuilder) Id(attr string) *UnmanagedNetworkBuilder {
	if builder.err != nil {
		return builder
	}

	builder.unmanagedNetwork.SetId(attr)
	return builder
}

func (builder *UnmanagedNetworkBuilder) Name(attr string) *UnmanagedNetworkBuilder {
	if builder.err != nil {
		return builder
	}

	builder.unmanagedNetwork.SetName(attr)
	return builder
}

func (builder *UnmanagedNetworkBuilder) Href(href string) *UnmanagedNetworkBuilder {
	if builder.err != nil {
		return builder
	}

	builder.unmanagedNetwork.SetHref(href)
	return builder
}

func (builder *UnmanagedNetworkBuilder) Build() (*UnmanagedNetwork, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.unmanagedNetwork, nil
}

func (builder *UnmanagedNetworkBuilder) MustBuild() *UnmanagedNetwork {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build UnmanagedNetwork instance, reason: %v", builder.err))
	}
	return builder.unmanagedNetwork
}

type UsbBuilder struct {
	usb *Usb
	err error
}

func NewUsbBuilder() *UsbBuilder {
	return &UsbBuilder{usb: &Usb{}, err: nil}
}

func (builder *UsbBuilder) Enabled(attr bool) *UsbBuilder {
	if builder.err != nil {
		return builder
	}

	builder.usb.SetEnabled(attr)
	return builder
}

func (builder *UsbBuilder) Type(attr UsbType) *UsbBuilder {
	if builder.err != nil {
		return builder
	}

	builder.usb.SetType(attr)
	return builder
}

func (builder *UsbBuilder) Href(href string) *UsbBuilder {
	if builder.err != nil {
		return builder
	}

	builder.usb.SetHref(href)
	return builder
}

func (builder *UsbBuilder) Build() (*Usb, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.usb, nil
}

func (builder *UsbBuilder) MustBuild() *Usb {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build Usb instance, reason: %v", builder.err))
	}
	return builder.usb
}

type UserBuilder struct {
	user *User
	err  error
}

func NewUserBuilder() *UserBuilder {
	return &UserBuilder{user: &User{}, err: nil}
}

func (builder *UserBuilder) Comment(attr string) *UserBuilder {
	if builder.err != nil {
		return builder
	}

	builder.user.SetComment(attr)
	return builder
}

func (builder *UserBuilder) Department(attr string) *UserBuilder {
	if builder.err != nil {
		return builder
	}

	builder.user.SetDepartment(attr)
	return builder
}

func (builder *UserBuilder) Description(attr string) *UserBuilder {
	if builder.err != nil {
		return builder
	}

	builder.user.SetDescription(attr)
	return builder
}

func (builder *UserBuilder) Domain(attr *Domain) *UserBuilder {
	if builder.err != nil {
		return builder
	}

	builder.user.SetDomain(attr)
	return builder
}

func (builder *UserBuilder) DomainBuilder(attrBuilder *DomainBuilder) *UserBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Domain(attr)
}

func (builder *UserBuilder) DomainEntryId(attr string) *UserBuilder {
	if builder.err != nil {
		return builder
	}

	builder.user.SetDomainEntryId(attr)
	return builder
}

func (builder *UserBuilder) Email(attr string) *UserBuilder {
	if builder.err != nil {
		return builder
	}

	builder.user.SetEmail(attr)
	return builder
}

func (builder *UserBuilder) Groups(attr *GroupSlice) *UserBuilder {
	if builder.err != nil {
		return builder
	}

	builder.user.SetGroups(attr)
	return builder
}

func (builder *UserBuilder) GroupsOfAny(anys ...*Group) *UserBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.user.groups == nil {
		builder.user.groups = new(GroupSlice)
	}
	builder.user.groups.slice = append(builder.user.groups.slice, anys...)
	return builder
}

func (builder *UserBuilder) GroupsBuilderOfAny(anyBuilders ...GroupBuilder) *UserBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.GroupsOfAny(attr)
	}
	return builder
}

func (builder *UserBuilder) Id(attr string) *UserBuilder {
	if builder.err != nil {
		return builder
	}

	builder.user.SetId(attr)
	return builder
}

func (builder *UserBuilder) LastName(attr string) *UserBuilder {
	if builder.err != nil {
		return builder
	}

	builder.user.SetLastName(attr)
	return builder
}

func (builder *UserBuilder) LoggedIn(attr bool) *UserBuilder {
	if builder.err != nil {
		return builder
	}

	builder.user.SetLoggedIn(attr)
	return builder
}

func (builder *UserBuilder) Name(attr string) *UserBuilder {
	if builder.err != nil {
		return builder
	}

	builder.user.SetName(attr)
	return builder
}

func (builder *UserBuilder) Namespace(attr string) *UserBuilder {
	if builder.err != nil {
		return builder
	}

	builder.user.SetNamespace(attr)
	return builder
}

func (builder *UserBuilder) Options(attr *UserOptionSlice) *UserBuilder {
	if builder.err != nil {
		return builder
	}

	builder.user.SetOptions(attr)
	return builder
}

func (builder *UserBuilder) OptionsOfAny(anys ...*UserOption) *UserBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.user.options == nil {
		builder.user.options = new(UserOptionSlice)
	}
	builder.user.options.slice = append(builder.user.options.slice, anys...)
	return builder
}

func (builder *UserBuilder) OptionsBuilderOfAny(anyBuilders ...UserOptionBuilder) *UserBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.OptionsOfAny(attr)
	}
	return builder
}

func (builder *UserBuilder) Password(attr string) *UserBuilder {
	if builder.err != nil {
		return builder
	}

	builder.user.SetPassword(attr)
	return builder
}

func (builder *UserBuilder) Permissions(attr *PermissionSlice) *UserBuilder {
	if builder.err != nil {
		return builder
	}

	builder.user.SetPermissions(attr)
	return builder
}

func (builder *UserBuilder) PermissionsOfAny(anys ...*Permission) *UserBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.user.permissions == nil {
		builder.user.permissions = new(PermissionSlice)
	}
	builder.user.permissions.slice = append(builder.user.permissions.slice, anys...)
	return builder
}

func (builder *UserBuilder) PermissionsBuilderOfAny(anyBuilders ...PermissionBuilder) *UserBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.PermissionsOfAny(attr)
	}
	return builder
}

func (builder *UserBuilder) Principal(attr string) *UserBuilder {
	if builder.err != nil {
		return builder
	}

	builder.user.SetPrincipal(attr)
	return builder
}

func (builder *UserBuilder) Roles(attr *RoleSlice) *UserBuilder {
	if builder.err != nil {
		return builder
	}

	builder.user.SetRoles(attr)
	return builder
}

func (builder *UserBuilder) RolesOfAny(anys ...*Role) *UserBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.user.roles == nil {
		builder.user.roles = new(RoleSlice)
	}
	builder.user.roles.slice = append(builder.user.roles.slice, anys...)
	return builder
}

func (builder *UserBuilder) RolesBuilderOfAny(anyBuilders ...RoleBuilder) *UserBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.RolesOfAny(attr)
	}
	return builder
}

func (builder *UserBuilder) SshPublicKeys(attr *SshPublicKeySlice) *UserBuilder {
	if builder.err != nil {
		return builder
	}

	builder.user.SetSshPublicKeys(attr)
	return builder
}

func (builder *UserBuilder) SshPublicKeysOfAny(anys ...*SshPublicKey) *UserBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.user.sshPublicKeys == nil {
		builder.user.sshPublicKeys = new(SshPublicKeySlice)
	}
	builder.user.sshPublicKeys.slice = append(builder.user.sshPublicKeys.slice, anys...)
	return builder
}

func (builder *UserBuilder) SshPublicKeysBuilderOfAny(anyBuilders ...SshPublicKeyBuilder) *UserBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.SshPublicKeysOfAny(attr)
	}
	return builder
}

func (builder *UserBuilder) Tags(attr *TagSlice) *UserBuilder {
	if builder.err != nil {
		return builder
	}

	builder.user.SetTags(attr)
	return builder
}

func (builder *UserBuilder) TagsOfAny(anys ...*Tag) *UserBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.user.tags == nil {
		builder.user.tags = new(TagSlice)
	}
	builder.user.tags.slice = append(builder.user.tags.slice, anys...)
	return builder
}

func (builder *UserBuilder) TagsBuilderOfAny(anyBuilders ...TagBuilder) *UserBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.TagsOfAny(attr)
	}
	return builder
}

func (builder *UserBuilder) UserName(attr string) *UserBuilder {
	if builder.err != nil {
		return builder
	}

	builder.user.SetUserName(attr)
	return builder
}

func (builder *UserBuilder) UserOptions(attr *PropertySlice) *UserBuilder {
	if builder.err != nil {
		return builder
	}

	builder.user.SetUserOptions(attr)
	return builder
}

func (builder *UserBuilder) UserOptionsOfAny(anys ...*Property) *UserBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.user.userOptions == nil {
		builder.user.userOptions = new(PropertySlice)
	}
	builder.user.userOptions.slice = append(builder.user.userOptions.slice, anys...)
	return builder
}

func (builder *UserBuilder) UserOptionsBuilderOfAny(anyBuilders ...PropertyBuilder) *UserBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.UserOptionsOfAny(attr)
	}
	return builder
}

func (builder *UserBuilder) Href(href string) *UserBuilder {
	if builder.err != nil {
		return builder
	}

	builder.user.SetHref(href)
	return builder
}

func (builder *UserBuilder) Build() (*User, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.user, nil
}

func (builder *UserBuilder) MustBuild() *User {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build User instance, reason: %v", builder.err))
	}
	return builder.user
}

type UserOptionBuilder struct {
	userOption *UserOption
	err        error
}

func NewUserOptionBuilder() *UserOptionBuilder {
	return &UserOptionBuilder{userOption: &UserOption{}, err: nil}
}

func (builder *UserOptionBuilder) Comment(attr string) *UserOptionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.userOption.SetComment(attr)
	return builder
}

func (builder *UserOptionBuilder) Content(attr string) *UserOptionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.userOption.SetContent(attr)
	return builder
}

func (builder *UserOptionBuilder) Description(attr string) *UserOptionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.userOption.SetDescription(attr)
	return builder
}

func (builder *UserOptionBuilder) Id(attr string) *UserOptionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.userOption.SetId(attr)
	return builder
}

func (builder *UserOptionBuilder) Name(attr string) *UserOptionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.userOption.SetName(attr)
	return builder
}

func (builder *UserOptionBuilder) User(attr *User) *UserOptionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.userOption.SetUser(attr)
	return builder
}

func (builder *UserOptionBuilder) UserBuilder(attrBuilder *UserBuilder) *UserOptionBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.User(attr)
}

func (builder *UserOptionBuilder) Href(href string) *UserOptionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.userOption.SetHref(href)
	return builder
}

func (builder *UserOptionBuilder) Build() (*UserOption, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.userOption, nil
}

func (builder *UserOptionBuilder) MustBuild() *UserOption {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build UserOption instance, reason: %v", builder.err))
	}
	return builder.userOption
}

type ValueBuilder struct {
	value *Value
	err   error
}

func NewValueBuilder() *ValueBuilder {
	return &ValueBuilder{value: &Value{}, err: nil}
}

func (builder *ValueBuilder) Datum(attr float64) *ValueBuilder {
	if builder.err != nil {
		return builder
	}

	builder.value.SetDatum(attr)
	return builder
}

func (builder *ValueBuilder) Detail(attr string) *ValueBuilder {
	if builder.err != nil {
		return builder
	}

	builder.value.SetDetail(attr)
	return builder
}

func (builder *ValueBuilder) Href(href string) *ValueBuilder {
	if builder.err != nil {
		return builder
	}

	builder.value.SetHref(href)
	return builder
}

func (builder *ValueBuilder) Build() (*Value, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.value, nil
}

func (builder *ValueBuilder) MustBuild() *Value {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build Value instance, reason: %v", builder.err))
	}
	return builder.value
}

type VcpuPinBuilder struct {
	vcpuPin *VcpuPin
	err     error
}

func NewVcpuPinBuilder() *VcpuPinBuilder {
	return &VcpuPinBuilder{vcpuPin: &VcpuPin{}, err: nil}
}

func (builder *VcpuPinBuilder) CpuSet(attr string) *VcpuPinBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vcpuPin.SetCpuSet(attr)
	return builder
}

func (builder *VcpuPinBuilder) Vcpu(attr int64) *VcpuPinBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vcpuPin.SetVcpu(attr)
	return builder
}

func (builder *VcpuPinBuilder) Href(href string) *VcpuPinBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vcpuPin.SetHref(href)
	return builder
}

func (builder *VcpuPinBuilder) Build() (*VcpuPin, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.vcpuPin, nil
}

func (builder *VcpuPinBuilder) MustBuild() *VcpuPin {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build VcpuPin instance, reason: %v", builder.err))
	}
	return builder.vcpuPin
}

type VendorBuilder struct {
	vendor *Vendor
	err    error
}

func NewVendorBuilder() *VendorBuilder {
	return &VendorBuilder{vendor: &Vendor{}, err: nil}
}

func (builder *VendorBuilder) Comment(attr string) *VendorBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vendor.SetComment(attr)
	return builder
}

func (builder *VendorBuilder) Description(attr string) *VendorBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vendor.SetDescription(attr)
	return builder
}

func (builder *VendorBuilder) Id(attr string) *VendorBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vendor.SetId(attr)
	return builder
}

func (builder *VendorBuilder) Name(attr string) *VendorBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vendor.SetName(attr)
	return builder
}

func (builder *VendorBuilder) Href(href string) *VendorBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vendor.SetHref(href)
	return builder
}

func (builder *VendorBuilder) Build() (*Vendor, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.vendor, nil
}

func (builder *VendorBuilder) MustBuild() *Vendor {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build Vendor instance, reason: %v", builder.err))
	}
	return builder.vendor
}

type VersionBuilder struct {
	version *Version
	err     error
}

func NewVersionBuilder() *VersionBuilder {
	return &VersionBuilder{version: &Version{}, err: nil}
}

func (builder *VersionBuilder) Build_(attr int64) *VersionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.version.SetBuild(attr)
	return builder
}

func (builder *VersionBuilder) Comment(attr string) *VersionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.version.SetComment(attr)
	return builder
}

func (builder *VersionBuilder) Description(attr string) *VersionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.version.SetDescription(attr)
	return builder
}

func (builder *VersionBuilder) FullVersion(attr string) *VersionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.version.SetFullVersion(attr)
	return builder
}

func (builder *VersionBuilder) Id(attr string) *VersionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.version.SetId(attr)
	return builder
}

func (builder *VersionBuilder) Major(attr int64) *VersionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.version.SetMajor(attr)
	return builder
}

func (builder *VersionBuilder) Minor(attr int64) *VersionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.version.SetMinor(attr)
	return builder
}

func (builder *VersionBuilder) Name(attr string) *VersionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.version.SetName(attr)
	return builder
}

func (builder *VersionBuilder) Revision(attr int64) *VersionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.version.SetRevision(attr)
	return builder
}

func (builder *VersionBuilder) Href(href string) *VersionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.version.SetHref(href)
	return builder
}

func (builder *VersionBuilder) Build() (*Version, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.version, nil
}

func (builder *VersionBuilder) MustBuild() *Version {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build Version instance, reason: %v", builder.err))
	}
	return builder.version
}

type VirtioScsiBuilder struct {
	virtioScsi *VirtioScsi
	err        error
}

func NewVirtioScsiBuilder() *VirtioScsiBuilder {
	return &VirtioScsiBuilder{virtioScsi: &VirtioScsi{}, err: nil}
}

func (builder *VirtioScsiBuilder) Enabled(attr bool) *VirtioScsiBuilder {
	if builder.err != nil {
		return builder
	}

	builder.virtioScsi.SetEnabled(attr)
	return builder
}

func (builder *VirtioScsiBuilder) Href(href string) *VirtioScsiBuilder {
	if builder.err != nil {
		return builder
	}

	builder.virtioScsi.SetHref(href)
	return builder
}

func (builder *VirtioScsiBuilder) Build() (*VirtioScsi, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.virtioScsi, nil
}

func (builder *VirtioScsiBuilder) MustBuild() *VirtioScsi {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build VirtioScsi instance, reason: %v", builder.err))
	}
	return builder.virtioScsi
}

type VirtualNumaNodeBuilder struct {
	virtualNumaNode *VirtualNumaNode
	err             error
}

func NewVirtualNumaNodeBuilder() *VirtualNumaNodeBuilder {
	return &VirtualNumaNodeBuilder{virtualNumaNode: &VirtualNumaNode{}, err: nil}
}

func (builder *VirtualNumaNodeBuilder) Comment(attr string) *VirtualNumaNodeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.virtualNumaNode.SetComment(attr)
	return builder
}

func (builder *VirtualNumaNodeBuilder) Cpu(attr *Cpu) *VirtualNumaNodeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.virtualNumaNode.SetCpu(attr)
	return builder
}

func (builder *VirtualNumaNodeBuilder) CpuBuilder(attrBuilder *CpuBuilder) *VirtualNumaNodeBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Cpu(attr)
}

func (builder *VirtualNumaNodeBuilder) Description(attr string) *VirtualNumaNodeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.virtualNumaNode.SetDescription(attr)
	return builder
}

func (builder *VirtualNumaNodeBuilder) Host(attr *Host) *VirtualNumaNodeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.virtualNumaNode.SetHost(attr)
	return builder
}

func (builder *VirtualNumaNodeBuilder) HostBuilder(attrBuilder *HostBuilder) *VirtualNumaNodeBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Host(attr)
}

func (builder *VirtualNumaNodeBuilder) Id(attr string) *VirtualNumaNodeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.virtualNumaNode.SetId(attr)
	return builder
}

func (builder *VirtualNumaNodeBuilder) Index(attr int64) *VirtualNumaNodeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.virtualNumaNode.SetIndex(attr)
	return builder
}

func (builder *VirtualNumaNodeBuilder) Memory(attr int64) *VirtualNumaNodeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.virtualNumaNode.SetMemory(attr)
	return builder
}

func (builder *VirtualNumaNodeBuilder) Name(attr string) *VirtualNumaNodeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.virtualNumaNode.SetName(attr)
	return builder
}

func (builder *VirtualNumaNodeBuilder) NodeDistance(attr string) *VirtualNumaNodeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.virtualNumaNode.SetNodeDistance(attr)
	return builder
}

func (builder *VirtualNumaNodeBuilder) NumaNodePins(attr *NumaNodePinSlice) *VirtualNumaNodeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.virtualNumaNode.SetNumaNodePins(attr)
	return builder
}

func (builder *VirtualNumaNodeBuilder) NumaNodePinsOfAny(anys ...*NumaNodePin) *VirtualNumaNodeBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.virtualNumaNode.numaNodePins == nil {
		builder.virtualNumaNode.numaNodePins = new(NumaNodePinSlice)
	}
	builder.virtualNumaNode.numaNodePins.slice = append(builder.virtualNumaNode.numaNodePins.slice, anys...)
	return builder
}

func (builder *VirtualNumaNodeBuilder) NumaNodePinsBuilderOfAny(anyBuilders ...NumaNodePinBuilder) *VirtualNumaNodeBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.NumaNodePinsOfAny(attr)
	}
	return builder
}

func (builder *VirtualNumaNodeBuilder) NumaTuneMode(attr NumaTuneMode) *VirtualNumaNodeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.virtualNumaNode.SetNumaTuneMode(attr)
	return builder
}

func (builder *VirtualNumaNodeBuilder) Statistics(attr *StatisticSlice) *VirtualNumaNodeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.virtualNumaNode.SetStatistics(attr)
	return builder
}

func (builder *VirtualNumaNodeBuilder) StatisticsOfAny(anys ...*Statistic) *VirtualNumaNodeBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.virtualNumaNode.statistics == nil {
		builder.virtualNumaNode.statistics = new(StatisticSlice)
	}
	builder.virtualNumaNode.statistics.slice = append(builder.virtualNumaNode.statistics.slice, anys...)
	return builder
}

func (builder *VirtualNumaNodeBuilder) StatisticsBuilderOfAny(anyBuilders ...StatisticBuilder) *VirtualNumaNodeBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.StatisticsOfAny(attr)
	}
	return builder
}

func (builder *VirtualNumaNodeBuilder) Vm(attr *Vm) *VirtualNumaNodeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.virtualNumaNode.SetVm(attr)
	return builder
}

func (builder *VirtualNumaNodeBuilder) VmBuilder(attrBuilder *VmBuilder) *VirtualNumaNodeBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Vm(attr)
}

func (builder *VirtualNumaNodeBuilder) Href(href string) *VirtualNumaNodeBuilder {
	if builder.err != nil {
		return builder
	}

	builder.virtualNumaNode.SetHref(href)
	return builder
}

func (builder *VirtualNumaNodeBuilder) Build() (*VirtualNumaNode, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.virtualNumaNode, nil
}

func (builder *VirtualNumaNodeBuilder) MustBuild() *VirtualNumaNode {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build VirtualNumaNode instance, reason: %v", builder.err))
	}
	return builder.virtualNumaNode
}

type VlanBuilder struct {
	vlan *Vlan
	err  error
}

func NewVlanBuilder() *VlanBuilder {
	return &VlanBuilder{vlan: &Vlan{}, err: nil}
}

func (builder *VlanBuilder) Id(attr int64) *VlanBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vlan.SetId(attr)
	return builder
}

func (builder *VlanBuilder) Href(href string) *VlanBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vlan.SetHref(href)
	return builder
}

func (builder *VlanBuilder) Build() (*Vlan, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.vlan, nil
}

func (builder *VlanBuilder) MustBuild() *Vlan {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build Vlan instance, reason: %v", builder.err))
	}
	return builder.vlan
}

type VmBuilder struct {
	vm  *Vm
	err error
}

func NewVmBuilder() *VmBuilder {
	return &VmBuilder{vm: &Vm{}, err: nil}
}

func (builder *VmBuilder) AffinityLabels(attr *AffinityLabelSlice) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetAffinityLabels(attr)
	return builder
}

func (builder *VmBuilder) AffinityLabelsOfAny(anys ...*AffinityLabel) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.vm.affinityLabels == nil {
		builder.vm.affinityLabels = new(AffinityLabelSlice)
	}
	builder.vm.affinityLabels.slice = append(builder.vm.affinityLabels.slice, anys...)
	return builder
}

func (builder *VmBuilder) AffinityLabelsBuilderOfAny(anyBuilders ...AffinityLabelBuilder) *VmBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.AffinityLabelsOfAny(attr)
	}
	return builder
}

func (builder *VmBuilder) Applications(attr *ApplicationSlice) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetApplications(attr)
	return builder
}

func (builder *VmBuilder) ApplicationsOfAny(anys ...*Application) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.vm.applications == nil {
		builder.vm.applications = new(ApplicationSlice)
	}
	builder.vm.applications.slice = append(builder.vm.applications.slice, anys...)
	return builder
}

func (builder *VmBuilder) ApplicationsBuilderOfAny(anyBuilders ...ApplicationBuilder) *VmBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.ApplicationsOfAny(attr)
	}
	return builder
}

func (builder *VmBuilder) Bios(attr *Bios) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetBios(attr)
	return builder
}

func (builder *VmBuilder) BiosBuilder(attrBuilder *BiosBuilder) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Bios(attr)
}

func (builder *VmBuilder) Cdroms(attr *CdromSlice) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetCdroms(attr)
	return builder
}

func (builder *VmBuilder) CdromsOfAny(anys ...*Cdrom) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.vm.cdroms == nil {
		builder.vm.cdroms = new(CdromSlice)
	}
	builder.vm.cdroms.slice = append(builder.vm.cdroms.slice, anys...)
	return builder
}

func (builder *VmBuilder) CdromsBuilderOfAny(anyBuilders ...CdromBuilder) *VmBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.CdromsOfAny(attr)
	}
	return builder
}

func (builder *VmBuilder) Cluster(attr *Cluster) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetCluster(attr)
	return builder
}

func (builder *VmBuilder) ClusterBuilder(attrBuilder *ClusterBuilder) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Cluster(attr)
}

func (builder *VmBuilder) Comment(attr string) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetComment(attr)
	return builder
}

func (builder *VmBuilder) Console(attr *Console) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetConsole(attr)
	return builder
}

func (builder *VmBuilder) ConsoleBuilder(attrBuilder *ConsoleBuilder) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Console(attr)
}

func (builder *VmBuilder) Cpu(attr *Cpu) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetCpu(attr)
	return builder
}

func (builder *VmBuilder) CpuBuilder(attrBuilder *CpuBuilder) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Cpu(attr)
}

func (builder *VmBuilder) CpuProfile(attr *CpuProfile) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetCpuProfile(attr)
	return builder
}

func (builder *VmBuilder) CpuProfileBuilder(attrBuilder *CpuProfileBuilder) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.CpuProfile(attr)
}

func (builder *VmBuilder) CpuShares(attr int64) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetCpuShares(attr)
	return builder
}

func (builder *VmBuilder) CreationTime(attr time.Time) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetCreationTime(attr)
	return builder
}

func (builder *VmBuilder) CustomCompatibilityVersion(attr *Version) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetCustomCompatibilityVersion(attr)
	return builder
}

func (builder *VmBuilder) CustomCompatibilityVersionBuilder(attrBuilder *VersionBuilder) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.CustomCompatibilityVersion(attr)
}

func (builder *VmBuilder) CustomCpuModel(attr string) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetCustomCpuModel(attr)
	return builder
}

func (builder *VmBuilder) CustomEmulatedMachine(attr string) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetCustomEmulatedMachine(attr)
	return builder
}

func (builder *VmBuilder) CustomProperties(attr *CustomPropertySlice) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetCustomProperties(attr)
	return builder
}

func (builder *VmBuilder) CustomPropertiesOfAny(anys ...*CustomProperty) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.vm.customProperties == nil {
		builder.vm.customProperties = new(CustomPropertySlice)
	}
	builder.vm.customProperties.slice = append(builder.vm.customProperties.slice, anys...)
	return builder
}

func (builder *VmBuilder) CustomPropertiesBuilderOfAny(anyBuilders ...CustomPropertyBuilder) *VmBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.CustomPropertiesOfAny(attr)
	}
	return builder
}

func (builder *VmBuilder) DeleteProtected(attr bool) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetDeleteProtected(attr)
	return builder
}

func (builder *VmBuilder) Description(attr string) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetDescription(attr)
	return builder
}

func (builder *VmBuilder) DiskAttachments(attr *DiskAttachmentSlice) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetDiskAttachments(attr)
	return builder
}

func (builder *VmBuilder) DiskAttachmentsOfAny(anys ...*DiskAttachment) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.vm.diskAttachments == nil {
		builder.vm.diskAttachments = new(DiskAttachmentSlice)
	}
	builder.vm.diskAttachments.slice = append(builder.vm.diskAttachments.slice, anys...)
	return builder
}

func (builder *VmBuilder) DiskAttachmentsBuilderOfAny(anyBuilders ...DiskAttachmentBuilder) *VmBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.DiskAttachmentsOfAny(attr)
	}
	return builder
}

func (builder *VmBuilder) Display(attr *Display) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetDisplay(attr)
	return builder
}

func (builder *VmBuilder) DisplayBuilder(attrBuilder *DisplayBuilder) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Display(attr)
}

func (builder *VmBuilder) Domain(attr *Domain) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetDomain(attr)
	return builder
}

func (builder *VmBuilder) DomainBuilder(attrBuilder *DomainBuilder) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Domain(attr)
}

func (builder *VmBuilder) ExternalHostProvider(attr *ExternalHostProvider) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetExternalHostProvider(attr)
	return builder
}

func (builder *VmBuilder) ExternalHostProviderBuilder(attrBuilder *ExternalHostProviderBuilder) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.ExternalHostProvider(attr)
}

func (builder *VmBuilder) Floppies(attr *FloppySlice) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetFloppies(attr)
	return builder
}

func (builder *VmBuilder) FloppiesOfAny(anys ...*Floppy) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.vm.floppies == nil {
		builder.vm.floppies = new(FloppySlice)
	}
	builder.vm.floppies.slice = append(builder.vm.floppies.slice, anys...)
	return builder
}

func (builder *VmBuilder) FloppiesBuilderOfAny(anyBuilders ...FloppyBuilder) *VmBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.FloppiesOfAny(attr)
	}
	return builder
}

func (builder *VmBuilder) Fqdn(attr string) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetFqdn(attr)
	return builder
}

func (builder *VmBuilder) GraphicsConsoles(attr *GraphicsConsoleSlice) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetGraphicsConsoles(attr)
	return builder
}

func (builder *VmBuilder) GraphicsConsolesOfAny(anys ...*GraphicsConsole) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.vm.graphicsConsoles == nil {
		builder.vm.graphicsConsoles = new(GraphicsConsoleSlice)
	}
	builder.vm.graphicsConsoles.slice = append(builder.vm.graphicsConsoles.slice, anys...)
	return builder
}

func (builder *VmBuilder) GraphicsConsolesBuilderOfAny(anyBuilders ...GraphicsConsoleBuilder) *VmBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.GraphicsConsolesOfAny(attr)
	}
	return builder
}

func (builder *VmBuilder) GuestOperatingSystem(attr *GuestOperatingSystem) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetGuestOperatingSystem(attr)
	return builder
}

func (builder *VmBuilder) GuestOperatingSystemBuilder(attrBuilder *GuestOperatingSystemBuilder) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.GuestOperatingSystem(attr)
}

func (builder *VmBuilder) GuestTimeZone(attr *TimeZone) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetGuestTimeZone(attr)
	return builder
}

func (builder *VmBuilder) GuestTimeZoneBuilder(attrBuilder *TimeZoneBuilder) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.GuestTimeZone(attr)
}

func (builder *VmBuilder) HasIllegalImages(attr bool) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetHasIllegalImages(attr)
	return builder
}

func (builder *VmBuilder) HighAvailability(attr *HighAvailability) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetHighAvailability(attr)
	return builder
}

func (builder *VmBuilder) HighAvailabilityBuilder(attrBuilder *HighAvailabilityBuilder) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.HighAvailability(attr)
}

func (builder *VmBuilder) Host(attr *Host) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetHost(attr)
	return builder
}

func (builder *VmBuilder) HostBuilder(attrBuilder *HostBuilder) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Host(attr)
}

func (builder *VmBuilder) HostDevices(attr *HostDeviceSlice) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetHostDevices(attr)
	return builder
}

func (builder *VmBuilder) HostDevicesOfAny(anys ...*HostDevice) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.vm.hostDevices == nil {
		builder.vm.hostDevices = new(HostDeviceSlice)
	}
	builder.vm.hostDevices.slice = append(builder.vm.hostDevices.slice, anys...)
	return builder
}

func (builder *VmBuilder) HostDevicesBuilderOfAny(anyBuilders ...HostDeviceBuilder) *VmBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.HostDevicesOfAny(attr)
	}
	return builder
}

func (builder *VmBuilder) Id(attr string) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetId(attr)
	return builder
}

func (builder *VmBuilder) Initialization(attr *Initialization) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetInitialization(attr)
	return builder
}

func (builder *VmBuilder) InitializationBuilder(attrBuilder *InitializationBuilder) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Initialization(attr)
}

func (builder *VmBuilder) InstanceType(attr *InstanceType) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetInstanceType(attr)
	return builder
}

func (builder *VmBuilder) InstanceTypeBuilder(attrBuilder *InstanceTypeBuilder) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.InstanceType(attr)
}

func (builder *VmBuilder) Io(attr *Io) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetIo(attr)
	return builder
}

func (builder *VmBuilder) IoBuilder(attrBuilder *IoBuilder) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Io(attr)
}

func (builder *VmBuilder) KatelloErrata(attr *KatelloErratumSlice) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetKatelloErrata(attr)
	return builder
}

func (builder *VmBuilder) KatelloErrataOfAny(anys ...*KatelloErratum) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.vm.katelloErrata == nil {
		builder.vm.katelloErrata = new(KatelloErratumSlice)
	}
	builder.vm.katelloErrata.slice = append(builder.vm.katelloErrata.slice, anys...)
	return builder
}

func (builder *VmBuilder) KatelloErrataBuilderOfAny(anyBuilders ...KatelloErratumBuilder) *VmBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.KatelloErrataOfAny(attr)
	}
	return builder
}

func (builder *VmBuilder) LargeIcon(attr *Icon) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetLargeIcon(attr)
	return builder
}

func (builder *VmBuilder) LargeIconBuilder(attrBuilder *IconBuilder) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.LargeIcon(attr)
}

func (builder *VmBuilder) Lease(attr *StorageDomainLease) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetLease(attr)
	return builder
}

func (builder *VmBuilder) LeaseBuilder(attrBuilder *StorageDomainLeaseBuilder) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Lease(attr)
}

func (builder *VmBuilder) Memory(attr int64) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetMemory(attr)
	return builder
}

func (builder *VmBuilder) MemoryPolicy(attr *MemoryPolicy) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetMemoryPolicy(attr)
	return builder
}

func (builder *VmBuilder) MemoryPolicyBuilder(attrBuilder *MemoryPolicyBuilder) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.MemoryPolicy(attr)
}

func (builder *VmBuilder) Migration(attr *MigrationOptions) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetMigration(attr)
	return builder
}

func (builder *VmBuilder) MigrationBuilder(attrBuilder *MigrationOptionsBuilder) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Migration(attr)
}

func (builder *VmBuilder) MigrationDowntime(attr int64) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetMigrationDowntime(attr)
	return builder
}

func (builder *VmBuilder) MultiQueuesEnabled(attr bool) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetMultiQueuesEnabled(attr)
	return builder
}

func (builder *VmBuilder) Name(attr string) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetName(attr)
	return builder
}

func (builder *VmBuilder) NextRunConfigurationExists(attr bool) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetNextRunConfigurationExists(attr)
	return builder
}

func (builder *VmBuilder) Nics(attr *NicSlice) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetNics(attr)
	return builder
}

func (builder *VmBuilder) NicsOfAny(anys ...*Nic) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.vm.nics == nil {
		builder.vm.nics = new(NicSlice)
	}
	builder.vm.nics.slice = append(builder.vm.nics.slice, anys...)
	return builder
}

func (builder *VmBuilder) NicsBuilderOfAny(anyBuilders ...NicBuilder) *VmBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.NicsOfAny(attr)
	}
	return builder
}

func (builder *VmBuilder) NumaNodes(attr *NumaNodeSlice) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetNumaNodes(attr)
	return builder
}

func (builder *VmBuilder) NumaNodesOfAny(anys ...*NumaNode) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.vm.numaNodes == nil {
		builder.vm.numaNodes = new(NumaNodeSlice)
	}
	builder.vm.numaNodes.slice = append(builder.vm.numaNodes.slice, anys...)
	return builder
}

func (builder *VmBuilder) NumaNodesBuilderOfAny(anyBuilders ...NumaNodeBuilder) *VmBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.NumaNodesOfAny(attr)
	}
	return builder
}

func (builder *VmBuilder) NumaTuneMode(attr NumaTuneMode) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetNumaTuneMode(attr)
	return builder
}

func (builder *VmBuilder) Origin(attr string) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetOrigin(attr)
	return builder
}

func (builder *VmBuilder) OriginalTemplate(attr *Template) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetOriginalTemplate(attr)
	return builder
}

func (builder *VmBuilder) OriginalTemplateBuilder(attrBuilder *TemplateBuilder) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.OriginalTemplate(attr)
}

func (builder *VmBuilder) Os(attr *OperatingSystem) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetOs(attr)
	return builder
}

func (builder *VmBuilder) OsBuilder(attrBuilder *OperatingSystemBuilder) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Os(attr)
}

func (builder *VmBuilder) Payloads(attr *PayloadSlice) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetPayloads(attr)
	return builder
}

func (builder *VmBuilder) PayloadsOfAny(anys ...*Payload) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.vm.payloads == nil {
		builder.vm.payloads = new(PayloadSlice)
	}
	builder.vm.payloads.slice = append(builder.vm.payloads.slice, anys...)
	return builder
}

func (builder *VmBuilder) PayloadsBuilderOfAny(anyBuilders ...PayloadBuilder) *VmBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.PayloadsOfAny(attr)
	}
	return builder
}

func (builder *VmBuilder) Permissions(attr *PermissionSlice) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetPermissions(attr)
	return builder
}

func (builder *VmBuilder) PermissionsOfAny(anys ...*Permission) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.vm.permissions == nil {
		builder.vm.permissions = new(PermissionSlice)
	}
	builder.vm.permissions.slice = append(builder.vm.permissions.slice, anys...)
	return builder
}

func (builder *VmBuilder) PermissionsBuilderOfAny(anyBuilders ...PermissionBuilder) *VmBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.PermissionsOfAny(attr)
	}
	return builder
}

func (builder *VmBuilder) PlacementPolicy(attr *VmPlacementPolicy) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetPlacementPolicy(attr)
	return builder
}

func (builder *VmBuilder) PlacementPolicyBuilder(attrBuilder *VmPlacementPolicyBuilder) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.PlacementPolicy(attr)
}

func (builder *VmBuilder) Quota(attr *Quota) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetQuota(attr)
	return builder
}

func (builder *VmBuilder) QuotaBuilder(attrBuilder *QuotaBuilder) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Quota(attr)
}

func (builder *VmBuilder) ReportedDevices(attr *ReportedDeviceSlice) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetReportedDevices(attr)
	return builder
}

func (builder *VmBuilder) ReportedDevicesOfAny(anys ...*ReportedDevice) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.vm.reportedDevices == nil {
		builder.vm.reportedDevices = new(ReportedDeviceSlice)
	}
	builder.vm.reportedDevices.slice = append(builder.vm.reportedDevices.slice, anys...)
	return builder
}

func (builder *VmBuilder) ReportedDevicesBuilderOfAny(anyBuilders ...ReportedDeviceBuilder) *VmBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.ReportedDevicesOfAny(attr)
	}
	return builder
}

func (builder *VmBuilder) RngDevice(attr *RngDevice) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetRngDevice(attr)
	return builder
}

func (builder *VmBuilder) RngDeviceBuilder(attrBuilder *RngDeviceBuilder) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.RngDevice(attr)
}

func (builder *VmBuilder) RunOnce(attr bool) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetRunOnce(attr)
	return builder
}

func (builder *VmBuilder) SerialNumber(attr *SerialNumber) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetSerialNumber(attr)
	return builder
}

func (builder *VmBuilder) SerialNumberBuilder(attrBuilder *SerialNumberBuilder) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.SerialNumber(attr)
}

func (builder *VmBuilder) Sessions(attr *SessionSlice) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetSessions(attr)
	return builder
}

func (builder *VmBuilder) SessionsOfAny(anys ...*Session) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.vm.sessions == nil {
		builder.vm.sessions = new(SessionSlice)
	}
	builder.vm.sessions.slice = append(builder.vm.sessions.slice, anys...)
	return builder
}

func (builder *VmBuilder) SessionsBuilderOfAny(anyBuilders ...SessionBuilder) *VmBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.SessionsOfAny(attr)
	}
	return builder
}

func (builder *VmBuilder) SmallIcon(attr *Icon) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetSmallIcon(attr)
	return builder
}

func (builder *VmBuilder) SmallIconBuilder(attrBuilder *IconBuilder) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.SmallIcon(attr)
}

func (builder *VmBuilder) Snapshots(attr *SnapshotSlice) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetSnapshots(attr)
	return builder
}

func (builder *VmBuilder) SnapshotsOfAny(anys ...*Snapshot) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.vm.snapshots == nil {
		builder.vm.snapshots = new(SnapshotSlice)
	}
	builder.vm.snapshots.slice = append(builder.vm.snapshots.slice, anys...)
	return builder
}

func (builder *VmBuilder) SnapshotsBuilderOfAny(anyBuilders ...SnapshotBuilder) *VmBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.SnapshotsOfAny(attr)
	}
	return builder
}

func (builder *VmBuilder) SoundcardEnabled(attr bool) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetSoundcardEnabled(attr)
	return builder
}

func (builder *VmBuilder) Sso(attr *Sso) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetSso(attr)
	return builder
}

func (builder *VmBuilder) SsoBuilder(attrBuilder *SsoBuilder) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Sso(attr)
}

func (builder *VmBuilder) StartPaused(attr bool) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetStartPaused(attr)
	return builder
}

func (builder *VmBuilder) StartTime(attr time.Time) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetStartTime(attr)
	return builder
}

func (builder *VmBuilder) Stateless(attr bool) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetStateless(attr)
	return builder
}

func (builder *VmBuilder) Statistics(attr *StatisticSlice) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetStatistics(attr)
	return builder
}

func (builder *VmBuilder) StatisticsOfAny(anys ...*Statistic) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.vm.statistics == nil {
		builder.vm.statistics = new(StatisticSlice)
	}
	builder.vm.statistics.slice = append(builder.vm.statistics.slice, anys...)
	return builder
}

func (builder *VmBuilder) StatisticsBuilderOfAny(anyBuilders ...StatisticBuilder) *VmBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.StatisticsOfAny(attr)
	}
	return builder
}

func (builder *VmBuilder) Status(attr VmStatus) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetStatus(attr)
	return builder
}

func (builder *VmBuilder) StatusDetail(attr string) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetStatusDetail(attr)
	return builder
}

func (builder *VmBuilder) StopReason(attr string) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetStopReason(attr)
	return builder
}

func (builder *VmBuilder) StopTime(attr time.Time) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetStopTime(attr)
	return builder
}

func (builder *VmBuilder) StorageDomain(attr *StorageDomain) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetStorageDomain(attr)
	return builder
}

func (builder *VmBuilder) StorageDomainBuilder(attrBuilder *StorageDomainBuilder) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.StorageDomain(attr)
}

func (builder *VmBuilder) StorageErrorResumeBehaviour(attr VmStorageErrorResumeBehaviour) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetStorageErrorResumeBehaviour(attr)
	return builder
}

func (builder *VmBuilder) Tags(attr *TagSlice) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetTags(attr)
	return builder
}

func (builder *VmBuilder) TagsOfAny(anys ...*Tag) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.vm.tags == nil {
		builder.vm.tags = new(TagSlice)
	}
	builder.vm.tags.slice = append(builder.vm.tags.slice, anys...)
	return builder
}

func (builder *VmBuilder) TagsBuilderOfAny(anyBuilders ...TagBuilder) *VmBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.TagsOfAny(attr)
	}
	return builder
}

func (builder *VmBuilder) Template(attr *Template) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetTemplate(attr)
	return builder
}

func (builder *VmBuilder) TemplateBuilder(attrBuilder *TemplateBuilder) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Template(attr)
}

func (builder *VmBuilder) TimeZone(attr *TimeZone) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetTimeZone(attr)
	return builder
}

func (builder *VmBuilder) TimeZoneBuilder(attrBuilder *TimeZoneBuilder) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.TimeZone(attr)
}

func (builder *VmBuilder) TpmEnabled(attr bool) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetTpmEnabled(attr)
	return builder
}

func (builder *VmBuilder) TunnelMigration(attr bool) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetTunnelMigration(attr)
	return builder
}

func (builder *VmBuilder) Type(attr VmType) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetType(attr)
	return builder
}

func (builder *VmBuilder) Usb(attr *Usb) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetUsb(attr)
	return builder
}

func (builder *VmBuilder) UsbBuilder(attrBuilder *UsbBuilder) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Usb(attr)
}

func (builder *VmBuilder) UseLatestTemplateVersion(attr bool) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetUseLatestTemplateVersion(attr)
	return builder
}

func (builder *VmBuilder) VirtioScsi(attr *VirtioScsi) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetVirtioScsi(attr)
	return builder
}

func (builder *VmBuilder) VirtioScsiBuilder(attrBuilder *VirtioScsiBuilder) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.VirtioScsi(attr)
}

func (builder *VmBuilder) VirtioScsiMultiQueuesEnabled(attr bool) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetVirtioScsiMultiQueuesEnabled(attr)
	return builder
}

func (builder *VmBuilder) VmPool(attr *VmPool) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetVmPool(attr)
	return builder
}

func (builder *VmBuilder) VmPoolBuilder(attrBuilder *VmPoolBuilder) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.VmPool(attr)
}

func (builder *VmBuilder) Watchdogs(attr *WatchdogSlice) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetWatchdogs(attr)
	return builder
}

func (builder *VmBuilder) WatchdogsOfAny(anys ...*Watchdog) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.vm.watchdogs == nil {
		builder.vm.watchdogs = new(WatchdogSlice)
	}
	builder.vm.watchdogs.slice = append(builder.vm.watchdogs.slice, anys...)
	return builder
}

func (builder *VmBuilder) WatchdogsBuilderOfAny(anyBuilders ...WatchdogBuilder) *VmBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.WatchdogsOfAny(attr)
	}
	return builder
}

func (builder *VmBuilder) Href(href string) *VmBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vm.SetHref(href)
	return builder
}

func (builder *VmBuilder) Build() (*Vm, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.vm, nil
}

func (builder *VmBuilder) MustBuild() *Vm {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build Vm instance, reason: %v", builder.err))
	}
	return builder.vm
}

type VmBaseBuilder struct {
	vmBase *VmBase
	err    error
}

func NewVmBaseBuilder() *VmBaseBuilder {
	return &VmBaseBuilder{vmBase: &VmBase{}, err: nil}
}

func (builder *VmBaseBuilder) Bios(attr *Bios) *VmBaseBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vmBase.SetBios(attr)
	return builder
}

func (builder *VmBaseBuilder) BiosBuilder(attrBuilder *BiosBuilder) *VmBaseBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Bios(attr)
}

func (builder *VmBaseBuilder) Cluster(attr *Cluster) *VmBaseBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vmBase.SetCluster(attr)
	return builder
}

func (builder *VmBaseBuilder) ClusterBuilder(attrBuilder *ClusterBuilder) *VmBaseBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Cluster(attr)
}

func (builder *VmBaseBuilder) Comment(attr string) *VmBaseBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vmBase.SetComment(attr)
	return builder
}

func (builder *VmBaseBuilder) Console(attr *Console) *VmBaseBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vmBase.SetConsole(attr)
	return builder
}

func (builder *VmBaseBuilder) ConsoleBuilder(attrBuilder *ConsoleBuilder) *VmBaseBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Console(attr)
}

func (builder *VmBaseBuilder) Cpu(attr *Cpu) *VmBaseBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vmBase.SetCpu(attr)
	return builder
}

func (builder *VmBaseBuilder) CpuBuilder(attrBuilder *CpuBuilder) *VmBaseBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Cpu(attr)
}

func (builder *VmBaseBuilder) CpuProfile(attr *CpuProfile) *VmBaseBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vmBase.SetCpuProfile(attr)
	return builder
}

func (builder *VmBaseBuilder) CpuProfileBuilder(attrBuilder *CpuProfileBuilder) *VmBaseBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.CpuProfile(attr)
}

func (builder *VmBaseBuilder) CpuShares(attr int64) *VmBaseBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vmBase.SetCpuShares(attr)
	return builder
}

func (builder *VmBaseBuilder) CreationTime(attr time.Time) *VmBaseBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vmBase.SetCreationTime(attr)
	return builder
}

func (builder *VmBaseBuilder) CustomCompatibilityVersion(attr *Version) *VmBaseBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vmBase.SetCustomCompatibilityVersion(attr)
	return builder
}

func (builder *VmBaseBuilder) CustomCompatibilityVersionBuilder(attrBuilder *VersionBuilder) *VmBaseBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.CustomCompatibilityVersion(attr)
}

func (builder *VmBaseBuilder) CustomCpuModel(attr string) *VmBaseBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vmBase.SetCustomCpuModel(attr)
	return builder
}

func (builder *VmBaseBuilder) CustomEmulatedMachine(attr string) *VmBaseBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vmBase.SetCustomEmulatedMachine(attr)
	return builder
}

func (builder *VmBaseBuilder) CustomProperties(attr *CustomPropertySlice) *VmBaseBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vmBase.SetCustomProperties(attr)
	return builder
}

func (builder *VmBaseBuilder) CustomPropertiesOfAny(anys ...*CustomProperty) *VmBaseBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.vmBase.customProperties == nil {
		builder.vmBase.customProperties = new(CustomPropertySlice)
	}
	builder.vmBase.customProperties.slice = append(builder.vmBase.customProperties.slice, anys...)
	return builder
}

func (builder *VmBaseBuilder) CustomPropertiesBuilderOfAny(anyBuilders ...CustomPropertyBuilder) *VmBaseBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.CustomPropertiesOfAny(attr)
	}
	return builder
}

func (builder *VmBaseBuilder) DeleteProtected(attr bool) *VmBaseBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vmBase.SetDeleteProtected(attr)
	return builder
}

func (builder *VmBaseBuilder) Description(attr string) *VmBaseBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vmBase.SetDescription(attr)
	return builder
}

func (builder *VmBaseBuilder) Display(attr *Display) *VmBaseBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vmBase.SetDisplay(attr)
	return builder
}

func (builder *VmBaseBuilder) DisplayBuilder(attrBuilder *DisplayBuilder) *VmBaseBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Display(attr)
}

func (builder *VmBaseBuilder) Domain(attr *Domain) *VmBaseBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vmBase.SetDomain(attr)
	return builder
}

func (builder *VmBaseBuilder) DomainBuilder(attrBuilder *DomainBuilder) *VmBaseBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Domain(attr)
}

func (builder *VmBaseBuilder) HighAvailability(attr *HighAvailability) *VmBaseBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vmBase.SetHighAvailability(attr)
	return builder
}

func (builder *VmBaseBuilder) HighAvailabilityBuilder(attrBuilder *HighAvailabilityBuilder) *VmBaseBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.HighAvailability(attr)
}

func (builder *VmBaseBuilder) Id(attr string) *VmBaseBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vmBase.SetId(attr)
	return builder
}

func (builder *VmBaseBuilder) Initialization(attr *Initialization) *VmBaseBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vmBase.SetInitialization(attr)
	return builder
}

func (builder *VmBaseBuilder) InitializationBuilder(attrBuilder *InitializationBuilder) *VmBaseBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Initialization(attr)
}

func (builder *VmBaseBuilder) Io(attr *Io) *VmBaseBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vmBase.SetIo(attr)
	return builder
}

func (builder *VmBaseBuilder) IoBuilder(attrBuilder *IoBuilder) *VmBaseBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Io(attr)
}

func (builder *VmBaseBuilder) LargeIcon(attr *Icon) *VmBaseBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vmBase.SetLargeIcon(attr)
	return builder
}

func (builder *VmBaseBuilder) LargeIconBuilder(attrBuilder *IconBuilder) *VmBaseBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.LargeIcon(attr)
}

func (builder *VmBaseBuilder) Lease(attr *StorageDomainLease) *VmBaseBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vmBase.SetLease(attr)
	return builder
}

func (builder *VmBaseBuilder) LeaseBuilder(attrBuilder *StorageDomainLeaseBuilder) *VmBaseBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Lease(attr)
}

func (builder *VmBaseBuilder) Memory(attr int64) *VmBaseBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vmBase.SetMemory(attr)
	return builder
}

func (builder *VmBaseBuilder) MemoryPolicy(attr *MemoryPolicy) *VmBaseBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vmBase.SetMemoryPolicy(attr)
	return builder
}

func (builder *VmBaseBuilder) MemoryPolicyBuilder(attrBuilder *MemoryPolicyBuilder) *VmBaseBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.MemoryPolicy(attr)
}

func (builder *VmBaseBuilder) Migration(attr *MigrationOptions) *VmBaseBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vmBase.SetMigration(attr)
	return builder
}

func (builder *VmBaseBuilder) MigrationBuilder(attrBuilder *MigrationOptionsBuilder) *VmBaseBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Migration(attr)
}

func (builder *VmBaseBuilder) MigrationDowntime(attr int64) *VmBaseBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vmBase.SetMigrationDowntime(attr)
	return builder
}

func (builder *VmBaseBuilder) MultiQueuesEnabled(attr bool) *VmBaseBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vmBase.SetMultiQueuesEnabled(attr)
	return builder
}

func (builder *VmBaseBuilder) Name(attr string) *VmBaseBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vmBase.SetName(attr)
	return builder
}

func (builder *VmBaseBuilder) Origin(attr string) *VmBaseBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vmBase.SetOrigin(attr)
	return builder
}

func (builder *VmBaseBuilder) Os(attr *OperatingSystem) *VmBaseBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vmBase.SetOs(attr)
	return builder
}

func (builder *VmBaseBuilder) OsBuilder(attrBuilder *OperatingSystemBuilder) *VmBaseBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Os(attr)
}

func (builder *VmBaseBuilder) PlacementPolicy(attr *VmPlacementPolicy) *VmBaseBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vmBase.SetPlacementPolicy(attr)
	return builder
}

func (builder *VmBaseBuilder) PlacementPolicyBuilder(attrBuilder *VmPlacementPolicyBuilder) *VmBaseBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.PlacementPolicy(attr)
}

func (builder *VmBaseBuilder) Quota(attr *Quota) *VmBaseBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vmBase.SetQuota(attr)
	return builder
}

func (builder *VmBaseBuilder) QuotaBuilder(attrBuilder *QuotaBuilder) *VmBaseBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Quota(attr)
}

func (builder *VmBaseBuilder) RngDevice(attr *RngDevice) *VmBaseBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vmBase.SetRngDevice(attr)
	return builder
}

func (builder *VmBaseBuilder) RngDeviceBuilder(attrBuilder *RngDeviceBuilder) *VmBaseBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.RngDevice(attr)
}

func (builder *VmBaseBuilder) SerialNumber(attr *SerialNumber) *VmBaseBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vmBase.SetSerialNumber(attr)
	return builder
}

func (builder *VmBaseBuilder) SerialNumberBuilder(attrBuilder *SerialNumberBuilder) *VmBaseBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.SerialNumber(attr)
}

func (builder *VmBaseBuilder) SmallIcon(attr *Icon) *VmBaseBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vmBase.SetSmallIcon(attr)
	return builder
}

func (builder *VmBaseBuilder) SmallIconBuilder(attrBuilder *IconBuilder) *VmBaseBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.SmallIcon(attr)
}

func (builder *VmBaseBuilder) SoundcardEnabled(attr bool) *VmBaseBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vmBase.SetSoundcardEnabled(attr)
	return builder
}

func (builder *VmBaseBuilder) Sso(attr *Sso) *VmBaseBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vmBase.SetSso(attr)
	return builder
}

func (builder *VmBaseBuilder) SsoBuilder(attrBuilder *SsoBuilder) *VmBaseBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Sso(attr)
}

func (builder *VmBaseBuilder) StartPaused(attr bool) *VmBaseBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vmBase.SetStartPaused(attr)
	return builder
}

func (builder *VmBaseBuilder) Stateless(attr bool) *VmBaseBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vmBase.SetStateless(attr)
	return builder
}

func (builder *VmBaseBuilder) StorageDomain(attr *StorageDomain) *VmBaseBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vmBase.SetStorageDomain(attr)
	return builder
}

func (builder *VmBaseBuilder) StorageDomainBuilder(attrBuilder *StorageDomainBuilder) *VmBaseBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.StorageDomain(attr)
}

func (builder *VmBaseBuilder) StorageErrorResumeBehaviour(attr VmStorageErrorResumeBehaviour) *VmBaseBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vmBase.SetStorageErrorResumeBehaviour(attr)
	return builder
}

func (builder *VmBaseBuilder) TimeZone(attr *TimeZone) *VmBaseBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vmBase.SetTimeZone(attr)
	return builder
}

func (builder *VmBaseBuilder) TimeZoneBuilder(attrBuilder *TimeZoneBuilder) *VmBaseBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.TimeZone(attr)
}

func (builder *VmBaseBuilder) TpmEnabled(attr bool) *VmBaseBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vmBase.SetTpmEnabled(attr)
	return builder
}

func (builder *VmBaseBuilder) TunnelMigration(attr bool) *VmBaseBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vmBase.SetTunnelMigration(attr)
	return builder
}

func (builder *VmBaseBuilder) Type(attr VmType) *VmBaseBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vmBase.SetType(attr)
	return builder
}

func (builder *VmBaseBuilder) Usb(attr *Usb) *VmBaseBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vmBase.SetUsb(attr)
	return builder
}

func (builder *VmBaseBuilder) UsbBuilder(attrBuilder *UsbBuilder) *VmBaseBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Usb(attr)
}

func (builder *VmBaseBuilder) VirtioScsi(attr *VirtioScsi) *VmBaseBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vmBase.SetVirtioScsi(attr)
	return builder
}

func (builder *VmBaseBuilder) VirtioScsiBuilder(attrBuilder *VirtioScsiBuilder) *VmBaseBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.VirtioScsi(attr)
}

func (builder *VmBaseBuilder) VirtioScsiMultiQueuesEnabled(attr bool) *VmBaseBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vmBase.SetVirtioScsiMultiQueuesEnabled(attr)
	return builder
}

func (builder *VmBaseBuilder) Href(href string) *VmBaseBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vmBase.SetHref(href)
	return builder
}

func (builder *VmBaseBuilder) Build() (*VmBase, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.vmBase, nil
}

func (builder *VmBaseBuilder) MustBuild() *VmBase {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build VmBase instance, reason: %v", builder.err))
	}
	return builder.vmBase
}

type VmPlacementPolicyBuilder struct {
	vmPlacementPolicy *VmPlacementPolicy
	err               error
}

func NewVmPlacementPolicyBuilder() *VmPlacementPolicyBuilder {
	return &VmPlacementPolicyBuilder{vmPlacementPolicy: &VmPlacementPolicy{}, err: nil}
}

func (builder *VmPlacementPolicyBuilder) Affinity(attr VmAffinity) *VmPlacementPolicyBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vmPlacementPolicy.SetAffinity(attr)
	return builder
}

func (builder *VmPlacementPolicyBuilder) Hosts(attr *HostSlice) *VmPlacementPolicyBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vmPlacementPolicy.SetHosts(attr)
	return builder
}

func (builder *VmPlacementPolicyBuilder) HostsOfAny(anys ...*Host) *VmPlacementPolicyBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.vmPlacementPolicy.hosts == nil {
		builder.vmPlacementPolicy.hosts = new(HostSlice)
	}
	builder.vmPlacementPolicy.hosts.slice = append(builder.vmPlacementPolicy.hosts.slice, anys...)
	return builder
}

func (builder *VmPlacementPolicyBuilder) HostsBuilderOfAny(anyBuilders ...HostBuilder) *VmPlacementPolicyBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.HostsOfAny(attr)
	}
	return builder
}

func (builder *VmPlacementPolicyBuilder) Href(href string) *VmPlacementPolicyBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vmPlacementPolicy.SetHref(href)
	return builder
}

func (builder *VmPlacementPolicyBuilder) Build() (*VmPlacementPolicy, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.vmPlacementPolicy, nil
}

func (builder *VmPlacementPolicyBuilder) MustBuild() *VmPlacementPolicy {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build VmPlacementPolicy instance, reason: %v", builder.err))
	}
	return builder.vmPlacementPolicy
}

type VmPoolBuilder struct {
	vmPool *VmPool
	err    error
}

func NewVmPoolBuilder() *VmPoolBuilder {
	return &VmPoolBuilder{vmPool: &VmPool{}, err: nil}
}

func (builder *VmPoolBuilder) AutoStorageSelect(attr bool) *VmPoolBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vmPool.SetAutoStorageSelect(attr)
	return builder
}

func (builder *VmPoolBuilder) Cluster(attr *Cluster) *VmPoolBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vmPool.SetCluster(attr)
	return builder
}

func (builder *VmPoolBuilder) ClusterBuilder(attrBuilder *ClusterBuilder) *VmPoolBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Cluster(attr)
}

func (builder *VmPoolBuilder) Comment(attr string) *VmPoolBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vmPool.SetComment(attr)
	return builder
}

func (builder *VmPoolBuilder) Description(attr string) *VmPoolBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vmPool.SetDescription(attr)
	return builder
}

func (builder *VmPoolBuilder) Display(attr *Display) *VmPoolBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vmPool.SetDisplay(attr)
	return builder
}

func (builder *VmPoolBuilder) DisplayBuilder(attrBuilder *DisplayBuilder) *VmPoolBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Display(attr)
}

func (builder *VmPoolBuilder) Id(attr string) *VmPoolBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vmPool.SetId(attr)
	return builder
}

func (builder *VmPoolBuilder) InstanceType(attr *InstanceType) *VmPoolBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vmPool.SetInstanceType(attr)
	return builder
}

func (builder *VmPoolBuilder) InstanceTypeBuilder(attrBuilder *InstanceTypeBuilder) *VmPoolBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.InstanceType(attr)
}

func (builder *VmPoolBuilder) MaxUserVms(attr int64) *VmPoolBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vmPool.SetMaxUserVms(attr)
	return builder
}

func (builder *VmPoolBuilder) Name(attr string) *VmPoolBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vmPool.SetName(attr)
	return builder
}

func (builder *VmPoolBuilder) Permissions(attr *PermissionSlice) *VmPoolBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vmPool.SetPermissions(attr)
	return builder
}

func (builder *VmPoolBuilder) PermissionsOfAny(anys ...*Permission) *VmPoolBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.vmPool.permissions == nil {
		builder.vmPool.permissions = new(PermissionSlice)
	}
	builder.vmPool.permissions.slice = append(builder.vmPool.permissions.slice, anys...)
	return builder
}

func (builder *VmPoolBuilder) PermissionsBuilderOfAny(anyBuilders ...PermissionBuilder) *VmPoolBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.PermissionsOfAny(attr)
	}
	return builder
}

func (builder *VmPoolBuilder) PrestartedVms(attr int64) *VmPoolBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vmPool.SetPrestartedVms(attr)
	return builder
}

func (builder *VmPoolBuilder) RngDevice(attr *RngDevice) *VmPoolBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vmPool.SetRngDevice(attr)
	return builder
}

func (builder *VmPoolBuilder) RngDeviceBuilder(attrBuilder *RngDeviceBuilder) *VmPoolBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.RngDevice(attr)
}

func (builder *VmPoolBuilder) Size(attr int64) *VmPoolBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vmPool.SetSize(attr)
	return builder
}

func (builder *VmPoolBuilder) SoundcardEnabled(attr bool) *VmPoolBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vmPool.SetSoundcardEnabled(attr)
	return builder
}

func (builder *VmPoolBuilder) Stateful(attr bool) *VmPoolBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vmPool.SetStateful(attr)
	return builder
}

func (builder *VmPoolBuilder) Template(attr *Template) *VmPoolBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vmPool.SetTemplate(attr)
	return builder
}

func (builder *VmPoolBuilder) TemplateBuilder(attrBuilder *TemplateBuilder) *VmPoolBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Template(attr)
}

func (builder *VmPoolBuilder) TpmEnabled(attr bool) *VmPoolBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vmPool.SetTpmEnabled(attr)
	return builder
}

func (builder *VmPoolBuilder) Type(attr VmPoolType) *VmPoolBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vmPool.SetType(attr)
	return builder
}

func (builder *VmPoolBuilder) UseLatestTemplateVersion(attr bool) *VmPoolBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vmPool.SetUseLatestTemplateVersion(attr)
	return builder
}

func (builder *VmPoolBuilder) Vm(attr *Vm) *VmPoolBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vmPool.SetVm(attr)
	return builder
}

func (builder *VmPoolBuilder) VmBuilder(attrBuilder *VmBuilder) *VmPoolBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Vm(attr)
}

func (builder *VmPoolBuilder) Href(href string) *VmPoolBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vmPool.SetHref(href)
	return builder
}

func (builder *VmPoolBuilder) Build() (*VmPool, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.vmPool, nil
}

func (builder *VmPoolBuilder) MustBuild() *VmPool {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build VmPool instance, reason: %v", builder.err))
	}
	return builder.vmPool
}

type VmSummaryBuilder struct {
	vmSummary *VmSummary
	err       error
}

func NewVmSummaryBuilder() *VmSummaryBuilder {
	return &VmSummaryBuilder{vmSummary: &VmSummary{}, err: nil}
}

func (builder *VmSummaryBuilder) Active(attr int64) *VmSummaryBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vmSummary.SetActive(attr)
	return builder
}

func (builder *VmSummaryBuilder) Migrating(attr int64) *VmSummaryBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vmSummary.SetMigrating(attr)
	return builder
}

func (builder *VmSummaryBuilder) Total(attr int64) *VmSummaryBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vmSummary.SetTotal(attr)
	return builder
}

func (builder *VmSummaryBuilder) Href(href string) *VmSummaryBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vmSummary.SetHref(href)
	return builder
}

func (builder *VmSummaryBuilder) Build() (*VmSummary, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.vmSummary, nil
}

func (builder *VmSummaryBuilder) MustBuild() *VmSummary {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build VmSummary instance, reason: %v", builder.err))
	}
	return builder.vmSummary
}

type VnicPassThroughBuilder struct {
	vnicPassThrough *VnicPassThrough
	err             error
}

func NewVnicPassThroughBuilder() *VnicPassThroughBuilder {
	return &VnicPassThroughBuilder{vnicPassThrough: &VnicPassThrough{}, err: nil}
}

func (builder *VnicPassThroughBuilder) Mode(attr VnicPassThroughMode) *VnicPassThroughBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vnicPassThrough.SetMode(attr)
	return builder
}

func (builder *VnicPassThroughBuilder) Href(href string) *VnicPassThroughBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vnicPassThrough.SetHref(href)
	return builder
}

func (builder *VnicPassThroughBuilder) Build() (*VnicPassThrough, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.vnicPassThrough, nil
}

func (builder *VnicPassThroughBuilder) MustBuild() *VnicPassThrough {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build VnicPassThrough instance, reason: %v", builder.err))
	}
	return builder.vnicPassThrough
}

type VnicProfileBuilder struct {
	vnicProfile *VnicProfile
	err         error
}

func NewVnicProfileBuilder() *VnicProfileBuilder {
	return &VnicProfileBuilder{vnicProfile: &VnicProfile{}, err: nil}
}

func (builder *VnicProfileBuilder) Comment(attr string) *VnicProfileBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vnicProfile.SetComment(attr)
	return builder
}

func (builder *VnicProfileBuilder) CustomProperties(attr *CustomPropertySlice) *VnicProfileBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vnicProfile.SetCustomProperties(attr)
	return builder
}

func (builder *VnicProfileBuilder) CustomPropertiesOfAny(anys ...*CustomProperty) *VnicProfileBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.vnicProfile.customProperties == nil {
		builder.vnicProfile.customProperties = new(CustomPropertySlice)
	}
	builder.vnicProfile.customProperties.slice = append(builder.vnicProfile.customProperties.slice, anys...)
	return builder
}

func (builder *VnicProfileBuilder) CustomPropertiesBuilderOfAny(anyBuilders ...CustomPropertyBuilder) *VnicProfileBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.CustomPropertiesOfAny(attr)
	}
	return builder
}

func (builder *VnicProfileBuilder) Description(attr string) *VnicProfileBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vnicProfile.SetDescription(attr)
	return builder
}

func (builder *VnicProfileBuilder) Failover(attr *VnicProfile) *VnicProfileBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vnicProfile.SetFailover(attr)
	return builder
}

func (builder *VnicProfileBuilder) FailoverBuilder(attrBuilder *VnicProfileBuilder) *VnicProfileBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Failover(attr)
}

func (builder *VnicProfileBuilder) Id(attr string) *VnicProfileBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vnicProfile.SetId(attr)
	return builder
}

func (builder *VnicProfileBuilder) Migratable(attr bool) *VnicProfileBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vnicProfile.SetMigratable(attr)
	return builder
}

func (builder *VnicProfileBuilder) Name(attr string) *VnicProfileBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vnicProfile.SetName(attr)
	return builder
}

func (builder *VnicProfileBuilder) Network(attr *Network) *VnicProfileBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vnicProfile.SetNetwork(attr)
	return builder
}

func (builder *VnicProfileBuilder) NetworkBuilder(attrBuilder *NetworkBuilder) *VnicProfileBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Network(attr)
}

func (builder *VnicProfileBuilder) NetworkFilter(attr *NetworkFilter) *VnicProfileBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vnicProfile.SetNetworkFilter(attr)
	return builder
}

func (builder *VnicProfileBuilder) NetworkFilterBuilder(attrBuilder *NetworkFilterBuilder) *VnicProfileBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.NetworkFilter(attr)
}

func (builder *VnicProfileBuilder) PassThrough(attr *VnicPassThrough) *VnicProfileBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vnicProfile.SetPassThrough(attr)
	return builder
}

func (builder *VnicProfileBuilder) PassThroughBuilder(attrBuilder *VnicPassThroughBuilder) *VnicProfileBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.PassThrough(attr)
}

func (builder *VnicProfileBuilder) Permissions(attr *PermissionSlice) *VnicProfileBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vnicProfile.SetPermissions(attr)
	return builder
}

func (builder *VnicProfileBuilder) PermissionsOfAny(anys ...*Permission) *VnicProfileBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.vnicProfile.permissions == nil {
		builder.vnicProfile.permissions = new(PermissionSlice)
	}
	builder.vnicProfile.permissions.slice = append(builder.vnicProfile.permissions.slice, anys...)
	return builder
}

func (builder *VnicProfileBuilder) PermissionsBuilderOfAny(anyBuilders ...PermissionBuilder) *VnicProfileBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.PermissionsOfAny(attr)
	}
	return builder
}

func (builder *VnicProfileBuilder) PortMirroring(attr bool) *VnicProfileBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vnicProfile.SetPortMirroring(attr)
	return builder
}

func (builder *VnicProfileBuilder) Qos(attr *Qos) *VnicProfileBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vnicProfile.SetQos(attr)
	return builder
}

func (builder *VnicProfileBuilder) QosBuilder(attrBuilder *QosBuilder) *VnicProfileBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Qos(attr)
}

func (builder *VnicProfileBuilder) Href(href string) *VnicProfileBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vnicProfile.SetHref(href)
	return builder
}

func (builder *VnicProfileBuilder) Build() (*VnicProfile, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.vnicProfile, nil
}

func (builder *VnicProfileBuilder) MustBuild() *VnicProfile {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build VnicProfile instance, reason: %v", builder.err))
	}
	return builder.vnicProfile
}

type VnicProfileMappingBuilder struct {
	vnicProfileMapping *VnicProfileMapping
	err                error
}

func NewVnicProfileMappingBuilder() *VnicProfileMappingBuilder {
	return &VnicProfileMappingBuilder{vnicProfileMapping: &VnicProfileMapping{}, err: nil}
}

func (builder *VnicProfileMappingBuilder) SourceNetworkName(attr string) *VnicProfileMappingBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vnicProfileMapping.SetSourceNetworkName(attr)
	return builder
}

func (builder *VnicProfileMappingBuilder) SourceNetworkProfileName(attr string) *VnicProfileMappingBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vnicProfileMapping.SetSourceNetworkProfileName(attr)
	return builder
}

func (builder *VnicProfileMappingBuilder) TargetVnicProfile(attr *VnicProfile) *VnicProfileMappingBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vnicProfileMapping.SetTargetVnicProfile(attr)
	return builder
}

func (builder *VnicProfileMappingBuilder) TargetVnicProfileBuilder(attrBuilder *VnicProfileBuilder) *VnicProfileMappingBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.TargetVnicProfile(attr)
}

func (builder *VnicProfileMappingBuilder) Href(href string) *VnicProfileMappingBuilder {
	if builder.err != nil {
		return builder
	}

	builder.vnicProfileMapping.SetHref(href)
	return builder
}

func (builder *VnicProfileMappingBuilder) Build() (*VnicProfileMapping, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.vnicProfileMapping, nil
}

func (builder *VnicProfileMappingBuilder) MustBuild() *VnicProfileMapping {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build VnicProfileMapping instance, reason: %v", builder.err))
	}
	return builder.vnicProfileMapping
}

type VolumeGroupBuilder struct {
	volumeGroup *VolumeGroup
	err         error
}

func NewVolumeGroupBuilder() *VolumeGroupBuilder {
	return &VolumeGroupBuilder{volumeGroup: &VolumeGroup{}, err: nil}
}

func (builder *VolumeGroupBuilder) Id(attr string) *VolumeGroupBuilder {
	if builder.err != nil {
		return builder
	}

	builder.volumeGroup.SetId(attr)
	return builder
}

func (builder *VolumeGroupBuilder) LogicalUnits(attr *LogicalUnitSlice) *VolumeGroupBuilder {
	if builder.err != nil {
		return builder
	}

	builder.volumeGroup.SetLogicalUnits(attr)
	return builder
}

func (builder *VolumeGroupBuilder) LogicalUnitsOfAny(anys ...*LogicalUnit) *VolumeGroupBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.volumeGroup.logicalUnits == nil {
		builder.volumeGroup.logicalUnits = new(LogicalUnitSlice)
	}
	builder.volumeGroup.logicalUnits.slice = append(builder.volumeGroup.logicalUnits.slice, anys...)
	return builder
}

func (builder *VolumeGroupBuilder) LogicalUnitsBuilderOfAny(anyBuilders ...LogicalUnitBuilder) *VolumeGroupBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.LogicalUnitsOfAny(attr)
	}
	return builder
}

func (builder *VolumeGroupBuilder) Name(attr string) *VolumeGroupBuilder {
	if builder.err != nil {
		return builder
	}

	builder.volumeGroup.SetName(attr)
	return builder
}

func (builder *VolumeGroupBuilder) Href(href string) *VolumeGroupBuilder {
	if builder.err != nil {
		return builder
	}

	builder.volumeGroup.SetHref(href)
	return builder
}

func (builder *VolumeGroupBuilder) Build() (*VolumeGroup, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.volumeGroup, nil
}

func (builder *VolumeGroupBuilder) MustBuild() *VolumeGroup {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build VolumeGroup instance, reason: %v", builder.err))
	}
	return builder.volumeGroup
}

type WatchdogBuilder struct {
	watchdog *Watchdog
	err      error
}

func NewWatchdogBuilder() *WatchdogBuilder {
	return &WatchdogBuilder{watchdog: &Watchdog{}, err: nil}
}

func (builder *WatchdogBuilder) Action(attr WatchdogAction) *WatchdogBuilder {
	if builder.err != nil {
		return builder
	}

	builder.watchdog.SetAction(attr)
	return builder
}

func (builder *WatchdogBuilder) Comment(attr string) *WatchdogBuilder {
	if builder.err != nil {
		return builder
	}

	builder.watchdog.SetComment(attr)
	return builder
}

func (builder *WatchdogBuilder) Description(attr string) *WatchdogBuilder {
	if builder.err != nil {
		return builder
	}

	builder.watchdog.SetDescription(attr)
	return builder
}

func (builder *WatchdogBuilder) Id(attr string) *WatchdogBuilder {
	if builder.err != nil {
		return builder
	}

	builder.watchdog.SetId(attr)
	return builder
}

func (builder *WatchdogBuilder) InstanceType(attr *InstanceType) *WatchdogBuilder {
	if builder.err != nil {
		return builder
	}

	builder.watchdog.SetInstanceType(attr)
	return builder
}

func (builder *WatchdogBuilder) InstanceTypeBuilder(attrBuilder *InstanceTypeBuilder) *WatchdogBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.InstanceType(attr)
}

func (builder *WatchdogBuilder) Model(attr WatchdogModel) *WatchdogBuilder {
	if builder.err != nil {
		return builder
	}

	builder.watchdog.SetModel(attr)
	return builder
}

func (builder *WatchdogBuilder) Name(attr string) *WatchdogBuilder {
	if builder.err != nil {
		return builder
	}

	builder.watchdog.SetName(attr)
	return builder
}

func (builder *WatchdogBuilder) Template(attr *Template) *WatchdogBuilder {
	if builder.err != nil {
		return builder
	}

	builder.watchdog.SetTemplate(attr)
	return builder
}

func (builder *WatchdogBuilder) TemplateBuilder(attrBuilder *TemplateBuilder) *WatchdogBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Template(attr)
}

func (builder *WatchdogBuilder) Vm(attr *Vm) *WatchdogBuilder {
	if builder.err != nil {
		return builder
	}

	builder.watchdog.SetVm(attr)
	return builder
}

func (builder *WatchdogBuilder) VmBuilder(attrBuilder *VmBuilder) *WatchdogBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Vm(attr)
}

func (builder *WatchdogBuilder) Vms(attr *VmSlice) *WatchdogBuilder {
	if builder.err != nil {
		return builder
	}

	builder.watchdog.SetVms(attr)
	return builder
}

func (builder *WatchdogBuilder) VmsOfAny(anys ...*Vm) *WatchdogBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.watchdog.vms == nil {
		builder.watchdog.vms = new(VmSlice)
	}
	builder.watchdog.vms.slice = append(builder.watchdog.vms.slice, anys...)
	return builder
}

func (builder *WatchdogBuilder) VmsBuilderOfAny(anyBuilders ...VmBuilder) *WatchdogBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.VmsOfAny(attr)
	}
	return builder
}

func (builder *WatchdogBuilder) Href(href string) *WatchdogBuilder {
	if builder.err != nil {
		return builder
	}

	builder.watchdog.SetHref(href)
	return builder
}

func (builder *WatchdogBuilder) Build() (*Watchdog, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.watchdog, nil
}

func (builder *WatchdogBuilder) MustBuild() *Watchdog {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build Watchdog instance, reason: %v", builder.err))
	}
	return builder.watchdog
}

type WeightBuilder struct {
	weight *Weight
	err    error
}

func NewWeightBuilder() *WeightBuilder {
	return &WeightBuilder{weight: &Weight{}, err: nil}
}

func (builder *WeightBuilder) Comment(attr string) *WeightBuilder {
	if builder.err != nil {
		return builder
	}

	builder.weight.SetComment(attr)
	return builder
}

func (builder *WeightBuilder) Description(attr string) *WeightBuilder {
	if builder.err != nil {
		return builder
	}

	builder.weight.SetDescription(attr)
	return builder
}

func (builder *WeightBuilder) Factor(attr int64) *WeightBuilder {
	if builder.err != nil {
		return builder
	}

	builder.weight.SetFactor(attr)
	return builder
}

func (builder *WeightBuilder) Id(attr string) *WeightBuilder {
	if builder.err != nil {
		return builder
	}

	builder.weight.SetId(attr)
	return builder
}

func (builder *WeightBuilder) Name(attr string) *WeightBuilder {
	if builder.err != nil {
		return builder
	}

	builder.weight.SetName(attr)
	return builder
}

func (builder *WeightBuilder) SchedulingPolicy(attr *SchedulingPolicy) *WeightBuilder {
	if builder.err != nil {
		return builder
	}

	builder.weight.SetSchedulingPolicy(attr)
	return builder
}

func (builder *WeightBuilder) SchedulingPolicyBuilder(attrBuilder *SchedulingPolicyBuilder) *WeightBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.SchedulingPolicy(attr)
}

func (builder *WeightBuilder) SchedulingPolicyUnit(attr *SchedulingPolicyUnit) *WeightBuilder {
	if builder.err != nil {
		return builder
	}

	builder.weight.SetSchedulingPolicyUnit(attr)
	return builder
}

func (builder *WeightBuilder) SchedulingPolicyUnitBuilder(attrBuilder *SchedulingPolicyUnitBuilder) *WeightBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.SchedulingPolicyUnit(attr)
}

func (builder *WeightBuilder) Href(href string) *WeightBuilder {
	if builder.err != nil {
		return builder
	}

	builder.weight.SetHref(href)
	return builder
}

func (builder *WeightBuilder) Build() (*Weight, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.weight, nil
}

func (builder *WeightBuilder) MustBuild() *Weight {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build Weight instance, reason: %v", builder.err))
	}
	return builder.weight
}

type FaultBuilder struct {
	fault *Fault
	err   error
}

func NewFaultBuilder() *FaultBuilder {
	return &FaultBuilder{fault: &Fault{}, err: nil}
}

func (builder *FaultBuilder) Detail(attr string) *FaultBuilder {
	if builder.err != nil {
		return builder
	}

	builder.fault.SetDetail(attr)
	return builder
}

func (builder *FaultBuilder) Reason(attr string) *FaultBuilder {
	if builder.err != nil {
		return builder
	}

	builder.fault.SetReason(attr)
	return builder
}

func (builder *FaultBuilder) Href(href string) *FaultBuilder {
	if builder.err != nil {
		return builder
	}

	builder.fault.SetHref(href)
	return builder
}

func (builder *FaultBuilder) Build() (*Fault, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.fault, nil
}

func (builder *FaultBuilder) MustBuild() *Fault {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build Fault instance, reason: %v", builder.err))
	}
	return builder.fault
}

type GracePeriodBuilder struct {
	gracePeriod *GracePeriod
	err         error
}

func NewGracePeriodBuilder() *GracePeriodBuilder {
	return &GracePeriodBuilder{gracePeriod: &GracePeriod{}, err: nil}
}

func (builder *GracePeriodBuilder) Expiry(attr int64) *GracePeriodBuilder {
	if builder.err != nil {
		return builder
	}

	builder.gracePeriod.SetExpiry(attr)
	return builder
}

func (builder *GracePeriodBuilder) Href(href string) *GracePeriodBuilder {
	if builder.err != nil {
		return builder
	}

	builder.gracePeriod.SetHref(href)
	return builder
}

func (builder *GracePeriodBuilder) Build() (*GracePeriod, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.gracePeriod, nil
}

func (builder *GracePeriodBuilder) MustBuild() *GracePeriod {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build GracePeriod instance, reason: %v", builder.err))
	}
	return builder.gracePeriod
}

type ActionBuilder struct {
	action *Action
	err    error
}

func NewActionBuilder() *ActionBuilder {
	return &ActionBuilder{action: &Action{}, err: nil}
}

func (builder *ActionBuilder) Activate(attr bool) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetActivate(attr)
	return builder
}

func (builder *ActionBuilder) AllowPartialImport(attr bool) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetAllowPartialImport(attr)
	return builder
}

func (builder *ActionBuilder) Async(attr bool) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetAsync(attr)
	return builder
}

func (builder *ActionBuilder) Attachment(attr *DiskAttachment) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetAttachment(attr)
	return builder
}

func (builder *ActionBuilder) AttachmentBuilder(attrBuilder *DiskAttachmentBuilder) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Attachment(attr)
}

func (builder *ActionBuilder) AuthorizedKey(attr *AuthorizedKey) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetAuthorizedKey(attr)
	return builder
}

func (builder *ActionBuilder) AuthorizedKeyBuilder(attrBuilder *AuthorizedKeyBuilder) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.AuthorizedKey(attr)
}

func (builder *ActionBuilder) AutoPinningPolicy(attr AutoPinningPolicy) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetAutoPinningPolicy(attr)
	return builder
}

func (builder *ActionBuilder) Bricks(attr *GlusterBrickSlice) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetBricks(attr)
	return builder
}

func (builder *ActionBuilder) BricksOfAny(anys ...*GlusterBrick) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.action.bricks == nil {
		builder.action.bricks = new(GlusterBrickSlice)
	}
	builder.action.bricks.slice = append(builder.action.bricks.slice, anys...)
	return builder
}

func (builder *ActionBuilder) BricksBuilderOfAny(anyBuilders ...GlusterBrickBuilder) *ActionBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.BricksOfAny(attr)
	}
	return builder
}

func (builder *ActionBuilder) Certificates(attr *CertificateSlice) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetCertificates(attr)
	return builder
}

func (builder *ActionBuilder) CertificatesOfAny(anys ...*Certificate) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.action.certificates == nil {
		builder.action.certificates = new(CertificateSlice)
	}
	builder.action.certificates.slice = append(builder.action.certificates.slice, anys...)
	return builder
}

func (builder *ActionBuilder) CertificatesBuilderOfAny(anyBuilders ...CertificateBuilder) *ActionBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.CertificatesOfAny(attr)
	}
	return builder
}

func (builder *ActionBuilder) CheckConnectivity(attr bool) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetCheckConnectivity(attr)
	return builder
}

func (builder *ActionBuilder) Clone(attr bool) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetClone(attr)
	return builder
}

func (builder *ActionBuilder) ClonePermissions(attr bool) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetClonePermissions(attr)
	return builder
}

func (builder *ActionBuilder) Cluster(attr *Cluster) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetCluster(attr)
	return builder
}

func (builder *ActionBuilder) ClusterBuilder(attrBuilder *ClusterBuilder) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Cluster(attr)
}

func (builder *ActionBuilder) CollapseSnapshots(attr bool) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetCollapseSnapshots(attr)
	return builder
}

func (builder *ActionBuilder) Comment(attr string) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetComment(attr)
	return builder
}

func (builder *ActionBuilder) CommitOnSuccess(attr bool) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetCommitOnSuccess(attr)
	return builder
}

func (builder *ActionBuilder) Connection(attr *StorageConnection) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetConnection(attr)
	return builder
}

func (builder *ActionBuilder) ConnectionBuilder(attrBuilder *StorageConnectionBuilder) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Connection(attr)
}

func (builder *ActionBuilder) ConnectivityTimeout(attr int64) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetConnectivityTimeout(attr)
	return builder
}

func (builder *ActionBuilder) DataCenter(attr *DataCenter) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetDataCenter(attr)
	return builder
}

func (builder *ActionBuilder) DataCenterBuilder(attrBuilder *DataCenterBuilder) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.DataCenter(attr)
}

func (builder *ActionBuilder) DeployHostedEngine(attr bool) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetDeployHostedEngine(attr)
	return builder
}

func (builder *ActionBuilder) Description(attr string) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetDescription(attr)
	return builder
}

func (builder *ActionBuilder) Details(attr *GlusterVolumeProfileDetails) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetDetails(attr)
	return builder
}

func (builder *ActionBuilder) DetailsBuilder(attrBuilder *GlusterVolumeProfileDetailsBuilder) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Details(attr)
}

func (builder *ActionBuilder) Directory(attr string) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetDirectory(attr)
	return builder
}

func (builder *ActionBuilder) DiscardSnapshots(attr bool) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetDiscardSnapshots(attr)
	return builder
}

func (builder *ActionBuilder) DiscoveredTargets(attr *IscsiDetailsSlice) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetDiscoveredTargets(attr)
	return builder
}

func (builder *ActionBuilder) DiscoveredTargetsOfAny(anys ...*IscsiDetails) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.action.discoveredTargets == nil {
		builder.action.discoveredTargets = new(IscsiDetailsSlice)
	}
	builder.action.discoveredTargets.slice = append(builder.action.discoveredTargets.slice, anys...)
	return builder
}

func (builder *ActionBuilder) DiscoveredTargetsBuilderOfAny(anyBuilders ...IscsiDetailsBuilder) *ActionBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.DiscoveredTargetsOfAny(attr)
	}
	return builder
}

func (builder *ActionBuilder) Disk(attr *Disk) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetDisk(attr)
	return builder
}

func (builder *ActionBuilder) DiskBuilder(attrBuilder *DiskBuilder) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Disk(attr)
}

func (builder *ActionBuilder) DiskProfile(attr *DiskProfile) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetDiskProfile(attr)
	return builder
}

func (builder *ActionBuilder) DiskProfileBuilder(attrBuilder *DiskProfileBuilder) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.DiskProfile(attr)
}

func (builder *ActionBuilder) Disks(attr *DiskSlice) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetDisks(attr)
	return builder
}

func (builder *ActionBuilder) DisksOfAny(anys ...*Disk) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.action.disks == nil {
		builder.action.disks = new(DiskSlice)
	}
	builder.action.disks.slice = append(builder.action.disks.slice, anys...)
	return builder
}

func (builder *ActionBuilder) DisksBuilderOfAny(anyBuilders ...DiskBuilder) *ActionBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.DisksOfAny(attr)
	}
	return builder
}

func (builder *ActionBuilder) Exclusive(attr bool) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetExclusive(attr)
	return builder
}

func (builder *ActionBuilder) Fault(attr *Fault) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetFault(attr)
	return builder
}

func (builder *ActionBuilder) FaultBuilder(attrBuilder *FaultBuilder) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Fault(attr)
}

func (builder *ActionBuilder) FenceType(attr string) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetFenceType(attr)
	return builder
}

func (builder *ActionBuilder) Filename(attr string) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetFilename(attr)
	return builder
}

func (builder *ActionBuilder) Filter(attr bool) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetFilter(attr)
	return builder
}

func (builder *ActionBuilder) FixLayout(attr bool) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetFixLayout(attr)
	return builder
}

func (builder *ActionBuilder) Force(attr bool) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetForce(attr)
	return builder
}

func (builder *ActionBuilder) GracePeriod(attr *GracePeriod) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetGracePeriod(attr)
	return builder
}

func (builder *ActionBuilder) GracePeriodBuilder(attrBuilder *GracePeriodBuilder) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.GracePeriod(attr)
}

func (builder *ActionBuilder) Host(attr *Host) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetHost(attr)
	return builder
}

func (builder *ActionBuilder) HostBuilder(attrBuilder *HostBuilder) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Host(attr)
}

func (builder *ActionBuilder) Id(attr string) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetId(attr)
	return builder
}

func (builder *ActionBuilder) Image(attr string) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetImage(attr)
	return builder
}

func (builder *ActionBuilder) ImageTransfer(attr *ImageTransfer) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetImageTransfer(attr)
	return builder
}

func (builder *ActionBuilder) ImageTransferBuilder(attrBuilder *ImageTransferBuilder) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.ImageTransfer(attr)
}

func (builder *ActionBuilder) ImportAsTemplate(attr bool) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetImportAsTemplate(attr)
	return builder
}

func (builder *ActionBuilder) IsAttached(attr bool) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetIsAttached(attr)
	return builder
}

func (builder *ActionBuilder) Iscsi(attr *IscsiDetails) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetIscsi(attr)
	return builder
}

func (builder *ActionBuilder) IscsiBuilder(attrBuilder *IscsiDetailsBuilder) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Iscsi(attr)
}

func (builder *ActionBuilder) IscsiTargets(attr []string) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetIscsiTargets(attr)
	return builder
}

func (builder *ActionBuilder) IscsiTargetsOfAny(anys ...string) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.iscsiTargets = append(builder.action.iscsiTargets, anys...)
	return builder
}

func (builder *ActionBuilder) Job(attr *Job) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetJob(attr)
	return builder
}

func (builder *ActionBuilder) JobBuilder(attrBuilder *JobBuilder) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Job(attr)
}

func (builder *ActionBuilder) Lease(attr *StorageDomainLease) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetLease(attr)
	return builder
}

func (builder *ActionBuilder) LeaseBuilder(attrBuilder *StorageDomainLeaseBuilder) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Lease(attr)
}

func (builder *ActionBuilder) LogicalUnits(attr *LogicalUnitSlice) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetLogicalUnits(attr)
	return builder
}

func (builder *ActionBuilder) LogicalUnitsOfAny(anys ...*LogicalUnit) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.action.logicalUnits == nil {
		builder.action.logicalUnits = new(LogicalUnitSlice)
	}
	builder.action.logicalUnits.slice = append(builder.action.logicalUnits.slice, anys...)
	return builder
}

func (builder *ActionBuilder) LogicalUnitsBuilderOfAny(anyBuilders ...LogicalUnitBuilder) *ActionBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.LogicalUnitsOfAny(attr)
	}
	return builder
}

func (builder *ActionBuilder) MaintenanceAfterRestart(attr bool) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetMaintenanceAfterRestart(attr)
	return builder
}

func (builder *ActionBuilder) MaintenanceEnabled(attr bool) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetMaintenanceEnabled(attr)
	return builder
}

func (builder *ActionBuilder) MigrateVmsInAffinityClosure(attr bool) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetMigrateVmsInAffinityClosure(attr)
	return builder
}

func (builder *ActionBuilder) ModifiedBonds(attr *HostNicSlice) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetModifiedBonds(attr)
	return builder
}

func (builder *ActionBuilder) ModifiedBondsOfAny(anys ...*HostNic) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.action.modifiedBonds == nil {
		builder.action.modifiedBonds = new(HostNicSlice)
	}
	builder.action.modifiedBonds.slice = append(builder.action.modifiedBonds.slice, anys...)
	return builder
}

func (builder *ActionBuilder) ModifiedBondsBuilderOfAny(anyBuilders ...HostNicBuilder) *ActionBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.ModifiedBondsOfAny(attr)
	}
	return builder
}

func (builder *ActionBuilder) ModifiedLabels(attr *NetworkLabelSlice) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetModifiedLabels(attr)
	return builder
}

func (builder *ActionBuilder) ModifiedLabelsOfAny(anys ...*NetworkLabel) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.action.modifiedLabels == nil {
		builder.action.modifiedLabels = new(NetworkLabelSlice)
	}
	builder.action.modifiedLabels.slice = append(builder.action.modifiedLabels.slice, anys...)
	return builder
}

func (builder *ActionBuilder) ModifiedLabelsBuilderOfAny(anyBuilders ...NetworkLabelBuilder) *ActionBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.ModifiedLabelsOfAny(attr)
	}
	return builder
}

func (builder *ActionBuilder) ModifiedNetworkAttachments(attr *NetworkAttachmentSlice) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetModifiedNetworkAttachments(attr)
	return builder
}

func (builder *ActionBuilder) ModifiedNetworkAttachmentsOfAny(anys ...*NetworkAttachment) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.action.modifiedNetworkAttachments == nil {
		builder.action.modifiedNetworkAttachments = new(NetworkAttachmentSlice)
	}
	builder.action.modifiedNetworkAttachments.slice = append(builder.action.modifiedNetworkAttachments.slice, anys...)
	return builder
}

func (builder *ActionBuilder) ModifiedNetworkAttachmentsBuilderOfAny(anyBuilders ...NetworkAttachmentBuilder) *ActionBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.ModifiedNetworkAttachmentsOfAny(attr)
	}
	return builder
}

func (builder *ActionBuilder) Name(attr string) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetName(attr)
	return builder
}

func (builder *ActionBuilder) OptimizeCpuSettings(attr bool) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetOptimizeCpuSettings(attr)
	return builder
}

func (builder *ActionBuilder) Option(attr *Option) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetOption(attr)
	return builder
}

func (builder *ActionBuilder) OptionBuilder(attrBuilder *OptionBuilder) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Option(attr)
}

func (builder *ActionBuilder) Pause(attr bool) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetPause(attr)
	return builder
}

func (builder *ActionBuilder) Permission(attr *Permission) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetPermission(attr)
	return builder
}

func (builder *ActionBuilder) PermissionBuilder(attrBuilder *PermissionBuilder) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Permission(attr)
}

func (builder *ActionBuilder) PowerManagement(attr *PowerManagement) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetPowerManagement(attr)
	return builder
}

func (builder *ActionBuilder) PowerManagementBuilder(attrBuilder *PowerManagementBuilder) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.PowerManagement(attr)
}

func (builder *ActionBuilder) ProxyTicket(attr *ProxyTicket) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetProxyTicket(attr)
	return builder
}

func (builder *ActionBuilder) ProxyTicketBuilder(attrBuilder *ProxyTicketBuilder) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.ProxyTicket(attr)
}

func (builder *ActionBuilder) Quota(attr *Quota) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetQuota(attr)
	return builder
}

func (builder *ActionBuilder) QuotaBuilder(attrBuilder *QuotaBuilder) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Quota(attr)
}

func (builder *ActionBuilder) Reason(attr string) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetReason(attr)
	return builder
}

func (builder *ActionBuilder) ReassignBadMacs(attr bool) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetReassignBadMacs(attr)
	return builder
}

func (builder *ActionBuilder) Reboot(attr bool) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetReboot(attr)
	return builder
}

func (builder *ActionBuilder) RegistrationConfiguration(attr *RegistrationConfiguration) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetRegistrationConfiguration(attr)
	return builder
}

func (builder *ActionBuilder) RegistrationConfigurationBuilder(attrBuilder *RegistrationConfigurationBuilder) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.RegistrationConfiguration(attr)
}

func (builder *ActionBuilder) RemoteViewerConnectionFile(attr string) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetRemoteViewerConnectionFile(attr)
	return builder
}

func (builder *ActionBuilder) RemovedBonds(attr *HostNicSlice) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetRemovedBonds(attr)
	return builder
}

func (builder *ActionBuilder) RemovedBondsOfAny(anys ...*HostNic) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.action.removedBonds == nil {
		builder.action.removedBonds = new(HostNicSlice)
	}
	builder.action.removedBonds.slice = append(builder.action.removedBonds.slice, anys...)
	return builder
}

func (builder *ActionBuilder) RemovedBondsBuilderOfAny(anyBuilders ...HostNicBuilder) *ActionBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.RemovedBondsOfAny(attr)
	}
	return builder
}

func (builder *ActionBuilder) RemovedLabels(attr *NetworkLabelSlice) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetRemovedLabels(attr)
	return builder
}

func (builder *ActionBuilder) RemovedLabelsOfAny(anys ...*NetworkLabel) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.action.removedLabels == nil {
		builder.action.removedLabels = new(NetworkLabelSlice)
	}
	builder.action.removedLabels.slice = append(builder.action.removedLabels.slice, anys...)
	return builder
}

func (builder *ActionBuilder) RemovedLabelsBuilderOfAny(anyBuilders ...NetworkLabelBuilder) *ActionBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.RemovedLabelsOfAny(attr)
	}
	return builder
}

func (builder *ActionBuilder) RemovedNetworkAttachments(attr *NetworkAttachmentSlice) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetRemovedNetworkAttachments(attr)
	return builder
}

func (builder *ActionBuilder) RemovedNetworkAttachmentsOfAny(anys ...*NetworkAttachment) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.action.removedNetworkAttachments == nil {
		builder.action.removedNetworkAttachments = new(NetworkAttachmentSlice)
	}
	builder.action.removedNetworkAttachments.slice = append(builder.action.removedNetworkAttachments.slice, anys...)
	return builder
}

func (builder *ActionBuilder) RemovedNetworkAttachmentsBuilderOfAny(anyBuilders ...NetworkAttachmentBuilder) *ActionBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.RemovedNetworkAttachmentsOfAny(attr)
	}
	return builder
}

func (builder *ActionBuilder) ResolutionType(attr string) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetResolutionType(attr)
	return builder
}

func (builder *ActionBuilder) RestoreMemory(attr bool) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetRestoreMemory(attr)
	return builder
}

func (builder *ActionBuilder) RootPassword(attr string) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetRootPassword(attr)
	return builder
}

func (builder *ActionBuilder) Seal(attr bool) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetSeal(attr)
	return builder
}

func (builder *ActionBuilder) Snapshot(attr *Snapshot) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetSnapshot(attr)
	return builder
}

func (builder *ActionBuilder) SnapshotBuilder(attrBuilder *SnapshotBuilder) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Snapshot(attr)
}

func (builder *ActionBuilder) SourceHost(attr *Host) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetSourceHost(attr)
	return builder
}

func (builder *ActionBuilder) SourceHostBuilder(attrBuilder *HostBuilder) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.SourceHost(attr)
}

func (builder *ActionBuilder) Ssh(attr *Ssh) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetSsh(attr)
	return builder
}

func (builder *ActionBuilder) SshBuilder(attrBuilder *SshBuilder) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Ssh(attr)
}

func (builder *ActionBuilder) Status(attr string) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetStatus(attr)
	return builder
}

func (builder *ActionBuilder) StopGlusterService(attr bool) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetStopGlusterService(attr)
	return builder
}

func (builder *ActionBuilder) StorageDomain(attr *StorageDomain) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetStorageDomain(attr)
	return builder
}

func (builder *ActionBuilder) StorageDomainBuilder(attrBuilder *StorageDomainBuilder) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.StorageDomain(attr)
}

func (builder *ActionBuilder) StorageDomains(attr *StorageDomainSlice) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetStorageDomains(attr)
	return builder
}

func (builder *ActionBuilder) StorageDomainsOfAny(anys ...*StorageDomain) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.action.storageDomains == nil {
		builder.action.storageDomains = new(StorageDomainSlice)
	}
	builder.action.storageDomains.slice = append(builder.action.storageDomains.slice, anys...)
	return builder
}

func (builder *ActionBuilder) StorageDomainsBuilderOfAny(anyBuilders ...StorageDomainBuilder) *ActionBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.StorageDomainsOfAny(attr)
	}
	return builder
}

func (builder *ActionBuilder) Succeeded(attr bool) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetSucceeded(attr)
	return builder
}

func (builder *ActionBuilder) SynchronizedNetworkAttachments(attr *NetworkAttachmentSlice) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetSynchronizedNetworkAttachments(attr)
	return builder
}

func (builder *ActionBuilder) SynchronizedNetworkAttachmentsOfAny(anys ...*NetworkAttachment) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.action.synchronizedNetworkAttachments == nil {
		builder.action.synchronizedNetworkAttachments = new(NetworkAttachmentSlice)
	}
	builder.action.synchronizedNetworkAttachments.slice = append(builder.action.synchronizedNetworkAttachments.slice, anys...)
	return builder
}

func (builder *ActionBuilder) SynchronizedNetworkAttachmentsBuilderOfAny(anyBuilders ...NetworkAttachmentBuilder) *ActionBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.SynchronizedNetworkAttachmentsOfAny(attr)
	}
	return builder
}

func (builder *ActionBuilder) Template(attr *Template) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetTemplate(attr)
	return builder
}

func (builder *ActionBuilder) TemplateBuilder(attrBuilder *TemplateBuilder) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Template(attr)
}

func (builder *ActionBuilder) Ticket(attr *Ticket) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetTicket(attr)
	return builder
}

func (builder *ActionBuilder) TicketBuilder(attrBuilder *TicketBuilder) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Ticket(attr)
}

func (builder *ActionBuilder) Timeout(attr int64) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetTimeout(attr)
	return builder
}

func (builder *ActionBuilder) UndeployHostedEngine(attr bool) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetUndeployHostedEngine(attr)
	return builder
}

func (builder *ActionBuilder) UpgradeAction(attr ClusterUpgradeAction) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetUpgradeAction(attr)
	return builder
}

func (builder *ActionBuilder) UseCloudInit(attr bool) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetUseCloudInit(attr)
	return builder
}

func (builder *ActionBuilder) UseIgnition(attr bool) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetUseIgnition(attr)
	return builder
}

func (builder *ActionBuilder) UseInitialization(attr bool) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetUseInitialization(attr)
	return builder
}

func (builder *ActionBuilder) UseSysprep(attr bool) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetUseSysprep(attr)
	return builder
}

func (builder *ActionBuilder) VirtualFunctionsConfiguration(attr *HostNicVirtualFunctionsConfiguration) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetVirtualFunctionsConfiguration(attr)
	return builder
}

func (builder *ActionBuilder) VirtualFunctionsConfigurationBuilder(attrBuilder *HostNicVirtualFunctionsConfigurationBuilder) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.VirtualFunctionsConfiguration(attr)
}

func (builder *ActionBuilder) Vm(attr *Vm) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetVm(attr)
	return builder
}

func (builder *ActionBuilder) VmBuilder(attrBuilder *VmBuilder) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	if attrBuilder.err != nil {
		builder.err = attrBuilder.err
		return builder
	}
	attr, err := attrBuilder.Build()
	if err != nil {
		builder.err = err
		return builder
	}
	return builder.Vm(attr)
}

func (builder *ActionBuilder) VnicProfileMappings(attr *VnicProfileMappingSlice) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetVnicProfileMappings(attr)
	return builder
}

func (builder *ActionBuilder) VnicProfileMappingsOfAny(anys ...*VnicProfileMapping) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	if builder.action.vnicProfileMappings == nil {
		builder.action.vnicProfileMappings = new(VnicProfileMappingSlice)
	}
	builder.action.vnicProfileMappings.slice = append(builder.action.vnicProfileMappings.slice, anys...)
	return builder
}

func (builder *ActionBuilder) VnicProfileMappingsBuilderOfAny(anyBuilders ...VnicProfileMappingBuilder) *ActionBuilder {
	if builder.err != nil || len(anyBuilders) == 0 {
		return builder
	}

	for _, b := range anyBuilders {
		if b.err != nil {
			builder.err = b.err
			return builder
		}
		attr, err := b.Build()
		if err != nil {
			builder.err = b.err
			return builder
		}
		builder.VnicProfileMappingsOfAny(attr)
	}
	return builder
}

func (builder *ActionBuilder) Volatile(attr bool) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetVolatile(attr)
	return builder
}

func (builder *ActionBuilder) Href(href string) *ActionBuilder {
	if builder.err != nil {
		return builder
	}

	builder.action.SetHref(href)
	return builder
}

func (builder *ActionBuilder) Build() (*Action, error) {
	if builder.err != nil {
		return nil, builder.err
	}
	return builder.action, nil
}

func (builder *ActionBuilder) MustBuild() *Action {
	if builder.err != nil {
		panic(fmt.Sprintf("Failed to build Action instance, reason: %v", builder.err))
	}
	return builder.action
}

type GlusterBrickStatus string

const (
	GLUSTERBRICKSTATUS_DOWN    GlusterBrickStatus = "down"
	GLUSTERBRICKSTATUS_UNKNOWN GlusterBrickStatus = "unknown"
	GLUSTERBRICKSTATUS_UP      GlusterBrickStatus = "up"
)

type GlusterHookStatus string

const (
	GLUSTERHOOKSTATUS_DISABLED GlusterHookStatus = "disabled"
	GLUSTERHOOKSTATUS_ENABLED  GlusterHookStatus = "enabled"
	GLUSTERHOOKSTATUS_MISSING  GlusterHookStatus = "missing"
)

type GlusterVolumeStatus string

const (
	GLUSTERVOLUMESTATUS_DOWN    GlusterVolumeStatus = "down"
	GLUSTERVOLUMESTATUS_UNKNOWN GlusterVolumeStatus = "unknown"
	GLUSTERVOLUMESTATUS_UP      GlusterVolumeStatus = "up"
)

type AccessProtocol string

const (
	ACCESSPROTOCOL_CIFS    AccessProtocol = "cifs"
	ACCESSPROTOCOL_GLUSTER AccessProtocol = "gluster"
	ACCESSPROTOCOL_NFS     AccessProtocol = "nfs"
)

type Architecture string

const (
	ARCHITECTURE_PPC64     Architecture = "ppc64"
	ARCHITECTURE_S390X     Architecture = "s390x"
	ARCHITECTURE_UNDEFINED Architecture = "undefined"
	ARCHITECTURE_X86_64    Architecture = "x86_64"
)

type AutoNumaStatus string

const (
	AUTONUMASTATUS_DISABLE AutoNumaStatus = "disable"
	AUTONUMASTATUS_ENABLE  AutoNumaStatus = "enable"
	AUTONUMASTATUS_UNKNOWN AutoNumaStatus = "unknown"
)

type AutoPinningPolicy string

const (
	AUTOPINNINGPOLICY_ADJUST   AutoPinningPolicy = "adjust"
	AUTOPINNINGPOLICY_DISABLED AutoPinningPolicy = "disabled"
	AUTOPINNINGPOLICY_EXISTING AutoPinningPolicy = "existing"
)

type BackupPhase string

const (
	BACKUPPHASE_FAILED       BackupPhase = "failed"
	BACKUPPHASE_FINALIZING   BackupPhase = "finalizing"
	BACKUPPHASE_INITIALIZING BackupPhase = "initializing"
	BACKUPPHASE_READY        BackupPhase = "ready"
	BACKUPPHASE_STARTING     BackupPhase = "starting"
	BACKUPPHASE_SUCCEEDED    BackupPhase = "succeeded"
)

type BiosType string

const (
	BIOSTYPE_CLUSTER_DEFAULT BiosType = "cluster_default"
	BIOSTYPE_I440FX_SEA_BIOS BiosType = "i440fx_sea_bios"
	BIOSTYPE_Q35_OVMF        BiosType = "q35_ovmf"
	BIOSTYPE_Q35_SEA_BIOS    BiosType = "q35_sea_bios"
	BIOSTYPE_Q35_SECURE_BOOT BiosType = "q35_secure_boot"
)

type BootDevice string

const (
	BOOTDEVICE_CDROM   BootDevice = "cdrom"
	BOOTDEVICE_HD      BootDevice = "hd"
	BOOTDEVICE_NETWORK BootDevice = "network"
)

type BootProtocol string

const (
	BOOTPROTOCOL_AUTOCONF           BootProtocol = "autoconf"
	BOOTPROTOCOL_DHCP               BootProtocol = "dhcp"
	BOOTPROTOCOL_NONE               BootProtocol = "none"
	BOOTPROTOCOL_POLY_DHCP_AUTOCONF BootProtocol = "poly_dhcp_autoconf"
	BOOTPROTOCOL_STATIC             BootProtocol = "static"
)

type CheckpointState string

const (
	CHECKPOINTSTATE_CREATED CheckpointState = "created"
	CHECKPOINTSTATE_INVALID CheckpointState = "invalid"
)

type CloudInitNetworkProtocol string

const (
	CLOUDINITNETWORKPROTOCOL_ENI                CloudInitNetworkProtocol = "eni"
	CLOUDINITNETWORKPROTOCOL_OPENSTACK_METADATA CloudInitNetworkProtocol = "openstack_metadata"
)

type ClusterUpgradeAction string

const (
	CLUSTERUPGRADEACTION_FINISH ClusterUpgradeAction = "finish"
	CLUSTERUPGRADEACTION_START  ClusterUpgradeAction = "start"
)

type ConfigurationType string

const (
	CONFIGURATIONTYPE_OVA ConfigurationType = "ova"
	CONFIGURATIONTYPE_OVF ConfigurationType = "ovf"
)

type CpuMode string

const (
	CPUMODE_CUSTOM           CpuMode = "custom"
	CPUMODE_HOST_MODEL       CpuMode = "host_model"
	CPUMODE_HOST_PASSTHROUGH CpuMode = "host_passthrough"
)

type CreationStatus string

const (
	CREATIONSTATUS_COMPLETE    CreationStatus = "complete"
	CREATIONSTATUS_FAILED      CreationStatus = "failed"
	CREATIONSTATUS_IN_PROGRESS CreationStatus = "in_progress"
	CREATIONSTATUS_PENDING     CreationStatus = "pending"
)

type DataCenterStatus string

const (
	DATACENTERSTATUS_CONTEND         DataCenterStatus = "contend"
	DATACENTERSTATUS_MAINTENANCE     DataCenterStatus = "maintenance"
	DATACENTERSTATUS_NOT_OPERATIONAL DataCenterStatus = "not_operational"
	DATACENTERSTATUS_PROBLEMATIC     DataCenterStatus = "problematic"
	DATACENTERSTATUS_UNINITIALIZED   DataCenterStatus = "uninitialized"
	DATACENTERSTATUS_UP              DataCenterStatus = "up"
)

type DiskBackup string

const (
	DISKBACKUP_INCREMENTAL DiskBackup = "incremental"
	DISKBACKUP_NONE        DiskBackup = "none"
)

type DiskBackupMode string

const (
	DISKBACKUPMODE_FULL        DiskBackupMode = "full"
	DISKBACKUPMODE_INCREMENTAL DiskBackupMode = "incremental"
)

type DiskContentType string

const (
	DISKCONTENTTYPE_BACKUP_SCRATCH              DiskContentType = "backup_scratch"
	DISKCONTENTTYPE_DATA                        DiskContentType = "data"
	DISKCONTENTTYPE_HOSTED_ENGINE               DiskContentType = "hosted_engine"
	DISKCONTENTTYPE_HOSTED_ENGINE_CONFIGURATION DiskContentType = "hosted_engine_configuration"
	DISKCONTENTTYPE_HOSTED_ENGINE_METADATA      DiskContentType = "hosted_engine_metadata"
	DISKCONTENTTYPE_HOSTED_ENGINE_SANLOCK       DiskContentType = "hosted_engine_sanlock"
	DISKCONTENTTYPE_ISO                         DiskContentType = "iso"
	DISKCONTENTTYPE_MEMORY_DUMP_VOLUME          DiskContentType = "memory_dump_volume"
	DISKCONTENTTYPE_MEMORY_METADATA_VOLUME      DiskContentType = "memory_metadata_volume"
	DISKCONTENTTYPE_OVF_STORE                   DiskContentType = "ovf_store"
)

type DiskFormat string

const (
	DISKFORMAT_COW DiskFormat = "cow"
	DISKFORMAT_RAW DiskFormat = "raw"
)

type DiskInterface string

const (
	DISKINTERFACE_IDE         DiskInterface = "ide"
	DISKINTERFACE_SATA        DiskInterface = "sata"
	DISKINTERFACE_SPAPR_VSCSI DiskInterface = "spapr_vscsi"
	DISKINTERFACE_VIRTIO      DiskInterface = "virtio"
	DISKINTERFACE_VIRTIO_SCSI DiskInterface = "virtio_scsi"
)

type DiskStatus string

const (
	DISKSTATUS_ILLEGAL DiskStatus = "illegal"
	DISKSTATUS_LOCKED  DiskStatus = "locked"
	DISKSTATUS_OK      DiskStatus = "ok"
)

type DiskStorageType string

const (
	DISKSTORAGETYPE_CINDER                DiskStorageType = "cinder"
	DISKSTORAGETYPE_IMAGE                 DiskStorageType = "image"
	DISKSTORAGETYPE_LUN                   DiskStorageType = "lun"
	DISKSTORAGETYPE_MANAGED_BLOCK_STORAGE DiskStorageType = "managed_block_storage"
)

type DiskType string

const (
	DISKTYPE_DATA   DiskType = "data"
	DISKTYPE_SYSTEM DiskType = "system"
)

type DisplayType string

const (
	DISPLAYTYPE_SPICE DisplayType = "spice"
	DISPLAYTYPE_VNC   DisplayType = "vnc"
)

type EntityExternalStatus string

const (
	ENTITYEXTERNALSTATUS_ERROR   EntityExternalStatus = "error"
	ENTITYEXTERNALSTATUS_FAILURE EntityExternalStatus = "failure"
	ENTITYEXTERNALSTATUS_INFO    EntityExternalStatus = "info"
	ENTITYEXTERNALSTATUS_OK      EntityExternalStatus = "ok"
	ENTITYEXTERNALSTATUS_WARNING EntityExternalStatus = "warning"
)

type ExternalStatus string

const (
	EXTERNALSTATUS_ERROR   ExternalStatus = "error"
	EXTERNALSTATUS_FAILURE ExternalStatus = "failure"
	EXTERNALSTATUS_INFO    ExternalStatus = "info"
	EXTERNALSTATUS_OK      ExternalStatus = "ok"
	EXTERNALSTATUS_WARNING ExternalStatus = "warning"
)

type ExternalSystemType string

const (
	EXTERNALSYSTEMTYPE_GLUSTER ExternalSystemType = "gluster"
	EXTERNALSYSTEMTYPE_VDSM    ExternalSystemType = "vdsm"
)

type ExternalVmProviderType string

const (
	EXTERNALVMPROVIDERTYPE_KVM    ExternalVmProviderType = "kvm"
	EXTERNALVMPROVIDERTYPE_VMWARE ExternalVmProviderType = "vmware"
	EXTERNALVMPROVIDERTYPE_XEN    ExternalVmProviderType = "xen"
)

type FenceType string

const (
	FENCETYPE_MANUAL  FenceType = "manual"
	FENCETYPE_RESTART FenceType = "restart"
	FENCETYPE_START   FenceType = "start"
	FENCETYPE_STATUS  FenceType = "status"
	FENCETYPE_STOP    FenceType = "stop"
)

type FipsMode string

const (
	FIPSMODE_DISABLED  FipsMode = "disabled"
	FIPSMODE_ENABLED   FipsMode = "enabled"
	FIPSMODE_UNDEFINED FipsMode = "undefined"
)

type FirewallType string

const (
	FIREWALLTYPE_FIREWALLD FirewallType = "firewalld"
	FIREWALLTYPE_IPTABLES  FirewallType = "iptables"
)

type GlusterState string

const (
	GLUSTERSTATE_DOWN    GlusterState = "down"
	GLUSTERSTATE_UNKNOWN GlusterState = "unknown"
	GLUSTERSTATE_UP      GlusterState = "up"
)

type GlusterVolumeType string

const (
	GLUSTERVOLUMETYPE_DISPERSE                      GlusterVolumeType = "disperse"
	GLUSTERVOLUMETYPE_DISTRIBUTE                    GlusterVolumeType = "distribute"
	GLUSTERVOLUMETYPE_DISTRIBUTED_DISPERSE          GlusterVolumeType = "distributed_disperse"
	GLUSTERVOLUMETYPE_DISTRIBUTED_REPLICATE         GlusterVolumeType = "distributed_replicate"
	GLUSTERVOLUMETYPE_DISTRIBUTED_STRIPE            GlusterVolumeType = "distributed_stripe"
	GLUSTERVOLUMETYPE_DISTRIBUTED_STRIPED_REPLICATE GlusterVolumeType = "distributed_striped_replicate"
	GLUSTERVOLUMETYPE_REPLICATE                     GlusterVolumeType = "replicate"
	GLUSTERVOLUMETYPE_STRIPE                        GlusterVolumeType = "stripe"
	GLUSTERVOLUMETYPE_STRIPED_REPLICATE             GlusterVolumeType = "striped_replicate"
)

type GraphicsType string

const (
	GRAPHICSTYPE_SPICE GraphicsType = "spice"
	GRAPHICSTYPE_VNC   GraphicsType = "vnc"
)

type HookContentType string

const (
	HOOKCONTENTTYPE_BINARY HookContentType = "binary"
	HOOKCONTENTTYPE_TEXT   HookContentType = "text"
)

type HookStage string

const (
	HOOKSTAGE_POST HookStage = "post"
	HOOKSTAGE_PRE  HookStage = "pre"
)

type HookStatus string

const (
	HOOKSTATUS_DISABLED HookStatus = "disabled"
	HOOKSTATUS_ENABLED  HookStatus = "enabled"
	HOOKSTATUS_MISSING  HookStatus = "missing"
)

type HostProtocol string

const (
	HOSTPROTOCOL_STOMP HostProtocol = "stomp"
	HOSTPROTOCOL_XML   HostProtocol = "xml"
)

type HostStatus string

const (
	HOSTSTATUS_CONNECTING                HostStatus = "connecting"
	HOSTSTATUS_DOWN                      HostStatus = "down"
	HOSTSTATUS_ERROR                     HostStatus = "error"
	HOSTSTATUS_INITIALIZING              HostStatus = "initializing"
	HOSTSTATUS_INSTALL_FAILED            HostStatus = "install_failed"
	HOSTSTATUS_INSTALLING                HostStatus = "installing"
	HOSTSTATUS_INSTALLING_OS             HostStatus = "installing_os"
	HOSTSTATUS_KDUMPING                  HostStatus = "kdumping"
	HOSTSTATUS_MAINTENANCE               HostStatus = "maintenance"
	HOSTSTATUS_NON_OPERATIONAL           HostStatus = "non_operational"
	HOSTSTATUS_NON_RESPONSIVE            HostStatus = "non_responsive"
	HOSTSTATUS_PENDING_APPROVAL          HostStatus = "pending_approval"
	HOSTSTATUS_PREPARING_FOR_MAINTENANCE HostStatus = "preparing_for_maintenance"
	HOSTSTATUS_REBOOT                    HostStatus = "reboot"
	HOSTSTATUS_UNASSIGNED                HostStatus = "unassigned"
	HOSTSTATUS_UP                        HostStatus = "up"
)

type HostType string

const (
	HOSTTYPE_OVIRT_NODE HostType = "ovirt_node"
	HOSTTYPE_RHEL       HostType = "rhel"
	HOSTTYPE_RHEV_H     HostType = "rhev_h"
)

type ImageFileType string

const (
	IMAGEFILETYPE_DISK   ImageFileType = "disk"
	IMAGEFILETYPE_FLOPPY ImageFileType = "floppy"
	IMAGEFILETYPE_ISO    ImageFileType = "iso"
)

type ImageTransferDirection string

const (
	IMAGETRANSFERDIRECTION_DOWNLOAD ImageTransferDirection = "download"
	IMAGETRANSFERDIRECTION_UPLOAD   ImageTransferDirection = "upload"
)

type ImageTransferPhase string

const (
	IMAGETRANSFERPHASE_CANCELLED          ImageTransferPhase = "cancelled"
	IMAGETRANSFERPHASE_CANCELLED_SYSTEM   ImageTransferPhase = "cancelled_system"
	IMAGETRANSFERPHASE_CANCELLED_USER     ImageTransferPhase = "cancelled_user"
	IMAGETRANSFERPHASE_FINALIZING_CLEANUP ImageTransferPhase = "finalizing_cleanup"
	IMAGETRANSFERPHASE_FINALIZING_FAILURE ImageTransferPhase = "finalizing_failure"
	IMAGETRANSFERPHASE_FINALIZING_SUCCESS ImageTransferPhase = "finalizing_success"
	IMAGETRANSFERPHASE_FINISHED_CLEANUP   ImageTransferPhase = "finished_cleanup"
	IMAGETRANSFERPHASE_FINISHED_FAILURE   ImageTransferPhase = "finished_failure"
	IMAGETRANSFERPHASE_FINISHED_SUCCESS   ImageTransferPhase = "finished_success"
	IMAGETRANSFERPHASE_INITIALIZING       ImageTransferPhase = "initializing"
	IMAGETRANSFERPHASE_PAUSED_SYSTEM      ImageTransferPhase = "paused_system"
	IMAGETRANSFERPHASE_PAUSED_USER        ImageTransferPhase = "paused_user"
	IMAGETRANSFERPHASE_RESUMING           ImageTransferPhase = "resuming"
	IMAGETRANSFERPHASE_TRANSFERRING       ImageTransferPhase = "transferring"
	IMAGETRANSFERPHASE_UNKNOWN            ImageTransferPhase = "unknown"
)

type ImageTransferTimeoutPolicy string

const (
	IMAGETRANSFERTIMEOUTPOLICY_CANCEL ImageTransferTimeoutPolicy = "cancel"
	IMAGETRANSFERTIMEOUTPOLICY_LEGACY ImageTransferTimeoutPolicy = "legacy"
	IMAGETRANSFERTIMEOUTPOLICY_PAUSE  ImageTransferTimeoutPolicy = "pause"
)

type InheritableBoolean string

const (
	INHERITABLEBOOLEAN_FALSE   InheritableBoolean = "false"
	INHERITABLEBOOLEAN_INHERIT InheritableBoolean = "inherit"
	INHERITABLEBOOLEAN_TRUE    InheritableBoolean = "true"
)

type IpVersion string

const (
	IPVERSION_V4 IpVersion = "v4"
	IPVERSION_V6 IpVersion = "v6"
)

type JobStatus string

const (
	JOBSTATUS_ABORTED  JobStatus = "aborted"
	JOBSTATUS_FAILED   JobStatus = "failed"
	JOBSTATUS_FINISHED JobStatus = "finished"
	JOBSTATUS_STARTED  JobStatus = "started"
	JOBSTATUS_UNKNOWN  JobStatus = "unknown"
)

type KdumpStatus string

const (
	KDUMPSTATUS_DISABLED KdumpStatus = "disabled"
	KDUMPSTATUS_ENABLED  KdumpStatus = "enabled"
	KDUMPSTATUS_UNKNOWN  KdumpStatus = "unknown"
)

type LogMaxMemoryUsedThresholdType string

const (
	LOGMAXMEMORYUSEDTHRESHOLDTYPE_ABSOLUTE_VALUE_IN_MB LogMaxMemoryUsedThresholdType = "absolute_value_in_mb"
	LOGMAXMEMORYUSEDTHRESHOLDTYPE_PERCENTAGE           LogMaxMemoryUsedThresholdType = "percentage"
)

type LogSeverity string

const (
	LOGSEVERITY_ALERT   LogSeverity = "alert"
	LOGSEVERITY_ERROR   LogSeverity = "error"
	LOGSEVERITY_NORMAL  LogSeverity = "normal"
	LOGSEVERITY_WARNING LogSeverity = "warning"
)

type LunStatus string

const (
	LUNSTATUS_FREE     LunStatus = "free"
	LUNSTATUS_UNUSABLE LunStatus = "unusable"
	LUNSTATUS_USED     LunStatus = "used"
)

type MessageBrokerType string

const (
	MESSAGEBROKERTYPE_QPID      MessageBrokerType = "qpid"
	MESSAGEBROKERTYPE_RABBIT_MQ MessageBrokerType = "rabbit_mq"
)

type MigrateOnError string

const (
	MIGRATEONERROR_DO_NOT_MIGRATE           MigrateOnError = "do_not_migrate"
	MIGRATEONERROR_MIGRATE                  MigrateOnError = "migrate"
	MIGRATEONERROR_MIGRATE_HIGHLY_AVAILABLE MigrateOnError = "migrate_highly_available"
)

type MigrationBandwidthAssignmentMethod string

const (
	MIGRATIONBANDWIDTHASSIGNMENTMETHOD_AUTO               MigrationBandwidthAssignmentMethod = "auto"
	MIGRATIONBANDWIDTHASSIGNMENTMETHOD_CUSTOM             MigrationBandwidthAssignmentMethod = "custom"
	MIGRATIONBANDWIDTHASSIGNMENTMETHOD_HYPERVISOR_DEFAULT MigrationBandwidthAssignmentMethod = "hypervisor_default"
)

type NetworkPluginType string

const (
	NETWORKPLUGINTYPE_OPEN_VSWITCH NetworkPluginType = "open_vswitch"
)

type NetworkStatus string

const (
	NETWORKSTATUS_NON_OPERATIONAL NetworkStatus = "non_operational"
	NETWORKSTATUS_OPERATIONAL     NetworkStatus = "operational"
)

type NetworkUsage string

const (
	NETWORKUSAGE_DEFAULT_ROUTE NetworkUsage = "default_route"
	NETWORKUSAGE_DISPLAY       NetworkUsage = "display"
	NETWORKUSAGE_GLUSTER       NetworkUsage = "gluster"
	NETWORKUSAGE_MANAGEMENT    NetworkUsage = "management"
	NETWORKUSAGE_MIGRATION     NetworkUsage = "migration"
	NETWORKUSAGE_VM            NetworkUsage = "vm"
)

type NfsVersion string

const (
	NFSVERSION_AUTO NfsVersion = "auto"
	NFSVERSION_V3   NfsVersion = "v3"
	NFSVERSION_V4   NfsVersion = "v4"
	NFSVERSION_V4_0 NfsVersion = "v4_0"
	NFSVERSION_V4_1 NfsVersion = "v4_1"
	NFSVERSION_V4_2 NfsVersion = "v4_2"
)

type NicInterface string

const (
	NICINTERFACE_E1000           NicInterface = "e1000"
	NICINTERFACE_PCI_PASSTHROUGH NicInterface = "pci_passthrough"
	NICINTERFACE_RTL8139         NicInterface = "rtl8139"
	NICINTERFACE_RTL8139_VIRTIO  NicInterface = "rtl8139_virtio"
	NICINTERFACE_SPAPR_VLAN      NicInterface = "spapr_vlan"
	NICINTERFACE_VIRTIO          NicInterface = "virtio"
)

type NicStatus string

const (
	NICSTATUS_DOWN NicStatus = "down"
	NICSTATUS_UP   NicStatus = "up"
)

type NotifiableEvent string

const (
	NOTIFIABLEEVENT_CLUSTER_ALERT_HA_RESERVATION                           NotifiableEvent = "cluster_alert_ha_reservation"
	NOTIFIABLEEVENT_CLUSTER_ALERT_HA_RESERVATION_DOWN                      NotifiableEvent = "cluster_alert_ha_reservation_down"
	NOTIFIABLEEVENT_DWH_ERROR                                              NotifiableEvent = "dwh_error"
	NOTIFIABLEEVENT_DWH_STOPPED                                            NotifiableEvent = "dwh_stopped"
	NOTIFIABLEEVENT_ENGINE_BACKUP_COMPLETED                                NotifiableEvent = "engine_backup_completed"
	NOTIFIABLEEVENT_ENGINE_BACKUP_FAILED                                   NotifiableEvent = "engine_backup_failed"
	NOTIFIABLEEVENT_ENGINE_BACKUP_STARTED                                  NotifiableEvent = "engine_backup_started"
	NOTIFIABLEEVENT_ENGINE_CA_CERTIFICATION_HAS_EXPIRED                    NotifiableEvent = "engine_ca_certification_has_expired"
	NOTIFIABLEEVENT_ENGINE_CA_CERTIFICATION_IS_ABOUT_TO_EXPIRE             NotifiableEvent = "engine_ca_certification_is_about_to_expire"
	NOTIFIABLEEVENT_ENGINE_CERTIFICATION_HAS_EXPIRED                       NotifiableEvent = "engine_certification_has_expired"
	NOTIFIABLEEVENT_ENGINE_CERTIFICATION_IS_ABOUT_TO_EXPIRE                NotifiableEvent = "engine_certification_is_about_to_expire"
	NOTIFIABLEEVENT_ENGINE_STOP                                            NotifiableEvent = "engine_stop"
	NOTIFIABLEEVENT_GLUSTER_BRICK_STATUS_CHANGED                           NotifiableEvent = "gluster_brick_status_changed"
	NOTIFIABLEEVENT_GLUSTER_HOOK_ADD_FAILED                                NotifiableEvent = "gluster_hook_add_failed"
	NOTIFIABLEEVENT_GLUSTER_HOOK_ADDED                                     NotifiableEvent = "gluster_hook_added"
	NOTIFIABLEEVENT_GLUSTER_HOOK_CONFLICT_DETECTED                         NotifiableEvent = "gluster_hook_conflict_detected"
	NOTIFIABLEEVENT_GLUSTER_HOOK_DETECTED_DELETE                           NotifiableEvent = "gluster_hook_detected_delete"
	NOTIFIABLEEVENT_GLUSTER_HOOK_DETECTED_NEW                              NotifiableEvent = "gluster_hook_detected_new"
	NOTIFIABLEEVENT_GLUSTER_HOOK_DISABLE                                   NotifiableEvent = "gluster_hook_disable"
	NOTIFIABLEEVENT_GLUSTER_HOOK_DISABLE_FAILED                            NotifiableEvent = "gluster_hook_disable_failed"
	NOTIFIABLEEVENT_GLUSTER_HOOK_ENABLE                                    NotifiableEvent = "gluster_hook_enable"
	NOTIFIABLEEVENT_GLUSTER_HOOK_ENABLE_FAILED                             NotifiableEvent = "gluster_hook_enable_failed"
	NOTIFIABLEEVENT_GLUSTER_HOOK_REMOVE_FAILED                             NotifiableEvent = "gluster_hook_remove_failed"
	NOTIFIABLEEVENT_GLUSTER_HOOK_REMOVED                                   NotifiableEvent = "gluster_hook_removed"
	NOTIFIABLEEVENT_GLUSTER_SERVER_ADD_FAILED                              NotifiableEvent = "gluster_server_add_failed"
	NOTIFIABLEEVENT_GLUSTER_SERVER_REMOVE                                  NotifiableEvent = "gluster_server_remove"
	NOTIFIABLEEVENT_GLUSTER_SERVER_REMOVE_FAILED                           NotifiableEvent = "gluster_server_remove_failed"
	NOTIFIABLEEVENT_GLUSTER_SERVICE_RESTART_FAILED                         NotifiableEvent = "gluster_service_restart_failed"
	NOTIFIABLEEVENT_GLUSTER_SERVICE_RESTARTED                              NotifiableEvent = "gluster_service_restarted"
	NOTIFIABLEEVENT_GLUSTER_SERVICE_START_FAILED                           NotifiableEvent = "gluster_service_start_failed"
	NOTIFIABLEEVENT_GLUSTER_SERVICE_STARTED                                NotifiableEvent = "gluster_service_started"
	NOTIFIABLEEVENT_GLUSTER_SERVICE_STOP_FAILED                            NotifiableEvent = "gluster_service_stop_failed"
	NOTIFIABLEEVENT_GLUSTER_SERVICE_STOPPED                                NotifiableEvent = "gluster_service_stopped"
	NOTIFIABLEEVENT_GLUSTER_VOLUME_ADD_BRICK                               NotifiableEvent = "gluster_volume_add_brick"
	NOTIFIABLEEVENT_GLUSTER_VOLUME_ADD_BRICK_FAILED                        NotifiableEvent = "gluster_volume_add_brick_failed"
	NOTIFIABLEEVENT_GLUSTER_VOLUME_ALL_SNAPSHOTS_DELETE_FAILED             NotifiableEvent = "gluster_volume_all_snapshots_delete_failed"
	NOTIFIABLEEVENT_GLUSTER_VOLUME_ALL_SNAPSHOTS_DELETED                   NotifiableEvent = "gluster_volume_all_snapshots_deleted"
	NOTIFIABLEEVENT_GLUSTER_VOLUME_BRICK_REPLACED                          NotifiableEvent = "gluster_volume_brick_replaced"
	NOTIFIABLEEVENT_GLUSTER_VOLUME_CONFIRMED_SPACE_LOW                     NotifiableEvent = "gluster_volume_confirmed_space_low"
	NOTIFIABLEEVENT_GLUSTER_VOLUME_CREATE                                  NotifiableEvent = "gluster_volume_create"
	NOTIFIABLEEVENT_GLUSTER_VOLUME_CREATE_FAILED                           NotifiableEvent = "gluster_volume_create_failed"
	NOTIFIABLEEVENT_GLUSTER_VOLUME_DELETE                                  NotifiableEvent = "gluster_volume_delete"
	NOTIFIABLEEVENT_GLUSTER_VOLUME_DELETE_FAILED                           NotifiableEvent = "gluster_volume_delete_failed"
	NOTIFIABLEEVENT_GLUSTER_VOLUME_MIGRATE_BRICK_DATA_FINISHED             NotifiableEvent = "gluster_volume_migrate_brick_data_finished"
	NOTIFIABLEEVENT_GLUSTER_VOLUME_OPTION_ADDED                            NotifiableEvent = "gluster_volume_option_added"
	NOTIFIABLEEVENT_GLUSTER_VOLUME_OPTION_MODIFIED                         NotifiableEvent = "gluster_volume_option_modified"
	NOTIFIABLEEVENT_GLUSTER_VOLUME_OPTION_SET_FAILED                       NotifiableEvent = "gluster_volume_option_set_failed"
	NOTIFIABLEEVENT_GLUSTER_VOLUME_OPTIONS_RESET                           NotifiableEvent = "gluster_volume_options_reset"
	NOTIFIABLEEVENT_GLUSTER_VOLUME_OPTIONS_RESET_ALL                       NotifiableEvent = "gluster_volume_options_reset_all"
	NOTIFIABLEEVENT_GLUSTER_VOLUME_OPTIONS_RESET_FAILED                    NotifiableEvent = "gluster_volume_options_reset_failed"
	NOTIFIABLEEVENT_GLUSTER_VOLUME_PROFILE_START                           NotifiableEvent = "gluster_volume_profile_start"
	NOTIFIABLEEVENT_GLUSTER_VOLUME_PROFILE_START_FAILED                    NotifiableEvent = "gluster_volume_profile_start_failed"
	NOTIFIABLEEVENT_GLUSTER_VOLUME_PROFILE_STOP                            NotifiableEvent = "gluster_volume_profile_stop"
	NOTIFIABLEEVENT_GLUSTER_VOLUME_PROFILE_STOP_FAILED                     NotifiableEvent = "gluster_volume_profile_stop_failed"
	NOTIFIABLEEVENT_GLUSTER_VOLUME_REBALANCE_FINISHED                      NotifiableEvent = "gluster_volume_rebalance_finished"
	NOTIFIABLEEVENT_GLUSTER_VOLUME_REBALANCE_NOT_FOUND_FROM_CLI            NotifiableEvent = "gluster_volume_rebalance_not_found_from_cli"
	NOTIFIABLEEVENT_GLUSTER_VOLUME_REBALANCE_START                         NotifiableEvent = "gluster_volume_rebalance_start"
	NOTIFIABLEEVENT_GLUSTER_VOLUME_REBALANCE_START_DETECTED_FROM_CLI       NotifiableEvent = "gluster_volume_rebalance_start_detected_from_cli"
	NOTIFIABLEEVENT_GLUSTER_VOLUME_REBALANCE_START_FAILED                  NotifiableEvent = "gluster_volume_rebalance_start_failed"
	NOTIFIABLEEVENT_GLUSTER_VOLUME_REBALANCE_STOP                          NotifiableEvent = "gluster_volume_rebalance_stop"
	NOTIFIABLEEVENT_GLUSTER_VOLUME_REBALANCE_STOP_FAILED                   NotifiableEvent = "gluster_volume_rebalance_stop_failed"
	NOTIFIABLEEVENT_GLUSTER_VOLUME_REMOVE_BRICKS                           NotifiableEvent = "gluster_volume_remove_bricks"
	NOTIFIABLEEVENT_GLUSTER_VOLUME_REMOVE_BRICKS_FAILED                    NotifiableEvent = "gluster_volume_remove_bricks_failed"
	NOTIFIABLEEVENT_GLUSTER_VOLUME_REMOVE_BRICKS_STOP                      NotifiableEvent = "gluster_volume_remove_bricks_stop"
	NOTIFIABLEEVENT_GLUSTER_VOLUME_REMOVE_BRICKS_STOP_FAILED               NotifiableEvent = "gluster_volume_remove_bricks_stop_failed"
	NOTIFIABLEEVENT_GLUSTER_VOLUME_REPLACE_BRICK_FAILED                    NotifiableEvent = "gluster_volume_replace_brick_failed"
	NOTIFIABLEEVENT_GLUSTER_VOLUME_REPLACE_BRICK_START                     NotifiableEvent = "gluster_volume_replace_brick_start"
	NOTIFIABLEEVENT_GLUSTER_VOLUME_REPLACE_BRICK_START_FAILED              NotifiableEvent = "gluster_volume_replace_brick_start_failed"
	NOTIFIABLEEVENT_GLUSTER_VOLUME_SNAPSHOT_ACTIVATE_FAILED                NotifiableEvent = "gluster_volume_snapshot_activate_failed"
	NOTIFIABLEEVENT_GLUSTER_VOLUME_SNAPSHOT_ACTIVATED                      NotifiableEvent = "gluster_volume_snapshot_activated"
	NOTIFIABLEEVENT_GLUSTER_VOLUME_SNAPSHOT_CREATE_FAILED                  NotifiableEvent = "gluster_volume_snapshot_create_failed"
	NOTIFIABLEEVENT_GLUSTER_VOLUME_SNAPSHOT_CREATED                        NotifiableEvent = "gluster_volume_snapshot_created"
	NOTIFIABLEEVENT_GLUSTER_VOLUME_SNAPSHOT_DEACTIVATE_FAILED              NotifiableEvent = "gluster_volume_snapshot_deactivate_failed"
	NOTIFIABLEEVENT_GLUSTER_VOLUME_SNAPSHOT_DEACTIVATED                    NotifiableEvent = "gluster_volume_snapshot_deactivated"
	NOTIFIABLEEVENT_GLUSTER_VOLUME_SNAPSHOT_DELETE_FAILED                  NotifiableEvent = "gluster_volume_snapshot_delete_failed"
	NOTIFIABLEEVENT_GLUSTER_VOLUME_SNAPSHOT_DELETED                        NotifiableEvent = "gluster_volume_snapshot_deleted"
	NOTIFIABLEEVENT_GLUSTER_VOLUME_SNAPSHOT_RESTORE_FAILED                 NotifiableEvent = "gluster_volume_snapshot_restore_failed"
	NOTIFIABLEEVENT_GLUSTER_VOLUME_SNAPSHOT_RESTORED                       NotifiableEvent = "gluster_volume_snapshot_restored"
	NOTIFIABLEEVENT_GLUSTER_VOLUME_START                                   NotifiableEvent = "gluster_volume_start"
	NOTIFIABLEEVENT_GLUSTER_VOLUME_START_FAILED                            NotifiableEvent = "gluster_volume_start_failed"
	NOTIFIABLEEVENT_GLUSTER_VOLUME_STOP                                    NotifiableEvent = "gluster_volume_stop"
	NOTIFIABLEEVENT_GLUSTER_VOLUME_STOP_FAILED                             NotifiableEvent = "gluster_volume_stop_failed"
	NOTIFIABLEEVENT_HA_VM_FAILED                                           NotifiableEvent = "ha_vm_failed"
	NOTIFIABLEEVENT_HA_VM_RESTART_FAILED                                   NotifiableEvent = "ha_vm_restart_failed"
	NOTIFIABLEEVENT_HOST_ACTIVATE_FAILED                                   NotifiableEvent = "host_activate_failed"
	NOTIFIABLEEVENT_HOST_ACTIVATE_MANUAL_HA                                NotifiableEvent = "host_activate_manual_ha"
	NOTIFIABLEEVENT_HOST_APPROVE_FAILED                                    NotifiableEvent = "host_approve_failed"
	NOTIFIABLEEVENT_HOST_BOND_SLAVE_STATE_DOWN                             NotifiableEvent = "host_bond_slave_state_down"
	NOTIFIABLEEVENT_HOST_CERTIFICATE_HAS_INVALID_SAN                       NotifiableEvent = "host_certificate_has_invalid_san"
	NOTIFIABLEEVENT_HOST_CERTIFICATION_HAS_EXPIRED                         NotifiableEvent = "host_certification_has_expired"
	NOTIFIABLEEVENT_HOST_CERTIFICATION_IS_ABOUT_TO_EXPIRE                  NotifiableEvent = "host_certification_is_about_to_expire"
	NOTIFIABLEEVENT_HOST_FAILURE                                           NotifiableEvent = "host_failure"
	NOTIFIABLEEVENT_HOST_HIGH_CPU_USE                                      NotifiableEvent = "host_high_cpu_use"
	NOTIFIABLEEVENT_HOST_HIGH_MEM_USE                                      NotifiableEvent = "host_high_mem_use"
	NOTIFIABLEEVENT_HOST_HIGH_SWAP_USE                                     NotifiableEvent = "host_high_swap_use"
	NOTIFIABLEEVENT_HOST_INITIATED_RUN_VM_FAILED                           NotifiableEvent = "host_initiated_run_vm_failed"
	NOTIFIABLEEVENT_HOST_INSTALL_FAILED                                    NotifiableEvent = "host_install_failed"
	NOTIFIABLEEVENT_HOST_INTERFACE_HIGH_NETWORK_USE                        NotifiableEvent = "host_interface_high_network_use"
	NOTIFIABLEEVENT_HOST_INTERFACE_STATE_DOWN                              NotifiableEvent = "host_interface_state_down"
	NOTIFIABLEEVENT_HOST_LOW_MEM                                           NotifiableEvent = "host_low_mem"
	NOTIFIABLEEVENT_HOST_LOW_SWAP                                          NotifiableEvent = "host_low_swap"
	NOTIFIABLEEVENT_HOST_RECOVER_FAILED                                    NotifiableEvent = "host_recover_failed"
	NOTIFIABLEEVENT_HOST_SET_NONOPERATIONAL                                NotifiableEvent = "host_set_nonoperational"
	NOTIFIABLEEVENT_HOST_SET_NONOPERATIONAL_DOMAIN                         NotifiableEvent = "host_set_nonoperational_domain"
	NOTIFIABLEEVENT_HOST_SET_NONOPERATIONAL_IFACE_DOWN                     NotifiableEvent = "host_set_nonoperational_iface_down"
	NOTIFIABLEEVENT_HOST_SLOW_STORAGE_RESPONSE_TIME                        NotifiableEvent = "host_slow_storage_response_time"
	NOTIFIABLEEVENT_HOST_TIME_DRIFT_ALERT                                  NotifiableEvent = "host_time_drift_alert"
	NOTIFIABLEEVENT_HOST_UNTRUSTED                                         NotifiableEvent = "host_untrusted"
	NOTIFIABLEEVENT_HOST_UPDATES_ARE_AVAILABLE                             NotifiableEvent = "host_updates_are_available"
	NOTIFIABLEEVENT_HOST_UPDATES_ARE_AVAILABLE_WITH_PACKAGES               NotifiableEvent = "host_updates_are_available_with_packages"
	NOTIFIABLEEVENT_IMPORTEXPORT_IMPORT_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED NotifiableEvent = "importexport_import_template_from_trusted_to_untrusted"
	NOTIFIABLEEVENT_IMPORTEXPORT_IMPORT_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED NotifiableEvent = "importexport_import_template_from_untrusted_to_trusted"
	NOTIFIABLEEVENT_IMPORTEXPORT_IMPORT_VM_FROM_TRUSTED_TO_UNTRUSTED       NotifiableEvent = "importexport_import_vm_from_trusted_to_untrusted"
	NOTIFIABLEEVENT_IMPORTEXPORT_IMPORT_VM_FROM_UNTRUSTED_TO_TRUSTED       NotifiableEvent = "importexport_import_vm_from_untrusted_to_trusted"
	NOTIFIABLEEVENT_IRS_CONFIRMED_DISK_SPACE_LOW                           NotifiableEvent = "irs_confirmed_disk_space_low"
	NOTIFIABLEEVENT_IRS_DISK_SPACE_LOW                                     NotifiableEvent = "irs_disk_space_low"
	NOTIFIABLEEVENT_IRS_DISK_SPACE_LOW_ERROR                               NotifiableEvent = "irs_disk_space_low_error"
	NOTIFIABLEEVENT_IRS_FAILURE                                            NotifiableEvent = "irs_failure"
	NOTIFIABLEEVENT_MAC_ADDRESS_IS_EXTERNAL                                NotifiableEvent = "mac_address_is_external"
	NOTIFIABLEEVENT_NETWORK_UPDATE_DISPLAY_FOR_CLUSTER_WITH_ACTIVE_VM      NotifiableEvent = "network_update_display_for_cluster_with_active_vm"
	NOTIFIABLEEVENT_NETWORK_UPDATE_DISPLAY_FOR_HOST_WITH_ACTIVE_VM         NotifiableEvent = "network_update_display_for_host_with_active_vm"
	NOTIFIABLEEVENT_NUMBER_OF_LVS_ON_STORAGE_DOMAIN_EXCEEDED_THRESHOLD     NotifiableEvent = "number_of_lvs_on_storage_domain_exceeded_threshold"
	NOTIFIABLEEVENT_REMOVE_GLUSTER_VOLUME_BRICKS_NOT_FOUND_FROM_CLI        NotifiableEvent = "remove_gluster_volume_bricks_not_found_from_cli"
	NOTIFIABLEEVENT_START_REMOVING_GLUSTER_VOLUME_BRICKS                   NotifiableEvent = "start_removing_gluster_volume_bricks"
	NOTIFIABLEEVENT_START_REMOVING_GLUSTER_VOLUME_BRICKS_DETECTED_FROM_CLI NotifiableEvent = "start_removing_gluster_volume_bricks_detected_from_cli"
	NOTIFIABLEEVENT_START_REMOVING_GLUSTER_VOLUME_BRICKS_FAILED            NotifiableEvent = "start_removing_gluster_volume_bricks_failed"
	NOTIFIABLEEVENT_SYSTEM_CHANGE_STORAGE_POOL_STATUS_NO_HOST_FOR_SPM      NotifiableEvent = "system_change_storage_pool_status_no_host_for_spm"
	NOTIFIABLEEVENT_SYSTEM_DEACTIVATED_STORAGE_DOMAIN                      NotifiableEvent = "system_deactivated_storage_domain"
	NOTIFIABLEEVENT_USER_ADD_VM_FROM_TRUSTED_TO_UNTRUSTED                  NotifiableEvent = "user_add_vm_from_trusted_to_untrusted"
	NOTIFIABLEEVENT_USER_ADD_VM_FROM_UNTRUSTED_TO_TRUSTED                  NotifiableEvent = "user_add_vm_from_untrusted_to_trusted"
	NOTIFIABLEEVENT_USER_ADD_VM_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED         NotifiableEvent = "user_add_vm_template_from_trusted_to_untrusted"
	NOTIFIABLEEVENT_USER_ADD_VM_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED         NotifiableEvent = "user_add_vm_template_from_untrusted_to_trusted"
	NOTIFIABLEEVENT_USER_HOST_MAINTENANCE                                  NotifiableEvent = "user_host_maintenance"
	NOTIFIABLEEVENT_USER_HOST_MAINTENANCE_MANUAL_HA                        NotifiableEvent = "user_host_maintenance_manual_ha"
	NOTIFIABLEEVENT_USER_HOST_MAINTENANCE_MIGRATION_FAILED                 NotifiableEvent = "user_host_maintenance_migration_failed"
	NOTIFIABLEEVENT_USER_UPDATE_VM_FROM_TRUSTED_TO_UNTRUSTED               NotifiableEvent = "user_update_vm_from_trusted_to_untrusted"
	NOTIFIABLEEVENT_USER_UPDATE_VM_FROM_UNTRUSTED_TO_TRUSTED               NotifiableEvent = "user_update_vm_from_untrusted_to_trusted"
	NOTIFIABLEEVENT_USER_UPDATE_VM_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED      NotifiableEvent = "user_update_vm_template_from_trusted_to_untrusted"
	NOTIFIABLEEVENT_USER_UPDATE_VM_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED      NotifiableEvent = "user_update_vm_template_from_untrusted_to_trusted"
	NOTIFIABLEEVENT_VM_CONSOLE_CONNECTED                                   NotifiableEvent = "vm_console_connected"
	NOTIFIABLEEVENT_VM_CONSOLE_DISCONNECTED                                NotifiableEvent = "vm_console_disconnected"
	NOTIFIABLEEVENT_VM_DOWN_ERROR                                          NotifiableEvent = "vm_down_error"
	NOTIFIABLEEVENT_VM_FAILURE                                             NotifiableEvent = "vm_failure"
	NOTIFIABLEEVENT_VM_MIGRATION_FAILED                                    NotifiableEvent = "vm_migration_failed"
	NOTIFIABLEEVENT_VM_MIGRATION_START                                     NotifiableEvent = "vm_migration_start"
	NOTIFIABLEEVENT_VM_MIGRATION_TO_SERVER_FAILED                          NotifiableEvent = "vm_migration_to_server_failed"
	NOTIFIABLEEVENT_VM_NOT_RESPONDING                                      NotifiableEvent = "vm_not_responding"
	NOTIFIABLEEVENT_VM_PAUSED                                              NotifiableEvent = "vm_paused"
	NOTIFIABLEEVENT_VM_PAUSED_EIO                                          NotifiableEvent = "vm_paused_eio"
	NOTIFIABLEEVENT_VM_PAUSED_ENOSPC                                       NotifiableEvent = "vm_paused_enospc"
	NOTIFIABLEEVENT_VM_PAUSED_EPERM                                        NotifiableEvent = "vm_paused_eperm"
	NOTIFIABLEEVENT_VM_PAUSED_ERROR                                        NotifiableEvent = "vm_paused_error"
	NOTIFIABLEEVENT_VM_RECOVERED_FROM_PAUSE_ERROR                          NotifiableEvent = "vm_recovered_from_pause_error"
	NOTIFIABLEEVENT_VM_SET_TICKET                                          NotifiableEvent = "vm_set_ticket"
	NOTIFIABLEEVENT_VM_STATUS_RESTORED                                     NotifiableEvent = "vm_status_restored"
)

type NotificationMethod string

const (
	NOTIFICATIONMETHOD_SMTP NotificationMethod = "smtp"
	NOTIFICATIONMETHOD_SNMP NotificationMethod = "snmp"
)

type NumaTuneMode string

const (
	NUMATUNEMODE_INTERLEAVE NumaTuneMode = "interleave"
	NUMATUNEMODE_PREFERRED  NumaTuneMode = "preferred"
	NUMATUNEMODE_STRICT     NumaTuneMode = "strict"
)

type OpenStackNetworkProviderType string

const (
	OPENSTACKNETWORKPROVIDERTYPE_EXTERNAL OpenStackNetworkProviderType = "external"
	OPENSTACKNETWORKPROVIDERTYPE_NEUTRON  OpenStackNetworkProviderType = "neutron"
)

type OpenstackVolumeAuthenticationKeyUsageType string

const (
	OPENSTACKVOLUMEAUTHENTICATIONKEYUSAGETYPE_CEPH OpenstackVolumeAuthenticationKeyUsageType = "ceph"
)

type OsType string

const (
	OSTYPE_OTHER             OsType = "other"
	OSTYPE_OTHER_LINUX       OsType = "other_linux"
	OSTYPE_RHEL_3            OsType = "rhel_3"
	OSTYPE_RHEL_3X64         OsType = "rhel_3x64"
	OSTYPE_RHEL_4            OsType = "rhel_4"
	OSTYPE_RHEL_4X64         OsType = "rhel_4x64"
	OSTYPE_RHEL_5            OsType = "rhel_5"
	OSTYPE_RHEL_5X64         OsType = "rhel_5x64"
	OSTYPE_RHEL_6            OsType = "rhel_6"
	OSTYPE_RHEL_6X64         OsType = "rhel_6x64"
	OSTYPE_UNASSIGNED        OsType = "unassigned"
	OSTYPE_WINDOWS_2003      OsType = "windows_2003"
	OSTYPE_WINDOWS_2003X64   OsType = "windows_2003x64"
	OSTYPE_WINDOWS_2008      OsType = "windows_2008"
	OSTYPE_WINDOWS_2008R2X64 OsType = "windows_2008r2x64"
	OSTYPE_WINDOWS_2008X64   OsType = "windows_2008x64"
	OSTYPE_WINDOWS_2012X64   OsType = "windows_2012x64"
	OSTYPE_WINDOWS_7         OsType = "windows_7"
	OSTYPE_WINDOWS_7X64      OsType = "windows_7x64"
	OSTYPE_WINDOWS_8         OsType = "windows_8"
	OSTYPE_WINDOWS_8X64      OsType = "windows_8x64"
	OSTYPE_WINDOWS_XP        OsType = "windows_xp"
)

type PayloadEncoding string

const (
	PAYLOADENCODING_BASE64    PayloadEncoding = "base64"
	PAYLOADENCODING_PLAINTEXT PayloadEncoding = "plaintext"
)

type PmProxyType string

const (
	PMPROXYTYPE_CLUSTER  PmProxyType = "cluster"
	PMPROXYTYPE_DC       PmProxyType = "dc"
	PMPROXYTYPE_OTHER_DC PmProxyType = "other_dc"
)

type PolicyUnitType string

const (
	POLICYUNITTYPE_FILTER         PolicyUnitType = "filter"
	POLICYUNITTYPE_LOAD_BALANCING PolicyUnitType = "load_balancing"
	POLICYUNITTYPE_WEIGHT         PolicyUnitType = "weight"
)

type PowerManagementStatus string

const (
	POWERMANAGEMENTSTATUS_OFF     PowerManagementStatus = "off"
	POWERMANAGEMENTSTATUS_ON      PowerManagementStatus = "on"
	POWERMANAGEMENTSTATUS_UNKNOWN PowerManagementStatus = "unknown"
)

type QcowVersion string

const (
	QCOWVERSION_QCOW2_V2 QcowVersion = "qcow2_v2"
	QCOWVERSION_QCOW2_V3 QcowVersion = "qcow2_v3"
)

type QosType string

const (
	QOSTYPE_CPU         QosType = "cpu"
	QOSTYPE_HOSTNETWORK QosType = "hostnetwork"
	QOSTYPE_NETWORK     QosType = "network"
	QOSTYPE_STORAGE     QosType = "storage"
)

type QuotaModeType string

const (
	QUOTAMODETYPE_AUDIT    QuotaModeType = "audit"
	QUOTAMODETYPE_DISABLED QuotaModeType = "disabled"
	QUOTAMODETYPE_ENABLED  QuotaModeType = "enabled"
)

type ReportedDeviceType string

const (
	REPORTEDDEVICETYPE_NETWORK ReportedDeviceType = "network"
)

type ResolutionType string

const (
	RESOLUTIONTYPE_ADD  ResolutionType = "add"
	RESOLUTIONTYPE_COPY ResolutionType = "copy"
)

type RngSource string

const (
	RNGSOURCE_HWRNG   RngSource = "hwrng"
	RNGSOURCE_RANDOM  RngSource = "random"
	RNGSOURCE_URANDOM RngSource = "urandom"
)

type RoleType string

const (
	ROLETYPE_ADMIN RoleType = "admin"
	ROLETYPE_USER  RoleType = "user"
)

type ScsiGenericIO string

const (
	SCSIGENERICIO_DISABLED   ScsiGenericIO = "disabled"
	SCSIGENERICIO_FILTERED   ScsiGenericIO = "filtered"
	SCSIGENERICIO_UNFILTERED ScsiGenericIO = "unfiltered"
)

type SeLinuxMode string

const (
	SELINUXMODE_DISABLED   SeLinuxMode = "disabled"
	SELINUXMODE_ENFORCING  SeLinuxMode = "enforcing"
	SELINUXMODE_PERMISSIVE SeLinuxMode = "permissive"
)

type SerialNumberPolicy string

const (
	SERIALNUMBERPOLICY_CUSTOM SerialNumberPolicy = "custom"
	SERIALNUMBERPOLICY_HOST   SerialNumberPolicy = "host"
	SERIALNUMBERPOLICY_NONE   SerialNumberPolicy = "none"
	SERIALNUMBERPOLICY_VM     SerialNumberPolicy = "vm"
)

type SnapshotStatus string

const (
	SNAPSHOTSTATUS_IN_PREVIEW SnapshotStatus = "in_preview"
	SNAPSHOTSTATUS_LOCKED     SnapshotStatus = "locked"
	SNAPSHOTSTATUS_OK         SnapshotStatus = "ok"
)

type SnapshotType string

const (
	SNAPSHOTTYPE_ACTIVE    SnapshotType = "active"
	SNAPSHOTTYPE_PREVIEW   SnapshotType = "preview"
	SNAPSHOTTYPE_REGULAR   SnapshotType = "regular"
	SNAPSHOTTYPE_STATELESS SnapshotType = "stateless"
)

type SpmStatus string

const (
	SPMSTATUS_CONTENDING SpmStatus = "contending"
	SPMSTATUS_NONE       SpmStatus = "none"
	SPMSTATUS_SPM        SpmStatus = "spm"
)

type SshAuthenticationMethod string

const (
	SSHAUTHENTICATIONMETHOD_PASSWORD  SshAuthenticationMethod = "password"
	SSHAUTHENTICATIONMETHOD_PUBLICKEY SshAuthenticationMethod = "publickey"
)

type SsoMethod string

const (
	SSOMETHOD_GUEST_AGENT SsoMethod = "guest_agent"
)

type StatisticKind string

const (
	STATISTICKIND_COUNTER StatisticKind = "counter"
	STATISTICKIND_GAUGE   StatisticKind = "gauge"
)

type StatisticUnit string

const (
	STATISTICUNIT_BITS_PER_SECOND  StatisticUnit = "bits_per_second"
	STATISTICUNIT_BYTES            StatisticUnit = "bytes"
	STATISTICUNIT_BYTES_PER_SECOND StatisticUnit = "bytes_per_second"
	STATISTICUNIT_COUNT_PER_SECOND StatisticUnit = "count_per_second"
	STATISTICUNIT_NONE             StatisticUnit = "none"
	STATISTICUNIT_PERCENT          StatisticUnit = "percent"
	STATISTICUNIT_SECONDS          StatisticUnit = "seconds"
)

type StepEnum string

const (
	STEPENUM_EXECUTING          StepEnum = "executing"
	STEPENUM_FINALIZING         StepEnum = "finalizing"
	STEPENUM_REBALANCING_VOLUME StepEnum = "rebalancing_volume"
	STEPENUM_REMOVING_BRICKS    StepEnum = "removing_bricks"
	STEPENUM_UNKNOWN            StepEnum = "unknown"
	STEPENUM_VALIDATING         StepEnum = "validating"
)

type StepStatus string

const (
	STEPSTATUS_ABORTED  StepStatus = "aborted"
	STEPSTATUS_FAILED   StepStatus = "failed"
	STEPSTATUS_FINISHED StepStatus = "finished"
	STEPSTATUS_STARTED  StepStatus = "started"
	STEPSTATUS_UNKNOWN  StepStatus = "unknown"
)

type StorageDomainStatus string

const (
	STORAGEDOMAINSTATUS_ACTIVATING                StorageDomainStatus = "activating"
	STORAGEDOMAINSTATUS_ACTIVE                    StorageDomainStatus = "active"
	STORAGEDOMAINSTATUS_DETACHING                 StorageDomainStatus = "detaching"
	STORAGEDOMAINSTATUS_INACTIVE                  StorageDomainStatus = "inactive"
	STORAGEDOMAINSTATUS_LOCKED                    StorageDomainStatus = "locked"
	STORAGEDOMAINSTATUS_MAINTENANCE               StorageDomainStatus = "maintenance"
	STORAGEDOMAINSTATUS_MIXED                     StorageDomainStatus = "mixed"
	STORAGEDOMAINSTATUS_PREPARING_FOR_MAINTENANCE StorageDomainStatus = "preparing_for_maintenance"
	STORAGEDOMAINSTATUS_UNATTACHED                StorageDomainStatus = "unattached"
	STORAGEDOMAINSTATUS_UNKNOWN                   StorageDomainStatus = "unknown"
)

type StorageDomainType string

const (
	STORAGEDOMAINTYPE_DATA                  StorageDomainType = "data"
	STORAGEDOMAINTYPE_EXPORT                StorageDomainType = "export"
	STORAGEDOMAINTYPE_IMAGE                 StorageDomainType = "image"
	STORAGEDOMAINTYPE_ISO                   StorageDomainType = "iso"
	STORAGEDOMAINTYPE_MANAGED_BLOCK_STORAGE StorageDomainType = "managed_block_storage"
	STORAGEDOMAINTYPE_VOLUME                StorageDomainType = "volume"
)

type StorageFormat string

const (
	STORAGEFORMAT_V1 StorageFormat = "v1"
	STORAGEFORMAT_V2 StorageFormat = "v2"
	STORAGEFORMAT_V3 StorageFormat = "v3"
	STORAGEFORMAT_V4 StorageFormat = "v4"
	STORAGEFORMAT_V5 StorageFormat = "v5"
)

type StorageType string

const (
	STORAGETYPE_CINDER                StorageType = "cinder"
	STORAGETYPE_FCP                   StorageType = "fcp"
	STORAGETYPE_GLANCE                StorageType = "glance"
	STORAGETYPE_GLUSTERFS             StorageType = "glusterfs"
	STORAGETYPE_ISCSI                 StorageType = "iscsi"
	STORAGETYPE_LOCALFS               StorageType = "localfs"
	STORAGETYPE_MANAGED_BLOCK_STORAGE StorageType = "managed_block_storage"
	STORAGETYPE_NFS                   StorageType = "nfs"
	STORAGETYPE_POSIXFS               StorageType = "posixfs"
)

type SwitchType string

const (
	SWITCHTYPE_LEGACY SwitchType = "legacy"
	SWITCHTYPE_OVS    SwitchType = "ovs"
)

type TemplateStatus string

const (
	TEMPLATESTATUS_ILLEGAL TemplateStatus = "illegal"
	TEMPLATESTATUS_LOCKED  TemplateStatus = "locked"
	TEMPLATESTATUS_OK      TemplateStatus = "ok"
)

type TransportType string

const (
	TRANSPORTTYPE_RDMA TransportType = "rdma"
	TRANSPORTTYPE_TCP  TransportType = "tcp"
)

type UsbType string

const (
	USBTYPE_LEGACY UsbType = "legacy"
	USBTYPE_NATIVE UsbType = "native"
)

type ValueType string

const (
	VALUETYPE_DECIMAL ValueType = "decimal"
	VALUETYPE_INTEGER ValueType = "integer"
	VALUETYPE_STRING  ValueType = "string"
)

type VgpuPlacement string

const (
	VGPUPLACEMENT_CONSOLIDATED VgpuPlacement = "consolidated"
	VGPUPLACEMENT_SEPARATED    VgpuPlacement = "separated"
)

type VmAffinity string

const (
	VMAFFINITY_MIGRATABLE      VmAffinity = "migratable"
	VMAFFINITY_PINNED          VmAffinity = "pinned"
	VMAFFINITY_USER_MIGRATABLE VmAffinity = "user_migratable"
)

type VmDeviceType string

const (
	VMDEVICETYPE_CDROM  VmDeviceType = "cdrom"
	VMDEVICETYPE_FLOPPY VmDeviceType = "floppy"
)

type VmPoolType string

const (
	VMPOOLTYPE_AUTOMATIC VmPoolType = "automatic"
	VMPOOLTYPE_MANUAL    VmPoolType = "manual"
)

type VmStatus string

const (
	VMSTATUS_DOWN               VmStatus = "down"
	VMSTATUS_IMAGE_LOCKED       VmStatus = "image_locked"
	VMSTATUS_MIGRATING          VmStatus = "migrating"
	VMSTATUS_NOT_RESPONDING     VmStatus = "not_responding"
	VMSTATUS_PAUSED             VmStatus = "paused"
	VMSTATUS_POWERING_DOWN      VmStatus = "powering_down"
	VMSTATUS_POWERING_UP        VmStatus = "powering_up"
	VMSTATUS_REBOOT_IN_PROGRESS VmStatus = "reboot_in_progress"
	VMSTATUS_RESTORING_STATE    VmStatus = "restoring_state"
	VMSTATUS_SAVING_STATE       VmStatus = "saving_state"
	VMSTATUS_SUSPENDED          VmStatus = "suspended"
	VMSTATUS_UNASSIGNED         VmStatus = "unassigned"
	VMSTATUS_UNKNOWN            VmStatus = "unknown"
	VMSTATUS_UP                 VmStatus = "up"
	VMSTATUS_WAIT_FOR_LAUNCH    VmStatus = "wait_for_launch"
)

type VmStorageErrorResumeBehaviour string

const (
	VMSTORAGEERRORRESUMEBEHAVIOUR_AUTO_RESUME  VmStorageErrorResumeBehaviour = "auto_resume"
	VMSTORAGEERRORRESUMEBEHAVIOUR_KILL         VmStorageErrorResumeBehaviour = "kill"
	VMSTORAGEERRORRESUMEBEHAVIOUR_LEAVE_PAUSED VmStorageErrorResumeBehaviour = "leave_paused"
)

type VmType string

const (
	VMTYPE_DESKTOP          VmType = "desktop"
	VMTYPE_HIGH_PERFORMANCE VmType = "high_performance"
	VMTYPE_SERVER           VmType = "server"
)

type VnicPassThroughMode string

const (
	VNICPASSTHROUGHMODE_DISABLED VnicPassThroughMode = "disabled"
	VNICPASSTHROUGHMODE_ENABLED  VnicPassThroughMode = "enabled"
)

type WatchdogAction string

const (
	WATCHDOGACTION_DUMP     WatchdogAction = "dump"
	WATCHDOGACTION_NONE     WatchdogAction = "none"
	WATCHDOGACTION_PAUSE    WatchdogAction = "pause"
	WATCHDOGACTION_POWEROFF WatchdogAction = "poweroff"
	WATCHDOGACTION_RESET    WatchdogAction = "reset"
)

type WatchdogModel string

const (
	WATCHDOGMODEL_DIAG288  WatchdogModel = "diag288"
	WATCHDOGMODEL_I6300ESB WatchdogModel = "i6300esb"
)
